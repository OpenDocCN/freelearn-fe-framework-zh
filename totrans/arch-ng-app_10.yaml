- en: NgRx – In Depth
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgRx – 深入了解
- en: This chapter will go into more advanced NgRx topics. As you implement your first
    applications using NgRx, you will notice that it means creating a lot of boilerplate
    and you may not feel as fast as when you were NOT using NgRx. For that reason,
    the entity library exists to help alleviate some of the boilerplate creation—more
    on that later in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将深入探讨更高级的NgRx主题。当您使用NgRx实现第一个应用程序时，您会注意到这意味着创建大量的样板代码，您可能不会感觉像不使用NgRx时那样快。因此，实体库存在是为了帮助减轻一些样板代码的创建——关于这一点，本章后面会详细介绍。
- en: The router and its state is another thing that can be interesting to keep track
    of. The URL of where you are currently, the router parameter, as well as query
    parameters are all interesting pieces of information that might come in handy.
    They might come in handy should you be in a situation where you might want to
    reinstate the app, also called **rehydration**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 路由及其状态是另一个可能值得跟踪的东西。您当前所在的URL、路由参数以及查询参数都是可能很有用的信息。如果您处于可能需要重新启动应用程序的情况，这些信息可能很有用，也称为**恢复**。
- en: Next, we will dive into how to build your own micro implementation of NgRx using
    RxJS, so you get a feel for what's going on. Hopefully, that will be a real eye-opening
    moment in understanding the underlying ideas of what makes NgRx and Redux tick.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入了解如何使用RxJS构建您自己的NgRx微实现，这样您就可以了解正在发生的事情。希望这将是一个真正令人耳目一新的时刻，有助于理解使NgRx和Redux运转的底层理念。
- en: To round off this chapter and this book, we will explain what schematics is
    and how it will help you quickly scaffold the various parts that you need to be
    a really efficient user of NgRx.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束本章和本书，我们将解释什么是schematics以及它将如何帮助您快速搭建您需要的各个部分，从而成为NgRx的真正高效用户。
- en: 'In this chapter, you will learn how to:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何：
- en: Leverage the entity library and how it makes our life easier using NgRx
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用实体库以及它如何使我们的生活更轻松使用NgRx
- en: Capture the router state as well as customize what gets saved down by writing
    our own customization code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过编写我们自己的定制代码来捕获路由状态以及自定义要保存的内容
- en: Build a micro implementation of NgRx
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建NgRx的微实现
- en: Demystify schematics and see how it can make us an even faster and more efficient
    user of NgRx
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 揭示schematics的神秘面纱，看看它如何使我们成为更快、更高效的NgRx用户。
- en: '@ngrx/entity'
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@ngrx/entity'
- en: The demo code for this section can be found in the code repository for this
    book under `Chapter10/Entity`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的示例代码可以在本书的代码仓库中的`Chapter10/Entity`下找到。
- en: The entity library is here to help us manage collections and basically, write
    less and do more. This means that so far we have been writing a lot of code when
    creating reducers and selectors that we simply won't need to do when we leverage
    the full power of the entity library.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 实体库在这里帮助我们管理集合，基本上，这意味着到目前为止，我们在创建reducer和selectors时编写了大量的代码，当我们利用实体库的全部功能时，我们根本不需要做这些。
- en: Setting it up
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置它
- en: 'We start by downloading the entity library. To do this, we need to run the
    following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先下载实体库。为此，我们需要运行以下命令：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We then need to perform the following steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要执行以下步骤：
- en: Create a model.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个模型。
- en: Create an entity state based on the model.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据模型创建一个实体状态。
- en: Create an entity adapter.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个实体适配器。
- en: Create the initial state.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建初始状态。
- en: Create the reducer and set up the state in the `StoreModule.`
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建reducer并在`StoreModule`中设置状态。
- en: 'Let''s start off by creating our model:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建我们的模型开始：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code is just a simple model with fields `id` and `name`. We then
    create our entity state, like so:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码只是一个具有`id`和`name`字段的简单模型。然后我们创建我们的实体状态，如下所示：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will be the return type our reducer needs to abide by. Type `EntityState`
    looks like the following, if you peek into the NgRx source code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们的reducer需要遵守的返回类型。类型`EntityState`看起来如下，如果您查看NgRx源代码的话：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By extending the preceding interface `EntityState,` when we create type `State`
    we will also get the properties `ids` and `entities`. We will see later in this
    section how these properties are populated, once we start using the utility methods
    the entity library gives us.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展前面的接口`EntityState`，当我们创建类型`State`时，我们也将获得`ids`和`entities`属性。我们将在本节稍后看到这些属性是如何被填充的，一旦我们开始使用实体库提供的实用方法。
- en: 'The next step is to create our adapter. An instance of the adapter sits on
    a range of methods, allowing us to write a great deal less code. We create the
    adapter with the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建我们的适配器。适配器实例提供了一系列方法，使我们能够编写更少的代码。我们用以下代码创建适配器：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At this point, we are almost ready; we just need to get the initial state from
    the adapter and provide that to our reducer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们几乎准备好了；我们只需要从适配器获取初始状态并将其提供给我们的reducer。
- en: 'To get the initial state, we need to talk to our adapter, like so:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取初始状态，我们需要与我们的适配器交谈，如下所示：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What's happening here is that we need to create an object representing the initial
    state. It needs to be of type `State` and therefore it needs to have the properties
    `ids`, `entities`, and `selectedUserId` defined. Then, we call `getInitialState()`
    on the adapter to produce our initial state. So, what do we need the initial state
    for? We'll need to set it as the default value of our reducer's state.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情是我们需要创建一个表示初始状态的对象。它需要是`State`类型，因此它需要定义`ids`、`entities`和`selectedUserId`属性。然后，我们在适配器上调用`getInitialState()`来生成我们的初始状态。那么，我们需要初始状态做什么呢？我们需要将其设置为reducer状态的默认值。
- en: 'Next, we create our reducer and set its default state to our initial state
    instance, created previously:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的reducer并将其默认状态设置为之前创建的初始状态实例：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note here how we call our `userAdapter` and invoke the method `addOne()`; this
    means that we don''t have to write code that looks like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里我们是如何调用我们的`userAdapter`并调用`addOne()`方法的；这意味着我们不需要编写像这样的代码：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The last step to setting everything up is to add the state to the `StoreModule`
    so that NgRx knows about it:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一切的最后一步是将状态添加到`StoreModule`中，这样NgRx就会知道它：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That concludes the required setup. The next steps we want to take in the following
    sections are how to display the data in a component, and also how to perform a
    full CRUD and thereby leveraging more of what the `EntityAdapter` has to offer.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了所需的设置。在接下来的几节中，我们想要采取的下一步是展示如何在组件中显示数据，以及如何执行完整的CRUD操作，从而充分利用`EntityAdapter`的功能。
- en: Selecting our data
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择我们的数据
- en: 'We have learnt by now that to select data in NgRx, we need to inject the store
    service and call `select` on it, either with a string as an argument or with a
    function. Let''s inject the store service and have a look at the state that comes
    back:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们已经了解到，在NgRx中选择数据，我们需要注入store服务并调用它的`select`方法，要么传递一个字符串作为参数，要么传递一个函数。让我们注入store服务并查看返回的状态：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding component won''t display the users in a neat list just yet; we
    will explain why later. In the meantime, we will just focus on what is logged
    to the console:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的组件还不会以整洁的列表形式显示用户；我们稍后会解释原因。同时，我们将专注于控制台上的日志输出：
- en: '![](img/ecf91d61-2e05-4d72-ac6e-2a5a54a1ae44.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ecf91d61-2e05-4d72-ac6e-2a5a54a1ae44.png)'
- en: 'What we see here is the state of our store, which contains a user''s property
    at the highest level, it has `entities`, `ids` and `selectedUserId` as properties.
    This is to be expected so far. What does surprise us a little is the fact that
    the entities dictionary is an object and not a list. How do we output that in
    a list form using `*ngFor`? Well, we can easily solve that with a `map()` operator,
    like so:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的是我们商店的状态，它包含用户属性的最高级别，它有`entities`、`ids`和`selectedUserId`作为属性。到目前为止这是可以预料的。但让我们有点惊讶的是，实体字典是一个对象而不是一个列表。我们如何使用`*ngFor`以列表形式输出它呢？嗯，我们可以很容易地用`map()`操作符解决这个问题，如下所示：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: OK, so now we drill down to `state.users.entities` to get to our users but we
    need to add the `map()` operation to turn our entities dictionary into a list.
    So, the console now shows us an empty array as the initial value of `users$`,
    which makes perfect sense. The UI is still empty, as we have an empty array and
    therefore nothing to show. In the following section, we will cover how to add,
    remove, and update the state using the `EntityAdapter`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们深入到`state.users.entities`以获取我们的用户，但我们需要添加`map()`操作来将我们的实体字典转换为列表。所以，控制台现在显示`users$`的初始值为一个空数组，这是完全合理的。UI仍然是空的，因为我们有一个空数组，因此没有东西可以显示。在下一节中，我们将介绍如何使用`EntityAdapter`添加、删除和更新状态。
- en: Adding the full CRUD
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加完整的CRUD
- en: 'What we mean by CRUD is the ability to add, edit, read, and delete the data
    from the store. The point of using the entity library is for it to do most of
    the heavy lifting. The time has come to revisit our reducer:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的CRUD是指从存储中添加、编辑、读取和删除数据的能力。使用实体库的目的就是让它做大部分繁重的工作。现在是时候回顾我们的reducer了：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we are using the `userAdapter` instance to carry out adding one item
    to the store. There is a lot more the adapter can do for us though—here is a full
    list of its capabilities:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`userAdapter`实例来执行向存储中添加一个项目的操作。尽管适配器还能为我们做更多的事情——以下是其全部功能列表：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Creating users
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户
- en: 'As we can see, `EntityStateAdapter` has methods for the full CRUD. Let''s look
    at adding the capability to add a user to our component. We need to make the following
    additions to our component:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`EntityStateAdapter`提供了完整的CRUD方法。让我们看看如何为我们的组件添加添加用户的能力。我们需要对我们的组件做以下添加：
- en: Add an input field
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个输入字段
- en: Dispatch an `ADD_USER` action with our new user as payload
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们的新用户作为有效负载派发`ADD_USER`动作
- en: 'The required code changes are in bold, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 必要的代码更改以粗体显示，如下所示：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This code demonstrates how we add an input element and connect that to the
    field `user` on our class through `ngModel`. We also added the `add()` method
    that dispatches a user to our reducer. Adding a user should now look like the
    following in the UI:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码演示了如何添加一个输入元素并将其通过`ngModel`连接到我们的类中的`user`字段。我们还添加了`add()`方法，该方法将用户派发到我们的reducer。现在在UI中添加用户应该看起来如下所示：
- en: '![](img/26348501-a729-444c-a0da-2bac9b6bcf29.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26348501-a729-444c-a0da-2bac9b6bcf29.png)'
- en: Updating users
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新用户
- en: 'There are two things we need to do to support updating users:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持更新用户，我们需要做两件事：
- en: Add a component that supports updating
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个支持更新的组件
- en: Adding a CASE to our reducer that listens to an action and calls the appropriate
    `adapter` method
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的reducer中添加一个CASE来监听动作并调用适当的`adapter`方法
- en: 'Let''s start with our component:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的组件开始：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we have a component that takes a `user` as input and is able to invoke
    a `save` as output thereby calling the parent component. In short, this component
    allows us to edit a user.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个组件，它接受一个`user`作为输入，并能够通过输出`save`调用父组件。简而言之，这个组件允许我们编辑用户。
- en: 'Now we need to add this component to `app.module.ts` so that other components
    within this module can use it:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将此组件添加到`app.module.ts`中，以便本模块内的其他组件可以使用它：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we are ready to add the component to the parent components template, like
    so:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备将组件添加到父组件的模板中，如下所示：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This code shows us how we add the `EditUserComponent` to the markup, as well
    as us adding the `update()` method that, when invoked, dispatches the action `UPDATE_USER`.
    This will lead to our reducer being invoked which leads us to our final piece
    of the puzzle, the required changes we need to make to the reducer:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了我们如何将`EditUserComponent`添加到标记中，以及我们添加的`update()`方法，当调用该方法时，会触发`UPDATE_USER`动作。这将导致我们的reducer被调用，进而引导我们到达拼图的最后一部分，即我们需要对reducer所做的必要更改：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We now support the ability to update our users list.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在支持更新用户列表。
- en: Deleting users
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除用户
- en: 'The last piece of supporting CRUD is the ability to remove users from the list.
    This case is very similar to all the other cases:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 支持CRUD的最后一部分是能够从列表中删除用户。这种情况与其他所有情况非常相似：
- en: We need to add support for it to `app.component.ts`
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要将其添加到`app.component.ts`中
- en: We need to update the reducer, and the reducer needs to call the appropriate
    adapter method
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要更新reducer，并且reducer需要调用适当的适配器方法
- en: 'Let''s start with the component and add support in the markup, as well as adding
    a `remove()` method to the component class, like so:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从组件开始，并在标记中添加支持，以及添加一个`remove()`方法到组件类中，如下所示：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The remaining part is updating our reducer to say the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的部分是更新我们的reducer，使其如下所示：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '@ngrx/router-store'
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@ngrx/router-store'
- en: We want to be able to trace where we are in the application—*where—*is represented
    by our route, route parameters, as well as by query parameters. By saving where
    we are, down to our store, we are able to easily serialize the stores information
    to a storage for later retrieval and deserialization, which means we can re-instate
    the app with not only the state, but also our page location.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够追踪我们在应用程序中的位置——*位置*由我们的路由、路由参数以及查询参数表示。通过将我们的位置保存到我们的store中，我们能够轻松地将store的信息序列化到存储中，以便稍后检索和反序列化，这意味着我们可以不仅恢复应用程序的状态，还可以恢复我们的页面位置。
- en: Installation and set up
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和设置
- en: 'The router store is in an NPM package and we can therefore type the following
    to install it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 路由存储在一个NPM包中，因此我们可以使用以下命令来安装它：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next thing we need to do is to import the correct modules and set those
    up in the `import` properties of our root module, like so:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，我们需要导入正确的模块，并在根模块的`import`属性中设置它们，如下所示：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We don't do a lot here. We call the `forRoot()` method on the `StoreRouterConnectingModule,`
    and we also add a new reducer entry in the form of a router that points to `routerReducer`
    as the reducer that will handle any changes to the `router` property.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里没有做太多。我们调用 `StoreRouterConnectingModule` 上的 `forRoot()` 方法，并且我们还添加了一个新的路由形式的reducer条目，指向
    `routerReducer` 作为将处理 `router` 属性任何变化的reducer。
- en: Investigating the router state
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调查路由状态
- en: 'We have just set up the router store. This means that we automatically write
    to a property `router` in our store every time we navigate. We can prove this
    is the case by editing the `app.component.ts` to subscribe to that slice of state:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚设置了路由存储。这意味着每次我们导航时，我们都会自动将 `router` 属性写入我们的存储。我们可以通过编辑 `app.component.ts`
    来订阅这个状态片段来证明这一点：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we subscribe to the state router and thereby listen to every time the
    route changes. We log the said object and it looks like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们订阅了状态路由器，因此每次路由变化时都会监听到。我们记录了所说的对象，它看起来是这样的：
- en: '![](img/6151db2f-b7b4-45af-bd21-0a905f2781a4.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6151db2f-b7b4-45af-bd21-0a905f2781a4.png)'
- en: This screenshot shows us the object our router state now contains. We can see
    the `url` property points to `/` which means our default route has been loaded.
    We can also see that this object contains router parameters and query parameters
    in the `root` property. So, there is some interesting information in there.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这张截图显示了我们的路由状态现在包含的对象。我们可以看到 `url` 属性指向 `/`，这意味着我们的默认路由已经被加载。我们还可以看到这个对象在 `root`
    属性中包含了路由参数和查询参数。所以，这里有一些有趣的信息。
- en: 'Let''s see what happens when we route somewhere like `/testing`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们路由到像 `/testing` 这样的地方时会发生什么：
- en: '![](img/ba557ce4-7997-478e-9e72-a55d3c850f25.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ba557ce4-7997-478e-9e72-a55d3c850f25.png)'
- en: Our router state has been updated and we can see that our `url` property points
    to `/testing`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的路由状态已经更新，我们可以看到我们的 `url` 属性指向 `/testing`。
- en: 'So far, we have subscribed to the router state and listened to when the route
    is changing. There is a second way. We could be listening to when a specific action
    is being dispatched. The action being dispatched for routing is the string `ROUTER_NAVIGATION`.
    We can therefore easily build an effect for this so we can carry out side effects
    when the route changes. We may want to carry out AJAX requests or store things
    in a local cache. Only you know what you want to do. Let''s build that effect.
    We will return back to an existing file, `routing.effects.ts`, and extend it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经订阅了路由状态，并监听了路由变化时的情况。还有第二种方式。我们可以监听特定动作的派发。用于路由的派发动作是字符串 `ROUTER_NAVIGATION`。因此，我们可以轻松地构建一个效果，以便在路由变化时执行副作用。我们可能想要执行
    AJAX 请求或存储本地缓存中的内容。只有你知道你想要做什么。让我们构建这个效果。我们将返回到现有的文件 `routing.effects.ts` 并扩展它：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Custom serialization
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义序列化
- en: 'The object being stored is a bit verbose though. It contains a lot of information
    and we may only be interested in parts of it. We can actually solve that by building
    our own custom serializer. We need to do the following to accomplish that:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 被存储的对象有点冗长。它包含了很多信息，而我们可能只对其中的一部分感兴趣。实际上，我们可以通过构建自己的自定义序列化器来解决这个问题。为了实现这一点，我们需要做以下几步：
- en: Create a class that implements the interface `RouterStateSerializer` and decide
    what we want to return
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个实现接口 `RouterStateSerializer` 的类，并决定我们想要返回什么
- en: Replace the router key `RouterStateSerializer` with our custom implementation
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将路由键 `RouterStateSerializer` 替换为我们的自定义实现
- en: 'Let''s begin. We first create a class, like so:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。我们首先创建一个类，如下所示：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `RouterStateSeralizer` interface forces us to specify a `type T`, which
    could be anything. `T` is what we want to return from the routing object. Remember
    the reason for doing what we are doing is to grab a subset of interesting information
    from the routing object. The full routing information is contained within our
    input parameter `routerState` that is of type `RouterStateSnapshot`. A comment
    though is that `MyState` is a bit anemic, as it only contains a single property,
    `url`. You can of course extend this according to the needs of your application.
    You most likely want to grab the `router` and `query` parameters. We will grab
    those as well before we are done with this section but let''s start with this
    to showcase how it works. The next step is to grab the data from the `routerState`
    parameter. For now, we dig out the `url`—let''s update the code to reflect that:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouterStateSeralizer`接口强制我们指定一个`type T`，它可以是任何东西。`T`是我们从路由对象中想要返回的内容。记住我们这样做的原因是为了从路由对象中获取有趣信息的一个子集。完整的路由信息包含在我们的输入参数`routerState`中，它是一个`RouterStateSnapshot`类型的对象。不过有一个评论是，`MyState`有点贫血，因为它只包含一个属性，`url`。当然，你可以根据你应用程序的需求来扩展它。你很可能想要获取`router`和`query`参数。我们将在本节完成之前获取这些参数，但让我们先展示它是如何工作的。下一步是从`routerState`参数中获取数据。现在，我们挖掘出`url`——让我们更新代码以反映这一点：'
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s now tell the provider to use our implementation instead. We need to
    go to the `app.module.ts` file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要告诉提供者使用我们的实现。我们需要进入`app.module.ts`文件：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have now imported the `MySerializer` class and the `RouterStateSeralizer`
    interface and we are replacing the provider key using the following line:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经导入了`MySerializer`类和`RouterStateSeralizer`接口，并且正在使用以下行替换提供者键：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now it''s time to take this for a spin. So, we fire up the app and see what
    happens if we navigate around in the app. Here is a quick reminder of what our
    app looks like right now:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候试一试了。所以，我们启动应用程序并看看在应用程序中导航会发生什么。这里有一个快速提醒，看看我们的应用程序现在是什么样子：
- en: '![](img/87df3b0a-3fc4-4f79-9a26-abe98e9ddcbf.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/87df3b0a-3fc4-4f79-9a26-abe98e9ddcbf.png)'
- en: 'Clicking either the Testing or Products link will take us to `/testing` or
    `/products,` respectively. Let''s do just that and see what that looks like. We
    have a look at the console and lo and, behold! Our router object is considerably
    smaller:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 点击测试或产品链接将分别带我们到`/testing`或`/products`。让我们这样做并看看它会是什么样子。我们查看控制台，哇！我们的路由对象小得多：
- en: '![](img/72311ccd-62ff-4d7c-95de-5a4b4748fa1a.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/72311ccd-62ff-4d7c-95de-5a4b4748fa1a.png)'
- en: 'Our object now contains pretty much only the `url` property. This is what gets
    stored down in the state of our application. If we want more things stored than
    that, then we can easily extend the `MySerializer` class—suggested additions are
    router and query parameters. Let''s make the following alterations to the `MySerializer`
    class:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的对象现在几乎只包含`url`属性。这是存储在我们应用程序状态中的内容。如果我们想存储比这更多的事情，我们可以很容易地扩展`MySerializer`类——建议的添加是路由和查询参数。让我们对`MySerializer`类做出以下更改：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Navigating to `http://localhost:4200/products?page=1` will now produce the
    following in the console:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`http://localhost:4200/products?page=1`现在将在控制台产生以下内容：
- en: '![](img/77337137-0f5a-4c76-88c0-c6d7ba03b73c.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/77337137-0f5a-4c76-88c0-c6d7ba03b73c.png)'
- en: 'The difference is now that we have a `queryParams` property, which points to
    an object with content `{ page: 1 }`. This is what we expected. Digging out the
    router parameters is equally easy. But for us to have router parameters that are
    populated in the first place, we need to have a route with a routing parameter.
    Instead of `/products,` we need something such as `products/:id`. Let''s start
    by adding that to our list of routes:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '现在的不同之处在于我们有一个`queryParams`属性，它指向一个包含内容`{ page: 1 }`的对象。这正是我们预期的。挖掘路由参数同样简单。但为了使我们一开始就有填充的路由参数，我们需要有一个带有路由参数的路由。我们不需要`/products`，而是需要像`products/:id`这样的东西。让我们首先将其添加到我们的路由列表中：'
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And we of course need to add a component. It does nothing special other than
    exist for our demo purposes. Remember the emphasis is on understanding the serialization
    process:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还需要添加一个组件。它除了用于我们的演示目的外没有做任何特别的事情。记住，重点是理解序列化过程：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'At this point, it''s time to return back to our browser and enter the `url`,
    `products/1?page=1`. Let''s have a look at the console now:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，是时候回到我们的浏览器中输入`url`，`products/1?page=1`了。现在让我们看看控制台：
- en: '![](img/69e1890f-dd94-4e31-839f-bf2507ed448c.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/69e1890f-dd94-4e31-839f-bf2507ed448c.png)'
- en: Here, we see how our `params` property has been added to our custom object.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到我们的`params`属性是如何添加到我们的自定义对象中的。
- en: Navigating through dispatch
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过分发进行导航
- en: Now that we have our router store properly set up, we can actually start thinking
    in terms of dispatching actions, even for routes. OK, what does that mean? Well,
    imagine we are thinking more and more in dispatching actions; it makes our world
    simpler. When you dispatch an action, an HTTP call happens, and, in dispatching
    an action, the application routes you where you want to go.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确设置了路由存储库，我们实际上可以开始考虑分发动作，甚至对于路由。好吧，那是什么意思呢？嗯，想象一下我们越来越多地考虑分发动作；这使我们的世界变得更简单。当你分发一个动作时，会发生
    HTTP 调用，并且在分发动作时，应用程序将你路由到你想要去的地方。
- en: 'This isn''t really a feature of the router store, but a way you can look at
    it. A way to implement this is by writing your own effect that responds to a route
    action, and, as a result, you call the router service and perform the navigation.
    Let''s summarize what we just said in a bullet list and carry out the resulting
    steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是路由存储库的真正功能，而是一种你可以看待它的方式。实现这一点的办法是编写自己的效果，以响应路由动作，然后，作为结果，你调用路由服务并执行导航。让我们用项目符号列表总结我们刚才说的内容，并执行相应的步骤：
- en: Set up some routing constants.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一些路由常量。
- en: Set up some routing actions.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一些路由动作。
- en: Write an effect that listens to routing actions and performs routing inside
    of the effect.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个效果，使其监听路由动作并在效果内部执行路由。
- en: 'Here is Step 1:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是第一步：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'OK, our next step is to define a set of action creators so we can set off a
    certain behavior when a specific action occurs:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们的下一步是定义一组动作创建器，这样我们就可以在特定动作发生时触发某种行为：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Our next step is our effect, which would now be able to respond to the preceding
    actions:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是我们的效果，它现在将能够响应前面的动作：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Understanding NgRx – building our own micro implementation
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 NgRx – 构建我们自己的微实现
- en: 'We have done this experiment once before in [Chapter 8](e29180be-1bdf-4fdb-805b-333607fd6e0d.xhtml),
    *Redux*. The point was to gain a deeper understanding of what goes on behind the
    scenes. The difference between implementing Redux and implementing NgRx is the
    use of a library for publish/ subscribe, which is the way you choose to convey
    to a listener that a change has occurred. In our Redux implementation in [Chapter
    8](e29180be-1bdf-4fdb-805b-333607fd6e0d.xhtml), *Redux*, we gave you the choice
    between implementing the Gang of Four publish-subscribe pattern without the help
    of a library, or using `EventEmitter` to achieve the same thing. In NgRx, that
    component is RxJS. So, let''s crack on with the implementation. Before doing so,
    let''s describe what we aim to implement:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在[第8章](e29180be-1bdf-4fdb-805b-333607fd6e0d.xhtml)，*Redux*中做过这个实验。目的是更深入地了解幕后发生了什么。实现
    Redux 和实现 NgRx 的区别在于使用一个用于发布/订阅的库，这是你选择传达给监听器发生更改的方式。在我们的[第8章](e29180be-1bdf-4fdb-805b-333607fd6e0d.xhtml)，*Redux*实现中，我们给了你选择在不使用库的情况下实现四人帮发布/订阅模式，或者使用`EventEmitter`来实现相同功能的机会。在
    NgRx 中，该组件是 RxJS。所以，让我们开始实现。在这样做之前，让我们描述我们想要实现的内容：
- en: We aim to implement a store that holds a state
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的目标是实现一个存储状态
- en: It should be possible to dispatch an action to said store so that its inner
    state changes
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该能够向该存储库分发一个动作，以便其内部状态发生变化
- en: Any change to the store should go through a reducer
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库的任何更改都应该通过还原器进行
- en: We will learn to handle side effects
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将学习如何处理副作用
- en: Adding a store
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加存储库
- en: 'A store at its heart is just a class wrapping a state. A store needs to be
    able to deal with changes; the change should come via method dispatch. The following
    pseudo code represents what the store might look like:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 核心来说，存储库只是一个封装状态的类。存储库需要能够处理更改；更改应通过方法分发。以下伪代码表示存储库可能的样子：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We mentioned in the beginning of this main section that NgRx uses RxJS at its
    core. We mentioned that it was so the store could convey changes to its listeners.
    Let''s mention the core concepts of RxJS that might fit the preceding problem
    description. In RxJS, we have:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的开头，我们提到 NgRx 在其核心使用 RxJS。我们提到这是为了让存储库能够将其更改传达给其监听器。让我们提及可能适合先前问题描述的 RxJS
    的核心概念。在 RxJS 中，我们有：
- en: '**Observable**: It is able to emit values and you can attach subscribers to
    it'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可观察者**：它能够发出值，并且你可以将其订阅者附加到它上面'
- en: '**Observer**: This is the object that is called so that we end up getting the
    values as a subscriber'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察者**：这是被调用的对象，以便我们最终以订阅者的形式获取值'
- en: '**Subscriber**: This is a combination of an Observable and an Observer in that
    it can be subscribed to but it is also possible to add values to it after the
    subscription has happened.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订阅者**：这是一个 Observable 和 Observer 的组合，它可以在订阅之后添加值。'
- en: 'Thinking about the store for a bit, we realize we need to be able to add values
    to it at any point and we need to be able to subscribe to it. This seems to fit
    the behavior of the `Subject`. Let''s continue our pseudo coding of the `Store`
    but let a `Subject` be part of it now:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细思考一下 store，我们意识到我们需要能够在任何时刻向其中添加值，并且我们需要能够订阅它。这似乎符合 `Subject` 的行为。让我们继续我们的
    `Store` 的伪代码编写，但现在让 `Subject` 成为它的一部分：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We implemented the `dispatch()` method with the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下代码实现了 `dispatch()` 方法：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'For now, let''s care about implementing subscription functionality. Let''s
    imagine the store will be used in the following way:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们关注实现订阅功能。让我们想象 store 将以以下方式使用：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For that to be possible, we could just add the `subscribe()` method to our
    store. If we were to do that ourselves, we would have to take care of a list of
    listeners and ensure listeners are told when a change happens to the state. A
    better option is to just let our store inherit from `Subject`. That would take
    care of the subscription bit. Let''s see what that might look like:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以在我们的 store 中添加 `subscribe()` 方法。如果我们自己这样做，我们必须注意一个监听器列表，并确保监听器在状态发生变化时被告知。更好的选择是让我们的
    store 继承自 `Subject`。这将处理订阅部分。让我们看看它可能的样子：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding code reimplements the `dispatch()` method and we also set up
    a subscription in the constructor to ensure our latest state is updated. There
    is a thing we need to improve here and that is how we add state to our store.
    With Redux, the incoming state change should be reduced into the old state, like
    so:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码重新实现了 `dispatch()` 方法，我们还在构造函数中设置了一个订阅，以确保我们的最新状态得到更新。这里有一个需要改进的地方，那就是我们如何向我们的
    store 添加状态。在 Redux 中，传入的状态变化应该被还原到旧状态，如下所示：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The way to achieve this is to refactor our code a little and create another
    `Subject` that will be the target of a call to dispatch, like so:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的方法是稍微重构我们的代码，并创建另一个 `Subject`，它将成为 dispatch 调用的目标，如下所示：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Merging the states in a better way
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好地合并状态
- en: 'In the preceding code, we used an `Object.assign()` to merge the old state
    with the new state. We can do this even better by using the `scan()` operator
    on our dispatcher member, like so:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了 `Object.assign()` 来合并旧状态和新状态。我们可以通过在我们的 dispatcher 成员上使用 `scan()`
    操作符来做得更好，如下所示：
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: An important thing to note in the preceding code is that we removed the state
    member from the store. It's simply not needed as we only care about the latest
    value being emitted anyway.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中需要注意的一个重要问题是，我们从 store 中移除了状态成员。这根本不是必需的，因为我们只关心正在发出的最新值。
- en: Implementing a reducer and integrating it with the store
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个 reducer 并将其与 store 集成
- en: 'An important concept of Redux is to guard who and what can affect your store.
    The *who* is reducers. By allowing only reducers to affect your store, we are
    more in control of what happens. A simple reducer is just a function that takes
    a state and action as parameters and is able to produce a new state based on the
    old state and existing state, like so:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 的重要概念之一是保护谁和什么可以影响你的 store。*谁* 是 reducers。通过只允许 reducers 影响你的 store，我们可以更好地控制发生的事情。一个简单的
    reducer 只是一个函数，它接受状态和动作作为参数，并能够根据旧状态和现有状态产生一个新的状态，如下所示：
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'So, where does a reducer come into the picture in Redux? Well, the state of
    the store is made up of an object, like so:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在 Redux 中，reducer 是如何进入画面的呢？嗯，store 的状态由一个对象组成，如下所示：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The way a store goes about calculating the next state of a store is by creating
    a function that looks something like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Store 计算下一个状态的方式是创建一个看起来像这样的函数：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'With the preceding code, we are able to let different reducer functions handle
    different parts of our state. Let''s add such a function to our store along with
    some reducers:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码，我们能够让不同的 reducer 函数处理我们状态的不同部分。让我们在我们的 store 中添加这样一个函数以及一些 reducers：
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We have made quite a few changes to our store at this point:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经对我们的 store 做了一些修改：
- en: We have added two reducers
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了两个 reducers
- en: Now we inherit from a `BehaviorSubject`; this is so we can remember what the
    old state was so when we call `calcState()` we are able to produce a new state
    based on the old state + action
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们从 `BehaviorSubject` 继承；这样做是为了记住旧的状态，当我们调用 `calcState()` 时，我们能够根据旧状态 + 动作生成一个新的状态
- en: We added the method `calcState()` that takes the old state and an action
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了 `calcState()` 方法，该方法接受旧状态和一个动作
- en: The dispatcher now takes an action instead of a state
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在分发器接受一个动作而不是状态
- en: The `super()` constructor in the constructor now takes an initial value
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数中的 `super()` 现在接受一个初始值
- en: We have set ourselves up quite well for our next step, namely on how to get
    a part of the state.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为下一步做好了充分的准备，即如何获取状态的一部分。
- en: Dealing with slices of state
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理状态切片
- en: 'The reason for wanting only part of the state is that we will use NgRx in a
    context where there will be many components that only care about rendering a little
    part of the application''s full state. For example, we may have a product list
    component, a product detail component, and so on. For that reason, we need to
    implement support for getting a slice of state. Thanks to the fact that our store
    inherits from a `BehaviorSubject,` implementing a slice of state is child''s play:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 只想获取部分状态的原因是，我们将在一个有许多组件只关心渲染应用程序完整状态的一小部分的上下文中使用 NgRx。例如，我们可能有一个产品列表组件、产品详情组件等。因此，我们需要实现获取状态切片的支持。由于我们的存储从
    `BehaviorSubject` 继承，实现状态切片变得轻而易举：
- en: '[PRE46]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Should we want a more advanced `select` method, we can let it take a function
    instead, like so:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个更高级的 `select` 方法，我们可以让它接受一个函数，如下所示：
- en: '[PRE47]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Handling side effects
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理副作用
- en: 'What is a side effect? A side effect is something that isn''t part of the normal
    code flow but something that accesses outside resources, such as filesystems or
    resources on other networks. In the context of Redux, side effects are most often
    used for carrying out AJAX calls. Once that call comes back, we most likely need
    to update the state of the store because something has changed. How would we implement
    such a function? One is add a method `effect()` that would take a function. The
    said function would take dispatch method as a parameter so that the parameter
    function can carry out a dispatch, should it have a need for it, once the side
    effect has run its course. Let''s imagine it is being used in the following way:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是副作用？副作用是指不属于正常代码流程的一部分，但它访问外部资源，例如文件系统或其他网络上的资源。在 Redux 的上下文中，副作用最常用于执行 AJAX
    调用。一旦调用返回，我们很可能需要更新存储的状态，因为某些东西已经改变。我们如何实现这样的函数？一种方法是添加一个 `effect()` 方法，该方法接受一个函数。该函数将接受
    dispatch 方法作为参数，以便参数函数在副作用运行完毕后，如果需要，可以执行 dispatch。让我们想象它将被这样使用：
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding code shows how we in our side effect would want to carry out
    an AJAX call and fetch our products. Once we are done with our fetch, we want
    to dispatch the fetched products so they become part of the store''s state. Let''s
    attempt to implement the preceding `effect()` function:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示了我们在副作用中想要执行 AJAX 调用并获取我们的产品的方式。一旦我们完成获取，我们希望分发获取到的产品，使它们成为存储状态的一部分。让我们尝试实现前面的
    `effect()` 函数：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The preceding code does the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行以下操作：
- en: Adds a new case `LOAD_PRODUCTS` to the `productsReducer`
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新的情况 `LOAD_PRODUCTS` 添加到 `productsReducer`
- en: Implements the `effect()` method on the `Store` class
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Store` 类上实现 `effect()` 方法
- en: Defines a `getProducts()` method to simulate AJAX calls
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个 `getProducts()` 方法来模拟 AJAX 调用
- en: Demonstrates the use of the effect method by carrying out a call to `getProducts`
    and ends up dispatching the fetched products to the store
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过执行对 `getProducts` 的调用来演示效果方法的使用，并将获取到的产品发送到存储中
- en: We have now fully implemented the store and effects libraries for NgRx—we should
    be proud of ourselves.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完全实现了 NgRx 的存储和效果库——我们应该为此感到自豪。
- en: '@ngrx/schematics'
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@ngrx/schematics'
- en: 'Schematics is dependent on all of the libraries you can possibly use with NgRx;
    it''s therefore a good idea to start out by installing these libraries before
    we do anything else. Just type the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Schematics 依赖于所有可能的 NgRx 库；因此，在我们做其他任何事情之前安装这些库是个好主意。只需输入以下内容：
- en: '[PRE50]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Schematics itself is a library that Angular-CLI uses to generate different
    constructs needed for Angular development, such as components services, filters,
    and much more. `@ngrx/schematics` provides blueprints to schematics so you can
    get help generating constructs that you need when working with NgRx, in other
    words it makes development a lot faster. You can get help with generating the
    following things:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Schematics 本身是一个库，Angular-CLI 使用它来生成 Angular 开发所需的不同结构，例如组件、服务、过滤器等等。`@ngrx/schematics`
    为 schematics 提供蓝图，以便在处理 NgRx 时获取帮助生成所需的构建结构，换句话说，它使开发速度大大加快。您可以获取以下内容的帮助：
- en: Actions
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作
- en: Container
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器
- en: Effect
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Effect
- en: Entity
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体
- en: Feature
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能
- en: Reducer
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reducer
- en: Store
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Store
- en: Setting it up
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: '`@ngrx/schematics` is an NPM library and as such can be easily installed by
    typing:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ngrx/schematics` 是一个 NPM 库，因此可以通过输入以下命令轻松安装：'
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: That's it. That's all that was needed to do the set up. To use it, you just
    need a terminal window and enter the appropriate commands. We will look at that
    next.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。这就是设置所需的所有内容。要使用它，您只需要一个终端窗口并输入适当的命令。我们将在下一节中查看。
- en: Generating constructs
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成结构
- en: 'Generating what you need is as simple as typing:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 生成所需的内容就像输入以下内容一样简单：
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This will create files in the appropriate place. This is a real time saver,
    so learn to use it. Almost all of the commands come with a lot of options so it's
    worth checking out how they can be configured in the official documentation, which
    can be found here [https://github.com/ngrx/platform/tree/master/docs/schematics.](https://github.com/ngrx/platform/tree/master/docs/schematics)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在适当的位置创建文件。这是一个节省时间的方法，所以学习如何使用它。几乎所有的命令都附带了很多选项，因此值得查看官方文档中它们如何配置，官方文档可以在以下位置找到
    [https://github.com/ngrx/platform/tree/master/docs/schematics.](https://github.com/ngrx/platform/tree/master/docs/schematics)
- en: Generating actions
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成动作
- en: 'Do this by typing the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入以下内容来完成此操作：
- en: '[PRE53]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'It will generate an actions file for us called `jedi.actions.ts` with the following
    content:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 它将为我们生成一个名为 `jedi.actions.ts` 的动作文件，内容如下：
- en: '[PRE54]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The preceding code gives us nice scaffolded files with some nice defaults and
    it creates a `enum` type that we can use in conjunction with reducers and selectors.
    Looking at the preceding code, we realize that we need to extend `JedisActionTypes`
    if we want things such as `ADD`, `CREATE,` and other CRUD operations.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码为我们提供了带有一些默认设置的精美脚手架文件，并创建了一个可以与 reducer 和选择器一起使用的 `enum` 类型。查看上述代码，我们意识到如果我们想要像
    `ADD`、`CREATE` 以及其他 CRUD 操作这样的功能，我们需要扩展 `JedisActionTypes`。
- en: Generating a container
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成容器
- en: 'This will inject a store into your component and create the component itself—the
    typical way to call this one is by typing:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您的组件中注入 store 并创建组件本身——调用此方法的典型方式是输入：
- en: '[PRE55]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This will create the following files:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建以下文件：
- en: '`jedis.component.ts`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jedis.component.ts`'
- en: '`jedis.component.html`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jedis.component.html`'
- en: '`jedis.component.css`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jedis.component.css`'
- en: '`jedis.component.spec.ts`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jedis.component.spec.ts`'
- en: 'And in `jedis.component.ts` and the store will be injected in the constructor,
    like so:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在 `jedis.component.ts` 中，store 将在构造函数中注入，如下所示：
- en: '[PRE56]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Generating an effect
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成效果
- en: 'You generate an effect by typing the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过输入以下内容来生成一个效果：
- en: '[PRE57]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This will produce the files:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下文件：
- en: '`jedis.effect.ts`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jedis.effect.ts`'
- en: '`jedis.effect.spec.ts`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jedis.effect.spec.ts`'
- en: 'The `effects` file looks like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`effects` 文件看起来如下：'
- en: '[PRE58]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Generating an entity
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成实体
- en: 'This generates a whole bunch of files that you can think of to work with an
    entity. To run the command, type:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一大堆可以用来处理实体的文件。要运行命令，请输入：
- en: '[PRE59]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The following files are generated:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的以下文件：
- en: '`product.actions.ts`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product.actions.ts`'
- en: '`product.model.ts`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product.model.ts`'
- en: '`product.reducer.ts`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product.reducer.ts`'
- en: '`product.reducer.spec.ts`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product.reducer.spec.ts`'
- en: It's worth mentioning that the `product.reducer.ts` file not only generates
    the full reducer function but also creates and initializes the `EntityAdapter`.
    That's a lot of boilerplate that you don't have to write. You also get all the
    actions and all selectors—a truly powerful command.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`product.reducer.ts` 文件不仅生成完整的 reducer 函数，还创建并初始化了 `EntityAdapter`。这省去了您需要编写的很多样板代码。您还将获得所有动作和所有选择器——这是一个真正强大的命令。
- en: Generating a feature
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成功能
- en: 'Generating a feature gives you a lot of files. Let''s have a look at what the
    command looks like:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 生成功能会为您生成很多文件。让我们看看命令的样子：
- en: '[PRE60]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This generates the following files:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下文件：
- en: '`category.actions.ts`'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`category.actions.ts`'
- en: '`category.reducer.ts`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`category.reducer.ts`'
- en: '`category.reducer.spec.ts`'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`category.reducer.spec.ts`'
- en: '`category.effects.ts`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`category.effects.ts`'
- en: '`category.effects.spec.ts`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`category.effects.spec.ts`'
- en: This again is a lot of files you don't have to write by hand.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是一堆您不必手动编写的文件。
- en: Generating a reducer
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成还原器
- en: 'This generates a reducer and a test file. If all you want is a reducer then
    this command is for you. To use it, type the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个还原器和测试文件。如果您只想有一个还原器，那么这个命令就是为您准备的。要使用它，请输入以下内容：
- en: '[PRE61]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This produces the following files:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下文件：
- en: '`travel.reducer.ts`'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`travel.reducer.ts`'
- en: '`travel.reducer.spec.ts`'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`travel.reducer.spec.ts`'
- en: Generating a store
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成存储库
- en: 'This command sets you up completely for using the `@ngrx/store`. It also allows
    you to set up feature stores. So, by typing the following two commands, you can
    generate a whole lot of files:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将您完全设置为使用`@ngrx/store`。它还允许您设置功能存储库。因此，通过输入以下两个命令，您可以生成大量的文件：
- en: '[PRE62]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The preceding code will generate a module as well as add a feature state. Running
    the following command will add the set up needed to work with the store, as well
    as set up the devtools that come with NgRx:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将生成一个模块，并添加一个功能状态。运行以下命令将添加与存储库一起工作的设置，以及设置随NgRx一起提供的devtools：
- en: '[PRE63]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this, the final chapter of the book, we have looked at how to truly master
    NgRx and all its accompanying helper libraries. We have also gone through how
    to build your own micro implementation of NgRx to establish that we really know
    what is going on behind the scenes. We have looked at various ways to improve
    our speed and productivity by looking at the entity library and schematics library,
    respectively.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章，我们探讨了如何真正掌握NgRx及其所有辅助库。我们还通过构建自己的NgRx微实现来验证我们确实了解幕后发生的事情。我们通过查看实体库和图库，分别探讨了各种提高我们速度和生产力的方法。
- en: You, as a reader, have been taken through a long journey of Flux and Redux patterns
    throughout the course of this book. In addition, Functional programming, Reactive
    Programming, and deep RxJS knowledge have been added to your tool belt. This has
    built up to two full chapters covering everything NgRx has to offer. The aim of
    this book was to give you a broad and deep enough context of the underlying thoughts
    and paradigms behind NgRx and the library itself. The hope is that after, reading
    this book, you will feel full of confidence and know how to tackle existing and
    future projects using Angular and NgRx.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 作为读者的您，在本书的过程中经历了一段关于Flux和Redux模式的漫长旅程。此外，函数式编程、响应式编程和深入RxJS知识也被添加到您的工具箱中。这最终形成了两章完整的章节，涵盖了NgRx所能提供的一切。本书的目的是为您提供足够广泛和深入的背景知识，了解NgRx及其库背后的思想和范式。希望阅读本书后，您将充满信心，知道如何使用Angular和NgRx应对现有和未来的项目。
- en: Thank you for taking the time to read this book, and do not hesitate to reach
    out with queries in any way, shape, or form.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您抽出时间阅读这本书，并且不要犹豫以任何方式提出疑问。
