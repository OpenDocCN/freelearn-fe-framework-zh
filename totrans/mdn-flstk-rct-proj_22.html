<html><head></head><body>
<div id="_idContainer149" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-300"><a id="_idTextAnchor303" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">17</span></h1>
<h1 id="_idParaDest-301" class="calibre5"><a id="_idTextAnchor304" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1">Introducing React Server Components</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">After implementing our static blog app in Next.js, it’s time to introduce some interactivity to it. </span><span class="kobospan" id="kobo.3.2">Instead of using the traditional pattern of writing a separate backend server, which the frontend fetches data from and makes requests to, we are going to use a new pattern </span><a id="_idIndexMarker902" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.4.1">called </span><strong class="bold"><span class="kobospan" id="kobo.5.1">React Server Components</span></strong><span class="kobospan" id="kobo.6.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.7.1">RSCs</span></strong><span class="kobospan" id="kobo.8.1">). </span><span class="kobospan" id="kobo.8.2">This new pattern allows us to directly access the database from React components by executing certain React components (so-called server components) only on the server. </span><span class="kobospan" id="kobo.8.3">Together with Server Actions (a way to call functions on the server from the client), this new pattern allows us to easily and quickly develop full-stack apps. </span><span class="kobospan" id="kobo.8.4">In this chapter, we are going to learn what RSCs and Server Actions are, why they matter, what their advantages are, and how to implement them properly </span><span><span class="kobospan" id="kobo.9.1">and securely.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.10.1">In this chapter, we are going to cover the following </span><span><span class="kobospan" id="kobo.11.1">main topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.12.1">What </span><span><span class="kobospan" id="kobo.13.1">are RSCs?</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.14.1">Adding a data layer to our </span><span><span class="kobospan" id="kobo.15.1">Next.js app</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.16.1">Using RSCs to fetch data from </span><span><span class="kobospan" id="kobo.17.1">the database</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.18.1">Using Server Actions to sign up, log in, and create </span><span><span class="kobospan" id="kobo.19.1">new posts</span></span></li>
</ul>
<h1 id="_idParaDest-302" class="calibre5"><a id="_idTextAnchor305" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.20.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.21.1">Before we start, please install all the requirements from </span><a href="B19385_01.xhtml#_idTextAnchor016" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.22.1">Chapter 1</span></em></span></a><span class="kobospan" id="kobo.23.1">, </span><em class="italic"><span class="kobospan" id="kobo.24.1">Preparing For Full-Stack Development</span></em><span class="kobospan" id="kobo.25.1">, and </span><a href="B19385_02.xhtml#_idTextAnchor028" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.26.1">Chapter 2</span></em></span></a><span class="kobospan" id="kobo.27.1">, </span><em class="italic"><span class="kobospan" id="kobo.28.1">Getting to Know Node.js </span></em><span><em class="italic"><span class="kobospan" id="kobo.29.1">and MongoDB</span></em></span><span><span class="kobospan" id="kobo.30.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.31.1">The versions listed in those chapters are the ones used in this book. </span><span class="kobospan" id="kobo.31.2">While installing a newer version should not be an issue, please note that certain steps might work differently. </span><span class="kobospan" id="kobo.31.3">If you are having an issue with the code and steps provided in this book, please try using the versions mentioned in </span><em class="italic"><span class="kobospan" id="kobo.32.1">Chapters 1 </span></em><span><span class="kobospan" id="kobo.33.1">and</span></span><span><em class="italic"><span class="kobospan" id="kobo.34.1"> 2</span></em></span><span><span class="kobospan" id="kobo.35.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.36.1">You can find the code for this chapter on </span><span><span class="kobospan" id="kobo.37.1">GitHub: </span></span><a href="https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch17" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.38.1">https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch17</span></span></a><span><span class="kobospan" id="kobo.39.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.40.1">The CiA video for this chapter can be found </span><span><span class="kobospan" id="kobo.41.1">at: </span></span><a href="https://youtu.be/4hGZJRmZW6E" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.42.1">https://youtu.be/4hGZJRmZW6E</span></span></a><span><span class="kobospan" id="kobo.43.1">.</span></span></p>
<h1 id="_idParaDest-303" class="calibre5"><a id="_idTextAnchor306" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.44.1">What are RSCs?</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.45.1">So far, we</span><a id="_idIndexMarker903" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.46.1"> have been using the traditional React architecture, where all components </span><a id="_idIndexMarker904" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.47.1">are </span><strong class="bold"><span class="kobospan" id="kobo.48.1">client components</span></strong><span class="kobospan" id="kobo.49.1">. </span><span class="kobospan" id="kobo.49.2">We started with client-side rendering. </span><span class="kobospan" id="kobo.49.3">However, there are some downsides to </span><span><span class="kobospan" id="kobo.50.1">client-side rendering:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.51.1">The JavaScript </span><a id="_idIndexMarker905" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.52.1">client bundle must be downloaded from the server before the client can start rendering anything, delaying </span><a id="_idIndexMarker906" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.53.1">the </span><strong class="bold"><span class="kobospan" id="kobo.54.1">first contentful paint</span></strong><span class="kobospan" id="kobo.55.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.56.1">FCP</span></strong><span class="kobospan" id="kobo.57.1">) for </span><span><span class="kobospan" id="kobo.58.1">the user.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.59.1">Data must be fetched from the server (after all JavaScript is downloaded and executed) to show anything </span><a id="_idIndexMarker907" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.60.1">meaningful, delaying the </span><strong class="bold"><span class="kobospan" id="kobo.61.1">first meaningful paint</span></strong><span class="kobospan" id="kobo.62.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.63.1">FMP</span></strong><span class="kobospan" id="kobo.64.1">) for </span><span><span class="kobospan" id="kobo.65.1">the user.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.66.1">Most of the load is on the client, even for pages that are not interactive, which is especially problematic for clients with slow processors, such as low-end mobile devices or old laptops. </span><span class="kobospan" id="kobo.66.2">It also uses more battery to load a heavy client-side </span><span><span class="kobospan" id="kobo.67.1">rendered page.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.68.1">In certain cases, data is fetched sequentially (for example, loading posts first and then resolving the authors of each post), which is especially a problem for slow connections with </span><span><span class="kobospan" id="kobo.69.1">high latency.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.70.1">To solve these problems, </span><strong class="bold"><span class="kobospan" id="kobo.71.1">server-side rendering</span></strong><span class="kobospan" id="kobo.72.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.73.1">SSR</span></strong><span class="kobospan" id="kobo.74.1">) was</span><a id="_idIndexMarker908" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.75.1"> introduced, but it still has a big downside: the initial page load can be slow due to everything being rendered on the server. </span><span class="kobospan" id="kobo.75.2">This slowdown happens because of the </span><span><span class="kobospan" id="kobo.76.1">following reasons:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.77.1">Data must be fetched from the server before any of it can </span><span><span class="kobospan" id="kobo.78.1">be shown.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.79.1">The JavaScript client bundle must be downloaded from the server before the client can be hydrated with it. </span><span class="kobospan" id="kobo.79.2">Hydration means that the page is ready to be interacted with by a user. </span><span class="kobospan" id="kobo.79.3">To refresh your knowledge of how hydration works, check out </span><a href="B19385_07.xhtml#_idTextAnchor147" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.80.1">Chapter 7</span></em></span></a><span><span class="kobospan" id="kobo.81.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.82.1">Hydration has to be completed on the client before anything can be </span><span><span class="kobospan" id="kobo.83.1">interacted with.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.84.1">Even when a client component is pre-rendered on the server, its code will be bundled and sent to the client for hydration. </span><span class="kobospan" id="kobo.84.2">This means that client components can run on both </span><a id="_idIndexMarker909" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.85.1">the server (for SSR) and the client, but they need to at least be able to run on </span><span><span class="kobospan" id="kobo.86.1">the client.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.87.1">In a traditional  </span><a id="_idIndexMarker910" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.88.1">full-stack React architecture with only client components, if we needed to access the filesystem of the server or a database, we needed to write a separate backend using Node.js and expose an API (such as a REST API). </span><span class="kobospan" id="kobo.88.2">Then, this API was queried in client components, for example, using TanStack Query. </span><span class="kobospan" id="kobo.88.3">These queries can also be made on the server side (as we saw in </span><a href="B19385_07.xhtml#_idTextAnchor147" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.89.1">Chapter 7</span></em></span></a><span class="kobospan" id="kobo.90.1">, </span><em class="italic"><span class="kobospan" id="kobo.91.1">Improving the Load Time Using Server-Side Rendering</span></em><span class="kobospan" id="kobo.92.1">), but they need to at least be executable on the client. </span><span class="kobospan" id="kobo.92.2">This means we cannot directly access the filesystem or database from a React component, even if that code could run on the server; it would be bundled and sent to the client, where running it would not work (or expose internal information, such as credentials, to </span><span><span class="kobospan" id="kobo.93.1">the database):</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer144">
<span class="kobospan" id="kobo.94.1"><img alt="Figure 17.1 – The architecture of a full-stack app without and with RSCs" src="image/B19385_17_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.95.1">Figure 17.1 – The architecture of a full-stack app without and with RSCs</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.96.1">React 18 introduced a new feature called </span><a id="_idIndexMarker911" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.97.1">RSCs, which allows us to define components that will be solely executed on the server, with only the output sent to the client. </span><span class="kobospan" id="kobo.97.2">Server components can, for example, fetch data from a database or the filesystem, and then render interactive client components, passing that data as props to them. </span><span class="kobospan" id="kobo.97.3">This new feature allows for an architecture where we can more easily write a full-stack application using only React, without having to deal with the overhead of defining a </span><span><span class="kobospan" id="kobo.98.1">REST API.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.99.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.100.1">It might still make sense to define REST APIs for certain apps, especially if the backend is developed by another team in a larger-scale project, or if it is consumed by other services </span><span><span class="kobospan" id="kobo.101.1">and frontends.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.102.1">RSCs solve the aforementioned issues with client-side rendering and SSR by allowing us to execute code exclusively on the server (no hydration needed on the client!) and selectively streaming components (so we don’t have to wait for everything to pre-render before serving components to </span><span><span class="kobospan" id="kobo.103.1">the client).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.104.1">The following figure compares </span><strong class="bold"><span class="kobospan" id="kobo.105.1">client-side rendering (CSR)</span></strong><span class="kobospan" id="kobo.106.1"> with SSR </span><span><span class="kobospan" id="kobo.107.1">and RSCs:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer145">
<span class="kobospan" id="kobo.108.1"><img alt="Figure 17.2 – Comparison between CSR, SSR and RSC" src="image/B19385_17_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.109.1">Figure 17.2 – Comparison between CSR, SSR and RSC</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.110.1">As you see, RSCs are not only faster overall (as a result of fewer roundtrips over the network), but they can also display the layout of an app immediately while waiting for the rest of the components </span><span><span class="kobospan" id="kobo.111.1">to load.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.112.1">Let’s sum up the most important</span><a id="_idIndexMarker912" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.113.1"> features </span><span><span class="kobospan" id="kobo.114.1">of RSCs:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.115.1">They can run ahead of time and are excluded from the JavaScript bundle, reducing bundle size and </span><span><span class="kobospan" id="kobo.116.1">improving performance.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.117.1">They can run either during build time (resulting in static HTML) or be executed on the fly when a request comes in. </span><span class="kobospan" id="kobo.117.2">Interestingly, server components can also be exclusively executed during build time, resulting in a static HTML bundle. </span><span class="kobospan" id="kobo.117.3">This can be useful for statically built CMS apps or personal blogs. </span><span class="kobospan" id="kobo.117.4">RSCs also allow a mix, where the initial cache is primed with a static build, and then later revalidated through Server Actions or Webhooks. </span><span class="kobospan" id="kobo.117.5">We are going to learn more about caching in </span><a href="B19385_18.xhtml#_idTextAnchor321" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.118.1">Chapter 18</span></em></span></a><em class="italic"><span class="kobospan" id="kobo.119.1">, Advanced Next.js Concepts </span></em><span><em class="italic"><span class="kobospan" id="kobo.120.1">and Optimizations</span></em></span><span><span class="kobospan" id="kobo.121.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.122.1">They can pass (serializable) data to client components. </span><span class="kobospan" id="kobo.122.2">Additionally, client components can still be server-side rendered to further </span><span><span class="kobospan" id="kobo.123.1">improve performance!</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.124.1">Inside a server component, other server components can be passed as props to client components, allowing for composition patterns where server components are “slotted into” interactive client components. </span><span class="kobospan" id="kobo.124.2">However, all components that are imported inside client components will be considered client components; they cannot be server </span><a id="_idIndexMarker913" class="calibre6 pcalibre1 pcalibre"/><span><span class="kobospan" id="kobo.125.1">components anymore.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.126.1">In frameworks such as Next.js, by default, a React component is considered a server component. </span><span class="kobospan" id="kobo.126.2">If we want to turn it into a client component, we need to write the </span><strong class="source-inline"><span class="kobospan" id="kobo.127.1">"use client"</span></strong><span class="kobospan" id="kobo.128.1"> directive at the beginning of a file. </span><span class="kobospan" id="kobo.128.2">We need to do this to make it possible to add interactivity (event listeners) or use state/life cycle effects and </span><span><span class="kobospan" id="kobo.129.1">browser-only APIs.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.130.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.131.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.132.1">"use client"</span></strong><span class="kobospan" id="kobo.133.1"> directive defines a network boundary between server and client components. </span><span class="kobospan" id="kobo.133.2">All data sent from a server component to a client component will be serialized and sent over the network. </span><span class="kobospan" id="kobo.133.3">When using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.134.1">"use client"</span></strong><span class="kobospan" id="kobo.135.1"> directive in a file, all other modules that are imported into it, including child components, are considered to be part of the </span><span><span class="kobospan" id="kobo.136.1">client bundle.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.137.1">The following figure provides an overview of when to use a server component or a </span><span><span class="kobospan" id="kobo.138.1">client component:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer146">
<span class="kobospan" id="kobo.139.1"><img alt="Figure 17.3 – Overview of when to use server components and client components" src="image/B19385_17_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.140.1">Figure 17.3 – Overview of when to use server components and client components</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.141.1">In general, RSCs are </span><a id="_idIndexMarker914" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.142.1">an optimization over client components. </span><span class="kobospan" id="kobo.142.2">You could simply write </span><strong class="source-inline"><span class="kobospan" id="kobo.143.1">"use client"</span></strong><span class="kobospan" id="kobo.144.1"> at the top of every file and be done with it, but you would be leaving all the advantages of RSCs behind! </span><span class="kobospan" id="kobo.144.2">So, try to use server components whenever possible, but do not hesitate to fall back to defining something as a client component if it turns out to be too complicated to split it up into server-side and client-side parts. </span><span class="kobospan" id="kobo.144.3">It can always be </span><span><span class="kobospan" id="kobo.145.1">optimized later.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.146.1">This new way of writing full-stack React applications can be hard to grasp in theory, so feel free to come back to this section again at the end of this chapter. </span><span class="kobospan" id="kobo.146.2">For now, we’ll move on and implement RSCs in our Next.js app as this will help us understand how the new concepts work in practice. </span><span class="kobospan" id="kobo.146.3">First, we’ll start by adding a data layer to our Next.js app, which will allow us to access the database from RSCs </span><span><span class="kobospan" id="kobo.147.1">later on.</span></span></p>
<h1 id="_idParaDest-304" class="calibre5"><a id="_idTextAnchor307" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.148.1">Adding a data layer to our Next.js app</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.149.1">In the traditional backend structure, we had the database layer, the services layer, and the routes layer. </span><span class="kobospan" id="kobo.149.2">In a modern full-stack Next.js app, we don’t need the routes layer of our backend because we can directly interface with it in RSCs. </span><span class="kobospan" id="kobo.149.3">So, we only need to have the database layer and a data layer to provide functions that access the database. </span><span class="kobospan" id="kobo.149.4">Theoretically, we could directly access the database in RSCs, but it is best practice to have specific functions that access it in certain ways. </span><span class="kobospan" id="kobo.149.5">Defining such functions allows us to clearly define what data is accessible (and thus avoid accidentally leaking too much information). </span><span class="kobospan" id="kobo.149.6">They are also more reusable and make it easier to unit-test and find potential vulnerabilities (for example, via a penetration test) in the </span><span><span class="kobospan" id="kobo.150.1">data layer.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.151.1">To recap, there are three main </span><span><span class="kobospan" id="kobo.152.1">data-handling approaches:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.153.1">HTTP APIs</span></strong><span class="kobospan" id="kobo.154.1">: We used these in previous chapters to implement our blog app. </span><span class="kobospan" id="kobo.154.2">These can be</span><a id="_idIndexMarker915" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.155.1"> useful when separate teams are working on the </span><a id="_idIndexMarker916" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.156.1">backend and frontend. </span><span class="kobospan" id="kobo.156.2">Due to this, this approach is recommended for existing large projects </span><span><span class="kobospan" id="kobo.157.1">and organizations.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.158.1">Data access layer</span></strong><span class="kobospan" id="kobo.159.1">: This is the</span><a id="_idIndexMarker917" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.160.1"> pattern we are going to</span><a id="_idIndexMarker918" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.161.1"> use in this section. </span><span class="kobospan" id="kobo.161.2">It is recommended for new projects that make use of the RSC architecture as it makes it easier to implement full-stack projects by separating concerns of dealing with data (and all the security challenges associated with that) and the user interface (displaying the data in React components). </span><span class="kobospan" id="kobo.161.3">Dealing with each problem on its own is easier to solve and less error-prone than handling the complexity of both </span><span><span class="kobospan" id="kobo.162.1">at once.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.163.1">Component-level data access</span></strong><span class="kobospan" id="kobo.164.1">: This is a pattern where the database is queried directly in RSCs. </span><span class="kobospan" id="kobo.164.2">This</span><a id="_idIndexMarker919" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.165.1"> approach can be useful</span><a id="_idIndexMarker920" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.166.1"> for rapid prototyping and learning. </span><span class="kobospan" id="kobo.166.2">However, it should not be used in a production app due to scalability issues and the potential introduction of </span><span><span class="kobospan" id="kobo.167.1">security problems.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.168.1">It is not recommended to mix these approaches, so it’s better to pick one and stick to it. </span><span class="kobospan" id="kobo.168.2">In our case, we are going with the “data access layer” approach as it is the safest approach for a modern </span><span><span class="kobospan" id="kobo.169.1">RSC architecture.</span></span></p>
<h2 id="_idParaDest-305" class="calibre7"><a id="_idTextAnchor308" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.170.1">Setting up the database connection</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.171.1">Let’s start by setting up the necessary </span><a id="_idIndexMarker921" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.172.1">packages and initializing a </span><span><span class="kobospan" id="kobo.173.1">database connection:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.174.1">Copy the existing </span><strong class="source-inline1"><span class="kobospan" id="kobo.175.1">ch16</span></strong><span class="kobospan" id="kobo.176.1"> folder to a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.177.1">ch17</span></strong><span class="kobospan" id="kobo.178.1"> folder, </span><span><span class="kobospan" id="kobo.179.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.180.1">$ cp -R ch16 ch17</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.181.1">Open the </span><strong class="source-inline1"><span class="kobospan" id="kobo.182.1">ch17</span></strong><span class="kobospan" id="kobo.183.1"> folder in VS Code and open </span><span><span class="kobospan" id="kobo.184.1">a Terminal.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.185.1">We are going to use a package called </span><strong class="source-inline1"><span class="kobospan" id="kobo.186.1">server-only</span></strong><span class="kobospan" id="kobo.187.1"> to make sure code from the database and data layer are only executed on the server-side, and not accidentally imported on the client. </span><span class="kobospan" id="kobo.187.2">Install it, </span><span><span class="kobospan" id="kobo.188.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.189.1">$ npm install server-only@0.0.1</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.190.1">We are also going to need the </span><strong class="source-inline1"><span class="kobospan" id="kobo.191.1">mongoose</span></strong><span class="kobospan" id="kobo.192.1"> package to connect to the database and create database schemas and models. </span><span class="kobospan" id="kobo.192.2">Run the following command to </span><span><span class="kobospan" id="kobo.193.1">install it:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.194.1">$ npm install mongoose@8.0.2</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.195.1">Create a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.196.1">src/db/</span></strong></span><span><span class="kobospan" id="kobo.197.1"> folder.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.198.1">Inside this folder, create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.199.1">src/db/init.js</span></strong><span class="kobospan" id="kobo.200.1"> file, in which we first import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.201.1">server-only</span></strong><span class="kobospan" id="kobo.202.1"> package to make sure the code is only executed on </span><span><span class="kobospan" id="kobo.203.1">the server:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.204.1">
import 'server-only'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.205.1">Next, </span><span><span class="kobospan" id="kobo.206.1">import </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.207.1">mongoose</span></strong></span><span><span class="kobospan" id="kobo.208.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.209.1">
import mongoose from 'mongoose'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.210.1">Define and export an </span><strong class="source-inline1"><span class="kobospan" id="kobo.211.1">async</span></strong><span class="kobospan" id="kobo.212.1"> function to initialize </span><span><span class="kobospan" id="kobo.213.1">the database:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.214.1">
export async function initDatabase() {
  const connection = await mongoose.connect(process.env.DATABASE_URL)
  return connection
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.215.1">Now, we need to define </span><strong class="source-inline1"><span class="kobospan" id="kobo.216.1">DATABASE_URL</span></strong><span class="kobospan" id="kobo.217.1"> in a </span><strong class="source-inline1"><span class="kobospan" id="kobo.218.1">.env</span></strong><span class="kobospan" id="kobo.219.1"> file. </span><span class="kobospan" id="kobo.219.2">So, create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.220.1">.env</span></strong><span class="kobospan" id="kobo.221.1"> file in</span><a id="_idIndexMarker922" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.222.1"> the root of the project and add the </span><span><span class="kobospan" id="kobo.223.1">following line:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.224.1">
DATABASE_URL=mongodb://localhost:27017/blog</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.225.1">Now that the database connection has been set up, we can move on to creating the </span><span><span class="kobospan" id="kobo.226.1">database models.</span></span></p>
<h2 id="_idParaDest-306" class="calibre7"><a id="_idTextAnchor309" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.227.1">Creating the database models</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.228.1">Now, we are going to create </span><a id="_idIndexMarker923" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.229.1">database models for posts and users. </span><span class="kobospan" id="kobo.229.2">These are going to be very similar to the ones we created for our blog app in previous chapters. </span><span class="kobospan" id="kobo.229.3">Follow these steps to start creating the </span><span><span class="kobospan" id="kobo.230.1">database models:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.231.1">Create a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.232.1">src/db/models/</span></strong></span><span><span class="kobospan" id="kobo.233.1"> folder.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.234.1">Inside it, create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.235.1">src/db/models/user.js</span></strong><span class="kobospan" id="kobo.236.1"> file, where we first import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.237.1">server-only</span></strong><span class="kobospan" id="kobo.238.1"> and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.239.1">mongoose</span></strong></span><span><span class="kobospan" id="kobo.240.1"> packages:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.241.1">
import 'server-only'
import mongoose, { Schema } from 'mongoose'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.242.1">Define </span><strong class="source-inline1"><span class="kobospan" id="kobo.243.1">userSchema</span></strong><span class="kobospan" id="kobo.244.1">, which consists of a unique required </span><strong class="source-inline1"><span class="kobospan" id="kobo.245.1">username</span></strong><span class="kobospan" id="kobo.246.1"> and a </span><span><span class="kobospan" id="kobo.247.1">required </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.248.1">password</span></strong></span><span><span class="kobospan" id="kobo.249.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.250.1">
const userSchema = new Schema({
  username: { type: String, required: true, unique: true },
  password: { type: String, required: true },
})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.251.1">We create the</span><a id="_idIndexMarker924" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.252.1"> Mongoose model if it has not been </span><span><span class="kobospan" id="kobo.253.1">created yet:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.254.1">
export const User = mongoose.models.user ?? </span><span class="kobospan1" id="kobo.254.2">mongoose.model('user', userSchema)</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.255.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.256.1">Returning the model if it already exists and only creating a new one if it does not is necessary to avoid an </span><strong class="source-inline1"><span class="kobospan" id="kobo.257.1">OverwriteModelError</span></strong><span class="kobospan" id="kobo.258.1"> issue, which happens when the model is imported (and thus redefined) </span><span><span class="kobospan" id="kobo.259.1">multiple times.</span></span></p>
<ol class="calibre15">
<li value="5" class="calibre11"><span class="kobospan" id="kobo.260.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.261.1">src/db/models/post.js</span></strong><span class="kobospan" id="kobo.262.1"> file, where we first import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.263.1">server-only</span></strong><span class="kobospan" id="kobo.264.1"> and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.265.1">mongoose</span></strong></span><span><span class="kobospan" id="kobo.266.1"> packages:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.267.1">
import 'server-only'
import mongoose, { Schema } from 'mongoose'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.268.1">Define </span><strong class="source-inline1"><span class="kobospan" id="kobo.269.1">postSchema</span></strong><span class="kobospan" id="kobo.270.1">, which consists of a required </span><strong class="source-inline1"><span class="kobospan" id="kobo.271.1">title</span></strong><span class="kobospan" id="kobo.272.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.273.1">author</span></strong><span class="kobospan" id="kobo.274.1"> (referencing the </span><strong class="source-inline1"><span class="kobospan" id="kobo.275.1">user</span></strong><span class="kobospan" id="kobo.276.1"> model), and </span><span><span class="kobospan" id="kobo.277.1">optional </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.278.1">contents</span></strong></span><span><span class="kobospan" id="kobo.279.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.280.1">
const postSchema = new Schema(
  {
    title: { type: String, required: true },
    author: { type: Schema.Types.ObjectId, ref: 'user', required: true },
    contents: String,
  },
  { timestamps: true },
)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.281.1">We create the Mongoose model if it has not been </span><span><span class="kobospan" id="kobo.282.1">created yet:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.283.1">
export const Post = mongoose.models.post ?? </span><span class="kobospan1" id="kobo.283.2">mongoose.model('post', postSchema)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.284.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.285.1">src/db/models/index.js</span></strong><span class="kobospan" id="kobo.286.1"> file and re-export </span><span><span class="kobospan" id="kobo.287.1">the models:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.288.1">
import 'server-only'
export * from './user'
export * from './post'</span></pre><p class="calibre3"><span class="kobospan" id="kobo.289.1">We re-export the</span><a id="_idIndexMarker925" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.290.1"> models from this folder to ensure that we can, for example, load a post and resolve the </span><strong class="source-inline"><span class="kobospan" id="kobo.291.1">author</span></strong><span class="kobospan" id="kobo.292.1"> by querying the corresponding user. </span><span class="kobospan" id="kobo.292.2">This would require defining the </span><strong class="source-inline"><span class="kobospan" id="kobo.293.1">user</span></strong><span class="kobospan" id="kobo.294.1"> model, although it is not directly used. </span><span class="kobospan" id="kobo.294.2">To avoid issues like these, we simply load models from a file that defines all models upon </span><span><span class="kobospan" id="kobo.295.1">importing them.</span></span></p></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.296.1">After defining the database models, we can define the data layer functions, which will provide various ways to access </span><span><span class="kobospan" id="kobo.297.1">the database.</span></span></p>
<h2 id="_idParaDest-307" class="calibre7"><a id="_idTextAnchor310" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.298.1">Defining data layer functions</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.299.1">Now that we have a database connection</span><a id="_idIndexMarker926" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.300.1"> and schemas, let’s start defining data layer functions that access </span><span><span class="kobospan" id="kobo.301.1">the database.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.302.1">Defining the posts data layer</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.303.1">We’ll start by defining the data layer </span><a id="_idIndexMarker927" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.304.1">for posts. </span><span class="kobospan" id="kobo.304.2">This allows us to access all the relevant functions for dealing with posts in </span><span><span class="kobospan" id="kobo.305.1">our app:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.306.1">Create a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.307.1">src/data/</span></strong></span><span><span class="kobospan" id="kobo.308.1"> folder.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.309.1">Inside it, create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.310.1">src/data/posts.js</span></strong><span class="kobospan" id="kobo.311.1"> file, where we import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.312.1">server-only</span></strong><span class="kobospan" id="kobo.313.1"> package and the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.314.1">Post</span></strong></span><span><span class="kobospan" id="kobo.315.1"> model:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.316.1">
import 'server-only'
import { Post } from '@/db/models'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.317.1">Define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.318.1">createPost</span></strong><span class="kobospan" id="kobo.319.1"> function that takes a </span><strong class="source-inline1"><span class="kobospan" id="kobo.320.1">userId</span></strong><span class="kobospan" id="kobo.321.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.322.1">title</span></strong><span class="kobospan" id="kobo.323.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.324.1">contents</span></strong><span class="kobospan" id="kobo.325.1"> and creates a </span><span><span class="kobospan" id="kobo.326.1">new post:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.327.1">
export async function createPost(userId, { title, contents }) {
  const post = new Post({ author: userId, title, contents })
  return await post.save()
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.328.1">Next, define</span><a id="_idIndexMarker928" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.329.1"> a </span><strong class="source-inline1"><span class="kobospan" id="kobo.330.1">listAllPosts</span></strong><span class="kobospan" id="kobo.331.1"> function, which first gets all posts from the database sorted by creation date descending (showing the newest </span><span><span class="kobospan" id="kobo.332.1">posts first):</span></span><pre class="source-code"><span class="kobospan1" id="kobo.333.1">
export async function listAllPosts() {
  return await Post.find({})
    .sort({ createdAt: 'descending' })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.334.1">Then, we must </span><strong class="source-inline1"><span class="kobospan" id="kobo.335.1">populate</span></strong><span class="kobospan" id="kobo.336.1"> the </span><strong class="source-inline1"><span class="kobospan" id="kobo.337.1">author</span></strong><span class="kobospan" id="kobo.338.1"> field by resolving the </span><strong class="source-inline1"><span class="kobospan" id="kobo.339.1">user</span></strong><span class="kobospan" id="kobo.340.1"> model and getting the </span><strong class="source-inline1"><span class="kobospan" id="kobo.341.1">username</span></strong><span class="kobospan" id="kobo.342.1"> value </span><span><span class="kobospan" id="kobo.343.1">from it:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.344.1">
    .populate('author', 'username')</span></pre><p class="calibre3"><span class="kobospan" id="kobo.345.1">In Mongoose, the </span><strong class="source-inline"><span class="kobospan" id="kobo.346.1">populate</span></strong><span class="kobospan" id="kobo.347.1"> function works like a </span><strong class="source-inline"><span class="kobospan" id="kobo.348.1">JOIN</span></strong><span class="kobospan" id="kobo.349.1"> statement in SQL: it takes the ID stored in the </span><strong class="source-inline"><span class="kobospan" id="kobo.350.1">author</span></strong><span class="kobospan" id="kobo.351.1"> field and then checks which model the ID references by looking at the </span><strong class="source-inline"><span class="kobospan" id="kobo.352.1">post</span></strong><span class="kobospan" id="kobo.353.1"> schema. </span><span class="kobospan" id="kobo.353.2">In the </span><strong class="source-inline"><span class="kobospan" id="kobo.354.1">post</span></strong><span class="kobospan" id="kobo.355.1"> schema, we defined that the </span><strong class="source-inline"><span class="kobospan" id="kobo.356.1">author</span></strong><span class="kobospan" id="kobo.357.1"> field references the </span><strong class="source-inline"><span class="kobospan" id="kobo.358.1">user</span></strong><span class="kobospan" id="kobo.359.1"> schema, so Mongoose will query the </span><strong class="source-inline"><span class="kobospan" id="kobo.360.1">user</span></strong><span class="kobospan" id="kobo.361.1"> model for the given ID and return a user object. </span><span class="kobospan" id="kobo.361.2">By providing the second argument, we specify that we only want to get the </span><strong class="source-inline"><span class="kobospan" id="kobo.362.1">username</span></strong><span class="kobospan" id="kobo.363.1"> value from the </span><strong class="source-inline"><span class="kobospan" id="kobo.364.1">user</span></strong><span class="kobospan" id="kobo.365.1"> object (the ID will always be returned anyway). </span><span class="kobospan" id="kobo.365.2">This is done to avoid leaking internal information, such as the (hashed) password of </span><span><span class="kobospan" id="kobo.366.1">a user.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.367.1">After populating the post objects, we use </span><strong class="source-inline1"><span class="kobospan" id="kobo.368.1">.lean()</span></strong><span class="kobospan" id="kobo.369.1"> to turn it into a plain, serializable </span><span><span class="kobospan" id="kobo.370.1">JavaScript object:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.371.1">
    .lean()
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.372.1">Having a serializable object is necessary to be able to pass the data from an RSC to a regular client-side component later since all data passed to the client needs to cross the network boundary, and thus needs to </span><span><span class="kobospan" id="kobo.373.1">be serializable.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.374.1">Lastly, we must define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.375.1">getPostById</span></strong><span class="kobospan" id="kobo.376.1"> function, which finds a single post by ID, populates the </span><strong class="source-inline1"><span class="kobospan" id="kobo.377.1">author</span></strong><span class="kobospan" id="kobo.378.1"> field, and turns the result into a plain JavaScript object by </span><a id="_idIndexMarker929" class="calibre6 pcalibre1 pcalibre"/><span><span class="kobospan" id="kobo.379.1">using </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.380.1">lean()</span></strong></span><span><span class="kobospan" id="kobo.381.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.382.1">
export async function getPostById(postId) {
  return await Post.findById(postId)
    .populate('author', 'username')
    .lean()
}</span></pre></li> </ol>
<h3 class="calibre9"><span class="kobospan" id="kobo.383.1">Defining the data layer for users</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.384.1">We are now going to define the </span><a id="_idIndexMarker930" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.385.1">data layer for users. </span><span class="kobospan" id="kobo.385.2">This will involve creating a JWT for authentication. </span><span class="kobospan" id="kobo.385.3">Again, a lot of the code will be very similar to what we previously implemented for our blog app. </span><span class="kobospan" id="kobo.385.4">Follow these steps to start defining the data layer </span><span><span class="kobospan" id="kobo.386.1">for users:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.387.1">Install </span><strong class="source-inline1"><span class="kobospan" id="kobo.388.1">bcrypt</span></strong><span class="kobospan" id="kobo.389.1"> (for hashing the user password) and </span><strong class="source-inline1"><span class="kobospan" id="kobo.390.1">jsonwebtoken</span></strong><span class="kobospan" id="kobo.391.1"> (for </span><span><span class="kobospan" id="kobo.392.1">handling JWTs):</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.393.1">$ npm install bcrypt@5.1.1 jsonwebtoken@9.0.2</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.394.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.395.1">src/data/users.js</span></strong><span class="kobospan" id="kobo.396.1"> file, where we import </span><strong class="source-inline1"><span class="kobospan" id="kobo.397.1">server-only</span></strong><span class="kobospan" id="kobo.398.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.399.1">bcrypt</span></strong><span class="kobospan" id="kobo.400.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.401.1">jwt</span></strong><span class="kobospan" id="kobo.402.1">, and the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.403.1">User</span></strong></span><span><span class="kobospan" id="kobo.404.1"> model:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.405.1">
import 'server-only'
import bcrypt from 'bcrypt'
import jwt from 'jsonwebtoken'
import { User } from '@/db/models'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.406.1">Define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.407.1">createUser</span></strong><span class="kobospan" id="kobo.408.1"> function, where</span><a id="_idIndexMarker931" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.409.1"> we hash the given password and then create a new instance of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.410.1">User</span></strong><span class="kobospan" id="kobo.411.1"> model and </span><span><span class="kobospan" id="kobo.412.1">save it:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.413.1">
export async function createUser({ username, password }) {
  const hashedPassword = await bcrypt.hash(password, 10)
  const user = new User({ username, password: hashedPassword })
  return await user.save()
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.414.1">Next, define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.415.1">loginUser</span></strong><span class="kobospan" id="kobo.416.1"> function, which first tries to find a user with the given username and throws an error if no user </span><span><span class="kobospan" id="kobo.417.1">is found:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.418.1">
export async function loginUser({ username, password }) {
  const user = await User.findOne({ username })
  if (!user) {
    throw new Error('invalid username!')
  }</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.419.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.420.1">Depending on your security requirements, you might want to consider not telling a potential attacker that a username exists and instead return a generic message such as “Invalid username or password.” </span><span class="kobospan" id="kobo.420.2">However, in our case, the usernames are assumed to be public information because each user is an author on the blog and their usernames are published with </span><span><span class="kobospan" id="kobo.421.1">their articles.</span></span></p>
<ol class="calibre15">
<li value="5" class="calibre11"><span class="kobospan" id="kobo.422.1">Then, use </span><strong class="source-inline1"><span class="kobospan" id="kobo.423.1">bcrypt</span></strong><span class="kobospan" id="kobo.424.1"> to compare the provided password against the hashed password from the database and throw an error if the password </span><span><span class="kobospan" id="kobo.425.1">is invalid:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.426.1">
  const isPasswordCorrect = await bcrypt.compare(password, user.password)
  if (!isPasswordCorrect) {
    throw new Error('invalid password!')
  }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.427.1">Lastly, generate, sign, and </span><a id="_idIndexMarker932" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.428.1">return </span><span><span class="kobospan" id="kobo.429.1">a JWT:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.430.1">
  const token = jwt.sign({ sub: user._id }, process.env.JWT_SECRET, {
    expiresIn: '24h',
  })
  return token
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.431.1">Now, we are going to define a function to get the user information (for now, we’re only going to get the username, but this could be extended later) from a user ID. </span><span class="kobospan" id="kobo.431.2">If the user ID does not exist, we throw </span><span><span class="kobospan" id="kobo.432.1">an error:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.433.1">
export async function getUserInfoById(userId) {
  const user = await User.findById(userId)
  if (!user) throw new Error('user not found!')
  return { username: user.username }
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.434.1">Next, define a function to get the user ID from a token, making sure to verify the token signature in addition to decoding the JWT, by </span><span><span class="kobospan" id="kobo.435.1">using </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.436.1">jwt.verify</span></strong></span><span><span class="kobospan" id="kobo.437.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.438.1">
export function getUserIdByToken(token) {
  if (!token) return null
  const decodedToken = jwt.verify(token, process.env.JWT_SECRET)
  return decodedToken.sub
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.439.1">Finally, define a </span><a id="_idIndexMarker933" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.440.1">function to get the user information from a token by combining the </span><strong class="source-inline1"><span class="kobospan" id="kobo.441.1">getUserIdByToken</span></strong><span class="kobospan" id="kobo.442.1"> and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.443.1">getUserInfoById</span></strong></span><span><span class="kobospan" id="kobo.444.1"> functions:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.445.1">
export async function getUserInfoByToken(token) {
  const userId = getUserIdByToken(token)
  if (!userId) return null
  const user = await getUserInfoById(userId)
  return user
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.446.1">We still need to define the </span><strong class="source-inline1"><span class="kobospan" id="kobo.447.1">JWT_SECRET</span></strong><span class="kobospan" id="kobo.448.1"> environment variable for our code to work. </span><span class="kobospan" id="kobo.448.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.449.1">.env</span></strong><span class="kobospan" id="kobo.450.1"> and add it, </span><span><span class="kobospan" id="kobo.451.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.452.1">
JWT_SECRET=replace-with-random-secret</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.453.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.454.1">This is a very basic implementation of authentication with Next.js. </span><span class="kobospan" id="kobo.454.2">For a large-scale project, it is recommended to look into a fully-fledged authentication solution, such as Auth.js (formerly next-auth), Auth0, or Supabase. </span><span class="kobospan" id="kobo.454.3">Check out the Next.js docs for more information on authentication with </span><span><span class="kobospan" id="kobo.455.1">Next.js: </span></span><a href="https://nextjs.org/docs/app/building-your-application/authentication" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.456.1">https://nextjs.org/docs/app/building-your-application/authentication</span></span></a><span><span class="kobospan" id="kobo.457.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.458.1">Now that we have a data layer to access the database, we can start implementing RSCs and Server Actions, which are going to call functions from the data layer to access information from the database and render React components that display it, turning our static blog app into a fully </span><span><span class="kobospan" id="kobo.459.1">functional blog.</span></span></p>
<h1 id="_idParaDest-308" class="calibre5"><a id="_idTextAnchor311" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.460.1">Using RSCs to fetch data from the database</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.461.1">As we have learned, when </span><a id="_idIndexMarker934" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.462.1">using Next.js, React components are considered to be Server Components by default, so all page components are already executed and rendered on the server. </span><span class="kobospan" id="kobo.462.2">Only if we need to use client-only functions, such as hooks or input fields, do we need to turn our components into a client component by using the </span><strong class="source-inline"><span class="kobospan" id="kobo.463.1">"use client"</span></strong><span class="kobospan" id="kobo.464.1"> directive. </span><span class="kobospan" id="kobo.464.2">For all components that do not require user interaction, we can simply keep them as server components, and they will only be statically rendered and served as as HTML (encoded in the RSC payload) and not hydrated on the client. </span><span class="kobospan" id="kobo.464.3">To the client (the browser), it will seem as if these React components don’t even exist as the browser will only see static HTML code. </span><span class="kobospan" id="kobo.464.4">This pattern greatly improves the performance of our web application as the client doesn’t need to load JavaScript to render such components. </span><span class="kobospan" id="kobo.464.5">It also reduces the bundle size because less JavaScript code is needed to load our </span><span><span class="kobospan" id="kobo.465.1">web application.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.466.1">Now, let’s implement RSCs to fetch data from </span><span><span class="kobospan" id="kobo.467.1">the database.</span></span></p>
<h2 id="_idParaDest-309" class="calibre7"><a id="_idTextAnchor312" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.468.1">Fetching a list of posts</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.469.1">We’ll start by </span><a id="_idIndexMarker935" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.470.1">implementing the </span><strong class="source-inline"><span class="kobospan" id="kobo.471.1">HomePage</span></strong><span class="kobospan" id="kobo.472.1">, where we</span><a id="_idIndexMarker936" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.473.1"> fetch and render a list </span><span><span class="kobospan" id="kobo.474.1">of posts:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.475.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.476.1">src/app/page.js</span></strong><span class="kobospan" id="kobo.477.1"> and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.478.1">initDatabase</span></strong><span class="kobospan" id="kobo.479.1"> and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.480.1">listAllPosts</span></strong></span><span><span class="kobospan" id="kobo.481.1"> functions:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.482.1">
import { initDatabase } from '@/db/init'
import { listAllPosts } from '@/data/posts'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.483.1">Turn the </span><strong class="source-inline1"><span class="kobospan" id="kobo.484.1">HomePage</span></strong><span class="kobospan" id="kobo.485.1"> component into an </span><strong class="source-inline1"><span class="kobospan" id="kobo.486.1">async</span></strong><span class="kobospan" id="kobo.487.1"> function, which allows us to wait until the data is fetched before rendering </span><span><span class="kobospan" id="kobo.488.1">the component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.489.1">
export default </span><strong class="bold1"><span class="kobospan1" id="kobo.490.1">async</span></strong><span class="kobospan1" id="kobo.491.1"> function HomePage() {</span></pre></li> <li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.492.1">Replace</span></em><span class="kobospan" id="kobo.493.1"> the sample </span><strong class="source-inline1"><span class="kobospan" id="kobo.494.1">posts</span></strong><span class="kobospan" id="kobo.495.1"> array with the </span><span><span class="kobospan" id="kobo.496.1">following code:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.497.1">
  await initDatabase()
  const posts = await listAllPosts()</span></pre></li> </ol>
<h2 id="_idParaDest-310" class="calibre7"><a id="_idTextAnchor313" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.498.1">Fetching a single post</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.499.1">Now that we can view a</span><a id="_idIndexMarker937" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.500.1"> list of posts, let’s continue by implementing the process of </span><a id="_idIndexMarker938" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.501.1">fetching a single post for </span><strong class="source-inline"><span class="kobospan" id="kobo.502.1">ViewPostPage</span></strong><span class="kobospan" id="kobo.503.1">. </span><span class="kobospan" id="kobo.503.2">Follow these steps to </span><span><span class="kobospan" id="kobo.504.1">get started:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.505.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.506.1">src/app/posts/[id]/page.js</span></strong><span class="kobospan" id="kobo.507.1"> and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.508.1">notFound</span></strong><span class="kobospan" id="kobo.509.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.510.1">getPostById</span></strong><span class="kobospan" id="kobo.511.1">, and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.512.1">initDatabase</span></strong></span><span><span class="kobospan" id="kobo.513.1"> functions:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.514.1">
import { notFound } from 'next/navigation'
import { getPostById } from '@/data/posts'
import { initDatabase } from '@/db/init'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.515.1">Turn the page component into an </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.516.1">async</span></strong></span><span><span class="kobospan" id="kobo.517.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.518.1">
export default </span><strong class="bold1"><span class="kobospan1" id="kobo.519.1">async</span></strong><span class="kobospan1" id="kobo.520.1"> function ViewPostPage({ params }) {</span></pre></li> <li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.521.1">Replace</span></em><span class="kobospan" id="kobo.522.1"> the sample </span><strong class="source-inline1"><span class="kobospan" id="kobo.523.1">post</span></strong><span class="kobospan" id="kobo.524.1"> object with calls to </span><strong class="source-inline1"><span class="kobospan" id="kobo.525.1">initDatabase</span></strong> <span><span class="kobospan" id="kobo.526.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.527.1">getPostById</span></strong></span><span><span class="kobospan" id="kobo.528.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.529.1">
  await initDatabase()
  const post = await getPostById(params.id)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.530.1">If no post was found, we call the </span><strong class="source-inline"><span class="kobospan" id="kobo.531.1">notFound</span></strong><span class="kobospan" id="kobo.532.1"> function, which throws a </span><strong class="source-inline"><span class="kobospan" id="kobo.533.1">NEXT_NOT_FOUND</span></strong><span class="kobospan" id="kobo.534.1"> error and terminates the rendering of the </span><span><span class="kobospan" id="kobo.535.1">route segment:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.536.1">  if (!post) notFound()</span></pre><p class="calibre3"><span class="kobospan" id="kobo.537.1">Now, we need to create a </span><strong class="source-inline"><span class="kobospan" id="kobo.538.1">not-found.js</span></strong><span class="kobospan" id="kobo.539.1"> file to catch the error and render a different </span><span><span class="kobospan" id="kobo.540.1">component instead.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.541.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.542.1">src/app/posts/[id]/not-found.js</span></strong><span class="kobospan" id="kobo.543.1"> file, where we render a “Post not found!” </span><span class="kobospan" id="kobo.543.2">message, </span><span><span class="kobospan" id="kobo.544.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.545.1">
export default function ViewPostError() {
  return &lt;strong&gt;Post not found!&lt;/strong&gt;
}</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.546.1">Tip</span></p>
<p class="callout"><span class="kobospan" id="kobo.547.1">We can also add an </span><strong class="source-inline1"><span class="kobospan" id="kobo.548.1">app/not-found.js</span></strong><span class="kobospan" id="kobo.549.1"> file to handle unmatched URLs for the whole application. </span><span class="kobospan" id="kobo.549.2">If users access a path that is not defined by the app, the component defined in that file will be </span><span><span class="kobospan" id="kobo.550.1">rendered instead.</span></span></p>
<ol class="calibre15">
<li value="5" class="calibre11"><span class="kobospan" id="kobo.551.1">Additionally, we</span><a id="_idIndexMarker939" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.552.1"> can create an error component that will be rendered for</span><a id="_idIndexMarker940" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.553.1"> any errors, such as not being able to connect to the database. </span><span class="kobospan" id="kobo.553.2">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.554.1">src/app/posts/[id]/error.js</span></strong><span class="kobospan" id="kobo.555.1"> file, where we render an “Error while loading the post!” </span><span class="kobospan" id="kobo.555.2">message, </span><span><span class="kobospan" id="kobo.556.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.557.1">
'use client'
export default function ViewPostError() {
  return &lt;strong&gt;Error while loading the post!&lt;/strong&gt;
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.558.1">Error pages need to be client components, so we added a </span><strong class="source-inline"><span class="kobospan" id="kobo.559.1">'use </span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.560.1">client'</span></strong></span><span><span class="kobospan" id="kobo.561.1"> directive.</span></span></p></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.562.1">Info</span></p>
<p class="callout"><span class="kobospan" id="kobo.563.1">The reason why error pages need to be client components is that they use the React </span><strong class="source-inline1"><span class="kobospan" id="kobo.564.1">ErrorBoundary</span></strong><span class="kobospan" id="kobo.565.1"> feature, which is implemented as class components (using </span><strong class="source-inline1"><span class="kobospan" id="kobo.566.1">componentDidCatch</span></strong><span class="kobospan" id="kobo.567.1">). </span><span class="kobospan" id="kobo.567.2">React class components cannot be server components, so we need to make the error page a </span><span><span class="kobospan" id="kobo.568.1">client component.</span></span></p>
<ol class="calibre15">
<li value="6" class="calibre11"><span class="kobospan" id="kobo.569.1">We still need to make a small adjustment to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.570.1">Post</span></strong><span class="kobospan" id="kobo.571.1"> component because the </span><strong class="source-inline1"><span class="kobospan" id="kobo.572.1">_id</span></strong><span class="kobospan" id="kobo.573.1"> is now actually not a string anymore; instead, it’s an </span><strong class="source-inline1"><span class="kobospan" id="kobo.574.1">ObjectId</span></strong><span class="kobospan" id="kobo.575.1"> object. </span><span class="kobospan" id="kobo.575.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.576.1">src/components/Post.jsx</span></strong><span class="kobospan" id="kobo.577.1"> and change the type, </span><span><span class="kobospan" id="kobo.578.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.579.1">
Post.propTypes = {
  _id: PropTypes.</span><strong class="bold1"><span class="kobospan1" id="kobo.580.1">object</span></strong><span class="kobospan1" id="kobo.581.1">.isRequired,</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.582.1">Make sure Docker and the MongoDB container are </span><span><span class="kobospan" id="kobo.583.1">running properly!</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.584.1">Run the dev server, </span><span><span class="kobospan" id="kobo.585.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.586.1">$ npm run dev</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.587.1">Go to </span><strong class="source-inline1"><span class="kobospan" id="kobo.588.1">http://localhost:3000</span></strong><span class="kobospan" id="kobo.589.1"> and click on one of the posts in the list; you will see that the post loads successfully. </span><span class="kobospan" id="kobo.589.2">If a post does not exist (for example, if you </span><a id="_idIndexMarker941" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.590.1">change a single digit in the ID), the “Post not found!” </span><span class="kobospan" id="kobo.590.2">message will be shown. </span><span class="kobospan" id="kobo.590.3">If there was</span><a id="_idIndexMarker942" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.591.1"> any other error (for example, an invalid ID), the “Error while loading the post!” </span><span class="kobospan" id="kobo.591.2">message will </span><span><span class="kobospan" id="kobo.592.1">be shown:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer147">
<span class="kobospan" id="kobo.593.1"><img alt="Figure 17.4 – Showing a post and the not found/error components" src="image/B19385_17_4.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.594.1">Figure 17.4 – Showing a post and the not found/error components</span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.595.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.596.1">If there are no posts in your database yet, either create a new post by using the blog app from earlier chapters or wait until we implement the create post functionality using Next.js at the end of </span><span><span class="kobospan" id="kobo.597.1">this chapter.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.598.1">After implementing RSCs for fetching posts, our blog app is now connected to the database. </span><span class="kobospan" id="kobo.598.2">However, all it can do right now is show posts; there is no way for the user to interact with the app yet. </span><span class="kobospan" id="kobo.598.3">Let’s move on to making our blog app interactive by adding Server Actions </span><span><span class="kobospan" id="kobo.599.1">to it.</span></span></p>
<h1 id="_idParaDest-311" class="calibre5"><a id="_idTextAnchor314" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.600.1">Using Server Actions to sign up, log in, and create new posts</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.601.1">So far, we have only been fetching data from the database on the server and sending it to the client, but for user interactivity, we need to be able to send data back from the client to the server. </span><span class="kobospan" id="kobo.601.2">To be able to do this, React introduced a pattern called </span><span><span class="kobospan" id="kobo.602.1">Server Actions.</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.603.1">Server Actions</span></strong><span class="kobospan" id="kobo.604.1"> are functions</span><a id="_idIndexMarker943" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.605.1"> that are executed on the server side but can be triggered from the client side, for example, through a form submission. </span><span class="kobospan" id="kobo.605.2">This can be done even with JavaScript disabled on the client, which will then submit the form using regular form submission. </span><span class="kobospan" id="kobo.605.3">When JavaScript is enabled, the form will be progressively enhanced and not require a full refresh to submit. </span><span class="kobospan" id="kobo.605.4">These functions are defined by tagging regular JavaScript functions with the </span><strong class="source-inline"><span class="kobospan" id="kobo.606.1">"use server"</span></strong><span class="kobospan" id="kobo.607.1"> directive, and then either importing them into a client component or passing them to a client component via props. </span><span class="kobospan" id="kobo.607.2">While regular JavaScript functions cannot be passed to client components (because they aren’t serializable), Server Actions </span><span><span class="kobospan" id="kobo.608.1">can be.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.609.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.610.1">You can define a whole file to be full of Server Actions by adding the </span><strong class="source-inline1"><span class="kobospan" id="kobo.611.1">"use server"</span></strong><span class="kobospan" id="kobo.612.1"> directive at the beginning of a file. </span><span class="kobospan" id="kobo.612.2">This will tell the bundler that all functions in this file are Server Actions; it </span><em class="italic"><span class="kobospan" id="kobo.613.1">does not</span></em><span class="kobospan" id="kobo.614.1"> define components inside it as server components (to enforce something to be executed on the server, use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.615.1">server-only</span></strong><span class="kobospan" id="kobo.616.1"> package instead, as explained). </span><span class="kobospan" id="kobo.616.2">You can then import functions from such a file in </span><span><span class="kobospan" id="kobo.617.1">client components.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.618.1">In client components, we can make use of the </span><strong class="source-inline"><span class="kobospan" id="kobo.619.1">useFormState</span></strong><span class="kobospan" id="kobo.620.1"> hook, which has a similar signature to </span><strong class="source-inline"><span class="kobospan" id="kobo.621.1">useState</span></strong><span class="kobospan" id="kobo.622.1"> but allows us to execute server actions (on the server) and get back the result on the client. </span><span class="kobospan" id="kobo.622.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.623.1">useFormState</span></strong><span class="kobospan" id="kobo.624.1"> hook’s signature looks </span><span><span class="kobospan" id="kobo.625.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.626.1">
const [state, formAction] = useFormState(fn, initialState)</span></pre> <p class="callout-heading"><span class="kobospan" id="kobo.627.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.628.1">In the React 19 release, </span><strong class="source-inline1"><span class="kobospan" id="kobo.629.1">useFormState</span></strong><span class="kobospan" id="kobo.630.1"> hook will be renamed to </span><strong class="source-inline1"><span class="kobospan" id="kobo.631.1">useActionState</span></strong><span class="kobospan" id="kobo.632.1">. </span><span class="kobospan" id="kobo.632.2">See </span><a href="https://react.dev/reference/react/useActionState" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.633.1">https://react.dev/reference/react/useActionState</span></a><span class="kobospan" id="kobo.634.1"> for </span><span><span class="kobospan" id="kobo.635.1">more information.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.636.1">As we can see, we pass in a function (Server Action) and an initial state. </span><span class="kobospan" id="kobo.636.2">The hook then returns the current state and a </span><strong class="source-inline"><span class="kobospan" id="kobo.637.1">formAction</span></strong><span class="kobospan" id="kobo.638.1"> function. </span><span class="kobospan" id="kobo.638.2">The state is initially set to the initial state, and updated to the result of the Server Action after the </span><strong class="source-inline"><span class="kobospan" id="kobo.639.1">formAction</span></strong><span class="kobospan" id="kobo.640.1"> function is called. </span><span class="kobospan" id="kobo.640.2">On the server side, the Server Action signature looks </span><span><span class="kobospan" id="kobo.641.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.642.1">
function exampleServerAction(previousState, formData) {
  "use server"
  // …do something…
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.643.1">As we can see, the Server Action function</span><a id="_idIndexMarker944" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.644.1"> accepts </span><strong class="source-inline"><span class="kobospan" id="kobo.645.1">previousState</span></strong><span class="kobospan" id="kobo.646.1"> (which will initially be set to </span><strong class="source-inline"><span class="kobospan" id="kobo.647.1">initialState</span></strong><span class="kobospan" id="kobo.648.1"> from the client) and a </span><strong class="source-inline"><span class="kobospan" id="kobo.649.1">formData</span></strong><span class="kobospan" id="kobo.650.1"> object (which is a regular </span><strong class="source-inline"><span class="kobospan" id="kobo.651.1">formData</span></strong><span class="kobospan" id="kobo.652.1"> object from the XMLHttpRequest API web standard). </span><span class="kobospan" id="kobo.652.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.653.1">formData</span></strong><span class="kobospan" id="kobo.654.1"> object contains all information submitted in form fields. </span><span class="kobospan" id="kobo.654.2">This allows us to easily submit forms to perform an action on the server and return the result to </span><span><span class="kobospan" id="kobo.655.1">the client.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.656.1">Now, let’s start using Server Actions to implement the signup page in our </span><span><span class="kobospan" id="kobo.657.1">blog app.</span></span></p>
<h2 id="_idParaDest-312" class="calibre7"><a id="_idTextAnchor315" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.658.1">Implementing the signup page</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.659.1">The</span><a id="_idIndexMarker945" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.660.1"> first action a user needs to take to interact with the blog app is signing up, so let’s start by implementing this feature. </span><span class="kobospan" id="kobo.660.2">Follow these steps to </span><span><span class="kobospan" id="kobo.661.1">get started:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.662.1">We start by implementing the client component. </span><span class="kobospan" id="kobo.662.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.663.1">src/components/Signup.jsx</span></strong><span class="kobospan" id="kobo.664.1"> and mark it as a client component, then import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.665.1">useFormState</span></strong><span class="kobospan" id="kobo.666.1"> hook </span><span><span class="kobospan" id="kobo.667.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.668.1">PropTypes</span></strong></span><span><span class="kobospan" id="kobo.669.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.670.1">
'use client'
import { useFormState } from 'react-dom'
import PropTypes from 'prop-types'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.671.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.672.1">Signup</span></strong><span class="kobospan" id="kobo.673.1"> component now needs to accept a </span><strong class="source-inline1"><span class="kobospan" id="kobo.674.1">signupAction</span></strong><span class="kobospan" id="kobo.675.1">, which we are going to define on the server </span><span><span class="kobospan" id="kobo.676.1">side later:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.677.1">
export function Signup(</span><strong class="bold1"><span class="kobospan1" id="kobo.678.1">{ signupAction }</span></strong><span class="kobospan1" id="kobo.679.1">) {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.680.1">Define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.681.1">useFormState</span></strong><span class="kobospan" id="kobo.682.1"> hook, which takes a Server Action and an initial state (in our case, an empty object), and returns the current state and </span><span><span class="kobospan" id="kobo.683.1">an action:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.684.1">
  const [state, formAction] = useFormState(signupAction, {})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.685.1">Now, we can add </span><strong class="source-inline1"><span class="kobospan" id="kobo.686.1">action</span></strong><span class="kobospan" id="kobo.687.1"> to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.688.1">&lt;form&gt;</span></strong><span class="kobospan" id="kobo.689.1"> tag, </span><span><span class="kobospan" id="kobo.690.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.691.1">
  return (
    &lt;form </span><strong class="bold1"><span class="kobospan1" id="kobo.692.1">action={formAction}</span></strong><span class="kobospan1" id="kobo.693.1">&gt;</span></pre><p class="calibre3"><span class="kobospan" id="kobo.694.1">The action will automatically be called when the form is submitted. </span><span class="kobospan" id="kobo.694.2">Alternatively, Server Actions can be called by executing them like a regular async function – for example, by calling </span><strong class="source-inline"><span class="kobospan" id="kobo.695.1">await formAction()</span></strong><span class="kobospan" id="kobo.696.1"> inside an </span><strong class="source-inline"><span class="kobospan" id="kobo.697.1">onClick</span></strong> <span><span class="kobospan" id="kobo.698.1">handler function.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.699.1">Additionally, we can show an error message below the “Sign Up” button if we get a </span><strong class="source-inline1"><span class="kobospan" id="kobo.700.1">state.error</span></strong><span class="kobospan" id="kobo.701.1"> message back from </span><span><span class="kobospan" id="kobo.702.1">the server:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.703.1">
      &lt;input type='submit' value='Sign Up' /&gt;
</span><strong class="bold1"><span class="kobospan1" id="kobo.704.1">      {state.error ? </span><span class="kobospan1" id="kobo.704.2">&lt;strong&gt; Error signing up: {state.error}&lt;/strong&gt; : null}</span></strong><span class="kobospan1" id="kobo.705.1">
    &lt;/form&gt;
  )
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.706.1">Let’s not</span><a id="_idIndexMarker946" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.707.1"> forget to define </span><strong class="source-inline1"><span class="kobospan" id="kobo.708.1">propTypes</span></strong><span class="kobospan" id="kobo.709.1"> for the </span><strong class="source-inline1"><span class="kobospan" id="kobo.710.1">Signup</span></strong><span class="kobospan" id="kobo.711.1"> component. </span><strong class="source-inline1"><span class="kobospan" id="kobo.712.1">signupAction</span></strong><span class="kobospan" id="kobo.713.1"> is </span><span><span class="kobospan" id="kobo.714.1">a function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.715.1">
Signup.propTypes = {
  signupAction: PropTypes.func.isRequired,
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.716.1">Now, we can start implementing the actual server action. </span><span class="kobospan" id="kobo.716.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.717.1">src/app/signup/page.js</span></strong><span class="kobospan" id="kobo.718.1"> and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.719.1">redirect</span></strong><span class="kobospan" id="kobo.720.1"> function from </span><strong class="source-inline1"><span class="kobospan" id="kobo.721.1">next/navigation</span></strong><span class="kobospan" id="kobo.722.1"> (to navigate to the login page after successfully signing up), as well as the </span><strong class="source-inline1"><span class="kobospan" id="kobo.723.1">createUser</span></strong><span class="kobospan" id="kobo.724.1"> and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.725.1">initDatabase</span></strong></span><span><span class="kobospan" id="kobo.726.1"> functions:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.727.1">import { redirect } from 'next/navigation'</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.728.1">import { createUser } from '@/data/users'</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.729.1">import { initDatabase } from '@/db/init'</span></strong><span class="kobospan1" id="kobo.730.1">
import { Signup } from '@/components/Signup'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.731.1">Then, outside of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.732.1">SignupPage</span></strong><span class="kobospan" id="kobo.733.1"> component, define a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.734.1">async</span></strong><span class="kobospan" id="kobo.735.1"> function that accepts the previous state (in our case, this is the empty object we defined as the initial state, so we can ignore it) and a </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.736.1">formData</span></strong></span><span><span class="kobospan" id="kobo.737.1"> object:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.738.1">
async function signupAction(prevState, formData) {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.739.1">We need to tag the function with the </span><strong class="source-inline1"><span class="kobospan" id="kobo.740.1">'use server'</span></strong><span class="kobospan" id="kobo.741.1"> directive to turn it into a </span><span><span class="kobospan" id="kobo.742.1">Server Action:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.743.1">
  'use server'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.744.1">Then, we can initialize the database and attempt to create </span><span><span class="kobospan" id="kobo.745.1">a user:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.746.1">
  try {
    await initDatabase()
    await createUser({
      username: formData.get('username'),
      password: formData.get('password'),
    })</span></pre><p class="calibre3"><span class="kobospan" id="kobo.747.1">As you can see, Server Actions </span><a id="_idIndexMarker947" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.748.1">build upon existing web APIs and use the  </span><strong class="source-inline"><span class="kobospan" id="kobo.749.1">FormData</span></strong><span class="kobospan" id="kobo.750.1"> API for form submission. </span><span class="kobospan" id="kobo.750.2">We can simply call </span><strong class="source-inline"><span class="kobospan" id="kobo.751.1">.get()</span></strong><span class="kobospan" id="kobo.752.1"> with the </span><strong class="source-inline"><span class="kobospan" id="kobo.753.1">name</span></strong><span class="kobospan" id="kobo.754.1"> of the input field and it will contain the value provided in the respective </span><span><span class="kobospan" id="kobo.755.1">input field.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.756.1">If there is an error, we return the error message (which will then be shown in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.757.1">Signup</span></strong> <span><span class="kobospan" id="kobo.758.1">client component):</span></span><pre class="source-code"><span class="kobospan1" id="kobo.759.1">
  } catch (err) {
    return { error: err.message }
  }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.760.1">Otherwise, if everything went well, we redirect to the </span><span><span class="kobospan" id="kobo.761.1">login page:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.762.1">
  redirect('/login')
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.763.1">After defining the Server Action, we can pass it to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.764.1">Signup</span></strong><span class="kobospan" id="kobo.765.1"> component, </span><span><span class="kobospan" id="kobo.766.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.767.1">
export default function SignupPage() {
  return &lt;Signup </span><strong class="bold1"><span class="kobospan1" id="kobo.768.1">signupAction={signupAction}</span></strong><span class="kobospan1" id="kobo.769.1"> /&gt;
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.770.1">Alternatively, the client component could directly import the </span><strong class="source-inline"><span class="kobospan" id="kobo.771.1">signupAction</span></strong><span class="kobospan" id="kobo.772.1"> function from a file. </span><span class="kobospan" id="kobo.772.2">So long as the function has the </span><strong class="source-inline"><span class="kobospan" id="kobo.773.1">'use server'</span></strong><span class="kobospan" id="kobo.774.1"> directive, it will be executed on the server. </span><span class="kobospan" id="kobo.774.2">In this case, we only need the function on this specific page, so it makes more sense to define it on the page and pass it to </span><span><span class="kobospan" id="kobo.775.1">the component.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.776.1">Run the dev</span><a id="_idIndexMarker948" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.777.1"> server, </span><span><span class="kobospan" id="kobo.778.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.779.1">$ npm run dev</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.780.1">Go to </span><strong class="source-inline1"><span class="kobospan" id="kobo.781.1">http://localhost:3000/signup</span></strong><span class="kobospan" id="kobo.782.1"> and try entering a username and password. </span><span class="kobospan" id="kobo.782.2">It should work successfully and redirect you to the login screen (the change is subtle, but the submit button changes from </span><strong class="bold"><span class="kobospan" id="kobo.783.1">Sign Up</span></strong><span class="kobospan" id="kobo.784.1"> to </span><span><strong class="bold"><span class="kobospan" id="kobo.785.1">Log In</span></strong></span><span><span class="kobospan" id="kobo.786.1">).</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.787.1">Go to </span><strong class="source-inline1"><span class="kobospan" id="kobo.788.1">http://localhost:3000/signup</span></strong><span class="kobospan" id="kobo.789.1"> again and try entering the same username. </span><span class="kobospan" id="kobo.789.2">You will get the </span><span><span class="kobospan" id="kobo.790.1">following error:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer148">
<span class="kobospan" id="kobo.791.1"><img alt="Figure 17.5 – An error is shown when the username already exists" src="image/B19385_17_5.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.792.1">Figure 17.5 – An error is shown when the username already exists</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.793.1">Of course, this error message is not very user-friendly, so we could do some work to improve the error messages here. </span><span class="kobospan" id="kobo.793.2">But for now, this is sufficient as an example to show how Server </span><span><span class="kobospan" id="kobo.794.1">Actions work.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.795.1">As you can see, RSCs and</span><a id="_idIndexMarker949" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.796.1"> Server Actions make implementing features that interface with the database straightforward. </span><span class="kobospan" id="kobo.796.2">As an additional bonus, all Server Actions that are submitted via </span><strong class="source-inline"><span class="kobospan" id="kobo.797.1">&lt;form&gt;</span></strong><span class="kobospan" id="kobo.798.1"> even work with JavaScript disabled – try it out by repeating </span><em class="italic"><span class="kobospan" id="kobo.799.1">Steps 15</span></em><span class="kobospan" id="kobo.800.1"> and </span><em class="italic"><span class="kobospan" id="kobo.801.1">16</span></em><span class="kobospan" id="kobo.802.1"> with </span><span><span class="kobospan" id="kobo.803.1">JavaScript disabled!</span></span></p>
<h2 id="_idParaDest-313" class="calibre7"><a id="_idTextAnchor316" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.804.1">Implementing the login page and JWT handling</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.805.1">Now that users </span><a id="_idIndexMarker950" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.806.1">can sign up, we need a way for them to log in. </span><span class="kobospan" id="kobo.806.2">This </span><a id="_idIndexMarker951" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.807.1">also means that we will need to implement functionality to create and store JWT. </span><span class="kobospan" id="kobo.807.2">Now that we have more control over the server-client interaction with Next.js, we can store the JWT in a cookie instead of in memory. </span><span class="kobospan" id="kobo.807.3">This means that the user session will persist even when they refresh </span><span><span class="kobospan" id="kobo.808.1">the page.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.809.1">Let’s start implementing the login page and </span><span><span class="kobospan" id="kobo.810.1">JWT handling:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.811.1">We’ll start by implementing the client component. </span><span class="kobospan" id="kobo.811.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.812.1">src/components/Login.jsx</span></strong><span class="kobospan" id="kobo.813.1"> and turn it into a </span><span><span class="kobospan" id="kobo.814.1">client component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.815.1">
'use client'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.816.1">Then, import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.817.1">useFormState</span></strong><span class="kobospan" id="kobo.818.1"> hook </span><span><span class="kobospan" id="kobo.819.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.820.1">PropTypes</span></strong></span><span><span class="kobospan" id="kobo.821.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.822.1">
import { useFormState } from 'react-dom'
import PropTypes from 'prop-types'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.823.1">Accept </span><strong class="source-inline1"><span class="kobospan" id="kobo.824.1">loginAction</span></strong><span class="kobospan" id="kobo.825.1"> as props. </span><span class="kobospan" id="kobo.825.2">We are going to use this to define the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.826.1">useFormState</span></strong></span><span><span class="kobospan" id="kobo.827.1"> hook:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.828.1">
export function Login(</span><strong class="bold1"><span class="kobospan1" id="kobo.829.1">{ loginAction }</span></strong><span class="kobospan1" id="kobo.830.1">) {
</span><strong class="bold1"><span class="kobospan1" id="kobo.831.1">  const [state, formAction] = useFormState(loginAction, {})</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.832.1">Pass </span><strong class="source-inline1"><span class="kobospan" id="kobo.833.1">formAction</span></strong><span class="kobospan" id="kobo.834.1">, which was returned from the hook, to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.835.1">&lt;</span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.836.1">form&gt;</span></strong></span><span><span class="kobospan" id="kobo.837.1"> element:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.838.1">
  return (
    &lt;form </span><strong class="bold1"><span class="kobospan1" id="kobo.839.1">action={formAction}</span></strong><span class="kobospan1" id="kobo.840.1">&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.841.1">Now, we can </span><a id="_idIndexMarker952" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.842.1">display potential errors at the end of </span><a id="_idIndexMarker953" class="calibre6 pcalibre1 pcalibre"/><span><span class="kobospan" id="kobo.843.1">the component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.844.1">
      &lt;input type='submit' value='Log In' /&gt;
</span><strong class="bold1"><span class="kobospan1" id="kobo.845.1">      {state.error ? </span><span class="kobospan1" id="kobo.845.2">&lt;strong&gt; Error logging in: {state.error}&lt;/strong&gt; : null}</span></strong><span class="kobospan1" id="kobo.846.1">
    &lt;/form&gt;
  )
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.847.1">Lastly, define </span><strong class="source-inline1"><span class="kobospan" id="kobo.848.1">propTypes</span></strong><span class="kobospan" id="kobo.849.1">, </span><span><span class="kobospan" id="kobo.850.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.851.1">
Login.propTypes = {
  loginAction: PropTypes.func.isRequired,
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.852.1">Now, we can create the </span><strong class="source-inline1"><span class="kobospan" id="kobo.853.1">loginAction</span></strong><span class="kobospan" id="kobo.854.1"> Server Action. </span><span class="kobospan" id="kobo.854.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.855.1">src/app/login/page.js</span></strong><span class="kobospan" id="kobo.856.1"> and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.857.1">cookies</span></strong><span class="kobospan" id="kobo.858.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.859.1">redirect</span></strong><span class="kobospan" id="kobo.860.1"> functions from Next.js, as well as the </span><strong class="source-inline1"><span class="kobospan" id="kobo.861.1">loginUser</span></strong><span class="kobospan" id="kobo.862.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.863.1">initDatabase</span></strong><span class="kobospan" id="kobo.864.1"> functions from our </span><span><span class="kobospan" id="kobo.865.1">data layer:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.866.1">import { cookies } from 'next/headers'</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.867.1">import { redirect } from 'next/navigation'</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.868.1">import { loginUser } from '@/data/users'</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.869.1">import { initDatabase } from '@/db/init'</span></strong><span class="kobospan1" id="kobo.870.1">
import { Login } from '@/components/Login'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.871.1">Define a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.872.1">loginAction</span></strong><span class="kobospan" id="kobo.873.1"> outside of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.874.1">LoginPage</span></strong><span class="kobospan" id="kobo.875.1"> component, in which we attempt to</span><a id="_idIndexMarker954" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.876.1"> log in with the given username </span><span><span class="kobospan" id="kobo.877.1">and </span></span><span><a id="_idIndexMarker955" class="calibre6 pcalibre1 pcalibre"/></span><span><span class="kobospan" id="kobo.878.1">password:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.879.1">
async function loginAction(prevState, formData) {
  'use server'
  let token
  try {
    await initDatabase()
    token = await loginUser({
      username: formData.get('username'),
      password: formData.get('password'),
    })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.880.1">If this fails, we return the </span><span><span class="kobospan" id="kobo.881.1">error message:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.882.1">
  } catch (err) {
    return { error: err.message }
  }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.883.1">Otherwise, we set an </span><strong class="source-inline1"><span class="kobospan" id="kobo.884.1">AUTH_TOKEN</span></strong><span class="kobospan" id="kobo.885.1"> cookie with an expiry of 24 hours (the same expiry time as the JWT we created), and make it </span><strong class="source-inline1"><span class="kobospan" id="kobo.886.1">secure</span></strong> <span><span class="kobospan" id="kobo.887.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.888.1">httpOnly</span></strong></span><span><span class="kobospan" id="kobo.889.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.890.1">
  cookies().set({
    name: 'AUTH_TOKEN',
    value: token,
    path: '/',
    maxAge: 60 * 60 * 24,
    secure: true,
    httpOnly: true,
  })</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.891.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.892.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.893.1">httpOnly</span></strong><span class="kobospan" id="kobo.894.1"> attribute makes sure cookies cannot be accessed by client JavaScript, reducing the possibility of cross-site scripting attacks in our app. </span><span class="kobospan" id="kobo.894.2">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.895.1">secure</span></strong><span class="kobospan" id="kobo.896.1"> attribute ensures that the cookie is set on the HTTPS version of the website. </span><span class="kobospan" id="kobo.896.2">To improve the development experience, this doesn’t apply </span><span><span class="kobospan" id="kobo.897.1">to localhost.</span></span></p>
<ol class="calibre15">
<li value="11" class="calibre11"><span class="kobospan" id="kobo.898.1">After setting the cookie, we redirect to the </span><span><span class="kobospan" id="kobo.899.1">home page:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.900.1">
  redirect('/')
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.901.1">Finally, we pass the </span><strong class="source-inline1"><span class="kobospan" id="kobo.902.1">loginAction</span></strong><span class="kobospan" id="kobo.903.1"> to the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.904.1">Login</span></strong></span><span><span class="kobospan" id="kobo.905.1"> component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.906.1">
export default function LoginPage() {
  return &lt;Login </span><strong class="bold1"><span class="kobospan1" id="kobo.907.1">loginAction={loginAction}</span></strong><span class="kobospan1" id="kobo.908.1"> /&gt;
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.909.1">Go to </span><strong class="source-inline1"><span class="kobospan" id="kobo.910.1">http://localhost:3000/login</span></strong><span class="kobospan" id="kobo.911.1"> and try entering a username that doesn’t exist; you will get an error. </span><span class="kobospan" id="kobo.911.2">Then, try entering the same username and password that you</span><a id="_idIndexMarker956" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.912.1"> used to sign up earlier. </span><span class="kobospan" id="kobo.912.2">It should work</span><a id="_idIndexMarker957" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.913.1"> successfully and redirect you to the </span><span><span class="kobospan" id="kobo.914.1">home page.</span></span></li>
</ol>
<h2 id="_idParaDest-314" class="calibre7"><a id="_idTextAnchor317" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.915.1">Checking if the user is logged in</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.916.1">You may have</span><a id="_idIndexMarker958" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.917.1"> noticed that after the user logs in, the navigation bar doesn’t change. </span><span class="kobospan" id="kobo.917.2">We still have to check if the user is logged in and then adjust the navigation bar accordingly. </span><span class="kobospan" id="kobo.917.3">Let’s do </span><span><span class="kobospan" id="kobo.918.1">that now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.919.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.920.1">src/app/layout.js</span></strong><span class="kobospan" id="kobo.921.1"> and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.922.1">cookies</span></strong><span class="kobospan" id="kobo.923.1"> function from Next.js and the </span><strong class="source-inline1"><span class="kobospan" id="kobo.924.1">getUserInfoByToken</span></strong><span class="kobospan" id="kobo.925.1"> function from our </span><span><span class="kobospan" id="kobo.926.1">data layer:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.927.1">import { cookies } from 'next/headers'</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.928.1">import { getUserInfoByToken } from '@/data/users'</span></strong><span class="kobospan1" id="kobo.929.1">
import { Navigation } from '@/components/Navigation'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.930.1">Turn </span><strong class="source-inline1"><span class="kobospan" id="kobo.931.1">RootLayout</span></strong><span class="kobospan" id="kobo.932.1"> into an </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.933.1">async</span></strong></span><span><span class="kobospan" id="kobo.934.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.935.1">
export default </span><strong class="bold1"><span class="kobospan1" id="kobo.936.1">async</span></strong><span class="kobospan1" id="kobo.937.1"> function RootLayout({ children }) {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.938.1">Get the </span><strong class="source-inline1"><span class="kobospan" id="kobo.939.1">AUTH_TOKEN</span></strong><span class="kobospan" id="kobo.940.1"> cookie and </span><a id="_idIndexMarker959" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.941.1">pass its value to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.942.1">getUserInfoByToken</span></strong><span class="kobospan" id="kobo.943.1"> function to get the </span><strong class="source-inline1"><span class="kobospan" id="kobo.944.1">user</span></strong><span class="kobospan" id="kobo.945.1"> object, </span><em class="italic"><span class="kobospan" id="kobo.946.1">replacing</span></em><span class="kobospan" id="kobo.947.1"> the sample </span><strong class="source-inline1"><span class="kobospan" id="kobo.948.1">user</span></strong><span class="kobospan" id="kobo.949.1"> object we </span><span><span class="kobospan" id="kobo.950.1">defined earlier:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.951.1">
  const token = cookies().get('AUTH_TOKEN')
  const user = await getUserInfoByToken(token?.value)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.952.1">If you still have the home page open from earlier, it should hot reload automatically and show your username and the </span><span><span class="kobospan" id="kobo.953.1">logout button.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.954.1">We are already passing </span><strong class="source-inline"><span class="kobospan" id="kobo.955.1">user?.username</span></strong><span class="kobospan" id="kobo.956.1"> to the </span><strong class="source-inline"><span class="kobospan" id="kobo.957.1">Navigation</span></strong><span class="kobospan" id="kobo.958.1"> component, so that’s all there is </span><span><span class="kobospan" id="kobo.959.1">to it!</span></span></p>
<h2 id="_idParaDest-315" class="calibre7"><a id="_idTextAnchor318" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.960.1">Implementing logout</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.961.1">Now that we can</span><a id="_idIndexMarker960" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.962.1"> show a different navigation bar when the user is logged in, we can finally see the logout button. </span><span class="kobospan" id="kobo.962.2">However, it doesn’t work yet. </span><span class="kobospan" id="kobo.962.3">We’ll implement the logout </span><span><span class="kobospan" id="kobo.963.1">button now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.964.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.965.1">src/app/layout.js</span></strong><span class="kobospan" id="kobo.966.1"> and define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.967.1">logoutAction</span></strong><span class="kobospan" id="kobo.968.1"> Server Action outside of the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.969.1">RootLayout</span></strong></span><span><span class="kobospan" id="kobo.970.1"> component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.971.1">
async function logoutAction() {
  'use server'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.972.1">Inside this action, we simply delete the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.973.1">AUTH_TOKEN</span></strong></span><span><span class="kobospan" id="kobo.974.1"> cookie:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.975.1">
  cookies().delete('AUTH_TOKEN')
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.976.1">Pass </span><strong class="source-inline1"><span class="kobospan" id="kobo.977.1">logoutAction</span></strong><span class="kobospan" id="kobo.978.1"> to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.979.1">Navigation</span></strong><span class="kobospan" id="kobo.980.1"> component, </span><span><span class="kobospan" id="kobo.981.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.982.1">
          &lt;Navigation
            username={user?.username}
            </span><strong class="bold1"><span class="kobospan1" id="kobo.983.1">logoutAction={logoutAction}</span></strong><span class="kobospan1" id="kobo.984.1">
          /&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.985.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.986.1">src/components/Navigation.jsx</span></strong><span class="kobospan" id="kobo.987.1"> and add </span><strong class="source-inline1"><span class="kobospan" id="kobo.988.1">logoutAction</span></strong><span class="kobospan" id="kobo.989.1"> to </span><strong class="source-inline1"><span class="kobospan" id="kobo.990.1">UserBar</span></strong><span class="kobospan" id="kobo.991.1"> and the </span><span><span class="kobospan" id="kobo.992.1">logout form:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.993.1">
export function UserBar({ username</span><strong class="bold1"><span class="kobospan1" id="kobo.994.1">, logoutAction </span></strong><span class="kobospan1" id="kobo.995.1">}) {
  return (
    &lt;form </span><strong class="bold1"><span class="kobospan1" id="kobo.996.1">action={logoutAction}</span></strong><span class="kobospan1" id="kobo.997.1">&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.998.1">Add the action to </span><strong class="source-inline1"><span class="kobospan" id="kobo.999.1">propTypes</span></strong><span class="kobospan" id="kobo.1000.1"> of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1001.1">UserBar</span></strong><span class="kobospan" id="kobo.1002.1"> component, </span><span><span class="kobospan" id="kobo.1003.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1004.1">
UserBar.propTypes = {
  username: PropTypes.string.isRequired,
</span><strong class="bold1"><span class="kobospan1" id="kobo.1005.1">  logoutAction: PropTypes.func.isRequired,</span></strong><span class="kobospan1" id="kobo.1006.1">
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1007.1">Then, add </span><strong class="source-inline1"><span class="kobospan" id="kobo.1008.1">logoutAction</span></strong><span class="kobospan" id="kobo.1009.1"> as props to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1010.1">Navigation</span></strong><span class="kobospan" id="kobo.1011.1"> component and pass it down </span><a id="_idIndexMarker961" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1012.1">to the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1013.1">UserBar</span></strong></span><span><span class="kobospan" id="kobo.1014.1"> component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1015.1">
export function Navigation({ username</span><strong class="bold1"><span class="kobospan1" id="kobo.1016.1">, logoutAction</span></strong><span class="kobospan1" id="kobo.1017.1"> }) {
  return (
    &lt;&gt;
      &lt;Link href='/'&gt;Home&lt;/Link&gt;
      {username ? </span><span class="kobospan1" id="kobo.1017.2">(
        &lt;UserBar
          username={username}
          </span><strong class="bold1"><span class="kobospan1" id="kobo.1018.1">logoutAction={logoutAction}</span></strong><span class="kobospan1" id="kobo.1019.1">
        /&gt;
      ) : (
        &lt;LoginSignupLinks /&gt;
      )}
    &lt;/&gt;
  )
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1020.1">Finally, change </span><strong class="source-inline1"><span class="kobospan" id="kobo.1021.1">propTypes</span></strong><span class="kobospan" id="kobo.1022.1"> of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1023.1">Navigation</span></strong><span class="kobospan" id="kobo.1024.1"> component, </span><span><span class="kobospan" id="kobo.1025.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1026.1">
Navigation.propTypes = {
  username: PropTypes.string,
</span><strong class="bold1"><span class="kobospan1" id="kobo.1027.1">  logoutAction: PropTypes.func.isRequired,</span></strong><span class="kobospan1" id="kobo.1028.1">
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1029.1">Click the </span><strong class="bold"><span class="kobospan" id="kobo.1030.1">Logout</span></strong><span class="kobospan" id="kobo.1031.1"> button to see the </span><a id="_idIndexMarker962" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1032.1">navigation bar change back to show the </span><strong class="bold"><span class="kobospan" id="kobo.1033.1">Log In</span></strong><span class="kobospan" id="kobo.1034.1"> and </span><strong class="bold"><span class="kobospan" id="kobo.1035.1">Sign </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.1036.1">Up</span></strong></span><span><span class="kobospan" id="kobo.1037.1"> links.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.1038.1">Now, our users can finally log in and log out again successfully. </span><span class="kobospan" id="kobo.1038.2">Let’s move on to implementing </span><span><span class="kobospan" id="kobo.1039.1">post creation.</span></span></p>
<h2 id="_idParaDest-316" class="calibre7"><a id="_idTextAnchor319" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1040.1">Implementing post creation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1041.1">The last feature</span><a id="_idIndexMarker963" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1042.1"> missing in our blog app is post creation. </span><span class="kobospan" id="kobo.1042.2">We can use Server Actions and a JWT to authenticate the user and allow them to create a post. </span><span class="kobospan" id="kobo.1042.3">Follow these steps to implement </span><span><span class="kobospan" id="kobo.1043.1">post creation:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1044.1">This time, we start by implementing the Server Action. </span><span class="kobospan" id="kobo.1044.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.1045.1">src/app/create/page.js</span></strong><span class="kobospan" id="kobo.1046.1"> and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1047.1">cookies</span></strong><span class="kobospan" id="kobo.1048.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.1049.1">redirect</span></strong><span class="kobospan" id="kobo.1050.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.1051.1">createPost</span></strong><span class="kobospan" id="kobo.1052.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.1053.1">getUserIdByToken</span></strong><span class="kobospan" id="kobo.1054.1">, and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1055.1">initDatabase</span></strong></span><span><span class="kobospan" id="kobo.1056.1"> functions:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1057.1">import { cookies } from 'next/headers'</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1058.1">import { redirect } from 'next/navigation'</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1059.1">import { createPost } from '@/data/posts'</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1060.1">import { getUserIdByToken } from '@/data/users'</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1061.1">import { initDatabase } from '@/db/init'</span></strong><span class="kobospan1" id="kobo.1062.1">
import { CreatePost } from '@/components/CreatePost'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1063.1">Inside the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1064.1">CreatePostPage</span></strong><span class="kobospan" id="kobo.1065.1"> component, get the token from </span><span><span class="kobospan" id="kobo.1066.1">the cookie:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1067.1">
export default function CreatePostPage() {
</span><strong class="bold1"><span class="kobospan1" id="kobo.1068.1">  const token = cookies().get('AUTH_TOKEN')</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1069.1">Still inside the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1070.1">CreatePostPage</span></strong><span class="kobospan" id="kobo.1071.1"> component, define a </span><span><span class="kobospan" id="kobo.1072.1">Server Action:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1073.1">
  async function createPostAction(formData) {
    'use server'</span></pre><p class="calibre3"><span class="kobospan" id="kobo.1074.1">We won’t be using the </span><strong class="source-inline"><span class="kobospan" id="kobo.1075.1">useFormState</span></strong><span class="kobospan" id="kobo.1076.1"> hook this time because we don’t need to handle the state or result of the action on the client side. </span><span class="kobospan" id="kobo.1076.2">So, the Server Action does not have the </span><strong class="source-inline"><span class="kobospan" id="kobo.1077.1">(prevState, formData)</span></strong><span class="kobospan" id="kobo.1078.1"> signature and instead has a </span><strong class="source-inline"><span class="kobospan" id="kobo.1079.1">(</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.1080.1">formData)</span></strong></span><span><span class="kobospan" id="kobo.1081.1"> signature.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.1082.1">Inside the </span><a id="_idIndexMarker964" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1083.1">Server Action, we get the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1084.1">userId</span></strong><span class="kobospan" id="kobo.1085.1"> value from the token, then initialize the database connection and create a </span><span><span class="kobospan" id="kobo.1086.1">new post:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1087.1">
    const userId = getUserIdByToken(token?.value)
    await initDatabase()
    const post = await createPost(userId, {
      title: formData.get('title'),
      contents: formData.get('contents'),
    })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1088.1">Lastly, we redirect to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1089.1">ViewPost</span></strong><span class="kobospan" id="kobo.1090.1"> page of the newly </span><span><span class="kobospan" id="kobo.1091.1">created post:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1092.1">
    redirect(`/posts/${post._id}`)
  }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1093.1">If the user isn’t logged in, we can now show an </span><span><span class="kobospan" id="kobo.1094.1">error message:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1095.1">
  if (!token?.value) {
    return &lt;strong&gt;You need to be logged in to create posts!&lt;/strong&gt;
  }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1096.1">Otherwise, we render the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1097.1">CreatePost</span></strong><span class="kobospan" id="kobo.1098.1"> component, passing </span><strong class="source-inline1"><span class="kobospan" id="kobo.1099.1">createPostAction</span></strong> <span><span class="kobospan" id="kobo.1100.1">to it:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1101.1">
  return &lt;CreatePost </span><strong class="bold1"><span class="kobospan1" id="kobo.1102.1">createPostAction={createPostAction}</span></strong><span class="kobospan1" id="kobo.1103.1"> /&gt;
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1104.1">Now, we can adjust the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1105.1">CreatePost</span></strong><span class="kobospan" id="kobo.1106.1"> component. </span><span class="kobospan" id="kobo.1106.2">We </span><em class="italic"><span class="kobospan" id="kobo.1107.1">don’t</span></em><span class="kobospan" id="kobo.1108.1"> need to turn it into a client component this time because we won’t be using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1109.1">useFormState</span></strong><span class="kobospan" id="kobo.1110.1"> hook. </span><span class="kobospan" id="kobo.1110.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.1111.1">src/components/CreatePost.jsx</span></strong><span class="kobospan" id="kobo.1112.1"> and </span><span><span class="kobospan" id="kobo.1113.1">import </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1114.1">PropTypes</span></strong></span><span><span class="kobospan" id="kobo.1115.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1116.1">
import PropTypes from 'prop-types'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1117.1">Then, add the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1118.1">createPostAction</span></strong><span class="kobospan" id="kobo.1119.1"> as props and</span><a id="_idIndexMarker965" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1120.1"> pass it to the </span><span><span class="kobospan" id="kobo.1121.1">form element:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1122.1">
export function CreatePost(</span><strong class="bold1"><span class="kobospan1" id="kobo.1123.1">{ createPostAction }</span></strong><span class="kobospan1" id="kobo.1124.1">) {
  return (
    &lt;form </span><strong class="bold1"><span class="kobospan1" id="kobo.1125.1">action={createPostAction}</span></strong><span class="kobospan1" id="kobo.1126.1">&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1127.1">Finally, define </span><strong class="source-inline1"><span class="kobospan" id="kobo.1128.1">propTypes</span></strong><span class="kobospan" id="kobo.1129.1">, </span><span><span class="kobospan" id="kobo.1130.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1131.1">
CreatePost.propTypes = {
  createPostAction: PropTypes.func.isRequired,
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1132.1">Go to </span><strong class="source-inline1"><span class="kobospan" id="kobo.1133.1">http://localhost:3000</span></strong><span class="kobospan" id="kobo.1134.1">, log in again, and then click the </span><strong class="bold"><span class="kobospan" id="kobo.1135.1">Create Post</span></strong><span class="kobospan" id="kobo.1136.1"> link. </span><span class="kobospan" id="kobo.1136.2">Enter a title and some</span><a id="_idIndexMarker966" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1137.1"> contents and click the </span><strong class="bold"><span class="kobospan" id="kobo.1138.1">Create</span></strong><span class="kobospan" id="kobo.1139.1"> button; you should get redirected to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1140.1">ViewPost</span></strong><span class="kobospan" id="kobo.1141.1"> page of the newly created </span><span><span class="kobospan" id="kobo.1142.1">blog post!</span></span></li>
</ol>
<h1 id="_idParaDest-317" class="calibre5"><a id="_idTextAnchor320" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1143.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1144.1">In this chapter, we learned about RSCs, why they were introduced, what their advantages are, and how they fit into our full-stack architecture. </span><span class="kobospan" id="kobo.1144.2">Then, we learned how to safely implement RSCs by introducing a data layer into our app. </span><span class="kobospan" id="kobo.1144.3">Afterward, we fetched data from our database and rendered components using RSCs. </span><span class="kobospan" id="kobo.1144.4">Finally, we learned about Server Actions and added interactive features to our blog app. </span><span class="kobospan" id="kobo.1144.5">Now, our blog app is fully </span><span><span class="kobospan" id="kobo.1145.1">functional again!</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1146.1">In the next chapter, </span><a href="B19385_18.xhtml#_idTextAnchor321" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.1147.1">Chapter 18</span></em></span></a><span class="kobospan" id="kobo.1148.1">, </span><em class="italic"><span class="kobospan" id="kobo.1149.1">Advanced Next.js Concepts and Optimizations</span></em><span class="kobospan" id="kobo.1150.1">, we are going to dive deep into how Next.js works and how we can further optimize our app when using it. </span><span class="kobospan" id="kobo.1150.2">We are going to learn about caching, image and font optimizations, and how to define metadata for </span><span><span class="kobospan" id="kobo.1151.1">SEO optimization.</span></span></p>
</div>
</body></html>