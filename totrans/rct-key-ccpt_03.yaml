- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components and Props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Build reusable React components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize a concept called **props** to make components configurable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build flexible user interfaces by combining components with props
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, you learned about the key building block of any React-based
    user interface: **components** . You learned why components matter, how they are
    used, and how you can build components yourself.'
  prefs: []
  type: TYPE_NORMAL
- en: You also learned about JSX, which is the HTML-like markup that’s typically returned
    by component functions. It’s this markup that defines what should be rendered
    on the final web page (in other words, which HTML markup should end up on the
    final web page that is being served to visitors).
  prefs: []
  type: TYPE_NORMAL
- en: Can Components Do More?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, so far, those components haven’t been too useful. While you could use
    them to split your web page content into smaller building blocks, the actual reusability
    of these components was pretty limited. For example, every course goal that you
    might have as part of an overall course goal list would go into its own component
    (if you decided to split your web page content into multiple components in the
    first place).
  prefs: []
  type: TYPE_NORMAL
- en: If you think about it, this isn’t too helpful; it would be much better if different
    list items could share one common component and you just configured that one component
    with different content or attributes—just like how HTML works.
  prefs: []
  type: TYPE_NORMAL
- en: 'When writing plain HTML code and describing content with it, you use reusable
    HTML elements and configure them with different content or attributes. For example,
    you have one `<a>` HTML element, but thanks to the `href` attribute and the element
    child content, you can build an endless amount of different anchor elements that
    point at different resources, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These two elements use the exact same HTML element ( `<a>` ) but lead to totally
    different links that would end up on the web page (pointing to two totally different
    websites).
  prefs: []
  type: TYPE_NORMAL
- en: To fully unlock the potential of React components, it would, therefore, be very
    useful if you could configure them just like regular HTML elements. And it turns
    out that you can do exactly that—with another key React concept called **props**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Using Props in Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do you use props in your components? And when do you need them?
  prefs: []
  type: TYPE_NORMAL
- en: The second question will be answered in greater detail a little bit later. For
    the moment, it’s enough to know that you typically will have some components that
    are reusable and, therefore, need props and some components that are unique and
    might not need props.
  prefs: []
  type: TYPE_NORMAL
- en: 'The “how” part of the question is the more important part at this point, and
    this part can be split into two complementary problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Passing props to components
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consuming props in a component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Passing Props to Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How would you want props and component configurability to work if you were to
    design React from the ground up?
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there would be a broad variety of possible solutions, but there
    is one great role model that can be considered: HTML. As mentioned above, when
    working with HTML, you pass content and configuration either between element tags
    or via attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, React components work just like HTML elements when it comes to
    configuring them. Props are simply passed as attributes (to your component) or
    as child data between component tags, and you can also mix both approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<Product id="abc1" price="12.99" />`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<FancyLink target="https://some-website.com">Click me</FancyLink>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this reason, configuring components is quite straightforward—at least, if
    you look at them from the consumer’s angle (in other words, at how you use them
    in JSX).
  prefs: []
  type: TYPE_NORMAL
- en: Consuming Props in a Component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How can you get access to the prop values passed into a component, when writing
    that component’s inner code?
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you’re building a `GoalItem` component that is responsible for outputting
    a single goal item (for example, a course goal or project goal) that will be part
    of an overall goals list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parent component JSX markup could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Inside `GoalItem` , the goal (no pun intended) would be to accept different
    goal titles so that the same component ( `GoalItem` ) can be used to output these
    different titles as part of the final list that’s displayed to website visitors.
    Maybe the component should also accept another piece of data (for example, a unique
    ID that is used internally).
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s how the `GoalItem` component could be used in JSX, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `GoalItem` component function, the plan would probably be to output
    dynamic content (in other words, the data received via props) like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'But this component function would not work. It has a problem: `title` and `id`
    are never defined inside that component function. This code would, therefore,
    cause an error because you’re using a variable that wasn’t defined.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, these shouldn’t be defined inside the `GoalItem` component anyway,
    as the idea was to make the `GoalItem` component reusable and receive different
    `title` and `id` values *from outside the component* (i.e., from the component
    that renders the list of `<GoalItem>` components).
  prefs: []
  type: TYPE_NORMAL
- en: 'React provides a solution for this problem: a special parameter value that
    is passed into every component function automatically by React. This is a special
    parameter that contains the extra configuration data that is set on the component
    in JSX code, called the `props` parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding component function could (and should) be rewritten like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The name of the parameter ( `props` ) is up to you, but using `props` as a name
    is a convention because the overall concept is called **props** .
  prefs: []
  type: TYPE_NORMAL
- en: To understand this concept, it is important to keep in mind that these component
    functions are not called by you somewhere else in your code and that, instead,
    React will call these functions on your behalf. And since React calls these functions,
    it can pass extra arguments into them when calling them.
  prefs: []
  type: TYPE_NORMAL
- en: This `props` argument is indeed such an extra argument. React will pass it into
    every component function, irrespective of whether you defined it as an extra parameter
    in the component function definition. However, if you didn’t define that `props`
    parameter in a component function, you, of course, won’t be able to work with
    the `props` data in that component.
  prefs: []
  type: TYPE_NORMAL
- en: This automatically provided `props` argument will always contain an object (because
    React passes an object as a value for this argument), and the properties of this
    object will be the “attributes” you added to your component (such as the `title`
    or `id` ) inside the JSX code where the component is used.
  prefs: []
  type: TYPE_NORMAL
- en: That’s why in this `GoalItem` component example, custom data can be passed via
    attributes ( `<GoalItem id="g1" … />` ) and consumed via the `props` object and
    its properties ( `<li>{props.title}</li>` ).
  prefs: []
  type: TYPE_NORMAL
- en: Components, Props, and Reusability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks to this props concept, components become *actually* reusable, instead
    of just being *theoretically* reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Outputting three `<GoalItem>` components without any extra configuration could
    only render the same goal three times, since the goal text (and any other data
    you might need) would have to be hardcoded into the component function.
  prefs: []
  type: TYPE_NORMAL
- en: By using props as described above, the same component can be used multiple times
    with different configurations. That allows you to define some general markup structure
    and logic once (in the component function) but then use it as often as needed
    with different configurations.
  prefs: []
  type: TYPE_NORMAL
- en: And if that sounds familiar, that is indeed exactly the same idea that applies
    to regular JavaScript (or any other programming language) functions. You define
    logic once, and you can then call it multiple times with different inputs to receive
    different results. It’s the same for components—at least when embracing this props
    concept.
  prefs: []
  type: TYPE_NORMAL
- en: The Special “children” Prop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It was mentioned before that React passes this `props` object automatically
    into component functions. That is indeed the case, and as described, this object
    contains all the attributes you set on the component (in JSX) as properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'But React does not just package your attributes into this object; it also adds
    another extra property to the `props` object: the special `children` property
    (a built-in property whose name is fixed, meaning you can’t change it).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `children` property holds a very important piece of data: the content you
    might have provided between the component’s opening and closing tags.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus far, in the examples shown above, the components were mostly self-closing.
    `<GoalItem id="…" title="…" />` holds no content between the component tags. All
    the data is passed into the component via attributes.
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing wrong with this approach. You can configure your components
    with attributes only. But for some pieces of data and some components, it might
    make more sense and be more logical to actually stick to regular HTML conventions,
    passing that data between the component tags instead. And the `GoalItem` component
    is actually a great example.
  prefs: []
  type: TYPE_NORMAL
- en: Which approach looks more intuitive?
  prefs: []
  type: TYPE_NORMAL
- en: '`<GoalItem id="g1" title="Learn React" />`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`<GoalItem id="g1">Learn React</GoalItem>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You might determine that the second option looks a bit more intuitive and in
    line with regular HTML because, there, you would also configure a normal list
    item like this: `<li id="li1">Some list item</li>` .'
  prefs: []
  type: TYPE_NORMAL
- en: While you have no choice when working with regular HTML elements (you can’t
    add a `goal` attribute to a `<li>` just because you want to), you do have a choice
    when working with React and your own components. It simply depends on how you
    consume props inside the component function. Both approaches can work, depending
    on the internal component code.
  prefs: []
  type: TYPE_NORMAL
- en: Still, you might want to pass certain pieces of data between component tags,
    and the special `children` property allows you to do just that. It contains any
    content you define between the component opening and closing tags. Therefore,
    in the case of example 2 (in the list above), `children` would contain the string
    `"Learn React"` .
  prefs: []
  type: TYPE_NORMAL
- en: 'In your component function, you can work with the `children` value just as
    you work with any other prop value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Which Components Need Props?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It was mentioned before, but it is extremely important: **props are optional!**'
  prefs: []
  type: TYPE_NORMAL
- en: React will always pass **prop** data into your components, but you don’t have
    to work with that `prop` parameter. You don’t even have to define it in your component
    function if you don’t plan on working with it.
  prefs: []
  type: TYPE_NORMAL
- en: There is no hard rule that would define which components need **props** and
    which don’t. It comes with experience and simply depends on the role of a component.
  prefs: []
  type: TYPE_NORMAL
- en: You might have a general `Header` component that displays a static header (with
    a logo, title, and so on), and such a component probably needs no external configuration
    (in other words, no “attributes” or other kinds of data passed into it). It could
    be self-contained, with all the required values hardcoded into the component.
  prefs: []
  type: TYPE_NORMAL
- en: But you will also often build and use components like the `GoalItem` component
    (in other words, components that do need external data to be useful). Whenever
    a component is used more than once in your React app, there is a high chance that
    it will utilize props. However, the opposite is not necessarily true. While you
    will have one-time components that don’t use props, you will absolutely also have
    components that are only used once in the entire app and still take advantage
    of props. As previously mentioned, it depends on the exact use case and component.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, you will see plenty of examples and exercises that will
    help you gain a deeper understanding of how to build components and use props.
  prefs: []
  type: TYPE_NORMAL
- en: How to Deal with Multiple Props
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As shown in the preceding examples, you are not limited to only one prop per
    component. Indeed, you can pass and use as many props as your component needs—no
    matter if that’s 1 or 100 (or more) props.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you do create components with more than just two or three props, a new
    question might come up: do you have to add all those props individually (in other
    words, as separate attributes), or can you pass fewer attributes that contain
    grouped data, such as arrays or objects?'
  prefs: []
  type: TYPE_NORMAL
- en: And indeed, you can. React allows you to pass arrays and objects as prop values
    as well. In fact, any valid JavaScript value can be passed as a prop value!
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows you to decide whether you want to have a component with 20 individual
    props (“attributes”) or just one “big” prop. Here’s an example of where the same
    component is configured in two different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the component must also be adapted internally (in other words, in
    the component function) to expect either individual or grouped props. But since
    you’re the developer, that is, of course, your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the component function, you can also make your life easier.
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing wrong with accessing prop values via `props.XYZ` , but if you
    have a component that receives multiple props, repeating `props.XYZ` over and
    over again could become cumbersome and make the code a bit harder to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use a default JavaScript feature to improve readability: **object destructuring**
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Object destructuring allows you to extract values from an object and assign
    those values to variables or constants in a single step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can, therefore, use this syntax to extract all prop values and assign them
    to equally named variables directly at the start of your component function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You don’t have to use this syntax, but it can make your life easier.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on object destructuring, MDN is a great place to dive deeper.
    You can access this at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Spreading Props
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine you’re building a custom component that should act as a “wrapper” around
    some other component—a built-in component, perhaps.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, you could be building a custom `Link` component that should return
    a standard `<a>` element with some custom styling or logic added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This very simple example component returns a pre-configured `<a>` element. This
    custom `Link` component configures the anchor element such that new pages are
    always opened in a new tab. In place of the standard `<a>` element, you could
    use this `Link` component in your React app to get that behavior out of the box
    for all your links.
  prefs: []
  type: TYPE_NORMAL
- en: 'But this custom component suffers from a problem: it’s a wrapper around a core
    element, but by creating your own component, you remove the configurability of
    that core element. If you were to use this `Link` component in your app, how would
    you set the `href` prop to configure the link destination?'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: However, this example code wouldn’t work because `Link` doesn’t accept or use
    a `href` prop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you could adjust the `Link` component function such that a `href`
    prop is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: But what if you also wanted to ensure that the `download` prop could be added
    if needed?
  prefs: []
  type: TYPE_NORMAL
- en: Well, it’s true that you can always accept more and more props (and pass them
    on to the `<a>` element inside your component), but this reduces the reusability
    and maintainability of your custom component.
  prefs: []
  type: TYPE_NORMAL
- en: A better solution is to use the standard JavaScript **spread operator** (i.e.,
    the `...` operator) and React’s support for that operator when working with components.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following component code is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `config` is expected to be a JavaScript object (i.e., a collection
    of key-value pairs). The spread operator ( `...` ), when used in JSX code on a
    JSX element, converts that object into multiple props.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example `config` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, when spreading it on `<a>` , (i.e., `<a {…config}>` ), the result
    would be the same as if you had written this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative, more common pattern uses yet another JavaScript feature: the
    **rest property** . That’s a JavaScript pattern that allows you to group properties
    that have not been destructured into a new object (which then only contains those
    properties).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, when destructuring props, only the `children` prop is destructured;
    the other ones are stored in a new object named `props` . The syntax is very similar
    to the spread operator syntax: you use three dots ( `...` ). But here, you use
    the operator in front of the property that should contain all remaining properties.
    Therefore, it’s the place where you use that operator that defines what it does.'
  prefs: []
  type: TYPE_NORMAL
- en: You can then use that rest property ( `props` in the example) like any other
    object. In the example above, it’s again used to spread its properties as props
    onto the `<a>` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this pattern allows you to use the `Link` component in a more natural
    way, where you don’t have to create and use a separate configuration object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: These behaviors and patterns can be used to build reusable components that should
    still maintain the configurability of the core element they may be wrapping. This
    helps you avoid long lists of pre-defined, accepted props and improves the reusability
    of components.
  prefs: []
  type: TYPE_NORMAL
- en: Prop Chains/Prop Drilling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is one last phenomenon that is worth noting when learning about props:
    **prop drilling** or **prop chains** .'
  prefs: []
  type: TYPE_NORMAL
- en: It’s a problem every React developer will encounter at some point. It occurs
    when you build a slightly more complex React app that contains multiple layers
    of nested components that need to send data to each other.
  prefs: []
  type: TYPE_NORMAL
- en: For example, assume that you have a `NavItem` component that should output a
    navigation link. Inside that component, you might have another nested component,
    `AnimatedLink` , that outputs the actual link (maybe with some nice animation
    styling).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NavItem` component could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And `AnimatedLink` could be defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `target` prop is passed through the `NavItem` component
    to the `AnimatedLink` component. The `NavItem` component must accept the `target`
    prop because it must be passed on to `AnimatedLink` .
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s what prop drilling/prop chains is all about: you forward a prop from
    a component that doesn’t really need it to another component that *does* need
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: Having some prop drilling in your app isn’t necessarily bad, and you can definitely
    accept it. But, if you should end up with longer chains of props (in other words,
    multiple **pass-through components** ), you can use a solution that will be discussed
    in *Chapter 11* , *Working with Complex States* .
  prefs: []
  type: TYPE_NORMAL
- en: Summary and Key Takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Props are a key React concept that make components configurable and, therefore,
    reusable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Props are automatically collected and passed into component functions by React.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You decide (on a per-component basis) whether you want to use the props data
    (an object) or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Props are passed into components like attributes or, via the special `children`
    prop, between the opening and closing tags.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use JavaScript features like destructuring, the rest property, or the
    spread operator to write concise, flexible code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since you are writing the code, it’s up to you how you want to pass data via
    props. Between the tags or as attributes? A single grouped attribute or many single-value
    attributes? It’s up to you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s Next?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Props allow you to make components configurable and reusable. Still, they are
    rather static. Data and, therefore, the UI output doesn’t change. You can’t react
    to user events like button clicks.
  prefs: []
  type: TYPE_NORMAL
- en: But the true power of React only becomes visible once you do add events (and
    reactions to them).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how you can add event listeners when working
    with React, and you will learn how you can react (no pun intended) to events and
    change the (invisible and visible) state of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Test Your Knowledge!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your knowledge regarding the concepts covered in this chapter by answering
    the following questions. You can then compare your answers to the example answers
    that can be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/03-components-props/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/03-components-props/exercises/questions-answers.md)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: Which “problem” do props solve?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are props passed into components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are props consumed inside of a component function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which options exist for passing (multiple) props into components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply What You Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this and the previous chapters, you now have enough basic knowledge to
    build truly reusable components.
  prefs: []
  type: TYPE_NORMAL
- en: Below, you will find an activity that allows you to apply all the knowledge,
    including the new props knowledge, you have acquired so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 3.1: Creating an App to Output Your Goals for This Book'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This activity builds upon *Activity 2.2* , *Creating a React App to Log Your
    Goals for This Book* , from the previous chapter. If you followed along there,
    you can use your existing code and enhance it by adding props. Alternatively,
    you can also use the solution provided as a starting point that is accessible
    at the following link: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/02-components-jsx/activities/practice-2](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/02-components-jsx/activities/practice-2)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this activity is to build reusable `GoalItem` components that can
    be configured via props. Every `GoalItem` component should receive and output
    a goal title and a short description text, with extra information about the goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Complete the second activity from the previous chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the hardcoded goal item components with a new configurable component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output multiple goal components with different titles (via props).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the detailed text description for every goal between the goal component’s
    opening and closing tags.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final user interface might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_03_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: The final result: multiple goals output below each other'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a full example solution here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/03-components-props/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/03-components-props/activities/practice-1)
    .'
  prefs: []
  type: TYPE_NORMAL
