<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Docker and the EC2 Container Service</h1>
            

            <article>
                
<p class="calibre2">We have done all the stuff related to database-as-a-backend with mLab. The publishing application should be working 100 percent remotely on the mLab MongoDB instance, so you don't need to run the <kbd class="calibre11">mongod</kbd> command anymore.</p>
<p class="calibre2">It's time to prepare our Docker container and deploy it on EC2 completely with the use of ECS (EC2 Container Service) and load balancers.</p>
<p class="calibre2">What is Docker? It's a very useful piece of software that is open source and helps you pack, ship, and run any app as a light (in comparison to a virtual machine, for example) container.</p>
<p class="calibre2">A container's goals are similar to virtual machines--the big difference is that Docker was created with software development in mind, as opposed to VMs. You need to also be aware that a fully virtualized system has its own resources allocated to it, which causes minimal resource sharing, which is different for Docker containers. Of course, in VMs, you get more isolation, but the cost is that the VMs are much heavier (requiring more disk space, RAM, and other resources). Docker's containers are lightweight and are able to share more things among different containers in comparison to VMs.</p>
<p class="calibre2">The good part is that Docker's containers are hardware and platform independent, so all worries about whether what you are working on will run everywhere are disappearing.</p>
<p class="calibre2">Generally, Docker's benefits are that it increases developers' productivity, helps them ship software faster, helps move the software from local development machines to production deployments on AWS, and so on. Docker also allows versioning (similar to Git) of your software, which can be helpful when you need a quick rollback on the production server.</p>
<p class="calibre2">In this chapter, you will learn the following things:</p>
<ul class="calibre14">
<li class="calibre15">Installing the Docker app on your machine with Docker Toolbox on non-Linux machines</li>
<li class="calibre15">Testing whether your Docker setup is correct</li>
<li class="calibre15">Preparing the publishing app in order to use mLab Mongo for the database</li>
<li class="calibre15">Creating a new Docker container for the publishing app</li>
<li class="calibre15">Creating your first Dockerfile, which will deploy the publishing app on Linux CentOS</li>
<li class="calibre15">EC2 Container Service</li>
<li class="calibre15">AWS load balancers</li>
<li class="calibre15">Using Amazon Route 53 for DNS services</li>
<li class="calibre15">AWS identity and access management (IAM)</li>
</ul>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Docker installation with Docker Toolbox</h1>
            

            <article>
                
<p class="calibre2">Installing Docker is quite easy. Visit the official installation page at <a href="https://docs.docker.com/engine/installation/" class="calibre6"><span>https://docs.docker.com/engine/installation/</span></a> because it will guide you best depending on your operating system. There are easy-to-follow installers for iOS and Windows and a lot of instructions for different Linux distributions.</p>
<p class="calibre2">If you are using a non-Linux machine, then you also need to install Docker Toolbox for Windows or OS X. This is quite simple with its installers, which are available at <a href="https://www.docker.com/products/docker-toolbox" class="calibre6"><span>https://www.docker.com/products/docker-toolbox</span></a>, as shown in the following screenshot:</p>
<div class="packt_figure"><img class="image-border89" src="../images/00094.jpeg"/></div>
<div class="packt_infobox">
<p class="calibre31">If you are using Linux, there are some extra steps to be performed as you need to turn on virtualization in BIOS:</p>
<ul class="calibre32">
<li class="calibre33">Install the Docker machine with instructions from the official docs at <span class="packt_screen"><a href="https://docs.docker.com/machine/install-machine/" class="calibre27">https://docs.docker.com/machine/install-machine/<br class="calibre24"/></a></span></li>
<li class="calibre33">For Ubuntu, you need to install VirtualBox manually from <a href="https://help.ubuntu.com/community/VirtualBox" class="calibre27">https://help.ubuntu.com/community/VirtualBox</a><a href="https://docs.docker.com/machine/install-machine/" class="calibre27"> <br class="calibre24"/></a></li>
<li class="calibre33">For other Linux distributions visit <a href="https://www.virtualbox.org/wiki/Linux_Downloads" class="calibre27"><span class="packt_screen">https://www.virtualbox.org/wiki/Linux_Downloads</span></a></li>
</ul>
</div>
<p class="calibre2">After you have installed Docker (together with Toolbox on OS X and Windows) on your local machine, run in the Terminal the following command:</p>
<pre class="calibre22">
<strong class="calibre1">$ docker info</strong>
</pre>
<p class="calibre2">After you run this command, you will be able to see something similar to the following screenshot:</p>
<div class="packt_figure"><img class="image-border90" src="../images/00095.jpeg"/></div>
<p class="calibre2">If you can see something like this, then your installation is successful. Let's continue with Docker.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Docker Hub - an hello world example</h1>
            

            <article>
                
<p class="calibre2">Before we start creating the publishing app's Docker container, let's start playing with an official Docker <em class="calibre21">hello world</em> example that will make you aware of how the Docker Hub works.</p>
<p class="calibre2">Docker Hub is to Docker containers as GitHub is to Git's repositories. You can have public and private containers in Docker. The main page of Docker Hub look like this:</p>
<div class="packt_figure"><img class="image-border91" src="../images/00096.jpeg"/></div>
<p class="calibre2">Just to give you a feel for it, if you visit <a href="https://hub.docker.com/explore/" class="calibre6"><span>https://hub.docker.com/explore/</span></a>, you can see different containers that are ready for use, like this, for example:</p>
<div class="packt_figure"><img class="image-border92" src="../images/00097.jpeg"/></div>
<p class="calibre2">Just for our demo exercise, we will use a container called <kbd class="calibre11">hello world</kbd>, which is publicly available at <a href="https://hub.docker.com/r/library/hello-world/" class="calibre6"><span>https://hub.docker.com/r/library/hello-world/</span></a>.</p>
<p class="calibre2">In order to run this <kbd class="calibre11">hello-world</kbd> example, run the following in your Terminal:</p>
<pre class="calibre22">
<strong class="calibre1">$ docker run hello-world</strong>
</pre>
<p class="calibre2">After you run this, you will see something similar to the following:</p>
<div class="packt_figure"><img class="image-border93" src="../images/00098.jpeg"/></div>
<p class="calibre2">Let's understand what's just happened: we use the <kbd class="calibre11">docker run</kbd> command in order to start the container based on an image (in our example, we have used the hello world container image). In this case, we do the following:</p>
<ol class="calibre17">
<li value="1" class="calibre15">Run the command that tells Docker to start the container named <kbd class="calibre11">hello-world</kbd> with no extra commands.</li>
<li value="2" class="calibre15">After you hit <span>Enter</span>, Docker will download Docker Hub.</li>
<li value="3" class="calibre15">Then it will start the container in the VM, using Docker Toolbox on non-Linux systems.</li>
</ol>
<p class="calibre2">The <kbd class="calibre11">hello-world</kbd> image comes from the public registry called Docker Hub as mentioned before (which you can visit at <a href="https://hub.docker.com/r/library/hello-world/" class="calibre6"><span>https://hub.docker.com/r/library/hello-world/</span></a>).</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Dockerfile example</h1>
            

            <article>
                
<p class="calibre2">Every image is composed of a Dockerfile. An example Dockerfile for the <kbd class="calibre11">hello-world</kbd> example looks like the following:</p>
<pre class="calibre22">
// source: https://github.com/docker-library/hello-world/blob/master/Dockerfile <br class="title-page-name"/>FROM scratch <br class="title-page-name"/>COPY hello / <br class="title-page-name"/>CMD ["/hello"]
</pre>
<p class="calibre2">A Dockerfile is a set of instructions that tell Docker how to build a container image. We will create our own in a moment. An analogy for a Dockerfile can be the Bash language that you can use on any Linux/Unix machine. Of course, it's different, but the general idea of writing instructions to create the job is similar.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Modifications to our codebase in order to create it</h1>
            

            <article>
                
<p class="calibre2">Currently, we are sure that our Docker application's setup is working correctly.</p>
<p class="calibre2">First of all, we need to make some modifications to our current codebase as there are small tweaks to make it work properly.</p>
<p class="calibre2">Make sure that the following files have the proper content.</p>
<p class="calibre2">The <kbd class="calibre11">server/.env</kbd> file's content has to be as follows:</p>
<pre class="calibre22">
AWS_ACCESS_KEY_ID=&lt;&lt;___AWS_ACCESS_KEY_ID__&gt;&gt; <br class="title-page-name"/>AWS_SECRET_ACCESS_KEY=&lt;&lt;___AWS_SECRET_ACCESS_KEY__&gt;&gt; <br class="title-page-name"/>AWS_BUCKET_NAME=publishing-app <br class="title-page-name"/>AWS_REGION_NAME=eu-central-1 <br class="title-page-name"/>MONGO_USER=&lt;&lt;___your_mlab_mongo_user__&gt;&gt; <br class="title-page-name"/>MONGO_PASS=&lt;&lt;___your_mlab_mongo_pass__&gt;&gt; <br class="title-page-name"/>MONGO_PORT=&lt;&lt;___your_mlab_mongo_port__&gt;&gt; <br class="title-page-name"/>MONGO_ENV=publishingapp <br class="title-page-name"/>MONGO_HOSTNAME=&lt;&lt;___your_mlab_mongo_hostname__&gt;&gt;
</pre>
<div class="packt_infobox">For now, we will load the environment variables from a file, but later we will load them from the AWS panel. It's not really production-secure to keep all that secret data on the server. We use it now for the sake of brevity; later, we'll delete it in favor of a more secure approach.</div>
<p class="calibre2">Regarding the Mongo environment variables, we learned them in the previous chapter about setting up mLab (get to back to the chapter if you missed any of the details required at this point).</p>
<p class="calibre2">The <kbd class="calibre11">server/index.js</kbd> file's content has to be as follows:</p>
<pre class="calibre22">
var env = require('node-env-file'); <br class="title-page-name"/>// Load any undefined ENV variables form a specified file.  <br class="title-page-name"/>env(__dirname + '/.env'); <br class="title-page-name"/><br class="title-page-name"/>require("babel-core/register"); <br class="title-page-name"/>require("babel-polyfill"); <br class="title-page-name"/>require('./server');
</pre>
<p class="calibre2">Make sure you are loading <kbd class="calibre11">.env</kbd> from the file at the beginning of <kbd class="calibre11">server/index.js</kbd>. It will be required in order to load the mLab Mongo details from the environment variables (<kbd class="calibre11">server/.env</kbd>).</p>
<p class="calibre2">The <kbd class="calibre11">server/configMongoose.js</kbd> file's content has to be replaced. Find the following code:</p>
<pre class="calibre22">
// this is old code from our codebase: <br class="title-page-name"/>import mongoose from 'mongoose'; <br class="title-page-name"/>var Schema = mongoose.Schema; <br class="title-page-name"/><br class="title-page-name"/>const conf = { <br class="title-page-name"/>  hostname: process.env.MONGO_HOSTNAME || 'localhost', <br class="title-page-name"/>  port: process.env.MONGO_PORT || 27017, <br class="title-page-name"/>  env: process.env.MONGO_ENV || 'local', <br class="title-page-name"/>}; <br class="title-page-name"/>mongoose.connect(&amp;grave;mongodb://${conf.hostname}: <br class="title-page-name"/> ${conf.port}/${conf.env}&amp;grave;);
</pre>
<p class="calibre2">The new version of the same improved code has to be as follows:</p>
<pre class="calibre22">
import mongoose from 'mongoose'; <br class="title-page-name"/>var Schema = mongoose.Schema; <br class="title-page-name"/><br class="title-page-name"/>const conf = { <br class="title-page-name"/>  hostname: process.env.MONGO_HOSTNAME || 'localhost', <br class="title-page-name"/>  port: process.env.MONGO_PORT || 27017, <br class="title-page-name"/>  env: process.env.MONGO_ENV || 'local', <br class="title-page-name"/>}; <br class="title-page-name"/><br class="title-page-name"/>let dbUser <br class="title-page-name"/>if(process.env.MONGO_USER &amp;&amp; process.env.MONGO_PASS) { <br class="title-page-name"/>  dbUser = {user: process.env.MONGO_USER, pass: <br class="title-page-name"/>   process.env.MONGO_PASS} <br class="title-page-name"/>} else { <br class="title-page-name"/>  dbUser = undefined; // on local dev not required <br class="title-page-name"/>} <br class="title-page-name"/>mongoose.connect(&amp;grave;mongodb://${conf.hostname}:${conf.port}/${conf.env}&amp;grave;, dbUser);
</pre>
<p class="calibre2">As you can see, we have added the ability to connect with a specific DB's user. We need it because the localhost on which we were working didn't require any user, but when we start using the mLab MongoDB, then specifying our database's user is a must. Otherwise, we won't be able to authenticate correctly.</p>
<p class="calibre2">From this point, you don't need to run the <kbd class="calibre11">mongod</kbd> process in the background of your system, because the app will connect with the mLab MongoDB node that you created in the previous chapter. The mLab MongoDB (free version) runs 24/7, but if you plan to use it for production-ready apps, then you need to update it and start using the replica set feature as well (which was mentioned in the previous chapter).</p>
<p class="calibre2">You can try to run the project with this command:</p>
<pre class="calibre22">
<strong class="calibre1">npm start</strong>
</pre>
<p class="calibre2">Then you should be able to load the app:</p>
<div class="packt_figure"><img class="image-border94" src="../images/00099.jpeg"/></div>
<p class="calibre2">The important difference now is that all the CRUD operations (read/write via our publishing app) are done on our remote MongoDB (not on the local one).</p>
<p class="calibre2">After the publishing app uses the mLab MongoDB, we are ready to prepare our Docker image and then deploy it on several instances of AWS EC2 with AWS Load Balancer and EC2 Container Service.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Working on the publishing app Docker image</h1>
            

            <article>
                
<p class="calibre2">Before continuing, you should be able to run your project locally by using remote mLab MongoDB. It's required because we will start running our publishing app in the Docker container. Our app will then connect with Mongo remotely. We won't run any MongoDB process in any Docker container. This is why it's so important to use mLab in the following steps.</p>
<p class="calibre2">Let's create the Dockerfile by executing the following command in a terminal/command line:</p>
<pre class="calibre22">
<strong class="calibre1">[[your are in the project main directory]]</strong><br class="title-page-name"/><strong class="calibre1">$ touch Dockerfile</strong>
</pre>
<p class="calibre2">Enter the following content in your new Dockerfile:</p>
<pre class="calibre22">
FROM centos:centos7 <br class="title-page-name"/><br class="title-page-name"/>RUN yum update -y <br class="title-page-name"/>RUN yum install -y tar wget <br class="title-page-name"/>RUN wget -q https://nodejs.org/dist/v4.0.0/node-v4.0.0-linux-x64.tar.gz -O - | tar xzf - -C /opt/ <br class="title-page-name"/><br class="title-page-name"/>RUN mv /opt/node-v* /opt/node <br class="title-page-name"/>RUN ln -s /opt/node/bin/node /usr/bin/node <br class="title-page-name"/>RUN ln -s /opt/node/bin/npm /usr/bin/npm <br class="title-page-name"/><br class="title-page-name"/>COPY . /opt/publishing-app/ <br class="title-page-name"/><br class="title-page-name"/>WORKDIR /opt/publishing-app <br class="title-page-name"/><br class="title-page-name"/>RUN npm install <br class="title-page-name"/>RUN yum clean all <br class="title-page-name"/><br class="title-page-name"/>EXPOSE 80 <br class="title-page-name"/>CMD ["npm", "start"]
</pre>
<p class="calibre2">Let's look step by step at the Dockerfile we are going to use in our publishing app together with Docker:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre11">FROM centos:centos7</kbd>: This says that we will use as a starting point the CentOS 7 Linux distribution from the <a href="https://hub.docker.com/r/_/centos/" class="calibre6"><span>https://hub.docker.com/r/_/centos/</span></a> public Docker repository.</li>
</ul>
<p class="calibre29">You can use any other package as a starting point, such as Ubuntu, but we are using CentOS 7 because it's more lightweight and generally very good for web app deployment. You can find further details at <a href="https://www.centos.org/" class="calibre6"><span>https://www.centos.org/</span></a>.</p>
<div class="packt_infobox">Documentation of all commands is available at <a href="https://docs.docker.com/engine/reference/builder/" class="calibre27"><span class="packt_screen">https://docs.docker.com/engine/reference/builder/</span></a>.</div>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre11">RUN yum update -y</kbd>: This updates packages from the command line with <kbd class="calibre11">yum--</kbd>standard for any Linux setup.</li>
<li class="calibre15"><kbd class="calibre11">RUN yum install -y tar wget</kbd>: This installs two packages as <kbd class="calibre11">tar</kbd> (for unpacking files) and <kbd class="calibre11">wget</kbd> (for downloading files).</li>
<li class="calibre15"><kbd class="calibre11">RUN wget -q https://nodejs.org/dist/v4.0.0/node-v4.0.0-linux-x64.tar.gz -O - | tar xzf - -C /opt/*</kbd>: This command downloads <kbd class="calibre11">node4.0.0</kbd> to our CentOS container, unpacks it, and puts all the files into the <kbd class="calibre11">/opt/</kbd> directory.</li>
<li class="calibre15"><kbd class="calibre11">RUN mv /opt/node-v /opt/node*</kbd>: This renames the folder we just downloaded and unpacked (with <kbd class="calibre11">node</kbd>) to simply <kbd class="calibre11">node</kbd> without version naming.</li>
<li class="calibre15"><kbd class="calibre11">RUN ln -s /opt/node/bin/node /usr/bin/node</kbd>: We are linking the <kbd class="calibre11">/opt/node/bin/node</kbd> location with a <kbd class="calibre11">/usr/bin/node</kbd> link, so we are able to use a simple <kbd class="calibre11">$ node</kbd> command in the Terminal. This is standard stuff for Linux users.</li>
<li class="calibre15"><kbd class="calibre11">RUN ln -s /opt/node/bin/npm /usr/bin/npm</kbd>: The same as with <kbd class="calibre11">node</kbd>, but with <kbd class="calibre11">npm</kbd>. We are linking it in order to make usage easier and linking it to <kbd class="calibre11">$ npm</kbd> on our CentOS 7.</li>
<li class="calibre15"><kbd class="calibre11">COPY . /opt/publishing-app/</kbd>: This copies all the files in the context (The <kbd class="calibre11">.</kbd> (dot) sign is the location when you start the container build. We will do that in a moment.) It copies all the files into the <kbd class="calibre11">/opt/publishing-app/</kbd> location in our container.</li>
</ul>
<p class="calibre29">In our case, we have created the Dockerfile in our publishing app's directory, so it will copy all the project files in the container to the given location at <kbd class="calibre11">/opt/publishing-app/</kbd>.</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre11">WORKDIR /opt/publishing-app</kbd>: After we have our publishing app's files in our Docker container, we need to choose the working directory. It's similar to <kbd class="calibre11">$ cd /opt/publishing-app</kbd> on any Unix/Linux machine.</li>
<li class="calibre15"><kbd class="calibre11">RUN npm install</kbd>: When we are in our working directory, which is <kbd class="calibre11">/opt/publishing-app</kbd>, then we run the standard <kbd class="calibre11">npm install</kbd> command.</li>
<li class="calibre15"><kbd class="calibre11">RUN yum clean all</kbd>: We clean the <kbd class="calibre11">yum</kbd> cache.</li>
<li class="calibre15"><kbd class="calibre11">EXPOSE 80</kbd>: We define the port that is using our publishing application.</li>
<li class="calibre15"><kbd class="calibre11">CMD ["npm", "start"]</kbd>: Then, we specify how to run the application in our Docker container.</li>
</ul>
<p class="calibre2">We will also create in the main project directory, a <kbd class="calibre11">.dockerignore</kbd> file:</p>
<pre class="calibre22">
<strong class="calibre1">$ [[[in the main directory]]]</strong><br class="title-page-name"/><strong class="calibre1">$ touch .dockerignore</strong>
</pre>
<p class="calibre2">The file content will be as following:</p>
<pre class="calibre22">
.git <br class="title-page-name"/>node_modules <br class="title-page-name"/>.DS_Store
</pre>
<p class="calibre2">We don't want to copy over the mentioned files <kbd class="calibre11">(.DS_Store</kbd> is specific to OS X).</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Building the publishing app container</h1>
            

            <article>
                
<p class="calibre2">Currently, you will be able to build the Docker's container.</p>
<p class="calibre2">In the main directory of the project, you need to run the following:</p>
<pre class="calibre22">
<strong class="calibre1">docker login</strong>
</pre>
<p class="calibre2">The <kbd class="calibre11">login</kbd> command will prompt you to insert your Docker username and password. After you are authenticated correctly, you can run the <kbd class="calibre11">build</kbd> command:</p>
<pre class="calibre22">
<strong class="calibre1">docker build -t przeor/pub-app-docker .</strong>
</pre>
<div class="packt_infobox">Of course, the username and the container name combination has to be yours. Replace it with your details.</div>
<p class="calibre2">That preceding command will build the container with the use of Dockerfile commands. This is what you will see (step 1, step 2, and so on):</p>
<div class="packt_figure"><img class="image-border95" src="../images/00100.jpeg"/></div>
<p class="calibre2">After a successful build, you will see in your Terminal/command line something similar to this:</p>
<pre class="calibre22">
<strong class="calibre1">[[[striped from here for the sake of brevity]]]</strong><br class="title-page-name"/><strong class="calibre1">Step 12 : EXPOSE 80</strong><br class="title-page-name"/><strong class="calibre1"> ---&gt; Running in 081e0359cbd5</strong><br class="title-page-name"/><strong class="calibre1"> ---&gt; ce0433b220a0</strong><br class="title-page-name"/><strong class="calibre1">Removing intermediate container 081e0359cbd5</strong><br class="title-page-name"/><strong class="calibre1">Step 13 : CMD npm start</strong><br class="title-page-name"/><strong class="calibre1"> ---&gt; Running in 581df04c8c81</strong><br class="title-page-name"/><strong class="calibre1"> ---&gt; 1970dde57fec</strong><br class="title-page-name"/><strong class="calibre1">Removing intermediate container 581df04c8c81</strong><br class="title-page-name"/><strong class="calibre1">Successfully built 1910dde57fec</strong>
</pre>
<p class="calibre2">As you can see here from the Docker Terminal, we have built a container in a successful manner. The next step is to test it locally and then learn a little bit more of Docker's basics and finally start working on our AWS deployment.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Running the publishing app container locally</h1>
            

            <article>
                
<p class="calibre2">In order to test whether the container has been built correctly, perform the following steps.</p>
<p class="calibre2">Run this command:</p>
<pre class="calibre22">
<strong class="calibre1">$ docker-machine env</strong>
</pre>
<p class="calibre2">The preceding command will give you output similar to this:</p>
<pre class="calibre22">
<strong class="calibre1">export DOCKER_TLS_VERIFY="1"</strong><br class="title-page-name"/><strong class="calibre1">export DOCKER_HOST="tcp://192.168.99.100:2376"</strong><br class="title-page-name"/><strong class="calibre1">export DOCKER_CERT_PATH="/Users/przeor/.docker/machine/machines/default"</strong><br class="title-page-name"/><strong class="calibre1">export DOCKER_MACHINE_NAME="default"</strong><br class="title-page-name"/><strong class="calibre1"># Run this command to configure your shell: </strong><br class="title-page-name"/><strong class="calibre1"># eval $(docker-machine env)</strong>
</pre>
<p class="calibre2">We are looking for the <kbd class="calibre11">DOCKER_HOST</kbd> IP address; in this case, it's <kbd class="calibre11">192.168.99.100</kbd>.</p>
<p class="calibre2">This Docker host IP will be used to check whether our application is running correctly in the container. Note it down.</p>
<p class="calibre2">The next step is to run our local container with the following command:</p>
<pre class="calibre22">
<strong class="calibre1">$ docker run -d -p 80:80  przeor/pub-app-docker npm start</strong>
</pre>
<p class="calibre2">Regarding flags: the <kbd class="calibre11">d</kbd> flag stands for "detached," so the process will run in the background. You can list all running Docker processes with the following command:</p>
<pre class="calibre22">
<strong class="calibre1">docker ps</strong>
</pre>
<p class="calibre2">An example output would be as follows:</p>
<div class="packt_figure"><img class="image-border96" src="../images/00101.jpeg"/></div>
<p class="calibre2">The <kbd class="calibre11">-p</kbd> flag is telling us that the container's port <kbd class="calibre11">80</kbd> is bound to port <kbd class="calibre11">80</kbd> on the Docker IP host. So if we expose our Node app on port <kbd class="calibre11">80</kbd> in the container, then it will be able to run on a standard port <kbd class="calibre11">80</kbd> on the IP (in the examples, it will be <kbd class="calibre11">192.168.99.100:80</kbd>; obviously, port <kbd class="calibre11">80</kbd> is for all HTTP requests).</p>
<p class="calibre2">The <kbd class="calibre11">przeor/pub-app-docker</kbd> command will specify the name of the container that we want to run.</p>
<p class="calibre2">With <kbd class="calibre11">npm start</kbd>, we tell which command we want to run in the Docker container right after starting (otherwise, the container would run and stop immediately).</p>
<div class="packt_infobox">More references about <kbd class="calibre23">docker run</kbd> are available at <a href="https://docs.docker.com/engine/reference/run/" class="calibre27"><span class="packt_screen">https://docs.docker.com/engine/reference/run/</span></a>.</div>
<p class="calibre2">The preceding command will run the app, as shown in the following screenshot:</p>
<div class="packt_figure"><img class="image-border97" src="../images/00102.jpeg"/></div>
<p class="calibre2">As you can see, the IP address in the browser's URL bar is <span>http://192.168.99.100</span>. It's our Docker host IP.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Debugging a container</h1>
            

            <article>
                
<p class="calibre2">In case the container doesn't work for you, like in the following screenshot, use the following command to debug and find the reason:</p>
<pre class="calibre22">
<strong class="calibre1">docker run -i -t -p 80:80 przeor/pub-app-docker</strong>
</pre>
<p class="calibre2">This command with the <kbd class="calibre11">-i -t -p</kbd> flags will show you all the logs in the Terminal/command line, like in the following screenshot (this is just an example in order to show you the ability to debug a Docker container locally):</p>
<div class="packt_figure"><img class="image-border98" src="../images/00103.jpeg"/></div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Pushing a Docker container to a remote repository</h1>
            

            <article>
                
<p class="calibre2">If a container works for you locally, then it's almost ready for AWS deployment.</p>
<p class="calibre2">Before pushing the container, let's add the <kbd class="calibre11">.env</kbd> file to<kbd class="calibre11">.dockerignore</kbd>, because you have in it all the sensitive data that you won't put into containers. So, into the <kbd class="calibre11">.dockerignore</kbd> file, add the following:</p>
<pre class="calibre22">
.git <br class="title-page-name"/>node_modules <br class="title-page-name"/>.DS_Store <br class="title-page-name"/>.env
</pre>
<p class="calibre2">After you add <kbd class="calibre11">.env</kbd> to <kbd class="calibre11">.gitignore</kbd>, we need to change the <kbd class="calibre11">server/index.js</kbd> file and add an additional <kbd class="calibre11">if</kbd> statement:</p>
<pre class="calibre22">
if(!process.env.PORT) { <br class="title-page-name"/>  var env = require('node-env-file'); <br class="title-page-name"/>  // Load any undefined ENV variables form a specified file.  <br class="title-page-name"/>  env(__dirname + '/.env'); <br class="title-page-name"/>}
</pre>
<p class="calibre2">This <kbd class="calibre11">if</kbd> statement checks whether we're running the app locally (with an <kbd class="calibre11">.env</kbd> file) or remotely on an AWS instance (then we pass the <kbd class="calibre11">env</kbd> variables in a more secure manner).</p>
<p class="calibre2">After you have added the <kbd class="calibre11">.env</kbd> file into <kbd class="calibre11">.dockerignore</kbd> (and modified <kbd class="calibre11">server/index.js</kbd>), build the container that will be ready for the push:</p>
<pre class="calibre22">
<strong class="calibre1">docker build -t przeor/pub-app-docker</strong>
</pre>
<p class="calibre2">Regarding the environment variables, we will add them via AWS advanced options. You will learn about this later, but to get a general idea of how to add them when running them on the localhost, check out the following example (fake data provided in the command's flag):</p>
<pre class="calibre22">
<strong class="calibre1">$ docker run -i -t -e PORT=80 -e AWS_ACCESS_KEY_ID='AKIMOCKED5JM4VUHA' -e AWS_SECRET_ACCESS_KEY='k3JxMOCKED0oRI6w3ZEmENE1I0l' -e AWS_BUCKET_NAME='publishing-app' -e AWS_REGION_NAME='eu-central-1' -e MONGO_USER='usermlab' -e MONGO_PASS='MOCKEDpassword' -e MONGO_PORT=25732 -e MONGO_ENV='publishingapp' -e MONGO_HOSTNAME='ds025761.mlab.com' -p 80:80 przeor/pub-app-docker</strong><br class="title-page-name"/><strong class="calibre1">npm start</strong>
</pre>
<div class="packt_infobox">Make sure that you have provided your correct <kbd class="calibre23">AWS_REGION_NAME</kbd>. Mine is <kbd class="calibre23">eu-central-1</kbd>, but yours can be different.</div>
<p class="calibre2">As you can see, everything from the <kbd class="calibre11">server/.env</kbd> file has been moved to the Docker run command in the Bash terminal:</p>
<pre class="calibre22">
<strong class="calibre1">AWS_ACCESS_KEY_ID=&lt;&lt;___AWS_ACCESS_KEY_ID__&gt;&gt;</strong><br class="title-page-name"/><strong class="calibre1">AWS_SECRET_ACCESS_KEY=&lt;&lt;___AWS_SECRET_ACCESS_KEY__&gt;&gt;</strong><br class="title-page-name"/><strong class="calibre1">AWS_BUCKET_NAME=publishing-app</strong><br class="title-page-name"/><strong class="calibre1">AWS_REGION_NAME=eu-central-1</strong><br class="title-page-name"/><strong class="calibre1">MONGO_USER=&lt;&lt;___your_mlab_mongo_user__&gt;&gt;</strong><br class="title-page-name"/><strong class="calibre1">MONGO_PASS=&lt;&lt;___your_mlab_mongo_pass__&gt;&gt;</strong><br class="title-page-name"/><strong class="calibre1">MONGO_PORT=&lt;&lt;___your_mlab_mongo_port__&gt;&gt;</strong><br class="title-page-name"/><strong class="calibre1">MONGO_ENV=publishingapp</strong><br class="title-page-name"/><strong class="calibre1">MONGO_HOSTNAME=&lt;&lt;___your_mlab_mongo_hostname__&gt;&gt;</strong><br class="title-page-name"/><strong class="calibre1">PORT=80</strong>
</pre>
<p class="calibre2">As you can find here, the <kbd class="calibre11">-e</kbd> flag is for an <kbd class="calibre11">env</kbd> variable. The last thing is to push the container to the remote repository hosted by Docker Hub:</p>
<pre class="calibre22">
<strong class="calibre1">docker push przeor/pub-app-docker</strong>
</pre>
<p class="calibre2">Then you will be able to find in your Bash/command line something similar to the following:</p>
<div class="packt_figure"><img class="image-border99" src="../images/00104.jpeg"/></div>
<p class="calibre2">The link to the pushed repo will be similar to this one:</p>
<div class="packt_figure"><img class="image-border100" src="../images/00105.jpeg"/></div>
<p class="calibre2">The preceding screenshot has been made from the pushed Docker repository.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">A summary of useful Docker commands</h1>
            

            <article>
                
<p class="calibre2">The following are a few useful Docker commands:</p>
<ul class="calibre14">
<li class="calibre15">This command will list all the images, and <kbd class="calibre11">docker rm</kbd> can delete the repo from your local machine in case you want to delete it:</li>
</ul>
<pre class="calibre22">
<strong class="calibre1">        docker images</strong><br class="title-page-name"/><strong class="calibre1">        docker rm CONTAINER-ID</strong>
</pre>
<ul class="calibre14">
<li class="calibre15">You can use just the first three characters from <kbd class="calibre11">CONTAINER-ID</kbd>. You don't need to write down whole container ID. This is a convenience.</li>
</ul>
<ul class="calibre14">
<li class="calibre15">This one is used for stopping a running Docker container:</li>
</ul>
<pre class="calibre22">
        <strong class="calibre1">docker ps</strong><br class="title-page-name"/><strong class="calibre1">docker stop CONTAINER-ID</strong>
</pre>
<ul class="calibre14">
<li class="calibre15">You can use version tag of your containers with the following approach:</li>
</ul>
<pre class="calibre22">
        <strong class="calibre1">docker tag przeor/pub-app-docker:latest przeor/pub-app-  <br class="title-page-name"/>        docker:0.1</strong><br class="title-page-name"/><strong class="calibre1">docker images</strong>
</pre>
<ul class="calibre14">
<li class="calibre15">After you have listed the Docker images, you may notice that you have two containers, one with the tag <kbd class="calibre11">latest</kbd> and the other with <kbd class="calibre11">0.1</kbd>. This is a way to track changes, because if you push the container, the tag will also be listed on Docker Hub.</li>
</ul>
<ul class="calibre14">
<li class="calibre15">Check your container's local IP:</li>
</ul>
<pre class="calibre22">
        <strong class="calibre1">$ docker-machine env</strong>
</pre>
<ul class="calibre14">
<li class="calibre15">Build your container from a Dockerfile:</li>
</ul>
<pre class="calibre22">
        <strong class="calibre1">docker build -t przeor/pub-app-docker .</strong>
</pre>
<ul class="calibre14">
<li class="calibre15">Run your container in "detached" mode:</li>
</ul>
<pre class="calibre22">
        <strong class="calibre1">$ docker run -d -p 80:80 przeor/pub-app-docker npm start</strong>
</pre>
<ul class="calibre14">
<li class="calibre15">Run your container to debug it without detaching it so that you can find what is going on in the container's Bash terminal:</li>
</ul>
<pre class="calibre22">
        <strong class="calibre1">docker run -i -t -p 80:80 przeor/pub-app-docker</strong>
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Introduction to Docker on AWS EC2</h1>
            

            <article>
                
<p class="calibre2">Two chapters ago, we implemented Amazon AWS S3 for static image uploading. You should already have an AWS account, so you are ready for the following steps to create our deployment on AWS.</p>
<p class="calibre2">In general, you can use the steps with free AWS tiers, but we will use the paid version in this tutorial. Read the AWS EC2 pricing before starting this section on how to deploy Docker containers on AWS.</p>
<p class="calibre2">AWS also has great Docker container support with their service called <strong class="calibre1">EC2 Container Service</strong> (<strong class="calibre1">ECS</strong>).</p>
<p class="calibre2">If you bought this book, it probably means you haven't been using AWS so far. Because of this, we will first deploy Docker manually on EC2 in order to show you how the EC2 instances work so that you can get more knowledge from the book.</p>
<p class="calibre2">Our main goal is to make the deployment of our Docker containers automatic, but for now, we will start with a manual approach. If you have already used EC2, you can skip the next subsection and go straight to ECS.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Manual approach - Docker on EC2</h1>
            

            <article>
                
<p class="calibre2">We were running our Docker container locally with the following command (a few pages previously):</p>
<pre class="calibre22">
<strong class="calibre1">$ docker run -d -p 80:80  przeor/pub-app-docker npm start</strong>
</pre>
<p class="calibre2">We will do the same thing, not locally but on the EC2 instance, 100% manually for now; later, we will do it 100% automatically with AWS ECS.</p>
<p class="calibre2">Before we continue, let's understand what EC2 is. It's a scalable computing capacity located in the Amazon Web Services cloud. In EC2, you don't need to invest money upfront in buying any hardware. Everything you pay is for the time spent using an EC2 instance. This allows you to deploy applications faster. Very quickly, you can add new virtual servers (when there is a bigger web traffic demand). There are some mechanisms to scale the number of EC2 instances automatically with the use of <strong class="calibre1">AWS CloudWatch</strong>. Amazon EC2 gives you the ability to scale up or down to handle changed requirements (such as spikes in popularity)--this feature reduces your need to forecast traffic (and saves you time and money).</p>
<p class="calibre2">For now, we will use only one EC2 instance (later in the book, we will see more EC2 instances with load balancers and ECS).</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Basics - launching an EC2 instance</h1>
            

            <article>
                
<p class="calibre2">We will launch an EC2 instance, then log in to it via SSH (you can use <strong class="calibre1">Putty</strong> on Windows OS).</p>
<p class="calibre2">Log in to AWS Console by visiting this link: <a href="https://eu-central-1.console.aws.amazon.com/console/home" class="calibre6"><span>https://eu-central-1.console.aws.amazon.com/console/home</span></a>.</p>
<p class="calibre2">Click on the EC2 link: <a href="https://eu-central-1.console.aws.amazon.com/ec2/v2/home" class="calibre6"><span>https://eu-central-1.console.aws.amazon.com/ec2/v2/home</span></a></p>
<p class="calibre2">Then click on the blue <span>Launch Instance</span> button:</p>
<div class="packt_figure"><img class="image-border101" src="../images/00106.jpeg"/></div>
<p class="calibre2">The button looks like this:</p>
<div class="packt_figure"><img class="image-border102" src="../images/00107.jpeg"/></div>
<p class="calibre2">After you click on the button, you will be redirected to the <strong class="calibre1">Amazon Machine Image</strong> (<strong class="calibre1">AMI</strong>) page:</p>
<div class="packt_figure"><img class="image-border103" src="../images/00108.jpeg"/></div>
<p class="calibre2">The AMI has a list of images that you can run an EC2 instance with. Each image has a list of preinstalled software. For example, the most standard image is the following:</p>
<div class="packt_figure"><img class="image-border104" src="../images/00109.jpeg"/></div>
<p class="calibre2">It has preinstalled software; for example, the Amazon Linux AMI is an EBS-backed, AWS-supported image. The default image includes AWS command-line tools, Python, Ruby, Perl, and Java. The repositories include Docker, PHP, MySQL, PostgreSQL, and other packages.</p>
<p class="calibre2">On the same page, you can also find other AMIs to buy on the marketplace or created and shared by the community for free. You can also filter the images so that it will list only the free tier:</p>
<div class="packt_figure"><img class="image-border105" src="../images/00110.jpeg"/></div>
<p class="calibre2">For the sake of making this step-by-step guide simple, let's choose the image that is in the preceding screenshot; its name will be similar to <kbd class="calibre11">Amazon Linux AMI 2016.03.3 (HVM), SSD Volume Type</kbd>.</p>
<div class="packt_infobox">The name of the image may slightly vary; don't worry about it.</div>
<p class="calibre2">Click on the blue <span>Select</span> button. Then you will be transferred to the <span>Step 2: Choose an Instance Type</span> page, as shown in the following screenshot:</p>
<div class="packt_figure"><img class="image-border106" src="../images/00111.jpeg"/></div>
<p class="calibre2">From this page, select the following:</p>
<div class="packt_figure"><img class="image-border107" src="../images/00112.jpeg"/></div>
<p class="calibre2">Then, click on this button:</p>
<div class="packt_figure"><img class="image-border108" src="../images/00113.jpeg"/></div>
<p class="calibre2">The simplest method is to choose the default options:</p>
<ol class="calibre17">
<li value="1" class="calibre15">Review.</li>
<li value="2" class="calibre15">Configure security group (we will make some changes in this tab).</li>
<li value="3" class="calibre15">Tag instance (keep the options default).</li>
<li value="4" class="calibre15">Add storage (keep the options default).</li>
<li value="5" class="calibre15">Configure the instance (keep the options default).</li>
</ol>
<ol start="6" class="calibre17">
<li value="6" class="calibre15">Choose an instance type.</li>
<li value="7" class="calibre15">Choose an AMI.</li>
<li class="calibre15" value="8">Generally, keep clicking on the next button until we get to the Configure security.</li>
</ol>
<p class="calibre2">An indicator of progress you can find at the top is this:</p>
<div class="packt_figure"><img class="image-border109" src="../images/00114.jpeg"/></div>
<p class="calibre2">Our goal for now is to get to the security configuration page because we need to customize slightly the allowed ports. A security group consists of rules that control network traffic for an EC2 instance (a.k.a. firewall options). For security, set the name to <kbd class="calibre11">ssh-and-http-security-group</kbd>:</p>
<div class="packt_figure"><img class="image-border110" src="../images/00115.jpeg"/></div>
<p class="calibre2">As you can find here, you also need to click on the <span>Add Rule</span> button and add a new one called <span>HTTP</span>. This will allow our new EC2 instance to be available via port <span>80</span> for all the IPs.</p>
<p class="calibre2">After you have added the name and HTTP port 80 as the new rule, you can click on the <span>Review and Launch</span> button:</p>
<div class="packt_figure"><img class="image-border111" src="../images/00116.jpeg"/></div>
<p class="calibre2">Then, after you are happy with reviewing the instance, click on the blue button called <span>Launch</span> in that view:</p>
<div class="packt_figure"><img class="image-border48" src="../images/00117.jpeg"/></div>
<p class="calibre2">After you click on the <span>Launch</span> button, you will see a modal that says <span>Select an existing key pair or create a new key pair</span>:</p>
<div class="packt_figure"><img class="image-border48" src="../images/00118.jpeg"/></div>
<p class="calibre2">Usually, you'll need to create a new key pair. Give it the name <kbd class="calibre11">pubapp-ec2-key-pair</kbd> and then click on the <span>Download</span> button, as shown in the following screenshot:</p>
<div class="packt_figure"><img class="image-border112" src="../images/00119.jpeg"/></div>
<p class="calibre2">After you have downloaded <kbd class="calibre11">pubapp-ec2-key-pai</kbd>, you will be able to click on the blue <span>Launch</span> button. Next, you will see the following:</p>
<div class="packt_figure"><img class="image-border48" src="../images/00120.jpeg"/></div>
<p class="calibre2">From this screen, you can go directly to the EC2 launch logs (click on the <span>View launch log</span> link) so that you will be able to find your instance listed, as seen in the following screenshot:</p>
<div class="packt_figure"><img class="image-border48" src="../images/00121.jpeg"/></div>
<p class="calibre2">Great. Your first EC2 has been launched successfully! We need to log in to it and set up the Docker container from there.</p>
<p class="calibre2">Save the public IP of your EC2 instance. In the preceding launch log, you can find that the machine we've just created has the public IP <span>52.29.107.244</span>.</p>
<p class="calibre2">Your IP will be different (of course, this is just an example). Save it somewhere; we will use it in a moment as you'll need it to log in via SSH to the server and install the Docker app.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">SSH access via PuTTy - Windows users only</h1>
            

            <article>
                
<p class="calibre2">If you don't work on Windows, you can skip this subsection.</p>
<p class="calibre2">We'll be using PuTTy, which is available for download at <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html" class="calibre6"><span>http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html</span></a> (<kbd class="calibre11">putty.exe</kbd>, <kbd class="calibre11">pageant.exe</kbd>, and <kbd class="calibre11">puttygen.exe</kbd>).</p>
<p class="calibre2">Download key pairs for the EC2 instance, and convert them to <kbd class="calibre11">ppk</kbd> using <kbd class="calibre11">puttygen.exe</kbd>:</p>
<div class="packt_figure"><img class="image-border113" src="../images/00122.jpeg"/></div>
<p class="calibre2">Click on the <span>Load</span> button and choose the <kbd class="calibre11">pubapp-ec2-key-pair.pem</kbd> file, and then covert it to <kbd class="calibre11">ppk</kbd>.</p>
<p class="calibre2">Then you need to click on the <span>Save private key</span> button. You are done; you can close <kbd class="calibre11">puttygen.exe</kbd> and open <kbd class="calibre11">pageant.exe</kbd>. From it, do the following:</p>
<ul class="calibre14">
<li class="calibre15">Choose <span>Add Key</span></li>
<li class="calibre15">Then check whether your key has been added correctly to the Pageant key list</li>
</ul>
<p class="calibre2">If your private key is on the list, you are ready to use <kbd class="calibre11">putty.exe</kbd>.</p>
<div class="packt_figure"><img class="image-border114" src="../images/00123.jpeg"/></div>
<p class="calibre2">If you have opened the PuTTy program, you need to log in via SSH by typing your EC2 instance IP and clicking on the <span>Open</span> button, as shown in the preceding screenshot. PuTTy allows using SSH connections on Windows.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Connecting to an EC2 instance via SSH </h1>
            

            <article>
                
<p class="calibre2">In a previous chapter, after we launched the EC2 instance, we found out our public IP (remember that your public IP will be different): <kbd class="calibre11">52.29.107.244</kbd>. We need to connect to the remote EC2 instance with this public IP.</p>
<p class="calibre2">I've saved <kbd class="calibre11">pubapp-ec2-key-pair.pem</kbd> in my <kbd class="calibre11">Downloads</kbd> directory, so go to the directory where you have downloaded your <kbd class="calibre11">.pem</kbd> file:</p>
<pre class="calibre22">
<strong class="calibre1">$ cd ~/Downloads/</strong><br class="title-page-name"/><strong class="calibre1">$ chmod 400 pubapp-ec2-key-pair.pem</strong><br class="title-page-name"/><strong class="calibre1">$ ssh -i pubapp-ec2-key-pair.pem ec2-user@52.29.107.244</strong>
</pre>
<div class="packt_infobox">In PuTTy on Windows, it will look similar after this step. You need to provide in the PuTTy box the IP and ports in order to correctly log in to the machine. When you get a prompt to type a username, use <kbd class="calibre23">ec2-user</kbd>, as in the SSH example.</div>
<p class="calibre2">After a successful login, you will be able to see this:</p>
<div class="packt_figure"><img class="image-border115" src="../images/00124.jpeg"/></div>
<p class="calibre2">The following instructions are for all OS users (OS X, Linux, and Windows) as we are logged in to the EC2 instance via SSH. The following commands are required next:</p>
<pre class="calibre22">
<strong class="calibre1">[ec2-user@ip-172-31-26-81 ~]$ sudo yum update -y</strong><br class="title-page-name"/><strong class="calibre1">[ec2-user@ip-172-31-26-81 ~]$ sudo yum install -y docker</strong><br class="title-page-name"/><strong class="calibre1">[ec2-user@ip-172-31-26-81 ~]$ sudo service docker start</strong>
</pre>
<p class="calibre2">These commands will update the <kbd class="calibre11">yum</kbd> package manager and install and start the Docker service in the background:</p>
<pre class="calibre22">
<strong class="calibre1">[ec2-user@ip-172-31-26-81 ~]$ sudo usermod -a -G docker ec2-user</strong><br class="title-page-name"/><strong class="calibre1">[ec2-user@ip-172-31-26-81 ~]$ exit</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">&gt; ssh -i pubapp-ec2-key-pair.pem ec2-user@52.29.107.244</strong><br class="title-page-name"/><strong class="calibre1">[ec2-user@ip-172-31-26-81 ~]$ docker info</strong>
</pre>
<p class="calibre2">After you run the <kbd class="calibre11">docker info</kbd> command, it will show something similar to the following output:</p>
<div class="packt_figure"><img class="image-border116" src="../images/00125.jpeg"/></div>
<p class="calibre2">If you look at the preceding screenshot, you'll see that everything is all right, and we can continue with running the publishing app's Docker container with the following command:</p>
<pre class="calibre22">
    <strong class="calibre1">[ec2-user@ip-172-31-26-81 ~]$ docker run -d PORT=80 -e AWS_ACCESS_KEY_ID='AKIMOCKED5JM4VUHA' -e AWS_SECRET_ACCESS_KEY='k3JxMOCKED0oRI5w3ZEmENE1I0l' -e AWS_BUCKET_NAME='publishing-app' -e AWS_REGION_NAME='eu-central-1' -e MONGO_USER='usermlab' -e MONGO_PASS='MOCKEDpassword' -e MONGO_PORT=25732 -e MONGO_ENV='publishingapp' -e MONGO_HOSTNAME='ds025761.mlab.com' -p 80:80 przeor/pub-app-docker npm start</strong>
</pre>
<div class="packt_infobox">Make sure you have provided your correct <kbd class="calibre23">AWS_REGION_NAME</kbd>. Mine is <kbd class="calibre23">eu-central-1</kbd>, but yours could be different.</div>
<p class="calibre2">As you can see, everything from the <kbd class="calibre11">server/.env</kbd> file has been moved to the <kbd class="calibre11">docker run</kbd> command in the Bash terminal:</p>
<pre class="calibre22">
<strong class="calibre1">AWS_ACCESS_KEY_ID=&lt;&lt;___AWS_ACCESS_KEY_ID__&gt;&gt;</strong><br class="title-page-name"/><strong class="calibre1">AWS_SECRET_ACCESS_KEY=&lt;&lt;___AWS_SECRET_ACCESS_KEY__&gt;&gt;</strong><br class="title-page-name"/><strong class="calibre1">AWS_BUCKET_NAME=publishing-app</strong><br class="title-page-name"/><strong class="calibre1">AWS_REGION_NAME=eu-central-1</strong><br class="title-page-name"/><strong class="calibre1">MONGO_USER=&lt;&lt;___your_mlab_mongo_user__&gt;&gt;</strong><br class="title-page-name"/><strong class="calibre1">MONGO_PASS=&lt;&lt;___your_mlab_mongo_pass__&gt;&gt;</strong><br class="title-page-name"/><strong class="calibre1">MONGO_PORT=&lt;&lt;___your_mlab_mongo_port__&gt;&gt;</strong><br class="title-page-name"/><strong class="calibre1">MONGO_ENV=publishingapp</strong><br class="title-page-name"/><strong class="calibre1">MONGO_HOSTNAME=&lt;&lt;___your_mlab_mongo_hostname__&gt;&gt;</strong><br class="title-page-name"/><strong class="calibre1">PORT=80</strong>
</pre>
<p class="calibre2">Also make sure to rename <kbd class="calibre11">AWS_BUCKET_NAME</kbd>, <kbd class="calibre11">AWS_REGION_NAME</kbd>, or <kbd class="calibre11">MONGO_ENV</kbd> if you have a different one (if you set it differently than what was suggested in the previous chapters).</p>
<p class="calibre2">Then, in order to check whether everything went well, you can also use the following:</p>
<pre class="calibre22">
<strong class="calibre1">[ec2-user@ip-172-31-26-81 ~]$ docker ps</strong>
</pre>
<p class="calibre2">This command will show you whether the Docker process runs correctly in the background as a detached container. And after 10-30 seconds, when <kbd class="calibre11">npm start</kbd> will run the whole project, you can test with this:</p>
<pre class="calibre22">
<strong class="calibre1">[ec2-user@ip-172-31-26-81 ~]$ curl http://localhost</strong>
</pre>
<p class="calibre2">After the application has been bootstraped correctly, you can see output similar to the following:</p>
<div class="packt_figure"><img class="image-border117" src="../images/00126.jpeg"/></div>
<p class="calibre2">After you visit the EC2 instance's public IP (in our example, it is <kbd class="calibre11">52.29.107.244</kbd>), you will be able to find our publishing app available online as we have set up the security group of our EC2 instance with the exposed port <kbd class="calibre11">80</kbd> to the world. The following is the screenshot:</p>
<div class="packt_figure"><img class="image-border118" src="../images/00127.jpeg"/></div>
<p class="calibre2">If you see our publishing app under a public IP, then you have just deployed a Docker container on Amazon AWS EC2 successfully!</p>
<p class="calibre2">The process we just went through is very inefficient and manual, but shows exactly what is going on under the hood when we start using ECS.</p>
<p class="calibre2">We are missing the following in our current approach:</p>
<ul class="calibre14">
<li class="calibre15">Integration with other Amazon services, such as load balancing, monitoring, alerting, crash recovery, and route 53.</li>
<li class="calibre15">Automation, as currently we are unable to efficiently deploy 10 Docker containers quickly. This is also important if you want to deploy different Docker containers for different services as, for example, you can have separate containers for serving the frontend, backend, and even the database (in our case, we use mLab, so we don't need one here).</li>
</ul>
<p class="calibre2">You've just learned the basics of Amazon Web Services.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Basics of ECS - AWS EC2</h1>
            

            <article>
                
<p class="calibre2">The EC2 Container Service helps you create a cluster of Docker Container instances (many copies of the same container on several EC2 instances). Each container is deployed automatically--this means you don't need to log in to any of the EC2 instances via SSH as we did it in the previous chapter (manual approach). The whole job is done by the AWS and Docker software, which you will learn to use in the future (a more automated approach).</p>
<p class="calibre2">For example, you set that you want to have five different EC2 instances--the group of EC2 instances in the exposed port 80 so you are able to find the publishing application under the <kbd class="calibre11">http://[[EC2_PUBLIC_IP]]</kbd> address. Additionally, we are adding a load balancer between all the EC2 instances and the rest of the world so that in case there is any spike in traffic or any of the EC2 instances break, the load balancer will replace the broken EC2 instance with a new one or scale down/up the number of EC2 instances based on the traffic.</p>
<p class="calibre2">A great feature of the AWS load balancer is that it pings each EC2 instance with port 80, and if the pinged instance doesn't respond with the correct code (200), then it terminates the broken instance and turns on a fresh new instance with the Docker Container that has the image of our publishing app. This helps us maintain continuous availability of our application.</p>
<p class="calibre2">Additionally, we will use Amazon Route 53 in order to have a highly available and scalable cloud <strong class="calibre1">domain name system</strong> (<strong class="calibre1">DNS</strong>) web service so we will be able to set up a top level domain; in our case, I will use a domain I have bought specially for the book: <kbd class="calibre11">http://reactjs.space</kbd>.</p>
<p class="calibre2">That will be our HTTP address, of course. If you build a different service, you need to buy your own domain in order to follow the instructions and learn how Amazon Route 53 works.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Working with ECS</h1>
            

            <article>
                
<p class="calibre2">Before we start working on ECS, let's understand some basic nomenclature:</p>
<ul class="calibre14">
<li class="calibre15"><strong class="calibre1">Cluster</strong>: This is the main part of our process that will pool underlying resources as EC2 instances and any attached storage. It clusters many EC2 instances into one containerized application that aims to be scalable.</li>
<li class="calibre15"><strong class="calibre1">Task definition</strong>: This task determines what Docker Containers you are going to run on each EC2 instance (that is, the <kbd class="calibre11">docker run</kbd> command) and it also helps you define more advanced options, such as environment variables that you want to pass down into a container.</li>
<li class="calibre15"><strong class="calibre1">Service</strong>: This is a kind of glue between the cluster and a task definition. The service handles the login of a running task on our cluster. This also contains the management of revisions of the task (combination of a container and its settings) you want to run. Every time you change any setting in your task, it creates a new revision of your task. In the service, you specify what the task is and its revision that you want to run on your EC2 instances in your ECS.</li>
</ul>
<p class="calibre2">Visit the AWS Console and find the ECS. Click on the link to go to the EC2 Container Service Console. There, you will find a blue button named <span>Get started</span>:</p>
<div class="packt_figure"><img class="image-border119" src="../images/00128.jpeg"/></div>
<p class="calibre2">After that, you will see an ECS wizard with the following steps:</p>
<ol class="calibre17">
<li value="1" class="calibre15">Create a task definition.</li>
<li value="2" class="calibre15">Configure service.</li>
<li value="3" class="calibre15">Configure cluster.</li>
<li value="4" class="calibre15">Review.</li>
</ol>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Step 1 - creating a task definition</h1>
            

            <article>
                
<p class="calibre2">In ECS, a task definition is a recipe for a container. It's something that helps an ECS understand what Docker Container you want to run on the EC2 instances. It's a recipe or a blueprint of steps that the ECS has automatically done in order to successfully deploy our publishing app's container.</p>
<p class="calibre2">The details for this step are shown in the following screenshot:</p>
<div class="packt_figure"><img class="image-border120" src="../images/00129.jpeg"/></div>
<p class="calibre2">In the preceding screenshot, you can find that our task definition name is <kbd class="calibre11">pubapp-task</kbd>. The container name is <kbd class="calibre11">pubapp-container</kbd>.</p>
<p class="calibre2">For <span>Image</span>, we use the same argument as when we were running a container locally with <kbd class="calibre11">docker run</kbd>. In the case of <kbd class="calibre11">przeor/pub-app-docker</kbd>, ECS will know that it has to download the container from <a href="https://hub.docker.com/r/przeor/pub-app-docker/" class="calibre6"><span>https://hub.docker.com/r/przeor/pub-app-docker/</span></a>.</p>
<p class="calibre2">For now, let's keep the maximum memory at the default value (<kbd class="calibre11">300</kbd>). Set both port mappings to <kbd class="calibre11">80</kbd>.</p>
<div class="packt_infobox">At the time of writing this book, there are some problems if your container doesn't expose port <kbd class="calibre23">80</kbd>. It's probably a bug with the ECS wizard; without the wizard, any port can be used on the container.</div>
<p class="calibre2">Click on <span>Advanced options</span> in the task definition view:</p>
<div class="packt_figure"><img class="image-border121" src="../images/00130.jpeg"/></div>
<p class="calibre2">You will see a slide panel with additional options:</p>
<div class="packt_figure"><img class="image-border122" src="../images/00131.jpeg"/></div>
<p class="calibre2">We need to specify the following things:</p>
<ul class="calibre14">
<li class="calibre15"><strong class="calibre1">Command</strong>: This has to be separated with commas, so we use <kbd class="calibre11">npm,start</kbd>.</li>
<li class="calibre15"><strong class="calibre1">Working directory</strong>: We use <kbd class="calibre11">/opt/publishing-app</kbd> (identical path is set in the Dockerfile).</li>
<li class="calibre15"><strong class="calibre1">Env variables</strong>: Here, we specify all values from the <kbd class="calibre11">server/.env</kbd> file. This part is important to set up; the app will not work correctly without the correct details provided via the environment variables.</li>
<li class="calibre15"><strong class="calibre1">Rest of the values/inputs</strong>: Keep them at the default without changes.</li>
</ul>
<div class="packt_infobox">It's very important to add all the environment variables. We need to be very careful as it's easy to make a mistake here that will break the app inside an EC2 instance.</div>
<p class="calibre2">After all these changes, you can click on the <span>Next</span> button.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Step 2 - configuring the service</h1>
            

            <article>
                
<p class="calibre2">Generally, a service is a mechanism that keeps a certain amount of EC2 instances running while checking their health at the same time (using the <strong class="calibre1">Elastic Load Balancing</strong> (<strong class="calibre1">ELB</strong>)).  ELB automatically distributes incoming application traffic across multiple Amazon EC2 instances. If a server doesn't respond on port 80 (the default but can be changed to more advanced health checks), then the service runs a new service while the unhealthy one is being shut down. This helps you maintain very high availability for your application.</p>
<div class="packt_figure"><img class="image-border123" src="../images/00132.jpeg"/></div>
<p class="calibre2">The service name is <kbd class="calibre11">pubapp-service</kbd>. In this book, we will set up three different EC2 instances (you can set up fewer or more; it's up to you), so this is the number for the <em class="calibre21">desired number of tasks</em> input.</p>
<p class="calibre2">In the same step, we also have to set up the <strong class="calibre1">Elastic Load Balancer</strong> (<strong class="calibre1">ELB</strong>):</p>
<div class="packt_figure"><img class="image-border124" src="../images/00133.jpeg"/></div>
<ul class="calibre14">
<li class="calibre15"><span>Container name:host port</span>: Choose from the drop-down list <kbd class="calibre11">pubapp-container:80</kbd></li>
<li class="calibre15"><span>ELB listener protocol*</span>: <span>HTTP</span></li>
<li class="calibre15"><span>ELB listener port*</span>: <kbd class="calibre11">80</kbd></li>
<li class="calibre15"><span>ELB health check</span>: Keep default; you can change it while you are out of the wizard (on the specific ELB's page)</li>
<li class="calibre15"><span>Service IAM role</span>: The wizard will create this for us</li>
</ul>
<p class="calibre2">After all this, you can click on the <span>Next step</span> button to continue:</p>
<div class="packt_figure"><img class="image-border125" src="../images/00134.jpeg"/></div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Step 3 - configuring the cluster</h1>
            

            <article>
                
<p class="calibre2">Now, you'll set up the details of the ECS container agent, called a cluster. Here, you specify the name of your cluster, what kind of instances you'd like to use, the number of instances (it has to be bigger than the number required by the service), and the key pair.</p>
<div class="packt_figure"><img class="image-border126" src="../images/00135.jpeg"/></div>
<ul class="calibre14">
<li class="calibre15"><span>Cluster name</span>: Our cluster name is <kbd class="calibre11">pubapp-ecs-cluster</kbd>.</li>
<li class="calibre15"><span>EC2 instance type</span>: <kbd class="calibre11">t2.micro</kbd> (in production, use a bigger one).</li>
<li class="calibre15"><span>Number of instances</span>: Five, and that means the service will keep three instances alive and another two instances will be on the bench, waiting for any fatal situations. By bench, I mean that at a time (with our setup), we'll use only three instances, whereas another two are ready for use, but not actively used (traffic is not redirected to them).</li>
<li class="calibre15"><span>Key pair</span>: I specified the key pair called <kbd class="calibre11">pubapp-ec2-key-pair</kbd> earlier in this chapter. Always keep them in a safe place for later use.</li>
</ul>
<p class="calibre2">On the same page, you will also find the security group and container instance IAM roles setup, but we'll keep it at the default for now:</p>
<div class="packt_figure"><img class="image-border127" src="../images/00136.jpeg"/></div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Step 4 - reviewing</h1>
            

            <article>
                
<p class="calibre2">The last thing is to review whether everything looks good:</p>
<div class="packt_figure"><img class="image-border128" src="../images/00137.jpeg"/></div>
<p class="calibre2">Then, choose <span>Launch instances &amp; run service</span>:</p>
<div class="packt_figure"><img class="image-border129" src="../images/00138.jpeg"/></div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Launch status</h1>
            

            <article>
                
<p class="calibre2">After you have clicked on the <span>Launch</span> button, you will find a page with the status. Keep it open until you get all the boxes green with success indicators:</p>
<div class="packt_figure"><img class="image-border130" src="../images/00139.jpeg"/></div>
<p class="calibre2">Here's what it looks like all up and running:</p>
<div class="packt_figure"><img class="image-border48" src="../images/00140.jpeg"/></div>
<p class="calibre2">After all the boxes have a success indicator, then you will be able to click on the <span>View service</span> button that is at the top:</p>
<div class="packt_figure"><img class="image-border48" src="../images/00141.jpeg"/></div>
<p class="calibre2">Click on that button (<span>View service</span>) after it becomes available.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Finding your load balancer address</h1>
            

            <article>
                
<p class="calibre2">After you click on the <span>View service</span> button, you will see the main dashboard, where all your clusters are listed (currently there will only be one):</p>
<div class="packt_figure"><img class="image-border131" src="../images/00142.jpeg"/></div>
<p class="calibre2">Click on <span>pubapp-ecs-cluster</span> and you will see the following:</p>
<div class="packt_figure"><img class="image-border132" src="../images/00143.jpeg"/></div>
<p class="calibre2">On the preceding screen, click on <span>pubapp-service</span> from the list:</p>
<div class="packt_figure"><img class="image-border133" src="../images/00144.jpeg"/></div>
<p class="calibre2">Then, you will see the following:</p>
<div class="packt_figure"><img class="image-border48" src="../images/00145.jpeg"/></div>
<p class="calibre2">From this page, choose the Elastic Balancer:</p>
<div class="packt_figure"><img class="image-border134" src="../images/00146.jpeg"/></div>
<p class="calibre2">The final view of ELB is as follows:</p>
<div class="packt_figure"><img class="image-border48" src="../images/00147.jpeg"/></div>
<p class="calibre2">In the preceding view, you will find (under the <span>Description Name</span> tab) an elastic balancer address like this one:</p>
<pre class="calibre22">
    <strong class="calibre1">DNS name:   </strong><br class="title-page-name"/><strong class="calibre1">EC2Contai-EcsElast-1E4Y3WOGMV6S4-39378274.eu-central-<br class="title-page-name"/>    1.elb.amazonaws.com (A Record)</strong>
</pre>
<div class="packt_infobox">If you try to open the address and it doesn't work, then give it more time. The EC2 instances may be in progress in terms of running our Docker publishing app container. We must be patient during the initial run of our ECS cluster.</div>
<p class="calibre2">This is the address of your ELB, which you can put into the browser and see the publishing app:</p>
<div class="packt_figure"><img class="image-border48" src="../images/00148.jpeg"/></div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">AWS Route 53</h1>
            

            <article>
                
<p class="calibre2">The last step left in this chapter is to set up Route 53, which is a highly available and scalable cloud DNS web service.</p>
<p class="calibre2">For this step, you have two options:</p>
<ul class="calibre14">
<li class="calibre15">Having your own domain already registered</li>
<li class="calibre15">Registering a new domain via Route 53</li>
</ul>
<p class="calibre2">In the following procedure, we will use the first option, so we assume that we have already registered the <kbd class="calibre11">reactjs.space</kbd> domain (of course, you need to have your own domain in order to successfully follow these steps).</p>
<p class="calibre2">We will route end users to the publishing app by translating the name <kbd class="calibre11">http://reactjs.space</kbd> into the address of our ELB (<kbd class="calibre11">EC2Contai-EcsElast-1E4Y3WOGMV6S4-39378274.eu-central-1.elb.amazonaws.com</kbd>) so that users will be able to visit our application in a more user-friendly manner by typing <kbd class="calibre11">reactjs.space</kbd> into the browser's address bar.</p>
<p class="calibre2">Choose Route 53 from the AWS services list:</p>
<div class="packt_figure"><img class="image-border48" src="../images/00149.jpeg"/></div>
<p class="calibre2">You will be able to see a main page like the following:</p>
<div class="packt_figure"><img class="image-border48" src="../images/00150.jpeg"/></div>
<p class="calibre2">The next step is to create a hosted zone on Route 53, so click on the blue button called <span>Create Hosted Zone</span>:</p>
<div class="packt_figure"><img class="image-border48" src="../images/00151.jpeg"/></div>
<p class="calibre2">After this, you won't see any hosted zones, so click again on the blue button:</p>
<div class="packt_figure"><img class="image-border48" src="../images/00152.jpeg"/></div>
<p class="calibre2">The form will have a <span>Domain Name</span> field, where you put your domain name (in our case, it's <kbd class="calibre11">reactjs.space</kbd>):</p>
<div class="packt_figure"><img class="image-border135" src="../images/00153.jpeg"/></div>
<p class="calibre2">Success! Now you will be able to see your DNS names:</p>
<div class="packt_figure"><img class="image-border48" src="../images/00154.jpeg"/></div>
<p class="calibre2">The next step is to park the DNSes on your domain's provider. The last step is to change DNS settings at your domain registrar; in my case, they're as follows (yours will be different):</p>
<pre class="calibre22">
<strong class="calibre1">ns-1276.awsdns-31.org.</strong><br class="title-page-name"/><strong class="calibre1">ns-1775.awsdns-29.co.uk.</strong><br class="title-page-name"/><strong class="calibre1">ns-763.awsdns-31.net.</strong><br class="title-page-name"/><strong class="calibre1">ns-323.awsdns-40.com.</strong>
</pre>
<p class="calibre2">Notice the <kbd class="calibre11">.</kbd> (dots) at the end; you can get rid of them so the final DNSes that we have to change are as follows:</p>
<pre class="calibre22">
<strong class="calibre1">ns-1276.awsdns-31.org</strong><br class="title-page-name"/><strong class="calibre1">ns-1775.awsdns-29.co.uk</strong><br class="title-page-name"/><strong class="calibre1">ns-763.awsdns-31.net</strong><br class="title-page-name"/><strong class="calibre1">ns-323.awsdns-40.com</strong>
</pre>
<p class="calibre2">After all these steps, you can visit the <kbd class="calibre11">http://reactjs.space</kbd> website (the DNS change may take up to 48 hours).</p>
<p class="calibre2">The last thing is to create an alias of the <kbd class="calibre11">reactjs.space</kbd> domain that points to our Elastic Load Balancer. Click the following button:</p>
<div class="packt_figure"><img class="image-border136" src="../images/00155.jpeg"/></div>
<p class="calibre2">Then, you'll have the following view:</p>
<div class="packt_figure"><img class="image-border137" src="../images/00156.jpeg"/></div>
<p class="calibre2">Choose <span>Yes</span> from the alias's radio button and then select the ELB from the list, as shown in the following example:</p>
<div class="packt_figure"><img class="image-border138" src="../images/00157.jpeg"/></div>
<p class="calibre2">Currently, everything will be working after the DNS changes are finished (which may take up to 48 hours). To improve the experience with our application, let's also make an alias from <kbd class="calibre11">www.reactjs.space</kbd> to <kbd class="calibre11">reactjs.space</kbd>, so if anyone types <kbd class="calibre11">www.</kbd> before the domain name, it will work as intended.</p>
<p class="calibre2">Click again on the button called <span>Create Record Set</span>, choose an alias, and type <kbd class="calibre11">www</kbd>., after which you will be able to choose the <kbd class="calibre11">www.reactjs.space</kbd> domain. Do so and hit the <span>Create</span> button:</p>
<div class="packt_figure"><img class="image-border139" src="../images/00158.jpeg"/></div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
            

            <article>
                
<p class="calibre2">We are done with all the AWS/Docker setup. After a successful DNS change, you will be able to find our application under the <kbd class="calibre11">http://reactjs.space</kbd> address:</p>
<div class="packt_figure"><img class="image-border140" src="../images/00159.jpeg"/></div>
<p class="calibre2">The next chapter will talk about the basics of continuous integration and also help you wrap up the remaining things in the app before it is 100% production ready (minification is missing so far).</p>
<p class="calibre2">Let's continue in the next chapter with a more detailed description of the remaining topics that are going to be covered in the book.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    </body></html>