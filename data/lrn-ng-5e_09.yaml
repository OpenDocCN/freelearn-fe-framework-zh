- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Navigating through Applications with Routing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路由在应用程序中导航
- en: In previous chapters, we did a great job of separating concerns and adding different
    layers of abstraction to increase the maintainability of an Angular application.
    However, we have barely focused on the application’s UX.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们很好地分离了关注点，并为 Angular 应用程序添加了不同的抽象层，以增加其可维护性。然而，我们几乎没有关注应用程序的用户体验（UX）。
- en: Our user interface is bloated, with components scattered across a single screen.
    We must provide a better navigational experience for users and a logical way to
    change the application’s view intuitively. Now is the right time to incorporate
    routing and split the different areas of interest into pages, connected by a grid
    of links and URLs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户界面过于臃肿，组件散布在单个屏幕上。我们必须为用户提供更好的导航体验，以及一种直观地更改应用程序视图的逻辑方式。现在是时候引入路由并将不同兴趣区域分割成页面，通过链接和
    URL 网格连接起来。
- en: So, how do we deploy a navigation scheme between components of an Angular application?
    We use the Angular router and create custom links for our components to react
    to.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在 Angular 应用程序的组件之间部署导航方案呢？我们使用 Angular 路由器并为我们的组件创建自定义链接以进行响应。
- en: 'This chapter contains the following sections:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含以下部分：
- en: Introducing the Angular router
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Angular 路由器
- en: Configuring the main routes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置主要路由
- en: Organizing application routes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织应用程序路由
- en: Passing parameters to routes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向路由传递参数
- en: Enhancing navigation with advanced features
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高级功能增强导航
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The chapter contains various code samples to walk you through routing in the
    Angular framework. You can find the related source code in the `ch09` folder of
    the following GitHub repository:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例，以指导您了解 Angular 框架中的路由。您可以在以下 GitHub 仓库的 `ch09` 文件夹中找到相关源代码：
- en: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition
    )'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition
    )'
- en: Introducing the Angular router
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Angular 路由器
- en: 'In traditional web applications, when we wanted to change from one view to
    another, we needed to request a new page from the server. The browser would create
    a URL for the view and send it to the server. The browser would then reload the
    page as soon as the client received a response. It was a process that resulted
    in round trip time delays and a bad user experience for our applications:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的 Web 应用程序中，当我们想要从一个视图切换到另一个视图时，我们需要从服务器请求一个新的页面。浏览器会为视图创建一个 URL 并将其发送到服务器。然后，浏览器会在客户端收到响应后立即重新加载页面。这是一个导致往返时间延迟并给我们的应用程序带来糟糕用户体验的过程：
- en: '![Εικόνα που περιέχει κείμενο, γραμμή, στιγμιότυπο οθόνης, αριθμός  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_09_01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、线条、屏幕截图、编号  自动生成的描述](img/B21418_09_01.png)'
- en: 'Figure 9.1: Routing in traditional web applications'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1：传统 Web 应用程序中的路由
- en: 'Modern web applications using JavaScript frameworks such as Angular follow
    a different approach. They handle changes between views or components on the client
    side without bothering the server. They contact the server once during bootstrapping
    to get the main HTML file. The router on the client intercepts and handles any
    subsequent URL changes. These applications are called **Single-Page Applications
    (SPAs)** because they do not cause a full reload of a page:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Angular 等JavaScript框架的现代 Web 应用程序采用不同的方法。它们在客户端处理视图或组件之间的变化，而不打扰服务器。它们在启动时仅与服务器联系一次以获取主
    HTML 文件。客户端的路由器拦截并处理任何随后的 URL 变化。这些应用程序被称为 **单页应用程序（SPA**），因为它们不会导致页面完全重新加载：
- en: '![Εικόνα που περιέχει κείμενο, παράλληλα, διάγραμμα, γραμμή  Περιγραφή που
    δημιουργήθηκε αυτόματα](img/B21418_09_02.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、并行、图表、线条  自动生成的描述](img/B21418_09_02.png)'
- en: 'Figure 9.2: SPA architecture'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2：SPA 架构
- en: The Angular framework provides the `@angular/router` npm package, which we can
    use to navigate between different components in an Angular application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 框架提供了 `@angular/router` npm 包，我们可以使用它来在 Angular 应用程序的不同组件之间进行导航。
- en: 'Adding routing in an Angular application involves the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 应用程序中添加路由涉及以下步骤：
- en: Specifying the base path for the Angular application
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定 Angular 应用程序的基本路径
- en: Using an appropriate directive or service from the `@angular/router` npm package
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `@angular/router` npm 包中的适当指令或服务
- en: Configuring different routes for the Angular application
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 Angular 应用程序的不同路由
- en: Deciding where to render components upon navigation
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定在导航时渲染组件的位置
- en: In the following sections, we will learn the basics of Angular routing before
    diving deeper into hands-on examples.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将在深入了解实际示例之前学习 Angular 路由的基础知识。
- en: Specifying a base path
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定基本路径
- en: As we have already seen, modern and traditional web applications react differently
    when a URL changes inside the application. The architecture of each browser plays
    an essential part in this behavior. Older browsers initiate a new request to the
    server when the URL changes. Modern browsers, also known as **evergreen** browsers,
    can change the URL and the browser history when navigating in different views
    without sending a request to the server, using a technique called **pushState**
    .
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，当应用程序内的 URL 发生变化时，现代和传统 Web 应用程序的反应不同。每个浏览器的架构在这个行为中起着至关重要的作用。旧浏览器在
    URL 发生变化时向服务器发起新的请求。现代浏览器，也称为 **evergreen** 浏览器，可以在不向服务器发送请求的情况下，通过使用称为 **pushState**
    的技术在不同视图中导航时更改 URL 和浏览器历史记录。
- en: HTML5 pushState allows in-app navigation without causing a full reload of a
    page and is supported by all modern browsers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5 pushState 允许在应用程序内导航而不会导致页面完全重新加载，并且所有现代浏览器都支持。
- en: 'An Angular application must set the `<base>` HTML tag in the `index.html` file
    to enable pushState routing:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 应用程序必须在 `index.html` 文件中设置 `<base>` HTML 标签以启用 pushState 路由：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `href` attribute informs the browser of the path it should follow when loading
    application resources. The Angular CLI automatically adds the tag when creating
    a new application and sets the `href` value to the application root, `/` . If
    your application resides in a different folder from the root, you should name
    it after that folder.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`href` 属性通知浏览器在加载应用程序资源时应遵循的路径。Angular CLI 在创建新应用程序时会自动添加此标签，并将 `href` 值设置为应用程序根目录，`/`。如果你的应用程序位于根目录之外的文件夹中，你应该将其命名为该文件夹的名称。'
- en: Enabling routing in Angular applications
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Angular 应用程序中启用路由
- en: 'The Angular router is enabled by default in new Angular applications, as indicated
    by the `provideRouter` method in the `app.config.ts` file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 Angular 应用程序默认启用 Angular 路由器，如 `app.config.ts` 文件中的 `provideRouter` 方法所示：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In applications built with older versions of the Angular framework, the router
    is enabled by importing the `RouterModule` class in the main application module
    and using its `forRoot` method to define the routing configuration.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用较旧版本的 Angular 框架构建的应用程序中，通过在主应用程序模块中导入 `RouterModule` 类并使用其 `forRoot` 方法来定义路由配置来启用路由器。
- en: 'The `provideRouter` method enables us to use a set of Angular artifacts related
    to routing:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`provideRouter` 方法使我们能够使用与路由相关的 Angular 艺术品集：'
- en: Services to perform common routing tasks such as navigation
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行常见路由任务（如导航）的服务
- en: Directives that we can use in our components to enrich them with navigation
    logic
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在组件中使用以丰富其导航逻辑的指令
- en: It accepts a single parameter, which is the routing configuration of the application,
    and is defined by default in the `app.routes.ts` file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个参数，即应用程序的路由配置，默认情况下在 `app.routes.ts` 文件中定义。
- en: Configuring the router
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置路由器
- en: 'The `app.routes.ts` file contains a list of `Routes` objects that specify which
    routes exist in the application and which components should respond to a specific
    route. It looks like the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.routes.ts` 文件包含一个 `Routes` 对象列表，指定应用程序中存在哪些路由以及哪些组件应该对特定路由做出响应。它看起来如下所示：'
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In applications built with older versions of the Angular framework, you may
    notice that the route configuration is defined in a dedicated `app-routing.module.ts`
    file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用较旧版本的 Angular 框架构建的应用程序中，你可能注意到路由配置是在专门的 `app-routing.module.ts` 文件中定义的。
- en: Each route definition object contains a `path` property, which is the URL path
    of the route, and a `component` property that defines which component will be
    loaded when the application navigates to that path.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每个路由定义对象包含一个 `path` 属性，它是路由的 URL 路径，以及一个 `component` 属性，它定义了当应用程序导航到该路径时将加载哪个组件。
- en: The value of a `path` property should not contain a leading `/` .
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`path` 属性的值不应包含前导 `/`。'
- en: Navigation in an Angular application can occur manually by changing the browser
    URL or navigating using in-app links. The browser will cause the application to
    reload in the first scenario, while the second will instruct the router to navigate
    at runtime. In our case, when the browser URL contains the `products` path, the
    router renders the product list component on the page. On the contrary, when the
    application navigates to `products` by code, the router follows the same procedure
    and updates the browser URL.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular应用程序中的导航可以通过手动更改浏览器URL或使用应用程序内的链接进行。在第一种情况下，浏览器将导致应用程序重新加载，而在第二种情况下，它将指示路由器在运行时进行导航。在我们的案例中，当浏览器URL包含`products`路径时，路由器将在页面上渲染产品列表组件。相反，当应用程序通过代码导航到`products`时，路由器遵循相同的程序并更新浏览器URL。
- en: If the user tries to navigate to a URL that does not match any route, Angular
    activates a custom type of route called **wildcard** or **fallback** . The wildcard
    route has a `path` property with two asterisks and matches any URL. The component
    property for this is usually an application-specific `PageNotFoundComponent` or
    the main component of the application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户尝试导航到不匹配任何路由的URL，Angular将激活一种自定义类型的路由，称为**通配符**或**后备**路由。通配符路由的`path`属性有两个星号，匹配任何URL。此组件的属性通常是特定于应用程序的`PageNotFoundComponent`或应用程序的主要组件。
- en: Rendering components
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件渲染
- en: The template of the main application component contains the `<router-outlet>`
    element, which is one of the main directives of the Angular router. It resides
    inside the `app.component.html` file and is used as a placeholder for components
    activated with routing. These components are rendered as a sibling element of
    the `<router-outlet>` element.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 主应用程序组件的模板包含`<router-outlet>`元素，这是Angular路由器的主要指令之一。它位于`app.component.html`文件中，用作通过路由激活的组件的占位符。这些组件作为`<router-outlet>`元素的兄弟元素进行渲染。
- en: We have covered the basics and provided a minimal router setup. In the next
    section, we will look at a more realistic example and expand our knowledge of
    routing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了基础知识并提供了最小化的路由设置。在下一节中，我们将查看一个更实际的示例并扩展我们对路由的知识。
- en: Configuring the main routes
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置主路由
- en: When we start designing the architecture of an Angular application with routing,
    it is easiest to think about its main features, such as menu links that users
    can click to access. Products and shopping carts are basic features of the e-shop
    application we are currently building. Adding links and configuring them to activate
    certain features of an Angular application is part of the route configuration
    of the application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始设计具有路由的Angular应用程序的架构时，最容易想到的是其主要功能，例如用户可以点击以访问的菜单链接。产品和购物车是我们目前正在构建的电子商务应用程序的基本功能。添加链接并将它们配置为激活Angular应用程序的特定功能是应用程序路由配置的一部分。
- en: 'You will need the source code of the Angular application we created in *Chapter
    8* , *Communicating with Data Services over HTTP* , to follow along with the rest
    of the chapter. After you get the code, we suggest you take the following actions
    for simplicity:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要我们创建在*第8章*，*通过HTTP与数据服务通信*中创建的Angular应用程序的源代码，以便跟随本章的其余部分。在您获取代码后，我们建议您为简化起见采取以下行动：
- en: Remove the `auth.interceptor.ts` and its unit test file. Actual calls in the
    Fake Store API do not need authentication.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除`auth.interceptor.ts`及其单元测试文件。在Fake Store API的实际调用中不需要身份验证。
- en: Modify the `app.config.ts` file so that the `provideHttpClient` method does
    not use the interceptor.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`app.config.ts`文件，以便`provideHttpClient`方法不使用拦截器。
- en: 'To set up the route configuration of our application, we need to follow the
    steps below:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置我们应用程序的路由配置，我们需要遵循以下步骤：
- en: 'Run the following command to create a new Angular component for the shopping
    cart:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以创建一个新的Angular组件用于购物车：
- en: '[PRE3]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Open the `app.routes.ts` file and add the following `import` statements:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.routes.ts`文件并添加以下`import`语句：
- en: '[PRE4]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add two route definition objects in the `routes` variable:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`routes`变量中添加两个路由定义对象：
- en: '[PRE5]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding snippet, the `products` route will activate the `ProductListComponent`
    , and the `cart` route will activate the `CartComponent` .
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`products`路由将激活`ProductListComponent`，而`cart`路由将激活`CartComponent`。
- en: 'Open the `app.component.html` file and modify the `<header>` HTML element as
    follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.component.html`文件，并按照以下方式修改`<header>` HTML元素：
- en: '[PRE6]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding template, we apply the `routerLink` directive to anchor HTML
    elements and assign the route path we want to navigate. Notice that the path should
    start with `/` as opposed to the `path` property in the route definition object.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模板中，我们应用了 `routerLink` 指令到锚点 HTML 元素，并分配我们想要导航的路由路径。请注意，路径应该以 `/` 开头，而不是路由定义对象中的
    `path` 属性。
- en: How the path starts depends on whether we want to use absolute or relative routing
    in our application, as we will learn later in the chapter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 路径如何开始取决于我们是否想在应用程序中使用绝对路由或相对路由，我们将在本章后面学习。
- en: 'Move the `<router-outlet>` HTML element inside the `<div>` element with the
    `content` class selector and remove the `<app-product-list>` component:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `<router-outlet>` HTML 元素移动到具有 `content` 类选择器的 `<div>` 元素内部，并删除 `<app-product-list>`
    组件：
- en: '[PRE7]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Open the `app.component.ts` file, remove any references to the `ProductListComponent`
    class, and import the `RouterLink` class:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app.component.ts` 文件，删除对 `ProductListComponent` 类的任何引用，并导入 `RouterLink`
    类：
- en: '[PRE8]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Open the `app.component.css` file and replace every CSS style related to the
    `.social-links` selector with the following styles:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app.component.css` 文件，并用以下样式替换与 `.social-links` 选择器相关的所有 CSS 样式：
- en: '[PRE9]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, open the global `styles.css` file and add the following CSS styles:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开全局的 `styles.css` 文件，并添加以下 CSS 样式：
- en: '[PRE10]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We are now ready to preview our Angular application:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以预览我们的 Angular 应用程序了：
- en: Run the `ng serve` command and navigate to `http://localhost:4200` . Initially,
    the application page displays the application header and the copyright information
    only.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `ng serve` 命令并导航到 `http://localhost:4200`。最初，应用程序页面仅显示应用程序标题和版权信息。
- en: Click on the **Products** link. The application should display the product list
    and update the browser URL to match the `/products` path.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Products** 链接。应用程序应该显示产品列表，并更新浏览器 URL 以匹配 `/products` 路径。
- en: 'Now navigate to the root path at `http://localhost:4200` and append the `/cart`
    path at the end of the browser URL. The application should replace the product
    list view with the cart component:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在导航到根路径 `http://localhost:4200`，并在浏览器 URL 的末尾追加 `/cart` 路径。应用程序应该用购物车组件替换产品列表视图：
- en: '**cart works!**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**购物车功能正常！**'
- en: Routing in Angular works bi-directionally. It enables us to navigate to an Angular
    component using the in-app links or the browser address bar.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 中的路由是双向的。它使我们能够使用应用程序内的链接或浏览器地址栏导航到 Angular 组件。
- en: Congratulations! Your Angular application now supports in-app navigation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您的 Angular 应用程序现在支持应用程序内导航。
- en: We have barely scratched the surface of Angular routing. There are many features
    for us to investigate in the following sections. For now, let’s try to break our
    components into more routes so that we can manage them easily.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 Angular 路由的探索还只是触及了皮毛。在接下来的章节中，我们将有许多特性要研究。现在，让我们尝试将我们的组件拆分成更多路由，以便我们能够轻松管理。
- en: Organizing application routes
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织应用程序路由
- en: Our application displays the product list along with the product details and
    the product create components. We need to organize the routing configuration so
    that different routes activate each component.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序显示产品列表以及产品详情和产品创建组件。我们需要组织路由配置，以便不同的路由激活每个组件。
- en: In this section, we will add a new route for the product create component. Later,
    in the *Passing parameters to routes* section, we will add a separate route for
    the product details component.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为产品创建组件添加一个新的路由。在后面的 *向路由传递参数* 部分，我们将为产品详情组件添加一个单独的路由。
- en: 'Let’s get started with the product create component:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建产品组件：
- en: 'Open the `app.routes.ts` file and add the following `import` statement:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app.routes.ts` 文件，并添加以下 `import` 语句：
- en: '[PRE11]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the following route definition object in the `routes` variable:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `routes` 变量中添加以下路由定义对象：
- en: '[PRE12]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Open the `product-list.component.ts` file and remove any references to the `ProductCreateComponent`
    class.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-list.component.ts` 文件，并删除对 `ProductCreateComponent` 类的任何引用。
- en: Open the `product-list.component.html` file and remove the `<app-product-create>`
    element.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-list.component.html` 文件，并删除 `<app-product-create>` 元素。
- en: Run the `ng serve` command to start the application, click on the **Products**
    link, and verify that the product create form is not displayed.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `ng serve` 命令以启动应用程序，点击 **Products** 链接，并验证产品创建表单没有显示。
- en: Currently, the product create component is only accessible using the browser
    URL, and we cannot reach it using the application UI. In the following section,
    we will learn how to accomplish that task and imperatively navigate to a route.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，产品创建组件只能通过浏览器URL访问，我们无法通过应用程序UI访问它。在下一节中，我们将学习如何完成这项任务并强制导航到路由。
- en: Navigating imperatively to a route
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制导航到路由
- en: 'The product create component can only be activated by entering the address
    `http://localhost:4200/products/new` in the browser address bar. Let’s add a button
    in the product list that will navigate us from the UI also:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 产品创建组件只能通过在浏览器地址栏中输入地址`http://localhost:4200/products/new`来激活。让我们在产品列表中添加一个按钮，以便我们也可以从UI导航：
- en: 'Open the `product-list.component.html` file and modify the second `@if` block
    as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-list.component.html`文件并修改第二个`@if`块如下：
- en: The `<path>` element below might be tricky to type out manually. Alternatively,
    you can find the code in the `ch09` folder in the book’s GitHub repository and
    copy it from there.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的`<path>`元素可能难以手动输入。或者，您可以在书的GitHub仓库中的`ch09`文件夹中找到代码并从那里复制。
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding snippet, we added an anchor element that will navigate us to
    the product create component, as indicated by the value of the `routerLink` directive.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们添加了一个锚点元素，它将带我们导航到产品创建组件，如`routerLink`指令的值所示。
- en: The value of the `routerLink` directive is `new` and not `/products/new` as
    someone would expect. The preceding behavior is because the button resides in
    the product list component, which is already activated by the `products` part
    of the route.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`routerLink`指令的值是`new`，而不是像人们预期的那样是`/products/new`。前面的行为是因为按钮位于产品列表组件中，该组件已经被路由的`products`部分激活。'
- en: The Angular router can synthesize the destination route by all activated routes,
    but if you don’t want to start from the root, you can add a `/` before the route.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Angular路由器可以通过所有激活的路由来合成目标路由，但如果您不想从根开始，可以在路由前添加一个`/`。
- en: 'Open the `product-list.component.css` file and add the following CSS styles:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-list.component.css`文件并添加以下CSS样式：
- en: '[PRE14]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Open the `product-list.component.ts` file and add the following `import` statement:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-list.component.ts`文件并添加以下`import`语句：
- en: '[PRE15]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the `RouterLink` class in the `imports` array of the `@Component` decorator:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`@Component`装饰器的`imports`数组中添加`RouterLink`类：
- en: '[PRE16]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Open the `product-create.component.css` file and add the following CSS style:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-create.component.css`文件并添加以下CSS样式：
- en: '[PRE17]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding style, the `:host` selector targets the host element of the
    product create component.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的样式中，`:host`选择器针对产品创建组件的主元素。
- en: 'Run the `ng serve` command to start the application and navigate to `http://localhost:4200/products`
    :'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ng serve`命令以启动应用程序并导航到`http://localhost:4200/products`：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_09_03.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图像，屏幕截图，字体，自动生成的描述](img/B21418_09_03.png)'
- en: 'Figure 9.3: Product list'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：产品列表
- en: 'Click the button with the plus sign. The application redirects you to the /
    `products/new` route and activates the product create component:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击带有加号的按钮。应用程序将您重定向到`/products/new`路由并激活产品创建组件：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, αριθμός  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_09_04.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图像，屏幕截图，字体，编号，自动生成的描述](img/B21418_09_04.png)'
- en: 'Figure 9.4: Product create form'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：产品创建表单
- en: 'Although the product create component remains functional, our change introduced
    a flaw in the application’s UX. The user does not have a visual indication when
    a new product is created because the product list belongs to a different route.
    We must modify the logic of the **Create** button so that it redirects the user
    to the product list upon successful creation of a product:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管产品创建组件仍然可用，但我们的更改在应用程序的UX中引入了一个缺陷。当创建新产品时，用户没有视觉指示，因为产品列表属于不同的路由。我们必须修改**创建**按钮的逻辑，以便在成功创建产品后将其重定向到产品列表：
- en: 'Open the `product-create.component.ts` file and add the following `import`
    statement:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-create.component.ts`文件并添加以下`import`语句：
- en: '[PRE18]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Inject the `Router` service in the `constructor` of the `ProductCreateComponent`
    class:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ProductCreateComponent`类的`constructor`中注入`Router`服务：
- en: '[PRE19]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Modify the `createProduct` method as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式修改`createProduct`方法：
- en: '[PRE20]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding method, we call the `navigate` method of the `Router` service
    to navigate into the `/products` route of the application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们调用 `Router` 服务的 `navigate` 方法来导航到应用程序的 `/products` 路径。
- en: We use the `/` character because we are using absolute routing by default.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `/` 字符是因为我们默认使用绝对路由。
- en: It accepts a **link parameters array** containing the destination route path
    we want to navigate.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个包含我们想要导航的目的地路由路径的**链接参数数组**。
- en: 'Open the `products.service.ts` file and modify the `getProducts` method so
    that it uses the Fake Store API when there is no local product data:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `products.service.ts` 文件，并修改 `getProducts` 方法，使其在没有本地产品数据时使用 Fake Store API：
- en: '[PRE21]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If we do not make the preceding change, the product list component will always
    return data from the Fake Store API.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不进行前面的更改，产品列表组件将始终从 Fake Store API 返回数据。
- en: Our application now redirects users to the product list whenever they create
    a new product so that they can see it on the list.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在在用户创建新产品时将用户重定向到产品列表，以便他们可以在列表中看到它。
- en: 'So far, we have configured the application routing to activate components according
    to a given path. However, our application does not show any components in the
    following situations:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经配置了应用程序的路由，以便根据给定的路径激活组件。然而，在我们的应用程序中，以下情况下不会显示任何组件：
- en: When we navigate to the root path of the application
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们导航到应用程序的根路径时
- en: When we try to navigate to a non-existing route
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们尝试导航到一个不存在的路由时
- en: In the following section, we will learn how to use the built-in route paths
    that Angular router provides and improve the application UX.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用 Angular 路由器提供的内置路由路径，并改进应用程序的用户体验。
- en: Using built-in route paths
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内置路由路径
- en: When we want to define a component that will be loaded when we navigate to the
    root path, we create a route definition object and set the `path` property to
    an empty string. A route with an empty string `path` is called the **default**
    route of the Angular application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要定义一个在导航到根路径时将被加载的组件时，我们创建一个路由定义对象，并将 `path` 属性设置为空字符串。具有空字符串 `path` 的路由称为
    Angular 应用程序的**默认路由**。
- en: 'In our case, we want the default route to display the product list component.
    Open the `app.routes.ts` file and add the following route at the end of the `routes`
    variable:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们希望默认路由显示产品列表组件。打开 `app.routes.ts` 文件，并在 `routes` 变量的末尾添加以下路由：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding snippet, we tell the router to redirect to the `products` path
    when the application navigates to the default route. The `pathMatch` property
    tells the router how to match the URL to the root path property. In this case,
    the router redirects to the `products` path only when the URL matches the root
    path, which is the empty string.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们告诉路由器当应用程序导航到默认路由时重定向到 `products` 路径。`pathMatch` 属性告诉路由器如何将 URL
    匹配到根路径属性。在这种情况下，只有当 URL 匹配根路径（即空字符串）时，路由器才会重定向到 `products` 路径。
- en: If we run the application, we will notice that when the browser URL points to
    the root path of our application, we are redirected to the `products` path, and
    the product list is displayed on the screen.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行应用程序，我们会注意到当浏览器 URL 指向我们的应用程序根路径时，我们会重定向到 `products` 路径，并且产品列表会显示在屏幕上。
- en: We added the default route after all other routes because the order of the routes
    is important. The router selects routes with a first-match-wins strategy. More
    specific routes should be defined before less specific ones.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在所有其他路由之后添加了默认路由，因为路由的顺序很重要。路由器采用“首次匹配即赢”的策略选择路由。更具体的路由应该定义在不太具体的路由之前。
- en: We have encountered the concept of unknown routes in the *Introducing the Angular
    router* section. We saw briefly how to set up a **wildcard** route to display
    a `PageNotFoundComponent` when our application tries to navigate to a route that
    does not exist. In real-world applications, it is common to create such a component,
    especially if you want to display additional information to the user, such as
    what next steps they can follow. In our case, which is simpler, we will redirect
    to the `products` route.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在“介绍 Angular 路由器”部分遇到了未知路由的概念。我们简要地看到了如何设置一个**通配符**路由，当我们的应用程序尝试导航到一个不存在的路由时，显示
    `PageNotFoundComponent`。在实际应用中，创建这样的组件很常见，尤其是如果你想向用户显示额外的信息，比如他们可以采取的下一步行动。在我们的案例中，这比较简单，我们将重定向到
    `products` 路由。
- en: 'Open the `app.routes.ts` file and add the following route at the end of the
    `routes` variable:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `app.routes.ts` 文件，并在 `routes` 变量的末尾添加以下路由：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The wildcard route must be the last entry in the route list because the application
    should only reach it if there are no matching routes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符路由必须是路由列表中的最后一个条目，因为应用程序只有在没有匹配的路由时才应该到达它。
- en: If we run our application using the `ng serve` command and navigate to an unknown
    path, our application will display the product list.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`ng serve`命令运行我们的应用程序并导航到一个未知路径，我们的应用程序将显示产品列表。
- en: Until now, we have relied on the address bar of the browser to indicate which
    route is active at any given time. As we will learn in the following section,
    we could improve the user experience using CSS styling.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直依赖于浏览器地址栏来指示在任何给定时间哪个路由是激活的。正如我们将在下一节中学习的，我们可以使用CSS样式来改进用户体验。
- en: Styling router links
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由链接样式
- en: The application header contains the **Products** and the **My Cart** links.
    When we navigate to each one, it is not clear which route has been activated.
    The Angular router exports the `routerLinkActive` directive, which we can use
    to change the style of a link when the corresponding route is active. It works
    similarly to the class binding we learned about in *Chapter 3* , *Structuring
    User Interfaces with Components* . It accepts a list of class names or a class
    that is added when the link is active and removed when it becomes inactive.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序标题包含**产品**和**我的购物车**链接。当我们导航到每个链接时，不清楚哪个路由已被激活。Angular路由器导出了`routerLinkActive`指令，我们可以用它来改变当对应路由激活时链接的样式。它的工作方式与我们在*第3章*中学习的类绑定类似，*使用组件结构化用户界面*。它接受一个类名列表或一个当链接激活时添加并当它变为非激活时移除的类。
- en: 'Let’s see how to use it in our application:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在我们的应用程序中使用它：
- en: 'Open the `app.component.css` file and add the following CSS style:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.component.css`文件并添加以下CSS样式：
- en: '[PRE24]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Open the `app.component.ts` file and import the `RouterLinkActive` class from
    the `@angular/router` npm package:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.component.ts`文件并从`@angular/router` npm包中导入`RouterLinkActive`类：
- en: '[PRE25]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the `RouterLinkActive` class in the `imports` array of the `@Component`
    decorator:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`@Component`装饰器的`imports`数组中添加`RouterLinkActive`类：
- en: '[PRE26]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Open the `app.component.html` file and add the `routerLinkActive` directive
    to both links:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.component.html`文件并将`routerLinkActive`指令添加到两个链接中：
- en: '[PRE27]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, when we click on an application link in the header, its color changes to
    denote the link is active.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们点击标题中的应用程序链接时，其颜色会改变以表示链接是激活的。
- en: We have learned how to use routing and activate components that do not need
    any parameters. However, the product details component accepts the product ID
    as a parameter. In the next section, we will learn how to activate the component
    using dynamic route parameters.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用路由和激活不需要任何参数的组件。然而，产品详情组件接受产品ID作为参数。在下一节中，我们将学习如何使用动态路由参数激活组件。
- en: Passing parameters to routes
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向路由传递参数
- en: A common scenario in enterprise web applications is to have a list of items,
    and when you click on one of them, the page changes the current view and displays
    details of the selected item. The previous approach resembles a master-detail
    browsing functionality, where each generated URL on the master page contains the
    identifiers required to load each item on the detail page.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 企业级Web应用中常见的场景是有一个项目列表，当你点击其中一个时，页面会改变当前视图并显示所选项目的详细信息。之前的方法类似于主从浏览功能，其中主页面上的每个生成的URL都包含在详情页上加载每个项目所需的标识符。
- en: We can represent the previous scenario with two routes navigating to different
    components. One component is the list of items, and the other is the item details.
    So, we need to find a way to create and pass dynamic item-specific data from one
    route to the other.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用两个路由来表示之前的场景，一个路由导航到不同的组件。一个组件是项目列表，另一个是项目详情。因此，我们需要找到一种方法从一条路由创建和传递动态的项目特定数据到另一条路由。
- en: 'We are tackling double trouble here: creating URLs with dynamic parameters
    at runtime and parsing the value of these parameters. No problem: the Angular
    router has our back, and we will see how with a real example.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里面临双重挑战：在运行时创建带有动态参数的URL以及解析这些参数的值。没问题：Angular路由器支持我们，我们将通过一个真实示例来了解这一点。
- en: Building a detail page using route parameters
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用路由参数构建详情页
- en: The product list in our application currently displays a list of products. When
    we click on a product, the product details appear below the list. We need to refactor
    the previous workflow so that the component responsible for displaying product
    details is rendered on a different page from the list. We will use the Angular
    router to redirect the user to the new page upon clicking on a product from the
    list.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，产品列表当前显示产品列表。当我们点击产品时，产品详情会显示在列表下方。我们需要重构之前的流程，以便负责显示产品详情的组件在列表的不同页面上渲染。我们将使用
    Angular 路由在从列表中点击产品时将用户重定向到新页面。
- en: 'The product list component currently passes the selected product ID via input
    binding. We will use the Angular router to pass the product ID as a route parameter
    instead:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 产品列表组件当前通过输入绑定传递所选产品 ID。我们将使用 Angular 路由将产品 ID 作为路由参数传递：
- en: 'Open the `app.routes.ts` file and add the following `import` statement:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app.routes.ts` 文件并添加以下 `import` 语句：
- en: '[PRE28]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the following route definition in the `routes` variable after the `products/new`
    route:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `routes` 变量中 `products/new` 路由之后添加以下路由定义：
- en: '[PRE29]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The colon character denotes `id` as a route parameter in the new route definition
    object. If a route has multiple parameters, we separate them with `/` . As we
    will learn later, the parameter name is important when we want to consume its
    value in our components.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号字符表示在新的路由定义对象中将 `id` 作为路由参数。如果一个路由有多个参数，我们用 `/` 分隔它们。正如我们稍后将要学习的，当我们在组件中消费其值时，参数名称很重要。
- en: 'Open the `product-list.component.html` file and add an anchor element for the
    product title so that it uses the new route definition:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-list.component.html` 文件并为产品标题添加一个锚点元素，使其使用新的路由定义：
- en: '[PRE30]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding snippet, the `routerLink` directive uses property binding to
    set its value in a link parameters array. We pass the `id` of the product template
    reference variable as a parameter in the array.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`routerLink` 指令使用属性绑定来设置其值在链接参数数组中。我们将产品模板引用变量的 `id` 作为参数传递到数组中。
- en: We do not need to prefix the value of the link parameters array with `/products`
    because that route already activates the product list.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要在链接参数数组的值前加 `/products` 前缀，因为该路由已经激活了产品列表。
- en: Remove the `<app-product-detail>` component and the `click` event binding from
    the `<li>` tag.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除 `<app-product-detail>` 组件和 `<li>` 标签上的 `click` 事件绑定。
- en: We can refactor the `product-list.component.ts` file and remove any code that
    uses the `selectedProduct` property and the `ProductDetailComponent` class. The
    product list does not need to keep the selected product in its local state because
    we are navigating away from the list upon choosing a product.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重构 `product-list.component.ts` 文件，并移除任何使用 `selectedProduct` 属性和 `ProductDetailComponent`
    类的代码。产品列表不需要在本地状态中保留所选产品，因为我们选择产品后会离开列表。
- en: 'We can now proceed by modifying the product detail component so that it works
    with routing:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过修改产品详情组件来使其与路由一起工作：
- en: 'Open the `product-detail.component.css` file and add a CSS style to set the
    width of the host element:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-detail.component.css` 文件，添加一个 CSS 样式来设置宿主元素的宽度：
- en: '[PRE31]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Open the `product-detail.component.ts` file and modify the `import` statements
    as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-detail.component.ts` 文件，并按如下方式修改 `import` 语句：
- en: '[PRE32]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The Angular router exports the `ActivatedRoute` service, which we can use to
    retrieve information about the currently activated route, including any parameters.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 路由导出 `ActivatedRoute` 服务，我们可以使用它来检索有关当前激活路由的信息，包括任何参数。
- en: 'Modify the component `constructor` to inject the `ActivatedRoute` and `Router`
    services:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `constructor` 组件以注入 `ActivatedRoute` 和 `Router` 服务：
- en: '[PRE33]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Modify the list of implemented interfaces of the `ProductDetailComponent` class:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `ProductDetailComponent` 类实现的接口列表：
- en: '[PRE34]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create the following `ngOnInit` method:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下 `ngOnInit` 方法：
- en: '[PRE35]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `ActivatedRoute` service contains the `paramMap` observable, which we can
    use to subscribe and get route parameter values. The `switchMap` RxJS operator
    is used when we want to get a value from an observable, complete it, and pass
    the value down to another observable. We use it, in this case, to pipe the `id`
    parameter from the `paramMap` observable to the `getProduct` method of the `ProductsService`
    class.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActivatedRoute` 服务包含 `paramMap` 可观察对象，我们可以使用它来订阅并获取路由参数值。当我们需要从一个可观察对象中获取值、完成它并将值传递给另一个可观察对象时，我们使用
    `switchMap` RxJS 操作符。在这种情况下，我们使用它将 `paramMap` 可观察对象中的 `id` 参数传递到 `ProductsService`
    类的 `getProduct` 方法。'
- en: 'Modify the `changePrice` and `remove` methods so that the application will
    redirect to the product list upon completion of each action:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `changePrice` 和 `remove` 方法，以便在每次操作完成后应用程序将重定向到产品列表：
- en: '[PRE36]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Remove the `ngOnChanges` method because the component and its bindings are initialized
    every time the route is activated.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除 `ngOnChanges` 方法，因为组件及其绑定每次激活路由时都会初始化。
- en: Remove the output event emitters because the product list component is not a
    parent component anymore. Leave the `id` input property as is because we will
    use it later in the chapter.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除输出事件发射器，因为产品列表组件不再是父组件。保留 `id` 输入属性不变，因为我们将在本章后面使用它。
- en: Leave the `addToCart` method empty for now. We will use it later in *Chapter
    10* , *Collecting User Data with Forms* .
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前将 `addToCart` 方法留空。我们将在第10章 *使用表单收集用户数据* 中使用它。
- en: 'It is also worth noting the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是：
- en: The `paramMap` observable returns an object of the `ParamMap` type. We can use
    the `get` method of the `ParamMap` object to pass the parameter name we defined
    in the route configuration and access its value.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`paramMap` 可观察者返回一个 `ParamMap` 类型的对象。我们可以使用 `ParamMap` 对象的 `get` 方法来传递我们在路由配置中定义的参数名称，并访问其值。'
- en: We convert the value of the `id` parameter to a number because route parameter
    values are always strings.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `id` 参数的值转换为数字，因为路由参数值始终是字符串。
- en: 'If we run the application using the `ng serve` command and click on a product
    from the list, the application navigates us to the product details component:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `ng serve` 命令运行应用程序并从列表中点击一个产品，应用程序将导航到产品详情组件：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, σχεδίαση  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_09_05.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、屏幕截图、字体、设计的图像自动生成的描述](img/B21418_09_05.png)'
- en: 'Figure 9.5: Product Details page'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：产品详情页面
- en: If you refresh the browser, the application will not display the product because
    the `getProduct` method of the `ProductsService` class works only with the cached
    version of product data. You must go to the product list again and select a product
    because the local cache has been reset. Note that this behavior is based on the
    current implementation of the e-shop application and is not tied to the Angular
    router architecture.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刷新浏览器，应用程序将不会显示产品，因为 `ProductsService` 类的 `getProduct` 方法只与产品数据的缓存版本一起工作。你必须再次转到产品列表并选择一个产品，因为本地缓存已被重置。请注意，这种行为基于电子商务应用程序的当前实现，并不依赖于Angular路由器架构。
- en: In the previous example, we used the `paramMap` property to get route parameters
    as an observable. So, ideally, our component could be notified of new values during
    its lifetime. But the component is destroyed each time we want to select a different
    product from the list, and so is the subscription to the `paramMap` observable.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了 `paramMap` 属性来获取路由参数作为可观察者。因此，理想情况下，我们的组件可以在其生命周期内通知新值。但是，每次我们想要从列表中选择不同的产品时，组件和
    `paramMap` 可观察者的订阅都会被销毁。
- en: Alternatively, we can avoid using observables by reusing the instance of a component
    as soon as it remains rendered on the screen during consecutive navigations. We
    can achieve this behavior using child routes, as we will learn in the following
    section.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在组件在连续导航中保持渲染在屏幕上时立即重用组件的实例，从而避免使用可观察者。我们可以通过使用子路由来实现这种行为，正如我们将在下一节中学习的。
- en: Reusing components using child routes
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用子路由重用组件
- en: Child routes are a perfect solution when we want a landing page component that
    will provide routing to other components. The component should contain a `<router-outlet>`
    element in which child routes will be loaded.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要一个提供其他组件路由的着陆页组件时，子路由是一个完美的解决方案。该组件应包含一个 `<router-outlet>` 元素，其中将加载子路由。
- en: 'Suppose that we want to define the layout of our Angular application like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想定义我们的Angular应用程序的布局如下：
- en: '![Shape  Description automatically generated with medium confidence](img/B21418_09_06.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![形状描述，中等置信度自动生成](img/B21418_09_06.png)'
- en: 'Figure 9.6: Master-detail layout'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：主-详细布局
- en: The scenario in the previous diagram requires the product list component to
    contain a `<router-outlet>` element to render the product details component when
    the related route is activated.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 上一图中的场景要求产品列表组件包含一个 `<router-outlet>` 元素，以便在激活相关路由时渲染产品详情组件。
- en: The product details component will be rendered in the `<router-outlet>` of the
    product list component and not in the `<router-outlet>` of the main application
    component.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 产品详情组件将在产品列表组件的`<router-outlet>`中渲染，而不是在主应用程序组件的`<router-outlet>`中。
- en: The product details component is not destroyed when we navigate from one product
    to another. Instead, it remains in the DOM tree, and its `ngOnInit` method is
    called once, the first time we select a product. When we choose a new product
    from the list, the `paramMap` observable emits the `id` of the new product. The
    new product is fetched using the `ProductsService` class, and the component template
    is refreshed to reflect the new changes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从一种产品导航到另一种产品时，产品详情组件不会被销毁。相反，它保持在DOM树中，并且它的`ngOnInit`方法只在第一次选择产品时被调用。当我们从列表中选择新产品时，`paramMap`可观察对象会发出新产品的`id`。新产品使用`ProductsService`类获取，组件模板被刷新以反映新的变化。
- en: 'The route configuration of the application, in this case, would be as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的路线配置，在这种情况下，如下所示：
- en: '[PRE37]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding snippet, we use the `children` property of the route definition
    object to define child routes containing a list of route definition objects.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用路由定义对象的`children`属性来定义包含路由定义对象列表的子路由。
- en: Notice also that we removed the word `products` from the `path` property of
    the children routes because the parent route will append it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还从子路由的`path`属性中移除了单词`products`，因为父路由会附加它。
- en: 'A parent route can also provide services to its children by using the `providers`
    property of the route definition object. Providing services in a route is very
    helpful when we want to limit access to a subset of the routing configuration.
    If we wanted to restrict the `ProductsService` class only to the product-related
    components, we should do the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 父路由也可以通过使用路由定义对象的`providers`属性为其子路由提供服务。在路由中提供服务在我们想要限制对路由配置子集的访问时非常有用。如果我们只想将`ProductsService`类限制在产品相关组件中，我们应该做以下操作：
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Angular creates a separate injector when providing services in route definition
    objects, which is an immediate child of the root injector. Suppose the service
    is also provided in the root injector, and suppose the cart component uses that.
    In that case, the instance created by one of the product-related components will
    differ from that of the cart component.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当在路由定义对象中提供服务时，Angular会创建一个独立的注入器，它是根注入器的直接子节点。假设该服务也在根注入器中提供，并且假设购物车组件使用它。在这种情况下，由产品相关组件之一创建的实例将与购物车组件的实例不同。
- en: We have learned how to use the `paramMap` observable in Angular routing. In
    the following section, we will discuss an alternative approach using snapshots.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何在Angular路由中使用`paramMap`可观察对象。在下一节中，我们将讨论使用快照的替代方法。
- en: Taking a snapshot of route parameters
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拍摄路由参数快照
- en: When we select a product from the list, the product list component is removed
    from the DOM tree, and the product details component is added. To choose a different
    product, we need to click on either the **Products** link or the back button of
    our browser. Consequently, the product details component is replaced by the product
    list component in the DOM. So, we are in a situation where only one component
    is displayed on the screen at any time.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从列表中选择产品时，产品列表组件会被从DOM树中移除，产品详情组件被添加。要选择不同的产品，我们需要点击**产品**链接或浏览器的后退按钮。因此，产品详情组件在DOM中被产品列表组件替换。所以，我们处于在任何时候屏幕上只显示一个组件的情况。
- en: 'When the product details component is destroyed, so is its `ngOnInit` method
    and the subscription to the `paramMap` observable. So, we do not benefit from
    using observables at this point. Alternatively, we could use the `snapshot` property
    of the `ActivatedRoute` service to get values for route parameters, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当产品详情组件被销毁时，它的`ngOnInit`方法和对`paramMap`可观察对象的订阅也会被销毁。因此，我们在此点使用可观察对象没有好处。作为替代，我们可以使用`ActivatedRoute`服务的`snapshot`属性来获取路由参数的值，如下所示：
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `snapshot` property represents the current value of a route parameter, which
    also happens to be the initial value. It contains the `params` property, an object
    of route parameter key-value pairs we can access.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`snapshot`属性表示路由参数的当前值，这恰好也是初始值。它包含`params`属性，这是一个我们可以访问的路由参数键值对的对象。'
- en: If you are sure your component will not be reused, use the snapshot approach.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确定你的组件不会被重用，请使用快照方法。
- en: So far, we have dealt with routing parameters in the form of `products/:id`
    . We use these parameters to navigate to a component that requires the parameter.
    In our case, the product details component requires the `id` parameter to get
    specific product details. However, there is another type of route parameter when
    we need it to be optional, as we will learn in the following section.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经处理了以 `products/:id` 形式的路由参数。我们使用这些参数导航到需要该参数的组件。在我们的例子中，产品详情组件需要 `id`
    参数来获取特定产品的详细信息。然而，当我们需要它为可选时，还有另一种类型的路由参数，我们将在下一节中学习。
- en: Filtering data using query parameters
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用查询参数过滤数据
- en: In *Chapter 8* , *Communicating with Data Services over HTTP* , we learned how
    to pass query parameters to a request using the `HttpParams` class. The Angular
    router also supports passing query parameters through the application’s URL.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第8章* ，*通过 HTTP 与数据服务通信* 中，我们学习了如何使用 `HttpParams` 类将查询参数传递给请求。Angular 路由也支持通过应用程序的
    URL 传递查询参数。
- en: 'The `getProducts` method in the `products.service.ts` file uses HTTP query
    parameters to limit product results returned from the Fake Store API:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`products.service.ts` 文件中的 `getProducts` 方法使用 HTTP 查询参数来限制从 Fake Store API
    返回的产品结果：'
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It uses a hardcoded value for setting the `limit` query parameter. We will
    modify the application so that the product list component passes the `limit` value
    dynamically:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用硬编码的值来设置 `limit` 查询参数。我们将修改应用程序，使产品列表组件动态传递 `limit` 值：
- en: 'Open the `products.service.ts` file and modify the `getProducts` method so
    that the `limit` is passed as a parameter:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `products.service.ts` 文件并修改 `getProducts` 方法，使 `limit` 作为参数传递：
- en: '[PRE41]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding method, if the `limit` value is **falsy** , we pass a default
    value of `10` to the query parameter.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，如果 `limit` 值为 **假值**，我们将默认值 `10` 传递给查询参数。
- en: A falsy value evaluates to `False` in a Boolean context and can be `null` ,
    `undefined` , `0` , or `False` . You can read more at [https://developer.mozilla.org/docs/Glossary/Falsy](https://developer.mozilla.org/docs/Glossary/Falsy)
    .
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在布尔上下文中，假值评估为 `False`，可以是 `null`、`undefined`、`0` 或 `False`。您可以在 [https://developer.mozilla.org/docs/Glossary/Falsy](https://developer.mozilla.org/docs/Glossary/Falsy)
    上了解更多信息。
- en: 'Open the `product-list.component.ts` file and import the `ActivatedRoute` service
    and the `switchMap` RxJS operator:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-list.component.ts` 文件并导入 `ActivatedRoute` 服务和 `switchMap` RxJS 操作符：
- en: '[PRE42]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Inject the `ActivatedRoute` service in the `constructor` of the `ProductListComponent`
    class:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ProductListComponent` 类的 `constructor` 中注入 `ActivatedRoute` 服务：
- en: '[PRE43]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `ActivatedRoute` service contains a `queryParamMap` observable that we
    can subscribe to get query parameter values. It returns a `ParamMap` object, similar
    to the `paramMap` observable we saw earlier, which we can query to get parameter
    values. Modify the `getProducts` method to use the `queryParamMap` observable:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ActivatedRoute` 服务包含一个 `queryParamMap` 可观察对象，我们可以订阅它以获取查询参数值。它返回一个 `ParamMap`
    对象，类似于我们之前看到的 `paramMap` 可观察对象，我们可以查询它以获取参数值。修改 `getProducts` 方法以使用 `queryParamMap`
    可观察对象：'
- en: '[PRE44]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding snippet, we use the `switchMap` RxJS operator to pipe the `limit`
    parameter from the `queryParamMap` observable to the `getProducts` method of the
    `ProductsService` class as a number.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用 `switchMap` RxJS 操作符将 `limit` 参数从 `queryParamMap` 可观察对象管道到 `ProductsService`
    类的 `getProducts` 方法作为数字。
- en: 'Run the `ng` `serve` command to start the application and navigate to `http://localhost:4200?limit=5`
    . You should see a list of 5 products:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `ng serve` 命令以启动应用程序并导航到 `http://localhost:4200?limit=5` 。你应该看到5个产品的列表：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_09_07.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图像，屏幕截图，字体，自动生成的描述](img/B21418_09_07.png)'
- en: 'Figure 9.7: Filtered product list'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：过滤后的产品列表
- en: Try to experiment with different values for the limit parameter and observe
    the output.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试对 `limit` 参数的不同值进行实验，并观察输出。
- en: Query parameters in routing are powerful and can be used for various use cases,
    such as filtering and sorting data. They can also be used when working with snapshot-based
    routing.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 路由中的查询参数功能强大，可用于各种用例，例如过滤和排序数据。它们也可以在与基于快照的路由一起工作时使用。
- en: In the following section, we will explore a new innovative way to pass route
    parameters using component input properties.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探索一种新的创新方法，使用组件输入属性传递路由参数。
- en: Binding input properties to routes
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将输入属性绑定到路由
- en: 'We have already learned, in *Chapter 3* , *Structuring User Interfaces with
    Components* , that we use input and output bindings to inter-communicate between
    components. An input binding can also pass route parameters while navigating to
    a component. We will see an example using the product detail component:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 *第 3 章* 中学习了，*使用组件构建用户界面*，我们使用输入和输出绑定在组件之间进行交互。输入绑定还可以在导航到组件时传递路由参数。我们将通过产品详情组件的示例来了解：
- en: 'The input binding with route parameters is not enabled by default in the Angular
    router. We must activate it from the application configuration file. Open the
    `app.config.ts` file and import the `withComponentInputBinding` function from
    the `@angular/router` npm package:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Angular 路由器没有启用带有路由参数的输入绑定。我们必须从应用程序配置文件中激活它。打开 `app.config.ts` 文件，并从
    `@angular/router` npm 包中导入 `withComponentInputBinding` 函数：
- en: '[PRE45]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Pass the preceding function as the second parameter in the `provideRouter`
    method:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面的函数作为 `provideRouter` 方法的第二个参数传递：
- en: '[PRE46]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, open the `product-detail.component.ts` file and change the type of the
    `id` component property to a `string` :'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `product-detail.component.ts` 文件，将 `id` 组件属性的类型更改为 `string`：
- en: '[PRE47]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We must change the property type because routing parameters are passed as strings.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须更改属性类型，因为路由参数是以字符串形式传递的。
- en: 'Modify the `ngOnInit` method to use the `id` parameter to fetch a product:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `ngOnInit` 方法以使用 `id` 参数获取产品：
- en: '[PRE48]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Run the `ng serve` command and verify that the product details are displayed
    upon selecting a product from the list.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `ng serve` 命令并验证在从列表中选择产品时是否显示产品详情。
- en: 'Binding route parameters to component input properties has the following advantages:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 将路由参数绑定到组件输入属性有以下优点：
- en: The TypeScript component class is simpler because we do not have asynchronous
    calls with observables
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 组件类更简单，因为我们没有使用异步调用与可观察对象
- en: We can access existing components that work with input and output bindings using
    a route
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用路由访问与输入和输出绑定一起工作的现有组件
- en: Input binding works with components that are activated via routing. If we want
    to access any route parameter from another component, we must use the `ActivatedRoute`
    service.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 输入绑定与通过路由激活的组件一起工作。如果我们想从另一个组件访问任何路由参数，我们必须使用 `ActivatedRoute` 服务。
- en: Now that we have learned all the different ways to pass parameters during navigation,
    we have covered all the essential information we need to start building Angular
    applications with routing. In the following sections, we will focus on advanced
    practices that enhance the user experience when using in-app navigation in Angular
    applications.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了在导航期间传递参数的所有不同方式，我们已经涵盖了开始使用路由构建 Angular 应用程序所需的所有基本信息。在以下章节中，我们将关注增强
    Angular 应用程序中应用程序导航用户体验的高级实践。
- en: Enhancing navigation with advanced features
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高级功能增强导航
- en: 'So far, we have covered basic routing with route and query parameters. The
    Angular router is quite capable, though, and able to do much more, such as the
    following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了使用路由和查询参数的基本路由。然而，Angular 路由器功能强大，能够做更多的事情，例如以下内容：
- en: Controlling access to a route
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制对路由的访问
- en: Preventing navigation away from a route
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止从路由导航离开
- en: Prefetching data to improve application UX
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预取数据以改善应用程序 UX
- en: Lazy-loading routes to speed up response time
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒加载路由以加快响应时间
- en: In the following sections, we will learn about all these techniques in more
    detail.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将更详细地了解所有这些技术。
- en: Controlling route access
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制路由访问
- en: 'When we want to control access to a particular route, we use a **guard** .
    To create a guard, we use the `ng generate` command of the Angular CLI, passing
    the word `guard` and its name as parameters:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要控制对特定路由的访问时，我们使用 **守卫**。要创建守卫，我们使用 Angular CLI 的 `ng generate` 命令，传递 `guard`
    和其名称作为参数：
- en: '[PRE49]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When we execute the previous command, the Angular CLI asks what type of guard
    we would like to create. There are multiple types of guards that we can create
    according to the functionality that they provide:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行前面的命令时，Angular CLI 会询问我们想要创建哪种类型的守卫。根据它们提供的功能，我们可以创建多种类型的守卫：
- en: '`CanActivate` : Controls whether a route can be activated'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanActivate` : 控制是否可以激活路由'
- en: '`CanActivateChild` : Controls whether children routes can be activated'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanActivateChild` : 控制子路由是否可以激活'
- en: '`CanDeactivate` : Controls whether a route can be deactivated'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanDeactivate` : 控制是否可以停用路由'
- en: Deactivation happens when we navigate away from a route.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 停用发生在我们从路由导航离开时。
- en: '`CanMatch` : Controls whether a route can be accessed at all'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanMatch`：控制是否可以访问任何路由'
- en: 'Select `CanActivate` and press *Enter* . The Angular CLI creates the following
    `auth.guard.ts` file:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`CanActivate`并按*Enter*。Angular CLI创建以下`auth.guard.ts`文件：
- en: '[PRE50]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The guard that we created is a function of type `CanActivateFn` , which accepts
    two parameters:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的守卫是一个`CanActivateFn`类型的函数，它接受两个参数：
- en: '`route` : Indicates the route that will be activated'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`route`：指示将要激活的路由'
- en: '`state` : Contains the state of the router upon successful navigation'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`：包含成功导航时的路由器状态'
- en: The `CanActivateFn` function can return a boolean value, either synchronously
    or asynchronously. In the latter case, the router will wait for the observable
    or the promise to resolve before continuing. If the asynchronous event does not
    complete, the navigation will not continue. It can also return a `UrlTree` object,
    which will cause new navigation to a defined route.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`CanActivateFn`函数可以同步或异步地返回一个布尔值。在后一种情况下，路由器将等待可观察对象或承诺解析完成后再继续。如果异步事件没有完成，导航将不会继续。它还可以返回一个`UrlTree`对象，这将导致新的导航到定义的路由。'
- en: 'Our guard returns `true` immediately, allowing free access to the route. Let’s
    add custom logic to control access based on whether the user is logged in:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的守卫立即返回`true`，允许自由访问路由。让我们添加自定义逻辑来根据用户是否登录来控制访问：
- en: 'Modify the `import` statements as follows:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式修改`import`语句：
- en: '[PRE51]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Replace the body of the arrow function with the following snippet:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将箭头函数的主体替换为以下代码片段：
- en: '[PRE52]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the preceding snippet, we use the `inject` method to inject the `AuthService`
    and `Router` services into the function. We then check the value of the `isLoggedIn`
    signal. If it is `true` , we allow the application to navigate to the requested
    route. Otherwise, we use the `parseUrl` method of the `Router` service to navigate
    to the root path of the Angular application.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用`inject`方法将`AuthService`和`Router`服务注入到函数中。然后我们检查`isLoggedIn`信号值的真假。如果它是`true`，我们允许应用程序导航到请求的路由。否则，我们使用`Router`服务的`parseUrl`方法导航到Angular应用程序的根路径。
- en: The `parseUrl` method returns a `UrlTree` object, which effectively cancels
    the previous navigation and redirects the user to the URL passed in the parameter.
    It is advised to use it over the `navigate` method, which may introduce unexpected
    behavior and can lead to complex navigation issues.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseUrl`方法返回一个`UrlTree`对象，它实际上取消了之前的导航并将用户重定向到参数中传入的URL。建议使用它而不是`navigate`方法，因为`navigate`方法可能会引入意外的行为，并可能导致复杂的导航问题。'
- en: 'Open the `app.routes.ts` file and add the following `import` statement:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.routes.ts`文件并添加以下`import`语句：
- en: '[PRE53]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Add the `authGuard` function in the `canActivate` array of the `cart` route:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`cart`路由的`canActivate`数组中添加`authGuard`函数：
- en: '[PRE54]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `canActivate` property is an array because multiple guards can control route
    activation. The order of guards in the array is important. If one of the guards
    fails to pass, Angular will prevent access to the route.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`canActivate`属性是一个数组，因为多个守卫可以控制路由激活。数组中守卫的顺序很重要。如果数组中的任何一个守卫未能通过，Angular将阻止访问该路由。'
- en: Only authenticated users can now access the shopping cart. If you run the application
    using the `ng serve` command and click the **My Cart** link, you will notice that
    nothing happens.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 只有经过身份验证的用户现在才能访问购物车。如果你使用`ng serve`命令运行应用程序并点击**我的购物车**链接，你会注意到没有任何反应。
- en: When you try to access the shopping cart from the product list, you always remain
    on the same page. This is because the redirection that happens due to the authentication
    guard does not have any effect when you are already in the redirected route.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试从产品列表访问购物车时，你总是停留在同一页面上。这是因为由于身份验证守卫导致的重定向在你已经在重定向的路由中时没有任何效果。
- en: Another guard type related to the activation of a route is the `CanDeactivate`
    guard. In the following section, we will learn how to use it to prevent a user
    leaving a route.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 与路由激活相关的另一种守卫类型是`CanDeactivate`守卫。在下一节中，我们将学习如何使用它来防止用户离开路由。
- en: Preventing navigation away from a route
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止从路由导航离开
- en: 'A guard that controls if a route can be deactivated is a function of the `CanDeactivateFn`
    type. We will learn how to use it by implementing a guard that notifies the user
    of pending products in the cart when they navigate away from the cart component:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 控制路由是否可以被退出的守卫是一个`CanDeactivateFn`类型的函数。我们将通过实现一个守卫来学习如何使用它，当用户从购物车组件导航离开时，它会通知用户购物车中有待处理的产品：
- en: 'Run the following command to generate a new guard:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以生成一个新的守卫：
- en: '[PRE55]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Select the `CanDeactivate` type from the list and press *Enter* .
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中选择`CanDeactivate`类型并按*Enter*键。
- en: 'Open the `checkout.guard.ts` file and add the following `import` statement:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`checkout.guard.ts`文件并添加以下`import`语句：
- en: '[PRE56]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Change the generic of the `CanDeactivateFn` to `CartComponent` and remove the
    parameters of the arrow function.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CanDeactivateFn`的泛型更改为`CartComponent`并移除箭头函数的参数。
- en: In a real-world scenario, we will probably need to add more components in the
    generics to create a generic guard.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的场景中，我们可能需要在泛型中添加更多组件来创建一个泛型守卫。
- en: 'Replace the body of the arrow function with the following snippet:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将箭头函数的主体替换为以下代码片段：
- en: '[PRE57]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the preceding snippet, we use the `confirm` method of the global `window`
    object to display a confirmation dialog before navigating away from the cart component.
    The application execution will wait until the confirmation dialog is dismissed
    as a user interaction.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用全局`window`对象的`confirm`方法在离开购物车组件之前显示一个确认对话框。应用程序执行将等待直到确认对话框被关闭，作为用户交互。
- en: 'Open the `app.routes.ts` file and add the following `import` statement:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.routes.ts`文件并添加以下`import`语句：
- en: '[PRE58]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'A route definition object contains a `canDeactivate` array similar to `canActivate`
    . Add the `checkoutGuard` function to the `canDeactivate` array of the `cart`
    route:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由定义对象包含一个类似于`canActivate`的`canDeactivate`数组。将`checkoutGuard`函数添加到`cart`路由的`canDeactivate`数组中：
- en: '[PRE59]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `canDeactivate` property is an array because multiple guards can control
    route deactivation. The order of guards in the array is important. If one of the
    guards fails to pass, Angular will prevent a user leaving the route.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`canDeactivate`属性是一个数组，因为多个守卫可以控制路由的停用。数组中守卫的顺序很重要。如果其中一个守卫未能通过，Angular将阻止用户离开该路由。'
- en: 'For such a simple scenario, we could have written the logic of the `checkoutGuard`
    function inline to avoid the creation of the `checkout.guard.ts` file:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样一个简单的场景，我们可以在内联中编写`checkoutGuard`函数的逻辑，以避免创建`checkout.guard.ts`文件：
- en: '[PRE60]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Run the application using the `ng serve` command and click the **My Cart**
    link after you have logged in. If you then click on the **Products** link or press
    the back button of the browser, you should see a dialog with the following message:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ng serve`命令运行应用程序，并在登录后点击**我的购物车**链接。如果你然后点击**产品**链接或按浏览器的后退按钮，你应该会看到一个包含以下信息的对话框：
- en: '**You have pending items in your cart. Do you want to continue?**'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**你的购物车中有待处理的项目。你想继续吗？**'
- en: If you click the **Cancel** button, the navigation is canceled, and the application
    remains in its current state. If you click the **OK** button, you will be redirected
    to the product list.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击**取消**按钮，导航将被取消，应用程序将保持当前状态。如果你点击**确定**按钮，你将被重定向到产品列表。
- en: Prefetching route data
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预取路由数据
- en: You may have noticed that when you navigate to the root path of the application
    for the first time, there is a delay in displaying the product list. It is reasonable
    since we are making an HTTP request to the backend API. However, the product list
    component was already initialized at that time.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当你第一次导航到应用程序的根路径时，产品列表的显示会有延迟。这是合理的，因为我们正在向后端API发出HTTP请求。然而，产品列表组件当时已经初始化了。
- en: The preceding behavior may lead to unwanted effects if the component contains
    logic that interacts with data during initialization. To solve this problem, we
    can use a **resolver** to prefetch the product list and load the component when
    data are available.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件在初始化期间与数据交互的逻辑导致这种行为，可能会导致不希望的效果。为了解决这个问题，我们可以使用**解析器**来预取产品列表并在数据可用时加载组件。
- en: A resolver can be handy when handling possible errors before activating a route.
    It would be more appropriate to navigate to an error page if the request to the
    API does not succeed instead of displaying a blank page.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在激活路由之前处理可能的错误时，解析器非常有用。如果API请求失败，导航到错误页面比显示空白页面更合适。
- en: 'To create a resolver, we use the `ng generate` command of the Angular CLI,
    passing the word `resolver` and its name as parameters:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个解析器，我们使用Angular CLI的`ng generate`命令，传递单词`resolver`及其名称作为参数：
- en: '[PRE61]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The preceding command creates the following `products.resolver.ts` file:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令创建以下`products.resolver.ts`文件：
- en: '[PRE62]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The resolver that we created is a function of type `ResolveFn` , which accepts
    two parameters:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的解析器是一个类型为`ResolveFn`的函数，它接受两个参数：
- en: '`route` : Indicates the route that will be activated'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`route`：指示将要激活的路由'
- en: '`state` : Contains the state of the activated route'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`：包含激活路由的状态'
- en: A `ResolveFn` function can return an observable or promise. The router will
    wait for the observable or the promise to resolve before continuing. If the asynchronous
    event does not complete, the navigation will not continue.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResolveFn`函数可以返回一个可观察对象或promise。路由器将在可观察对象或promise解析之前等待，如果异步事件未完成，则导航不会继续。'
- en: 'Currently, our resolver returns a boolean value. Let’s add custom logic so
    that it returns an array of products:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的解析器返回一个布尔值。让我们添加自定义逻辑，使其返回产品数组：
- en: 'Add the following `import` statements:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`import`语句：
- en: '[PRE63]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Modify the `productsResolver` function so that it returns a product array:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`productsResolver`函数，使其返回产品数组：
- en: '[PRE64]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Use the `inject` method to inject `ProductsService` in the function body:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`inject`方法在函数体中注入`ProductsService`：
- en: '[PRE65]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Use the `queryParamMap` property to get the `limit` parameter value from the
    current route:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`queryParamMap`属性从当前路由获取`limit`参数值：
- en: '[PRE66]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Replace the `return` statement with the following:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`return`语句替换为以下内容：
- en: '[PRE67]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The resulting function should look like the following:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成的函数应如下所示：
- en: '[PRE68]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now that we have created the resolver, we can connect it with the product list
    component:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了解析器，我们可以将其与产品列表组件连接起来：
- en: 'Open the `app.routes.ts` file and add the following `import` statement:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.routes.ts`文件并添加以下`import`语句：
- en: '[PRE69]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Add the following `resolve` property to the `products` route:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`resolve`属性添加到`products`路由：
- en: '[PRE70]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `resolve` property is an object that contains a unique name as a key and
    the resolver function as a value. The key name is important because we will use
    it in our components to access the resolved data.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`resolve`属性是一个包含唯一名称作为键和解析函数作为值的对象。键名称很重要，因为我们将使用它在我们的组件中访问解析数据。'
- en: 'Open the `product-list.component.ts` file and import the `of` operator from
    the `rxjs` npm package:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-list.component.ts`文件并从`rxjs`npm包中导入`of`运算符：
- en: '[PRE71]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Modify the `getProducts` method so that it subscribes to the `data` property
    of the `ActivatedRoute` service:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`getProducts`方法，使其订阅`ActivatedRoute`服务的`data`属性：
- en: '[PRE72]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In the preceding snippet, the `data` observable emits an object whose value
    exists in the `products` key. Notice that we use the `switchMap` operator to return
    products in a new observable.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`data`可观察对象发出一个对象，其值存在于`products`键中。请注意，我们使用`switchMap`运算符在新的可观察对象中返回产品。
- en: At this point, we can also remove any references to the `ProductsService` class
    because it is not needed anymore.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们也可以删除对`ProductsService`类的任何引用，因为它不再需要了。
- en: Run the `ng serve` command to start the application and verify that the product
    list is displayed when navigating to `http://localhost:4200` .
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ng serve`命令以启动应用程序并验证在导航到`http://localhost:4200`时是否显示产品列表。
- en: Angular resolvers improve application performance when complex initialization
    logic exists in routed components. Another way to improve the application performance
    is to load components or child routes on demand, as we will learn in the following
    section.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由组件中存在复杂的初始化逻辑时，Angular解析器可以提高应用程序性能。提高应用程序性能的另一种方法是按需加载组件或子路由，我们将在下一节中学习。
- en: Lazy-loading parts of the application
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒加载应用程序的部分
- en: Our application may grow at some point, and the amount of data we put into it
    may also increase. The application may take a long time to start initially, or
    certain parts can take a long time to load. To overcome these problems, we can
    use a technique called **lazy loading** .
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，我们的应用程序可能会增长，我们放入其中的数据量也可能增加。应用程序可能需要很长时间才能启动，或者某些部分可能需要很长时间才能加载。为了克服这些问题，我们可以使用称为**懒加载**的技术。
- en: 'Lazy loading means we don’t initially load certain application parts, such
    as Angular components or routes. There are many advantages of lazy loading in
    an Angular application:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载意味着我们最初不会加载某些应用程序部分，例如Angular组件或路由。在Angular应用程序中，懒加载有许多优点：
- en: Components and routes can be loaded upon request from the user
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件和路由可以根据用户请求进行加载
- en: Users who visit certain areas of your application can significantly benefit
    from this technique
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问您应用程序特定区域的用户可以从这项技术中显著受益
- en: We can add more features in a lazy-loaded area without affecting the overall
    application bundle size
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在懒加载区域添加更多功能，而不会影响整体应用程序包的大小
- en: To understand how lazy loading in Angular works, we will create a new component
    that displays the current user profile.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解Angular中的懒加载是如何工作的，我们将创建一个新的组件来显示当前用户的个人资料。
- en: A good practice is to lazy-load parts of the application that are not used frequently,
    such as the profile of the currently logged-in user.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的做法是懒加载那些不常使用的应用程序部分，例如当前登录用户的个人资料。
- en: 'Let’s get started:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'Run the following command to create an Angular component:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令创建Angular组件：
- en: '[PRE73]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Create a file named `user.routes.ts` in the `src\app` folder and add the following
    content:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src\app`文件夹中创建一个名为`user.routes.ts`的文件，并添加以下内容：
- en: '[PRE74]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In the preceding snippet, we set the `path` property to an empty string to activate
    the route by default. We also use the `default` keyword to benefit from the default
    export feature in lazy loading.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将`path`属性设置为空字符串以默认激活路由。我们还使用`default`关键字来利用懒加载中的默认导出功能。
- en: 'Open the `app.routes.ts` file and add the following route definition in the
    `routes` variable:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.routes.ts`文件并在`routes`变量中添加以下路由定义：
- en: '[PRE75]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `loadChildren` property of a route definition object is used to lazy-load
    Angular routes. It returns an arrow function that uses a dynamic `import` statement
    to lazy-load the routes file. The `import` function accepts the relative path
    of the routes file we want to import.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 路由定义对象的`loadChildren`属性用于懒加载Angular路由。它返回一个使用动态`import`语句懒加载路由文件的箭头函数。`import`函数接受我们想要导入的路由文件的相对路径。
- en: 'Add a new anchor element to the `<header>` element of the `app.component.html`
    file that links to the newly created route:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app.component.html`文件的`<header>`元素中添加一个新的锚点元素，链接到新创建的路由：
- en: '[PRE76]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Run the command `ng serve` and observe the output in the console window. It
    should look similar to the following:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行命令`ng serve`并观察控制台窗口中的输出。它应该类似于以下内容：
- en: '[PRE77]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In the preceding output, we can see that the Angular CLI has created a lazy
    chunk file named **user-routes** in addition to the initial chunk files of the
    application.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到Angular CLI除了创建了应用的初始块文件外，还创建了一个名为**user-routes**的懒加载块文件。
- en: Navigate with your browser to `http://localhost:4200` and open the developer
    tools.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的浏览器导航到`http://localhost:4200`并打开开发者工具。
- en: 'Click the **My Profile** link and inspect the **Network** requests tab:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**我的个人资料**链接并检查**网络**请求标签页：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, αριθμός  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_09_08.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图片，屏幕截图，字体，编号  自动生成的描述](img/B21418_09_08.png)'
- en: 'Figure 9.8: Lazy-loaded route'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8：懒加载路由
- en: The application initiates a new request to the chunk file, which is the bundle
    of the user route. The Angular framework creates a new bundle for each lazy-loaded
    artifact and does not include it in the main application bundle.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序向块文件发起新的请求，这是用户路由的包。Angular框架为每个懒加载的组件创建一个新的包，并且不将其包含在主应用程序包中。
- en: If you navigate away and click the **My Profile** link again, you will notice
    that the application does not make a new request to load the bundle file. As soon
    as a lazy-loaded route is requested, it is kept in memory and can be used for
    subsequent requests.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您离开导航并再次点击**我的个人资料**链接，您会注意到应用程序不会发出新的请求来加载包文件。一旦请求懒加载的路由，它就会被保留在内存中，并可用于后续请求。
- en: 'Lazy loading works not only with routes but also with components. We could
    have lazy-loaded the user component instead of the whole route by modifying the
    `user` route as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载不仅适用于路由，也适用于组件。我们可以通过修改`user`路由来懒加载用户组件而不是整个路由，如下所示：
- en: '[PRE78]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In the preceding snippet, we use the `loadComponent` property to import the
    `user.component.ts` file dynamically. The `import` function returns a promise
    that we chain with the `then` method to load the `UserComponent` class.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用`loadComponent`属性动态导入`user.component.ts`文件。`import`函数返回一个promise，我们通过`then`方法将其链接以加载`UserComponent`类。
- en: The user route is currently accessible for all users, even if not authenticated.
    In the following section, we will learn how to protect them using guards.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 用户路由目前对所有用户都可用，即使未经过身份验证。在下一节中，我们将学习如何使用守卫来保护它们。
- en: Protecting a lazy-loaded route
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保护懒加载路由
- en: We can control unauthorized access to a lazy-loaded route similarly to how we
    can on normal routes. However, our guards need to support a function type named
    `CanMatchFn` .
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像在正常路由上一样控制对懒加载路由的无授权访问。然而，我们的守卫需要支持一个名为`CanMatchFn`的函数类型。
- en: 'We will extend our authentication guard for use with lazy-loaded routes:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展我们的认证守卫以用于懒加载的路由：
- en: 'Open the `auth.guard.ts` file and import the `CanMatchFn` type from the `@angular/router`
    npm package:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `auth.guard.ts` 文件，并从 `@angular/router` npm 包中导入 `CanMatchFn` 类型：
- en: '[PRE79]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Modify the signature of the `authGuard` function as follows:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `authGuard` 函数的签名如下：
- en: '[PRE80]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Open the `app.routes.ts` file and add the `authGuard` function in the `canMatch`
    array of the `user` route:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app.routes.ts` 文件，并在 `user` 路由的 `canMatch` 数组中添加 `authGuard` 函数：
- en: '[PRE81]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `canMatch` property is an array because multiple guards can control route
    matching. The order of guards in the array is important. If one of the guards
    fails to match with a route, Angular will prevent access to the route.
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`canMatch` 属性是一个数组，因为多个守卫可以控制路由匹配。数组中守卫的顺序很重要。如果其中一个守卫无法与路由匹配，Angular 将阻止访问该路由。'
- en: If we now run the application and click the **My Profile** link, we will notice
    that we cannot navigate to the respective component unless we are authenticated.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用程序并点击 **我的资料** 链接，我们会注意到除非我们已认证，否则无法导航到相应的组件。
- en: Lazy loading is a technique preferred when the application performance is critical.
    Angular has also introduced a more performant feature to delay loading parts of
    an Angular application called **deferrable views** . Deferrable views give developers
    more fine-grained control over the conditions under which a part of the application
    will be loaded. We will explore deferrable views in *Chapter 15* , *Optimizing
    Application Performance* .
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序性能至关重要时，懒加载是一种首选的技术。Angular 还引入了一个更高效的功能，即延迟加载 Angular 应用程序的部分，称为 **可延迟视图**。可延迟视图让开发者能够更精细地控制应用的一部分将在何种条件下被加载。我们将在第
    15 章，*优化应用性能* 中探讨可延迟视图。
- en: Summary
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have now uncovered the power of the Angular router, and we hope you have
    enjoyed this journey into the intricacies of this library. One of the things that
    shines in the Angular router is the vast number of options and scenarios we can
    cover with such a simple but powerful implementation.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经揭开了 Angular 路由的威力，希望您已经享受了这次深入了解这个库的旅程。Angular 路由中闪耀的一点是，我们可以用这样简单但强大的实现覆盖大量的选项和场景。
- en: We have learned the basics of setting up routing and handling different types
    of parameters. We have also learned about more advanced features, such as child
    routing. Furthermore, we have learned how to protect our routes from unauthorized
    access. Finally, we have shown the full power of routing and how you can improve
    response time with lazy loading and prefetching.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了设置路由和处理不同类型参数的基础知识。我们还了解了更多高级功能，例如子路由。此外，我们还学习了如何保护我们的路由免受未经授权的访问。最后，我们展示了路由的全部威力以及如何通过懒加载和预加载来提高响应时间。
- en: In the next chapter, we will beef up our application components to showcase
    the mechanisms underlying web forms in Angular and the best strategies to grab
    user input with form controls.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将增强我们的应用组件，以展示 Angular 中 Web 表单背后的机制以及最佳策略，以使用表单控件捕获用户输入。
