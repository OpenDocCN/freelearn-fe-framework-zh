<html><head></head><body>
<section epub:type="frontmatter chapter" role="doc-chapter">
<h1 class="chapter-number" id="_idParaDest-116"><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-117"><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.2.1">Exploring Data Management in React</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In modern frontend development, the way we handle state and data access can make or break an application. </span><span class="koboSpan" id="kobo.3.2">Whether you’re a solo developer or part of a large team, understanding best practices and common pitfalls is critical. </span><span class="koboSpan" id="kobo.3.3">This chapter aims to elevate your proficiency in state management and data handling within React applications, focusing on scalable and maintainable approaches.</span></p>
<p><span class="koboSpan" id="kobo.4.1">State management is challenging, particularly in React, and there are many issues that developers tend to face in their day-to-day work. </span><span class="koboSpan" id="kobo.4.2">One of the challenges is where you can locate the business logic in your code base. </span><span class="koboSpan" id="kobo.4.3">When business logic infiltrates UI components, it compromises their reusability. </span><span class="koboSpan" id="kobo.4.4">Many domain objects, along with computational logic, are scattered in UI components either deliberately or unintentionally, which can lead to tangled logic that’s hard to follow, debug, and test. </span><span class="koboSpan" id="kobo.4.5">It can also lead to performance issues, which negatively affect the user experience.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Another issue is prop drilling, where passing props from a parent component to deeply nested children becomes both cumbersome and susceptible to errors. </span><span class="koboSpan" id="kobo.5.2">This often leads to code duplication as the same snippets find their way into multiple files, making any future updates a complicated task.</span></p>
<p><span class="koboSpan" id="kobo.6.1">Lastly, sharing state in a React application presents its own set of challenges. </span><span class="koboSpan" id="kobo.6.2">Various mechanisms exist for this, but choosing the most efficient way to share stateful logic across components can be quite perplexing. </span><span class="koboSpan" id="kobo.6.3">We’ll dive deep to explore the issues of sharing state and see how React’s Context API can help.</span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will cover the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.8.1">Understanding business logic leaks</span></li>
<li><span class="koboSpan" id="kobo.9.1">Introducing the anti-corruption layer</span></li>
<li><span class="koboSpan" id="kobo.10.1">Exploring the prop drilling issue</span></li>
<li><span class="koboSpan" id="kobo.11.1">Using the Context API to resolve prop drilling</span></li>
</ul>
<h1 id="_idParaDest-118"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.12.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.13.1">A GitHub repository has been created to host all the code we’ll discuss in this book. </span><span class="koboSpan" id="kobo.13.2">For this chapter, you can find the recommended structure at </span><a href="https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch8"><span class="koboSpan" id="kobo.14.1">https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch8</span></a><span class="koboSpan" id="kobo.15.1">.</span></p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.16.1">Understanding business logic leaks</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.17.1">Business logic</span></strong><span class="koboSpan" id="kobo.18.1"> refers to </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.19.1">the rules, calculations, and processes that are essential to the operation of a business application. </span><span class="koboSpan" id="kobo.19.2">When this business logic “leaks” into components or areas of the application where it doesn’t belong, this is known as a </span><strong class="bold"><span class="koboSpan" id="kobo.20.1">business </span></strong><strong class="bold"><span class="koboSpan" id="kobo.21.1">logic leak</span></strong><span class="koboSpan" id="kobo.22.1">.</span></p>
<p><span class="koboSpan" id="kobo.23.1">This issue </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.24.1">frequently crops up in various projects, partly because there’s no widely agreed-upon approach for handling business logic in React. </span><span class="koboSpan" id="kobo.24.2">The framework’s flexibility allows you to implement this logic directly in components, Hooks, or helper functions; as a result, developers often end up embedding the logic directly into components, where it’s immediately needed – hence the leakage.</span></p>
<p><span class="koboSpan" id="kobo.25.1">This leakage can cause many problems. </span><span class="koboSpan" id="kobo.25.2">Business logic leaks can result in tightly coupled components that become difficult to test, maintain, or reuse. </span><span class="koboSpan" id="kobo.25.3">When business logic is scattered across different parts of the application, it leads to code duplication and inconsistency, making the application more prone to errors and harder to debug. </span><span class="koboSpan" id="kobo.25.4">Additionally, this scattering complicates any future modifications to the business rules as changes will likely have to be made in multiple places, increasing the risk of introducing new issues.</span></p>
<p><span class="koboSpan" id="kobo.26.1">There are various indicators that business logic is leaking into your code, but the most prevalent sign is the incorporation of data transformation directly within views or UI components. </span><span class="koboSpan" id="kobo.26.2">In this section, we’ll delve into this issue in depth; in the following section, we’ll explore solutions to mitigate this problem.</span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.27.1">Data transformation</span></strong><span class="koboSpan" id="kobo.28.1"> is a function </span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.29.1">that takes one shape (or format) of data (usually from another module or a remote service) and maps the data to the shape that fits another usage. </span><span class="koboSpan" id="kobo.29.2">The following is a typical example you would see in many </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.30.1">React applications, showing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.31.1">UserProfile</span></strong><span class="koboSpan" id="kobo.32.1"> function:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.33.1">
function UserProfile({ id }: { id: string }) {
  const [user, setUser] = useState&lt;User | null&gt;(null);
  useEffect(() =&gt; {
    async function fetchUser() {
      const response = await fetch(`/api/users/${id}`);
      const data = await response.json();
      setUser({
        id: data.user_identification,
        name: data.user_full_name,
        isPremium: data.is_premium_user,
        subscription: data.subscription_details.level,
        expire: data.subscription_details.expiry,
      });
    }
    fetchUser();
  }, [id]);
  if (!user) {
    return &lt;div&gt;Loading...&lt;/div&gt;;
  }
  return (
    &lt;div data-testid="user-profile"&gt;
      &lt;h1&gt;{user.name}&lt;/h1&gt;
    &lt;/div&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.34.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.35.1">UserProfile</span></strong><span class="koboSpan" id="kobo.36.1"> function component fetches user data from a backend API. </span><span class="koboSpan" id="kobo.36.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.37.1">useEffect</span></strong><span class="koboSpan" id="kobo.38.1"> Hook ensures that data fetching happens whenever the ID changes. </span><span class="koboSpan" id="kobo.38.2">The fetched data is then stored in a local state variable, </span><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">user</span></strong><span class="koboSpan" id="kobo.40.1">, and the component displays the user’s name </span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.41.1">once the data is available. </span><span class="koboSpan" id="kobo.41.2">If the data is still loading, a </span><strong class="bold"><span class="koboSpan" id="kobo.42.1">Loading…</span></strong><span class="koboSpan" id="kobo.43.1"> message is displayed.</span></p>
<p><span class="koboSpan" id="kobo.44.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">useEffect</span></strong><span class="koboSpan" id="kobo.46.1"> block, the fetched data transforms being stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">user</span></strong><span class="koboSpan" id="kobo.48.1"> state variable. </span><span class="koboSpan" id="kobo.48.2">Specifically, the keys from the fetched JSON response are mapped to new names that are more suitable for the frontend application – for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">data.user_identification</span></strong><span class="koboSpan" id="kobo.50.1"> becomes </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">id</span></strong><span class="koboSpan" id="kobo.52.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">data.user_full_name</span></strong><span class="koboSpan" id="kobo.54.1"> becomes </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">name</span></strong><span class="koboSpan" id="kobo.56.1">. </span><span class="koboSpan" id="kobo.56.2">This transformation allows for easier handling and readability within the React component.</span></p>
<p><span class="koboSpan" id="kobo.57.1">As you might imagine, this type of transformation can happen in many places in an application, and it isn’t limited to the inside of a React component; sometimes, this transformation can be present in Hooks and other places, as demonstrated in the following figure:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer049">
<span class="koboSpan" id="kobo.58.1"><img alt="Figure 8.1: Using data transformation in views" src="image/B21103_08_01.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.59.1">Figure 8.1: Using data transformation in views</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.60.1">The backend service can serve data in various formats that are supported by different technologies – some utilize RESTful APIs, while others employ GraphQL. </span><span class="koboSpan" id="kobo.60.2">From the perspective of </span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.61.1">the frontend code, the specifics of these formats are abstracted away. </span><span class="koboSpan" id="kobo.61.2">For instance, one component may be responsible for transforming XML data (indicated by an orange diamond shape) into an internal type, </span><i class="italic"><span class="koboSpan" id="kobo.62.1">X</span></i><span class="koboSpan" id="kobo.63.1"> (depicted as a blue square). </span><span class="koboSpan" id="kobo.63.2">Meanwhile, another component may interact with a GraphQL endpoint, processing the received data (represented by a red circle) into the same internal type, </span><i class="italic"><span class="koboSpan" id="kobo.64.1">X</span></i><span class="koboSpan" id="kobo.65.1">.</span></p>
<p><span class="koboSpan" id="kobo.66.1">This discrepancy necessitates data transformations across multiple areas in the code. </span><span class="koboSpan" id="kobo.66.2">When such transformations are duplicated, there’s a higher risk of overlooking changes, especially if the backend alters the structure of their data.</span></p>
<p><span class="koboSpan" id="kobo.67.1">All these varied transformations can be centralized into a single location where data reshaping occurs, along with empty field checks, field renaming, and the elimination of unnecessary fields. </span><span class="koboSpan" id="kobo.67.2">This segues nicely into our next topic: the </span><strong class="bold"><span class="koboSpan" id="kobo.68.1">anti-corruption </span></strong><strong class="bold"><span class="koboSpan" id="kobo.69.1">layer</span></strong><span class="koboSpan" id="kobo.70.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.71.1">A</span><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.72.1">CL</span></strong><span class="koboSpan" id="kobo.73.1">).</span></p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.74.1">Introducing the ACL</span></h1>
<p><span class="koboSpan" id="kobo.75.1">In software development, an ACL acts like a translator or a mediator between different subsystems </span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.76.1">that may not speak the same “language,” so to speak. </span><span class="koboSpan" id="kobo.76.2">Imagine that you have two systems, each with its own set of rules, structures, and complexities. </span><span class="koboSpan" id="kobo.76.3">If these systems interact directly, there’s a risk that they could influence each </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.77.1">other in unintended ways, leading to what is called </span><i class="italic"><span class="koboSpan" id="kobo.78.1">corruption</span></i><span class="koboSpan" id="kobo.79.1"> in the domain logic.</span></p>
<p><span class="koboSpan" id="kobo.80.1">In the context of frontend development, especially in complex applications, an ACL becomes crucial for managing the interactions between the frontend and various backends or APIs. </span><span class="koboSpan" id="kobo.80.2">Frontend developers often have to deal with multiple services that may have inconsistent or convoluted data formats. </span><span class="koboSpan" id="kobo.80.3">Implementing an ACL in the frontend allows you to create a unified interface to interact with these services.</span></p>
<p><span class="koboSpan" id="kobo.81.1">For example, if your frontend application has to communicate with multiple RESTful APIs, GraphQL services, and even WebSocket servers, each may have its own set of rules, data structures, and complexities. </span><span class="koboSpan" id="kobo.81.2">A frontend ACL would take on the role of translating these disparate forms of data into a format that your frontend application understands. </span><span class="koboSpan" id="kobo.81.3">This means that your UI components don’t have to worry about the intricate details of each service’s data format, making the components easier to develop, test, and maintain.</span></p>
<p><span class="koboSpan" id="kobo.82.1">The ACL can also be a strategic place to handle caching, error transformations, and other cross-cutting concerns. </span><span class="koboSpan" id="kobo.82.2">By centralizing these functionalities, you avoid scattering similar logic all </span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.83.1">over your frontend code base, thus adhering to the </span><strong class="bold"><span class="koboSpan" id="kobo.84.1">Don’t Repeat Yourself</span></strong><span class="koboSpan" id="kobo.85.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.86.1">DRY</span></strong><span class="koboSpan" id="kobo.87.1">) principle:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer050">
<span class="koboSpan" id="kobo.88.1"><img alt="Figure 8.2: Introduced ACL for data transforming" src="image/B21103_08_02.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.89.1">Figure 8.2: Introduced ACL for data transforming</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.90.1">As illustrated in </span><i class="italic"><span class="koboSpan" id="kobo.91.1">Figure 8</span></i><i class="italic"><span class="koboSpan" id="kobo.92.1">.2</span></i><span class="koboSpan" id="kobo.93.1">, all data transformations are now centralized, eliminating the need for </span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.94.1">such operations in the views. </span><span class="koboSpan" id="kobo.94.2">You might be curious about how to put this into practice in your code.</span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.95.1">Introducing a typical usage</span></h2>
<p><span class="koboSpan" id="kobo.96.1">To get started, let’s build on the example from the previous section and introduce a basic function </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.97.1">as the starting point for our ACL. </span><span class="koboSpan" id="kobo.97.2">We should identify the external data format and what we consume, then define functions as the transformers before putting them in a common place.</span></p>
<p><span class="koboSpan" id="kobo.98.1">First, let’s define a type for the user data format we receive from the remote server. </span><span class="koboSpan" id="kobo.98.2">By using TypeScript, we gain the advantage of compile-time checks, thereby ensuring that any inconsistencies in the data format are flagged before the application runs:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.99.1">
type RemoteUser = {
  user_identification: string;
  user_full_name: string;
  is_premium_user: boolean;
  subscription_details: {
    level: string;
    expiry: string;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.100.1">We will </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.101.1">also define the local </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">User</span></strong><span class="koboSpan" id="kobo.103.1"> type – it includes all fields (</span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">id</span></strong><span class="koboSpan" id="kobo.105.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">name</span></strong><span class="koboSpan" id="kobo.107.1">, and so on) that we use in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">UserProfile</span></strong><span class="koboSpan" id="kobo.109.1"> component:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.110.1">
type UserSubscription = "Basic" | "Standard" | "Premium" | "Enterprise";
type User = {
  id: string;
  name: string;
  isPremium: boolean;
  subscription: UserSubscription;
  expire: string;
};</span></pre> <p><span class="koboSpan" id="kobo.111.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">type</span></strong><span class="koboSpan" id="kobo.113.1"> definition specifies the structure of a user object that will be used in React components. </span><span class="koboSpan" id="kobo.113.2">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">subscription</span></strong><span class="koboSpan" id="kobo.115.1"> property uses a custom type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">UserSubscription</span></strong><span class="koboSpan" id="kobo.117.1">, which can take one of four string values: </span><strong class="bold"><span class="koboSpan" id="kobo.118.1">Basic</span></strong><span class="koboSpan" id="kobo.119.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.120.1">Standard</span></strong><span class="koboSpan" id="kobo.121.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.122.1">Premium</span></strong><span class="koboSpan" id="kobo.123.1">, or </span><strong class="bold"><span class="koboSpan" id="kobo.124.1">Enterprise</span></strong><span class="koboSpan" id="kobo.125.1">. </span><span class="koboSpan" id="kobo.125.2">Also, </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">expire</span></strong><span class="koboSpan" id="kobo.127.1"> is a string that indicates when the user’s subscription will expire.</span></p>
<p><span class="koboSpan" id="kobo.128.1">With this setup, we can define a new function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">transformUser</span></strong><span class="koboSpan" id="kobo.130.1"> in a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">transformer.ts</span></strong><span class="koboSpan" id="kobo.132.1">. </span><span class="koboSpan" id="kobo.132.2">The file simply returns the mapped object with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">User</span></strong><span class="koboSpan" id="kobo.134.1"> type we just defined:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.135.1">
import {RemoteUser, User, UserSubscription} from "./types";
export const transformUser = (remoteUser: RemoteUser): User =&gt; {
  return {
    id: remoteUser.user_identification,
    name: remoteUser.user_full_name,
    isPremium: remoteUser.is_premium_user,
    subscription: remoteUser.subscription_details.level as 
     UserSubscription,
    expire: remoteUser.subscription_details.expiry,
  };
};</span></pre> <p><span class="koboSpan" id="kobo.136.1">With this </span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.137.1">new extracted function in </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">transformer.ts</span></strong><span class="koboSpan" id="kobo.139.1">, our component can be simplified like so:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.140.1">
async function fetchUserData&lt;T&gt;(id: string) {
  const response = await fetch(`/api/users/${id}`);
  const rawData = await response.json();
  return transformUser(rawData) as T;
}
function UserProfile({ id }: { id: string }) {
  const [user, setUser] = useState&lt;User | null&gt;(null);
  useEffect(() =&gt; {
    async function fetchUser() {
      const response = await fetchUserData&lt;User&gt;(id);
      setUser(response);
    }
    fetchUser();
  }, [id]);
  if (!user) {
    return &lt;div&gt;Loading…&lt;/div&gt;;
  }
  return (
    &lt;div data-tested="user-profile"&gt;
      &lt;h1&gt;{user.name}&lt;/h1&gt;
    &lt;/div&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.141.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">UserProfile</span></strong><span class="koboSpan" id="kobo.143.1"> component relies on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">fetchUserData</span></strong><span class="koboSpan" id="kobo.145.1"> helper function to retrieve and </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.146.1">process user data from an API. </span><span class="koboSpan" id="kobo.146.2">This design insulates </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">UserProfile</span></strong><span class="koboSpan" id="kobo.148.1"> from any knowledge of the remote data structure. </span><span class="koboSpan" id="kobo.148.2">If there are future changes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">RemoteUser</span></strong><span class="koboSpan" id="kobo.150.1"> type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">UserProfile</span></strong><span class="koboSpan" id="kobo.152.1"> remains unaffected as all the adjustments will be confined to </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">transformer.ts</span></strong><span class="koboSpan" id="kobo.154.1">.</span></p>
<p><span class="koboSpan" id="kobo.155.1">It’s advantageous to have a distinct function dedicated to managing remote data and molding it to suit the requirements of higher-level views. </span><span class="koboSpan" id="kobo.155.2">However, complications arise when the backend fails to deliver the necessary data. </span><span class="koboSpan" id="kobo.155.3">In such scenarios, additional logic is necessitated in this layer to establish fallback or defa</span><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.156.1">ult values.</span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.157.1">Using the fallback or default value</span></h2>
<p><span class="koboSpan" id="kobo.158.1">Another frequently observed issue related to data transformation is the excessive use of defensive </span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.159.1">programming in React views. </span><span class="koboSpan" id="kobo.159.2">While defensive programming is generally good practice and useful in various contexts, overloading React components with too many null checks and fallbacks can clutter the code and make it difficult to comprehend.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.160.1">Note</span></p>
<p class="callout"><strong class="bold"><span class="koboSpan" id="kobo.161.1">Defensive programming</span></strong><span class="koboSpan" id="kobo.162.1"> is a practice that involves writing code in a way that anticipates </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.163.1">possible errors, failures, or exceptions, and handles them gracefully. </span><span class="koboSpan" id="kobo.163.2">The goal is to make your application more resilient and maintainable by minimizing the impact of unexpected scenarios.</span></p>
<p><span class="koboSpan" id="kobo.164.1">For instance, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">UserProfile</span></strong><span class="koboSpan" id="kobo.166.1"> example, you might encounter situations where certain values from the remote service are empty. </span><span class="koboSpan" id="kobo.166.2">Instead of displaying </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">null</span></strong><span class="koboSpan" id="kobo.168.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">undefined</span></strong><span class="koboSpan" id="kobo.170.1"> to end users, you would need to implement fallback values.</span></p>
<p><span class="koboSpan" id="kobo.171.1">Let’s review the </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">transformUser</span></strong><span class="koboSpan" id="kobo.173.1"> function we extracted previously:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.174.1">
export const transformUser = (remoteUser: RemoteUser): User =&gt; {
  return {
    id: remoteUser.user_identification,
    name: remoteUser.user_full_name,
    isPremium: remoteUser.is_premium_user,
    subscription: remoteUser.subscription_details.level as 
     UserSubscription,
    expire: remoteUser.subscription_details.expiry,
  };
};</span></pre> <p><span class="koboSpan" id="kobo.175.1">What if </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">subscription_details</span></strong><span class="koboSpan" id="kobo.177.1"> doesn’t exist, or what happens when </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">expiry</span></strong><span class="koboSpan" id="kobo.179.1"> isn’t a valid date format from the backend? </span><span class="koboSpan" id="kobo.179.2">These mismatches can cause runtime exceptions, so we should fall back to some default value when the remote data isn’t in the right format.</span></p>
<p><span class="koboSpan" id="kobo.180.1">We could </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.181.1">put the fallback logic into components, right before we render them. </span><span class="koboSpan" id="kobo.181.2">Without the ACL, we might end up with some logic in </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">UserProfile</span></strong><span class="koboSpan" id="kobo.183.1">, like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.184.1">
function UserProfile({ user }: { user: User }) {
  const fullName = user &amp;&amp; user.name ? </span><span class="koboSpan" id="kobo.184.2">user.name : "Loading"…";
  const subscriptionLevel =
    user &amp;&amp; user.subscription ? </span><span class="koboSpan" id="kobo.184.3">user.subscription": "Basic";
  const subscriptionExpiry = user &amp;&amp; user.expire ? </span><span class="koboSpan" id="kobo.184.4">user.expire": 
   "Never";
  return (
    &lt;div&gt;
      &lt;h1&gt;{fullName}&lt;/h1&gt;
      &lt;p&gt;Subscription Level: {subscriptionLevel}&lt;/p&gt;
      &lt;p&gt;Subscription Expiry: {subscriptionExpiry}&lt;/p&gt;
    &lt;/div&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.185.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">UserProfile</span></strong><span class="koboSpan" id="kobo.187.1"> function component takes a user object as a prop. </span><span class="koboSpan" id="kobo.187.2">It displays the user’s full name, subscription level, and subscription expiry date. </span><span class="koboSpan" id="kobo.187.3">If any of these values are missing or falsy, it provides default fallback text such as </span><strong class="bold"><span class="koboSpan" id="kobo.188.1">Loading…</span></strong><span class="koboSpan" id="kobo.189.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.190.1">Basic</span></strong><span class="koboSpan" id="kobo.191.1">, or </span><strong class="bold"><span class="koboSpan" id="kobo.192.1">Never</span></strong><span class="koboSpan" id="kobo.193.1">.</span></p>
<p><span class="koboSpan" id="kobo.194.1">As such, logic begins to infiltrate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">UserProfile</span></strong><span class="koboSpan" id="kobo.196.1"> component, increasing the component’s length and therefore complexity.</span></p>
<p><span class="koboSpan" id="kobo.197.1">This kind of logic can be better managed by moving it into a function such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">transformUser</span></strong><span class="koboSpan" id="kobo.199.1">, where it can be thoroughly tested:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.200.1">
export const transformUser = (remoteUser: RemoteUser): User =&gt; {
  return {
    id: remoteUser.user_identification ?? </span><span class="koboSpan" id="kobo.200.2">'N/A',
    name: remoteUser.user_full_name ?? </span><span class="koboSpan" id="kobo.200.3">'Unknown User',
    isPremium: remoteUser.is_premium_user ?? </span><span class="koboSpan" id="kobo.200.4">false,
    subscription: (remoteUser.subscription_details?.level ?? </span><span class="koboSpan" id="kobo.200.5">'Basic') 
     as UserSubscription,
    expire: remoteUser.subscription_details?.expiry ?? </span><span class="koboSpan" id="kobo.200.6">'Never',
  };
};</span></pre> <p><span class="koboSpan" id="kobo.201.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">transformUser</span></strong><span class="koboSpan" id="kobo.203.1"> function maps fields from the remote user data structure to the application’s expected </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">user</span></strong><span class="koboSpan" id="kobo.205.1"> data structure, providing default values for each field in case they are missing or null. </span><span class="koboSpan" id="kobo.205.2">For example, if </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">remoteUser.user_identification</span></strong><span class="koboSpan" id="kobo.207.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">null</span></strong><span class="koboSpan" id="kobo.209.1">, it will use </span><strong class="bold"><span class="koboSpan" id="kobo.210.1">N/A</span></strong><span class="koboSpan" id="kobo.211.1"> as the default ID.</span></p>
<p><span class="koboSpan" id="kobo.212.1">Note </span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.213.1">that here, we use </span><strong class="bold"><span class="koboSpan" id="kobo.214.1">optional chaining</span></strong><span class="koboSpan" id="kobo.215.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">?</span></strong><span class="koboSpan" id="kobo.217.1">), which allows </span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.218.1">you to access deeply nested properties without checking each level of nesting. </span><span class="koboSpan" id="kobo.218.2">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">subscription_details</span></strong><span class="koboSpan" id="kobo.220.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">level</span></strong><span class="koboSpan" id="kobo.222.1"> is null or undefined, the result, </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">subscription</span></strong><span class="koboSpan" id="kobo.224.1">, will also </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.225.1">be undefined and no errors will be thrown. </span><span class="koboSpan" id="kobo.225.2">We also used </span><strong class="bold"><span class="koboSpan" id="kobo.226.1">nullish coalescing</span></strong><span class="koboSpan" id="kobo.227.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">??</span></strong><span class="koboSpan" id="kobo.229.1">) for falling back – it takes the value on its left if that value isn’t null or undefined; otherwise, it takes the value on its right.</span></p>
<p><span class="koboSpan" id="kobo.230.1">All this transforming and fallback logic is now encapsulated in a common place – the ACL. </span><span class="koboSpan" id="kobo.230.2">Any further changes to the remote or local data shape can easily happen in this layer, and we don’t have to look up the entire code base for different usages.</span></p>
<p><span class="koboSpan" id="kobo.231.1">Excellent – the ACL pattern effectively isolates business logic from your views. </span><span class="koboSpan" id="kobo.231.2">However, there are additional challenges in managing data within a React application, such as sharing data between components and avoiding prop drilling. </span><span class="koboSpan" id="kobo.231.3">In the following section, we’ll explore how to tackle these issues using</span><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.232.1"> the Context API.</span></p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.233.1">Exploring the prop drilling issue</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.234.1">Prop drilling</span></strong><span class="koboSpan" id="kobo.235.1"> is an issue </span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.236.1">that arises when you have to pass data through multiple levels of components that don’t need the data, just so it can reach a component deeper in the hierarchy that does need it. </span><span class="koboSpan" id="kobo.236.2">This often makes the code harder to follow, understand, and maintain.</span></p>
<p><span class="koboSpan" id="kobo.237.1">Consider a standard scenario in React where we have a universal searchable list component. </span><span class="koboSpan" id="kobo.237.2">This component takes in a list and displays each item, whether it’s a list of books, menus, tickets, or anything else you can think of. </span><span class="koboSpan" id="kobo.237.3">In addition to displaying the list, the component also includes a search box, allowing users to easily filter through a lengthy list:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer051">
<span class="koboSpan" id="kobo.238.1"><img alt="Figure 8.3: The searchable list component" src="image/B21103_08_03.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.239.1">Figure 8.3: The searchable list component</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.240.1">At first </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.241.1">glance, the implementation seems straightforward and not overly complicated:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.242.1">
import React, { ChangeEvent, useState } from "react";
export type Item = {
  id: string;
  name: string;
  description: string;
};
const SearchableList = ({ items }: { items: Item[] }) =&gt; {
  const [filteredItems, setFilteredItems] = useState&lt;Item[]&gt;(items);
  const handleChange = (e: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    setFilteredItems(
      items.filter((item) =&gt; item.name.includes(e.target.value))
    );
  };
  return (
    &lt;div&gt;
      &lt;input type="text" onChange={handleChange} /&gt;
      &lt;ul&gt;
        {filteredItems.map((item, index) =&gt; (
          &lt;li key={index}&gt;{item.name}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};
export default SearchableList;</span></pre> <p><span class="koboSpan" id="kobo.243.1">The code defines a </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">SearchableList</span></strong><span class="koboSpan" id="kobo.245.1"> component in React that filters and displays a list of items </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.246.1">based on user input. </span><span class="koboSpan" id="kobo.246.2">It starts with a full list of items and updates the filtered list whenever the text in the input box changes.</span></p>
<p><span class="koboSpan" id="kobo.247.1">Over time, as the component evolves and is used in more diverse scenarios, the code base becomes increasingly complex, resulting in additional layout changes and more lines of code. </span><span class="koboSpan" id="kobo.247.2">As illustrated in </span><i class="italic"><span class="koboSpan" id="kobo.248.1">Figure 8</span></i><i class="italic"><span class="koboSpan" id="kobo.249.1">.4</span></i><span class="koboSpan" id="kobo.250.1">, on the right-hand side, we can break the searchable list input into three sub-components called </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">SearchInput</span></strong><span class="koboSpan" id="kobo.252.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">List</span></strong><span class="koboSpan" id="kobo.254.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">ListItem</span></strong><span class="koboSpan" id="kobo.256.1">:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer052">
<span class="koboSpan" id="kobo.257.1"><img alt="Figure 8.4: Breaking a searchable list into smaller components" src="image/B21103_08_04.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.258.1">Figure 8.4: Breaking a searchable list into smaller components</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.259.1">On the right-hand side, </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">SearchInput</span></strong><span class="koboSpan" id="kobo.261.1"> accepts the user’s input (in the top red rectangle). </span><span class="koboSpan" id="kobo.261.2">It is a sibling of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">List</span></strong><span class="koboSpan" id="kobo.263.1"> component (inside the green rectangle), which contains multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">ListItem</span></strong><span class="koboSpan" id="kobo.265.1"> (in the purple rectangle) – each </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">ListItem</span></strong><span class="koboSpan" id="kobo.267.1"> represents an item (one might have a title, description, or buttons in it).</span></p>
<p><span class="koboSpan" id="kobo.268.1">Let’s look </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.269.1">at each of these extracted components in detail:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.270.1">
const ListItem = ({ item }: { item: Item }) =&gt; {
  return (
    &lt;li&gt;
      &lt;h2&gt;{item.name}&lt;/h2&gt;
      &lt;p&gt;{item.description}&lt;/p&gt;
    &lt;/li&gt;
  );
};</span></pre> <p><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">ListItem</span></strong><span class="koboSpan" id="kobo.272.1"> displays the name and description of an item. </span><span class="koboSpan" id="kobo.272.2">For any further details that are needed, we only need to modify this file directly.</span></p>
<p><span class="koboSpan" id="kobo.273.1">Then, each </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">ListItem</span></strong><span class="koboSpan" id="kobo.275.1"> is wrapped inside a container component, </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">List</span></strong><span class="koboSpan" id="kobo.277.1">, like so:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.278.1">
const List = ({ items }: { items: Item[] }) =&gt; {
  return (
    &lt;section data-testid="searchable-list"&gt;
      &lt;ul&gt;
        {items.map((item) =&gt; (
          &lt;ListItem item={item} /&gt;
        ))}
      &lt;/ul&gt;
      &lt;footer&gt;Total items: {items.length}&lt;/footer&gt;
    &lt;/section&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.279.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">List</span></strong><span class="koboSpan" id="kobo.281.1"> acts as the container for all the items. </span><span class="koboSpan" id="kobo.281.2">It also includes a footer to show some summary information of the items.</span></p>
<p><span class="koboSpan" id="kobo.282.1">Finally, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">SearchInput</span></strong><span class="koboSpan" id="kobo.284.1"> component, which is responsible for collecting user input and </span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.285.1">triggering searches as the user is typing:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.286.1">
const SearchInput = ({ onSearch }: { onSearch: (keyword: string) =&gt; void }) =&gt; {
  const handleChange = (e: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    onSearch(e.target.value);
  };
  return &lt;input type="text" onChange={handleChange} /&gt;;
};
const SearchableList = ({ items }: { items: Item[] }) =&gt; {
  const [filteredItems, setFilteredItems] = useState&lt;Item[]&gt;(items);
  const onSearch = (keyword: string) =&gt; {
    setFilteredItems(items.filter((item) =&gt; item.name.
</span><span class="koboSpan" id="kobo.286.2">     includes(keyword)));
  };
  return (
    &lt;div&gt;
      &lt;SearchInput onSearch={onSearch} /&gt;
      &lt;List items={filteredItems} /&gt;
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.287.1">Note that this code breakdown is only an internal structural change – we made the change only to make each part easy to read and understand. </span><span class="koboSpan" id="kobo.287.2">People who use </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">SearchableList</span></strong><span class="koboSpan" id="kobo.289.1"> aren’t aware of such changes at all – the props of </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">SearchableList</span></strong><span class="koboSpan" id="kobo.291.1"> haven’t been changed so far.</span></p>
<p><span class="koboSpan" id="kobo.292.1">However, the consumer has requested a new feature: they wish to track user interactions </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.293.1">for analytics, specifically to gauge the popularity of items and the utilization of the search function. </span><span class="koboSpan" id="kobo.293.2">To meet this requirement, two new props are being introduced: an </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">onItemClicked</span></strong><span class="koboSpan" id="kobo.295.1"> callback to capture when an item is clicked, and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">onSearch</span></strong><span class="koboSpan" id="kobo.297.1"> callback to monitor when a search is performed.</span></p>
<p><span class="koboSpan" id="kobo.298.1">So, we need to modify our code to meet these requirements, starting from the new type used in </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">SearchableList</span></strong><span class="koboSpan" id="kobo.300.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.301.1">
type SearchableListProps = {
  items: Item[];
  onSearch: (keyword: string) =&gt; void;
  onItemClicked: (item: Item) =&gt; void;
};
const SearchableList = ({
  items,
  onSearch,
  onItemClicked,
}: SearchableListProps) =&gt; {
  //...
</span><span class="koboSpan" id="kobo.301.2">}</span></pre> <p><span class="koboSpan" id="kobo.302.1">To pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">onSearch</span></strong><span class="koboSpan" id="kobo.304.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">onItemClicked</span></strong><span class="koboSpan" id="kobo.306.1">, we’ll make some changes to </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">ListItem</span></strong><span class="koboSpan" id="kobo.308.1">. </span><span class="koboSpan" id="kobo.308.2">We need to </span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.309.1">change the props list (adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">onItemClicked</span></strong><span class="koboSpan" id="kobo.311.1">) and then call the function when the list is clicked:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.312.1">
const ListItem = ({
  item,
  onItemClicked,
}: {
  item: Item;
  onItemClicked: (item: Item) =&gt; void;
}) =&gt; {
  return (
    &lt;li onClick={() =&gt; onItemClicked(item)}&gt;
      &lt;h2&gt;{item.name}&lt;/h2&gt;
      &lt;p&gt;{item.description}&lt;/p&gt;
    &lt;/li&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.313.1">However, as </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">ListItem</span></strong><span class="koboSpan" id="kobo.315.1"> is not exposed directly to the outside world, the props are passed from its parent component, </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">List</span></strong><span class="koboSpan" id="kobo.317.1">. </span><span class="koboSpan" id="kobo.317.2">So, we also need to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">List</span></strong><span class="koboSpan" id="kobo.319.1"> component’s props list to add </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">onItemClicked</span></strong><span class="koboSpan" id="kobo.321.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.322.1">
const List = ({
  items,
  onItemClicked,
}: {
  items: Item[];
  onItemClicked: (item: Item) =&gt; void;
}) =&gt; {
  return (
    &lt;section data-testid="searchable-list"&gt;
      &lt;ul&gt;
        {items.map((item) =&gt; (
          &lt;ListItem item={item} onItemClicked={onItemClicked} /&gt;
        ))}
      &lt;/ul&gt;
      &lt;footer&gt;Total items: {items.length}&lt;/footer&gt;
    &lt;/section&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.323.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">List</span></strong><span class="koboSpan" id="kobo.325.1"> component </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.326.1">has to accept </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">onItemClicked</span></strong><span class="koboSpan" id="kobo.328.1"> as a prop and then pass on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">onItemClicked</span></strong><span class="koboSpan" id="kobo.330.1"> prop into </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">ListItem</span></strong><span class="koboSpan" id="kobo.332.1"> without touching it. </span><span class="koboSpan" id="kobo.332.2">This is a code smell, signaling that the component is dealing with something not directly relevant to its function.</span></p>
<p><span class="koboSpan" id="kobo.333.1">Then, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">onItemClick</span></strong><span class="koboSpan" id="kobo.335.1"> prop is passed from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">List</span></strong><span class="koboSpan" id="kobo.337.1"> component's parent </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">SearchableList</span></strong><span class="koboSpan" id="kobo.339.1"> component, as shown here:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.340.1">
const SearchableList = ({
  items,
  onSearch,
  onItemClicked,
}: SearchableListProps) =&gt; {
  const [filteredItems, setFilteredItems] = useState&lt;Item[]&gt;(items);
  const handleSearch = (keyword: string) =&gt; {
    setFilteredItems(items.filter((item) =&gt; item.name.
</span><span class="koboSpan" id="kobo.340.2">     includes(keyword)));
  };
  return (
    &lt;div&gt;
      &lt;SearchInput onSearch={handleSearch} /&gt;
      &lt;List items={filteredItems} onItemClicked={onItemClicked} /&gt;
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.341.1">Observe </span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.342.1">how we transfer the </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">onItemClicked</span></strong><span class="koboSpan" id="kobo.344.1"> prop to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">ListItem</span></strong><span class="koboSpan" id="kobo.346.1"> component. </span><span class="koboSpan" id="kobo.346.2">First, it goes through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">List</span></strong><span class="koboSpan" id="kobo.348.1"> component, which directly passes it down to </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">ListItem</span></strong><span class="koboSpan" id="kobo.350.1"> without using it for anything. </span><span class="koboSpan" id="kobo.350.2">This is a classic example of prop drilling. </span><span class="koboSpan" id="kobo.350.3">The same could happen with </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">SearchInput</span></strong><span class="koboSpan" id="kobo.352.1">. </span><span class="koboSpan" id="kobo.352.2">As we continue to add more and more props from the outside and drill them down through the component tree, the entire structure could soon become unmanageable.</span></p>
<p><span class="koboSpan" id="kobo.353.1">Fortunately, the Context API provides an elegant solution to the prop drilling issue, which we will review in the next section (we covered the fundamentals of using the Context API in </span><a href="B21103_02.xhtml#_idTextAnchor044"><i class="italic"><span class="koboSpan" id="kobo.354.1">Chapter 2</span></i></a><span class="koboSpan" id="kobo.355.1">; you can revisit that chapter if </span><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.356.1">you’d like a refresher).</span></p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.357.1">Using the Context API to resolve prop drilling</span></h1>
<p><span class="koboSpan" id="kobo.358.1">The concept behind using the Context API to address prop drilling is to create a shared container </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.359.1">for all sub-components under a common parent. </span><span class="koboSpan" id="kobo.359.2">This eliminates the need for explicitly passing down props from </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.360.1">parent to child. </span><span class="koboSpan" id="kobo.360.2">Sub-components can directly access the shared context whenever necessary. </span><span class="koboSpan" id="kobo.360.3">Another advantage of using the Context API is that it triggers automatic re-rendering of components whenever the data within the context changes.</span></p>
<p><span class="koboSpan" id="kobo.361.1">Returning to our searchable list example, which has already got the </span><i class="italic"><span class="koboSpan" id="kobo.362.1">props drilling</span></i><span class="koboSpan" id="kobo.363.1"> issue, </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">onItemClicked</span></strong><span class="koboSpan" id="kobo.365.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">List</span></strong><span class="koboSpan" id="kobo.367.1"> component isn’t necessary as </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">List</span></strong><span class="koboSpan" id="kobo.369.1"> doesn’t use the prop. </span><span class="koboSpan" id="kobo.369.2">This scenario involves just one layer and one prop. </span><span class="koboSpan" id="kobo.369.3">Now, envision a situation where we need to insert additional elements between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">List</span></strong><span class="koboSpan" id="kobo.371.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">ListItem</span></strong><span class="koboSpan" id="kobo.373.1"> components; we would have to pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">onItemClicked</span></strong><span class="koboSpan" id="kobo.375.1"> prop down to where it’s utilized. </span><span class="koboSpan" id="kobo.375.2">The complexity is amplified if we have multiple props to relay.</span></p>
<p><span class="koboSpan" id="kobo.376.1">The first step is to define a context with an appropriate type:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.377.1">
import { createContext } from "react";
import { Item } from "./types";
type SearchableListContextType = {
  onSearch: (keyword: string) =&gt; void;
  onItemClicked: (item: Item) =&gt; void;
};
const noop = () =&gt; {};
const SearchableListContext = createContext&lt;SearchableListContextType&gt;({
  onSearch: noop,
  onItemClicked: noop,
});
export { SearchableListContext };</span></pre> <p><span class="koboSpan" id="kobo.378.1">This code </span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.379.1">defines a React context called </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">SearchableListContext</span></strong><span class="koboSpan" id="kobo.381.1">. </span><span class="koboSpan" id="kobo.381.2">It </span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.382.1">specifies the types of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">onSearch</span></strong><span class="koboSpan" id="kobo.384.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">onItemClicked</span></strong><span class="koboSpan" id="kobo.386.1"> functions that the context will hold. </span><span class="koboSpan" id="kobo.386.2">It also initializes these functions with a no-operation (</span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">noop</span></strong><span class="koboSpan" id="kobo.388.1">) function by default.</span></p>
<p><span class="koboSpan" id="kobo.389.1">Now, we can </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.390.1">use the context as a wrapper in the searchable list to provide the context to all its child components:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.391.1">
const SearchableList = ({
  items,
  onSearch,
  onItemClicked,
}: SearchableListProps) =&gt; {
  const [filteredItems, setFilteredItems] = useState&lt;Item[]&gt;(items);
  const handleSearch = (keyword: string) =&gt; {
    setFilteredItems(items.filter((item) =&gt; item.name.
</span><span class="koboSpan" id="kobo.391.2">     includes(keyword)));
  };
  return (
    &lt;SearchableListContext.Provider value={{ onSearch, onItemClicked }}&gt;
      &lt;SearchInput onSearch={handleSearch} /&gt;
      &lt;List items={filteredItems} /&gt;
    &lt;/SearchableListContext.Provider&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.392.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">SearchableList</span></strong><span class="koboSpan" id="kobo.394.1"> component wraps its children, </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">SearchInput</span></strong><span class="koboSpan" id="kobo.396.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">List</span></strong><span class="koboSpan" id="kobo.398.1">, inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">SearchableListContext.Provider</span></strong><span class="koboSpan" id="kobo.400.1">. </span><span class="koboSpan" id="kobo.400.2">This allows these child components to access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">onSearch</span></strong><span class="koboSpan" id="kobo.402.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">onItemClicked</span></strong><span class="koboSpan" id="kobo.404.1"> functions from the context without passing </span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.405.1">them down explicitly as props. </span><span class="koboSpan" id="kobo.405.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">handleSearch</span></strong><span class="koboSpan" id="kobo.407.1"> function filters items based on the search keyword.</span></p>
<p><span class="koboSpan" id="kobo.408.1">This </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.409.1">means our </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">List</span></strong><span class="koboSpan" id="kobo.411.1"> component can be reverted to the simple version before we introduce </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">onItemClicked</span></strong><span class="koboSpan" id="kobo.413.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.414.1">
const List = ({ items }: { items: Item[] }) =&gt; {
  return (
    &lt;section data-testid="searchable-list"&gt;
      &lt;ul&gt;
        {items.map((item) =&gt; (
          &lt;ListItem item={item} /&gt;
        ))}
      &lt;/ul&gt;
      &lt;footer&gt;Total items: {items.length}&lt;/footer&gt;
    &lt;/section&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.415.1">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">ListItem</span></strong><span class="koboSpan" id="kobo.417.1">, we can directly access </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">onItemClicked</span></strong><span class="koboSpan" id="kobo.419.1"> from the context:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.420.1">
const ListItem = ({ item }: { item: Item }) =&gt; {
  const { onItemClicked } = useContext(SearchableListContext);
  return (
    &lt;li onClick={() =&gt; onItemClicked(item)}&gt;
      &lt;h2&gt;{item.name}&lt;/h2&gt;
      &lt;p&gt;{item.description}&lt;/p&gt;
    &lt;/li&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.421.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">ListItem</span></strong><span class="koboSpan" id="kobo.423.1"> component now uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">useContext</span></strong><span class="koboSpan" id="kobo.425.1"> to access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">onItemClicked</span></strong><span class="koboSpan" id="kobo.427.1"> function </span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.428.1">from </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">SearchableListContext</span></strong><span class="koboSpan" id="kobo.430.1">. </span><span class="koboSpan" id="kobo.430.2">When a list item is clicked, </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">onItemClicked</span></strong><span class="koboSpan" id="kobo.432.1"> is called with </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.433.1">the clicked item as an argument.</span></p>
<p><span class="koboSpan" id="kobo.434.1">Likewise, for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">SearchInput</span></strong><span class="koboSpan" id="kobo.436.1"> component, there’s no need to pass down extra props from </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">SearchableList</span></strong><span class="koboSpan" id="kobo.438.1">. </span><span class="koboSpan" id="kobo.438.2">Instead, we can directly access what we need from the context:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.439.1">
const SearchInput = ({ onSearch }: { onSearch: (keyword: string) =&gt; 
 void }) =&gt; {
  const { onSearch: providedOnSearch } = 
   useContext(SearchableListContext);
  const handleChange = (e: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    onSearch(e.target.value);
    providedOnSearch(e.target.value);
  };
  return &lt;input type="text" onChange={handleChange} /&gt;;
};</span></pre> <p><span class="koboSpan" id="kobo.440.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">SearchInput</span></strong><span class="koboSpan" id="kobo.442.1"> component uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">useContext</span></strong><span class="koboSpan" id="kobo.444.1"> Hook to access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">onSearch</span></strong><span class="koboSpan" id="kobo.446.1"> function from </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">SearchableListContext</span></strong><span class="koboSpan" id="kobo.448.1">. </span><span class="koboSpan" id="kobo.448.2">When the input changes, it calls both the local </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">onSearch</span></strong><span class="koboSpan" id="kobo.450.1"> function and the one from the context, effectively merging external and internal behaviors.</span></p>
<p><span class="koboSpan" id="kobo.451.1">As demonstrated, the Context API results in a much cleaner structure. </span><span class="koboSpan" id="kobo.451.2">It allows you to make </span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.452.1">additional structural adjustments </span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.453.1">to sub-components without the concern of continually passing props down the hierarchy. </span><span class="koboSpan" id="kobo.453.2">This simplifies the component interface, makin</span><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.454.1">g it easier to read and understand.</span></p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.455.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.456.1">In this chapter, we delved into some of the most pressing challenges that are often encountered in React development, such as the leakage of business logic, the complexities associated with prop drilling, and the difficulties of managing shared state. </span><span class="koboSpan" id="kobo.456.2">To counter these issues, we introduced robust solutions such as the ACL and the Context API. </span><span class="koboSpan" id="kobo.456.3">These strategies aim to streamline your code, making it both more maintainable and effective for long-term projects.</span></p>
<p><span class="koboSpan" id="kobo.457.1">Next up, we’ll dive into common React design patterns that you can use to further refine your coding skills. </span><span class="koboSpan" id="kobo.457.2">Stay tuned.</span></p>
</section>
</body></html>