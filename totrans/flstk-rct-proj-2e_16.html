<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Customizing the Media Player and Improving SEO</h1>
                </header>
            
            <article>
                
<p>Users visit a media-streaming application mainly to play media and explore other related media. This makes the media player—and the view that renders the related media details—crucial to a streaming application.</p>
<p>In this chapter, we will focus on developing the play media page for the MERN Mediastream application that we started building in the previous chapter, <a href="d3f14062-4c41-497c-9627-dc22075fb8fb.xhtml" target="_blank">Chapter 11</a>, <em>Building a Media Streaming Application</em>. We will address the following topics to bolster the media-playing functionalities and to help boost the presence of the media content across the web so that it reaches more users:</p>
<ul>
<li style="font-weight: 400">Customizing player controls on <kbd>ReactPlayer</kbd></li>
<li style="font-weight: 400">Playing the next video from a list of related videos</li>
<li>Autoplaying a list of related media</li>
<li style="font-weight: 400"><strong>Server-side rendering</strong> (<strong>SSR</strong>) of the <kbd>PlayMedia</kbd> view with data to improve <strong>search engine optimization</strong> (<strong>SEO</strong>)</li>
</ul>
<p>After completing these topics, you will be more adept at designing complex interactions between React components in a frontend user interface, and also at improving SEO across your full-stack React applications.</p>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a custom media player to MERN Mediastream  </h1>
                </header>
            
            <article>
                
<p>The MERN Mediastream application developed in the previous chapter implemented a simple media player with default browser controls that played one video at a time. In this chapter, we will update the view that plays media with a customized <kbd>ReactPlayer</kbd> and a related media list that can be set to play automatically when the current video ends. The updated view with the custom player and related playlist will resemble the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-897 image-border" src="assets/630604d3-93f9-4f02-baaa-248ca5940adf.png" style="width:92.25em;height:64.50em;"/></div>
<div class="packt_tip"><span>The code for the complete MERN Mediastream application is available on GitHub at</span> <a href="https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter11%20and%2012/mern-mediastream" target="_blank">https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter11%20and%2012/mern-mediastream</a><span>.</span><span> </span><span>You can</span><span> clone this code and run the application as you go through the code explanations for the rest of this chapter. </span></div>
<p>The following component tree diagram shows all the custom components that make up the MERN Mediastream frontend, including the components that will be improved or added in this chapter:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-898 image-border" src="assets/73c7dd59-4cba-4d9c-96da-8e44f3063c1f.png" style="width:102.50em;height:72.08em;"/></div>
<p><span>Modified components and new components added in this chapter include the <kbd>PlayMedia</kbd> component, which houses all the media player functionalities; the</span> <kbd>MediaPlayer</kbd> <span>component, which adds a</span> <kbd>ReactPlayer</kbd> <span>with custom controls; and a</span> <kbd>RelatedMedia</kbd> <span>component, which contains a list of related videos. In the following section, we will discuss the play media page structure, and how it will accommodate all the media viewing and interaction features to be extended in the MERN Mediastream application throughout this chapter. </span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The play media page</h1>
                </header>
            
            <article>
                
<p>When visitors want to view specific media on MERN Mediastream, they will be taken to the play media page, which will contain the media details, a media player to stream the video, and a list of related media that can be played next. We will implement this <kbd>PlayMedia</kbd> view in a React component named <kbd>PlayMedia</kbd>. In the following section, we discuss how this component will be structured to enable these functionalities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The component structure</h1>
                </header>
            
            <article>
                
<p>We will compose the component structure in the play media page in a way that allows the media data to trickle down to the inner components from the parent component. In this case, the <kbd>PlayMedia</kbd> component will be the parent component, containing the <kbd>RelatedMedia</kbd> component and also the <kbd>Media</kbd> component, which will have a nested <kbd>MediaPlayer</kbd> component, as sectioned and highlighted in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-899 image-border" src="assets/6fffc2bf-bea3-481b-bbb3-5310a6ba7106.png" style="width:91.92em;height:60.00em;"/></div>
<p>When individual media links are accessed in the frontend of the application, the <kbd>PlayMedia</kbd> component will retrieve and load the corresponding media data and list of related media from the server. Then, the relevant details will be <span>passed </span>as props to the <kbd>Media</kbd> and <kbd>RelatedMedia</kbd> child components.</p>
<p>The <kbd>RelatedMedia</kbd> component will list and link other related media, and clicking any media in this list will re-render the <kbd>PlayMedia</kbd> component and its inner components with the new data.</p>
<p>We will update the <kbd>Media</kbd> component we developed in <a href="" target="_blank">Chapter 11</a>, <em>Building a Media-Streaming Application</em>, to add a customized media player as a child component. This customized <kbd>MediaPlayer</kbd> component will also utilize the data passed from <kbd>PlayMedia</kbd> to stream the current video and link to the next video in the related media list.</p>
<p>In the <kbd>PlayMedia</kbd> component, we will add an autoplay toggle that will let users choose to autoplay the videos in the related media list, one after the other. The autoplay state will be managed from the <kbd>PlayMedia</kbd> component, but this feature will require the data available in the parent component's state to re-render when a video ends in the <kbd>MediaPlayer</kbd> nested child component, so it can be ensured that the next video starts playing automatically while keeping track of the related list.</p>
<p>To achieve this, the <kbd>PlayMedia</kbd> component will need to provide a state updating method as a prop that will be used in the <kbd>MediaPlayer</kbd> component to update the shared and interdependent state values across these components.</p>
<p>Taking this component structure into consideration, we will extend and update the MERN Mediastream application to implement a functional play media page. In the next section, we will start by adding the feature that provides a list of related media to the user in this <kbd>PlayMedia</kbd> view. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing related media </h1>
                </header>
            
            <article>
                
<p>When a user is viewing an individual media on the application, they will also see a list of related media on the same page. The related media list will consist of other media records that belong to the same genre as the given video and is sorted by the highest number of views. For this feature, we will <span>need to integrate a full-stack slice that retrieves the relevant list from the</span> Media <span>collection in the backend and renders it in the frontend. In the following sections, we will add a related media list API in the backend, along with a way to fetch this API in the frontend, and a React component that renders the list of media retrieved by this API.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The related media list API</h1>
                </header>
            
            <article>
                
<p>We will implement an API endpoint in the backend to retrieve the list of related media from the database. The API will receive a <kbd>GET</kbd> request at <kbd>'/api/media/related/:mediaId'</kbd>, and the route will be declared with the other media routes, as follows:</p>
<p><kbd>mern-mediastream/server/routes/media.routes.js</kbd></p>
<pre>router.route('/api/media/related/:mediaId')<br/>        .get(mediaCtrl.listRelated)</pre>
<p>The <kbd>:mediaId</kbd> parameter in the route path will be processed by the <kbd>mediaByID</kbd> method implemented in <em>The video API</em> section of <a href="d3f14062-4c41-497c-9627-dc22075fb8fb.xhtml" target="_blank">Chapter 11</a>,<span> </span><em>Building a Media Streaming Application</em><span>. It retrieves the media corresponding to this ID from the database and attaches it to the</span> <kbd>request</kbd><span> object, so it can be accessed in the next method. The <kbd>listRelated</kbd> controller method is the next method invoked for the</span> <kbd>GET</kbd> request at this API route. This method will query the Media collection to find records with the same genre as the media<span> provided</span>, and also exclude this given media record from the results returned. <span>The</span><span> </span><kbd>listRelated</kbd><span> </span><span>controller method is defined as shown in the following code:</span></p>
<p><kbd>mern-mediastream/server/controllers/media.controller.js</kbd></p>
<pre>const listRelated = async (req, res) =&gt; {<br/>  try {<br/>    let media = await Media.find({ "_id": { "$ne": req.media }, <br/>          "genre": req.media.genre})<br/>      .limit(4)<br/>      .sort('-views')<br/>      .populate('postedBy', '_id name')<br/>      .exec()<br/>    res.json(media)<br/>  } catch (err) {<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p><span>The results returned from the query will be sorted by the highest number of views and limited to the top four media records. Each </span><kbd>media</kbd><span> object in the returned results will also contain the name and ID of the user who posted the media, as specified in the <kbd>populate</kbd> method.</span></p>
<p class="mce-root"/>
<p>On the client side, we will set up a corresponding <kbd>fetch</kbd> method that will be used in the <kbd>PlayMedia</kbd> component to retrieve the related list of media using this API. This method will be defined as follows:</p>
<p><kbd>mern-mediastream/client/media/api-media.js</kbd></p>
<pre>const listRelated = async (params, signal) =&gt; {<br/>  try {<br/>    let response = await fetch('/api/media/related/'+ params.mediaId, {<br/>    method: 'GET',<br/>    signal: signal,<br/>    headers: {<br/>      'Accept': 'application/json',<br/>      'Content-Type': 'application/json'<br/>    }<br/>  })<br/>      return await response.json()<br/>  } catch(err) {<br/>    console.log(err)<br/>  }<br/>}</pre>
<p><span>This </span><kbd>listRelated</kbd><span> fetch method will take a media ID and make a <kbd>GET</kbd> request to the related media list API in the backend. We will use this method in the <kbd>PlayMedia</kbd> component to retrieve a list of media related to the current media loaded in the media player. Then this list will be rendered in the <kbd>RelatedMedia</kbd> component. In the next section, we will look at the implementation of this <kbd>RelatedMedia</kbd> component.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The RelatedMedia component</h1>
                </header>
            
            <article>
                
<p>In the play media page, beside the media loaded in the player, we will load a list of related media in the <kbd>RelatedMedia</kbd> component. The <kbd>RelatedMedia</kbd> component will take the list of related media as a prop from the <kbd>PlayMedia</kbd> component and render the details along with a video snapshot of each video in the list, as pictured in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-900 image-border" src="assets/f0422916-b6e8-43d1-bcec-3d100fed2f54.png" style="width:15.50em;height:19.92em;"/></p>
<p>In the implementation of the <kbd>RelatedMedia</kbd> view, we iterate through the media array received in the props using the <kbd>map</kbd> function and render each media item's details and video snapshot, as shown in the following code structure:</p>
<p><kbd>mern-mediastream/client/media/RelatedMedia.js</kbd></p>
<pre>{props.media.map((item, i) =&gt; { <br/>    return <br/>      &lt;span key={i}&gt;... video snapshot ... | ... media details ...&lt;/span&gt; <br/>  })<br/>}</pre>
<p>In this structure, to render the video snapshot for each media item, we will use a basic <kbd>ReactPlayer</kbd> without the controls, as follows:</p>
<p><kbd><span>mern-mediastream/client/media/RelatedMedia.js</span></kbd></p>
<pre><br/>&lt;Link to={"/media/"+item._id}&gt;<br/>  &lt;ReactPlayer url={'/api/media/video/'+item._id} <br/>               width='160px'    <br/>               height='140px'/&gt;<br/>&lt;/Link&gt;</pre>
<p><span>We wrap the <kbd>ReactPlayer</kbd> with a link to the individual view of this media. So, clicking on the given video snapshot will re-render the</span> <kbd>PlayMedia</kbd> <span>view to load the linked media's details. </span>Beside<span> the snapshot, we will display the details of each video including title, genre, created date, and the number of views, with the following code:</span></p>
<p><kbd><span>mern-mediastream/client/media/RelatedMedia.js</span></kbd></p>
<pre>&lt;Typography type="title" color="primary"&gt;{item.title}&lt;/Typography&gt;<br/>&lt;Typography type="subheading"&gt; {item.genre} &lt;/Typography&gt;<br/><span>&lt;Typography component="p"&gt;</span><br/>        {(new Date(item.created)).toDateString()}<br/>&lt;/Typography&gt;<br/>&lt;Typography type="subheading"&gt;{item.views} views&lt;/Typography&gt;</pre>
<p>This will render the details next to the video snapshot for each media in the related media list that is received in the props.</p>
<p>To render this <kbd>RelatedMedia</kbd> component in the play media page, we have to add it to the <kbd>PlayMedia</kbd> component. The <kbd>PlayMedia</kbd> component will use the related media list API implemented earlier in this section to retrieve the related media from the backend, and then pass it in the props to the <kbd>RelatedMedia</kbd> component. In the next section, we will discuss the implementation of this <kbd>PlayMedia</kbd> component. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The PlayMedia component</h1>
                </header>
            
            <article>
                
<p>The <kbd>PlayMedia</kbd> component will render the play media page. This component consists of the <kbd>Media</kbd> and <kbd>RelatedMedia</kbd> child components along with an autoplay toggle, and it provides data to these components when it loads in the view.</p>
<p>To render the <kbd>PlayMedia</kbd> component when individual media links are accessed by the user, we will add a <kbd>Route</kbd> in <kbd>MainRouter</kbd> and mount <kbd>PlayMedia</kbd> at <kbd>'/media/:mediaId'</kbd>, as follows:</p>
<p><kbd>mern-mediastream/client/MainRouter.js</kbd></p>
<pre>&lt;Route path="/media/:mediaId" component={PlayMedia}/&gt;</pre>
<p>When the <kbd>PlayMedia</kbd> component mounts, it will fetch the media data and the related media list from the server with <kbd>useEffect</kbd> hooks<span> </span>based on the <kbd>mediaId</kbd> parameter in the route link.</p>
<p>In one <kbd>useEffect</kbd> hook, it will fetch the media to be loaded in the media player, as shown in the following code:</p>
<p><kbd>mern-mediastream/client/media/PlayMedia.js</kbd></p>
<pre>useEffect(() =&gt; {<br/>     const abortController = new AbortController()<br/>     const signal = abortController.signal<br/><br/>     read({mediaId: props.match.params.mediaId}, signal).then((data) =&gt; {<br/>         if (data &amp;&amp; data.error) {<br/>             console.log(data.error)<br/>         } else {<br/>             setMedia(data)<br/>         }<br/>     })<br/>     return function cleanup(){<br/>         abortController.abort()<br/>     }<br/>}, [props.match.params.mediaId])</pre>
<p>The media ID from the route path is accessed in the <kbd>props.match</kbd> received from the React Router components. It is used in the call to the <kbd>read</kbd> API fetch method to retrieve the media details from the server. <span>The received <kbd>media</kbd> object is set in the state so that it can be rendered in the <kbd>Media</kbd> component. </span></p>
<p>In another <kbd>useEffect</kbd> hook, we use the same media ID to call the <kbd>listRelated</kbd> API fetch method, as shown in the following code.</p>
<p><kbd><span>mern-mediastream/client/media/PlayMedia.js</span></kbd></p>
<pre>useEffect(() =&gt; {<br/>    const abortController = new AbortController()<br/>    const signal = abortController.signal<br/><br/>    <strong>listRelated</strong>({<br/>      mediaId: props.match.params.mediaId}, signal).then((data) =&gt; {<br/>      if (data.error) {<br/>        console.log(data.error)<br/>      } else {<br/>        setRelatedMedia(data)<br/>      }<br/>    })<br/>    return function cleanup(){<br/>      abortController.abort()<br/>    }<br/>}, [props.match.params.mediaId])</pre>
<p>The<span> </span><kbd>listRelated</kbd><span> </span>API fetch method retrieves the related media list from the server and sets the values to the state so that it can be rendered in the <kbd>RelatedMedia</kbd> component.</p>
<p>The media and related media list values stored in the state are used to pass relevant props to these child components that are added in the view. For example, in the following code, the <kbd>RelatedMedia</kbd> component is only rendered if the list of related media contains any media, and the list <span>is passed to it</span> as a prop:</p>
<p><kbd><span>mern-mediastream/client/media/PlayMedia.js</span></kbd></p>
<pre>{relatedMedia.length &gt; 0 &amp;&amp; <br/>      (&lt;RelatedMedia media={relatedMedia}/&gt;)}</pre>
<p>Later in the chapter, in the <em>Autoplaying related media</em> section, we will add the <kbd>Autoplay</kbd> toggle component above the <kbd>RelatedMedia</kbd> component only if the length of the related media list is greater than <kbd>0</kbd>. We will also discuss the <span>implementation of the </span><kbd>handleAutoPlay</kbd> method that will be passed as a prop to the <kbd>Media</kbd> component. It will also receive the <kbd>media</kbd> detail object, and the video URL for the first item in the related media list, which will be treated as the next URL to play. The <kbd>Media</kbd> component is added to <kbd>PlayMedia</kbd>, along with these props, as shown in the following code:</p>
<p><kbd><span>mern-mediastream/client/media/PlayMedia.js</span></kbd></p>
<pre>const nextUrl = relatedMedia.length &gt; 0<br/>          ? `/media/${relatedMedia[0]._id}` : ''<br/>&lt;Media media={media} <br/>       nextUrl={nextUrl} <br/>       handleAutoplay={handleAutoplay}/&gt;</pre>
<p>This <kbd>Media</kbd> component renders the media details on the play media page, and also a customized media player that allows viewers to control the streaming of the video. In the next section, we will discuss the implementation of this customized media player and complete this core feature of the play media page.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Customizing the media player</h1>
                </header>
            
            <article>
                
<p>In MERN Mediastream, we want to provide users with a media player with more controls than those available in the default browser options, and with a look that matches the rest of the application. We will customize the player controls on <kbd>ReactPlayer</kbd> to replace these default controls with a custom look and functionality, as seen in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-901 image-border" src="assets/1c92cc00-464d-4493-9dc3-2a059ef9bdfa.png" style="width:35.33em;height:32.00em;"/></div>
<p><span>The controls will be added below the video and will include the progress seeking bar;</span> the play, pause, next, volume, loop, and fullscreen <span>options; and will also display full duration of the video and the amount that's been played. In the following sections, we will first update the <kbd>Media</kbd> component discussed in the previous chapter, <a href="d3f14062-4c41-497c-9627-dc22075fb8fb.xhtml" target="_blank">Chapter 11</a>, <em>Building a Media Streaming Application</em>, to accommodate the new player features. Then, we will initialize a <kbd>MediaPlayer</kbd> component that will contain the new player, before implementing functionality for the custom media controls in this player.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the Media component</h1>
                </header>
            
            <article>
                
<p>The existing <kbd>Media</kbd> component contains a basic <kbd>ReactPlayer</kbd> with default browser controls for playing a given video. We will replace this <kbd>ReactPlayer</kbd> with a new <kbd>MediaPlayer</kbd> component that we will begin implementing in the next section. The <kbd>MediaPlayer</kbd> component<span> will contain a customized </span><kbd>ReactPlayer</kbd>, and it will be added to the <kbd>Media</kbd> component code as follows:</p>
<p><kbd>mern-mediastream/client/media/Media.js</kbd></p>
<pre>const mediaUrl = props.media._id<br/>          ? `/api/media/video/${props.media._id}`<br/>          : null<br/>...<br/>&lt;MediaPlayer srcUrl={mediaUrl} <br/>             nextUrl={props.nextUrl} <br/>             handleAutoplay={props.handleAutoplay}/&gt;</pre>
<p><span>While adding this </span><kbd>MediaPlayer</kbd><span> component to the <kbd>Media</kbd> component, it will be passed the current video's source URL, the next video's source URL, and the </span><kbd>handleAutoPlay</kbd><span> method, which are received as </span><kbd>props</kbd><span> in the <kbd>Media</kbd> component from the </span><kbd>PlayMedia</kbd><span> component. These URL values and the</span> autoplay <span>handling method will be used in the <kbd>MediaPlayer</kbd> component to add various video-playing options. In the next section, we will begin implementing this <kbd>MediaPlayer</kbd> component by initializing the different values needed for adding functional controls to the custom media player.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Initializing the media player</h1>
                </header>
            
            <article>
                
<p>We will implement the customized media player <span>in t</span><span>he </span><kbd>MediaPlayer</kbd><span> component.</span> This player will render the video streamed from the backend and provide the user with different control options. We will incorporate this media-playing functionality and the custom control options in the <kbd>MediaPlayer</kbd> using a <kbd>ReactPlayer</kbd> component. The <kbd>ReactPlayer</kbd> component, as discussed in the previous chapter, provides a range of customizations that we will leverage for the media player features to be added in this application. </p>
<p><span>While defining the <kbd>MediaPlayer</kbd> component, we will begin by initializing the <kbd>ReactPlayer</kbd> component with starting values for the controls,</span> before we add the custom functionalities and corresponding user-action handling code for each control.</p>
<div class="packt_infobox">The control values we customize will correspond to the props allowed in the <kbd>ReactPlayer</kbd> component. To see a list of available props and an explanation of each, visit <a href="https://github.com/CookPete/react-player#props" target="_blank">github.com/CookPete/react-player#props</a>.<a href="https://github.com/CookPete/react-player#props"/></div>
<p class="mce-root">First, we need to set the initial control values in the component's state. We will start with control values that correspond to the following:</p>
<ul>
<li class="mce-root">The playing state of the media</li>
<li class="mce-root">The volume of the audio</li>
<li class="mce-root">The muted state</li>
<li class="mce-root">The duration of the video</li>
<li class="mce-root">The seeking state</li>
<li class="mce-root">The playback rate of the video</li>
<li class="mce-root">The loop value</li>
<li class="mce-root">The fullscreen value</li>
<li class="mce-root">Video errors</li>
<li class="mce-root">The played, loaded, and ended states of the video getting streamed</li>
</ul>
<p>The code to initialize these values in the component will be added as follows:</p>
<p><kbd>mern-mediastream/client/media/MediaPlayer.js</kbd></p>
<pre>  const [playing, setPlaying] = useState(false)<br/>  const [volume, setVolume] = useState(0.8) <br/>  const [muted, setMuted] = useState(false)  <br/>  const [duration, setDuration] = useState(0)<br/>  const [seeking, setSeeking] = useState(false) <br/>  const [playbackRate, setPlaybackRate] = useState(1.0) <br/>  const [loop, setLoop] = useState(false) <br/>  const [fullscreen, setFullscreen] = useState(false)<br/>  const [videoError, setVideoError] = useState(false) <br/>  const [values, setValues] = useState({<br/>    played: 0, loaded: 0, ended: false<br/>  })</pre>
<p>These values set in the state will allow us to customize the functionalities of the corresponding controls in the <kbd>ReactPlayer</kbd> component, which we discuss in detail in the next section.</p>
<p>In the <kbd>MediaPlayer</kbd> component's view code, we will add this  <kbd>ReactPlayer</kbd> with these control values and source URL, using the prop sent from the <kbd>Media</kbd> component, as shown in the following code:</p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>&lt;ReactPlayer<br/> ref={ref}<br/> width={fullscreen ? '100%':'inherit'}<br/> height={fullscreen ? '100%':'inherit'}<br/> style={fullscreen ? {position:'relative'} : {maxHeight: '500px'}}<br/> config={{ attributes: { style: { height: '100%', width: '100%'} } }}<br/> url={props.srcUrl}<br/> playing={playing}<br/> loop={loop}<br/> playbackRate={playbackRate}<br/> volume={volume}<br/> muted={muted}<br/> onEnded={onEnded}<br/> onError={showVideoError}<br/> onProgress={onProgress}<br/> onDuration={onDuration}/&gt;</pre>
<p>Besides setting the control values, we will also add styling to the player, depending on whether it is in fullscreen mode. We also need to get a reference to this player element rendered in the browser so that it can be used in the change-handling code for the custom controls. We will use the <kbd>useRef</kbd> React hook to initialize the reference to <kbd>null</kbd> and then set it to the corresponding player element using the <kbd>ref</kbd> method, as defined in the following code: </p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>let playerRef = useRef(null)<br/>const ref = player =&gt; {<br/>    playerRef = player<br/>}</pre>
<p>The value in <kbd>playerRef</kbd> will give access to the player element rendered in the browser. We will use this reference to manipulate the player as required, to make the custom controls functional.</p>
<p>As a final step for initializing the media player, we will add code for handling errors thrown by the player if the specified video source cannot be loaded for any reason. We will define a <kbd>showVideoError</kbd> method that will be invoked when a video error occurs. The<span> </span><kbd>showVideoError</kbd><span> method will be defined as follows:</span></p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>  const showVideoError = e =&gt; {<br/>    console.log(e)<br/>    setVideoError(true)<br/>  }</pre>
<p>This method will render an error message in the view above the media player. We can show this error message conditionally by adding the following code in the view above the <kbd>ReactPlayer</kbd>:</p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>{videoError &amp;&amp; &lt;p className={classes.videoError}&gt;Video Error. Try again later.&lt;/p&gt;}</pre>
<p>This will render the video error message when an error occurs. As we will allow users to play another video in the player from the related media list, we will reset the error message if a new video is loaded. We can <span>hide the error message</span> when a new video loads with a <kbd>useEffect</kbd> hook, by ensuring the <kbd>useEffect</kbd> only runs when the video source URL changes, as shown in the following code: </p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>useEffect(() =&gt; {<br/>    setVideoError(false)<br/>}, [props.srcUrl])</pre>
<p>This will ensure the error message isn't shown when a new video is loaded and streaming correctly.</p>
<p>With these initial control values set and the <kbd>ReactPlayer</kbd> added to the component, <span>in the next section, </span>we can begin customizing how these controls will appear and function in our application. </p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom media controls</h1>
                </header>
            
            <article>
                
<p>We will add custom player control elements below the video rendered in the <kbd>MediaPlayer</kbd> component and manipulate their functionality using the options and events provided by the <kbd>ReactPlayer</kbd> library. In the following sections, we will implement the play, pause, and replay controls; the play next control; the loop functionality; volume control options; progress control options; fullscreen option, and also display full duration of the video and the amount that's been played.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Play, pause, and replay</h1>
                </header>
            
            <article>
                
<p>Users will be able to play, pause, and replay the current video. We will implement these three options using <kbd>Material-UI</kbd> components bound to <kbd>ReactPlayer</kbd> attributes and events. The play, pause, and replay options will render as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5af8e3ab-a683-446a-835a-cb00744750c8.png" style="width:18.67em;height:2.50em;"/></div>
<p>To implement the play, pause, and replay functionality, we will add a play, pause, or replay icon button conditionally depending on whether the video is playing, is paused, or has ended, as shown in the following code:</p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>&lt;IconButton color="primary" onClick={playPause}&gt;<br/>    &lt;Icon&gt;{playing ? 'pause': (ended ? 'replay' : 'play_arrow')}&lt;/Icon&gt;<br/>&lt;/IconButton&gt;</pre>
<p>The play, pause, or replay icons are rendered in this <kbd>IconButton</kbd> based on the outcome of the ternary operator.</p>
<p>When the user clicks the button, we will update the <kbd>playing</kbd> value in the state, so the <kbd>ReactPlayer</kbd> is also updated. We achieve this by invoking the <kbd>playPause</kbd> method when <span>this button is clicked</span>. The <kbd>playPause</kbd> method is defined as follows:</p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>const playPause = () =&gt; {<br/>    setPlaying(!playing)<br/>}</pre>
<p class="mce-root"/>
<p>The updated value of <kbd>playing</kbd> in the state will play or pause the video in the <kbd>ReactPlayer</kbd> component accordingly. In the next section, we will see how we can add a control option that will allow us to play the next video from the list of related media.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Play next</h1>
                </header>
            
            <article>
                
<p>Users will be able to play the next video in the related media list using a play next button, which will render depending on whether the next video is available or not. The two versions of this play next button will display as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7cc4eac6-e97b-4698-abff-0219052c85f0.png" style="width:15.92em;height:3.25em;"/></div>
<p>The play next button will be disabled if the related list does not contain any media. The play next icon will basically link to the next URL value passed in as a prop from <kbd>PlayMedia</kbd>. This play next button will be added to the <kbd>MediaPlayer</kbd> view, as follows:</p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>&lt;IconButton disabled={!props.nextUrl} color="primary"&gt;<br/>    &lt;Link to={props.nextUrl}&gt;<br/>       &lt;Icon&gt;skip_next&lt;/Icon&gt;<br/>    &lt;/Link&gt;<br/>&lt;/IconButton&gt;</pre>
<p>Clicking on this play next button will reload the <kbd>PlayMedia</kbd> component with the new media details and start playing the video. <span>In the next section, we will add a control option that will allow the current video to be played in a loop.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loop when a video ends</h1>
                </header>
            
            <article>
                
<p>Users will be able to set the current video to keep playing in a loop, using a loop button. The loop button will render in two states, set and unset, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/403de211-6868-4820-ad12-9a04ba0594b1.png" style="width:14.25em;height:3.17em;"/></div>
<p><span><span>T</span></span>his loop icon button will display in a different color to indicate whether it has been set or unset by the user. The code for rendering this loop button will be added to the <kbd>MediaPlayer</kbd>, as follows:</p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>&lt;IconButton color={loop ? 'primary' : 'default'} <br/>            onClick={onLoop}&gt;<br/>    &lt;Icon&gt;loop&lt;/Icon&gt;<br/>&lt;/IconButton&gt;</pre>
<p>The loop icon color will change based on the value of <kbd>loop</kbd> in the state. When this loop icon button is clicked, we will update the <kbd>loop</kbd> value in the state by invoking the <kbd>onLoop</kbd> method, which is defined as follows:</p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>const onLoop = () =&gt; {<br/>    setLoop(!loop)<br/>}</pre>
<p>The video will play on loop when this <kbd>loop</kbd> value is set to <kbd>true</kbd>. We will need to catch the <kbd>onEnded</kbd> event, to check whether <kbd>loop</kbd> has been set to <kbd>true</kbd>, so the <kbd>playing</kbd> value can be updated accordingly. When a video reaches the end, the <kbd>onEnded</kbd> method will be invoked. This <kbd>onEnded</kbd> method will be defined as follows:</p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>const onEnded = () =&gt; {<br/>  if(loop){<br/>    setPlaying(true)<br/>  } else{<br/>    setValues({...values, ended: true}) <br/>    setPlaying(false)<br/>  }<br/>}</pre>
<p>So, if the <kbd>loop</kbd> value is set to <kbd>true</kbd>, when the video ends it will start playing again; otherwise, it will stop playing and render the replay button. In the next section, we will add controls for setting the volume of the video.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Volume control</h1>
                </header>
            
            <article>
                
<p>In order to control the volume of the video being played, users will have the option to increase or decrease the volume, as well as to mute or unmute. The rendered volume controls will be updated based on the user action and current value of the volume. The different states of the volume controls will be as follows:</p>
<ul>
<li><span>A volume-up icon will be rendered if the volume is raised, as shown in the following screenshot:</span></li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="assets/22206b2a-35d7-497c-aa01-48aca0e8d71f.png" style="width:11.08em;height:2.50em;"/></div>
<ul>
<li><span>A volume-off icon will be rendered if the user decreases the volume to zero, as pictured next:</span></li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8495d831-b880-40d1-b4fb-27618760c109.png" style="width:11.08em;height:2.50em;"/></div>
<ul>
<li><span>A volume-mute icon button will be shown if the user clicks the icon to mute the volume, as shown next:</span></li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="assets/faff96a6-8595-43c1-aa3b-22a71517126a.png" style="width:11.58em;height:2.67em;"/></div>
<p>To implement this, we will conditionally render the different icons in an <kbd>IconButton</kbd>, based on the <kbd>volume</kbd>, <kbd>muted</kbd>, <kbd>volume_up</kbd>, and <kbd>volume_off</kbd> values, as shown in the following code:</p>
<pre>&lt;IconButton color="primary" onClick={toggleMuted}&gt;<br/>    &lt;Icon&gt; {volume &gt; 0 &amp;&amp; !muted &amp;&amp; 'volume_up' || <br/>            muted &amp;&amp; 'volume_off' || <br/>               volume==0 &amp;&amp; 'volume_mute'} &lt;/Icon&gt;<br/>&lt;/IconButton&gt;</pre>
<p>When this <kbd>IconButton</kbd><span> </span>is clicked, it will either mute or unmute the volume by invoking the <kbd>toggleMuted</kbd> method, which is defined as follows:</p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>const toggleMuted = () =&gt; {<br/>    setMuted(!muted)<br/>}</pre>
<p>The volume will be muted or unmuted, depending on the current value of <kbd>muted</kbd> in the state. To allow users to increase or decrease the volume, we will add an input element of type <kbd>range</kbd> that will allow users to set a volume value between <kbd>0</kbd> and <kbd>1</kbd>. This input element will be added to the code, as follows:</p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>&lt;input type="range" <br/>       min={0} <br/>       max={1} <br/>       step='any' <br/>       value={muted? 0 : volume} <br/>       onChange={changeVolume}/&gt;</pre>
<p>Changing the <kbd>value</kbd> on the input range will set the <kbd>volume</kbd> value in the state accordingly by invoking the <kbd>changeVolume</kbd> method. This <kbd>changeVolume</kbd> method will be defined as follows:</p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>const changeVolume = e =&gt; {<br/>    setVolume(parseFloat(e.target.value))<br/>}</pre>
<p>The <kbd>volume</kbd> value changed in the state will be applied to the <kbd>ReactPlayer</kbd>, and this will set the volume of the current media being played. In the next section, we will add options to control the progression of the video being played.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Progress control</h1>
                </header>
            
            <article>
                
<p>In the media player, users will see how much of the video has been loaded and played in a progress bar. To implement this feature, we will use a Material-UI <kbd>LinearProgress</kbd> component to indicate how much of the video has buffered, and how much has been played already. Then, we'll combine this component with an input element of type <kbd>range</kbd> to give users the ability to move the time slider to a different part of the video and play from there.</p>
<p>This time slider and progress bar will render as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-902 image-border" src="assets/d00bcb88-028b-41be-8992-1f5c6f04412f.png" style="width:19.75em;height:4.08em;"/></div>
<p>The <kbd>LinearProgress</kbd> component will use the <kbd>played</kbd> and <kbd>loaded</kbd> values in the state to render these bars. It will take the <kbd>played</kbd> and <kbd>loaded</kbd> values to show each in a different color, as shown in the following code:</p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>&lt;LinearProgress color="primary" variant="buffer" <br/>                value={values.played*100} valueBuffer={values.loaded*100} <br/>                style={{width: '100%'}} <br/>                classes={{<br/>                          colorPrimary: classes.primaryColor,<br/>                          dashedColorPrimary : classes.primaryDashed,<br/>                          dashed: classes.dashed<br/>                        }}<br/>/&gt;</pre>
<p>The look and color for each progress bar will be determined by the styles you define for the <kbd>primaryColor</kbd>, <kbd>dashedColorPrimary</kbd>, and <kbd>dashed</kbd> classes.</p>
<p>To update the <kbd>LinearProgress</kbd> component when the video is playing or loading, we will use the <kbd>onProgress</kbd> event listener to set the current values for <kbd>played</kbd> and <kbd>loaded</kbd>. The <kbd>onProgress</kbd> method will be defined as shown in the following code:</p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>const onProgress = progress =&gt; {<br/>  if (!seeking) {<br/>    setValues({...values, played: progress.played, loaded: progress.loaded})<br/>  }<br/>}</pre>
<p>We only want to update the time slider if we are not currently seeking, so we first check the <kbd>seeking</kbd> value in the state before setting the <kbd>played</kbd> and <kbd>loaded</kbd> values.</p>
<p>For time-sliding control, we will add the range input element and define styles, as highlighted in the following code, to place it over the <kbd>LinearProgress</kbd> component. The current value of the range will update as the <kbd>played</kbd> value changes, so the range value seems to be moving with the progression of the video. This input element representing the time slider will be added to the media player, as shown in the following code:</p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>&lt;input type="range" min={0} max={1}<br/>       value={values.played} step='any'<br/>       onMouseDown={onSeekMouseDown}<br/>       onChange={onSeekChange}<br/>       onMouseUp={onSeekMouseUp}<br/>       <strong>style</strong>={{ position: 'absolute',<br/>                width: '100%',<br/>                top: '-7px',<br/>                zIndex: '999',<br/>                '-webkit-appearance': 'none',<br/>                backgroundColor: 'rgba(0,0,0,0)' }}<br/>/&gt;</pre>
<p>In the case where the user drags and sets the range picker on their own, we will add code to handle the <kbd>onMouseDown</kbd>, <kbd>onMouseUp</kbd>, and <kbd>onChange</kbd> events to start the video from the desired position.</p>
<p>When the user starts dragging by holding the mouse down, we will set <kbd>seeking</kbd> to <kbd>true</kbd> so that the progress values are not set in <kbd>played</kbd> and <kbd>loaded</kbd>. This will be achieved with the <kbd>onSeekMouseDown</kbd> method, which is defined as follows:</p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>const onSeekMouseDown = e =&gt; {<br/>    setSeeking(true)<br/>}</pre>
<p>As the range value change occurs, we will invoke the <kbd>onSeekChange</kbd> method to set the <kbd>played</kbd> value and also the <kbd>ended</kbd> value, after checking whether the user dragged the time slider to the end of the video. This <span><kbd>onSeekChange</kbd> method will be defined as follows:</span></p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>const onSeekChange = e =&gt; {<br/>    setValues({...values, played:parseFloat(e.target.value), <br/>                          ended: parseFloat(e.target.value) &gt;= 1})<br/>}</pre>
<p>When the user is done dragging and lifts their click on the mouse, we will set <kbd>seeking</kbd> to <kbd>false</kbd>, and set the <kbd>seekTo</kbd> value for the media player to the current value set in the input range. The <kbd>onSeekMouseUp</kbd> method will be executed when the user is done seeking, and it is defined as follows:</p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>const onSeekMouseUp = e =&gt; {<br/>    setSeeking(false)<br/>    playerRef.seekTo(parseFloat(e.target.value))<br/>}</pre>
<p>This way, the user will be able to select any part of the video to play from, and also get visual information on the time progress of the video being streamed. In the next section, we will add a control that will allow the user to view the video in fullscreen mode.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fullscreen</h1>
                </header>
            
            <article>
                
<p>Users will be able to view the video in fullscreen mode by clicking the fullscreen button in the controls. The fullscreen button for the player will be rendered as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-903 image-border" src="assets/872dafe3-3d9a-4cda-9b0f-a188110d13a3.png" style="width:2.75em;height:2.75em;"/></div>
<p>In order to implement a fullscreen option for the video, we will use the <kbd>screenfull</kbd> Node module to track when the view is in fullscreen, and <kbd>findDOMNode</kbd> from <kbd>react-dom</kbd> to specify which <strong>Document Object Model</strong> (<strong>DOM</strong>) element will be made fullscreen with <kbd>screenfull</kbd>.</p>
<p>To set up the <kbd>fullscreen</kbd> code, we first install <kbd>screenfull</kbd>, by running the following command from the command line:</p>
<pre><strong>yarn add screenfull</strong></pre>
<p>Then, we will import <kbd>screenfull</kbd> and <kbd>findDOMNode</kbd> into the <kbd>MediaPlayer</kbd> component, as shown in the following code:</p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>import screenfull from 'screenfull'<br/>import { findDOMNode } from 'react-dom'</pre>
<p>When the <kbd>MediaPlayer</kbd> component mounts, we will use a <kbd>useEffect</kbd> hook to add a <kbd>screenfull</kbd> change event listener that will update the <kbd>fullscreen</kbd> value in the state to indicate whether the screen is in fullscreen or not. The <kbd>useEffect</kbd> hook will be added as follows, with the <kbd>screenfull</kbd> change listener code: </p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>  useEffect(() =&gt; {<br/>    if (screenfull.enabled) {<br/>      screenfull.on('change', () =&gt; {<br/>        let fullscreen = screenfull.isFullscreen ? true : false<br/>        setFullscreen(fullscreen)<br/>      })<br/>    }<br/>  }, [])</pre>
<p>This <kbd>fullscreen</kbd> value set in the state will be updated when the user interacts with the button for rendering the video in fullscreen mode. In the view, <span>we will add an <kbd>icon</kbd> button for <kbd>fullscreen</kbd> </span>with the other control buttons, as shown in the following code:</p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>&lt;IconButton color="primary" onClick={onClickFullscreen}&gt;<br/>  &lt;Icon&gt;fullscreen&lt;/Icon&gt;<br/>&lt;/IconButton&gt;</pre>
<p>When the user clicks this button, we will use <kbd>screenfull</kbd> and <kbd>findDOMNode</kbd> to make the video player fullscreen by invoking the <kbd>onClickFullscreen</kbd> method, which is defined as follows:</p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>  const onClickFullscreen = () =&gt; {<br/>   screenfull.request(findDOMNode(playerRef))<br/>  }</pre>
<p>We access the element that renders the media player in the browser by using the <kbd>playerRef</kbd> reference in <kbd>findDOMNode</kbd> and make it fullscreen by using <kbd>screenfull.request</kbd>. The user can then watch the video in fullscreen, where they can press <em>Esc</em> at any time to exit fullscreen and get back to the <kbd>PlayMedia</kbd> view. In the next section, we will implement the final customization in the media player controls to display the total length of the video, and how much of it was already played.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Played duration</h1>
                </header>
            
            <article>
                
<p>In the custom media controls section of the media player, we want to show the time that has already passed and the total duration of the video in a readable time format, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-904 image-border" src="assets/65044ac0-2632-46a7-ab82-0b093bf2227b.png" style="width:6.17em;height:2.42em;"/></div>
<p>To show the time, we can utilize the HTML <kbd>time</kbd> element, which takes a <kbd>datetime</kbd> value, and add it to the view code in <kbd>MediaPlayer</kbd>, as follows:</p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>&lt;time dateTime={`P${Math.round(duration * played)}S`}&gt;<br/>      {format(duration * played)}<br/>&lt;/time&gt; / <br/>&lt;time dateTime={`P${Math.round(duration)}S`}&gt;<br/>    {format(duration)}<br/>&lt;/time&gt;</pre>
<p>In the <kbd>dateTime</kbd> attribute for these <kbd>time</kbd> elements, we provide the total rounded-off seconds that represent the played duration or the total duration of the video. We will get this total <kbd>duration</kbd> value for a video by using the <kbd>onDuration</kbd> event and then set it to the state, so it can be rendered in the <kbd>time</kbd> element. The <kbd>onDuration</kbd> method is defined as follows:</p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>  const onDuration = (duration) =&gt; {<br/>    setDuration(duration)<br/>  }</pre>
<p>To make the duration and already played time values readable, we will use the following <kbd>format</kbd> function:</p>
<p><kbd><span>mern-mediastream/client/media/MediaPlayer.js</span></kbd></p>
<pre>  const format = (seconds) =&gt; {<br/>    const date = new Date(seconds * 1000)<br/>    const hh = date.getUTCHours()<br/>    let mm = date.getUTCMinutes()<br/>    const ss = ('0' + date.getUTCSeconds()).slice(-2)<br/>    if (hh) {<br/>      mm = ('0' + date.getUTCMinutes()).slice(-2)<br/>      return `${hh}:${mm}:${ss}`<br/>    }<br/>    return `${mm}:${ss}`<br/>  }</pre>
<p>This <kbd>format</kbd> function takes the duration value in seconds and converts it to the <kbd>hh/mm/ss</kbd> format, using methods from the JavaScript Date API.</p>
<p>The controls added to this custom media player are all mostly based on some of the available functionality provided in the <kbd>ReactPlayer</kbd> module, and its examples in the official documentation. While implementing the custom media player for this application, we updated and added the associated playing controls, looping option, volume controls, progress seeking control, fullscreen viewing option, and a display of the video duration. There are more options available for further customizations and extensions in <kbd>ReactPlayer</kbd> that may be explored depending on specific feature requirements. With the different functionalities of the customized media player implemented, in the next section, we can start discussing the implementation of autoplaying videos in this player from a list of available media.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Autoplaying related media</h1>
                </header>
            
            <article>
                
<p>In the play media page, users will have the option to autoplay one video after the other from the related media list. To make this feature possible, the <kbd>PlayMedia</kbd> component will manage the autoplay state, which will determine the data and how it will be rendered next in the <kbd>MediaPlayer</kbd> and <kbd>RelatedMedia</kbd> components after the current video finishes streaming in the player. In the following sections, we will complete this autoplay functionality by adding a toggle in the <kbd>PlayMedia</kbd> component and implementing the <kbd>handleAutoplay</kbd> method, which needs to be called when a video ends in the <kbd>MediaPlayer</kbd> component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Toggling autoplay</h1>
                </header>
            
            <article>
                
<p>On the play media page, we will add an autoplay toggle option above the related media list. Besides letting the user set autoplay, the toggle will also indicate whether it is currently set or not, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-905 image-border" src="assets/9a49efbd-9bdd-4004-8eea-1c0df87803ca.png" style="width:10.67em;height:7.17em;"/></div>
<p>To add the autoplay toggle option, we will use a Material-UI <kbd>Switch</kbd> component along with a <kbd>FormControlLabel</kbd>, and add it to the <kbd>PlayMedia</kbd> component over the <kbd>RelatedMedia</kbd> component. It will only be rendered when there are media in the related media list. We will add this <kbd>Switch</kbd> component representing the autoplay toggle as shown in the following code:</p>
<p><kbd>mern-mediastream/client/media/PlayMedia.js</kbd></p>
<pre>&lt;FormControlLabel<br/>      control={<br/>        &lt;Switch<br/>          checked={autoPlay}<br/>          onChange={handleChange}<br/>          color="primary"<br/>        /&gt;<br/>      }<br/>      label={autoPlay ? 'Autoplay ON':'Autoplay OFF'}<br/>/&gt;</pre>
<p>The autoplay toggle label will render according to the current value of <kbd>autoPlay</kbd> in the state. To handle the change to the toggle when the user interacts with it, and to reflect this change in the state's <kbd>autoPlay</kbd> value, we will use the following <kbd>onChange</kbd> handler function:</p>
<p><kbd><span>mern-mediastream/client/media/PlayMedia.js</span></kbd></p>
<pre>const handleChange = (event) =&gt; {<br/>   setAutoPlay(event.target.checked)<br/>}</pre>
<p>This <kbd>autoPlay</kbd> value, which represents whether the user chose to autoplay all the media, will determine what happens when the current video finishes streaming. In the next section, we will discuss how the autoplay behavior will be integrated with the child components in <kbd>PlayMedia</kbd>, depending on the toggled value set for <kbd>autoPlay</kbd> by the user.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling autoplay across components</h1>
                </header>
            
            <article>
                
<p>When a user selects to set the <span class="packt_screen">Autoplay</span> toggle to <span class="packt_screen">ON</span>, t<span>he functionality desired here is that when a video ends, if <kbd>autoPlay</kbd> is set to <kbd>true</kbd> and the current related list of media is not empty, </span><kbd>PlayMedia</kbd><span> should load the media details of the first video in the related list.</span></p>
<p><span>In turn, the </span><kbd>Media</kbd><span> and </span><kbd>MediaPlayer</kbd><span> components should update with the new media details, start playing the new video, and render the controls on the player appropriately. The list in the </span><kbd>RelatedMedia</kbd><span> component should also update with the current media removed from the list, so only the remaining playlist items are visible.</span></p>
<p>In order to handle this autoplay behavior across the <kbd>PlayMedia</kbd> component and its child components, <kbd>PlayMedia</kbd> passes a <kbd>handleAutoPlay</kbd> method to the <kbd>Media</kbd> component as a prop to be used by the <kbd>MediaPlayer</kbd> component when a video ends. The<span> </span><kbd>handleAutoPlay</kbd><span> method is defined as shown in the following code:</span></p>
<p><kbd><span>mern-mediastream/client/media/PlayMedia.js</span></kbd></p>
<pre>const handleAutoplay = (updateMediaControls) =&gt; {<br/>    let playList = relatedMedia<br/>    let playMedia = playList[0]<br/>    if(!autoPlay || playList.length == 0 )<br/>      return updateMediaControls()<br/><br/>    if(playList.length &gt; 1){<br/>      playList.shift()<br/>      setMedia(playMedia)<br/>      setRelatedMedia(playList)<br/>    }else{<br/>      listRelated({<br/>          mediaId: playMedia._id}).then((data) =&gt; {<br/>            if (data.error) {<br/>             console.log(data.error)<br/>            } else {<br/>              setMedia(playMedia)<br/>              setRelatedMedia(data)<br/>            }<br/>         })<br/>    }<br/>}</pre>
<p>This <kbd>handleAutoplay</kbd> method takes care of the following when a video ends in the <kbd>MediaPlayer</kbd> component:</p>
<ul>
<li style="font-weight: 400">It takes a callback function from the <kbd>onEnded</kbd> event listener in the <kbd>MediaPlayer</kbd> component. This callback will be executed if autoplay is not set or the related media list is empty so that the controls on the <kbd>MediaPlayer</kbd> are rendered to show that the video has ended.</li>
</ul>
<ul>
<li style="font-weight: 400">If autoplay is set and there are more than one related media in the list, then:
<ul>
<li style="font-weight: 400">The first item in the related media list is set as the current <kbd>media</kbd> object in the state so it can be rendered.</li>
<li style="font-weight: 400">The related media list is updated by removing this first item, which will now start playing in the view.</li>
</ul>
</li>
</ul>
<ul>
<li style="font-weight: 400">If autoplay is set and there is only one item in the related media list, this last item is set to <kbd>media</kbd> so it can start playing, and the <kbd>listRelated</kbd> fetch method is called to repopulate the <kbd>RelatedMedia</kbd> view with the related media for this last item.</li>
</ul>
<p>With these steps covered within this <kbd>handleAutoplay</kbd> method, all the aspects of the play media page can be updated accordingly at the end of a video, if autoplay is set to <kbd>true</kbd>. In the next section, we will see how the <kbd>MediaPlayer</kbd> component utilizes this <kbd>handleAutoplay</kbd> method when the current video ends, in order to make the autoplay feature functional.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the state when a video ends in MediaPlayer</h1>
                </header>
            
            <article>
                
<p>The <kbd>MediaPlayer</kbd> component receives the <kbd>handleAutoplay</kbd> method as a prop from <kbd>PlayMedia</kbd>. This method will be utilized when the current video finishes playing in the player. Hence, we will update the listener code for the <kbd>onEnded</kbd> event to execute this method only when the <kbd>loop</kbd> is set to <kbd>false</kbd> for the current video. We don't want to play the next video if the user has decided to loop the current video. The <kbd>onEnded</kbd> method in <kbd>MediaPlayer</kbd> will be updated with the highlighted code shown in the following block:</p>
<p><kbd>mern-mediastream/client/media/MediaPlayer.js</kbd></p>
<pre>  const onEnded = () =&gt; {<br/>    if(loop){<br/>      setPlaying(true)<br/>    } else{<br/>      <strong>props.handleAutoplay(()=&gt;{</strong><br/><strong>        setValues({...values, ended: true}) </strong><br/><strong>        setPlaying(false)</strong><br/><strong>      })</strong><br/>    }<br/>  }</pre>
<p>In this code, a callback function is passed to the <kbd>handleAutoplay</kbd> method, in order to set the <kbd>playing</kbd> value to <kbd>false</kbd> and render the replay icon button instead of the play or pause icon button, after it is determined in <kbd>PlayMedia</kbd> that the autoplay has not been set or that the related media list is empty.</p>
<p>The autoplay functionality will continue playing the related videos one after the other with this implementation. This implementation demonstrates another way to update the state across the components when the values are interdependent. </p>
<p class="mce-root">With this autoplay functionality implemented, we have a complete play media page with a customized media player and a related media list that the user can choose to autoplay through like a playlist. In the next section, we will make this page SEO-friendly by SSR of this view with the media data populated in the backend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Server-side rendering with data</h1>
                </header>
            
            <article>
                
<p>SEO is important for any web application that delivers content to its users and wants to make the content easy to find. Generally, content on any web page will have a better chance of getting more viewers if the content is easily readable to search engines. When a search-engine bot accesses a web URL, it will get the SSR output. Hence, to make the content discoverable, the content should be part of the SSR output.</p>
<p>In MERN Mediastream, we will use the case of making media details popular across search engine results, to demonstrate how to inject data into an SSR view in a MERN-based application. We will focus on implementing SSR with data injected for the <kbd>PlayMedia</kbd> component that is returned at the <kbd>'/media/:mediaId'</kbd> path. The general implementation steps outlined here can be used to implement SSR with data for other views.</p>
<p>In the following sections, we will extend the SSR implementation discussed in <a href="6f2ca10a-8079-4e3a-9d42-a3db8e85b9d9.xhtml" target="_blank">Chapter 4</a>, <em>Adding a React Frontend to Complete MERN</em>. We will first define a static route configuration file and use it to update the existing SSR code in the backend to inject the necessary media data from the database. Then, we will update the frontend code to render this server-injected data in the view, and, finally, check if this SSR implementation works as expected.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a route configuration file</h1>
                </header>
            
            <article>
                
<p>In order to load data for the React views when these are rendered on the server, we will need to list the frontend routes in a route configuration file. This file may then be used with the <kbd><span>react-router-config</span></kbd> module, which provides static route configuration helpers for React Router.</p>
<p>We will first install the module by running the following command from the command line:</p>
<pre><strong>yarn add react-router-config </strong></pre>
<p>Next, we will create a route configuration file that will list frontend React Router routes. This configuration will be used on the server to match these routes with incoming request URLs, to check whether data must be injected before the server returns the rendered markup in response to this request.</p>
<p>For the route configuration in MERN Mediastream, we will only list the route that renders the <kbd>PlayMedia</kbd> component and demonstrate how to server-render a specific component with data injected from the backend. The route configuration will be defined as follows:</p>
<p><kbd>mern-mediastream/client/routeConfig.js</kbd></p>
<pre>import PlayMedia from './media/PlayMedia' <br/>import { read } from './media/api-media.js' <br/>const routes = [<br/>  {<br/>    path: '/media/:mediaId',<br/>    component: PlayMedia,<br/>    loadData: (params) =&gt; read(params)<br/>  }<br/>]<br/>export default routes </pre>
<p>For this frontend route and <kbd>PlayMedia</kbd> component, we specify the <kbd>read</kbd> fetch method from <kbd>api-media.js</kbd> as the <kbd>loadData</kbd> method. This can then be used to retrieve and inject the data into the <kbd>PlayMedia</kbd> view when the server generates the markup for this component, after receiving a request at <kbd>/media/:mediaId</kbd>. In the next section, we will use this route configuration to update the existing SSR code on the backend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating SSR code for the Express server</h1>
                </header>
            
            <article>
                
<p>We will update the existing basic SSR code in <kbd>server/express.js</kbd> to add the data-loading functionality for the React views that will get rendered server-side. In the following sections, we will first see how to use the route configuration to load the data that needs to be injected when the server renders React components. Then, we will integrate <kbd>isomorphic-fetch</kbd> so the server is able to make the <kbd>read</kbd> fetch call to retrieve the necessary data, using the same API fetching code from the frontend. Finally, we will inject this retrieved data into the markup generated by the server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using route configuration to load data</h1>
                </header>
            
            <article>
                
<p>We will use the routes defined in the route configuration file to look for a matching route when the server receives any request. If a match is found, we will use the corresponding <kbd>loadData</kbd> method declared for this route in the configuration to retrieve the necessary data, before it is injected into the server-rendered markup representing the React frontend. We will perform these route-matching and data-loading actions in a method called <kbd>loadBranchData</kbd>, which is defined as follows:</p>
<p><kbd>mern-mediastream/server/express.js</kbd></p>
<pre>import { matchRoutes } from 'react-router-config' <br/>import routes from './../client/routeConfig' <br/>const loadBranchData = (location) =&gt; {<br/>  const branch = matchRoutes(routes, location) <br/>  const promises = branch.map(({ route, match }) =&gt; {<br/>    return route.loadData<br/>      ? route.loadData(branch[0].match.params)<br/>      : Promise.resolve(null)<br/>  })<br/>  return Promise.all(promises)<br/>}</pre>
<p><span>This method uses </span><kbd>matchRoutes</kbd><span> from </span><kbd>react-router-config</kbd><span>, and the routes defined in the route configuration file, to look for a route matching the incoming request URL, which is passed as the <kbd>location</kbd> argument. </span>If a matching route is found, then any associated <kbd>loadData</kbd> method will be executed to return a <kbd>Promise</kbd> containing the fetched data, or <kbd>null</kbd> if there were no <kbd>loadData</kbd> methods. The <kbd>loadBranchData</kbd> defined here will need to be called whenever the server receives a request, so if any matching route is found, we can fetch the relevant data and inject it into the React components while rendering server side. In the next section, we will ensure the fetch methods defined in the frontend code also work on the server side, so these same methods also load the corresponding data from the server side.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Isomorphic-fetch</h1>
                </header>
            
            <article>
                
<p>We will ensure that any fetch method we defined for the client code can also be used on the server by using the <kbd>isomorphic-fetch</kbd> Node module. We will first install the module by running the following command from the command line:</p>
<pre><strong>yarn add isomorphic-fetch</strong></pre>
<p>Then, we will simply<span> import <kbd>isomorphic-fetch</kbd> in </span><kbd>express.js</kbd><span>, as shown in the following code, to ensure fetch methods now work isomorphically both on the client and the server side: </span></p>
<p><kbd>mern-mediastream/server/express.js</kbd></p>
<pre>import 'isomorphic-fetch'</pre>
<p>This <kbd>isomorphic-fetch</kbd> integration will make sure <span>that the </span><kbd>read</kbd><span> fetch method, or any other fetch method that we defined for the client, can now be used on the server as well. Before this integration becomes functional, we need to ensure the fetch methods use absolute URLs, as discussed in the next section.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Absolute URLs</h1>
                </header>
            
            <article>
                
<p>One issue with using <kbd>isomorphic-fetch</kbd> is that it currently requires the fetch URLs to be absolute. So, we need to update the URL used in the <kbd>read</kbd> fetch method, defined in <kbd>api-media.js</kbd>, into an absolute URL.</p>
<p>Instead of hardcoding a server address in the code, we will set a <kbd>config</kbd> variable in <kbd>config.js</kbd>, as follows:</p>
<p><kbd>mern-mediastream/config/config.js</kbd></p>
<pre>serverUrl: process.env.serverUrl || 'http://localhost:3000'</pre>
<p>This will allow us to define and use separate absolute URLs for the API routes in development and in production.</p>
<p>Then, we will update the <kbd>read</kbd> method in <kbd>api-media.js</kbd> to make sure it uses an absolute URL to call the <kbd>read</kbd> API on the server, as highlighted in the following code:</p>
<p><kbd>mern-mediastream/client/media/api-media.js</kbd></p>
<pre><strong>import config from '../../config/config'</strong><br/>const read = (params) =&gt; {<br/>  return fetch(<strong>config.serverUrl +'/api/media/' + params.mediaId</strong>, {<br/>    method: 'GET'<br/>  }).then((response) =&gt; { ... })</pre>
<p>This will make the <kbd>read</kbd> fetch call compatible with <kbd>isomorphic-fetch</kbd>, so it can be used without a problem on the server side to retrieve the media data while server-rendering the <kbd>PlayMedia</kbd> component with data. In the next section, we will discuss how to inject this retrieved data into the server-generated markup representing the rendered React frontend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Injecting data into the React app</h1>
                </header>
            
            <article>
                
<p>In the existing SSR code in the backend, we use <kbd>ReactDOMServer</kbd> to convert the React app to markup. We will update this code in <kbd>express.js</kbd> to inject the retrieved data into the <kbd>MainRouter</kbd>, as shown in the following code:</p>
<p><kbd><span>mern-mediastream/server/express.js</span></kbd></p>
<pre>...<br/><strong>loadBranchData(req.url).then(data =&gt; {</strong><br/>       const markup = ReactDOMServer.renderToString(<br/>        sheets.collect(<br/>         &lt;StaticRouter location={req.url} context={context}&gt;<br/>             &lt;ThemeProvider theme={theme}&gt;<br/>                  &lt;MainRouter <strong>data={data}</strong>/&gt;<br/>             &lt;/ThemeProvider&gt;<br/>          &lt;/StaticRouter&gt;<br/>        )<br/>      )<br/>       ...<br/>  <strong>}).catch(err =&gt; {</strong><br/><strong>      res.status(500).send({"error": "Could not load React view with data"})</strong><br/><strong>  })</strong><br/>...<br/><br/></pre>
<p>We utilize the <kbd>loadBranchData</kbd> method to retrieve the relevant data for the requested view, then pass this data as a prop to the <kbd>MainRouter</kbd> component. For this data to be added correctly in the rendered <kbd>PlayMedia</kbd> component when the server generates the markup, we need to update the client-side code to consider this server-injected data, as discussed in the next section.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Applying server-injected data to client code</h1>
                </header>
            
            <article>
                
<p>We will update the React code in the frontend to add considerations for the data that may be injected from the server if the view is being rendered server-side. For this MERN Mediastream application, on the client side, we will access the media data passed from the server, and add it to the <kbd>PlayMedia</kbd> view when the server receives a direct request to render this component. In the following sections, we will see how to pass the data received in the <kbd>MainRouter</kbd> to the <kbd>PlayMedia</kbd> component, and render it accordingly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Passing data props to PlayMedia from MainRouter</h1>
                </header>
            
            <article>
                
<p>While generating markup with <kbd>ReactDOMServer.renderToString</kbd>, we pass the preloaded data to <kbd>MainRouter</kbd> as a prop. We can access this data prop in the <kbd>MainRouter</kbd> component definition, as follows: </p>
<p><kbd>mern-mediastream/client/MainRouter.js</kbd></p>
<pre>const MainRouter = (<strong>{data}</strong>) =&gt; { ... }</pre>
<p>To give <kbd>PlayMedia</kbd> access to this data from the <kbd>MainRouter</kbd>, we will change the <kbd>Route</kbd> component added originally to declare the route for <kbd>PlayMedia</kbd>, and pass this data as a prop, as shown in the following code:</p>
<p><kbd>mern-mediastream/client/MainRouter.js</kbd></p>
<pre>&lt;Route path="/media/:mediaId" <br/>       <strong>render={(props) =&gt; (</strong><br/><strong>                &lt;PlayMedia {...props} data={data} /&gt;</strong><br/><strong>              )}</strong> <br/>/&gt;</pre>
<p>The data prop sent to <kbd>PlayMedia</kbd> will need to be rendered in the view, as discussed next. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rendering received data in PlayMedia</h1>
                </header>
            
            <article>
                
<p>In the <kbd>PlayMedia</kbd> component, we will check for data passed from the server and set the values to the state so the media details are rendered in the view when the server is generating the corresponding markup. We will do this checking and assignment as shown in the following code:</p>
<p><kbd>mern-mediastream/client/media/PlayMedia.js</kbd></p>
<pre>if (props.data &amp;&amp; props.data[0] != null) {<br/>          media = props.data[0]<br/>          relatedMedia = []<br/>}</pre>
<p>If media data is received in the props from the server, we assign it to the <kbd>media</kbd> value in the state. We also set the <kbd>relatedMedia</kbd> value to an empty array, as we do not intend to render the related media list in the server-generated version. This implementation will produce server-generated markup with media data injected in the <kbd>PlayMedia</kbd> view when the corresponding frontend route request is received directly on the server. In the next section, we will see how to ensure this implementation is actually working and successfully rendering server-generated markup with the data populated.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checking the implementation of SSR with data</h1>
                </header>
            
            <article>
                
<p><span>For MERN Mediastream, any of t</span>he links th<span>at render <kbd>PlayMedia</kbd> should now generate markup on the server side with media details preloaded. </span>We can verify that the implementation for SSR with data is working properly by opening the app URL in a browser, with JavaScript turned off. In the following section, we will look into how to achieve this check in the Chrome browser, and what the resulting view should show to the user and to a search engine.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing in Chrome</h1>
                </header>
            
            <article>
                
<p>Testing this implementation in Chrome just requires updating the Chrome settings and loading the application in a tab, with JavaScript blocked. In the following sections, we will go over the steps to check whether the <kbd>PlayMedia</kbd> view renders with data when it is just server-generated markup.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading a page with JavaScript enabled</h1>
                </header>
            
            <article>
                
<p>First, open the MERN Mediastream application in Chrome, then browse to any media link and let it render normally with JavaScript enabled. This should show the implemented <kbd>PlayMedia</kbd> view with the functioning media player and the related media list. Leave this tab open as we move on to the next step, to disable JavaScript in Chrome. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Disabling JavaScript from settings</h1>
                </header>
            
            <article>
                
<p>To test how the server-generated markup is rendered in the view, we need to disable JavaScript on Chrome. For this, you can go to the advanced settings <span>at <kbd>chrome://settings/content/javascript</kbd>, and use the toggle to block JavaScript, as shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-906 image-border" src="assets/f60e09a3-e532-4a03-a84b-b43dcdab701e.png" style="width:15.50em;height:8.58em;"/></div>
<p>Now, refresh the media link in the MERN Mediastream tab, and there should be an icon next to the address URL, as shown in the following screenshot, indicating that JavaScript is indeed disabled:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-907 image-border" src="assets/b727426e-3006-417b-b8ae-863f5ed033d1.png" style="width:26.25em;height:2.17em;"/></div>
<p>The view that will be displayed in the browser at this point will only render the server-generated markup received from the backend. In the next section, we will discuss what the expected view is when JavaScript is blocked on the browser. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PlayMedia view with JavaScript blocked</h1>
                </header>
            
            <article>
                
<p>When JavaScript is blocked in the browser, the <kbd>PlayMedia</kbd> view should render with only the media details populated. But <span>the user interface is no longer interactive as JavaScript </span>is blocked, and only the default browser controls are operational, as shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-908 image-border" src="assets/7726da83-d4db-4ace-a46a-0970824d4ebb.png" style="width:38.42em;height:33.17em;"/></div>
<p>This is the markup that a search-engine bot will read for media content, and also what a user will see when no JavaScript loads on the browser. If this <span>implementation for </span>SSR with data was not added to the application, then this view would render without the associated media details in this scenario, and hence the media information would not be read and indexed by search engines. </p>
<p>MERN Mediastream now has fully operational media-playing tools that will allow users to browse and play videos with ease. In addition, the media views that display individual media content items are now search-engine-optimized because of SSR with preloaded data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we completely upgraded the play media page on MERN Mediastream. We first added custom media player controls, utilizing options available in the <kbd>ReactPlayer</kbd> component. Then, we incorporated the autoplay functionality for a related media playlist, after retrieving the related media from the database. Finally, we made the media details search-engine-readable by injecting data from the server when the view is rendered on the server. </p>
<p class="mce-root">You can apply the techniques explored in this chapter to build the play media page, to compose and build your own complex user interface with React components that are interdependent, and to add SSR with data for views that need to be SEO-friendly in your applications. </p>
<p>We have now explored advanced capabilities, such as <span>streaming and SEO, with</span> the MERN stack technologies. In the next two chapters, we will test the potential of this stack further by incorporating <strong>virtual reality</strong> (<strong>VR</strong>) elements into a full-stack web application using React 360.</p>


            </article>

            
        </section>
    </body></html>