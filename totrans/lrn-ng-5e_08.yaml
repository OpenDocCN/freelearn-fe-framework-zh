- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Communicating with Data Services over HTTP
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过HTTP与数据服务通信
- en: A real-world scenario for enterprise Angular applications is to connect to remote
    services and APIs to exchange data. The Angular HTTP client provides out-of-the-box
    support for communicating with services over HTTP. The interaction of an Angular
    application with the HTTP client is based on RxJS observable streams, giving developers
    a rich set of capabilities for data access.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于企业级Angular应用程序的一个真实场景是连接到远程服务和API以交换数据。Angular HTTP客户端提供了与HTTP服务通信的现成支持。Angular应用程序与HTTP客户端的交互基于RxJS可观察流，为开发者提供了一套丰富的数据访问能力。
- en: There are many ways to connect to APIs through HTTP. In this book, we will only
    scratch the surface. Still, the insights covered in this chapter will give you
    all you need to connect your Angular applications to HTTP services in no time,
    leaving all you can do with them up to your creativity.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过HTTP连接到API有许多方法。在这本书中，我们只会触及表面。然而，本章涵盖的见解将让你能够迅速将Angular应用程序连接到HTTP服务，而如何使用它们的创意则完全取决于你。
- en: 'In this chapter, we will explore the following concepts:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下概念：
- en: Communicating data over HTTP
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过HTTP进行数据通信
- en: Introducing the Angular HTTP client
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Angular HTTP客户端
- en: Setting up a backend API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置后端API
- en: Handling CRUD data in Angular
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular中处理CRUD数据
- en: Authentication and authorization with HTTP
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP进行身份验证和授权
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The chapter contains various code samples to walk you through the concept of
    the Angular HTTP client. You can find the related source code in the `ch08` folder
    of the following GitHub repository:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例，以向您介绍Angular HTTP客户端的概念。您可以在以下GitHub仓库的`ch08`文件夹中找到相关源代码：
- en: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition)'
- en: Communicating data over HTTP
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过HTTP进行数据通信
- en: Before we dive into describing the Angular HTTP client and how to use it to
    communicate with servers, let’s talk about native HTTP implementations first.
    Currently, if we want to communicate with a server over HTTP using JavaScript,
    we can use the JavaScript-native `fetch` API. It contains all the necessary methods
    to connect with a server and exchange data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入描述Angular HTTP客户端及其如何与服务器通信之前，让我们首先谈谈原生的HTTP实现。目前，如果我们想使用JavaScript通过HTTP与服务器通信，我们可以使用JavaScript原生的`fetch`
    API。它包含所有连接到服务器和交换数据所需的方法。
- en: 'You can see an example of how to fetch data in the following code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下代码中看到一个如何获取数据的示例：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Although the `fetch` API is promise-based, the promise it returns is not rejected
    if there is an error. Instead, the request is unsuccessful when the `ok` property
    is not in the `response` object.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`fetch` API基于promise，但如果发生错误，它返回的promise不会被拒绝。相反，当`response`对象中没有`ok`属性时，请求将不成功。
- en: If the request to the remote URL is completed, we can use the `text()` method
    of the `response` object to return the response text inside a new promise. Finally,
    in the second `then` callback, we display either the response text or a specific
    error message to the browser console.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对远程URL的请求完成，我们可以使用`response`对象的`text()`方法在一个新的promise中返回响应文本。最后，在第二个`then`回调中，我们将响应文本或特定的错误消息显示到浏览器控制台。
- en: To learn more about the `fetch` API, check out the official documentation at
    [https://developer.mozilla.org/docs/Web/API/fetch](https://developer.mozilla.org/docs/Web/API/fetch)
    .
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`fetch` API的信息，请查看官方文档[https://developer.mozilla.org/docs/Web/API/fetch](https://developer.mozilla.org/docs/Web/API/fetch)。
- en: We have already learned that observables are flexible for managing asynchronous
    operations. You are probably wondering how we can apply this pattern when consuming
    information from an HTTP service. So far, you will be becoming used to submitting
    asynchronous requests to AJAX services and then passing the response to a callback
    or a promise. Now, we will handle the call by returning an observable. The observable
    will emit the server response as an event in the context of a stream, which can
    be funneled through RxJS operators to better digest the response.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，可观察者是管理异步操作时的灵活工具。你可能想知道我们如何将此模式应用于从HTTP服务获取信息时。到目前为止，你将习惯于向AJAX服务提交异步请求，然后将响应传递给回调或promise。现在，我们将通过返回一个可观察者来处理调用。该可观察者将在流的环境中作为事件发出服务器响应，这可以通过RxJS运算符进行过滤，以更好地处理响应。
- en: 'Let’s convert the previous example with the `fetch` API to an observable. We
    use the `Observable` class to wrap the `fetch` call in an observable stream and
    replace the `console` methods with the appropriate `observer` object methods:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将之前的 `fetch` API 示例转换为可观察对象。我们使用 `Observable` 类将 `fetch` 调用包装在一个可观察的流中，并用适当的
    `observer` 对象方法替换 `console` 方法：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding snippet, we use the following `observer` methods:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用了以下 `observer` 方法：
- en: '`next` : This returns the response data to subscribers when they arrive'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next`：当数据到达时，这个方法将响应数据返回给订阅者'
- en: '`complete` : This notifies subscribers that no other data will be available
    in the stream'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`complete`：这个方法通知订阅者流中不会有其他数据可用'
- en: '`error` : This alerts subscribers that an error has occurred'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`：这个方法会通知订阅者发生了错误'
- en: That’s it! We have now built a custom HTTP client. Of course, this isn’t much.
    Our custom HTTP client only handles a **GET** operation to get data from a remote
    endpoint. We are not handling many other operations of the HTTP protocol, such
    as **POST** , **PUT** , and **DELETE** . It was, however, essential to realize
    all the heavy lifting the HTTP client in Angular is doing for us. Another important
    lesson is how easy it is to turn an asynchronous API into an observable API that
    fits nicely with the rest of our asynchronous concepts. So, let’s continue with
    Angular’s implementation of an HTTP service.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们现在已经构建了一个自定义的 HTTP 客户端。当然，这并不算什么。我们的自定义 HTTP 客户端只处理一个 **GET** 操作来从远程端点获取数据。我们并没有处理
    HTTP 协议的许多其他操作，如 **POST**、**PUT** 和 **DELETE**。然而，意识到 Angular 中 HTTP 客户端为我们所做的大量工作是非常重要的。另一个重要的教训是如何轻松地将异步
    API 转换为与我们的其他异步概念很好地配合的可观察 API。因此，让我们继续探讨 Angular 中 HTTP 服务的实现。
- en: Introducing the Angular HTTP client
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Angular HTTP 客户端
- en: The HTTP client of the Angular framework is a separate Angular library that
    resides in the `@angular/common` npm package under the `http` namespace. The Angular
    CLI installs this package by default when creating a new Angular project.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 框架的 HTTP 客户端是一个独立的 Angular 库，位于 `@angular/common` npm 包下的 `http` 命名空间中。Angular
    CLI 在创建新的 Angular 项目时默认安装此包。
- en: You will need the source code of the Angular application we created in *Chapter
    6* , *Reactive Patterns in Angular* , to follow along with the rest of the chapter.
    After you get the code, we suggest you remove the `key-logger` folder for simplicity.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要我们在 *第 6 章*，*Angular 中的响应式模式* 中创建的 Angular 应用程序的源代码，以便跟随本章的其余部分。在您获取代码后，我们建议您为了简化，删除
    `key-logger` 文件夹。
- en: 'To start using the Angular HTTP client, we need to import the `provideHttpClient`
    method in the `app.config.ts` file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Angular HTTP 客户端，我们需要在 `app.config.ts` 文件中导入 `provideHttpClient` 方法：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Suppose we want to use the HTTP client in applications built with older versions
    of Angular. In that case, we need to import an Angular module, called `HttpClientModule`
    , from the `@angular/common/http` namespace into one of the modules of our application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在用旧版本的 Angular 构建的应用程序中使用 HTTP 客户端。在这种情况下，我们需要从 `@angular/common/http`
    命名空间中导入一个名为 `HttpClientModule` 的 Angular 模块到我们应用程序的某个模块中。
- en: 'The `provideHttpClient` method exposes various Angular services we can use
    to handle asynchronous HTTP communication. The most basic is the `HttpClient`
    service, which provides a robust API and abstracts all operations required to
    handle asynchronous connections through the following HTTP methods:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`provideHttpClient` 方法暴露了我们可以用来处理异步 HTTP 通信的各种 Angular 服务。最基本的是 `HttpClient`
    服务，它提供了一个强大的 API，并抽象了通过以下 HTTP 方法处理异步连接所需的所有操作：'
- en: '`get` : This performs a **GET** operation to fetch data'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`：这个方法执行一个 **GET** 操作来获取数据'
- en: '`post` : This performs a **POST** operation to add new data'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post`：这个方法执行一个 **POST** 操作来添加新数据'
- en: '`put` / `patch` : This performs a **PUT** / **PATCH** operation to update existing
    data'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put` / `patch`：这个方法执行一个 **PUT** / **PATCH** 操作来更新现有数据'
- en: '`delete` : This performs a **DELETE** operation to remove existing data'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete`：这个方法执行一个 **DELETE** 操作来删除现有数据'
- en: The previous HTTP methods constitute the primary operations for **Create, Read,
    Update, Delete** ( **CRUD** ) applications. All the earlier methods of the Angular
    HTTP client return an observable data stream. Angular components can use the RxJS
    library to subscribe to those methods and interact with a remote API.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 HTTP 方法构成了 **创建、读取、更新、删除**（**CRUD**）应用程序的主要操作。Angular HTTP 客户端的早期方法都返回一个可观察的数据流。Angular
    组件可以使用 RxJS 库订阅这些方法并与远程 API 交互。
- en: The Angular team is currently investigating and experimenting to see if they
    can make the use of RxJS optional in the framework. In that case, we might see
    an HTTP implementation that is based on signals. For the rest of this chapter,
    we will stick with observables because the Angular HTTP client does not support
    signals out of the box.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 团队目前正在调查和实验，看看他们是否可以使 RxJS 的使用在框架中成为可选的。在这种情况下，我们可能会看到一个基于信号的 HTTP 实现。在本章的其余部分，我们将坚持使用观察者，因为
    Angular HTTP 客户端不支持开箱即用的信号。
- en: In the following section, we will explore how to use these methods and communicate
    with a remote API.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用这些方法并与远程 API 通信。
- en: Setting up a backend API
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置后端 API
- en: A web CRUD application usually connects to a server and uses an HTTP backend
    API to perform operations on data. It fetches existing data, updates it, creates
    new data, or deletes it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Web CRUD 应用程序通常连接到服务器，并使用 HTTP 后端 API 对数据进行操作。它获取现有数据，更新它，创建新数据或删除它。
- en: In a real-world scenario, you will most likely interact with a real backend
    API service through HTTP. In this book, we will use a fake API called **Fake Store
    API** .
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的场景中，你很可能会通过 HTTP 与真实的后端 API 服务交互。在本书中，我们将使用一个名为 **Fake Store API** 的假
    API。
- en: The official Fake Store API documentation can be found at [https://fakestoreapi.com](https://fakestoreapi.com)
    .
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的 Fake Store API 文档可以在 [https://fakestoreapi.com](https://fakestoreapi.com)
    找到。
- en: 'The Fake Store API is a backend REST API available online that you can use
    when you need fake data for an e-commerce or e-shop web application. It can manage
    products, shopping carts, and users available in the JSON format. It exposes the
    following main endpoints:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Fake Store API 是一个在线可用的后端 REST API，当你需要为电子商务或网店 Web 应用程序生成假数据时可以使用它。它可以管理以 JSON
    格式存在的产品、购物车和用户。它公开以下主要端点：
- en: '**products** : This manages a set of product items'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**products**：这管理一组产品项'
- en: '**cart** : This manages the shopping cart of a user'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cart**：这管理用户的购物车'
- en: '**user** : This manages a collection of application users'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**user**：这管理应用程序用户集合'
- en: '**login** : This handles user authentication'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**login**：这处理用户认证'
- en: In this chapter, we will work only with the products and login endpoints. However,
    we will revisit the cart endpoint later in the book.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本章中，我们将仅与产品和登录端点一起工作。然而，我们将在本书的后面部分重新访问购物车端点。
- en: All operations that modify data do not persist them physically in a database.
    However, they return an indication of whether the operation was successful. All
    operations that get data return a predefined collection of items.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所有修改数据的操作都不会在数据库中物理持久化。然而，它们返回操作是否成功的指示。所有获取数据的操作返回一个预定义的项目集合。
- en: Handling CRUD data in Angular
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Angular 中处理 CRUD 数据
- en: CRUD applications are widely used in the Angular world. You will hardly find
    any web application that does not follow this pattern. Angular does a great job
    of supporting this type of application by providing the `HttpClient` service.
    In this section, we will explore the Angular HTTP client by interacting with the
    products endpoint of the Fake Store API.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD 应用程序在 Angular 世界中广泛使用。你几乎找不到不遵循此模式的 Web 应用程序。Angular 通过提供 `HttpClient`
    服务来很好地支持此类应用程序。在本节中，我们将通过与 Fake Store API 的产品端点交互来探索 Angular HTTP 客户端。
- en: Fetching data through HTTP
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 HTTP 获取数据
- en: 'The `ProductListComponent` class uses the `ProductsService` class to fetch
    and display product data. Data is currently hardcoded into the `products` property
    of the `ProductsService` class. In this section, we will modify our Angular application
    to work with live data from the Fake Store API:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductListComponent` 类使用 `ProductsService` 类来获取和显示产品数据。数据目前硬编码在 `ProductsService`
    类的 `products` 属性中。在本节中，我们将修改我们的 Angular 应用程序以使用 Fake Store API 的实时数据：'
- en: Open the `app.component.ts` file and remove the `providers` property from the
    `@Component` decorator. We will provide `APP_SETTINGS` directly through the application
    configuration file.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app.component.ts` 文件，从 `@Component` 装饰器中移除 `providers` 属性。我们将直接通过应用程序配置文件提供
    `APP_SETTINGS`。
- en: 'At this point, we can also remove the `title` property, the `title$` observable,
    the `setTitle` property, and the `constructor` of the component class:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们也可以移除 `title` 属性、`title$` 可观察对象、`setTitle` 属性和组件类的 `constructor`：
- en: '[PRE3]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Open the `app.component.html` file and modify the `<header>` HTML element so
    that it uses the `settings` object directly:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app.component.html` 文件，修改 `<header>` HTML 元素，使其直接使用 `settings` 对象：
- en: '[PRE4]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Open the `app.config.ts` file and add the `APP_SETTINGS` provider as follows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app.config.ts` 文件，并按如下方式添加 `APP_SETTINGS` 提供者：
- en: '[PRE5]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We provide `APP_SETTINGS` from the application configuration file because we
    want it to be accessible globally in the application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从应用程序配置文件中提供 `APP_SETTINGS`，因为我们希望它在应用程序中全局可访问。
- en: 'Open the `app.settings.ts` file and add a new property in the `AppSettings`
    interface that represents the URL of the Fake Store API:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app.settings.ts` 文件，并在 `AppSettings` 接口中添加一个新属性，代表 Fake Store API 的 URL：
- en: '[PRE6]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The URL of a backend API can also be added in environment files, as we will
    learn in *Chapter 14* , *Bringing Applications to Production* .
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 后端 API 的 URL 也可以添加到环境文件中，我们将在 *第 14 章*，*将应用程序部署到生产环境* 中学习这一点。
- en: 'Open the `products.service.ts` file and modify the `import` statements accordingly:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `products.service.ts` 文件，并相应地修改 `import` 语句：
- en: '[PRE7]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create the following property in the `ProductsService` class that represents
    the API products endpoint:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ProductsService` 类中创建以下属性，代表 API 产品端点：
- en: '[PRE8]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Modify the `constructor` to inject the `HttpClient` service:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `constructor` 以注入 `HttpClient` 服务：
- en: '[PRE9]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Modify the `getProducts` method so that it uses the `HttpClient` service to
    get the list of products:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `getProducts` 方法，使其使用 `HttpClient` 服务获取产品列表：
- en: '[PRE10]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding method, we use the `get` method of the `HttpClient` class and
    pass the products endpoint of the API as a parameter. We also define the `Product`
    as a generic type in the `get` method to indicate that the response from the API
    contains a list of `Product` objects.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们使用 `HttpClient` 类的 `get` 方法，并将 API 的产品端点作为参数传递。我们还在 `get` 方法中定义 `Product`
    为泛型类型，以指示 API 的响应包含 `Product` 对象的列表。
- en: 'Convert the `products` property to an empty array:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `products` 属性转换为空数组：
- en: '[PRE11]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will use this for local cache purposes later, in the *Modifying data through
    HTTP* section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *通过 HTTP 修改数据* 部分稍后用于本地缓存。
- en: 'Open the `product-list.component.html` file and modify the `@if` block so that
    it checks if the `products` template variable exists:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-list.component.html` 文件，并修改 `@if` 块，使其检查 `products` 模板变量是否存在：
- en: '[PRE12]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We need to check if the variable exists because data is now fetched from the
    Fake Store API and there will be a network delay before the variable has a value.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要检查变量是否存在，因为数据现在是从 Fake Store API 获取的，变量获得值之前会有网络延迟。
- en: 'If we run the application using the `ng serve` command, we should see an extended
    list of products from the API similar to the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `ng serve` 命令运行应用程序，我们应该看到来自 API 的扩展产品列表，类似于以下内容：
- en: '![img](img/B21418_08_01.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B21418_08_01.png)'
- en: 'Figure 8.1: Product list from the Fake Store API'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：Fake Store API 的产品列表
- en: 'The products endpoint supports passing a request parameter to limit the results
    returned from the API. As indicated at [https://fakestoreapi.com/docs#p-limit](https://fakestoreapi.com/docs#p-limit)
    , we can use a query parameter named **limit** to accomplish that task. Let’s
    see how we can pass query parameters in the Angular HTTP client:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 产品端点支持传递一个请求参数来限制 API 返回的结果。如 [https://fakestoreapi.com/docs#p-limit](https://fakestoreapi.com/docs#p-limit)
    所示，我们可以使用名为 **limit** 的查询参数来完成此任务。让我们看看如何在 Angular HTTP 客户端中传递查询参数：
- en: 'Open the `products.service.ts` file and import the `HttpParams` class from
    the `@angular/common/http` namespace:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `products.service.ts` 文件，从 `@angular/common/http` 命名空间导入 `HttpParams` 类：
- en: '[PRE13]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `HttpParams` class is used to pass query parameters in an HTTP request.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpParams` 类用于在 HTTP 请求中传递查询参数。'
- en: 'Create the following variable inside the `getProducts` method:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `getProducts` 方法内部创建以下变量：
- en: '[PRE14]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `HttpParams` class is immutable. The following would not work because every
    operation returns a new instance:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpParams` 类是不可变的。以下操作不会工作，因为每个操作都会返回一个新的实例：'
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `set` method of the `HttpParams` class creates a new query parameter. If
    we wanted to pass additional parameters, we should chain more `set` methods, such
    as:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpParams` 类的 `set` 方法创建一个新的查询参数。如果我们想传递额外的参数，我们应该链式调用更多的 `set` 方法，例如：'
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We use the second parameter of the `get` method to pass query parameters using
    the `params` property:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `get` 方法的第二个参数通过 `params` 属性传递查询参数：
- en: '[PRE17]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Save your changes, wait for the application to reload, and observe the application’s
    output:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的更改，等待应用程序重新加载，并观察应用程序的输出：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_08_02.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图片，屏幕截图，字体，自动生成的描述](img/B21418_08_02.png)'
- en: 'Figure 8.2: Product list'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2：产品列表
- en: 'In the preceding list, all products are displayed with the same tag icon, which
    is the default one according to the `@switch` block in the `product-list.component.html`
    file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，所有产品都显示相同的标签图标，这是根据 `product-list.component.html` 文件中的 `@switch` 块的默认设置：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `@switch` block relies on the product `title` property. We will change it
    so that it is based on the `category` property, which comes from the products
    endpoint of the API.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`@switch` 块依赖于产品 `title` 属性。我们将将其改为基于来自 API 产品端点的 `category` 属性：'
- en: 'Open the `product.ts` file and replace the `categories` property with the following
    property:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product.ts` 文件并将 `categories` 属性替换为以下属性：
- en: '[PRE19]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Open the `product-list.component.html` file and modify the `@switch` block
    as follows:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-list.component.html` 文件并按如下方式修改 `@switch` 块：
- en: '[PRE20]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We also need to modify the `product-detail.component.html` file because we
    replaced the `categories` property in step 1:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要修改 `product-detail.component.html` 文件，因为我们已经在步骤 1 中替换了 `categories` 属性：
- en: '[PRE21]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Save your changes, wait for the application to reload, and observe the application’s
    output:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的更改，等待应用程序重新加载，并观察应用程序的输出：
- en: '![img](img/B21418_08_03.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B21418_08_03.png)'
- en: 'Figure 8.3: Product list with categories'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3：带有类别的产品列表
- en: 'If you click on a product in the list, you will notice that the product details
    are shown correctly:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击列表中的产品，你会注意到产品详情显示正确：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_08_04.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图片，屏幕截图，字体，自动生成的描述](img/B21418_08_04.png)'
- en: 'Figure 8.4: Product details'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4：产品详情
- en: 'The product details component continues to work as expected because we pass
    the selected product as an input property from the product list:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 产品详情组件继续按预期工作，因为我们从产品列表传递所选产品作为输入属性：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will change the previous behavior and get the product details directly from
    the API using an HTTP GET request. The Fake Store API contains an endpoint method
    that we can use to get the details for a specific product based on its ID:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将改变之前的行为，直接通过 HTTP GET 请求从 API 获取产品详情。Fake Store API 包含一个端点方法，我们可以使用它根据产品的
    ID 获取特定产品的详情：
- en: 'Open the `products.service.ts` file and create a new `getProduct` method that
    accepts the product `id` as a parameter and initiates a GET request to the API
    based on that `id` :'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `products.service.ts` 文件并创建一个新的 `getProduct` 方法，该方法接受产品 `id` 作为参数，并根据该 `id`
    初始化对 API 的 GET 请求：
- en: '[PRE23]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding method uses the `get` method of the `HttpClient` service. It accepts
    the products endpoint URL followed by the product `id` as a parameter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法使用 `HttpClient` 服务的 `get` 方法。它接受产品端点 URL 后跟产品 `id` 作为参数。
- en: 'Open the `product-detail.component.ts` file and modify the `import` statements
    as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-detail.component.ts` 文件并按如下方式修改 `import` 语句：
- en: '[PRE24]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the following property in the `ProductDetailComponent` class:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ProductDetailComponent` 类中添加以下属性：
- en: '[PRE25]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `id` component property will be used to pass the ID of the selected product
    from the list.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`id` 组件属性将用于从列表传递所选产品的 ID。'
- en: 'Replace the `product` input property with the following observable:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `product` 输入属性替换为以下可观察对象：
- en: '[PRE26]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `product$` property will be used to call the `getProduct` method from the
    service.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`product$` 属性将用于从服务中调用 `getProduct` 方法。'
- en: 'Add a `constructor` in the `ProductDetailComponent` class and inject `ProductsService`
    :'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ProductDetailComponent` 类中添加一个 `constructor` 并注入 `ProductsService`：
- en: '[PRE27]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add `OnChanges` in the list of implemented interfaces:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现接口列表中添加 `OnChanges`：
- en: '[PRE28]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Implement the `ngOnChanges` method as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现以下 `ngOnChanges` 方法：
- en: '[PRE29]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding method, we assign the value of the `getProduct` method from
    `ProductsService` to the `product$` component property every time a new `id` is
    passed using the input binding.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，每次使用输入绑定传递新的 `id` 时，我们都将 `ProductsService` 中的 `getProduct` 方法的值分配给 `product$`
    组件属性。
- en: 'Open the `product-detail.component.html` file and modify its content so that
    it uses the `product$` observable:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-detail.component.html` 文件并修改其内容，使其使用 `product$` 可观察对象：
- en: '[PRE30]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, open the `product-list.component.html` file and bind the `id` of the
    `selectedProduct` property to the `id` input binding of the `<app-product-detail>`
    component:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开 `product-list.component.html` 文件并绑定 `selectedProduct` 属性的 `id` 到 `<app-product-detail>`
    组件的 `id` 输入绑定：
- en: '[PRE31]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If we run the application using the `ng serve` command and select a product
    from the list, we will verify that the product detail is displayed correctly.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`ng serve`命令运行应用程序并从列表中选择一个产品，我们将验证产品详情是否正确显示。
- en: We have learned how to get a list of items and a single item from a backend
    API and covered the **Read** part of a CRUD operation. In the following section,
    we cover the remaining parts of a CRUD operation, which are mainly concerned with
    modifying data.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何从后端API获取项目列表和单个项目，并涵盖了CRUD操作的**读取**部分。在下一节中，我们将涵盖CRUD操作的其余部分，这些部分主要涉及修改数据。
- en: Modifying data through HTTP
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过HTTP修改数据
- en: 'Modifying data in a CRUD application usually refers to adding new data and
    updating or deleting existing data. To demonstrate how to implement such functionality
    in an Angular application using the HTTP client, we will make the following changes
    to our application:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在CRUD应用程序中修改数据通常指的是添加新数据以及更新或删除现有数据。为了演示如何使用HTTP客户端在Angular应用程序中实现此类功能，我们将对我们的应用程序进行以下更改：
- en: Create an Angular component to add new products
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Angular组件以添加新产品
- en: Modify the product detail component to change the price of an existing product
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改产品详情组件以更改现有产品的价格
- en: Add a button in the product detail component to delete an existing product
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在产品详情组件中添加一个按钮以删除现有产品
- en: 'We have already mentioned that no HTTP operations persist data physically in
    the Fake Store API, so we need to implement a local cache mechanism for our product
    data and interact with it directly in the products service:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到，在Fake Store API中，没有HTTP操作会物理持久化数据，因此我们需要为我们的产品数据实现一个本地缓存机制，并在产品服务中直接与之交互：
- en: 'Open the `products.service.ts` file and import the `map` RxJS operator:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`products.service.ts`文件并导入`map` RxJS运算符：
- en: '[PRE32]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Modify the `getProducts` method as follows:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下修改`getProducts`方法：
- en: '[PRE33]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding method fills the `products` array with data from the API and returns
    product data as an observable.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法使用API中的数据填充`products`数组，并将产品数据作为可观察对象返回。
- en: 'Modify the `getProduct` method so that it uses the `products` array to return
    a product object instead of the Fake Store API:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`getProduct`方法，使其使用`products`数组返回产品对象，而不是使用Fake Store API：
- en: '[PRE34]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We now have our products service in place and can start building the component
    for adding new products.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经有了产品服务，可以开始构建添加新产品的组件。
- en: Adding new products
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加新产品
- en: 'To add a new product through our application, we need to send its details to
    the Fake Store API:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过我们的应用程序添加新产品，我们需要将其详细信息发送到Fake Store API：
- en: 'Open the `products.service.ts` file and add the following method:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`products.service.ts`文件并添加以下方法：
- en: '[PRE35]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding snippet, we use the `post` method of the `HttpClient` class
    and pass the products endpoint of the API along with a new product object as parameters.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用了`HttpClient`类的`post`方法，并传递了API的产品端点以及一个新产品对象作为参数。
- en: We define the new product as `Partial` because new products do not have an ID.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将新产品定义为`Partial`，因为新产品没有ID。
- en: The generic type defined in the `post` method indicates that the returned product
    from the API is a `Product` object. We also add the new product into the local
    cache and return it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在`post`方法中定义的泛型类型表示从API返回的产品是一个`Product`对象。我们还将在本地缓存中添加新产品并返回它。
- en: 'Run the following Angular CLI command to create a new component:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下Angular CLI命令以创建一个新的组件：
- en: '[PRE36]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Open the `product-create.component.ts` file and add the following `import`
    statement:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-create.component.ts`文件并添加以下`import`语句：
- en: '[PRE37]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create a `constructor` and inject the `ProductsService` class:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`constructor`并注入`ProductsService`类：
- en: '[PRE38]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add the following method to the component class:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下方法添加到组件类中：
- en: '[PRE39]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We do not need to unsubscribe when interacting with the Angular HTTP client
    because the framework will do it automatically for us.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在与Angular HTTP客户端交互时，我们不需要取消订阅，因为框架会自动为我们完成。
- en: The preceding method accepts the product details as parameters and calls the
    `addProduct` method of the `ProductsService` class. We use the native `Number`
    function to convert the price value to a number because it will be passed as a
    string from the template.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法接受产品详情作为参数并调用`ProductsService`类的`addProduct`方法。我们使用原生的`Number`函数将价格值转换为数字，因为它将从模板中作为字符串传递。
- en: 'Open the `product-create.component.html` file and replace its content with
    the following HTML template:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-create.component.html`文件并将内容替换为以下HTML模板：
- en: '[PRE40]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding template, we bind the `createProduct` method to the `click`
    event of the `Create` button and pass the value of the `<input>` and `<select>`
    HTML elements using the respective template reference variables.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模板中，我们将 `createProduct` 方法绑定到 `Create` 按钮的 `click` 事件，并使用相应的模板引用变量传递 `<input>`
    和 `<select>` HTML 元素的值。
- en: 'Open the global `styles.css` file and add the following CSS style:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开全局 `styles.css` 文件并添加以下 CSS 样式：
- en: '[PRE41]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Also, move the button-related styles from the `product-detail.component.css`
    file in the global CSS styles file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将按钮相关的样式从 `product-detail.component.css` 文件移动到全局 CSS 样式文件中。
- en: 'Open the `product-create.component.css` file and add the following CSS styles
    to give a nice look and feel to our new component:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-create.component.css` 文件并添加以下 CSS 样式以给我们的新组件一个良好的外观和感觉：
- en: '[PRE42]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Open the `product-list.component.ts` file and import the `ProductCreateComponent`
    class:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-list.component.ts` 文件并导入 `ProductCreateComponent` 类：
- en: '[PRE43]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, open the `product-list.component.html` file and add the following
    snippet at the end of the template:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开 `product-list.component.html` 文件并在模板末尾添加以下片段：
- en: '[PRE44]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we now run our Angular application using the `ng serve` command, we should
    see the component for adding new products at the end of the page:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在使用 `ng serve` 命令运行我们的 Angular 应用程序，我们应该在页面末尾看到添加新产品的组件：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, αριθμός  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_08_05.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、屏幕截图、字体、编号的自动生成的描述](img/B21418_08_05.png)'
- en: 'Figure 8.5: Create a product'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5：创建产品
- en: To experiment, try to add a new product by filling in its details, clicking
    on the **Create** button, and verifying that the new product has been added to
    the list.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实验，尝试通过填写其详细信息，点击 **创建** 按钮，并验证新产品是否已添加到列表中。
- en: The next feature we will add to our application is to modify data by changing
    the price of an existing product.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在应用程序中添加的下一个功能是通过更改现有产品的价格来修改数据。
- en: Updating product price
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新产品价格
- en: 'The price of a product in an e-commerce application may need to change at some
    point. We need to provide a way for our users to update that price through our
    application:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子商务应用程序中，产品的价格可能在某个时候需要更改。我们需要提供一个方法，让我们的用户可以通过我们的应用程序更新该价格：
- en: 'Open the `products.service.ts` file and add a new method for updating a product:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `products.service.ts` 文件并添加一个用于更新产品的新的方法：
- en: '[PRE45]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the preceding method, we use the `patch` method of the `HttpClient` class
    to send the details of the product that we want to modify to the API. We also
    update the price of the selected product in the local cache of products and return
    it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们使用 `HttpClient` 类的 `patch` 方法将我们要修改的产品详情发送到 API。我们还更新了所选产品的本地产品缓存中的价格，并返回它。
- en: Alternatively, we could have used the `put` method of the HTTP client. The `patch`
    method should be used when we want to update only a subset of an object, whereas
    the `put` method interacts with all object properties. In this case, we do not
    want to update the product title, so we use the `patch` method. Both methods accept
    the API endpoint and the object we want to update as parameters.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用 HTTP 客户端的 `put` 方法。当我们只想更新对象的一个子集时，应该使用 `patch` 方法，而 `put` 方法会与所有对象属性交互。在这种情况下，我们不想更新产品标题，因此使用
    `patch` 方法。这两种方法都接受 API 端点和我们要更新的对象作为参数。
- en: 'Add the following method to the `ProductDetailComponent` class:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下方法添加到 `ProductDetailComponent` 类中：
- en: '[PRE46]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The preceding method accepts an existing `product` and its new `price` as parameters
    and calls the `updateProduct` method of the `ProductsService` class.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法接受一个现有的 `product` 和其新的 `price` 作为参数，并调用 `ProductsService` 类的 `updateProduct`
    方法。
- en: 'Open the `product-detail.component.html` file and add an `<input>` and a `<button>`
    element after the paragraph element of the price:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-detail.component.html` 文件并在价格段落元素之后添加一个 `<input>` 和一个 `<button>`
    元素：
- en: '[PRE47]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `<input>` element is used to enter the new price of the product and defines
    the `price` template reference variable. The `click` event of the `<button>` element
    is bound to the `changePrice` method that passes the current `product` object
    and the value of the `price` variable.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`<input>` 元素用于输入产品的新的价格并定义 `price` 模板引用变量。`<button>` 元素的 `click` 事件绑定到 `changePrice`
    方法，该方法传递当前的 `product` 对象和 `price` 变量的值。'
- en: 'Finally, open the `product-detail.component.css` file and add the following
    CSS styles:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开 `product-detail.component.css` 文件并添加以下 CSS 样式：
- en: '[PRE48]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Run the `ng serve` command to start the Angular application and select a product
    from the list. The product details should look like the following:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `ng serve` 命令以启动 Angular 应用程序，并从列表中选择一个产品。产品详情应如下所示：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_08_06.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图像，屏幕截图，字体  自动生成的描述](img/B21418_08_06.png)'
- en: 'Figure 8.6: Product details'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6：产品详情
- en: 'Enter a price in the **New price** input box and click the **Change** button.
    The existing price should be updated to reflect the change, for example:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **新价格** 输入框中输入一个价格并点击 **更改** 按钮。现有价格应更新以反映更改，例如：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_08_07.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图像，屏幕截图，字体  自动生成的描述](img/B21418_08_07.png)'
- en: 'Figure 8.7: Product details with changed price'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7：更改价格后的产品详情
- en: We can now modify a product by changing its price.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过更改价格来修改产品。
- en: Remember that changes in products that come from the Fake Store API are not
    physically persisted. If you change the price and refresh the browser, it will
    restore the initial price.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，来自 Fake Store API 的产品更改不会物理持久化。如果你更改价格并刷新浏览器，它将恢复初始价格。
- en: The next and final step of our CRUD application will be to delete an existing
    product.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 CRUD 应用程序的下一步和最后一步将是删除一个现有的产品。
- en: Removing a product
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除产品
- en: 'Deleting a product from an e-shop application is not very common. However,
    we need to provide functionality for it in case users enter incorrect or invalid
    data and want to delete it afterward. In our application, deleting an existing
    product will be done with the product details component:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子商务应用程序中删除产品并不常见。然而，我们需要为此提供功能，以防用户输入错误或不正确的数据，之后想要删除它。在我们的应用程序中，删除现有产品将通过产品详情组件来完成：
- en: 'Open the `products.service.ts` file and import the `tap` operator from the
    `rxjs` package:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `products.service.ts` 文件，并从 `rxjs` 包中导入 `tap` 操作符：
- en: '[PRE49]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Add the following method to the `ProductsService` class:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下方法添加到 `ProductsService` 类中：
- en: '[PRE50]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding method, we use the `delete` method of the `HttpClient` class,
    passing the products endpoint and the product `id` we want to delete in the API.
    We are also using the `splice` method of the `products` array to remove the product
    from the local cache.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们使用 `HttpClient` 类的 `delete` 方法，将产品端点和要删除的 API 产品 `id` 传递给方法。我们还在使用
    `products` 数组的 `splice` 方法从本地缓存中删除产品。
- en: The return type of the method is set to `Observable<void>` because we are not
    currently interested in the result of the HTTP request. We only need to know if
    it was successful or not. We also use the `tap` RxJS operator because we are not
    altering the returned value from the observable.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的返回类型设置为 `Observable<void>`，因为我们目前对 HTTP 请求的结果不感兴趣。我们只需要知道它是否成功。我们还使用了 `tap`
    RxJS 操作符，因为我们没有改变可观察返回的值。
- en: 'Open the `product-detail.component.ts` file and create a new output property
    in the `ProductDetailComponent` class:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-detail.component.ts` 文件，并在 `ProductDetailComponent` 类中创建一个新的输出属性：
- en: '[PRE51]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The preceding property will notify the `ProductListComponent` that the selected
    product has been deleted.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的属性将通知 `ProductListComponent` 已删除所选产品。
- en: 'Create the following method, which calls the `deleteProduct` method of the
    `ProductsService` class and triggers the `deleted` output event:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下方法，该方法调用 `ProductsService` 类的 `deleteProduct` 方法并触发 `deleted` 输出事件：
- en: '[PRE52]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Open the `product-detail.component.html` file, create a `<button>` element,
    and bind its `click` event to the `emit` method of the `deleted` output:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-detail.component.html` 文件，创建一个 `<button>` 元素，并将其 `click` 事件绑定到 `deleted`
    输出事件的 `emit` 方法：
- en: '[PRE53]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the preceding snippet, we grouped the two buttons in a `<div>` HTML element
    so that they appear side by side.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将两个按钮分组在一个 `<div>` HTML 元素中，以便它们并排显示。
- en: 'Add an appropriate style for the new button and the button group in the `product-detail.component.css`
    file:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `product-detail.component.css` 文件中添加新按钮和按钮组的适当样式：
- en: '[PRE54]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Open the `product-list.component.html` file and add a binding to the `deleted`
    event of the `<app-product-detail>` component:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-list.component.html` 文件，并为 `<app-product-detail>` 组件的 `deleted`
    事件添加绑定：
- en: '[PRE55]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If we run the application using the `ng serve` command and select a product
    from the list, we should see something like the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `ng serve` 命令运行应用程序并从列表中选择一个产品，我们应该看到以下内容：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_08_08.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图片，屏幕截图，字体，自动生成的描述](img/B21418_08_08.png)'
- en: 'Figure 8.8: Product details'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8：产品详情
- en: The product detail component now has a **Delete** button that deletes the product
    and removes it from the list when it is clicked.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 产品详情组件现在有一个 **删除** 按钮，当点击时，它会删除产品并将其从列表中移除。
- en: Remember that changes in products that come from the Fake Store API are not
    physically persisted. If you delete a product and refresh the browser, the product
    will appear again on the list.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，来自 Fake Store API 的产品更改不会物理持久化。如果你删除一个产品并刷新浏览器，该产品将再次出现在列表中。
- en: The e-shop application we have built so far has an **Add to cart** button that
    we can use to add a product to a shopping cart. The button does not do much yet,
    but we will implement the full cart functionality in the following chapters. According
    to the documentation of the Fake Store API, shopping carts are only available
    to authenticated users, so we must ensure that the **Add to cart** button will
    only be available to them in our application.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止构建的电子商务应用有一个 **添加到购物车** 按钮可以用来将产品添加到购物车。按钮目前还没有做什么，但我们将将在下一章中实现完整的购物车功能。根据
    Fake Store API 的文档，购物车仅对认证用户可用，因此我们必须确保在我们的应用中 **添加到购物车** 按钮仅对它们可用。
- en: In an Angular enterprise application, the product management feature must also
    be protected from unauthorized users. In this case, we would implement a more
    granular authorization scheme with user roles, allowing only administrators to
    change and add products. We will not implement this feature, but we encourage
    you to experiment.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 企业应用中，产品管理功能也必须保护免受未经授权的用户访问。在这种情况下，我们将实现一个更细粒度的授权方案，使用户角色仅允许管理员更改和添加产品。我们不会实现此功能，但鼓励您进行实验。
- en: In the following section, we will learn about authentication and authorization
    in Angular.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习 Angular 中的认证和授权。
- en: Authentication and authorization with HTTP
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HTTP 进行认证和授权
- en: The Fake Store API provides an endpoint for authenticating users. It contains
    a login method that accepts a username and a password as parameters and returns
    an authentication token. We will use the authentication token in our application
    to differentiate between a logged-in user and a guest.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Fake Store API 提供了一个用于用户认证的端点。它包含一个接受用户名和密码作为参数的登录方法，并返回一个认证令牌。我们将在我们的应用中使用认证令牌来区分已登录用户和访客。
- en: A predefined pool from the users endpoint at [https://fakestoreapi.com/users](https://fakestoreapi.com/users)
    provides the username and password.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 来自用户端点 [https://fakestoreapi.com/users](https://fakestoreapi.com/users) 的预定义池提供了用户名和密码。
- en: 'We will explore the following authentication and authorization topics in this
    section:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下认证和授权主题：
- en: Authenticating with a backend API
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用后端 API 进行认证
- en: Authorizing users for certain features
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权用户访问某些功能
- en: Authorizing HTTP requests using interceptors
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用拦截器授权 HTTP 请求
- en: Let’s get started with the topic of authenticating with the Fake Store API.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用 Fake Store API 进行认证的主题开始。
- en: Authenticating with a backend API
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用后端 API 进行认证
- en: In Angular real-world applications, we usually create an Angular component,
    allowing users to log in and out of the application. An Angular service will communicate
    with the API and handle all authentication tasks.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 的实际应用中，我们通常创建一个 Angular 组件，允许用户登录和注销应用。Angular 服务将与 API 通信并处理所有认证任务。
- en: 'Let’s get started by creating the authentication service:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建认证服务开始：
- en: 'Run the following command to create a new Angular service:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以创建一个新的 Angular 服务：
- en: '[PRE56]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Open the `auth.service.ts` file and modify the `import` statements as follows:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `auth.service.ts` 文件并按如下方式修改 `import` 语句：
- en: '[PRE57]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Create the following properties in the `AuthService` class:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AuthService` 类中创建以下属性：
- en: '[PRE58]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the preceding snippet, the `accessToken` signal will store the authentication
    token from the API, and the `isLoggedIn` signal indicates whether the user is
    logged in. The logged-in status of the user depends on whether the `accessToken`
    property has a value.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`accessToken` 信号将存储来自 API 的认证令牌，而 `isLoggedIn` 信号指示用户是否已登录。用户的登录状态取决于
    `accessToken` 属性是否有值。
- en: Signals can be used not only in Angular components but also inside services.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 信号不仅可以在 Angular 组件中使用，也可以在服务内部使用。
- en: The `authUrl` property points to the authentication endpoint URL of the Fake
    Store API.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`authUrl` 属性指向 Fake Store API 的认证端点 URL。'
- en: 'Inject the `HttpClient` class in the `constructor` :'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `constructor` 中注入 `HttpClient` 类：
- en: '[PRE59]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create a `login` method to allow users to log in to the Fake Store API:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `login` 方法以允许用户登录到 Fake Store API：
- en: '[PRE60]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The preceding method initiates a POST request to the API, using the login endpoint
    and passing `username` and `password` in the request body. The observable returned
    from the POST request is passed to the `tap` operator, which updates the `accessToken`
    signal.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法使用 API 的登录端点发起 POST 请求，并在请求体中传递 `username` 和 `password`。从 POST 请求返回的可观察对象传递给
    `tap` 操作符，该操作符更新 `accessToken` 信号。
- en: 'Create a `logout` method that resets the `accessToken` signal:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `logout` 方法来重置 `accessToken` 信号：
- en: '[PRE61]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We have already set up the business logic for authenticating users in our Angular
    application. In the following section, we will learn how to use it to control
    authorization in the application.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 Angular 应用程序中设置了用户认证的业务逻辑。在下一节中，我们将学习如何使用它来控制应用程序中的授权。
- en: Authorizing user access
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权用户访问
- en: 'First, we will create an authentication component that will allow our users
    to log in and out of the application:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个认证组件，允许我们的用户登录和登出应用程序：
- en: 'Run the following command to create a new Angular component:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以创建一个新的 Angular 组件：
- en: '[PRE62]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Open the `auth.component.ts` file and add the following `import` statement:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `auth.component.ts` 文件并添加以下 `import` 语句：
- en: '[PRE63]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Inject `AuthService` in the component’s `constructor` :'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的 `constructor` 中注入 `AuthService`：
- en: '[PRE64]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the preceding snippet, we use the `public` access modifier to inject `AuthService`
    because we want it to be accessible from the component’s template.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用 `public` 访问修饰符注入 `AuthService`，因为我们希望它可以从组件的模板中访问。
- en: 'Create the following methods in the `AuthComponent` class:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AuthComponent` 类中创建以下方法：
- en: '[PRE65]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In the preceding snippet, the `login` method uses predefined credentials from
    the users endpoint.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`login` 方法使用用户端点的预定义凭据。
- en: 'Open the `auth.component.html` file and replace its content with the following
    HTML template:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `auth.component.html` 文件，并用以下 HTML 模板替换其内容：
- en: '[PRE66]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The preceding template contains two `<button>` HTML elements for login/logout
    purposes. Each button is displayed conditionally according to the value of the
    `isLoggedIn` signal of the `AuthService` class.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模板包含两个 `<button>` HTML 元素，用于登录/登出。每个按钮根据 `AuthService` 类的 `isLoggedIn` 信号值有条件地显示。
- en: 'We can now leverage the `isLoggedIn` signal in the product detail component
    and toggle the visibility of the **Add to cart** button:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以利用产品详情组件中的 `isLoggedIn` 信号来切换 **添加到购物车** 按钮的可见性：
- en: 'Open the `product-detail.component.ts` file and add the following `import`
    statement:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-detail.component.ts` 文件并添加以下 `import` 语句：
- en: '[PRE67]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Inject `AuthService` in the `constructor` of the `ProductDetailComponent` class:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ProductDetailComponent` 类的 `constructor` 中注入 `AuthService`：
- en: '[PRE68]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Open the `product-detail.component.html` file and use an `@if` block to display
    the **Add to cart** button conditionally:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-detail.component.html` 文件，并使用 `@if` 块有条件地显示 **添加到购物车** 按钮：
- en: '[PRE69]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Open the `app.component.ts` file and import the `AuthComponent` class:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app.component.ts` 文件并导入 `AuthComponent` 类：
- en: '[PRE70]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Open the `app.component.html` file and add the `<app-auth>` tag inside the
    `<header>` HTML element:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app.component.html` 文件并在 `<header>` HTML 元素内添加 `<app-auth>` 标签：
- en: '[PRE71]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To try the authentication feature in the application, follow these steps:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试应用程序中的认证功能，请按照以下步骤操作：
- en: Run the `ng serve` command to start the application and navigate to `http://localhost:4200`
    .
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `ng serve` 命令以启动应用程序并导航到 `http://localhost:4200` 。
- en: Select a product from the list and verify that the **Add to cart** button is
    not visible.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中选择一个产品并验证 **添加到购物车** 按钮不可见。
- en: Click the **Login** button in the top-left corner of the page. The text should
    change to **Logout** after you have logged in successfully to the Fake Store API,
    and the **Add to cart** button should appear.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面左上角的 **登录** 按钮。成功登录到 Fake Store API 后，文本应更改为 **登出**，并且 **添加到购物车** 按钮应出现。
- en: Congratulations! You have added basic authentication and authorization patterns
    to your Angular application.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已将基本认证和授权模式添加到您的 Angular 应用程序中。
- en: It is common in enterprise applications to perform authorization in the business
    logic layer while communicating with the backend API. The backend API often requires
    certain method calls to pass the authentication token in each request through
    headers. We will learn how to work with **HTTP headers** in the following section.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用程序中，在向后端API通信时执行授权是常见的。后端API通常要求在每次请求中通过头部传递认证令牌。在下一节中，我们将学习如何使用**HTTP头部**。
- en: Authorizing HTTP requests
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权HTTP请求
- en: 'The Fake Store API does not require authorization while communicating with
    its endpoints. However, suppose we are working with a backend API that expects
    all HTTP requests to contain an authentication token using HTTP headers. A common
    pattern in web applications is to include the token in an **Authorization** header.
    We can use HTTP headers in an Angular application by importing the `HttpHeaders`
    class from the `@angular/common/http` namespace and modifying our methods accordingly.
    Here is an example of how the `getProducts` method should look:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Fake Store API在与端点通信时不需要授权。然而，假设我们正在与一个期望所有HTTP请求都包含使用HTTP头部传递的认证令牌的后端API一起工作。在Web应用程序中，一个常见的模式是在**Authorization**头部中包含令牌。我们可以通过从`@angular/common/http`命名空间导入`HttpHeaders`类并在相应的方法中修改来在Angular应用程序中使用HTTP头部。以下是如何看起来`getProducts`方法的示例：
- en: '[PRE72]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: For simplicity, we are using a hardcoded value for the authentication token.
    In a real-world scenario, we may get it from the local storage of the browser
    or some other means.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们正在使用硬编码的值作为认证令牌。在实际场景中，我们可能从浏览器的本地存储或其他方式中获取它。
- en: All `HttpClient` methods accept an optional object as a parameter for passing
    additional options to an HTTP request, including HTTP headers. To set headers,
    we use the `headers` property of the `options` object and create a new instance
    of the `HttpHeaders` class as a value. The `HttpHeaders` object is a key-value
    pair that defines custom HTTP headers.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`HttpClient`方法都接受一个可选的对象作为参数，用于将额外的选项传递给HTTP请求，包括HTTP头部。要设置头部，我们使用`options`对象的`headers`属性，并创建一个`HttpHeaders`类的新实例作为值。`HttpHeaders`对象是一个键值对，它定义了自定义HTTP头部。
- en: Now, imagine what will happen if we need to pass the authentication token in
    all methods of the `ProductsService` class. We should go to each of them and write
    the same code repeatedly. Our code could quickly become cluttered and difficult
    to test. Luckily, the Angular HTTP client has another feature we can use to help
    us in such a situation called **interceptors** .
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们需要在`ProductsService`类的所有方法中传递认证令牌，会发生什么情况。我们应该逐个进入它们并重复编写相同的代码。我们的代码可能会很快变得杂乱无章，难以测试。幸运的是，Angular
    HTTP客户端有另一个我们可以用来帮助这种情况的功能，称为**拦截器**。
- en: 'An HTTP interceptor is an Angular service that intercepts HTTP requests and
    responses that pass through the Angular HTTP client. It can be used in the following
    scenarios:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP拦截器是一个Angular服务，它拦截通过Angular HTTP客户端传递的HTTP请求和响应。它可以在以下场景中使用：
- en: When we want to pass custom HTTP headers in every request, such as an authentication
    token
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想要在每次请求中传递自定义HTTP头部，例如认证令牌
- en: When we want to display a loading indicator while we wait for a response from
    the server
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想要在等待服务器响应时显示加载指示器
- en: When we want to provide a logging mechanism for every HTTP communication
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想要为每次HTTP通信提供一个日志记录机制
- en: 'In our case, we can create an interceptor for passing the authentication token
    to each HTTP request:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们可以为每个HTTP请求创建一个传递认证令牌的拦截器：
- en: 'Run the following command to create a new interceptor:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以创建一个新的拦截器：
- en: '[PRE73]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Open the `app.config.ts` file and import the `withInterceptors` function from
    the `@angular/common/http` namespace:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.config.ts`文件并从`@angular/common/http`命名空间导入`withInterceptors`函数：
- en: '[PRE74]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The `withInterceptors` function is used to register an interceptor with the
    HTTP client.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`withInterceptors`函数用于将拦截器注册到HTTP客户端。'
- en: 'Import the interceptor we created in the previous step using the following
    statement:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下语句导入我们在上一步中创建的拦截器：
- en: '[PRE75]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Modify the `provideHttpClient` method to register the `authInterceptor` :'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`provideHttpClient`方法以注册`authInterceptor`：
- en: '[PRE76]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `withInterceptors` function accepts a list of registered interceptors,
    and their order matters. In the following diagram, you can see how interceptors
    process HTTP requests and responses according to their order:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`withInterceptors`函数接受一个已注册的拦截器列表，它们的顺序很重要。在下面的图中，你可以看到拦截器如何根据它们的顺序处理HTTP请求和响应：'
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, διάγραμμα, γραμματοσειρά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_08_09.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、屏幕截图、图表、字体样式的自动生成的描述](img/B21418_08_09.png)'
- en: 'Figure 8.9: Execution order of Angular interceptors'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：Angular拦截器的执行顺序
- en: By default, the last interceptor before sending the request to the server is
    a built-in Angular service named **HttpBackend** .
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在将请求发送到服务器之前的最后一个拦截器是一个名为**HttpBackend**的内置Angular服务。
- en: 'Open the `auth.interceptor.ts` file and modify the arrow function of the `authInterceptor`
    function as follows:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`auth.interceptor.ts`文件，并按照以下方式修改`authInterceptor`函数的箭头函数：
- en: '[PRE77]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The arrow function accepts the following parameters: `req` , which indicates
    the current request, and `next` , which is the next interceptor in the chain.
    In the preceding snippet, we use the `clone` method to modify the existing request
    because HTTP requests are immutable by default. Similarly, due to the immutable
    nature of HTTP headers, we use the `setHeaders` method to update them. Finally,
    we delegate the request to the next interceptor using the `handle` method.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数接受以下参数：`req`，表示当前请求，以及`next`，它是链中的下一个拦截器。在上面的代码片段中，我们使用`clone`方法修改现有的请求，因为默认情况下HTTP请求是不可变的。同样，由于HTTP头部的不可变性质，我们使用`setHeaders`方法来更新它们。最后，我们使用`handle`方法将请求委托给下一个拦截器。
- en: 'Interceptors can use the `inject` method to get dependencies that they may
    need from the Angular DI mechanism. For example, if we wanted to use the `AuthService`
    class inside the interceptor, we could modify it as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器可以使用`inject`方法从Angular DI机制获取它们可能需要的依赖项。例如，如果我们想在拦截器内部使用`AuthService`类，我们可以按照以下方式修改它：
- en: '[PRE78]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In applications built with older versions of the Angular framework, you may
    notice that interceptors are TypeScript classes instead of pure functions. To
    register an interceptor with the HTTP client, we need to add the following `provide`
    object literal in the `providers` array of the module, which also provides the
    `HttpClientModule` :'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用较旧版本的Angular框架构建的应用程序中，您可能会注意到拦截器是TypeScript类而不是纯函数。为了将拦截器注册到HTTP客户端，我们需要在模块的`providers`数组中添加以下`provide`对象字面量，它还提供了`HttpClientModule`：
- en: '[PRE79]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In the preceding snippet, `HTTP_INTERCEPTORS` is an injection token that can
    be provided multiple times as indicated by the `multi` property.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`HTTP_INTERCEPTORS`是一个可以多次提供的注入令牌，如`multi`属性所示。
- en: Angular interceptors have many uses, and authorization is one of the most basic.
    Passing authentication tokens during HTTP requests is a common scenario in enterprise
    web applications.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Angular拦截器有许多用途，其中授权是最基本的之一。在HTTP请求期间传递认证令牌是企业级Web应用程序中的常见场景。
- en: Summary
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Enterprise web applications must exchange information with a backend API almost
    daily. The Angular framework enables applications to communicate with an API over
    HTTP using the Angular HTTP client. In this chapter, we explored the essential
    parts of the Angular HTTP client.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 企业级Web应用程序几乎每天都需要与后端API交换信息。Angular框架使应用程序能够通过Angular HTTP客户端使用HTTP与API进行通信。在本章中，我们探讨了Angular
    HTTP客户端的基本部分。
- en: We learned to move away from the traditional `fetch` API and use observables
    to communicate over HTTP. We explored the basic parts of a CRUD application using
    the Fake Store API as our backend. We investigated how to implement authentication
    and authorization in Angular applications. Finally, we learned what Angular interceptors
    are and how to use them to authorize HTTP calls.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何摆脱传统的`fetch`API，并使用可观察对象通过HTTP进行通信。我们使用Fake Store API作为后端，探讨了CRUD应用程序的基本部分。我们研究了如何在Angular应用程序中实现认证和授权。最后，我们学习了Angular拦截器是什么以及如何使用它们来授权HTTP调用。
- en: Now that we know how to consume data from a backend API in our components, we
    can further improve the user experience of our application. In the next chapter,
    we will learn how to load our components through navigation using the Angular
    router.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何在组件中从后端API获取数据，我们可以进一步改善我们应用程序的用户体验。在下一章中，我们将学习如何使用Angular路由通过导航来加载我们的组件。
