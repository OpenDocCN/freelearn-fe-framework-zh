- en: Chapter 1. Sliding Puzzle
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 滑动拼图
- en: In our first project we'll get to see a variety of techniques in action, in
    a fun and relaxed setting. Consider this a gentle warm up for the rest of the
    book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个项目中，我们将在一个有趣和轻松的环境中看到各种技术的实际运用。把它看作是本书其余部分的轻松热身。
- en: We'll see how to make elements draggable using jQuery UI and how we can configure
    the behavior of the draggable elements. We'll also look at other subjects including
    sorting algorithms, and client-side storage using the localStorage API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何使用jQuery UI使元素可拖动，以及如何配置可拖动元素的行为。我们还将研究其他主题，包括排序算法，以及使用localStorage API进行客户端存储。
- en: Mission Briefing
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务简报
- en: In this project we'll be building a simple but fun puzzle game in which a picture
    is scrambled and has to be unscrambled back to the original picture by sliding
    the different pieces around the board – a modern web-based take on a classic game
    from yesteryear.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将制作一个简单但有趣的拼图游戏，在这个游戏中，一张图片被打乱，必须通过移动板上的不同片段将其复原成原始图片 - 这是对昔日经典游戏的现代基于网络的改编。
- en: Typically there is one blank space on the board and pieces can only be moved
    into this blank space so we will need to build a system that keeps track of where
    the blank space is, and only allows pieces directly adjacent to it to be dragged.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在板上有一个空白空间，片段只能移动到这个空白空间，因此我们需要建立一个跟踪空白空间位置并只允许片段直接相邻的地方被拖动的系统。
- en: 'To give the player an incentive, we can also look at keeping track of how long
    it takes the player to solve the puzzle so that the player''s best time can be
    recorded. The following is a screenshot that shows the final result of this project:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给玩家一些动力，我们还可以看看如何跟踪玩家解决拼图所需的时间，以便记录玩家的最佳时间。以下是显示这个项目的最终结果的屏幕截图：
- en: '![Mission Briefing](img/9106OS_01_02.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![任务简报](img/9106OS_01_02.jpg)'
- en: Why Is It Awesome?
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么它如此棒？
- en: Games are fun and they can keep people coming back to your site, especially
    a younger audience. Non-flash browser-based games are taking off in a big way,
    but getting into the action at the top end of the scale can have a steep learning
    curve.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏很有趣，它可以吸引人们回到您的网站，尤其是年轻的观众。非闪存浏览器游戏以非常大的方式起飞，但是进入顶层行动可能有一个陡峭的学习曲线。
- en: A simple drag-based game like this is the perfect way to ease yourself into
    the gaming market without jumping straight in at the deep end, allowing you to
    hone your skills with some of the simpler concepts of game development.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一个简单的基于拖动的游戏是让你毫不费力地进入游戏市场的完美方式，而不是立即跳入深水区，让您用一些游戏开发的简单概念来磨练您的技能。
- en: This is also a great way to learn how to build a draggable interface in a precise
    and engaging format that is well suited to its intended purpose and intuitive
    to use. We can also look at some more advanced draggable concepts such as collision
    avoidance and precise positioning. We will also be learning how to interact with
    the localStorage API in order to store and retrieve data between sessions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是学习如何构建一个精确而引人入胜的可视化接口的绝佳方式，非常适合其预期目标，并且易于直观使用。我们还可以研究一些更高级的可拖动概念，例如避免碰撞和精确定位。我们还将学习如何使用localStorage
    API与会话之间存储和检索数据。
- en: Your Hotshot Objectives
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的热门目标
- en: 'This project will be broken down into the following tasks, which we''ll work
    through sequentially in order to produce a working end result:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目将被分解成以下任务，我们将按顺序逐步进行工作以产生一个可工作的最终结果：
- en: Laying down the underlying HTML
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布置基础HTML
- en: Creating a code wrapper and defining variables
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建代码包装器并定义变量
- en: Splitting an image into pieces
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图像分割成片段
- en: Shuffling the puzzle pieces
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 洗牌拼图片段
- en: Making the puzzle pieces draggable
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使拼图片段可拖动
- en: Starting and stopping the timer
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动和停止计时器
- en: Determining if the puzzle has been solved
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定拼图是否已解决
- en: Remembering best times and adding some final styling
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住美好时光，并增加一些最终的样式
- en: Mission Checklist
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务检查清单
- en: As well as jQuery, we'll also be using jQuery UI in this project, so now is
    the time to grab these libraries and put them in place. We can also take a moment
    to set up our project folder, which is where we can store all of the files that
    we'll create over the course of the book.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了jQuery，我们还将在这个项目中使用jQuery UI，所以现在是时候获取这些库并将它们放在合适的位置。我们还可以花一点时间来设置我们的项目文件夹，这是我们可以存储在整本书中创建的所有文件的地方。
- en: Create a new folder somewhere called `jquery-hotshots`. Within this folder create
    three new folders called `js`, `css`, and `img`. All the HTML pages we create
    will go into the root `jquery-hotshots` folder, while the other files we use will
    be distributed amongst the subfolders according to their type.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个地方创建一个名为 `jquery-hotshots` 的新文件夹。在此文件夹中创建三个新文件夹，分别命名为 `js`、`css` 和 `img`。我们创建的所有
    HTML 页面都将放在根目录 `jquery-hotshots` 文件夹中，而我们使用的其他文件将根据其类型分布在子文件夹中。
- en: For the projects covered throughout the book we'll use a local copy of the latest
    version of jQuery, which at the time of writing is the brand new 1.9.0\. Download
    a copy of the minified version from [http://code.jquery.com/jquery-1.9.0.min.js](http://code.jquery.com/jquery-1.9.0.min.js)
    and save it in the `js` folder.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中涵盖的项目，我们将使用最新版本的 jQuery 的本地副本，撰写本文时是全新的 1.9.0。从 [http://code.jquery.com/jquery-1.9.0.min.js](http://code.jquery.com/jquery-1.9.0.min.js)
    下载压缩版本的副本并将其保存在 `js` 文件夹中。
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's considered best practice to use Google's **content delivery network** (**CDN**)
    to load jQuery and to link to the file without specifying a protocol. Using a
    CDN means the file is more likely to be in the visitor's browser cache, making
    the library much quicker to load.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Google 的**内容传送网络**（**CDN**）加载 jQuery，并链接到文件而不指定协议被认为是最佳实践。使用 CDN 意味着文件更可能在访问者的浏览器缓存中，使库加载速度更快。
- en: It is also advisable to provide a fallback in the event that the CDN is not
    accessible for some reason. We can very easily use the excellent **yepnope** to
    load a local version of the script if the CDN version is not found. See the yepnope
    site, [http://yepnopejs.com/](http://yepnopejs.com/), for more information on
    this and other resource-loading tips and tricks.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 还建议在某种原因导致 CDN 不可访问时提供一个备用方案。如果未找到 CDN 版本，我们可以非常容易地使用优秀的 **yepnope** 来加载脚本的本地版本。有关此及其他资源加载技巧和技巧的更多信息，请参阅
    yepnope 网站 [http://yepnopejs.com/](http://yepnopejs.com/)。
- en: To download the jQuery UI components we'll require, visit the download builder
    at [http://jqueryui.com/](http://jqueryui.com/). We'll be using various other
    components in later projects, so for simplicity we can just download the complete
    library using the **Stable** button. The current version at the time of writing
    is 1.10.0.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载我们需要的 jQuery UI 组件，请访问下载构建器 [http://jqueryui.com/](http://jqueryui.com/)。我们将在后续项目中使用各种其他组件，所以为了简单起见，我们可以使用
    **Stable** 按钮下载完整库。撰写本文时的当前版本为 1.10.0。
- en: Once the build has been downloaded, you'll need to grab a copy of the `jquery-ui-x.x.x.custom.min.js
    file` (where `x.x.x` is the version number) from the `js` directory inside the
    archive, and paste it into your `js` folder.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，您需要从存档中的 `js` 目录中获取 `jquery-ui-x.x.x.custom.min.js 文件`（其中 `x.x.x` 是版本号），并将其粘贴到您的
    `js` 文件夹中。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Recent versions of jQuery UI, as well as some of the more popular pre-built
    themes generated with Themeroller, are also available via Google's CDN.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最近版本的 jQuery UI，以及一些通过 Themeroller 生成的更受欢迎的预定义主题，也可以通过 Google 的 CDN 获取。
- en: Laying down the underlying HTML
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奠定基础 HTML
- en: First of all we need to build out the page that'll contain our sliding puzzle.
    The initial page will be a shell with mostly just a few containers; the draggable
    elements that will make up the individual pieces of the puzzle can all be created
    dynamically when required.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要构建包含滑动拼图的页面。初始页面将是一个主要只包含几个容器的外壳；当需要时，可以动态创建组成拼图的可拖动元素。
- en: Prepare for Lift Off
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为起飞做准备
- en: 'We''ll use a standard starting point for all of the different projects throughout
    this book, so we''ll look at this briefly now to save showing it in every project:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为本书中的所有不同项目使用标准起点，因此现在简要介绍一下以节省在每个项目中显示它的时间：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 购买的帐户中下载您购买的所有 Packt
    图书的示例代码文件。如果您在其他地方购买了这本书，您可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册，直接将文件发送到您的邮箱。
- en: Each project we cover will be contained in a page that starts out exactly like
    this. Save a copy of the previous file now in your local project folder and call
    it `template.html`. At the start of each project I'll say something like "save
    a copy of the template file as `project-name.html`". This is the file I'll be
    referring to.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所涵盖的每个项目都将包含在一个页面中，该页面的开头与此相同。现在在您的本地项目文件夹中保存上一个文件的副本，并将其命名为`template.html`。在每个项目的开头，我会说类似于"将模板文件另存为`project-name.html`"。这就是我将要引用的文件。
- en: So in this case, save a copy of the previous HTML (or `template.html` if you
    wish) in the main project directory (`jquery-hotshots`) and call it `sliding-puzzle.html`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在主项目目录（`jquery-hotshots`）中保存上一个HTML（或`template.html`，如果您愿意），并将其命名为`sliding-puzzle.html`。
- en: We'll also be using a common style sheet for basic styling that each project
    will utilize. It contains things such as an HTML5 reset, clearfix, and other utilities,
    as well as some basic typographical fixtures and theming for consistency between
    projects. While I won't go into detail on that here, you can take a look at the
    `common.css` source file in the accompanying download of this book for more information.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用一个通用的样式表进行基本样式设置，每个项目都将使用它。它包含诸如HTML5重置、清除浮动和其他实用工具，以及一些基本的排版修复和主题设置，以确保项目之间的一致性。虽然我不会在这里详细介绍它，但你可以查看本书附带下载的`common.css`源文件以获取更多信息。
- en: Each project will also need its own style sheet. These will be covered where
    applicable and will be discussed on a per-project basis as and when required.
    We can create the custom style sheet we'll be using in this project now.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目还将需要自己的样式表。在适当的情况下，这些将会涵盖，并将根据需要按项目讨论。我们现在可以创建这个项目中将使用的自定义样式表。
- en: 'Create a new file and call it `sliding-puzzle.css`, then save it in the `css`
    folder. We can link to this file in the `<head>` of the page using the following
    code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件并将其命名为`sliding-puzzle.css`，然后将其保存在`css`文件夹中。我们可以使用以下代码在页面的`<head>`部分链接到这个文件：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This should appear directly after the `common.css` style sheet reference.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该直接出现在`common.css`样式表引用之后。
- en: 'We can also link to the script files that we''ll be using in this project.
    First, the jQuery UI file we downloaded and copied into the `js` folder can be
    linked to using the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以链接到本项目中将要使用的脚本文件。首先，我们下载并复制到`js`文件夹中的jQuery UI文件可以使用以下代码链接：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Remember to always add the script for jQuery UI on the next line after the script
    for jQuery itself.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在jQuery本身的脚本之后始终添加jQuery UI的脚本。
- en: 'Lastly we can add the script file we''ll use for this project. Create a new
    file and save it as `sliding-puzzle.js` in the `js` folder. We can link to it
    by adding the following `<script>` element directly after the jQuery UI reference:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以添加用于此项目的脚本文件。创建一个新文件并将其保存为`sliding-puzzle.js`，保存在`js`文件夹中。我们可以通过在jQuery
    UI引用之后直接添加以下`<script>`元素来链接到它：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Engage Thrusters
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'Save a copy of the template file as `sliding-puzzle.html` in the root project
    folder and then add the following mark-up to the `<body>` element (before the
    jQuery `<script>` element):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在根项目文件夹中将模板文件另存为`sliding-puzzle.html`，然后将以下标记添加到`<body>`元素中（在jQuery`<script>`元素之前）：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Objective Complete - Mini Debriefing
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小结
- en: This simple HTML is all that's required to start with. As this is a book about
    JavaScript, I won't cover the HTML in much detail unless absolutely critical to
    the project at hand. In this case most of the elements themselves aren't significant.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的HTML就是开始的全部。由于这是一本关于JavaScript的书，我不会详细介绍HTML，除非绝对必要。在这种情况下，大部分元素本身并不重要。
- en: The main thing is that we have a series of containers with `id` attributes that
    make selecting them fast and easy. The only really important element is the `<img>`,
    which displays the original image that we'll be turning into the puzzle.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的是我们有一系列具有`id`属性的容器，这使得选择它们变得快速简便。唯一真正重要的元素是`<img>`，它显示我们将要转换成拼图的原始图像。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The awesome image used in this example was created by the extremely talented
    *Mr. Eamon O'Donoghue*. More examples of his fine work can be seen at [http://eamonart.com/](http://eamonart.com/).
    The image used in this project can be found at [http://eamonart.com/IMAGES/PINUPSLINKS/Space%20Girl%20Vera.html](http://eamonart.com/IMAGES/PINUPSLINKS/Space%20Girl%20Vera.html).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中使用的精彩图像是由极具天赋的*奥登纽·奥达诺休*先生创建的。您可以在[http://eamonart.com/](http://eamonart.com/)上查看更多他精美作品的示例。项目中使用的图像可以在[http://eamonart.com/IMAGES/PINUPSLINKS/Space%20Girl%20Vera.html](http://eamonart.com/IMAGES/PINUPSLINKS/Space%20Girl%20Vera.html)找到。
- en: Creating a code wrapper and defining variables
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建代码包装器和定义变量
- en: All of our code will need to be contained within a wrapper function that is
    executed once the page has finished loading.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的代码都需要包含在一个在页面加载完成后立即执行的包装函数中。
- en: Prepare for Lift Off
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: 'The steps that we''ll complete in this part of the project are as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在项目的这一部分将完成的步骤如下：
- en: Add a wrapper function for our code that will execute as soon as the page has
    finished loading
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的代码添加一个包装函数，该函数将在页面加载完成后立即执行
- en: Define the variables that we'll use throughout the script
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义我们将在整个脚本中使用的变量
- en: Engage Thrusters
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'The first step is to create a wrapper function for our code that will be executed
    as soon as the page has loaded. Add the following code to a new script file called
    `sliding-puzzle.js`, which should be saved in the `js` directory we created earlier:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是为我们的代码创建一个包装函数，该函数将在页面加载完成后立即执行。将以下代码添加到一个名为 `sliding-puzzle.js` 的新脚本文件中，该文件应保存在我们之前创建的
    `js` 目录中：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Most jQuery code that we see in the wild resides within some kind of wrapper
    like this. Using `$(function(){});` is a shortcut to jQuery's `document.ready`
    function, which is fired once the DOM for the page has loaded.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在野外看到的大多数 jQuery 代码都位于某种包装器内。使用 `$(function(){});` 是 jQuery 的 `document.ready`
    函数的快捷方式，该函数在页面的 DOM 加载完成后触发。
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Using $**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 $**'
- en: We wouldn't normally use `$` in the global scope like this if we were sharing
    our code with other developers, as there may be other libraries on the page also
    using it. Best practice is to alias the `$` character within an automatically
    invoked anonymous function, or an immediately invoked function expression if you
    prefer. This can be done using the syntax `(function($) { … }(jQuery));`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们与其他开发人员共享我们的代码，我们通常不会在全局范围内像这样使用 `$`，因为页面上可能还有其他库也在使用它。最佳实践是在自动调用的匿名函数内或者您喜欢的立即调用的函数表达式内将
    `$` 字符别名化。可以使用 `(function($) { … }(jQuery));` 语法来完成此操作。
- en: Next we can set some variables near the top of the script file. This is so that
    we don't have lots of values that we may want to change later distributed throughout
    the file. Organization is one of the keys to writing maintainable code, and we
    should always strive to make our code, as well as our intentions, as clear as
    possible.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在脚本文件的顶部设置一些变量。这样做是为了避免我们希望稍后更改的大量值分布在整个文件中。组织是编写可维护代码的关键之一，我们应该始终努力使我们的代码以及我们的意图尽可能清晰。
- en: 'Next add the following code inside the function we just defined, replacing
    the comment shown in the previous code sample:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们刚刚定义的函数内添加以下代码，替换前一个代码示例中显示的注释：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These aren't all of the variables that we'll use, just the majority of them.
    The list also includes any variables that we'll need to use inside callback functions
    so that we don't run into scope issues.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我们将使用的所有变量，只是其中大部分。列表还包括我们将需要在回调函数中使用的任何变量，以便我们不会遇到作用域问题。
- en: Objective Complete - Mini Debriefing
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成目标 - 迷你总结
- en: The variables we defined first are a combination of simple (primitive) values
    and objects or arrays that we'll use throughout the code, and cached jQuery elements.
    For best performance when using jQuery, it's best to select elements from the
    page and store them in variables instead of repeatedly selecting them from the
    page.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义的变量是简单（原始）值和我们将在整个代码中使用的对象或数组以及缓存的 jQuery 元素的组合。在使用 jQuery 时，为了获得最佳性能，最好从页面中选择元素并将它们存储在变量中，而不是反复从页面中选择它们。
- en: Although none of our variables are directly assigned to `window`, and are therefore
    not actually global, because we are defining them right at the top of our outermost
    function, they will be visible throughout our code and we can consider them as
    global. This gives us the visibility of globals, without actually cluttering the
    global namespace.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的变量都没有直接赋值给`window`，因此实际上不是全局变量，但由于我们将它们定义在最外层函数的顶部，它们将在整个代码中可见，我们可以将它们视为全局变量。这样我们就能获得全局变量的可见性，而不会实际上使全局命名空间混乱。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is best practice to define variables at the top of the function they are
    scoped to because of a phenomenon known as **hoisting**, in which variables defined
    deep inside a function, inside a `for` loop for example, are "hoisted" to the
    top of the function in some situations, potentially causing errors that are hard
    to track down.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是在它们所属的函数顶部定义变量，因为存在一种被称为**提升**的现象，其中在函数内部深处定义的变量，例如在`for`循环内部，有时会在函数顶部“提升”，可能导致难以追踪的错误。
- en: Defining variables at the top of the function where possible is a simple way
    to avoid this occurring and is considered a good practice when writing jQuery,
    or JavaScript in general.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，在函数顶部定义变量是避免此类情况发生的简单方法，在编写jQuery或一般JavaScript时被认为是一种良好的实践。
- en: Most of the variables are quite straightforward. We store the number of puzzle
    pieces we'd like to use and the aspect ratio of the image being used. It's important
    that the number of pieces can be equally divided by both the `width` and `height`
    components of the ratio.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数变量都非常直接。我们存储了我们想要使用的拼图块数以及所使用图像的宽高比。重要的是，拼图块的数量可以被宽度和高度的比率组件等分。
- en: We split the aspect ratio into its component parts using JavaScript's `split()`
    function and specifying the colon as the character to split on. We also use the
    JavaScript `parseInt()` function to ensure we end up with actual numbers and not
    strings in the `aspectW` and `aspectH` variables.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用JavaScript的`split()`函数将宽高比拆分为其组成部分，并指定冒号作为拆分字符。我们还使用JavaScript的`parseInt()`函数确保我们最终得到的是实际数字而不是字符串，存在`aspectW`和`aspectH`变量中。
- en: The next three variables are all different elements selected from the page that
    we need to manipulate. Following this is a new element that we create using jQuery.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三个变量都是我们需要操作的页面中选择的不同元素。随后是使用jQuery创建的新元素。
- en: Next we calculate the `width` and `height` each piece of the puzzle will need
    to be sized to, based on the `width` and `height` of the original image and the
    aspect ratio, and we initialize a counter variable that we'll use to add a unique,
    ordered `id` attribute to each puzzle piece. We also add an empty array called
    `positions`, which we'll use to store the `top` and `left` positions of each new
    piece.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们根据原始图像的宽度和高度以及宽高比计算每个拼图块需要调整大小的`width`和`height`，并初始化一个计数器变量，我们将使用它向每个拼图块添加一个唯一的、有序的`id`属性。我们还添加了一个名为`positions`的空数组，我们将用它来存储每个新块的`top`和`left`位置。
- en: We'll need a way of keeping track of the empty space as the pieces are moved
    around the board, so we create an object called `empty` and give it `top`, `left`,
    `bottom`, and `right` properties so that we'll know exactly where the blank is
    space at any given moment. We'll also want to keep track of the previous location
    of any given piece so we create an empty object called `previous` that we'll populate
    with properties when required.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当拼图块在板上移动时，我们需要一种方法来跟踪空白空间，因此我们创建了一个名为`empty`的对象，并赋予它`top`、`left`、`bottom`和`right`属性，以便我们随时知道空白位置在哪里。我们还希望跟踪任何给定块的上一个位置，因此我们创建了一个名为`previous`的空对象，我们将在需要时填充它的属性。
- en: The remaining three variables are all concerned with keeping track of the time
    it takes to solve the puzzle. We defined, but didn't initialize the `timer` variable
    that we'll use to store a reference to a JavaScript `setInterval()`-based timer
    later in the script. We also created an empty object called `currentTime`, which
    again we'll populate when required, and cached a reference to the element that
    we'll use to display the current time.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的三个变量都与跟踪解决拼图所需的时间有关。我们定义了但没有初始化`timer`变量，稍后在脚本中将使用它来存储对JavaScript `setInterval()`-based定时器的引用。我们还创建了一个名为`currentTime`的空对象，当需要时会再次填充它，并缓存了一个引用，我们将用它来显示当前时间的元素。
- en: Splitting an image into pieces
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将图像拆分为块
- en: Our next task is to divide the image into a specified number of squares to represent
    the individual pieces of the puzzle. To do this we'll create a series of smaller
    elements which each show a different part of the image and which can be manipulated
    individually.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个任务是将图像分割成指定数量的方块，以表示拼图的各个部分。为此，我们将创建一系列较小的元素，每个元素显示图像的不同部分，并可以单独操作。
- en: Prepare for Lift Off
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: The single step required to complete this task is to create a specified number
    of puzzle pieces and give each a unique background-position and position in order
    to recreate the image.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此任务所需的单个步骤是创建指定数量的拼图块，并为每个拼图块设置唯一的背景位置和位置，以重新创建图像。
- en: Engage Thrusters
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'We now want to generate the different pieces that make up the puzzle. We can
    do this with the following code, which should be added directly after the variables
    we just defined in `sliding-puzzle.js`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想要生成组成拼图的不同部分。我们可以使用以下代码来完成这个任务，这段代码应该直接添加在我们刚刚在 `sliding-puzzle.js` 中定义的变量之后：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Objective Complete - Mini Debriefing
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小结
- en: We used a nested set of `for` loops to create the new puzzle pieces in a grid
    pattern. The first loop will run for as many rows as required; with a 3:4 aspect-ratio
    image such as that used in this example, we will need four rows of squares. The
    inner loop will for run for as many columns as required, which in this case is
    three.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用嵌套的 `for` 循环来以网格模式创建新的拼图块。第一个循环将根据需要运行多少行；对于像本示例中使用的 3:4 宽高比图像，我们将需要四行方块。内部循环将根据需要运行多少列，本例中是三列。
- en: Within the inner loop we first create two new variables `top` and `left`. We
    need to use these values in a couple of places so it makes sense to create them
    once and reuse them each time they're required.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部循环中，我们首先创建两个新变量 `top` 和 `left`。我们需要在几个地方使用这些值，因此一次创建并在每次需要时重用它们是有意义的。
- en: The `top` position is equal to the `height` of the piece multiplied by the current
    value of the outer loop's counter variable (`x`), while the `left` position is
    equal to the `width` of the piece multiplied by the current value of the inner
    loop's counter variable (`a`). These variables are used to make the puzzle pieces
    line up in a grid.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`top` 位置等于外部循环的计数变量（`x`）的当前值乘以拼图块的 `height`，而 `left` 位置等于内部循环的计数变量（`a`）的当前值乘以拼图块的
    `width`。这些变量用于使拼图块在网格中排列。'
- en: We then copy our stored `<div>` element using jQuery's `clone()` method and
    use the `attr()` method to set a unique `id` attribute using the `idCounter` variable
    that we initialized in the first part of the project. Notice that we increment
    the variable at the same time as setting it directly within the `attr()` method.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 jQuery 的 `clone()` 方法复制我们存储的 `<div>` 元素，并使用 `attr()` 方法使用我们在项目的第一部分初始化的
    `idCounter` 变量设置一个唯一的 `id` 属性。请注意，我们同时在 `attr()` 方法中设置变量并递增变量。
- en: We could increment the variable either inside the method as we have done here,
    or outside of the method; there's no real difference in performance or anything
    else. I just feel that it's more succinct to update it in situ.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样在方法内部递增变量，也可以在方法外部递增变量；在性能或其他方面没有真正区别。我只是觉得在原地更新更简洁。
- en: Next we use the `css()` method to set a `style` attribute on the new element.
    We set the `width` and `height` of the puzzle piece and position it using our
    `top` and `left` variables, as well as set its `backgroundImage` and `backgroundPosition`
    style properties.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `css()` 方法在新元素上设置一个 `style` 属性。我们设置拼图块的 `width` 和 `height` 并使用我们的 `top`
    和 `left` 变量定位它，以及设置其 `backgroundImage` 和 `backgroundPosition` 样式属性。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Any style properties that are usually defined using hyphenated words, such as
    `background-image`, should be camel-cased when used with jQuery's `css()` method
    in conjunction with an object.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用连字符单词定义的任何样式属性，例如 `background-image`，在与 jQuery 的 `css()` 方法一起使用对象时，应该使用驼峰命名法。
- en: The `backgroundImage` property can be set using our `path` variable and the
    rest of the string components of the style, but the `backgroundPosition` property
    will need to be calculated individually for each puzzle piece.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`backgroundImage` 属性可以使用我们的 `path` 变量和样式的其余字符串组件设置，但是 `backgroundPosition`
    属性需要为每个拼图块单独计算。'
- en: The horizontal component of the `backgroundPosition` style property is equal
    to the `width` of the piece multiplied by the value of the inner loop's counter
    variable (`a`), while the vertical component is equal to the `height` of the piece
    multiplied by the value of the outer loop's counter variable (`x`).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`backgroundPosition`样式属性的水平分量等于`width`乘以内部循环计数变量（`a`）的值，而垂直分量等于`height`乘以外部循环计数变量（`x`）的值。'
- en: Once the new element has been created we can add its position to our `positions`
    array using JavaScript's `push()` method, passing in an object containing the
    `top` and `left` positional properties of the element for later use.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦新元素被创建，我们可以使用JavaScript的`push()`方法将其位置添加到我们的`positions`数组中，传递一个包含元素的`top`和`left`位置属性的对象，以供以后使用。
- en: Classified Intel
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机密情报
- en: Instead of using standard string concatenation to construct the `backgroundImage`
    and `backgroundPosition` strings, we put the values into an array literal and
    then joined the array using JavaScript's `join()` method. By specifying an empty
    string as the value to use to join the string, we ensure that no additional characters
    are added to the string.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再使用标准的字符串连接来构造`backgroundImage`和`backgroundPosition`字符串，而是将值放入数组文字中，然后使用JavaScript的`join()`方法将数组连接起来。通过指定一个空字符串作为用于连接字符串的值，我们确保不会向字符串添加任何附加字符。
- en: Joining an array of substrings to form a single string is much faster than building
    a string using the `+` operator on substrings, and as we're working repetitively
    inside a loop, we should optimize the code within the loop as much as possible.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个子字符串数组连接成一个单一字符串比使用`+`运算符在子字符串上构建字符串要快得多，并且由于我们在循环内部重复工作，我们应尽可能优化循环内的代码。
- en: Shuffling the puzzle pieces
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 洗牌拼图块
- en: In this step we need to randomly shuffle the pieces to make it a puzzle so that
    the visitor can unscramble them. We can also remove the original image as it's
    no longer required, and remove the first piece to create an empty space so that
    the other pieces can be moved around.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在此步骤中，我们需要随机洗牌拼图块，使其成为一个谜题，以便访问者可以重新排列它们。我们还可以删除原始图像，因为它不再需要，并删除第一个拼图块以创建一个空白空间，以便其他拼图块可以移动。
- en: Prepare for Lift Off
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备升空
- en: 'The steps we''ll cover in this task are:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本任务中将涵盖的步骤是：
- en: Removing the original image from the page
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从页面中删除原始图像
- en: Removing the first piece of the puzzle
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除拼图的第一个块
- en: Removing the first item in the positions array
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从位置数组中删除第一个项目
- en: Shuffling the pieces randomly
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机洗牌拼图块
- en: Engage Thrusters
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'Completing the first step requires just the following line of code, which should
    be added directly after the closing curly-bracket of the outer `for` loop we added
    to `sliding-puzzle.js` in the last task:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 完成第一步仅需要添加以下代码行，应直接添加到上一任务中我们在`sliding-puzzle.js`中添加的外部`for`循环的结束大括号之后：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The second step is equally as simple; the following can be added directly after
    the previous line of code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步同样简单；以下内容可以直接添加到上一行代码之后：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can also use a single line of code for the next step. Add the following
    directly after the previous line of code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还可以为下一步使用一行代码。将以下内容直接添加到上一行代码之后： '
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Shuffling the pieces will be slightly more complex; you''ll remember from the
    first part of the project when we added the underlying HTML that one of the elements
    was a start button. We''ll use this button to trigger the shuffle. Add the following
    code directly after the first two lines we just added (make sure they are still
    within the outer function wrapper):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 洗牌拼图块将稍微复杂一些；您会记得项目的第一部分中我们添加基础HTML时其中一个元素是一个开始按钮。我们将使用此按钮来触发洗牌。将以下代码直接添加到我们刚刚添加的前两行代码之后（确保它们仍然在外部函数包装器内）：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Objective Complete - Mini Debriefing
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 迷你总结
- en: jQuery's `remove()` method is used to remove the original image element from
    the page, which we already selected when we declared our variables at the start
    of the script. We use the same method to remove the first puzzle piece, which
    we should do *before* the pieces are shuffled to avoid removing a key piece, such
    as a face. As with the image used in this example, an image where the main item
    of interest is not in the top-left corner is beneficial.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery的`remove()`方法用于从页面中删除原始图像元素，这些元素在脚本开头声明变量时已经选择了。我们使用相同的方法来删除第一个拼图块，我们应该在拼图块被洗牌之前*之前*这样做，以避免删除关键部件，例如脸部。与此示例中使用的图像一样，其中感兴趣的主要项目不在左上角的图像是有益的。
- en: As we've removed the first piece from the board, we should also remove the first
    item in the `positions` array. We'll use this array when we come to check whether
    the puzzle has been unscrambled and as there won't be a piece at the first position,
    we don't need to store its position. We use JavaScript's `unshift()` method to
    do this, which simply removes the first item in the array it is called on.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从面板上移除了第一块拼图，因此我们也应该移除`positions`数组中的第一项。当我们来检查拼图是否已经还原时，我们将使用这个数组，由于第一个位置上没有拼图块，我们不需要存储它的位置。我们使用JavaScript的`unshift()`方法来实现这一点，它简单地移除调用它的数组中的第一个项目。
- en: Adding an event handler to the button using on()
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用on()为按钮添加事件处理程序
- en: We added a click event handler for the button by selecting it and calling the
    jQuery `on()` method. The `on()` method takes two arguments in this example (although
    it can take three when event delegation is required).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过选择按钮并调用jQuery的`on()`方法为按钮添加了点击事件处理程序。在这个例子中，`on()`方法接受两个参数（尽管在需要事件委托时它可以接受三个参数）。
- en: The first argument is the event to listen for and the second is the handler
    function to be executed each time the event is detected. We are listening for
    the `click` event in this case.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是要监听的事件，第二个参数是每次检测到事件时要执行的处理程序函数。在这种情况下，我们正在监听`click`事件。
- en: Tip
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**The all-encompassing on() method**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**全能的on()方法**'
- en: jQuery's `on()` method, introduced in version 1.7, replaces the `bind()`, `live()`,
    and `delegate()` methods, which are now deprecated. Using `on()` is now the recommended
    way of attaching event handlers in jQuery.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery的`on()`方法，自1.7版本引入，取代了现已废弃的`bind()`、`live()`和`delegate()`方法。现在使用`on()`是jQuery中附加事件处理程序的推荐方法。
- en: Within the handler function we first define a variable which stores the children
    of the `<figure>` element. Although we need to select the pieces from the page
    again, we can still use our cached `imgContainer` variable to avoid creating a
    new jQuery object.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理程序函数内部，我们首先定义一个变量，它存储了`<figure>`元素的子元素。虽然我们需要再次从页面中选择拼图块，但我们仍然可以使用我们缓存的`imgContainer`变量来避免创建新的jQuery对象。
- en: Shuffling the pieces
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 洗牌拼图块
- en: Next we define a function called `shuffle()`, which accepts the array to shuffle
    as an argument. This function performs a **Fisher-Yates** shuffle, which is an
    established pattern for creating a random ordering of a given set of values.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们定义了一个名为`shuffle()`的函数，它接受要洗牌的数组作为参数。这个函数执行了一个**Fisher-Yates**洗牌算法，这是一个创建给定值的随机排序的已知模式。
- en: Within the function, we first get the length of the array that was passed in,
    and return `false` (exiting the function) if the array is empty. We then use a
    `while` loop to cycle through the array. A `while` loop in JavaScript is similar
    to a `for` loop but executes while the condition specified in brackets has a truthy
    value (or while it evaluates to true), instead of executing a specified number
    of times. A pre-decrementing loop condition is used to avoid an unnecessary iteration
    of the loop once the items have all been shuffled.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们首先获取传入的数组的长度，如果数组为空，则返回`false`（退出函数）。然后，我们使用`while`循环遍历数组。在JavaScript中，`while`循环类似于`for`循环，但是当括号中指定的条件具有`truthy`值（或者评估为`true`）时执行，而不是执行指定次数的循环。使用预减量循环条件是为了避免在所有项都被洗牌后不必要地迭代循环。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In JavaScript, as well as the `true` or `false` Boolean values, other types
    of variables can be said to be `truthy` or `falsey`. The following values are
    all considered falsey:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，除了`true`或`false`布尔值之外，其他类型的变量也可以被称为`truthy`或`falsey`。以下值都被认为是`falsey`：
- en: The Boolean value `false`
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值`false`
- en: The number `0`
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字`0`
- en: An empty string
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空字符串
- en: '`null`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`'
- en: '`undefined`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`'
- en: '`NaN`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NaN`'
- en: All other values are considered truthy. This is so that non-Boolean values can
    be used as conditionals. The similarities between the terms falsey and false may
    lead to confusion; just remember that false is an actual value, and falsey is
    an aspect of a value, which values other than false also have.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他值都被认为是`truthy`。这样可以使非布尔值用作条件。falsey和false之间的相似性可能会导致混淆；只需记住false是一个实际的值，而falsey是一个值的一个方面，除了false还有其他值也具有。
- en: For more information on this subject, see [http://james.padolsey.com/javascript/truthy-falsey/](http://james.padolsey.com/javascript/truthy-falsey/).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此主题的更多信息，请参见[http://james.padolsey.com/javascript/truthy-falsey/](http://james.padolsey.com/javascript/truthy-falsey/)。
- en: Within the loop, which will be executed once for each item in the array except
    the first item, we want to pick a random item from the array and swap its position
    in the array with another item. To generate a random number to use as the index
    of the item to swap, we first generate a random number using JavaScript's `Math.random()`
    function and multiply the random number (which will be between `0` and `1`) by
    the length of the array plus `1`. This will give us a random number, between `0`
    and the length of the array.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内，对数组中的每个项（除第一个项外）进行随机选择，并与数组中的另一项交换位置。为了生成用作要交换的项的索引的随机数，我们首先使用JavaScript的`Math.random()`函数生成一个随机数，把得到的随机数（在`0`和`1`之间）乘以数组的长度加`1`。这将给我们一个在`0`和数组长度之间的随机数。
- en: We then pull the item with the current index out of the array, along with the
    item at the randomly generated index, and swap them. It may seem complex but this
    is almost universally regarded as the most efficient way to randomly shuffle the
    items in the array. It gives us the most random result for the least amount of
    processing.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从数组中取出当前索引的项，以及随机生成的索引处的项，并交换它们的位置。这可能看起来很复杂，但这几乎被普遍认为是随机洗牌数组中项的最有效方式。它给了我们最随机的结果，处理的工作量最少。
- en: Once we have defined the function, we then invoke it, passing in the `pieces`
    array as the array to shuffle.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了函数，我们就会调用它，将`pieces`数组作为要洗牌的数组传递进去。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the JavaScript implementation of the Fisher-Yates shuffle,
    see [http://sedition.com/perl/javascript-fy.html](http://sedition.com/perl/javascript-fy.html).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Fisher-Yates乱序的JavaScript实现的更多信息，请参阅[http://sedition.com/perl/javascript-fy.html](http://sedition.com/perl/javascript-fy.html)。
- en: Positioning the pieces
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定位元素
- en: Once the array of elements has been shuffled, we iterate it using jQuery's `each()`
    method. This method is passed the array to iterate over, which in this case is
    the `pieces` array we have just shuffled. The second argument is an iterator function
    that will be called for each item in the array.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 完成元素数组的洗牌后，我们使用jQuery的`each()`方法对其进行迭代。此方法传递了要迭代的数组，在这种情况下是刚刚洗牌的`pieces`数组。第二个参数是一个迭代器函数，将对数组中的每个项进行调用。
- en: Within this function we use our `positions` array to put the shuffled elements
    in the right place on the page. If we didn't do this, the elements would be shuffled,
    but would still appear in the same place on the page because of their `absolute`
    positioning. We can use the `positions` array that we updated when creating the
    new elements to get the correct `top` and `left` positions for each of the shuffled
    elements.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们使用我们的`positions`数组将洗牌后的元素放在页面的正确位置。如果我们不这样做，元素将被洗牌，但因为它们的`absolute`定位，它们仍会出现在页面的同一位置。我们可以使用在创建新元素时更新的`positions`数组来获得每个洗牌元素的正确`top`和`left`位置。
- en: Once the collection of elements have been iterated and their positions set,
    we then append them back to the page using jQuery's `appendTo()` method. Again
    we can specify our `imgContainer` variable as the argument to `appendTo()` in
    order to avoid selecting the container from the page once more.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦元素集合被迭代并设置了它们的位置，我们就可以使用jQuery的`appendTo()`方法把它们再次附加到页面上。同样，我们可以把我们的`imgContainer`变量作为`appendTo()`的参数，以避免再次从页面选择容器。
- en: Positioning the empty space
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定位空白空间
- en: Lastly we should make sure that the empty space is definitely at `0` top and
    `0` left, that is the top-left square of the board. If the button is clicked,
    some pieces are moved and then the button is clicked again, we have to ensure
    that the empty space is in the right place. We do this by setting both the `top`
    and `left` properties of the `empty` object to `0`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该确保空白空间确实位于板的顶部和左边的`0`位置。如果点击了按钮，移动了一些方块，然后再次点击按钮，我们必须确保空白空间在正确的位置。我们通过将`empty`对象的`top`和`left`属性都设置为`0`来实现这一点。
- en: We can also remove any previous messages that may be displayed in the UI area
    (we'll cover adding these messages towards the end of this project). We don't
    want to remove the timer though, so we filter this element out of the selection
    using jQuery's `not()` method, which accepts a selector for which matching elements
    are discarded and therefore not removed from the page.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以删除显示在UI区域的任何先前消息（我们将在项目的最后部分涵盖添加这些消息）。但我们不想删除计时器，所以我们使用jQuery的`not()`方法来过滤出当前元素，该方法接受一个选择器，匹配的元素被丢弃，因此不会从页面中删除。
- en: 'At this point we should be able to run the page in a browser and shuffle the
    pieces by clicking on the **Start!** button:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们应该能够在浏览器中运行页面，并通过点击**开始！**按钮来打乱拼图块：
- en: '![Positioning the empty space](img/9106OS_01_01.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![定位空白区域](img/9106OS_01_01.jpg)'
- en: Making the puzzle pieces draggable
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使拼图块可拖动
- en: Now it's time to kickstart jQuery UI to make the individual pieces of the puzzle
    draggable.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候启动jQuery UI，使拼图的各个部分可拖动了。
- en: jQuery UI is a suite of jQuery plugins used to build interactive and efficient
    user interfaces. It is stable, mature, and is recognized as the official, although
    not the only UI library for jQuery.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery UI是一套用于构建交互式和高效用户界面的jQuery插件。它稳定、成熟，并被公认为是jQuery的官方UI库，尽管不是唯一的。
- en: Prepare for Lift Off
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: 'In this task we''ll cover the following steps:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在此任务中，我们将涵盖以下步骤：
- en: Making the puzzle pieces draggable using jQuery UI's Draggable component
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用jQuery UI的可拖动组件使拼图块可拖动
- en: Configuring the draggables so that only pieces directly next to the empty space
    can be moved
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置可拖动的元素，以便只有直接相邻空白区域的块可以移动
- en: Configuring the draggables so that pieces can only be moved into the empty space
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置可拖动的元素，以便块只能移动到空白区域
- en: Engage Thrusters
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'First we''ll make the pieces draggable and set some of the configuration options
    that the component exposes. This code should be added to `sliding-puzzle.js`,
    directly after the code added in the previous task:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使拼图块可拖动，并设置一些组件公开的配置选项。此代码应添加到上一个任务中添加的代码之后的`sliding-puzzle.js`中：
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The next few steps in this task will see additional code added to the `start`,
    `drag`, and `stop` callback functions in the previous code sample.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在此任务的接下来几个步骤中，将在上一个代码示例的`start`、`drag`和`stop`回调函数中添加额外的代码。
- en: We also need to configure the draggability so that the pieces can only be moved
    into the empty space, and not over each other, and so that only pieces directly
    adjacent to the empty space can be moved at all.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要配置可拖动性，以便块只能移动到空白区域，而不是在彼此之间移动，并且只有直接相邻空白区域的块才能被移动。
- en: 'Next add the following code in to the `start` callback function that we just
    added:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将以下代码添加到我们刚刚添加的`start`回调函数中：
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, add the following code to the `drag` callback function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下代码添加到`drag`回调函数中：
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we should add the following code to the `stop` callback function:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该将以下代码添加到`stop`回调函数中：
- en: '[PRE15]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In each of our callbacks we''ve used a helper function that returns the exact
    position of the current draggable. We should also add this function after the
    `draggable()`method:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的每个回调函数中，我们使用了一个辅助函数，返回当前可拖动元素的确切位置。我们还应该在`draggable()`方法之后添加此函数：
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Objective Complete - Mini Debriefing
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小结
- en: We wrote a lot of code in that last task, so let's break it down and see what
    we did. We started by making the pieces draggable using the jQuery UI draggable
    component. We did this by calling the `draggable()` method, passing in an object
    literal that sets various options that the draggable component exposes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个任务中写了很多代码，让我们来分解并看看我们做了什么。我们首先通过使用jQuery UI的可拖动组件使块可拖动。我们通过调用`draggable()`方法来实现这一点，传入一个对象字面量，设置可拖动组件公开的各种选项。
- en: First we set the `containment` option to `parent`, which stops any of the pieces
    being dragged out of the `<figure>` element that they are within. We also set
    the `grid` option, which allows us to specify a grid of points that the piece
    being dragged should snap to. We set an array as the value of this option.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`containment`选项设置为`parent`，这样可以阻止任何拼图块被拖出它们所在的`<figure>`元素。我们还设置了`grid`选项，允许我们指定拼图块应该捕捉到的点的网格。我们将数组设置为此选项的值。
- en: The first item in this array sets the horizontal points on the grid and the
    second item sets the vertical points on the grid. Setting these options gives
    the movement of the pieces a more realistic and tactile experience.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此数组中的第一项设置了网格的水平点，第二项设置了网格的垂直点。设置这些选项使块的移动更具真实感和触觉体验。
- en: The next and final three options that we set are actually callback functions
    that are invoked at different points in the life-cycle of a drag. We use the `start`,
    `drag`, and `stop` callbacks.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们设置的最后三个选项实际上是回调函数，在拖动的生命周期的不同点被调用。我们使用`start`、`drag`和`stop`回调。
- en: When the drag begins
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当拖动开始时
- en: The `start` callback will be invoked once at the very start of the drag interaction
    following a `mousedown` event on a draggable. The `stop` callback will be invoked
    once at the very end of a drag interaction, once a `mouseup` event has registered.
    The `drag` callback will fire almost continuously while a piece is being dragged
    as it is invoked for every pixel the dragged element moves.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`回调将在可拖动对象上的`mousedown`事件后的拖动交互的最开始触发一次。`stop`回调将在拖动交互的最后，即`mouseup`事件注册后触发一次。`drag`回调几乎在被拖动元素每移动一个像素时都会连续触发，因为它被用于每次拖动元素移动时都调用。'
- en: Let's look at the `start` callback first. Each callback is passed two arguments
    by jQuery UI when it is invoked. The first of these is the event object, which
    we don't require in this project, while the second is an object containing useful
    properties about the current draggable.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下`start`回调。每个回调在被调用时由jQuery UI传递两个参数。其中之一是事件对象，在这个项目中我们不需要，而第二个是一个包含有关当前可拖动对象的有用属性的对象。
- en: At the beginning of the function we first get the exact position of the piece
    that dragging has started on. When we call our `getPosition()` function, we pass
    in the `helper` property of the `ui` object, which is a jQuery-wrapped reference
    to the underlying DOM element that has started to be dragged.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数开始时，我们首先获取拖动开始的块的确切位置。当我们调用我们的`getPosition()`函数时，我们传入`ui`对象的`helper`属性，它是对已开始被拖动的基础DOM元素的jQuery封装引用。
- en: Once we have the element's position, we first check whether the element is in
    the same row as the empty space by comparing the `left` property of the current
    object (the object returned by `getPosition()`) with the `left` property of the
    `empty` object.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了元素的位置，我们首先检查元素是否与空白空间在同一行，方法是将当前对象（由`getPosition()`返回的对象）的`left`属性与`empty`对象的`left`属性进行比较。
- en: If the two properties are equal, we set the `axis` option of the draggable to
    `y` so that it can only move horizontally. Configuration options can be set in
    any jQuery UI widget or component using the `option` method.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个属性相等，则将可拖动对象的`axis`选项设置为`y`，以便它只能水平移动。可以使用`option`方法在任何jQuery UI小部件或组件中设置配置选项。
- en: If it isn't in the same row, we check whether it is in the same column instead
    by comparing the `top` properties of the `current` and `empty` objects. If these
    two properties are equal, we instead set the `axis` option to `x` so that the
    piece may only move vertically.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它不在同一行，则通过比较`current`和`empty`对象的`top`属性来检查它是否在同一列。如果这两个属性相等，则我们将`axis`选项设置为`x`，以便块只能垂直移动。
- en: If neither of these conditions is true, the piece cannot be adjacent to the
    empty space, so we manually trigger a `mouseup` event to stop the drag using jQuery's
    `trigger()` method, and also return `false` from the function so that our `stop`
    handler is not triggered.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些条件都不为真，则该块不能与空白空间相邻，因此我们使用jQuery的`trigger()`方法手动触发`mouseup`事件来停止拖动，并从函数中返回`false`，以便我们的`stop`处理程序不会被触发。
- en: We need to make sure that only squares in the same row or column as the empty
    space are draggable, but we also need to make sure that any pieces that are not
    directly adjacent to the empty space cannot be dragged either.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保只有与空白空间在同一行或同一列的方块可以被拖动，但我们还需要确保任何不直接与空白空间相邻的方块也不能被拖动。
- en: 'To stop any pieces not adjacent to the empty space being dragged, we just check
    that:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阻止非邻近空白空间的块被拖动，我们只需检查：
- en: The *bottom* of the current piece is *less* than the *top* of the empty space
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前块的*下边*小于空白空间的*上边*
- en: The *top* of the current piece is *greater* than the *bottom* of the empty space
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前块的*上边*大于空白空间的*下边*
- en: The *left* of the current piece is *greater* than the *right* of the empty space
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前块的*左边*大于空白空间的*右边*
- en: The *right* of the current piece is *less* than the *left* of the empty space
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前块的*右边*小于空白空间的*左边*
- en: If any of these conditions are true, we again stop the drag by triggering a
    `mouseup` event manually, and stop any further event handlers on the draggable
    being called (but only for the current drag interaction) by returning `false`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些条件中的任何一个为真，我们再次通过手动触发`mouseup`事件停止拖动，并通过返回`false`来停止调用拖动对象上的任何进一步事件处理程序（但仅限于当前拖动交互）。
- en: If the callback function has not returned at this point, we know we are dealing
    with a draggable that is adjacent to the empty space, thereby constituting a valid
    drag object. We therefore store its current position at the start of the drag
    for later use by setting the `top` and `left` properties of the `previous` object
    that we initialized at the start of the project.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果回调函数在这一点没有返回，我们就知道我们正在处理一个与空白空间相邻的可拖动对象，因此我们通过在项目开始时初始化的`previous`对象的`top`和`left`属性来存储它当前的位置，以便以后使用。
- en: Tip
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**The position of ui.helper**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**ui.helper的位置**'
- en: The `ui` object passed to our callback function actually contains an object
    called `position`, which can be used to obtain the current draggable's position.
    However, because we are using the `grid` option, the values contained in this
    object may not be granular enough for our needs.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给我们回调函数的`ui`对象实际上包含一个称为`position`的对象，它可以用于获取当前可拖动物体的位置。然而，由于我们使用了`grid`选项，此对象中包含的值可能对我们的需求不够精细。
- en: During the drag
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在拖动期间
- en: Next we can walk through the `drag` callback, which will be called every time
    the position of the current draggable changes. This will occur during a `mousedown`
    event.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以走一遍`drag`回调，这将在每次当前可拖动物体的位置改变时调用。这将发生在`mousedown`事件期间。
- en: First of all we need to know where the piece that's being dragged is, so we
    call our `getPosition()` helper function again.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要知道被拖动的拼图在哪里，所以我们再次调用我们的`getPosition()`辅助函数。
- en: Then we want to check whether the piece being dragged is in the empty space.
    If it is, we can stop the drag in the same way that we did before – by manually
    triggering a `mouseup` event and returning `false`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们想要检查被拖动的拼图是否在空白空间中。如果是，我们可以像之前一样停止拖动-手动触发`mouseup`事件并返回`false`。
- en: During the drag, only valid pieces will be draggable because we've already filtered
    out any pieces that are not directly adjacent to the empty space. However, we
    still need to check that the piece being dragged is not being dragged away from
    the empty space. We do this in the same way that we filtered out pieces not adjacent
    to the empty space in the `start` callback.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在拖动过程中，只有有效的拼图才能被拖动，因为我们已经筛选掉了与空白空间不直接相邻的拼图。然而，我们还需要检查被拖动的拼图是否正在远离空白空间。我们可以在`start`回调中筛选出与空白空间不直接相邻的拼图的方式进行检查。
- en: When the drag ends
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拖动结束时
- en: The `stop` callback is the simplest of the three callbacks. We get the position
    of the piece that was dragged, and if it's definitely in the empty space, we move
    the empty space so that it is in the position the dragged piece was in when the
    drag began. Remember we stored this information in an object called `previous`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`stop`回调是三个回调中最简单的。我们获取被拖动的拼图的位置，如果它确实在空白空间中，我们就把空白空间移到拖动时它所在的位置。记住，我们把这些信息存储在一个叫`previous`的对象中。'
- en: Starting and stopping the timer
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动和停止计时器
- en: At this point, our game is fully functional and the puzzle can be unscrambled;
    however to make it more fun we should introduce an element of competitiveness
    by incorporating a timer.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的游戏已经功能完善，拼图也可以被拼好了；但是为了增加乐趣，我们应该通过引入计时器来增加竞争元素。
- en: Prepare for Lift Off
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为起飞做准备
- en: 'In this task we''ll need to complete the following steps:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们需要完成以下步骤：
- en: Check the timer isn't already running when the **Start** button is clicked
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查是否在单击**开始**按钮时计时器已经在运行
- en: Start the timer from `0`
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`0`开始计时
- en: Increment the timer every second
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每秒增加一次计时器
- en: Update the display on the page so that the player can see how long the current
    game has taken so far
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在页面上更新显示，以便玩家可以看到当前游戏已经进行了多长时间
- en: Engage Thrusters
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'To check whether the timer is already running when the **Start** button is
    clicked we should add the following code directly after where we appended the
    shuffled pieces to the page, and directly before the call to `draggable()`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查在单击**开始**按钮时计时器是否已经在运行，我们应该在将洗牌后的拼图追加到页面之后直接添加以下代码，并紧接着调用`draggable()`之前：
- en: '[PRE17]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next we can add the function that increments the timer and updates the display.
    This code should come directly after where we update `currentTime.hours` in the
    previous code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以添加一个增加计时器并更新显示的函数。这段代码应该直接放在我们在前面更新`currentTime.hours`的代码之后：
- en: '[PRE18]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Objective Complete - Mini Debriefing
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成-小结报告
- en: The first thing we have to do in this task is check whether a timer is already
    running. The timer will be stored in one of our "global" variables so we can check
    it easily. We use an `if` statement to check whether `timer` contains a truthy
    value (see the previous information on JavaScript's truthy and falsey values).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在此任务中，我们首先要做的是检查定时器是否已经在运行。定时器将存储在我们的一个“全局”变量中，因此我们可以轻松地检查它。我们使用`if`语句来检查`timer`是否包含真值（请参阅有关JavaScript的真值和虚值的先前信息）。
- en: If it does, we know the timer is already running, so we cancel the timer using
    JavaScript's `clearInterval()` function, passing in our `timer` variable as the
    timer to clear. We can also reset the timer display if the timer is already running.
    We selected the timer display element from the page and cached it when we initially
    declared our variables at the start of this project.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有的话，我们知道定时器已经在运行，因此我们使用JavaScript的`clearInterval()`函数取消定时器，将我们的`timer`变量作为要清除的定时器传入。如果定时器已经在运行，我们还可以重置定时器显示。在项目开始时，我们从页面中选择了定时器显示元素，并在最初声明变量时对其进行了缓存。
- en: Next we start the timer using JavaScript's `setInterval()` method and assign
    it to our `timer` variable. When the timer begins this variable will contain the
    ID of the timer, not the value of the timer, which is how `clearInterval()` knows
    which timer to clear.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用JavaScript的`setInterval()`方法启动定时器，并将其分配给我们的`timer`变量。当定时器开始时，此变量将包含定时器的ID，而不是定时器的值，这就是`clearInterval()`知道要清除哪个定时器的方式。
- en: The `setInterval()` function accepts a function to execute after the specified
    interval as the first argument, and the interval as the second argument. We specify
    `1000` milliseconds as the interval, which is equal to 1 second, so the function
    passed as the first argument will be called every second until the timer is cleared.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`setInterval()`函数接受一个要在指定间隔后执行的函数作为第一个参数，间隔作为第二个参数。我们将间隔指定为`1000`毫秒，等于1秒，因此将每秒调用作为第一个参数传递的函数，直到定时器被清除。'
- en: Once the timer has started we can also reset the values stored in the object
    we'll use to keep track of the timer – the `currentTime` object. We set the `seconds`,
    `minutes`, and `hours` properties of this object to `0`. We need an object to
    keep track of the time because the `timer` variable itself just contains the ID
    of the timer.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定时器启动，我们还可以重置存储在我们将用于跟踪定时器的对象中的值 - `currentTime`对象。我们将此对象的`seconds`，`minutes`和`hours`属性设置为`0`。我们需要一个对象来跟踪时间，因为`timer`变量本身只包含定时器的ID。
- en: Next we added the `updateTime()` function that will be called by our interval
    every second. All we do in this function is update the relevant properties of
    the `currentTime` object, and update the display. We use an `if` conditional to
    check which parts of the timer to update.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加了`updateTime()`函数，该函数将由我们的间隔每秒调用一次。在此函数中，我们只需更新`currentTime`对象的相关属性，并更新显示。我们使用`if`条件来检查要更新定时器的哪些部分。
- en: We first check that the timer has not reached 24 hours. I would hope that no
    one would actually spend that long playing the game, but if the browser is left
    open for some reason for this length of time, we don't want the time display to
    say, for example, 24 hours and 1 minute, because at that point, we really should
    update the display to say 1 day, 0 hours, and 1 minute. But we aren't bothering
    with days so instead we just stop the timer.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查定时器是否尚未达到24小时。我希望没有人会实际花费那么长的时间来玩游戏，但是如果出于某种原因浏览器保持打开状态达到这么长时间，我们不希望时间显示为，例如，24小时1分钟，因为在那时，我们真的应该更新显示为1天0小时1分钟。但我们不关心天数，所以我们只是停止定时器。
- en: If the timer has not reached this length of time we then check whether the current
    minutes equal `59` and the current seconds equal `59`. If they do we need to increment
    `currentTime.hours` by `1` and reset the `currentTime.minutes` and `currentTime.seconds`
    properties back to `0`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定时器尚未达到此时间长度，则我们检查当前分钟是否等于`59`，当前秒是否等于`59`。如果是，我们需要将`currentTime.hours`增加`1`，并将`currentTime.minutes`和`currentTime.seconds`属性重置为`0`。
- en: If this check fails we then check whether the seconds equal `59`. If they do,
    we increment the `currentTime.minutes` property and then reset `currentTime.seconds`
    back to `0`. If this second test also fails we know that all we have to do is
    increment `currentTime.seconds`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此检查失败，则我们检查秒是否等于`59`。如果是，则我们增加`currentTime.minutes`属性，然后将`currentTime.seconds`重置为`0`。如果此第二个测试也失败，则我们知道我们所要做的就是增加`currentTime.seconds`。
- en: Next we need to check whether we need to pad any of the time components with
    a leading `0`. We could use another `if else` conditional for this, but the JavaScript
    ternary construct is neater and more compact so we use this instead.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要检查是否需要在时间组件的前面加上前导`0`。我们可以使用另一个`if else`条件来实现，但 JavaScript 的三元结构更简洁更紧凑，所以我们使用它。
- en: First we test whether `currentTime.hours` is equal to or less than `9` and if
    so we add `0` to the start of the value. We do the same for `currentTime.minutes`
    and `currentTime.seconds`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们测试`currentTime.hours`是否小于或等于`9`，如果是，我们在值的开头添加`0`。对于`currentTime.minutes`和`currentTime.seconds`，我们也是这样做的。
- en: Finally, we build the string which we will use to update the timer display.
    Instead of using boring and slow string concatenation, we again use an awesome
    array comprising the various parts of the display and then join the array.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们构建将用于更新计时器显示的字符串。我们不再使用乏味且缓慢的字符串连接，而是再次使用包含显示各个部分的数组，然后将数组连接起来。
- en: The resulting string is set as the value of the `<span>` element contained in
    the `timerDisplay` variable and the element on the page is updated using jQuery's
    `text()` method.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 结果字符串被设置为`timerDisplay`变量中包含的`<span>`元素的值，并使用 jQuery 的`text()`方法更新页面上的元素。
- en: At this point we can now click on the button to shuffle the puzzle pieces, and
    watch as the timer starts to increment.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们现在可以点击按钮来洗牌拼图块，并观察计时器开始递增。
- en: Determining if the puzzle has been solved
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定拼图是否已解决
- en: In this task we'll focus on determining whether the pieces have been put back
    into their correct locations, unscrambling and therefore solving the puzzle.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将专注于确定拼图块是否已放回其正确位置，从而对拼图进行解开并解决。
- en: Prepare for Lift Off
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: 'The following steps will be covered in this task:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在此任务中将涵盖以下步骤：
- en: Checking the order of pieces to see if they match the starting order of the
    pieces
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查拼图块的顺序是否与拼图块的初始顺序匹配
- en: Stopping the timer
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止计时器
- en: Displaying a congratulatory message
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示祝贺消息
- en: Engage Thrusters
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: First of all we need to decide when we should check whether the puzzle has been
    completed. A good place to do the check would be on the `stop` event of the drag.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要决定何时检查拼图是否已完成。在拖动的`stop`事件上进行检查的好地方。
- en: 'First add the following new variable directly after the existing `current`
    variable at the top of the `stop()` callback:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`stop()`回调的顶部的现有`current`变量之后直接添加以下新变量：
- en: '[PRE19]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Don''t forget to add a trailing comma after the first variable, as shown in
    the previous code sample. Next add the following code directly after the `if`
    statement:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在第一个变量之后添加尾随逗号，就像前面的代码示例中所示的那样。接下来，在`if`语句之后直接添加以下代码：
- en: '[PRE20]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Objective Complete - Mini Debriefing
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成目标 - 小结
- en: First of all we defined a new variable called `correctPieces` and set its value
    to `0`. We then used jQuery's `each()` method to iterate the `positions` array
    that we populated much earlier in the code, when we initially shuffled the pieces.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个名为`correctPieces`的新变量，并将其值设置为`0`。然后，我们使用 jQuery 的`each()`方法迭代了我们在代码早期，当我们最初对拼图块进行洗牌时，填充的`positions`数组。
- en: What we need to do at this point is get each piece from the puzzle and check
    whether the pieces are in the correct order. However, we can't just select the
    elements from the page using jQuery's `children()` method, for example, or `find()`,
    because jQuery does not return the elements in the order that they are found in
    the DOM, especially as we have already dragged them all around their parent container.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要做的是获取拼图的每一块，并检查这些块是否按正确的顺序排列。然而，我们不能仅仅使用 jQuery 的`children()`方法或`find()`方法选择页面上的元素，因为
    jQuery 不会以它们在 DOM 中找到的顺序返回元素，尤其是因为我们已经将它们全部移动到了它们的父容器周围。
- en: What we have to do instead is select each element by its `id` attribute, and
    check to see what `top` and `left` CSS properties it has in its `style` attribute.
    The length of the `positions` array is the same as the number of pieces so we
    can iterate this array and use the index argument that jQuery automatically passes
    to the iterator function.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是通过其`id`属性选择每个元素，然后检查其在`style`属性中具有的`top`和`left`CSS属性。`positions`数组的长度与拼图块的数量相同，因此我们可以迭代此数组，并使用
    jQuery 自动传递给迭代器函数的索引参数。
- en: Within the iterator we first select the current element. The `id` attributes
    for each piece will start at `1` instead of `0` because we already removed the
    first piece from the puzzle, so we add `1` to the index value when selecting each
    piece. We also get the position of the current element using our existing `getPosition()`
    function, passing in the element we just selected.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代器中，我们首先选择当前元素。每个方块的`id`属性将从`1`开始，而不是从`0`开始，因为我们已经从拼图中移除了第一个方块，所以在选择每个方块时，我们将索引值加`1`。我们还使用现有的`getPosition()`函数获取当前元素的位置，传入我们刚刚选择的元素。
- en: Next we compare the current piece's `top` and `left` properties with the equivalent
    item from the `positions` array, and if both the `top` and `left` properties match,
    we increment the `correctPieces` variable.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将当前方块的`top`和`left`属性与`positions`数组中等效的项目进行比较，如果`top`和`left`属性都匹配，我们将增加`correctPieces`变量。
- en: Once each piece from the page and each item in the positions array have been
    compared and the `each()` method has finished iterating, we then check whether
    the value of the `correctPieces` variable is equal to the length of the `positions`
    array. If it is, we know that each piece is in the correct place.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦页面上的每个方块和`positions`数组中的每个项目都被比较，并且`each()`方法完成迭代，我们接着检查`correctPieces`变量的值是否等于`positions`数组的长度。如果是的话，我们知道每个方块都在正确的位置上。
- en: We can stop the timer at this point in the same way that we did before – using
    the `clearInterval()` function, and then create the congratulatory message and
    append it to the element with an `id` of `ui`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像以前一样停止计时器，使用`clearInterval()`函数，然后创建祝贺消息并将其附加到具有`id`为`ui`的元素。
- en: Remembering best times and adding some final styling
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记住最佳时间并添加一些最终样式
- en: The game is now pretty playable as it stands. We can shuffle the pieces, only
    allow them to be dragged according to the rules, and the game will detect when
    the puzzle has been solved. Using a simple timer we can tell the player how long
    it took for them to solve it, but then what? What is the player supposed to do,
    just remember his/her best score?
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经可以玩得很好。我们可以打乱方块，只允许按规则拖动它们，游戏将会检测拼图何时完成。使用简单的计时器，我们可以告诉玩家解决问题所需的时间，但接下来呢？玩家应该做些什么，只是记住他/她的最高分吗？
- en: Of course, we now need a way to save the player's best time. It would also be
    handy if we could display an additional message if they beat their stored best
    time. We'll use the JavaScript localStorage API to store the best time.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，现在我们需要一种方法来保存玩家的最佳时间。如果他们超过存储的最佳时间，显示额外的消息也会很方便。我们将使用JavaScript的localStorage
    API来存储最佳时间。
- en: We can also add a little extra styling to finish the appearance of the game
    and lay out the different elements a little better.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加一些额外的样式来完成游戏的外观，并更好地布置不同的元素。
- en: Prepare for Lift Off
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为起飞做准备
- en: 'The steps that we''ll cover in this task are as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这项任务中将要涉及的步骤如下：
- en: Checking whether a best time has been saved
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查是否已保存了最佳时间
- en: Checking whether the current best time is better than the saved best time
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查当前最佳时间是否优于保存的最佳时间
- en: Updating the saved best time when the current best time is better than it
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当当前最佳时间优于保存的最佳时间时更新保存的最佳时间
- en: Displaying an additional message when the saved best time is beaten
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在超过保存的最佳时间时显示额外消息
- en: Tidying up the presentation of the game with CSS
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用CSS整理游戏的呈现方式
- en: Engage Thrusters
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'Everything we need to do in this task can be done in the `if` statement that
    is executed once the pieces are back in the correct order. Directly after where
    we displayed the congratulatory message in the last task add the following code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这项任务中需要做的一切都可以在`if`语句中完成，该语句在方块恢复正确顺序后执行。在上个任务中显示祝贺消息的地方后面直接添加以下代码：
- en: '[PRE21]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We already created the style sheet that we''ll use for this – `sliding-puzzle.css`,
    so we just need to add the following selectors and style rules to this file:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '我们已经创建了我们将用于此的样式表 – `sliding-puzzle.css`，所以我们只需要将以下选择器和样式规则添加到该文件中： '
- en: '[PRE22]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Objective Complete - Mini Debriefing
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小型总结
- en: First of all we convert the current time into seconds so that we have only a
    single value to work with and store. The seconds are calculated using the `hours`,
    `minutes`, and `seconds` properties of the `currentTime` object used to update
    the visible timer on the page.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们将当前时间转换为秒，这样我们就只有一个值可以使用和存储。秒数是使用`currentTime`对象的`hours`、`minutes`和`seconds`属性来计算的，用来更新页面上可见的计时器。
- en: The `hours` property is multiplied by `60` to convert to minutes, and then by
    `60` again to convert to seconds. The `minutes` property is multiplied by `60`
    a single time, then these two values are added to the seconds remaining in the
    `seconds` property to give the final total, which we store in the `totalSeconds`
    variable.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`hours` 属性乘以 `60` 转换为分钟，然后再乘以 `60` 转换为秒。 `minutes` 属性仅乘以 `60` 一次，然后将这两个值加到
    `seconds` 属性中剩余的秒数中，得到最终的总数，我们将其存储在 `totalSeconds` 变量中。'
- en: Next we check the localStorage to see if a key exists with the name `puzzleBestTime`.
    If it does, we store the value held in `localStorage` in the `bestTime` variable.
    If the value of our `totalSeconds` variable is less than the `bestTime` variable,
    we have a new high score, which we save in localStorage with the `puzzleBestTime`
    name in order to overwrite the old best time. We then display a second congratulatory
    message to say a new high score has been achieved.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查 localStorage 是否存在一个名称为 `puzzleBestTime` 的键。如果存在，则将 `localStorage` 中保存的值存储在
    `bestTime` 变量中。如果 `totalSeconds` 变量的值小于 `bestTime` 变量，我们就有了一个新的最高分，我们将其保存在 localStorage
    中，名称为 `puzzleBestTime`，以覆盖旧的最佳时间。然后，我们显示第二个祝贺消息，表示已经取得了新的最高分。
- en: If localStorage doesn't contain a key with this name, this must be the first
    time the game has been played in this browser, so we set the name of the key and
    store the value of the `currentTime` variable as the new best time, and again
    display the second congratulatory message.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 localStorage 不包含具有此名称的键，那么这必须是此浏览器中首次玩游戏，因此我们将键的名称设置为并将 `currentTime` 变量的值存储为新的最佳时间，然后再次显示第二个祝贺消息。
- en: There's nothing really crucial in the CSS that we added; it was just a little
    bit of light styling to tidy up the various elements we've used and present the
    game in a cleaner style.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加的 CSS 中没有什么真正关键的内容；它只是一点点轻微的样式，用来整理我们使用的各种元素，并以更清晰的风格呈现游戏。
- en: Classified Intel
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机密情报
- en: The localStorage API is one of the more stable JavaScript APIs that fall within
    the general umbrella term of HTML5, and enjoys wide support by all of the latest
    versions of all common browsers.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: localStorage API 是 HTML5 通用术语中比较稳定的 JavaScript API 之一，并且受到所有常见浏览器的最新版本的广泛支持。
- en: Old browsers, which we may still need to support, such as IE7 or Firefox 2,
    do not support localStorage. Luckily there are plenty of polyfills and workarounds
    that exist to add a basic level of support in these legacy browsers.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能仍然需要支持的旧浏览器，比如 IE7 或 Firefox 2，不支持 localStorage。幸运的是，有大量的填充和解决方法可以在这些旧浏览器中添加基本的支持。
- en: See [https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills](https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills)
    for a wide range of polyfills and patches that add support for modern APIs to
    legacy browsers.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills](https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills)获取一系列支持现代
    API 的填充和补丁，以在旧浏览器中添加支持。
- en: Mission Accomplished
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务完成
- en: We used a wide range of jQuery and plain-vanilla JavaScript over the course
    of this project to create this simple game. We also looked at using jQuery UI's
    draggable component as well as the localStorage API.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目的过程中，我们使用了大量的 jQuery 和原生 JavaScript 来创建这个简单的游戏。我们还研究了使用 jQuery UI 的可拖动组件以及
    localStorage API。
- en: We covered a lot of code so let's briefly look back at what we did.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们涵盖了很多代码，所以让我们简要回顾一下我们做过的事情。
- en: We first declared most of the variables that we used throughout the project
    right at the start of our `document.ready` function. It's useful to do this so
    that variables can be used throughout our code without making them global in scope.
    For performance reasons, it's also best to cache jQuery objects so that they can
    be manipulated frequently without having to keep selecting them from the page.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在 `document.ready` 函数的开头声明了大部分在整个项目中使用的变量。这样做很有用，因为变量可以在我们的代码中使用，而不需要将它们全局范围化。出于性能原因，最好缓存
    jQuery 对象，以便它们可以经常被操作，而无需在页面中不断地重新选择它们。
- en: We then saw how we can easily split an image of a known aspect-ratio into a
    number of equally-sized pieces laid out in a grid using nothing but some nested
    `for` loops and some simple mathematics. We also saw that using an array of substrings
    to create a string instead of using string concatenation is a very easy optimization
    that can help speed up our applications when long strings need to be constructed.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着看到了如何利用一些嵌套的`for`循环和简单的数学知识，轻松地将已知长宽比的图像分割成多个等大小的块，排列在一个网格中。我们还发现，使用子字符串数组来创建字符串而不是使用字符串连接是一个非常简单的优化，可以在构建长字符串时帮助加快我们应用程序的速度。
- en: We then saw how to shuffle the individual pieces into a random order using an
    accepted algorithm for randomizing – the Fisher-Yates shuffle. We didn't actually
    use jQuery at all to do this, but don't forget that the code to produce the shuffle
    was executed inside an event handler added using jQuery's `on()` method.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看到了如何使用一个接受的算法来随机化——费希尔-耶茨洗牌算法，将各个部分随机排列。实际上，我们完全没有使用jQuery来做这个，但不要忘记，生成洗牌的代码是在使用jQuery的`on()`方法添加的事件处理程序内执行的。
- en: Next we looked at how to make the pieces of the puzzle draggable using jQuery
    UI. We looked at some of the configurable options exposed by the component, as
    well as how to react to different events generated when the pieces were dragged.
    Specifically, we used the `start`, `drag`, and `stop` callbacks to enforce the
    rules of the game concerning which pieces could be moved, and how they could be
    moved during game play.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看了如何使用jQuery UI使拼图的各个部分可拖动。我们看了组件暴露的一些可配置选项，以及如何在拖动部分时对生成的不同事件作出反应。具体来说，我们使用了`start`、`drag`和`stop`回调来执行游戏规则，限制哪些部分可以在游戏中移动，以及它们在游戏过程中如何移动。
- en: After this we looked at using a standard JavaScript timer to keep track of how
    long it took to solve the puzzle, and how to keep the visible timer on the page
    updated so that the player could see the time that has elapsed since they started.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们看了如何使用标准的JavaScript定时器来跟踪解谜游戏所需的时间，以及如何更新页面上可见的计时器，让玩家能够看到他们开始以来经过的时间。
- en: Detecting when the puzzle was solved was also a crucial ability of the code.
    Our main obstacle here was the fact that the pieces weren't selected from the
    page in the visible order we could see on the screen, but this was easily overcome
    by selecting the pieces using their numbered `id` attributes and then manually
    checking their CSS position.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 检测拼图何时被解决也是代码的一个关键能力。我们在这里的主要障碍是，拼图的部分并不是按照我们在屏幕上看到的可见顺序选取的，但这很容易通过使用它们的编号`id`属性来选取部分，然后手动检查它们的CSS位置来克服。
- en: Lastly we looked at how to keep a record of the player's best time in solving
    the puzzle. localStorage is the obvious choice here, and it was a small step to
    check whether a score was already stored, and then compare the current time with
    the stored time to see if the record had been beaten.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看了如何记录玩家解谜游戏的最佳时间。在这里，localStorage是显而易见的选择，只需一小步检查是否已经存储了分数，然后比较当前时间和存储的时间，就能知道记录是否被打破了。
- en: You Ready To Go Gung HO? A Hotshot Challenge
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你准备好全力以赴了吗？一个高手的挑战
- en: There is still much more functionality we could add to our simple game. Why
    not update the game so that it has different skill levels available for the player
    to choose from?
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的简单游戏仍然可以添加许多更多的功能。为什么不更新游戏，让玩家可以选择不同的技能水平呢？
- en: All we'd need to do to achieve this would be to provide some kind of interface
    to allow the visitor to select the skill level, and then think of a way in which
    the game could be made more difficult.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们只需要提供某种接口，允许访问者选择技能水平，然后考虑一种使游戏变得更难的方式。
- en: If we assume that the game in its current format is the easiest skill level,
    one very simple way to make it harder is to increase the number of pieces that
    the original image is split into. Have a go at doing this yourself. Those of you
    with a deep understanding of mathematics may realize that our game has another
    flaw – some random combinations of the pieces will simply not be solvable. Storing
    or computing all of the possible combinations that are solvable is probably beyond
    practical, but there is another option.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设当前游戏格式是最简单的技能水平，那么使游戏变得更难的一个非常简单的方法是增加将原始图像分割成的块数。尝试自己做这个吧。那些对数学有深刻理解的人可能会意识到我们的游戏还有另一个缺陷——一些随机组合的部分根本无法解决。存储或计算所有可解决的可能组合可能超出了实际可行，但还有另一种选择。
- en: Instead of randomly shuffling the array of pieces and then writing their positions
    to the board, we could instead shuffle the pieces by programmatically moving them
    around the board. A puzzle shuffled according to the rules of the game by which
    the player is bound would result in a solvable puzzle every time.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是随机洗牌一堆碎片，然后将它们的位置写入板上，我们可以通过程序化地在棋盘上移动它们来洗牌。根据玩家受限的游戏规则进行洗牌的拼图将每次都得到一个可解的拼图。
