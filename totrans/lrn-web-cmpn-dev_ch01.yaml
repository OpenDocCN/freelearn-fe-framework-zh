- en: Chapter 1. Introducing Web Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the web component specification in detail.
    Web component is changing the web application development process. It comes with
    standard and technical features, such as templates, custom elements, Shadow DOM,
    and HTML Imports.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main topics that we will cover in this chapter about web component specification
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: What are web components?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benefits and challenges of web components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web component architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML Import
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shadow DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a digital clock component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The X-Tag library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: web component libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are web components?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web components are a W3C specification to build a standalone component for web
    applications. It helps developers leverage the development process to build reusable
    and reliable widgets. A web application can be developed in various ways, such
    as page focus development and navigation-based development, where the developer
    writes the code based on the requirement. All of these approaches fulfil the present
    needs of the application, but may fail in the reusability perspective. This problem
    leads to component-based development.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and challenges of web components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many benefits of web components:'
  prefs: []
  type: TYPE_NORMAL
- en: A web component can be used in multiple applications. It provides interoperability
    between frameworks, developing the web component ecosystem. This makes it *reusable*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A web component has a template that can be used to put the entire markup separately,
    making it more *maintainable*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As web components are developed using HTML, CSS, and JavaScript, it can run
    on different browsers. This makes it *platform independent*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shadow DOM provides *encapsulation mechanism* to style, script, and HTML markup.
    This encapsulation mechanism provides **private scope** and prevents the content
    of the component being affected by the external document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Equally, some of the challenges for a web component include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation**: The W3C web component specification is very new to the
    browser technology and not completely implemented by the browsers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shared resource**: A web component has its own scoped resources. There may
    be cases where some of the resources between the components are common.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Increase in the number of web components takes more time to
    get used inside the DOM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polyfill size**: The polyfill are a workaround for a feature that is not
    currently implemented by the browsers. These polyfill files have a large memory
    foot print.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SEO**: As the HTML markup present inside the template is inert, it creates
    problems in the search engine for the indexing of web pages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web component architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The W3C web component specification has four main building blocks for component
    development. Web component development is made possible by template, HTML Imports,
    Shadow DOM, and custom elements and decorators. However, decorators do not have
    a proper specification at present, which results in the four pillars of web component
    paradigm. The following diagram shows the building blocks of web component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The web component architecture](img/image00197.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: These four pieces of technology power a web component that can be reusable across
    the application. In the coming section, we will explore these features in detail
    and understand how they help us in web component development.
  prefs: []
  type: TYPE_NORMAL
- en: Template element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTML `<template>` element contains the HTML markup, style, and script, which
    can be used multiple times. The templating process is nothing new to a web developer.
    Handlebars, Mustache, and Dust are the templating libraries that are already present
    and heavily used for web application development. To streamline this process of
    template use, W3C web component specification has included the `<template>` element.
  prefs: []
  type: TYPE_NORMAL
- en: This template element is very new to web development, so it lacks features compared
    to the templating libraries such as Handlebars.js that are present in the market.
    In the near future, it will be equipped with new features, but, for now, let's
    explore the present template specification.
  prefs: []
  type: TYPE_NORMAL
- en: Template element detail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The HTML `<template>` element is an `HTMLTemplateElement` interface. The **interface
    definition language** (**IDL**) definition of the template element is listed in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is written in IDL language. This IDL language is used by
    the W3C for writing specification. Browsers that support HTML Import must implement
    the aforementioned IDL. The details of the preceding code are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HTMLTemplateElement`: This is the template interface and extends the `HTMLElement`
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`content`: This is the only attribute of the HTML template element. It returns
    the content of the template and is read-only in nature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DocumentFragment`: This is a return type of the `content` attribute. `DocumentFragment`
    is a lightweight version of the document and does not have a parent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To find out more about `DocumentFargment`, use the following link:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en/docs/Web/API/DocumentFragment](https://developer.mozilla.org/en/docs/Web/API/DocumentFragment)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Template feature detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The HTML `<template>` element is very new to web application development and
    not completely implemented by all browsers. Before implementing the template element,
    we need to check the browser support. The JavaScript code for template support
    in a browser is listed in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the `isTemplateSupported` method checks the `content`
    property present inside the template element. If the `content` attribute is present
    inside the template element, this method returns either `true` or `false`. If
    the template element is supported by the browser, the `h1` element will show the
    support message. The browser that is used to run the preceding code is Chrome
    39 release. The output of the preceding code is shown in following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Template feature detection](img/image00198.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows that the browser used for development is supporting
    the HTML template element.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is also a great online tool called **Can I Use** for checking support
    for the template element in the current browser. To check out the template support
    in the browser, use the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://caniuse.com/#feat=template](http://caniuse.com/#feat=template)'
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows the current status of the support for the template
    element in the browsers using the **Can I Use** online tool.
  prefs: []
  type: TYPE_NORMAL
- en: '![Template feature detection](img/image00199.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Inert template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The HTML content inside the template element is inert in nature until it is
    activated. The inertness of template content contributes to increasing the performance
    of the web application. The following code demonstrates the inertness of the template
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, a template contains an image element with the `src`
    attribute, pointing to a Gravatar profile image, and an inline JavaScript `alert`
    method. On page load, the `document.getElementById` method is looking for an HTML
    element with the `#profileImage` ID. The output of the preceding code is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inert template](img/image00200.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows that the script is not able to find the HTML
    element with the `profileImage` ID and renders `null` in the browser. From the
    preceding screenshot it is evident that the content of the template is inert in
    nature.
  prefs: []
  type: TYPE_NORMAL
- en: Activating a template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, the content of the `<template>` element is inert and are not part
    of the DOM. The two different ways that can be used to activate the nodes are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Cloning a node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing a node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloning a node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `cloneNode` method can be used to duplicate a node. The syntax for the
    `cloneNode` method is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the preceding code syntax are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: This method can be applied on a node that needs to be cloned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return type of this method is `Node`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The input parameter for this method is of the `Boolean` type and represents
    a type of cloning. There are 2 different types of cloning, listed as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deep cloning**: In deep cloning, the children of the targeted node also get
    copied. To implement deep cloning, the `Boolean` input parameter to `cloneNode`
    method needs to be `true`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shallow cloning**: In shallow cloning, only the targeted node is copied without
    the children. To implement shallow cloning the `Boolean` input parameter to `cloneNode`
    method needs to be `false`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows the use of the `cloneNode` method to copy the content
    of a template, having the `h1` element with some text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the template element has the `aTemplate` ID and is referenced
    using the `querySelector` method. The HTML markup content inside the template
    is then retrieved using a `content` property and saved in a `templateContent`
    variable. The `cloneNode` method is then used for deep cloning to get the activated
    node that is later appended to a `div` element. The following screenshot shows
    the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cloning a node](img/image00201.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To find out more about the `cloneNode` method visit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/API/Node.cloneNode](https://developer.mozilla.org/en-US/docs/Web/API/Node.cloneNode)'
  prefs: []
  type: TYPE_NORMAL
- en: Importing a node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `importNode` method is another way of activating the template content.
    The syntax for the aforementioned method is listed in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the preceding code syntax are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: This method returns a copy of the node from an external document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method takes two input parameters. The first parameter is the target node
    that needs to be copied. The second parameter is a `Boolean` flag and represents
    the way the target node is cloned. If the `Boolean` flag is `false`, the `importNode`
    method makes a shallow copy, and for a `true` value, it makes a deep copy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows the use of the `importNode` method to copy the content
    of a template containing an `h1` element with some text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the template element has the `aTemplate` ID and is referenced
    using the `querySelector` method. The HTML markup content inside the template
    is then retrieved using the `content` property and saved in the `templateContent`
    variable. The `importNode` method is then used for deep cloning to get the activated
    node that is later appended to a `div` element. The following screenshot shows
    the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing a node](img/image00202.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To find out more about the `importNode` method, visit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://mdn.io/importNode](http://mdn.io/importNode)'
  prefs: []
  type: TYPE_NORMAL
- en: HTML Import
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The HTML Import is another important piece of technology of the W3C web component
    specification. It provides a way to include another HTML document present in a
    file with the current document. HTML Imports provide an alternate solution to
    the `Iframe` element, and are also great for resource bundling. The syntax of
    the HTML Imports is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the preceding syntax are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: The HTML file can be imported using the `<link>` tag and the `rel` attribute
    with import as the value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `href` string points to the external HTML file that needs to be included
    in the current document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The HTML `import` element is implemented by the `HTMLElementLink` class. The
    IDL definition of HTML Import is listed in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows IDL for the HTML Import where the parent interface
    is `LinkImport` which has the `readonly` attribute `import`. The `HTMLLinkElement`
    class implements the `LinkImport` parent interface. The browser that supports
    HTML Import must implement the preceding IDL.
  prefs: []
  type: TYPE_NORMAL
- en: HTML Import feature detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The HTML Import is new to the browser and may not be supported by all browsers.
    To check the support of the HTML Import in the browser, we need to check for the
    `import` property that is present inside a `<link>` element. The code to check
    the HTML `import` support is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code has a `isImportSupported` function, which returns the `Boolean`
    value for HTML `import` support in the current browser. The function creates a
    `<link>` element and then checks the existence of an `import` attribute using
    the `in` operator. The following screenshot shows the output of the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HTML Import feature detection](img/image00203.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows that the import is supported by the current browser
    as the `isImportSupported` method returns true.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Can I Use** tool can also be utilized for checking support for the HTML
    Import in the current browser. To check out the template support in the browser,
    use the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://caniuse.com/#feat=imports](http://caniuse.com/#feat=imports)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the current status of support for the HTML Import
    in browsers using the **Can I Use** online tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HTML Import feature detection](img/image00204.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Accessing the HTML Import document
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The HTML Import includes the external document to the current page. We can
    access the external document content using the `import` property of the link element.
    In this section, we will learn how to use the `import` property to refer to the
    external document. The `message.html` file is an external HTML file document that
    needs to be imported. The content of the `message.html` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows the HTML document where the `message.html` file is
    loaded and referenced by the `import` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the preceding code are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: In the header section, the `<link>` element is importing the HTML document present
    inside the `message.html` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the body section, an inline `<script>` element using the `document.querySelector`
    method is referencing the link elements having the `rel` attribute with the `import`
    value. Once the link element is located, the content of this external document
    is copied using the `import` property to the `externalDocument` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The header `h1` element inside the external document is then located using a
    `querySelector` method and saved to the `headerElement` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The header element is then deep copied using the `cloneNode` method and appended
    to the `body` element of the current document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing the HTML Import document](img/image00205.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: HTML Import events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The HTML `<link>` element with the `import` attribute supports two event handlers.
    These two events are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`load`: This event is fired when the external HTML file is imported successfully
    onto the current page. A JavaScript function can be attached to the `onload` attribute,
    which can be executed on a successful load of the external HTML file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`: This event is fired when the external HTML file is not loaded or found(HTTP
    code 404 not found). A JavaScript function can be attached to the `onerror` attribute,
    which can be executed on error of importing the external HTML file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows the use of these two event types while importing the
    `message.html` file to the current page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the preceding code are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`handleSuccess`: This method is attached to the `onload` attribute which is
    executed on the successful load of `message.html` in the current document. The
    `handleSuccess` method imports the document present inside the `message.html`
    file, then it finds the `h1` element, and makes a deep copy of it . The cloned
    `h1` element then gets appended to the body element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handleError`: This method is attached to the `onerror` attribute of the `<link>`
    element. This method will be executed if the `message.html` file is not found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As the `message.html` file is imported successfully, the `handleSuccess` method
    gets executed and header element `h1` is rendered in the browser. The following
    screenshot shows the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HTML Import events](img/image00206.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Shadow DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before the web component specification, there were many issues of building
    web applications using HTML, CSS, and JavaScript. Some of the issues are listed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Style override**: The document stylesheet may change the style of the web
    component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Script alteration**: The document JavaScript may alter some part of the web
    component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ID overlap**: There may be a duplicate ID present in the document, which
    can lead to many erroneous situations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the aforementioned issue list, there is clearly a problem with **scoping**.
    Shadow DOM is another important piece of web component specification that solves
    the scoping problem by the encapsulation mechanism. Shadow DOM provides a way
    of packaging the HTML, CSS, and JavaScript for a web component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the HTML5 elements, such as the progress bar, are implemented as Shadow
    DOM by the Chrome browser. We can inspect this Shadow DOM through the Chrome developer
    console. By default, the Chrome developer console will not show Shadow DOM. We
    need to enable the **Show user agent shadow DOM** checkbox present inside the
    settings of the developer console. The following screenshot shows the Chrome developer
    console setting to enable Shadow DOM inspection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shadow DOM](img/image00207.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After enabling the Shadow DOM inspection setting, we can inspect the `<progress>`
    HTML5 element. The following screenshot shows the Chrome developer inspection
    of the progress bar element containing Shadow DOM node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shadow DOM](img/image00208.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we can see a new element `#shadow-root`. This node
    is the Shadow DOM of the progress bar element. As the progress bar is built in
    the browser element; we can see the user-agent text in parenthesis.
  prefs: []
  type: TYPE_NORMAL
- en: Shadow DOM feature detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Shadow DOM support for a browser can be checked by enabling the `createShadowRoot`
    property inside an element. The following code demonstrates a way of detecting
    the support of the Shadow DOM in the current browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the `isShadowDOMSupported` method checks the support
    of the Shadow DOM in the current browser by checking the existence of the `createShadowRoot`
    property in the `document.body` element. The following screenshot shows the output
    of the preceding code in the current browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shadow DOM feature detection](img/image00209.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding screenshot shows that the Shadow DOM is supported by the current
    browser, as the `isShadowDOMSupport` method returns `true`. We can also check
    the support of the Shadow DOM using the **Can I Use** online tool. The following
    screenshot shows the status of Shadow DOM support in a different browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shadow DOM feature detection](img/image00210.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Shadow tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Shadow DOM brings the ability to include a subtree of DOM elements inside a
    document on the rendering time. The nodes inside DOM are organized as a tree structure.
    A node inside the DOM tree can have its own Shadow DOM tree. This makes the DOM
    a tree of trees. We can classify the DOM tree into three different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Document tree**: This represents the normal DOM tree whose root node is a
    document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shadow tree**: This represents the internal DOM subtree formed using HTML
    elements present inside shadow host. The root node of this tree is called **shadow
    root**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composed tree**: This represents the more expanded version of document tree,
    which includes the Shadow DOM trees too and is used by the browser for rendering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The DOM element that has one or more than one Shadow DOM subtrees is called
    as **host element** or **shadow host**. The following diagram shows a sample DOM
    tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shadow tree](img/image00211.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding diagram, we find out that the node present inside the DOM
    element represents another subtree, which makes the DOM a tree of trees. A browser
    which supports Shadow DOM implementation should follow the IDL definition for
    declaring the shadow root element. The IDL of a shadow root element is listed
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the preceding IDL are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getElementById`: This method finds the element present inside the Shadow DOM
    tree with the given ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getElementsByClassName`: This method finds the element present inside the
    Shadow DOM tree with the given class name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getElementsByTagName`: This method finds the element present inside the Shadow
    DOM tree with the given tag name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getElementsByTagNameNS`: This method finds the element present inside the
    Shadow DOM tree with the given namespace and tag name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getSelection`: This method returns the selection object for currently selected
    element inside the Shadow DOM tree'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`elementFromPoint`: This method returns the element with the given *x* and
    *y* coordinates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`activeElement`: This property returns currently focused element inside the
    Shadow DOM tree'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`host`: This property returns the shadow host element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`olderShadowRoot`: If the element has multiple shadow trees then this property
    returns the shadow root which was created earlier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`innerHTML`: This property returns the HTML content of the shadow root as a
    string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`styleSheets`: This property returns the list of stylesheet objects if the
    shadow tree contains the `<style>` element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s check out an example which demonstrates the use of these properties
    and the methods of a shadow root. The example code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the two Shadow DOM subtrees `shadowRoot1` and `shadowRoot2`
    are present for the host element. The `shadowRoot1` subtree is created first and
    `shadowRoot2` is created later. Hence, the `shadowRoot1` subtree is an older shadow
    root. The `shadowRoot2` subtree contains the HTML markup from a template with
    the `selectorTemplate` ID. The `shadowRoot2` subtree has a `<form>` element containing
    a `<label>` and `<input>` element. It also contains some CSS styles inside the
    `<style>` element. The output of the preceding code is presented in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shadow tree](img/image00212.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the console log messages, which demonstrate
    the use of the preceding methods for the shadow tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shadow tree](img/image00213.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the console log messages that demonstrate the
    use of the preceding properties for the shadow tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shadow tree](img/image00214.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Custom element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web component specifications come with the power to create a new element for
    DOM. A custom element can have its own properties and methods. The reasons for
    creating a custom element are less code from the developer's point of view, creating
    a more semantic tag library, reducing the number of `div` tags, and so on. Once
    a web component is developed, it can be used by any application.
  prefs: []
  type: TYPE_NORMAL
- en: Custom element feature detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A new element can be registered to DOM using the `registerElement` method.
    We can detect the support of the custom element in the current browser by checking
    the presence of the `registerElement` function inside document. The following
    JavaScript code shows a method to detect the support for custom element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the `isCustomElementSupported` method has the code to
    check the custom element support. It uses the `in` operator to check whether the
    `registerElement` function is present inside the document object. If the custom
    element is supported, the method returns true and the success message gets rendered
    in the browser. The following screenshot shows the output of the preceding code
    in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom element feature detection](img/image00215.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also use the **Can I Use** online tool to check the support for custom
    elements. The following screenshot shows the current status of the browser for
    custom element support:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom element feature detection](img/image00216.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Developing a custom element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will develop a custom element and understand each step
    in detail. The steps involved in developing a custom element are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining object properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining lifecycle methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering a new element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending an element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A new object can be created using the `Object.create` method. The syntax of
    this method is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Object.create` method takes two parameters. The first parameter is the
    target prototype of the newly created object. The second parameter contains the
    properties of the newly created object. The second parameter is optional. The
    following code defines a new object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, a new object is created that has the `HTMLElement.prototype`
    parameter and is saved in the `objectPrototype` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To find out more about the `Object.create` method, use the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create)'
  prefs: []
  type: TYPE_NORMAL
- en: Defining object properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can define the property of an object using two different methods `defineProperty`
    and `defineProperties`. The `defineProperty` method is used to create a single
    property, and the `defineProperties` method for multiple properties. The syntax
    of these methods is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the preceding syntax are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`targetObject`: This represents the target object for which the property needs
    to be defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`propertyName`: This represents the key of the property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`propertySettings`: This represents all the configuration options for a property.
    The possible settings options are listed here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`configurable`: This takes a Boolean value. For a `true` value, the type of
    property can be changed or deleted. For a `false` value, the property type cannot
    be changed and deleted.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enumerable`: This takes a Boolean value. For a `true` value, the property
    will be enumerated as its own property.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value`: This takes any JavaScript value. It represents the value associated
    with the property.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`writable`: This takes a Boolean value. For a `true` value, the associated
    value of the property can be updated using assignment operator.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get`: This takes a function. It returns the value of the property.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set`: This takes a function. It sets the input value to the property.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows an example of defining a single property named `title`
    for `newObject` that is writable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To find out more about the `Object.defineProperty` method, use the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows an example of defining multiple properties like `title`
    and `country` for the `newObject` variable. The `title` property is writable,
    and the `country` property is not writable and has a fixed value `India`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To find out more about the `Object.defineProperties` method, use the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties)'
  prefs: []
  type: TYPE_NORMAL
- en: Defining lifecycle methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An object in JavaScript goes through different states during its lifecycle.
    The different states of an object lifecycle are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`created`: An object is in the `created` state when it is initialized. The
    event handler for this state is the `createdCallback` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attached`: An object is in the `attached` state when it is inserted to the
    DOM. The event handler for this state is the `attachedCallback` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`detached`: An object is in the `detached` state when it is removed from the
    DOM. The event handler for this state is the `detachedCallback` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attributeChanged`: An object is in the `attaributeChanged` state when one
    of its property''s values is updated. The event handler for this state is the
    `attributeChangedCallback` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows an example where an object is created using the `Object.create`
    method, and a callback method is attached for the created state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Registering a new element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A new element can be registered to the DOM using the `document.registerElement`
    method. The syntax of this method is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the preceding syntax are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tag-name`: This represents the name of the custom element. The name must be
    separated with a hyphen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`settings`: This takes the configuration option for the custom element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`constructor` : The `registerElement` method returns the constructor of new
    element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows an example of registering a new element named `welcome-message`
    to the DOM. The prototype of the `welcome-message` element is `objectPrototype`,
    which is created using the `Object.create` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To find out more about the `document.registerElement` method, use the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/API/document.registerElement](https://developer.mozilla.org/en-US/docs/Web/API/document.registerElement)'
  prefs: []
  type: TYPE_NORMAL
- en: Extending an element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An element can inherit a native or another custom element. The `extend` property
    is used to inherit another element. The following code shows an example of extending
    an `<i>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `is` operator is used to define the type of an HTML element. The following
    code shows if an element is of the italic type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Example of a custom element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will create a simple custom element named `<my-message>`.
    Code for the `<my-message>` element is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, a custom `my-name` element is defined using the `registerElement`
    method. It has the `title` attribute, which has been defined using the `Object.defineProperty`
    method. A `createdCallback` method is added, which takes the input string of the
    `title` property and inserts it using the `innerText` property. The following
    screenshot shows the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of a custom element](img/image00217.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Node distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The composed tree takes part in rendering the DOM inside the browser. The Shadow
    DOM subtree of the nodes gets arranged for display. The arrangements of the nodes
    are done by a distribution mechanism with the help of specific insertion points.
    These insertion points are of two types:'
  prefs: []
  type: TYPE_NORMAL
- en: Content insertion point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shadow insertion point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A content insertion point
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A content insertion point is a **placeholder** for child nodes of the shadow
    host distribution. It works like a marker, which reprojects the child nodes of
    the shadow host. A content insertion point can be defined using the `<content>`
    element. The `<content>` element has a `select` attribute through which we can
    filter out the **reprojection**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code gives an example of the use of the `<content>` element with
    the `select` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'A detailed explanation of the preceding code is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: A custom element named `<selector-component>` is created, which has a list of
    fruits and flowers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTML template of the custom element has two `<content>` elements. One content
    element filters out all the flowers using the `select` attribute with the `b.flower`
    value, and the other `<content>` element filters out all the fruits using the
    `select` attribute with the `b.fruit` value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of the preceding code of filtering
    fruit and flower in a separate group:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A content insertion point](img/image00218.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A shadow insertion point
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Shadow insertion points are placeholders for other shadow trees. This insertion
    point reprojects the elements of other shadow trees. A shadow insertion point
    can be created using the `<shadow>` element. The following code gives an example
    of the use of the shadow insertion point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the preceding code are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: There are two shadow roots, `shadowRoot1(old)` and `shadowRoot2(new)`, created
    for the `<div>` element with the `aShadowHost` ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `shadow1Template` is the HTML template for `shadowRoot1`, and `shadow2Template`
    is the HTML template for `shadow2Root`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `shadow1Template` contains a `<button>` element, and `shadow2Template` contains
    a `<fieldset>` and `<legend>` element. The `<fieldset>` element also has a `<shadow>`
    insertion point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During rendering of the page, the shadow insertion point will take the older
    shadow root content and insert it in the shadow insertion point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following screenshot shows the output of the preceding code, where the older
    shadow root elements are reprojected and rendered inside the `<fieldset>` element,
    which belongs to the younger shadow root, that is, `shadowRoot1`.
  prefs: []
  type: TYPE_NORMAL
- en: '![A shadow insertion point](img/image00219.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Styling web components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The way we styled the HTML DOM elements earlier needs to be changed with the
    emergence of the web component specification. In this section, we will explore
    some of the key areas that need more focus while authoring CSS. We need to know
    some new pseudo element selectors for styling the web component. These pseudo
    selectors are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unresolved pseudo selector**: When a custom element is loaded and registered
    with the DOM, the browser picks the matched element and upgrades it based on the
    defined lifecycle. During this upgradation process, the elements are exposed to
    the browser and appear as unstyled for a few moments. We can avoid the flash of
    unstyled content using the `:unresolved` pseudo class. An example of `unresolved`
    pseudo selector for the `<header-message>` custom element are listed here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Host pseudo selector**: The custom element itself can be referred using the
    `:host` pseudo selector to apply the `style` attribute. An example of the `host`
    selector is listed in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Shadow pseudo selector**: The Shadow DOM subtree of the custom element can
    be referred using the `::shadow` pseudo selector to apply the `style` attributes.
    An example of `shadow` selector is listed here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Content pseudo selector**: The content of the older insertion point element
    can be referred using the `::content` pseudo selector to apply the `style` attributes.
    An example of `content` selector is listed in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's check out a simple example to demonstrate the aforementioned pseudo selectors.
    The following code creates a custom element named `<header-element>`. To show
    the use of the `:unresolved` pseudo selector, we delayed registering the custom
    element for 3 seconds using the `window.setTimeOut` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the preceding code are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: The registration process of the custom element is delayed on purpose for 3 seconds.
    During this time, the element becomes `HTMLUnknownElement`. We used the `:unresolved`
    pseudo selector to show a **Registering Element…** message during this time in
    the color red.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the element is registered, the custom element becomes resolved (`HTMLElement`).
    In the `createdCallback` lifecycle method, we created a shadow root appended as
    a child.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The template of `<header-element>` is present inside the `<template>` element
    with the `headerTemplate` ID. The template is then activated using the `document.importNode`
    method, which are added as children of the preceding shadow root.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The host DOM tree is referred using the `:host` pseudo selector, which has a
    `style` attribute in order to transform the text into capital letters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Shadow DOM tree is referred using the `::shadow` pseudo selector, which
    has a `style` attribute to change the text color to orange.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The template also has the `<content>` element, which selects the original children
    of `<header-element>` and puts it into this location. In our example, the children
    are wrapped around the `<b>` tag. We referred this `<b>` element using the content
    selector to apply the `style` attribute so as to make the text color `blue` and
    the text type `italic`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following screenshot shows the output of the preceding code with the `:unresolved`
    pseudo selector style in effect for the first 3 seconds. We can see the message
    in red.
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling web components](img/image00220.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the element is registered to the DOM, the lifecycle method gets executed
    and `<header-element>` gets upgraded with its Shadow DOM. The following screenshot
    shows the final output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling web components](img/image00221.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Building a digital clock component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will build a simple digital clock element. The motive behind
    building a custom component is to implement the template, HTML Imports, Shadow
    DOM, and custom element to a real-time example. The definition of the digital
    clock component is present in the `clock-element.html` file, and the use of the
    digital clock component is present in the `clock-demo.html` file. The `clock-element.html`
    file has two sections. These are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Clock template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clock element registration script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clock template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The digital clock template contains the HTML markup and the CSS styles for
    rendering in the browser on activation. The HTML template code and the CSS styles
    for the clock component are listed in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'A detailed explanation of the preceding code is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: The content of the clock element is present inside the `<template>` element.
    The ID of the template element is `clockTemplate`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This template contains two section styles and HTML markup.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the CSS style classes are wrapped around the `<style>` element. The host
    clock element is targeted using the `:host` pseudo selector, and its shadow tree
    children are targeted using the `::shadow` pseudo attribute and the styles are
    applied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTML markup for the clock element is wrapped around the `div` element .The
    parent `div` element has the `.clock` class. The parent `div` element has the
    three children `div` element representing hours, minutes, and seconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clock element registration script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The clock component registration script is present in the `clock-element.html`
    file and is wrapped around a self-invoking anonymous function. The JavaScript
    code to create and register a clock component is listed in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the preceding code are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: The script for registering the clock element is embedded inside a self-calling
    function, which saves the reference to the current owner document to `selfDocument`
    variable using `document.currentScript.ownerDocument`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new object is created using the `Object.create` method. The prototype of this
    new object is `HTMLElement.prototype`. The reference of this new object is saved
    in the `objectPrototype` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `createdCallback` lifecycle method of the host element is overloaded with
    the following steps:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new `shadowRoot` object is created for the host element using the `createShadowRoot`
    method. Reference to this `shadowRoot` is then saved to the `shadow` variable.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The template content of the clock element is then retrieved using the `selfDocument`
    reference variable.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The inert content of the clock template is then activated using the `document.importNode`
    method.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The activated template contents are then added as children to the host's shadow
    root.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `window.setInterval()`, a block of code is called every 1 second. The
    purpose of this code block is to get the hours, minutes, and seconds of the current
    time and update the DOM repeatedly every second.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The clock element is then registered with the DOM using the `document.registerElement`
    method. After registering, the clock component is now ready for use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the clock component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we developed the clock component that is present inside
    the `clock-element.html` file. In this section, we will import the clock element
    and use it in the markup to render in the browser. The code to use clock component
    is present in the `clock-demo.html` file and is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the clock component is imported using the `link` element
    with the `rel` attribute, which has the `import` value. The digital clock component
    can be implemented using the `<digital-clock></digital-clock>` custom element.
    The output of the preceding code is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the clock component](img/image00222.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding screenshot shows the digital clock component. The numbers in
    the screenshot are showing *hours* (HH), *minutes* (MM), and *seconds* (SS). The
    following screenshot shows the developer console of the clock component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the clock component](img/image00223.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The details of the preceding screenshot are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: The clock element is imported to the current page and has its own `#document`
    root
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The digital clock element has its Shadow DOM tree, which is rendered as a clock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: X-Tag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The X-Tag is a small JavaScript library for web component development by Mozilla.
    This library is built on the web component polyfill from Polymer team. The Mozilla
    Bricks framework is built on top of the X-Tag library. We can download the X-Tag
    library using [http://www.x-tags.org/download](http://www.x-tags.org/download).
  prefs: []
  type: TYPE_NORMAL
- en: X-Tag element lifecycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every X-Tag element has a lifecycle. An element state is decided based on the
    event that is fired during state transition. An element during its lifecycle goes
    through the following states (event fired):'
  prefs: []
  type: TYPE_NORMAL
- en: '`created`: This event is fired by the element when it is initially created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inserted`: This event is fired by the element when it is inserted into the
    DOM for first time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removed`: This event is fired by the element when it is removed from the DOM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attributeChanged`: This event is fired when any of the property values of
    the element is changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The lifecycle of the element can be defined inside the `lifecycle` attribute.
    The following code shows the syntax of the `lifecycle` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: X-Tag custom element development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A custom X-Tag element can be created using the `xtag.register` method. The
    X-Tag core library code is present inside the `x-tag-components.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The X-Tag core library source code can be downloaded by visiting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/x-tag/core](https://github.com/x-tag/core)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `xtag.register` method has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the preceding syntax are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lifecycle`: This property can have code for all states during the lifecycle
    of the element. Therefore, we can define its logic for the custom elements by
    implementing the `created`, `inserted`, `removed`, and `attributeChanged` state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`methods`: This property can have all the methods that need to be exposed as
    a public API that is to be consumed externally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`events`: This property can have all the element''s event binding listeners
    that need to be fired based on the user action of the custom element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`accessors`: This property can have all the attributes that need the getter
    and setters methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, it is time to create a custom component using this X-Tag library. The
    code for creating an X-Tag base custom element is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the preceding code are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: A custom X-Tag-based element named `italic-string` is created by the `xtag.register`
    method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This custom element takes the `innerHTML` content and wraps it with a `<i>`
    element, which gives it an italic style font.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This custom element has a `textColor` property name, where a color string can
    be given. The value of the `textColor` property is then applied to the `style`
    property of the `<i>` element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `textColor` property is created using the `accessors` property. This `accessors`
    property takes the attributes that need to be configured to the `italic-string`
    element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An event listener is created using the `events` property. In the preceding code
    a `click` event type listener is attached to the `<i>` element. When the `<i>`
    element is clicked on, it shows a message in the console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method can be defined using the `methods` property. There is a method callback
    `changedToRed()` that can be accessed as an API. This callback method has used
    `document.getElementById()` to locate the X-Tag custom element with the `iStringComponent`
    (the `italic-string` component). It then finds and changes the `color` style attribute
    of the `<i>` element to `Red`. A button's `onclick` method is attached with a
    `doColorRed` JavaScript function, which in turn calls the `changeToRed` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of the preceding code looks like the following screenshot. It has
    the **Click Me** text and a **Make Red** button rendered in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![X-Tag custom element development](img/image00224.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When user clicks on the **Make Red** button, the **Click Me** text will change
    to red in color. The following screenshot shows the **Click Me** text changed
    to red:'
  prefs: []
  type: TYPE_NORMAL
- en: '![X-Tag custom element development](img/image00225.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If the user clicks on the **Click Me** text, then the event handler attached
    with it gets executed and prints the message. The following screenshot shows the
    console log message when the user clicks on the X-Tag element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![X-Tag custom element development](img/image00226.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To know more about X-Tag library use the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.x-tags.org/docs](http://www.x-tags.org/docs)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Web component specification is not completely implemented by the browsers.
    However, there are many libraries with polyfill support for web components that
    exist. In this section, we will list the libraries, and get a quick introduction
    to them. Some of the most popular libraries are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Polymer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Polymer is the web component library from Google Inc. This library allows a
    web developer to compose CSS, HTML, and JavaScript to build rich, powerful, and
    reusable web component. In [Chapter 2](lrn-web-cmpn-dev_ch02.html#aid-PNV61 "Chapter 2. Introducing
    Polymer"), *Introducing Polymer* and [Chapter 3](lrn-web-cmpn-dev_ch03.html#aid-VF2I1
    "Chapter 3. Developing Web Components Using Polymer"), *Developing Web Components
    Using Polymer*, we will learn more about this library.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To find out more about Polymer library use the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.polymer-project.org](https://www.polymer-project.org)'
  prefs: []
  type: TYPE_NORMAL
- en: Mozilla Brick
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mozilla Brick is another web component library from Mozilla. It has a collection
    of reusable UI components to be used in web application. The current version of
    this library is 2.0\. In [Chapter 5](lrn-web-cmpn-dev_ch05.html#aid-1IHDQ1 "Chapter 5. Developing
    Web Components Using Mozilla Brick"), *Developing Web Components Using Mozilla
    Brick*, we will learn more about this library.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To find out more about Mozilla Brick library use the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://brick.readme.io/v2.0](http://brick.readme.io/v2.0)'
  prefs: []
  type: TYPE_NORMAL
- en: ReactJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ReactJS is a library for web component development from Facebook. This library
    takes a different approach to build the web application. In [Chapter 6](lrn-web-cmpn-dev_ch06.html#aid-1R42S1
    "Chapter 6. Building Web Components with ReactJS"), *Building Web Components with
    ReactJS*, we will learn more about the ReactJS library.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To find out more about ReactJS library, use the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://facebook.github.io/react](http://facebook.github.io/react)'
  prefs: []
  type: TYPE_NORMAL
- en: Bosonic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bosonic is another library for web component development. It uses some of the
    PolymerJS polyfill in the core. In [Chapter 4](lrn-web-cmpn-dev_ch04.html#aid-19UOO1
    "Chapter 4. Exploring Bosonic Tools for Web Component Development"), *Exploring
    Bosonic Tools for Web Component Development*, we will explore more details about
    Bosonic.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To find out more about the Bosonic library, use the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bosonic.github.io/index.html](http://bosonic.github.io/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the web component specification. We also explored
    the building blocks of web components such as Shadow DOM, custom element, HTML
    Imports, and templates. In the next chapter, we will learn about the PolymerJS
    library in detail.
  prefs: []
  type: TYPE_NORMAL
