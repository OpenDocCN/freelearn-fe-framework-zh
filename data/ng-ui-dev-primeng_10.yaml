- en: Creating Robust Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建健壮的应用程序
- en: Testing web applications is an important process to eliminate bugs. Tests ensure
    that the written code works as expected and the functionality is not broken on
    subsequent changes. They also help you to better understand the complex code you
    are working on. There are two main types of testing--**unit testing** and **end-to-end**
    (**e2e**) testing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 测试Web应用程序是一个重要的过程，可以消除错误。测试确保编写的代码按预期工作，并且功能在后续更改中不会中断。它们还可以帮助您更好地理解您正在处理的复杂代码。有两种主要类型的测试--**单元测试**和**端到端**（**e2e**）测试。
- en: Unit testing is about testing isolated pieces of code. Unit tests normally use
    mocks for inputs and then assert that the expected results have occurred. The
    e2e approach executes tests against your application running in a real browser.
    Such tests assert that all pieces of code properly interact with each other. Standard
    test frameworks for Angular applications are Jasmine and Protractor. Jasmine is
    used for unit testing in combination with Karma-- a test runner for JavaScript.
    Protractor is an e2e test framework. This chapter describes two types of testing
    in a concise manner. You will learn how to set up and use the test frameworks
    efficiently. Testing and debugging tips round off the book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是关于测试孤立的代码片段。单元测试通常使用模拟输入，然后断言预期结果是否发生。e2e方法执行针对在真实浏览器中运行的应用程序的测试。这些测试断言所有代码片段是否正确地相互交互。Angular应用程序的标准测试框架是Jasmine和Protractor。Jasmine与Karma一起用于单元测试，Karma是JavaScript的测试运行器。Protractor是一个e2e测试框架。本章简要描述了两种测试类型。您将学习如何高效地设置和使用测试框架。测试和调试技巧为本书画上了句号。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章中，我们将涵盖以下主题:'
- en: Setting up unit testing with Jasmine and Karma
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jasmine和Karma设置单元测试
- en: Unit testing of components and services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件和服务的单元测试
- en: Tips on how to speed up unit testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何加快单元测试的技巧
- en: Setting up the e2e test environment with Protractor
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Protractor设置e2e测试环境
- en: Writing automated UI tests at a glance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一览自动化UI测试
- en: Exploring an PrimeNG application with Augury and ng.probe
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Augury和ng.probe探索PrimeNG应用程序
- en: Setting up unit testing with Jasmine and Karma
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jasmine和Karma设置单元测试
- en: This section will give a brief overview of Jasmine ([http://jasmine.github.io](http://jasmine.github.io))
    and Karma ([https://karma-runner.github.io](https://karma-runner.github.io)).
    We will set up a testing environment before writing concrete unit tests. For this
    purpose, the Webpack seed project introduced in the *Setting up PrimeNG project
    with Webpack* section of [Chapter 1](0cbd9d79-a0ba-42ba-9172-2b76d8ad8788.xhtml),
    *Getting Started with Angular and PrimeNG*, will be extended.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将简要概述Jasmine ([http://jasmine.github.io](http://jasmine.github.io)) 和Karma
    ([https://karma-runner.github.io](https://karma-runner.github.io))。在编写具体的单元测试之前，我们将建立一个测试环境。为此，将扩展在[第1章](0cbd9d79-a0ba-42ba-9172-2b76d8ad8788.xhtml)的*使用Webpack设置PrimeNG项目*部分介绍的Webpack种子项目。
- en: Brief introduction to Jasmine
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jasmine简介
- en: 'Jasmine is a JavaScript testing framework with zero dependencies. With `npm`,
    you can install it as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine是一个没有依赖的JavaScript测试框架。使用`npm`，您可以按如下方式安装它：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You also need to install the Jasmine type definition file. Otherwise, the TypeScript
    compiler will not know about the Jasmine types.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要安装Jasmine类型定义文件。否则，TypeScript编译器将不知道Jasmine类型。
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Jasmine has four main concepts:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 'Jasmine有四个主要概念:'
- en: '**Specs**: In Jasmine terminology, unit tests are called specs. The `it(string,
    function)` function specifies a test. It takes a title and a function containing
    one or more expectations.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规格**: 在Jasmine术语中，单元测试称为规格。`it(string, function)`函数指定一个测试。它接受一个标题和一个包含一个或多个期望的函数。'
- en: '**Suites**: Specs are wrapped in suites. The `describe(string, function)` function
    describes a test suite. It takes a title and a function containing one or more
    specs. Suit can contain other nested suites as well.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**套件**: 规范被包裹在套件中。`describe(string, function)`函数描述了一个测试套件。它接受一个标题和一个包含一个或多个规范的函数。套件也可以包含其他嵌套套件。'
- en: '**Expectations**: These are assertions which are specified using the `expect(actual)`
    function. The function gets one argument--the `actual` value.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**期望**: 这些是使用`expect(actual)`函数指定的断言。该函数接受一个参数--`actual`值。'
- en: '**Matchers**: Assertions are followed by matchers. Jasmine has a lot of matchers
    such as `toBe(expected)`, `toEqual(expected)`, `toBeLessThan(expected)`, and many
    more. The `expected` argument is the expected value. For example, `expect(2 +
    3).toBeLessThan(6)`. Matchers implement a Boolean comparison between `actual`
    and `expected` values. If the matcher returns `true`, the spec passes; otherwise,
    an error is thrown. Any matcher can be negated with `not`; for example, `expect(array).not.toContain(member)`.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**匹配器**: 断言后面跟着匹配器。Jasmine有很多匹配器，比如`toBe(expected)`、`toEqual(expected)`、`toBeLessThan(expected)`等等。`expected`参数是期望的值。例如，`expect(2
    + 3).toBeLessThan(6)`。匹配器在`actual`和`expected`值之间实现布尔比较。如果匹配器返回`true`，则规范通过；否则，会抛出错误。任何匹配器都可以用`not`否定；例如，`expect(array).not.toContain(member)`。'
- en: A full list of matchers is available on GitHub at [https://github.com/JamieMason/Jasmine-Matchers](https://github.com/JamieMason/Jasmine-Matchers).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的匹配器列表可在GitHub上找到：[https://github.com/JamieMason/Jasmine-Matchers](https://github.com/JamieMason/Jasmine-Matchers)。
- en: 'An example of a simple test with Jasmine is shown here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine的一个简单测试示例如下：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The titles in the functions `it()` and `describe()` serve the purpose of documentation.
    Tests should be self-described so that other developers can better understand
    what the test does.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`it()`和`describe()`函数中的标题用于文档编写。测试应该是自描述的，这样其他开发人员就可以更好地理解测试的作用。'
- en: 'Jasmine has some setup and teardown functions:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine有一些设置和拆卸函数：
- en: '`beforeAll()`: Executes some code before the suite runs.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeAll()`: 在套件运行之前执行一些代码。'
- en: '`beforeEach()`: Executes some code before each spec runs.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeEach()`: 在每个规范运行之前执行一些代码。'
- en: '`afterAll()`: Executes some code after the suite is finished.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterAll()`: 在套件完成后执行一些代码。'
- en: '`afterEach()`: Executes some code after each spec is finished.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterEach()`: 在每个规范完成后执行一些代码。'
- en: 'An example with `beforeEach()` and `afterAll()` is demonstrated here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里演示了使用`beforeEach()`和`afterAll()`的示例：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Testing setup with Webpack and Karma
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Webpack和Karma进行测试设置
- en: 'There are two runners to execute tests:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个运行器来执行测试：
- en: '**HTML runner from the Jasmine''s standalone distribution (**[https://github.com/jasmine/jasmine/releases](https://github.com/jasmine/jasmine/releases)**)**:
    Download the ZIP file, unzip it, and open the `SpecRunner.html` file in any text
    editor. This HTML file includes some base code that loads the test framework.
    You need to add regular Angular dependencies, an Angular testing library, and
    a SystemJS loader, which loads the `.spec` files. After that, you can open the
    HTML file in your web browser to see the test results.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jasmine独立发布版的HTML运行器（[https://github.com/jasmine/jasmine/releases](https://github.com/jasmine/jasmine/releases)**)**:
    下载ZIP文件，解压缩，并在任何文本编辑器中打开`SpecRunner.html`文件。这个HTML文件包含一些加载测试框架的基本代码。您需要添加常规的Angular依赖项、一个Angular测试库和一个SystemJS加载器，加载`.spec`文件。之后，您可以在Web浏览器中打开HTML文件查看测试结果。'
- en: '**Command-line runner Karma**: Karma can run tests in different browsers and
    report possible errors with various reporters. The runner can be integrated into
    the build process so that the unit tests get executed automatically as a part
    of the build.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令行运行器Karma**: Karma可以在不同的浏览器中运行测试，并使用各种报告器报告可能的错误。该运行器可以集成到构建过程中，以便单元测试作为构建的一部分自动执行。'
- en: 'In this book, we will only concentrate on the Karma runner. The Webpack-based
    project setup needs the following Karma dependencies:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们只关注Karma运行器。基于Webpack的项目设置需要以下Karma依赖：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Attentive readers will notice that we want to run tests against Google Chrome
    and PhantomJS ([http://phantomjs.org](http://phantomjs.org))--a headless browser,
    which is perfect for testing web applications.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 细心的读者会注意到，我们想要针对Google Chrome和PhantomJS（[http://phantomjs.org](http://phantomjs.org)）运行测试--一个无头浏览器，非常适合测试Web应用程序。
- en: The complete project with instructions is available on GitHub at
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的项目及说明可在GitHub上找到
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter10/unit-testing](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter10/unit-testing).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter10/unit-testing](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter10/unit-testing)。'
- en: 'The testing setup with Webpack and Karma requires three configuration files.
    First of all, we need a Karma configuration file: `karma.config.js`. This file
    will tell Karma where the tests are located, which browser(s) to use to execute
    the tests, which reporting mechanism to use, and so on. In the project on GitHub,
    this file has the following content:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Webpack和Karma进行测试设置需要三个配置文件。首先，我们需要一个Karma配置文件：`karma.config.js`。这个文件将告诉Karma测试的位置在哪里，使用哪个浏览器来执行测试，使用哪种报告机制等等。在GitHub上的项目中，这个文件的内容如下：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Two important points should be mentioned here. There is a special Webpack configuration
    for tests, which is located in the `webpack.test.js` file. Its content is simple:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里应该提到两个重要的点。有一个专门的Webpack配置用于测试，位于`webpack.test.js`文件中。它的内容很简单：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `webpack.test.js` doesn''t specify entry points for files to be tested.
    The location and file extension for test files are defined in `spec-bundle.js`.
    This is another important file processed by Webpack. It loads Angular modules
    required for testing and initializes the test environment. At the end, all the
    test files are getting loaded in the browser. The content of the `spec-bundle.js`
    file is listed here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`webpack.test.js`没有指定要测试的文件的入口点。测试文件的位置和文件扩展名在`spec-bundle.js`中定义。这是Webpack处理的另一个重要文件。它加载测试所需的Angular模块并初始化测试环境。最后，所有测试文件都会在浏览器中加载。`spec-bundle.js`文件的内容如下：'
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The convention is to name your test file the same as the file it is testing,
    but with the suffix `.spec` before the file extension. For example, `header.component.spec.ts`
    and `language.service.spec.ts`. It is also the best practice to keep each test
    file in the same directory as the corresponding file under test.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 约定是将测试文件命名为要测试的文件相同，但在文件扩展名之前加上后缀`.spec`。例如，`header.component.spec.ts`和`language.service.spec.ts`。最佳实践也是将每个测试文件保存在与相应受测试文件相同的目录中。
- en: In `package.json`, we can configure three convenient commands.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.json`中，我们可以配置三个方便的命令。
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, we are ready to run our tests using one of the three commands. When we
    execute `npm run test`, Karma will open and close each configured browser and
    print the test results.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备使用三个命令之一来运行我们的测试。当我们执行`npm run test`时，Karma将打开和关闭每个配置的浏览器并打印测试结果。
- en: When using the Angular CLI, it handles the configuration for us. You don't need
    to write any configuration files and can quickly run all tests by typing `ng test`
    in our project root. This command watches for changes and reruns the tests automatically.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Angular CLI时，它会为我们处理配置。您不需要编写任何配置文件，只需在项目根目录中键入`ng test`即可快速运行所有测试。此命令会监视更改并自动重新运行测试。
- en: Unit testing of components and services
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件和服务的单元测试
- en: In this section, we will introduce Angular testing utilities and show how to
    test components and services. Testing of directives, pipes, router, and so on,
    will not be explained due to the limited size of the book.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍Angular测试工具，并展示如何测试组件和服务。由于本书篇幅有限，不会解释指令、管道、路由器等的测试。
- en: Angular testing utilities
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular测试工具
- en: As you could see in the previous section, Angular comes with a testing library,
    `@angular/core/testing`, which offers the `TestBed` helper class and many other
    utilities. `TestBed` helps us to set up dependencies for tests--modules, components,
    providers, and so on. You can call `TestBed.configureTestingModule()` and pass
    the same metadata configuration object as used with `@NgModule`. The `configureTestingModule()`
    function should be called within a `beforeEach()` setup function.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前一节中看到的，Angular带有一个测试库`@angular/core/testing`，它提供了`TestBed`辅助类和许多其他实用程序。`TestBed`帮助我们为测试设置依赖项--模块、组件、提供者等。您可以调用`TestBed.configureTestingModule()`并传递与`@NgModule`中使用的相同的元数据配置对象。`configureTestingModule()`函数应该在`beforeEach()`设置函数中调用。
- en: 'Another useful function from the testing library is called `inject()`. It allows
    you to inject the specified objects into the tests. The following code snippet
    provides an example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 测试库中的另一个有用函数称为`inject()`。它允许您将指定的对象注入到测试中。以下代码片段提供了一个示例：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The next useful function is the `async()` function. It may be used with asynchronous
    operations because it doesn''t complete the test until all asynchronous operations
    in the test have been completed or the specified timeout occurs. The `async()`
    function wraps the second argument of the `it()` function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个有用的函数是`async()`函数。它可用于异步操作，因为它在测试中不会完成，直到测试中的所有异步操作完成或发生指定的超时。`async()`函数包装了`it()`函数的第二个参数：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The timeout parameter is optional. It is also possible to call `async()` in
    combination with `inject()`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 超时参数是可选的。还可以结合`inject()`调用`async()`：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that if you change some component''s property value and this property
    is bound to the view via the `ngModel` directive, you have to do this within `async()`
    as well. The reason: `ngModel` updates the value asynchronously. We will develop
    an appropriate example in this section.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您更改了某个组件的属性值，并且该属性通过`ngModel`指令绑定到视图，您也必须在`async()`中执行此操作。原因是：`ngModel`会异步更新值。我们将在本节中开发一个适当的示例。
- en: 'The `fakeAsync()` function from the Angular testing utilities is similar to
    `async()`, but it enables a linear coding style by running the test body in a
    special *fakeAsync test zone*. The `fakeAsync()` method is used in combination
    with the `tick()` function, which simulates the passage of time until all pending
    asynchronous activities have been finished. There are no nested `then(...)` blocks
    anymore; the test appears to be synchronous:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Angular测试工具中的`fakeAsync()`函数类似于`async()`，但它通过在特殊的*fakeAsync测试区域*中运行测试主体来实现线性编码风格。`fakeAsync()`方法与`tick()`函数一起使用，后者模拟时间的流逝，直到所有挂起的异步活动都已完成。不再有嵌套的`then(...)`块；测试看起来是同步的：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There is one limitation with `fakeAsync()`--you cannot make an XHR call from
    within `fakeAsync()`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`fakeAsync()`有一个限制--您不能在`fakeAsync()`中进行XHR调用。'
- en: Testing a component
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试一个组件
- en: 'We want to test a component called `SectionComponent` with just one property
    `username`. The component has the following markup:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要测试一个名为`SectionComponent`的组件，它只有一个属性`username`。该组件具有以下标记：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the test file `section.component.spec.ts`, we will assign the value `James
    Bond` to the property `username` and then check whether the value appears in the
    view. The full listing of the test code is shown here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试文件`section.component.spec.ts`中，我们将把值`James Bond`赋给属性`username`，然后检查该值是否出现在视图中。测试代码的完整列表如下：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s explain the code. First of all, we need to configure the testing module
    with `TestBed`. It is done as usual within `beforeEach()`. The class `TestBed`
    has a static method `createComponent(component)`, which we use to create `ComponentFixture`--a
    wrapper around the component instance on the test environment. The fixture provides
    an access to the component instance itself, to the native root element, and to
    `DebugElement`, which is a wrapper around the root element of this component.
    Furthermore, `ComponentFixture` has a lot of other useful methods:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下代码。首先，我们需要用`TestBed`配置测试模块。这通常在`beforeEach()`中完成。`TestBed`类有一个静态方法`createComponent(component)`，我们用它来创建`ComponentFixture`——在测试环境中包装组件实例的包装器。fixture提供了对组件实例本身、原生根元素以及`DebugElement`的访问，后者是对该组件的根元素的包装器。此外，`ComponentFixture`还有许多其他有用的方法：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The most important methods are `detectChanges()` and `whenStable()`. The first
    one triggers the change detection cycle for the component. This is necessary to
    propagate the changes to the UI. The second one returns `Promise` and can be used
    to resume testing when all asynchronous calls or asynchronous change detection
    have ended. We used two different APIs to check the expected result after `Promise`
    got resolved.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的方法是`detectChanges()`和`whenStable()`。第一个触发组件的变更检测周期。这是必要的，以便将更改传播到UI。第二个返回`Promise`，可以在所有异步调用或异步变更检测结束时用于恢复测试。我们使用了两种不同的API来检查`Promise`解析后的预期结果。
- en: 'Jasmine has a concept of spies. A spy mocks any object or function and tracks
    calls to it and all of its arguments. The `toHaveBeenCalled` matcher will return
    `true` if the spy was called. The next code snippet creates a spy on the `showDetails`
    method. After some interactions, we can verify if the method was called:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine有一个间谍的概念。间谍模拟任何对象或函数，并跟踪对它及其所有参数的调用。如果间谍被调用，`toHaveBeenCalled`匹配器将返回`true`。下一个代码片段在`showDetails`方法上创建了一个间谍。经过一些交互后，我们可以验证该方法是否被调用：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can also verify if the method was called with specific arguments, how many
    times it was called, and so on. Refer to the Jasmine documentation for more details.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以验证方法是否使用特定参数进行了调用，调用了多少次等等。有关更多详细信息，请参阅Jasmine文档。
- en: Testing a service
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试一个服务
- en: 'The next example outlines how to test services. We want to test a service,
    which returns some countries from a remote backend:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子概述了如何测试服务。我们想要测试一个从远程后端返回一些国家的服务：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `Country` objects have the following shape:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Country`对象具有以下形状：'
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We don''t want to make HTTP calls during the tests. To achieve that, we have
    to replace `XHRBackend` by `MockBackend`. The `MockBackend` allows us to catch
    outgoing HTTP requests and simulate incoming responses. We can just define a response
    as we want and then compare the result from the service with our expectations.
    The next code snippet shows how to build a mocked response, so when we finally
    make a call to our service, it gets the predefined array of countries:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望在测试期间进行HTTP调用。为了实现这一点，我们必须用`MockBackend`替换`XHRBackend`。`MockBackend`允许我们捕获传出的HTTP请求并模拟传入的响应。我们可以按照自己的意愿定义一个响应，然后将服务的结果与我们的期望进行比较。下一个代码片段展示了如何构建一个模拟响应，所以当我们最终调用我们的服务时，它会得到预定义的国家数组：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note, that we don''t need the `async()` function here because `MockBackend`
    behaves synchronously. Now, when all the tests are successful, you will see the
    following output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里我们不需要 `async()` 函数，因为 `MockBackend` 的行为是同步的。现在，当所有测试都成功时，您将看到以下输出：
- en: '![](assets/8e22742c-8e05-43d5-a9e8-d465faa01390.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8e22742c-8e05-43d5-a9e8-d465faa01390.png)'
- en: The demonstrated test of the service class was not an *isolated unit test*.
    Isolated unit tests explore the inner logic of the tested class and don't require
    the Angular testing utilities. You don't need to prepare a testing module, call
    `inject()`, `async()`, and so on. A test instance of the class is created with
    `new`, supplying mock, spy, or fake objects for the constructor parameters. Generally,
    services and pipes are good candidates for isolated unit testing. Read the official
    Angular testing guide to learn more details ([https://angular.io/docs/ts/latest/guide/testing.html](https://angular.io/docs/ts/latest/guide/testing.html)).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 所演示的服务类测试不是*孤立的单元测试*。孤立的单元测试探索被测试类的内部逻辑，并且不需要使用Angular测试工具。您不需要准备测试模块，调用 `inject()`，`async()`
    等。使用 `new` 创建类的测试实例，并为构造函数参数提供模拟、间谍或虚假对象。通常，服务和管道是孤立单元测试的良好候选对象。阅读官方的Angular测试指南以了解更多细节
    ([https://angular.io/docs/ts/latest/guide/testing.html](https://angular.io/docs/ts/latest/guide/testing.html))。
- en: The complete project with instructions is available on GitHub at
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的项目及说明可在GitHub上找到
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter10/unit-testing](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter10/unit-testing).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter10/unit-testing](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter10/unit-testing).'
- en: Tips on how to speed up unit testing
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加速单元测试的提示
- en: In a real web application, you can have a lot of test files. The bundling and
    running of all test files might take a while. Karma takes a while for the booting
    process as well. It is not satisfactory for rapid software development if you
    always have to run hundreds and more tests in order to test a small change in
    a single file. If you would like to narrow testing for files you are writing the
    tests for, one file or a specified collection of files should be tested, without
    rebooting Karma. How to do this?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个真实的网络应用程序中，您可能有很多测试文件。捆绑和运行所有测试文件可能需要一段时间。Karma的引导过程也需要一段时间。如果您总是需要运行数百甚至更多的测试来测试单个文件中的小更改，这对于快速软件开发来说是不令人满意的。如果您想要缩小测试范围，只测试您编写测试的文件，或者一组指定的文件，而不重新启动Karma。如何做到这一点？
- en: 'This is the case where `karma-webpack-grep` ([https://www.npmjs.com/package/karma-webpack-grep](https://www.npmjs.com/package/karma-webpack-grep))
    can help you. It allows to limit files, which are bundled by `karma-webpack`.
    First, install it:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `karma-webpack-grep` ([https://www.npmjs.com/package/karma-webpack-grep](https://www.npmjs.com/package/karma-webpack-grep))
    可以帮助您的情况。它允许限制由 `karma-webpack` 捆绑的文件。首先，安装它：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After that, we have to extend the `karma.conf.js` file. Put the new `karma-webpack-grep`
    plugin to the array of all Webpack''s plugins. Everything else remains unchanged:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们必须扩展 `karma.conf.js` 文件。将新的 `karma-webpack-grep` 插件放入所有Webpack插件的数组中。其他一切保持不变：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that the `testContext` option is exactly the same that as passed in `require.context(...)`
    (see `spec-bundle.js`). But, where the `config.grep` coming from? Karma parses
    command-line arguments. That means, if you execute the following command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`testContext` 选项与 `require.context(...)` 中传递的内容完全相同（请参阅 `spec-bundle.js`）。但是，`config.grep`
    是从哪里来的？Karma解析命令行参数。这意味着，如果您执行以下命令：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `config.grep` will be set to `some/path`. Let''s extend the `npm` scripts:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`config.grep` 将设置为 `some/path`。让我们扩展 `npm` 脚本：'
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, you are able to run concrete tests in watch mode. For Chrome browser,
    it looks as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在观察模式下运行具体的测试。对于Chrome浏览器，它看起来如下：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For PhantomJS, the tests start with `npm test test:headless:grep`. The test
    result looks like the following (here for `CountryService`):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于PhantomJS，测试以`npm test test:headless:grep`开头。测试结果看起来像下面这样（这里是针对`CountryService`）：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The Karma runner continues to run and watches the file changes. Test results
    appear very fast on every file change. It is also possible to watch and execute
    test files in a certain folder. For that, you can simple pass this folder to the
    `npm` script. For instance:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Karma运行器继续运行并监视文件更改。每次文件更改时，测试结果都会非常快地显示出来。还可以观察并执行特定文件夹中的测试文件。为此，您可以简单地将此文件夹传递给`npm`脚本。例如：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'All tests under `src/app/section` will be watched and executed. Just concentrate
    on writing the code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将在`src/app/section`下的所有测试都被监视和执行。只需专注于编写代码：
- en: The complete project with instructions is available on GitHub at
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的项目及说明可在GitHub上找到
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter10/unit-testing](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter10/unit-testing).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter10/unit-testing](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter10/unit-testing)。'
- en: Setting up the e2e test environment with Protractor
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Protractor设置端到端测试环境
- en: Protractor ([http://www.protractortest.org](http://www.protractortest.org))
    is an open source e2e testing automation framework, designed specifically for
    Angular web applications. The Protractor is a Node.js tool built on the top of
    WebDriverJS--an official implementation of the W3C WebDriver API to interact with
    the browser.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor（[http://www.protractortest.org](http://www.protractortest.org)）是一个开源的端到端测试自动化框架，专门为Angular
    web应用程序设计。Protractor是一个基于WebDriverJS的Node.js工具，它是W3C WebDriver API的官方实现，用于与浏览器交互。
- en: Protractor has many advantages. You no longer need to add `waits` and `sleeps`
    to your test for pending tasks. Protractor can automatically execute the next
    step in your test at the moment the web page finishes asynchronous tasks (for
    example, AJAX updates). The framework also supports Angular's locator strategies,
    which allows you to find Angular-specific elements by binding, model, and so on,
    without much effort. This section gives a brief introduction to Protractor including
    the setup and specific testing constructs.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor有许多优点。您不再需要为挂起的任务在测试中添加`waits`和`sleeps`。Protractor可以在网页完成异步任务（例如，AJAX更新）时自动执行测试中的下一步。该框架还支持Angular的定位策略，允许您轻松地通过绑定、模型等找到特定于Angular的元素。本节简要介绍了Protractor，包括设置和特定的测试构造。
- en: Installing and configuring Protractor
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置Protractor
- en: 'The preferred method is to install Protractor globally with the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首选方法是使用以下命令全局安装Protractor：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Protractor will automatically download the *Selenium Standalone Server* and
    all the browser drivers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor将自动下载*Selenium独立服务器*和所有浏览器驱动程序。
- en: The Selenium Standalone Server is normally needed if you want to connect to
    remote machine(s) and run tests against browser(s) on remote machine(s). It is
    often used with *Selenium-Grid* when you distribute your tests over multiple machines.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium独立服务器通常在您想要连接到远程机器并对远程机器上的浏览器运行测试时需要。当您将测试分布在多台机器上时，通常与*Selenium-Grid*一起使用。
- en: 'Execute this command to update the Selenium Standalone Server and the browser
    drivers:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令以更新Selenium独立服务器和浏览器驱动程序：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Ensure that you have installed the `jasmine-core` package locally as shown
    in the *Setting up unit testing with Jasmine and Karma* section . The tests will
    be written in Jasmine, but you can also use Mocha ([https://mochajs.org](https://mochajs.org))--another
    JavaScript test framework running on Node.js. In addition, a reporter implementation
    is required. Install `jasmine-spec-reporter`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经像在*使用Jasmine和Karma设置单元测试*部分所示的那样在本地安装了`jasmine-core`包。测试将使用Jasmine编写，但您也可以使用Mocha（[https://mochajs.org](https://mochajs.org)）-另一个在Node.js上运行的JavaScript测试框架。此外，还需要安装一个报告生成工具`jasmine-spec-reporter`：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The Protractor configuration takes place in the `protractor.conf.js` file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor配置在`protractor.conf.js`文件中进行。
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The description of the most important configuration options is listed down
    here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下面列出了最重要的配置选项的描述：
- en: '| **Option** | **Description** |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| **选项** | **描述** |'
- en: '| `allScriptsTimeout` | The timeout in milliseconds for each script running
    on the browser. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `allScriptsTimeout` | 浏览器上每个脚本运行的超时时间（以毫秒为单位）。 |'
- en: '| `specs` | Spec patterns are relative to the location of this config. The
    best practice is to place all e2e tests in the `e2e` folder. The sub-folder names
    correspond to the page names. For example, tests for the `home` page should be
    in the `home` sub-folder. The file names also correspond to the name of pages.
    We add the `.e2e-spec.ts` suffix to our spec files. For example, the spec file
    for the home page is `home.e2e-spec.ts`. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `specs` | Spec模式相对于此配置的位置。最佳实践是将所有的e2e测试放在`e2e`文件夹中。子文件夹名称对应页面名称。例如，`home`页面的测试应该在`home`子文件夹中。文件名也对应页面名称。我们在我们的spec文件中添加`.e2e-spec.ts`后缀。例如，home页面的spec文件是`home.e2e-spec.ts`。
    |'
- en: '| `capabilities` | Configuration object for the browser the tests run against.
    You can also run tests on more than one browser at once. For that, use the `multiCapabilities`
    option, which expects an array of capabilities. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `capabilities` | 浏览器测试的配置对象。您也可以同时在多个浏览器上运行测试。为此，请使用`multiCapabilities`选项，该选项需要一个能力数组。
    |'
- en: '| `seleniumAddress` | Use this option to connect to a running Selenium Server
    started with `webdriver-manager start`. For example, `seleniumAddress: ''http://localhost:4444/wd/hub''`.
    Protractor will send requests to this server to control a browser. You can see
    information about the status of the server at `http://localhost:4444/wd/hub`.
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `seleniumAddress` | 使用此选项连接到使用`webdriver-manager start`启动的运行中的Selenium服务器。例如，`seleniumAddress:
    ''http://localhost:4444/wd/hub''`。Protractor将向该服务器发送请求以控制浏览器。您可以在`http://localhost:4444/wd/hub`上查看有关服务器状态的信息。
    |'
- en: '| `directConnect` | Use this option to connect to Chrome or Firefox directly
    (only two browsers are supported for direct connection). In this book, we use
    `directConnect` instead of `seleniumAddress`. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `directConnect` | 使用此选项直接连接到Chrome或Firefox（仅支持两种浏览器的直接连接）。在本书中，我们使用`directConnect`而不是`seleniumAddress`。
    |'
- en: '| `baseUrl` | The base URL for the application under test. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `baseUrl` | 被测试应用的基本URL。 |'
- en: '| `framework` | Test framework to use. Normally, Jasmine or Mocha are used.
    |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `framework` | 使用的测试框架。通常使用Jasmine或Mocha。 |'
- en: '| `beforeLaunch` | A callback function called once configs are read but before
    any environment setup. This will only run once, and before `onPrepare`. In the
    preceding configuration, `ts-node` will be executed. The `ts-node` module takes
    care of transpiling TypeScript files to JavaScript ones. You must install it via
    `npm` as `npm install ts-node --save-dev`. Also, consider the `project` configuration
    option which points to the folder with a specific `tsconfig.json` file. Normally,
    we need different TypeScript compiler options for e2e tests. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `beforeLaunch` | 一旦配置文件被读取但在任何环境设置之前调用的回调函数。这只会运行一次，在`onPrepare`之前。在前面的配置中，将执行`ts-node`。`ts-node`模块负责将TypeScript文件转换为JavaScript文件。您必须通过`npm`安装它，如`npm
    install ts-node --save-dev`。还要考虑`project`配置选项，它指向具有特定`tsconfig.json`文件的文件夹。通常，我们需要不同的TypeScript编译器选项来进行e2e测试。'
- en: '| `onPrepare` | A callback function called once Protractor is ready and available,
    and before the specs are executed. We can add some reporters there. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `onPrepare` | 一旦Protractor准备就绪并可用，但在执行规范之前调用的回调函数。我们可以在那里添加一些报告者。'
- en: 'All preparations are done. Now, ensure that the application is running at `http://localhost:3000/`
    and run the tests from the project root with:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 所有准备工作都已完成。现在，请确保应用程序正在`http://localhost:3000/`上运行，并从项目根目录运行测试：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For the sake of convenience, you can configure this command as the `npm` script
    and run with `npm run e2e`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，您可以将此命令配置为`npm`脚本，并使用`npm run e2e`运行：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `webdriver-manager update` command should be running first as a pre-hook.
    This is why we need `"pree2e"` in the `scripts` section.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`webdriver-manager update`命令应该首先作为预挂钩运行。这就是为什么我们需要在`scripts`部分中有`"pree2e"`的原因。'
- en: 'It is possible to separate e2e tests into various suites and run suite-related
    tests separately. You can accomplish this task in the configuration file within
    the `suites` section. For instance, let''s define two suites, `homepage` and `payment`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将e2e测试分成不同的套件，并分别运行与套件相关的测试。您可以在配置文件的`suites`部分完成这项任务。例如，让我们定义两个套件，`homepage`和`payment`：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following command will only run the homepage-related tests:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将仅运行与主页相关的测试：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When using the Angular CLI, it creates the configuration file for us. You can
    execute e2e tests by running `ng serve` and `ng e2e` in two separate consoles.
    If you need different settings, specific mocks, and so on for e2e tests, you must
    create a new `environment.e2e.ts` file with the specific environment variables,
    and register it in `.angular-cli.json` under `environments` as `"e2e": "environments/environment.e2e.ts"`.
    Now, you can import the `environment.ts` in the `app.module.ts`, check the environment
    variables and perform custom logic where required; for example, provide mocks,
    and so on. To make it work, the application should be started as `ng serve --env=e2e`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '在使用Angular CLI时，它会为我们创建配置文件。您可以通过在两个单独的控制台中运行`ng serve`和`ng e2e`来执行e2e测试。如果您需要不同的设置、特定的模拟等等用于e2e测试，您必须创建一个新的`environment.e2e.ts`文件，其中包含特定的环境变量，并在`.angular-cli.json`中的`environments`下注册它为`"e2e":
    "environments/environment.e2e.ts"`。现在，您可以在`app.module.ts`中导入`environment.ts`，检查环境变量，并在需要时执行自定义逻辑；例如，提供模拟等等。为了使其工作，应用程序应该以`ng
    serve --env=e2e`启动。'
- en: Writing automated UI tests at a glance
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一览自动化UI测试
- en: This section describes the syntax of Protractor tests as well as the *Page Object*
    and *Page Element* design patterns, which are the best practices for the e2e testing.
    Armed with this knowledge, we will write a complete e2e test for the demo application
    introduced in [Chapter 9](2d7dd952-def7-41fa-bc5a-0fafbbd20eba.xhtml), *Miscellaneous
    Use Cases and Best Practices,* in the section *Displaying confirmation dialog
    with guarded routes*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了 Protractor 测试的语法，以及 *Page Object* 和 *Page Element* 设计模式，这些是最佳的 e2e 测试实践。掌握了这些知识，我们将为
    [第 9 章](2d7dd952-def7-41fa-bc5a-0fafbbd20eba.xhtml) 中介绍的演示应用编写一个完整的 e2e 测试，*杂项用例和最佳实践*，在
    *使用受保护的路由显示确认对话框* 部分。
- en: Browser object, element, and locators
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器对象、元素和定位器
- en: 'The browser object is a globally created wrapper around an instance of `WebDriver`.
    It is used for navigation and page-wide information. With `browser.get()`, you
    can navigate to a page and then check the page''s title as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器对象是围绕 `WebDriver` 实例全局创建的包装器。它用于导航和页面范围的信息。使用 `browser.get()`，您可以导航到一个页面，然后检查页面的标题，如下所示：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The current URL is returned by `browser.getCurrentUrl()`. For example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当前 URL 可以通过 `browser.getCurrentUrl()` 返回。例如：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Other global objects created by Protractor are `element` and `by`. `element`
    is a helper function for finding DOM elements on the page you are testing. It
    requires one parameter--a *locator* for locating the element. Locators are created
    using the `by` object. There is a range of locators. We will only mention a few
    of them. For a full list, read the official API documentation ([http://www.protractortest.org/#/api](http://www.protractortest.org/#/api)).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor 创建的其他全局对象是 `element` 和 `by`。`element` 是一个帮助函数，用于在测试的页面上查找 DOM 元素。它需要一个参数--用于定位元素的
    *定位器*。定位器是使用 `by` 对象创建的。有各种定位器。我们只会提到其中一些。要获取完整列表，请阅读官方 API 文档 ([http://www.protractortest.org/#/api](http://www.protractortest.org/#/api))。
- en: 'The `by.css` selector locates elements using a CSS selector. For example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`by.css` 选择器使用 CSS 选择器定位元素。例如：'
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `by.id` selector locates an element by its ID. For example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`by.id` 选择器通过其 ID 定位元素。例如：'
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `by.tagName` selector locates elements with a given tag name. For example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`by.tagName` 选择器定位具有给定标记名称的元素。例如：'
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that for Angular 2+ apps, the `by.binding` and `by.model` locators are
    not supported. They are only supported for Angular 1.x.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于 Angular 2+ 应用程序，不支持 `by.binding` 和 `by.model` 定位器。它们仅支持 Angular 1.x。
- en: 'The `element` function returns an `ElementFinder` object, which can be used
    to interact with the underlying DOM element or get information from it. The following
    table lists the most important methods of `ElementFinder`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`element` 函数返回一个 `ElementFinder` 对象，可以用于与底层 DOM 元素交互或从中获取信息。以下表格列出了 `ElementFinder`
    的最重要方法：'
- en: '| **Method** | **Description** |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `getText()` | Returns the text of an element. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `getText()` | 返回元素的文本。 |'
- en: '| `click()` | Executes a click on an element. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `click()` | 在元素上执行点击。 |'
- en: '| `sendKeys(keys)` | Sends passed in characters to an element (useful for filling
    in forms). |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `sendKeys(keys)` | 将传入的字符发送到元素（用于填写表单）。 |'
- en: '| `element(locator)` | Finds child elements within a parent (this element)
    by a given locator. It returns the first found child element as an object of type
    `ElementFinder`. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `element(locator)` | 通过给定的定位器在父元素（此元素）中查找子元素。它将第一个找到的子元素作为 `ElementFinder`
    类型的对象返回。 |'
- en: '| `all(locator)` | Finds child elements within a parent (this element) by a
    given locator. It returns an array of all found child elements as an object of
    type `ElementArrayFinder`. The `ElementArrayFinder` object has a lot of useful
    methods. For instance, `count()` provides a count of found elements, `get(index:
    number)` provides an element at a specified position in the array. For more information,
    read the API documentation. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `all(locator)` | 通过给定的定位器在父元素（此元素）中查找子元素。它将返回一个`ElementArrayFinder`类型的对象，其中包含所有找到的子元素的数组。`ElementArrayFinder`对象具有许多有用的方法。例如，`count()`提供找到的元素数量，`get(index:
    number)`在数组中提供指定位置的元素。有关更多信息，请阅读API文档。|'
- en: '| `getId()` | Gets the ID of the DOM element. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `getId()` | 获取DOM元素的ID。|'
- en: '| `isDisplayed()` | Checks whether the DOM element is visible. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `isDisplayed()` | 检查DOM元素是否可见。|'
- en: '| `isEnabled()` | Checks whether the DOM element is enabled. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `isEnabled()` | 检查DOM元素是否已启用。|'
- en: 'Let''s see two examples, and check if an element with the style class `info`
    is displayed (visible) as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看两个例子，并检查具有样式类`info`的元素是否显示（可见）如下：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The next code snippet checks if a button is clickable:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码片段检查按钮是否可点击：
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Be careful with animations. When an element appears after some animation, it
    is reasonable to wait for an animation end. To achieve that, use `browser.wait()`
    as `browser.wait(element(by.id('id')).isDisplayed()).toBe(true)`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要小心动画。当元素在一些动画之后出现时，等待动画结束是合理的。为了实现这一点，使用`browser.wait()`，如`browser.wait(element(by.id('id')).isDisplayed()).toBe(true)`。
- en: 'Be aware that access operations for DOM elements return promises and not elements
    themselves. It concerns, for example, `getText()`, `count()`, and so on. Protractor
    patches Jasmine''s `expect()` function so that it waits automatically until the
    promise gets resolved and the located DOM element is accessible. After that, the
    matcher will be applied. This is convenient, but there are some cases where you
    need an access to the value of the resolved promise. In these cases, you can use
    the promise''s `then()` function explicitly. Assume you want to output the count
    of rows within a table. The next code snippet exemplifies the idea:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对DOM元素的访问操作返回的是promise而不是元素本身。例如，`getText()`，`count()`等。Protractor修补了Jasmine的`expect()`函数，以便自动等待直到promise得到解决并且定位的DOM元素可访问。之后，将应用匹配器。这很方便，但也有一些情况下，您需要访问已解决promise的值。在这些情况下，您可以显式使用promise的`then()`函数。假设您想要输出表格中行的数量。下面的代码片段举例说明了这个想法：
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Clean architecture with Page Objects
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用页面对象的清洁架构
- en: 'A Page Object encapsulates the behavior of a web page. In single-page applications,
    we have views. For the sake of convenience, if we say "web page," we will mean
    both full page and view. There is one Page Object per web page that abstracts
    the page''s logic to the outside. That means the interaction with the web page
    is encapsulated in the Page Object. The e2e tests operate on Page Objects. Take
    an example from a web shop: the Page Objects could be written as classes: `ProductPage`,
    `ShoppingCartPage`, `PaymentPage`, and so on.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 页面对象封装了网页的行为。在单页面应用程序中，我们有视图。为了方便起见，如果我们说“网页”，我们将指代完整页面和视图。每个网页都有一个页面对象，将页面的逻辑抽象到外部。这意味着与网页的交互被封装在页面对象中。端到端测试操作页面对象。以网店为例：页面对象可以编写为类：`ProductPage`，`ShoppingCartPage`，`PaymentPage`等等。
- en: A Page Element (aka *HTML Wrapper*) is another subdivision of a web page. It
    represents an HTML element and encapsulates the logic for the interaction with
    this element. For instance, an HTML Wrapper for DatePicker can provide the API
    methods such as "set a date into the input field," "open the calendar popup,"
    and "choose given day in the calendar popup". An HTML Wrapper can be composite;
    that means, it can consist of multiple small elements. For instance, a product
    catalog consists of products, a shopping cart consists of items, and so on.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 页面元素（又称*HTML包装器*）是网页的另一个细分。它代表一个HTML元素，并封装了与该元素交互的逻辑。例如，一个DatePicker的HTML包装器可以提供API方法，如“将日期设置到输入字段中”、“打开日历弹出窗口”和“在日历弹出窗口中选择给定的日期”。HTML包装器可以是复合的；这意味着它可以由多个小元素组成。例如，产品目录由产品组成，购物车由商品组成，等等。
- en: 'Page Objects and HTML Wrappers as design patterns were described by Martin
    Fowler ([https://martinfowler.com/bliki/PageObject.html](https://martinfowler.com/bliki/PageObject.html)).
    There are a lot of advantages with this architecture:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Martin Fowler（[https://martinfowler.com/bliki/PageObject.html](https://martinfowler.com/bliki/PageObject.html)）描述了页面对象和HTML包装器作为设计模式。这种架构有很多优势：
- en: Clean separation between test code and page-specific code.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试代码与特定页面代码之间的清晰分离。
- en: The `by` locators to find elements on the page are not disclosed to the outside.
    The Page Object's caller never bothers with the `by` locators.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在页面上查找元素的`by`定位器不会透露给外部。页面对象的调用者从不需要关心`by`定位器。
- en: If some UI changes for any page, you don't need to change the corresponding
    tests. We just need to change the code at one place--within the Page Object.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果页面发生了一些UI更改，您不需要更改相应的测试。我们只需要在一个地方更改代码——在页面对象内部。
- en: Page Objects reduce the amount of duplicated code. If the tests share the same
    scenario, you don't need to copy/paste your code. Write once, share everywhere!
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面对象减少了重复代码的数量。如果测试共享相同的场景，您就不需要复制/粘贴代码。只需编写一次，随处共享！
- en: The spec files are more readable and more compact--one glance at the code and
    we know what the test does.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规范文件更易读，更紧凑——一眼看到代码，我们就知道测试的功能。
- en: 'The next code snippet demonstrates a simple Page Object for an imaginary login
    page:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码片段演示了一个想象中的登录页面的简单页面对象：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As you see, many steps were extracted into one method. The test code using
    `LoginPage` is concise:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，许多步骤被提取到一个方法中。使用`LoginPage`的测试代码是简洁的：
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: A spec file should be grouped with the corresponding Page Object in the same
    folder. It is a best practice to use the `.po.ts` suffix for the Page Object files.
    For example, the Page Object file for the login page is called `login.po.ts`.
    For Page Element files, we suggest to use the `.pe.ts` suffix; for example, `dialog.pe.ts`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 规范文件应该与相应的页面对象分组放在同一个文件夹中。最佳实践是为页面对象文件使用`.po.ts`后缀。例如，登录页面的页面对象文件称为`login.po.ts`。对于页面元素文件，我们建议使用`.pe.ts`后缀；例如，`dialog.pe.ts`。
- en: Writing complete the e2e test
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写完整的端到端测试
- en: 'We are going to write e2e specs testing the UI from *Displaying confirmation
    dialog with guarded routes* of [Chapter 9](2d7dd952-def7-41fa-bc5a-0fafbbd20eba.xhtml),
    *Miscellaneous Use Cases and Best Practices*. Just to recap: the first view has
    an input field (username) with a submit button. The button triggers a navigation
    to the second view. Whenever the user changes the username, a confirmation dialog
    with the text You have unsaved changes. Are you sure you want to leave this page?
    will appear. The user can click on Yes or No. We want to write five test cases
    that verify:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写端到端的规范，测试UI从[第9章](2d7dd952-def7-41fa-bc5a-0fafbbd20eba.xhtml)的*显示受保护路由的确认对话框*，*杂项用例和最佳实践*。简而言之：第一个视图有一个带有提交按钮的输入字段（用户名）。按钮触发导航到第二个视图。每当用户更改用户名时，将出现一个带有文本“您有未保存的更改。您确定要离开此页面吗？”的确认对话框。用户可以点击“是”或“否”。我们想要编写五个测试用例来验证：
- en: Whether the first page has a proper title displayed within the `h1` tag
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一页是否在`h1`标签中显示适当的标题
- en: Whether the navigation happens when no input exists
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当没有输入时导航是否发生
- en: Whether a confirmation dialog gets displayed when an input exists
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当输入存在时，确认对话框是否显示
- en: Whether the user leaves the current view when clicking on Yes
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户在点击“是”时是否离开当前视图
- en: Whether the user stays on the current view when clicking on No
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户在点击“否”时是否停留在当前视图
- en: 'Before writing specs, we need a Page Object called `FirstViewPage`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写规范之前，我们需要一个名为`FirstViewPage`的页面对象：
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The Page Element `ConfirmDialogPageElement` encapsulates the internal structure
    details of the confirmation dialog. It offers three methods to ask for the dialog''s
    visibility and to interact with the Yes and No buttons:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 页面元素`ConfirmDialogPageElement`封装了确认对话框的内部结构细节。它提供三种方法来询问对话框的可见性并与“是”和“否”按钮交互：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`$()` is a handy shortcut notation for `element(by.css())`. The `by.xpath(''..'')`
    locator allows to select the parent element.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`$()`是`element(by.css())`的一个方便的快捷符号。`by.xpath(''..'')`定位器允许选择父元素。'
- en: 'The specs themselves are clean--they invoke public APIs from `FirstViewPage`
    and `ConfirmDialogPageElement`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 规范本身很干净-它们调用`FirstViewPage`和`ConfirmDialogPageElement`的公共API：
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The next screenshot shows spec reports in IntelliJ/WebStorm:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个屏幕截图显示了在IntelliJ/WebStorm中的规范报告：
- en: '![](assets/e3a4df7f-cf87-49f9-bc39-a042e1f15f21.png)The complete project with
    instructions is available on GitHub at'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/e3a4df7f-cf87-49f9-bc39-a042e1f15f21.png)完整的项目及说明可在GitHub上找到'
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter10/e2e-testing](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter10/e2e-testing).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter10/e2e-testing](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter10/e2e-testing)。'
- en: Exploring a PrimeNG application with Augury and ng.probe
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Augury和ng.probe探索PrimeNG应用程序
- en: Augury is a Google Chrome browser extension for inspecting Angular 2+ applications
    ([https://augury.angular.io/](https://augury.angular.io/)). The tool visualizes
    the application through a component tree, router tree, module dependencies, and
    more. Developers immediately see the application structure, change detection,
    and other useful characteristics. They can explore relationships between several
    building blocks, such as components, services, routes, modules, injectors, and
    so on. Augury is interactive. It allows for modifying application states and emitting
    events.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Augury是用于检查Angular 2+应用程序的Google Chrome浏览器扩展（[https://augury.angular.io/](https://augury.angular.io/)）。该工具通过组件树、路由器树、模块依赖关系等可视化应用程序。开发人员立即看到应用程序结构、变更检测和其他有用的特性。他们可以探索几个构建块之间的关系，例如组件、服务、路由、模块、注入器等。Augury是交互式的。它允许修改应用程序状态并发出事件。
- en: 'You can install Augury from the Chrome Web Store: [https://chrome.google.com/webstore/detail/augury/elgalmkoelokbchhkhacckoklkejnhcd](https://chrome.google.com/webstore/detail/augury/elgalmkoelokbchhkhacckoklkejnhcd).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从Chrome网络商店安装Augury：[https://chrome.google.com/webstore/detail/augury/elgalmkoelokbchhkhacckoklkejnhcd](https://chrome.google.com/webstore/detail/augury/elgalmkoelokbchhkhacckoklkejnhcd)。
- en: 'Once the plugin has been successfully installed, you will see a new Augury
    tab in the Chrome Developer Tools (DevTools). Shortcuts for opening the DevTools:
    *F12* (Windows), *Command* + *Option* + *I* (Mac).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦插件成功安装，您将在Chrome开发者工具（DevTools）中看到一个新的Augury选项卡。打开DevTools的快捷键：*F12*（Windows），*Command*
    + *Option* + *I*（Mac）。
- en: There is another way to explore Angular 2+ applications. In the development
    mode, Angular exposes a global `ng.probe` function, which takes native DOM element
    and returns corresponding debug elements. With the debug element, you can inspect
    the current state of components, injectors, listeners, trigger events, and so
    on. The `ng.probe` function is accessible in the browser's console.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种探索Angular 2+应用程序的方法。在开发模式下，Angular公开了一个全局的`ng.probe`函数，该函数接受原生DOM元素并返回相应的调试元素。使用调试元素，您可以检查组件、注射器、监听器的当前状态，触发事件等。`ng.probe`函数可以在浏览器的控制台中访问。
- en: In this section, we will apply both Augury and `ng.probe` to the already known
    CRUD demo application from [Chapter 9](2d7dd952-def7-41fa-bc5a-0fafbbd20eba.xhtml),
    *Miscellaneous Use Cases and Best Practices*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将对已知的CRUD演示应用程序应用Augury和`ng.probe`，该应用程序来自[第9章](2d7dd952-def7-41fa-bc5a-0fafbbd20eba.xhtml)，*杂项用例和最佳实践*。
- en: Augury in action
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Augury在操作中
- en: 'The first visible view in Augury is the Component Tree, which shows loaded
    components. Selecting a component within the tree highlights the component''s
    template within the browser. At the same time, additional information about the
    selected component is presented on the right side in the Properties tab. Let''s
    select `DataTableCrudComponent`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Augury中第一个可见的视图是组件树，显示了加载的组件。在树中选择一个组件会突出显示浏览器中组件的模板。同时，在属性选项卡的右侧呈现有关所选组件的附加信息。让我们选择`DataTableCrudComponent`：
- en: '![](assets/88e03f87-fad4-4470-a307-c87816df9891.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/88e03f87-fad4-4470-a307-c87816df9891.png)'
- en: 'You see all the internal properties, inputs, and outputs. All the properties
    are editable. The next screenshot shows the properties of the Dialog component.
    The output property `visibleChange` is an event emitter. We can trigger the event
    emitter by setting the value to `true` and clicking on the button Emit. In response,
    the dialog becomes visible:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到所有内部属性、输入和输出。所有属性都是可编辑的。下一张屏幕截图显示了对话框组件的属性。输出属性`visibleChange`是一个事件发射器。我们可以通过将值设置为`true`并单击“Emit”按钮来触发事件发射器。作为响应，对话框变得可见：
- en: '![](assets/3222f6ee-ae1b-4b13-8751-50ab146e8232.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3222f6ee-ae1b-4b13-8751-50ab146e8232.png)'
- en: 'Next to the Properties tab is the Injector Graph, which displays the dependencies
    of components and services. If we select the DataTable component, the dependency
    of the DataTable and its ancestry chain to the root injector will be shown:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性选项卡旁边是注射器图，显示了组件和服务的依赖关系。如果我们选择DataTable组件，则将显示DataTable的依赖关系及其祖先链到根注射器：
- en: '![](assets/12772ffa-326a-4b6d-a797-cbcc4fe07a7a.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/12772ffa-326a-4b6d-a797-cbcc4fe07a7a.png)'
- en: The circle symbols for services need to be clarified. The hollow red circle
    means the service is not provided by the component. It is provided from an ancestor
    in the dependency tree. A dashed blue line shows exactly where the service comes
    from. In our case, all services are provided by the root injector--the main module
    declaration in `app.module.ts`. The filled red circle means the service is being
    injected and registered in the same component.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的圆形符号需要澄清。空心红色圆圈表示该服务不是由组件提供的，而是来自依赖树中的祖先。虚线蓝线显示了服务的确切来源。在我们的情况下，所有服务都是由根注入器提供的——即`app.module.ts`中的主模块声明。填充的红色圆圈表示该服务正在被注入并在同一组件中注册。
- en: 'The Router Tree gives you a tree view of all the routes in your application.
    You can explore which routes come from which parts of the application. We will
    skip the appropriate screenshot. The next tab, NgModules, lists all the modules
    in the application, along with the modules'' imports, exports, providers, and
    declarations. An insight into NgModules gives the complexity and size of the available
    modules:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器树为您提供了应用程序中所有路由的树状视图。您可以探索哪些路由来自应用程序的哪些部分。我们将跳过适当的截图。下一个选项卡 NgModules 列出了应用程序中的所有模块，以及模块的导入、导出、提供者和声明。对
    NgModules 的了解可以了解可用模块的复杂性和大小：
- en: '![](assets/bacde7c2-9473-4897-9b53-2cdba7f2b022.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bacde7c2-9473-4897-9b53-2cdba7f2b022.png)'
- en: Debugging with ng.probe
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `ng.probe` 进行调试
- en: By default, Angular runs in the development mode and builds a *debugging elements
    tree*--a tree, which has almost the same structure as a rendered DOM, but with
    objects of type `DebugElement`. Whenever `ng.probe(element)` is invoked in the
    browser console, a corresponding debug element is returned. The `DebugElement`
    class extends `DebugNode` ([https://angular.io/docs/ts/latest/api/core/index/DebugNode-class.html](https://angular.io/docs/ts/latest/api/core/index/DebugNode-class.html)).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Angular 在开发模式下运行并构建一个*调试元素树*——一个树，其结构几乎与呈现的 DOM 相同，但具有 `DebugElement`
    类型的对象。每当在浏览器控制台中调用 `ng.probe(element)` 时，都会返回相应的调试元素。`DebugElement` 类扩展了 `DebugNode`
    ([https://angular.io/docs/ts/latest/api/core/index/DebugNode-class.html](https://angular.io/docs/ts/latest/api/core/index/DebugNode-class.html))。
- en: In the production mode, no debugging elements tree is available and you cannot
    debug an Angular application with `ng.probe`. The production mode is enabled with
    `enableProdMode()`, which is a function from Angular's package, `@angular/core`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产模式下，没有调试元素树可用，也无法使用 `ng.probe` 调试 Angular 应用程序。生产模式是通过 Angular 包 `@angular/core`
    中的 `enableProdMode()` 函数启用的。
- en: 'Let''s see how to use public methods of the exposed `DebugElement`. First of
    all, we need to select a DOM element in DevTools. This keeps a reference to the
    selected DOM node in the variable `$0`, which can then be accessed from the console.
    In the CRUD application, we will select the Add button, as shown in the following
    screenshot:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用公开的 `DebugElement` 的公共方法。首先，我们需要在 DevTools 中选择一个 DOM 元素。这将在变量 `$0`
    中保留对所选 DOM 节点的引用，然后可以从控制台中访问。在 CRUD 应用程序中，我们将选择“添加”按钮，如下截图所示：
- en: '![](assets/aab4ac62-daf6-4481-8ab5-ce1b06efdf19.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aab4ac62-daf6-4481-8ab5-ce1b06efdf19.png)'
- en: 'Now, we are able to get a reference to the component instance the button belongs
    to. Once we have that instance, we can interact with it; for example, we can change
    properties, and so on. Let''s reset the array of `employees`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们能够获取按钮所属的组件实例的引用。一旦我们有了该实例，我们就可以与之交互；例如，我们可以更改属性等。让我们重置`employees`数组：
- en: '[PRE48]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Selecting any element within the component template will always provide the
    same component instance.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件模板中选择任何元素将始终提供相同的组件实例。
- en: 'There is one problem--the code explained didn''t change anything in the UI.
    The reason is obvious--we need to invoke the change detector manually. The next
    line is a bit complicated, but does exactly what we need--it runs the change detection
    cycle. As a result, the table with employees becomes empty:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个问题——所解释的代码没有改变UI。原因很明显——我们需要手动调用变更检测器。下一行有点复杂，但确实做到了我们需要的事情——运行变更检测周期。结果，员工表变为空：
- en: '[PRE49]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `injector` property allows accessing all the providers on the component
    and its parents. For instance, assume there is the following provider definition:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`injector`属性允许访问组件及其父级上的所有提供者。例如，假设存在以下提供者定义：'
- en: '[PRE50]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The value `http://someendpoint.com/v1/payment/` can be grabbed with the following
    code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码获取值`http://someendpoint.com/v1/payment/`：
- en: '[PRE51]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The DOM element with the `some` style class should be located within the component
    the defined provider is visible for.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 具有`some`样式类的DOM元素应位于定义提供者可见的组件内部。
- en: 'One interesting use case is the triggering registered event handlers. In the
    demo application, we could select the Add button and trigger the click event on
    this button as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的用例之一是触发注册的事件处理程序。在演示应用程序中，我们可以选择“添加”按钮，并按如下方式触发该按钮的点击事件：
- en: '[PRE52]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This command will open the following dialog:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将打开以下对话框：
- en: '![](assets/aaf215a5-ed6f-4bfa-a46a-0da996927300.png)You might also be interested
    in a graphical analysis tool, *ngrev*, for reverse engineering of Angular projects
    ([https://github.com/mgechev/ngrev](https://github.com/mgechev/ngrev)). With this
    tool, you can explore the structure of your application, and the relationship
    between different modules, providers, and directives without running the application.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/aaf215a5-ed6f-4bfa-a46a-0da996927300.png)您可能还对一个名为*ngrev*的图形分析工具感兴趣，用于反向工程Angular项目（[https://github.com/mgechev/ngrev](https://github.com/mgechev/ngrev)）。使用此工具，您可以探索应用程序的结构，以及不运行应用程序的情况下不同模块、提供者和指令之间的关系。'
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: At the end of this chapter, you should be able to set up the test environment
    for unit and e2e testing. The *de facto* standard unit test framework and runner
    introduced in this chapter were Jasmine and Karma, respectively. You got skills
    in writing unit tests for most used constructs, as well as basic skills in writing
    the e2e test with the Protractor framework.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您应该能够为单元测试和端到端测试设置测试环境。本章介绍的*事实上*标准单元测试框架和运行器分别是Jasmine和Karma。您已经掌握了为大多数常用结构编写单元测试的技能，以及使用Protractor框架编写端到端测试的基本技能。
- en: You are also equipped with useful tips for creating robust applications. The
    `karma-webpack-grep` plugin can give a huge performance boost when booting up
    Karma in development. The Augury tool, as well as `ng.probe`, enable debugging
    and profiling Angular 2+ applications. We hope that the last chapter and the entire
    book will contribute to a flawless development process of your next Angular and
    PrimeNG applications.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以获得有关创建健壮应用程序的有用提示。`karma-webpack-grep`插件在开发中启动Karma时可以大大提高性能。Augury工具以及`ng.probe`可以启用对Angular
    2+应用程序的调试和分析。我们希望本章和整本书能够为您的下一个Angular和PrimeNG应用程序的无缺开发过程做出贡献。
