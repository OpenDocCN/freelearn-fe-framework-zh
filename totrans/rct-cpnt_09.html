<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Thinking of Plugins"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Thinking of Plugins</h1></div></div></div><p>In the previous chapter, we looked at a couple of design patterns that we could use to build our applications. There are reasons for and against the use of Flux and Redux, but they generally improve the structure of React applications.</p><p>A good structure is essential for any large-scale application. Cobbling things together may work for small experiments, but design patterns are an integral part of maintaining anything larger. They do not say much in the way of creating extendable components, though. In this chapter, we're going to look at a few ways that we can use to make our components extendable by replacing them, injecting functionality, and composing interfaces from dynamic lists of components.</p><p>We're going to review a few related software design concepts and take a look at how they can assist us (and others) when we want to replace parts of our application with modified components and alternative implementations.</p><div class="section" title="Dependency injection and service location"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec52"/>Dependency injection and service location</h1></div></div></div><p><span class="emphasis"><em>Dependency injection</em></span> and <span class="emphasis"><em>service location</em></span> are interesting concepts that are not limited to React development. To really understand them, let's move away from components for a while. For a<a id="id210" class="indexterm"/> moment, imagine that we wanted to create a sitemap. To do<a id="id211" class="indexterm"/> this, we could perhaps use code resembling the following code:</p><div class="informalexample"><pre class="programlisting">let backend = {
    getAll() {
        // ...return pages
    }
};
class SitemapFormatter {
    format(items) {
        // ...generate xml from items
    }
}
function createSitemap() {
    const pages = backend.getAll();
    const formatter = new SitemapFormatter();
  
    return formatter.format(
        pages.filter(page =&gt; page.isPublic)
    );
}

let sitemap = createSitemap();</pre></div><p>In this example, <code class="literal">createSitemap</code> has two dependencies. Firstly, we fetch pages from <code class="literal">backend</code>. This is a kind of global storage object. We used something similar to this when we looked at the Flux architecture.</p><p>The second dependency is to the <code class="literal">SitemapFormatter</code> implementation. We use it to take a list of pages and return some kind of markup, summarizing these pages in the list. We're hardcoding both of these dependencies in a way that is okay in small doses, but they are problematic as the application expands.</p><p>For instance, what if <a id="id212" class="indexterm"/>we wanted to use this sitemap generator with multiple backends? What if we also wanted to try alternative implementations of the formatter? Right now, we've coupled the sitemap generator to a single backend and a single formatter implementation.</p><p>Dependency injection and service location are two possible solutions to this problem.</p><div class="section" title="Dependency injection"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec21"/>Dependency injection</h2></div></div></div><p>We've already <a id="id213" class="indexterm"/>used dependency injection, in subtle ways. This looks like the following:</p><div class="informalexample"><pre class="programlisting">function createSitemap(<span class="strong"><strong>backend, formatter</strong></span>) {
    const pages = backend.getAll();
  
    return formatter.format(
        pages.filter(page =&gt; page.isPublic)
    );
}

<span class="strong"><strong>let formatter = new SitemapFormatter();</strong></span>
let sitemap = createSitemap(<span class="strong"><strong>backend, formatter</strong></span>);</pre></div><p>Dependency injection is all about moving dependencies out of the functions and classes that use them. This is not about avoiding their use; but rather it is creating new instances outside and passing them in through function parameters.</p><p>There are two<a id="id214" class="indexterm"/> kinds of dependency injection: constructor injection and setter injection. This may illustrate the difference:</p><div class="informalexample"><pre class="programlisting">class SitemapGenerator {
    <span class="strong"><strong>constructor(formatter) {</strong></span>
        <span class="strong"><strong>this._formatter = formatter;</strong></span>
    <span class="strong"><strong>}</strong></span>
  
    <span class="strong"><strong>set formatter(formatter) {</strong></span>
        <span class="strong"><strong>this._formatter = formatter;</strong></span>
    <span class="strong"><strong>}</strong></span>
}

<span class="strong"><strong>let generator = new SitemapGenerator(new SitemapFormatter());</strong></span>

<span class="strong"><strong>generator.formatter = new AlternativeSitemapFormatter();</strong></span>
</pre></div><p>We can inject dependencies through the constructor and assign them to properties, or we can create setters for them. We saw constructor injection a few times already, but setter injection is another valid means of injecting dependencies. We could also use normal functions to inject dependencies, but then we wouldn't be able to set or get them through object properties.</p><p>Similarly, when we define component properties, we're essentially injecting these property values as constructor dependencies.</p></div><div class="section" title="Factories and service locators"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec22"/>Factories and service locators</h2></div></div></div><p>An alternative solution <a id="id215" class="indexterm"/>would be to encapsulate the logic to create new<a id="id216" class="indexterm"/> instances and use references to this factory-like object when looking for dependencies:</p><div class="informalexample"><pre class="programlisting">class Factory {
    <span class="strong"><strong>createNewFormatter() {</strong></span>
        <span class="strong"><strong>// ...create new formatter instance</strong></span>
    <span class="strong"><strong>}</strong></span>
  
    <span class="strong"><strong>getSharedBackend() {</strong></span>
        <span class="strong"><strong>// ...get shared backend instance</strong></span>
    <span class="strong"><strong>}</strong></span>
}

const factory = new Factory();

<span class="strong"><strong>const formatter = factory.createNewFormatter();</strong></span>
<span class="strong"><strong>const backend = factory.getSharedBackend();</strong></span>
</pre></div><p>We can then<a id="id217" class="indexterm"/> pass around an instance of the <code class="literal">Factory</code> class, or even inject this as a <a id="id218" class="indexterm"/>dependency. In other dynamic languages, such as PHP, this has become a common practice. We can then use these factories to create new instances that are based on some initial criteria. We can have a factory to create new database connections and connect to MySQL or SQLite, which is based on a connection type that we specify.</p><p>An alternative would be to create a number of objects and store them inside a common service locator object:</p><div class="informalexample"><pre class="programlisting">let locator = new ServiceLocator();
locator.set("formatter", new Formatter());
locator.set("backend", new Backend());</pre></div><p>Likewise, we can inject the locator as a dependency and fetch the actual dependencies, as needed:</p><div class="informalexample"><pre class="programlisting">class SitemapGenerator {
    constructor(locator) {
        this.formatter = locator.get("formatter");
        this.backend = locator.get("backend");
    }
}

let generator = new SitemapGenerator(locator);</pre></div></div><div class="section" title="Fold"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec23"/>Fold</h2></div></div></div><p>Fortunately, we do not <a id="id219" class="indexterm"/>need to build and maintain factories, dependency injectors, and service locators. There are already many to choose from, especially in JavaScript. We will discuss one in particular. Remember when we discussed rendering React components on the server? We looked at an MVC application framework, called AdonisJS.</p><p>The creator of AdonisJS also maintains a dependency injection container, called <span class="emphasis"><em>Fold</em></span>. Some of the things that Fold does is interesting, and we want to share them with you.</p><p>We can install Fold using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save adonis-fold</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note50"/>Note</h3><p>In previous chapters, we created a workflow to run ES6 code through Node.js. We recommend that you re-create this setup for some of the code in this chapter.</p></div></div><p>We can then start to<a id="id220" class="indexterm"/> use it to register and resolve objects:</p><div class="informalexample"><pre class="programlisting">import { Ioc } from "adonis-fold";

Ioc.bind("App/Authenticator", function() {
    // ...return a new authenticator object
});

let authenticator = Ioc.use("App/Authenticator");</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note51"/>Note</h3><p>Fold introduces a global <code class="literal">use</code> function, so we could use it without needing to import <code class="literal">Ioc</code> each time.</p></div></div><p>We use <code class="literal">bind</code> to assign an alias to a factory-like function. When this alias is <span class="emphasis"><em>used</em></span>, this factory function will be called and the result returned. This becomes even more powerful when we have large dependency graphs:</p><div class="informalexample"><pre class="programlisting">Ioc.bind("App/Authenticator", function() {
    const repository = <span class="strong"><strong>Ioc.use("App/UserRepository")</strong></span>;
    const crypto = <span class="strong"><strong>Ioc.use("App/Crypto")</strong></span>;

    return <span class="strong"><strong>new Authenticator(repository, crypto)</strong></span>;
});</pre></div><p>We can compose calls to <code class="literal">bind</code> and <code class="literal">use</code>. In this example, creating a new <code class="literal">App/Authenticator</code> will in turn resolve <code class="literal">App/UserRepository</code> and <code class="literal">App/Crypto</code> from the container.</p><p>What's more is that we can use Fold to load class files automatically. So, let's suppose that we have an <code class="literal">Authenticator</code> class file resembling the following (in <code class="literal">src/Authenticator.js</code>):</p><div class="informalexample"><pre class="programlisting">class Authenticator {
    // ...do some authentication!
}

module.exports = Authenticator;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note52"/>Note</h3><p>Usually we export classes or functions with <code class="literal">export default ...</code>; but in this case, we're just assigning the class to <code class="literal">module.exports</code>. This makes it easier for Fold to do more interesting things with our code.</p></div></div><p>We can autoload this with the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Ioc.autoload("App", __dirname + "/src")</strong></span>;

const Authenticator = <span class="strong"><strong>Ioc.use("App/Authenticator")</strong></span>;

let authenticator = new Authenticator();</pre></div><p>We can also use<a id="id221" class="indexterm"/> regular classes as singletons with a slightly different binding syntax:</p><div class="informalexample"><pre class="programlisting">Ioc.<span class="strong"><strong>singleton</strong></span>("App/Backend", function() {
    // ...this will only be run once!
<span class="strong"><strong>    return new Backend();</strong></span>
});
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note53"/>Note</h3><p>The <code class="literal">use</code> works in the same way, whether you use <code class="literal">bind</code> or <code class="literal">singleton</code>.</p></div></div><p>Fold really shines when it comes to resolving dependencies recursively. Let's change <code class="literal">Authenticator</code>:</p><div class="informalexample"><pre class="programlisting">
class Authenticator {
    <span class="strong"><strong>static get inject() {</strong></span>
        <span class="strong"><strong>return ["App/Repository", "App/Crypto"];</strong></span>
    <span class="strong"><strong>}</strong></span>

    constructor(<span class="strong"><strong>repository, crypto</strong></span>) {
        <span class="strong"><strong>this.repository = repository;</strong></span>
        <span class="strong"><strong>this.crypto = crypto;</strong></span>
    }
}

module.exports = Authenticator;</pre></div><p>We can use getters (a feature of ES6) to overload property access for a static <code class="literal">inject</code> property. This just means that a function will be run whenever we write <code class="literal">Authenticator.inject</code>. Fold uses this static array property to work out which dependencies<a id="id222" class="indexterm"/> to resolve. Therefore, we can create <code class="literal">Repository</code> (in <code class="literal">src/Repository.js</code>), as follows:</p><div class="informalexample"><pre class="programlisting">class Repository {
    // ...probably fetches users from a data source
}

module.exports = Repository;</pre></div><p>We can also create <code class="literal">Crypto</code> (in <code class="literal">src/Crypto.js</code>), as follows:</p><div class="informalexample"><pre class="programlisting">class Crypto {
    // ...probably performs cryptographic comparisons
}

module.exports = Crypto;</pre></div><p>The function of these classes isn't important. What is important is how Fold connects them together:</p><div class="informalexample"><pre class="programlisting">Ioc.autoload("App", __dirname + "/src");

let authenticator = Ioc.make("App/Authenticator");</pre></div><p>The first line creates a link between the <code class="literal">App/</code> class prefix and the class files that we want to load. Therefore, a class in <code class="literal">src/Foo/Bar.js</code> will be loaded when we create <code class="literal">App/Foo/Bar</code>. Similarly, aliases defined in the static inject array property will be connected to their relevant constructor parameters when we use <code class="literal">Ioc.make</code>.</p></div><div class="section" title="Why this matters"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec24"/>Why this matters</h2></div></div></div><p>If we inject dependencies, we can easily replace one part of an application with another because<a id="id223" class="indexterm"/> dependencies aren't named within the classes that depend on them. These classes aren't responsible for creating new instances, only receiving instances created on the outside.</p><p>If we use a service locator (especially one that resolves dependencies recursively), we can avoid a lot of boilerplate during a bootstrapping phase.</p><p>What do we gain from being able to replace parts of our application?</p><p>We allow other developers to inject behavior into our application by replacing core parts of the application. Imagine we have the following <code class="literal">Authenticator</code> method:</p><div class="informalexample"><pre class="programlisting">class Authenticator {
    static get inject() {
        return ["App/Repository", "App/Crypto"];
    }

    constructor(repository, crypto) {
        this.repository = repository;
        this.crypto = crypto;
    }

    <span class="strong"><strong>authenticate(email, password) {</strong></span>
        <span class="strong"><strong>// ...authenticate the user details</strong></span>
    <span class="strong"><strong>}</strong></span>
}</pre></div><p>Now imagine that we want to add logging to all authentication. We can change the <code class="literal">Authenticator</code> <a id="id224" class="indexterm"/>class directly. This is easy if we <span class="emphasis"><em>own</em></span> the code, but we often use third-party libraries. We can create a decorator (in <code class="literal">src/AuthenticatorLogger.js</code>):</p><div class="informalexample"><pre class="programlisting">class AuthenticatorLogger {
    <span class="strong"><strong>static get inject() {</strong></span>
        <span class="strong"><strong>return ["App/Authenticator"];</strong></span>
    <span class="strong"><strong>}</strong></span>

    constructor(<span class="strong"><strong>authenticator</strong></span>) {
        <span class="strong"><strong>this.authenticator = authenticator;</strong></span>
    }

    <span class="strong"><strong>authenticate(email, password) {</strong></span>
        <span class="strong"><strong>this.log("authentication attempted");</strong></span>
        <span class="strong"><strong>return this.authenticator.authenticate(email, password);</strong></span>
    <span class="strong"><strong>}</strong></span>

    <span class="strong"><strong>log(message) {</strong></span>
        <span class="strong"><strong>// ...store the log message</strong></span>
    <span class="strong"><strong>}</strong></span>
}

module.exports = AuthenticatorLogger;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note54"/>Note</h3><p>Decorators are classes that augment the functionality of other classes, usually by composing an<a id="id225" class="indexterm"/> instance of the class that they augment. You can learn more about this pattern at <a class="ulink" href="https://en.wikipedia.org/wiki/Decorator_pattern">https://en.wikipedia.org/wiki/Decorator_pattern</a>.</p></div></div><p>This new class expects an <code class="literal">Authenticator</code> dependency and adds transparent logging to the <code class="literal">authenticate</code> method. We can override the default (autoload) behavior by rebinding <code class="literal">App/Authenticator</code>:</p><div class="informalexample"><pre class="programlisting">const Authenticator = Ioc.use("App/Authenticator");
const AuthenticatorLogger = Ioc.use("App/AuthenticatorLogger");

Ioc.bind<span class="strong"><strong>("App/Authenticator"</strong></span>, function() {
    <span class="strong"><strong>return new AuthenticatorLogger(Ioc.make(Authenticator));</strong></span>
});

let authenticator = Ioc.make("App/Authenticator");</pre></div><p>Let's think about this<a id="id226" class="indexterm"/> in terms of components. Imagine that we have a list of pages that are presented to us by a <code class="literal">PagesComponent</code> component (in <code class="literal">src/Page.js</code>):</p><div class="informalexample"><pre class="programlisting">import React from "react";

class PagesComponent extends React.Component {
    constructor(props, context) {
        super(props, context);
        // ...get context.store state
    }
    componentDidMount() {
        // ...add context.store change listener
    }
    componentWillUnmount() {
        // ...remove context.store change listener
    }
    render() {
        // ...return a list of pages
        return &lt;div&gt;pages&lt;/div&gt;;
    }
}

module.exports = PagesComponent;</pre></div><p>We can autoload this using Fold, as follows:</p><div class="informalexample"><pre class="programlisting">import React from "react";
import ReactDOMServer from "react-dom/server";

const PagesComponent = Ioc.use("App/PagesComponent");

let rendered = ReactDOMServer.renderToString(
    &lt;PagesComponent /&gt;
);</pre></div><p>Now, imagine that another developer came along and wanted to add some extra chrome around the list of<a id="id227" class="indexterm"/> pages. They could dig into the <code class="literal">node_modules</code> folder and directly edit the component, but this would be messy. Instead (and as we're using a dependency injection container), they can override the alias to <code class="literal">App/PagesComponent</code>:</p><div class="informalexample"><pre class="programlisting">const PagesComponent = Ioc.use("App/PagesComponent");

<span class="strong"><strong>Ioc.bind("App/PagesComponent{}", function() {</strong></span>
    <span class="strong"><strong>return (</strong></span>
        <span class="strong"><strong>&lt;PagesComponent /&gt;</strong></span>
    <span class="strong"><strong>);</strong></span>
<span class="strong"><strong>});</strong></span>

// ...then, when we want to decorate the component

class PagesComponentChrome extends React.Component {
    render() {
        return (
            &lt;div className="chrome"&gt;
                {this.props.children}
            &lt;/div&gt;
        )
    }
}

<span class="strong"><strong>Ioc.bind("App/PagesComponent{}", function() {</strong></span>
    <span class="strong"><strong>return (</strong></span>
        <span class="strong"><strong>&lt;PagesComponentChrome&gt;</strong></span>
            <span class="strong"><strong>&lt;PagesComponent /&gt;</strong></span>
        <span class="strong"><strong>&lt;/PagesComponentChrome&gt;</strong></span>
    <span class="strong"><strong>);</strong></span>
<span class="strong"><strong>});</strong></span>

// ...some time later

let rendered = ReactDOMServer.renderToString(
    <span class="strong"><strong>Ioc.use("App/PagesComponent{}")</strong></span>
);</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note55"/>Note</h3><p>Things get a bit tricky when it comes to the <code class="literal">React.Component</code> subclasses versus instances of these subclasses. The <code class="literal">ReactDOM.render</code> and <code class="literal">ReactDOMServer.renderToString</code> expect instances are created when we use <code class="literal">&lt;SomeComponent/&gt;</code> in JSX. This may be helpful to register both forms in the container: bindings for a class reference and bindings for factory functions that create instances of these classes. We've suffixed the latter with <code class="literal">{}</code>, which we can use directly in a <code class="literal">render</code> method.</p></div></div><p>It may be a little <a id="id228" class="indexterm"/>easier to understand this last part by making the following small change:</p><div class="informalexample"><pre class="programlisting">// ...some time later

<span class="strong"><strong>const NewPagesComponent = Ioc.use("App/PagesComponent{}");</strong></span>

let rendered = ReactDOMServer.renderToString(
    &lt;div<span class="strong"><strong>&gt;{NewPagesComponent}</strong></span>&lt;/div&gt;
);</pre></div><p>In this way, we allow other developers to replace parts of the application with custom classes or component decorators. There's definitely some work to be done in terms of creating a team standard for this pattern, but the basic idea is solid.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note56"/>Note</h3><p>You can learn more about <a id="id229" class="indexterm"/>Fold at <a class="ulink" href="http://adonisjs.com/docs/2.0/ioc-container">http://adonisjs.com/docs/2.0/ioc-container</a>.</p></div></div></div></div></div>
<div class="section" title="Extending with callbacks"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec53"/>Extending with callbacks</h1></div></div></div><p>Another method to <a id="id230" class="indexterm"/>create more pluggable components is to expose (and act on) event callbacks. We saw something similar already, but let's take a look at this anyway. Suppose we have a <code class="literal">PageEditorComponent</code> class, as follows:</p><div class="informalexample"><pre class="programlisting">import React from "react";

class PageEditorComponent extends React.Component {
    onSave(e, refs) {
        this.props.onSave(e, refs);
    }
    onCancel(e, refs) {
        this.props.onCancel(e, refs);
    }
    render() {
        let refs = {};

        return (
            &lt;div&gt;
                &lt;input type="text"
                    ref={ref =&gt; refs.title = ref} /&gt;
                &lt;input type="text"
                    ref={ref =&gt; refs.body = ref} /&gt;
                &lt;button onClick={e =&gt; this.onSave(e, refs)}&gt;
                    save
                &lt;/button&gt;
                &lt;button onClick={e =&gt; this.onCancel(e, refs)}&gt;
                    cancel
                &lt;/button&gt;
            &lt;/div&gt;
        );
    }
}

PageEditorComponent.propTypes = {
    "onSave": React.PropTypes.func.isRequired,
    "onCancel": React.PropTypes.func.isRequired
};

module.exports = PageEditorComponent;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note57"/>Note</h3><p>This is another<a id="id231" class="indexterm"/> bit of code that would run best through one of the workflows<a id="id232" class="indexterm"/> that we created earlier (that allow rendering components in the browser) or <a class="ulink" href="https://jsbin.com">https://jsbin.com</a>. We're interested in looking at some dynamic behavior, so it's important that we can click on things!</p></div></div><p>As we saw earlier, we can pass <code class="literal">onSave</code> and <code class="literal">onCancel</code> callbacks through properties from some higher component. Each React component can have a <code class="literal">ref</code> callback. A reference to the DOM node is passed to this callback, so we can use methods such as <code class="literal">focus</code> and properties such as <code class="literal">value</code>. This works well to synchronize state with a common backend or store. However, what can we do to add some custom validation?</p><p>We can add <a id="id233" class="indexterm"/>optional callback properties (and <code class="literal">propTypes</code>) and incorporate these in our <code class="literal">onSave</code> and <code class="literal">onCancel</code> methods:</p><div class="informalexample"><pre class="programlisting">class PageEditorComponent extends React.Component {
    onSave(e, refs) {
        <span class="strong"><strong>if (this.props.onBeforeSave) {</strong></span>
            <span class="strong"><strong>if (!this.props.onBeforeSave(e, refs)) {</strong></span>
                <span class="strong"><strong>return;</strong></span>
            <span class="strong"><strong>}</strong></span>
        <span class="strong"><strong>}</strong></span>

        this.props.onSave(e, refs);

        <span class="strong"><strong>if (this.props.onAfterSave) {</strong></span>
            <span class="strong"><strong>this.props.onAfterSave(e, refs);</strong></span>
        <span class="strong"><strong>}</strong></span>
    }
    onCancel(e, refs) {
        this.props.onCancel(e, refs);
    }
    render() {
        let refs = {};

        return (
            &lt;div&gt;
                &lt;input type="text"
                    ref={ref =&gt; refs.title = ref} /&gt;
                &lt;input type="text"
                    ref={ref =&gt; refs.body = ref} /&gt;
                &lt;button onClick={e =&gt; this.onSave(e, refs)}&gt;
                    save
                &lt;/button&gt;
                &lt;button onClick={e =&gt; this.onCancel(e, refs)}&gt;
                    cancel
                &lt;/button&gt;
            &lt;/div&gt;
        );
    }
}

PageEditorComponent.propTypes = {
    "onSave": React.PropTypes.func.isRequired,
    "onCancel": React.PropTypes.func.isRequired,
    <span class="strong"><strong>"onBeforeSave": React.PropTypes.func,</strong></span>
    <span class="strong"><strong>"onAfterSave": React.PropTypes.func,</strong></span>
};</pre></div><p>We can then<a id="id234" class="indexterm"/> define additional steps at key points in the component's behavior:</p><div class="informalexample"><pre class="programlisting">const onSave = (e, refs) =&gt; {
    // ...save the data
    console.log("saved");
};

const onCancel = (e, refs) =&gt; {
    // ...cancel the edit
    console.log("cancelled");
};

const onBeforeSave = (e, refs) =&gt; {
    <span class="strong"><strong>if (refs.title.value == "a bad title") {</strong></span>
        <span class="strong"><strong>console.log("validation failed");</strong></span>
        <span class="strong"><strong>return false;</strong></span>
    <span class="strong"><strong>}</strong></span>
  
    <span class="strong"><strong>return true;</strong></span>
};

ReactDOM.render(
    &lt;PageEditorComponent
        <span class="strong"><strong>onBeforeSave={onBeforeSave}</strong></span>
        onSave={onSave}
        onCancel={onCancel} /&gt;,
    document.querySelector(".react")
);</pre></div><p>The <code class="literal">onSave</code> method checks whether an optional <code class="literal">onBeforeSave</code> property is defined. If so, this callback is run. If the callback returns <code class="literal">false</code>, we can use this as a way to prevent the default component <a id="id235" class="indexterm"/>save behavior. We still need the default save or cancel behavior to work, so these properties are required. The others are optional but useful.</p></div>
<div class="section" title="Stores, reducers, and components"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec54"/>Stores, reducers, and components</h1></div></div></div><p>Building on<a id="id236" class="indexterm"/> these concepts, the<a id="id237" class="indexterm"/> final thing that we want you to look at is how this<a id="id238" class="indexterm"/> all fits together inside a Redux architecture.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note58"/>Note</h3><p>If you've skipped ahead to this chapter, make sure that you have a firm understanding of Redux by reading the previous chapter.</p></div></div><p>Let's begin with a <code class="literal">PageComponent</code> class (for individual pages, in a list):</p><div class="informalexample"><pre class="programlisting">import React from "react";

class PageComponent extends React.Component {
    constructor(props) {
        super(props);
        this.state = props.store.getState();
    }
    componentDidMount() {
        this.remove = this.props.store.register(
            this.onChange
        );
    }
    componentWillUnmount() {
        this.remove();
    }
    onChange() {
        this.setState(this.props.store.getState());
    }
    render() {
        <span class="strong"><strong>const DummyPageViewComponent = use(</strong></span>
            <span class="strong"><strong>"App/DummyPageViewComponent"</strong></span>
        <span class="strong"><strong>);</strong></span>

        <span class="strong"><strong>const DummyPageEditorComponent = use(</strong></span>
            <span class="strong"><strong>"App/DummyPageEditorComponent"</strong></span>
        <span class="strong"><strong>);</strong></span>

        <span class="strong"><strong>const DummyPageActionsComponent = use(</strong></span>
            <span class="strong"><strong>"App/DummyPageActionsComponent"</strong></span>
        <span class="strong"><strong>);</strong></span>

        return (
            &lt;div&gt;
                <span class="strong"><strong>&lt;DummyPageViewComponent /&gt;</strong></span>
                <span class="strong"><strong>&lt;DummyPageEditorComponent /&gt;</strong></span>
                <span class="strong"><strong>&lt;DummyPageActionsComponent /&gt;</strong></span>
            &lt;/div&gt;
        );
    }
}

module.exports = PageComponent;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note59"/>Note</h3><p>The <code class="literal">Dummy*Component</code> classes can be anything, really. We created a few "empty" components in the source code that goes with this chapter. The main thing is that <code class="literal">PageComponent</code> composes a few other components.</p></div></div><p>Nothing too<a id="id239" class="indexterm"/> fancy here: we compose a few components and hook into the usual <a id="id240" class="indexterm"/>Redux stuff. This is complemented by some new service<a id="id241" class="indexterm"/> location stuff:</p><div class="informalexample"><pre class="programlisting">import { <span class="strong"><strong>combineReducers</strong></span>, createStore } from "redux";

<span class="strong"><strong>Ioc.bind("App/Reducers", function() {</strong></span>
    <span class="strong"><strong>return [</strong></span>
        <span class="strong"><strong>(state = {}, action) =&gt; {</strong></span>
            <span class="strong"><strong>let pages = state.pages || [];</strong></span>

            <span class="strong"><strong>if (action.type == "UPDATE_TITLE") {</strong></span>
                <span class="strong"><strong>pages = pages.map(page =&gt; {</strong></span>
                    <span class="strong"><strong>if (page.id = payload.id) {</strong></span>
                        <span class="strong"><strong>page.title = payload.title;</strong></span>
                    <span class="strong"><strong>}</strong></span>

                    <span class="strong"><strong>return page;</strong></span>
                <span class="strong"><strong>});</strong></span>
            <span class="strong"><strong>}</strong></span>

            <span class="strong"><strong>return {</strong></span>
                <span class="strong"><strong>pages</strong></span>
            <span class="strong"><strong>};</strong></span>
        <span class="strong"><strong>}</strong></span>
    <span class="strong"><strong>];</strong></span>
<span class="strong"><strong>});</strong></span>

<span class="strong"><strong>Ioc.bind("App/Store", function() {</strong></span>
    <span class="strong"><strong>const reducers = combineReducers(</strong></span>
        <span class="strong"><strong>Ioc.use("App/Reducers")</strong></span>
    <span class="strong"><strong>);</strong></span>

    <span class="strong"><strong>return createStore(reducers);</strong></span>
<span class="strong"><strong>});</strong></span>

<span class="strong"><strong>const Store = Ioc.use("App/Store");</strong></span>
const PageComponent = Ioc.use("App/PageComponent");

let rendered = ReactDOMServer.renderToString(
    &lt;PageComponent <span class="strong"><strong>store={Store}</strong></span> /&gt;
)</pre></div><p>We're using a <a id="id242" class="indexterm"/>new <code class="literal">combineReducers</code> method, which takes an array of reducers <a id="id243" class="indexterm"/>and produces a<a id="id244" class="indexterm"/> new mega-reducer. Let's make the order and inclusion of the child components configurable:</p><div class="informalexample"><pre class="programlisting">render() {
    <span class="strong"><strong>const components = [</strong></span>
        <span class="strong"><strong>use("App/DummyPageViewComponent"),</strong></span>
        <span class="strong"><strong>use("App/DummyPageEditorComponent"),</strong></span>
        <span class="strong"><strong>use("App/DummyPageActionsComponent"),</strong></span>
    ];

    return (
        &lt;div&gt;
            <span class="strong"><strong>{components.map((Component, i) =&gt; {</strong></span>
                <span class="strong"><strong>return &lt;Component key={i} /&gt;;</strong></span>
            <span class="strong"><strong>})}</strong></span>
        &lt;/div&gt;
    );
}</pre></div><p>Two interesting things are happening here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In ES6, the <code class="literal">Array.prototype.map</code> method passes a second parameter to the callback. This is the numeric index for the current iteration of the array that is being mapped. We can use this as the <code class="literal">key</code> parameter when we're creating a list of child components.</li><li class="listitem" style="list-style-type: disc">We can use dynamic component names. Pay careful attention to the capitalization of<a id="id245" class="indexterm"/> <code class="literal">Component</code>. If the component name variable starts with a lowercase letter, React will assume a literal value.</li></ul></div><p>Now that <a id="id246" class="indexterm"/>we're building a dynamic list of components, we can move the default list out of this <a id="id247" class="indexterm"/>component:</p><div class="informalexample"><pre class="programlisting">Ioc.bind(<span class="strong"><strong>"App/PageComponentChildren"</strong></span>, function() {
    return [
        <span class="strong"><strong>use("App/DummyPageViewComponent"),</strong></span>
        <span class="strong"><strong>use("App/DummyPageEditorComponent"),</strong></span>
        <span class="strong"><strong>use("App/DummyPageActionsComponent"),</strong></span>
    ];
});</pre></div><p>We can then replace this list in <code class="literal">PageComponent.render</code>:</p><div class="informalexample"><pre class="programlisting">render() {
    <span class="strong"><strong>const components = use("App/PageComponentChildren");</strong></span>

    return (
        &lt;div&gt;
            {components.map((Component, i) =&gt; {
                return &lt;Component key={i} /&gt;;
            })}
        &lt;/div&gt;
    );
}</pre></div><p>Building on what we learned earlier about Fold, we can override this list when we want to add plugins! We can include a plugin to e-mail a snapshot of a page to someone:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>const PageComponentChildren = use("App/PageComponentChildren");</strong></span>

Ioc.bind("App/PageComponentChildren", function() {
    <span class="strong"><strong>return [</strong></span>
        <span class="strong"><strong>...PageComponentChildren,</strong></span>
        <span class="strong"><strong>use("App/DummyPageEmailPluginComponent"),</strong></span>
    <span class="strong"><strong>];</strong></span>
});

let extended = ReactDOMServer.renderToString(
    &lt;PageComponent store={Store} /&gt;
);</pre></div><p>This new plugin <a id="id248" class="indexterm"/>configuration can be miles away from the core definition of <code class="literal">PageComponent</code>, and we don't have to change any core code to make this work. We can add new reducers<a id="id249" class="indexterm"/> in exactly the same way (thereby altering <a id="id250" class="indexterm"/>our store or dispatcher behavior):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>const Reducers = use("App/Reducers");</strong></span>

Ioc.bind("App/Reducers", function() {
    <span class="strong"><strong>return [</strong></span>
        <span class="strong"><strong>...Reducers,</strong></span>
        <span class="strong"><strong>(state, action) =&gt; {</strong></span>
            <span class="strong"><strong>if (action.type == "EMAIL_PAGE") {</strong></span>
                <span class="strong"><strong>// ...email the page</strong></span>
            <span class="strong"><strong>}</strong></span>

            <span class="strong"><strong>return state;</strong></span>
        <span class="strong"><strong>}</strong></span>
    <span class="strong"><strong>]</strong></span>
});</pre></div><p>In this way, other developers can create entirely new components and reducers and apply them effortlessly to the system that we've already built.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec55"/>Summary</h1></div></div></div><p>In this chapter, we looked at a few methods that we could use to make our components (and general architecture) open to extension without requiring core modification. There's a lot to take in here and not nearly enough community standardization for this to be the final word on pluggable components. Hopefully, there's enough here for you to design the right plugin architecture for your application.</p><p>In the next chapter, we will look at various ways to test the components and classes that we've built so far. We'll continue to see the benefits of things, such as dependency injection and service location, while also learning about a few new tools.</p></div></body></html>