- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Creating the Marvel Explorer App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Marvel Explorer应用
- en: Let’s build an app that’s a bit more advanced, using a third-party API to feed
    it with data. I hope you like comics, because we will build an explorer on the
    Marvel Comics API, and I will try to squeeze in some heroic puns. We’ll explore
    adding different routes and add a bit of abstraction to make better use of writing
    our code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个稍微复杂一些的应用，使用第三方API为其提供数据。我希望你喜欢漫画，因为我们将构建一个基于Marvel Comics API的探索器，我还会尝试加入一些英雄式的双关语。我们将探索添加不同的路由，并添加一些抽象来更好地利用编写我们的代码。
- en: 'We’ll cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Getting started
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用
- en: Retrieving data from the API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从API获取数据
- en: Routing in a single-page application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单页应用程序中的路由
- en: Writing and using composables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写和使用composables
- en: Searching for and handling data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索和处理数据
- en: User-friendly error handling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户友好的错误处理
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we’ll replace **node package manager** (**npm**) with **performant
    npm** (**pnpm**): [https://pnpm.io](https://pnpm.io).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将用**性能npm**(**pnpm**)替换**node包管理器**(**npm**)：[https://pnpm.io](https://pnpm.io)。
- en: We need to register at [https://developer.marvel.com/](https://developer.marvel.com/)
    to retrieve an API key. We’ll add **Tailwind CSS** ([https://tailwindcss.com/](https://tailwindcss.com/))
    to apply styling to this app as well.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在[https://developer.marvel.com/](https://developer.marvel.com/)注册以获取API密钥。我们将添加**Tailwind
    CSS**([https://tailwindcss.com/](https://tailwindcss.com/))来为此应用应用样式。
- en: 'In this chapter we introduce routes using the official router for Vue.js applications:
    [https://router.vuejs.org/](https://router.vuejs.org/).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍使用Vue.js应用程序的官方路由来使用路由：[https://router.vuejs.org/](https://router.vuejs.org/)。
- en: The complete code for this chapter is available at [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/04.marvel](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/04.marvel).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可在[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/04.marvel](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/04.marvel)找到。
- en: Getting started with our new project
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始我们的新项目
- en: In order to get started, we need an API key. If you go to [https://developer.marvel.com/](https://developer.marvel.com/)
    and select **Get a Key** from the menu, you will need to register for a free account.
    Afterward, you will be redirected to the developer portal, where you create a
    key to interact with the API. Make sure to note the public and private keys.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们需要一个API密钥。如果您访问[https://developer.marvel.com/](https://developer.marvel.com/)并从菜单中选择**获取密钥**，您需要注册一个免费账户。之后，您将被重定向到开发者门户，在那里您创建一个密钥以与API交互。请确保记下公钥和私钥。
- en: For our example, we will access the API from localhost, so you need to add `localhost`
    and `127.0.0.1` to the list of authorized referrers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将从localhost访问API，因此您需要将`localhost`和`127.0.0.1`添加到授权引用者列表中。
- en: Note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to deploy this app to the web, you will need to make sure to add
    the corresponding URL of the app’s address there as well, but the deployment step
    is not covered in this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想将此应用部署到网络上，您还需要确保将应用的相应URL添加到那里，但本章不涵盖部署步骤。
- en: I’d like to point out the documentation, which you’ll find under **Interactive
    Documentation**. I recommend playing around with it for a bit to get a sense of
    our data provider.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我想指出文档，您可以在**交互式文档**下找到它。我建议您尝试操作一下，以了解我们的数据提供者。
- en: Let’s start a new project!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始一个新项目！
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Hit `y` to proceed, choose `vue-marvel-explorer` as the project name, and select
    the options shown in the following image:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 按`y`键继续，将项目名称选择为`vue-marvel-explorer`，并选择以下图片中显示的选项：
- en: '![Figure 4.1 – The setup configuration for the Marvel Explorer app](img/B19563_04_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – Marvel Explorer应用的设置配置](img/B19563_04_01.jpg)'
- en: Figure 4.1 – The setup configuration for the Marvel Explorer app
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – Marvel Explorer应用的设置配置
- en: After following the instructions to install the dependencies we can get to work!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 按照安装依赖项的说明操作后，我们就可以开始工作了！
- en: Let’s install our project’s dependencies using pnpm this time. This is an alternative
    package manager for node that has some benefits over npm, such as better storage
    management of packages, which results in increased installation speed and reduced
    network requests. If your internet connection is less than optimal, pnpm has got
    your back! You can read the installation guide here ([https://pnpm.io/installation](https://pnpm.io/installation)).
    The commands are similar to npm, so it should be very easy to get up to speed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，让我们使用 pnpm 安装我们项目的依赖项。pnpm 是一个针对 node 的包管理器，它相对于 npm 有一些优势，例如更好的包存储管理，这导致安装速度提高和网络请求减少。如果您互联网连接不佳，pnpm
    会帮您解决问题！您可以在此处阅读安装指南（[https://pnpm.io/installation](https://pnpm.io/installation)）。命令与
    npm 类似，因此应该很容易上手。
- en: Navigate to your project’s folder and type `pnpm install` (instead of `npm install`).
    The neat thing is that every future installation of the same package will reference
    the already installed local cache, which saves a ton of bandwidth and time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到您的项目文件夹，并输入 `pnpm install`（而不是 `npm install`）。酷的地方在于，将来安装相同包时，都会引用已安装的本地缓存，这样可以节省大量带宽和时间。
- en: 'We’ll install tailwind on the project as well, revisiting the steps from the
    Weather app, using pnpm, an alternative to npm, aimed at optimizing `node_modules`
    management:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用 pnpm 在项目中安装 tailwind，回顾来自天气应用程序的步骤，使用 npm 的替代品，旨在优化 `node_modules` 管理：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s update the `tailwind.config.js` file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 `tailwind.config.js` 文件：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a `style.css` file in the `./``src` folder:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `./src` 文件夹中创建一个 `style.css` 文件：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And finally, open the `./src/main.ts` file to import the CSS file into the
    app (note that this file contains the router initialization):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开 `./src/main.ts` 文件以将 CSS 文件导入到应用程序中（注意该文件包含路由初始化）：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you run the development server with `pnpm run dev`, you’ll see that the demo
    app added an example route, allowing you to navigate between a Home and About
    view. Close the dev server, and let’s open the project in the code editor.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 `pnpm run dev` 运行开发服务器，您会看到演示应用程序添加了一个示例路由，允许您在主页和关于视图之间导航。关闭开发服务器，让我们在代码编辑器中打开项目。
- en: You can remove the components that the default Vue installation added to clean
    up your project a bit. If you are unsure, you can always refer to the GitHub repository.
    The link can be found at the *Technical* *requirements* section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以移除默认 Vue 安装添加的组件，以清理您的项目。如果您不确定，可以始终参考 GitHub 仓库。链接可以在 *技术要求* 部分找到。*技术* *要求*
- en: 'Rename the `.env.example` file to .`env` and make sure to insert the secrets
    from the Marvel Developer portal:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `.env.example` 文件重命名为 `.env`，并确保从 Marvel 开发者门户插入秘密：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Variables from a `.env` file that are prefixed with `VITE_APP_` are automatically
    passed to and available in your application on a pre-defined `import.meta.env`
    object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `VITE_APP_` 为前缀的来自 `.env` 文件的变量会自动传递到您的应用程序中，并在预定义的 `import.meta.env` 对象中可用。
- en: Note
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I want to stress again that sharing secrets is not a best practice in production-like
    environments. You’d normally use something like an authorization broker to make
    sure that the API only receives trusted requests. In a way, we’ve done this by
    defining the request domains in the Marvel API configuration. Typically, `localhost`
    or its equivalent, `127.0.0.1`, is not something you would see in a production
    environment either!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我再次强调，在类似生产环境的生产环境中共享秘密不是最佳实践。您通常会使用类似授权代理的东西来确保 API 只接收受信任的请求。从某种意义上说，我们已经通过在
    Marvel API 配置中定义请求域做到了这一点。通常，`localhost` 或其等效的 `127.0.0.1` 也不会出现在生产环境中！
- en: This concludes our environment set up. We’ll now move forward with connecting
    these settings to our application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的环境设置。接下来，我们将继续将这些设置连接到我们的应用程序。
- en: The Superhero connection
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超级英雄连接
- en: We want to retrieve data from the Marvel Comics API from different components
    in our application. A good pattern for doing this is by creating a Vue composable.
    A Vue composable is a proven pattern for using and reusing logic throughout your
    application. We’ll create a folder called `composables` in the `src` folder and
    create a file called `marvelApi.ts`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望从应用程序的不同组件中检索 Marvel 漫画 API 的数据。一个很好的模式是通过创建 Vue 可组合式来实现。Vue 可组合式是在整个应用程序中使用和重用逻辑的一个经过验证的模式。我们将在
    `src` 文件夹中创建一个名为 `composables` 的文件夹，并创建一个名为 `marvelApi.ts` 的文件。
- en: You can import the types from the example repository ([https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/src/types/marvel.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/src/types/marvel.ts)).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从示例仓库中导入类型（[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/src/types/marvel.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/src/types/marvel.ts)）。
- en: These types are mainly contracts with the API. Feel free to take a look at them.
    I created them by ingesting the results from the API and defining the types.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型主要是与API的合约。请随意查看它们。我是通过摄取API的结果并定义类型来创建它们的。
- en: 'We’ll start with an asynchronous function that fetches the data from the API
    from the comics endpoint and returns a promise of the response. We’re going to
    expand the functionality gradually. Add a new composable function called `useComics`
    to the file and don’t forget to import the type:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个异步函数开始，该函数从API的漫画端点获取数据，并返回响应的promise。我们将逐步扩展其功能。向文件中添加一个新的组合函数`useComics`，并不要忘记导入类型：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we can wire the API call to the user interface. We are going to create
    our component to display the data from the endpoint. Create a new Vue component
    in the `src/components` folder called `ComicsOverview.vue`. We’ll start with the
    `script` tag contents:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将API调用连接到用户界面。我们将创建一个组件来显示端点数据。在`src/components`文件夹中创建一个新的Vue组件，名为`ComicsOverview.vue`。我们将从`script`标签的内容开始：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `script` block is very similar to the weather app from [*Chapter 4*](B19563_04.xhtml#_idTextAnchor092).
    We’re requesting data when the component gets mounted, and we’ll track the state
    using the `isLoading` variable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`script`块与第4章中的天气应用[*第4章*](B19563_04.xhtml#_idTextAnchor092)非常相似。我们在组件挂载时请求数据，并使用`isLoading`变量跟踪状态。'
- en: 'In the template of the same file, we’ll add the following contents:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件的模板中，我们将添加以下内容：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can quickly see the result by temporarily importing the component into `App.vue`
    and loading it in the template. A slight difference here is that we’ve abstracted
    the actual fetch to the composition, which makes the code of the component a bit
    cleaner and makes the fetch more reusable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过临时将组件导入到`App.vue`并在模板中加载它来快速查看结果。这里有一点细微的差别是我们将实际的获取操作抽象到了组合中，这使得组件的代码更加简洁，并且使获取操作更加可重用。
- en: 'Now that our data is coming in, we’re going to polish the component a bit.
    Let’s create a `LoadingIndicator.vue` component:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了数据，我们将稍微润色一下组件。让我们创建一个`LoadingIndicator.vue`组件：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can import it to the component and then use it to replace the `<div v-if="isLoading"><p>Loading
    comics…</p></div>` element, like so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将它导入到组件中，然后使用它来替换`<div v-if="isLoading"><p>Loading comics…</p></div>`元素，如下所示：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We do this to create more consistency when using recurring user interface patterns.
    Again, this is one of the strengths of a component-based architecture.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是为了在使用重复的用户界面模式时创建更多的一致性。再次强调，这是基于组件的架构的一个优势。
- en: We can also create the visual representation of a comic. We’re going to apply
    the abstractions right away. In practice, it happens more often that refactors
    occur while progressing on the code base. It’s tricky to predict what code will
    be reused beforehand, so don’t hesitate to refactor early and often, when the
    need arises. In our case, though, we have a different goal to teach, so we won’t
    focus on the refactoring part.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建漫画的视觉表示。我们将立即应用抽象。在实践中，代码重构往往发生在代码库的开发过程中。预先预测哪些代码将被重用是很困难的，所以当需要时，不要犹豫，尽早和经常重构。然而，在我们的案例中，我们有一个不同的目标要教授，所以我们将不会专注于重构部分。
- en: 'Create a component called `CardView.vue` that contains the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`CardView.vue`的组件，其中包含以下代码：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this component, we are making use of slots. Slots are placeholders for specific
    dynamic content (components or text) that comes from the parent component. Slots
    are an excellent way to reuse templates and offer a lot of flexibility. Consider
    the `LoadingIndicator` component, which accepts only a text as a property. Restriction
    can be good, but sometimes you might prefer flexibility over constraint. Let’s
    start to apply this generic component.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组件中，我们正在使用插槽。插槽是来自父组件的特定动态内容（组件或文本）的占位符。插槽是重用模板和提供大量灵活性的绝佳方式。考虑一下`LoadingIndicator`组件，它只接受一个文本属性。限制可能是有益的，但有时您可能更愿意选择灵活性而不是约束。让我们开始应用这个通用组件。
- en: 'We’ll create a `ComicCard.vue` component with the following contents: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.1-ComicCard.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.1-ComicCard.vue)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个包含以下内容的`ComicCard.vue`组件：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.1-ComicCard.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.1-ComicCard.vue)
- en: 'Let’s break that component down, shall we? You should be familiar with most
    of the concepts, but I have managed to introduce a bit more. A particular addition
    is the following line:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个组件，好吗？你应该熟悉大多数概念，但我已经介绍了一些更多内容。一个特别的添加是以下这一行：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Intl` is a standardized namespace that deals with language-sensitive functions.
    In our case, we are setting up a list specific formatter in the English (`en`)
    language and using it in the template to string together the list of creators.
    The list is provided as an array (that is, `[“Evan You”,` `“Sebastien Chopin”,`
    `“Anthony Fu”]`). Using the `Intl` formatter, the result is readable text that
    is specific to that language: *Evan You, Sebastien Chopin, and* *Anthony Fu!*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intl`是一个标准化的命名空间，用于处理与语言相关的函数。在我们的案例中，我们正在设置一个特定于英语（`en`）语言的列表格式化器，并在模板中使用它来连接创作者列表。列表作为数组提供（即`[“Evan
    You”, “Sebastien Chopin”, “Anthony Fu”]`）。使用`Intl`格式化器，结果是特定于该语言的易读文本：*Evan You,
    Sebastien Chopin, and Anthony Fu!*'
- en: We’re using the computed values to create lists of characters for every comic
    (`charactersList`) and the creators of every comic (`creatorsList`).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用计算值来为每个漫画创建角色列表（`charactersList`）和每个漫画的创作者列表（`creatorsList`）。
- en: 'In the template, we see how we are using the slots in the `CardView` component
    and filling it with our own templates:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，我们看到我们是如何在`CardView`组件中使用插槽并填充我们自己的模板的：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We’ve defined the contents of the templates. We’ve designated `comic.title`
    for the header in the component. For the default slot, we’re providing the markup
    for the contents of the card. In both cases, we let the `<CardView>` component
    handle the formatting and style, which also ensures a consistent user interface.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了模板的内容。我们指定`comic.title`作为组件中的标题。对于默认插槽，我们提供了卡片内容的标记。在两种情况下，我们都让`<CardView>`组件处理格式化和样式，这也确保了用户界面的统一性。
- en: 'In the example code, you will see the shorthand notation for named slots:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例代码中，你会看到命名插槽的简写表示法：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For now, we’ll remove the temporary change to `App.vue` because we’re going
    to add this to a specific route view!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将移除对`App.vue`的临时更改，因为我们打算将其添加到特定的路由视图中！
- en: With the components we have prepared, we’ll continue by moving those components
    to specific views and routes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们准备好的组件，我们将继续将这些组件移动到特定的视图和路由中。
- en: Marvelous routes in a single-page application
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单页应用程序中的精彩路由
- en: 'Now, let’s take a look at the default setup of the application, because we’ve
    pre-installed the app to use `vue-router`. This configured the app with a couple
    of things:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看应用程序的默认设置，因为我们已经预安装了应用程序以使用`vue-router`。这配置了应用程序的一些功能：
- en: We have an `index.ts` file in the `router` folder
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`router`文件夹中，我们有一个`index.ts`文件
- en: In the `views` folder, we have two components called `HomeView.vue` and `AboutView.vue`
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`views`文件夹中，我们有两个名为`HomeView.vue`和`AboutView.vue`的组件
- en: In `App.vue`, we have some components called `RouterLink` and `RouterView`
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`App.vue`中，我们有几个名为`RouterLink`和`RouterView`的组件
- en: That’s how routes are tied together. Let’s take a look at each of them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是路由是如何相互关联的。让我们看看每一个。
- en: The contents of the `router` folder define and configure the routes for the
    application. Routes define the different paths in your application and the components
    that should be rendered when those paths are accessed. Each route is represented
    as an object with properties such as `path`, `name`, and `component`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`router`文件夹的内容定义和配置了应用程序的路由。路由定义了应用程序中的不同路径以及当访问这些路径时应渲染的组件。每个路由都表示为一个具有`path`、`name`和`component`等属性的对象。'
- en: The `path` property specifies the URL path, and the `component` property specifies
    the Vue component to render. The `name` is not required and more meant as a human-readable
    identifier for a route.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`path`属性指定了URL路径，`component`属性指定了要渲染的Vue组件。`name`不是必需的，更多的是作为一个人类可读的标识符用于路由。'
- en: Using the default configuration, it defined the home view for us and set up
    the other view to support code splitting to limit bundle sizes per route. So,
    this is a best practice out of the box!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认配置，它为我们定义了主页视图，并设置了其他视图以支持代码拆分，以限制每个路由的包大小。所以，这是一个开箱即用的最佳实践！
- en: 'We’ll change the references to `about` into `search`, in preparation for our
    final result:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把对`about`的引用更改为`search`，为我们的最终结果做准备：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We’ll rename `AboutView.vue` to `SearchView.vue`. For the contents of the file,
    you can just strip most of it, we’ll build something new later on. Something like
    this is fine for now:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把`AboutView.vue`重命名为`SearchView.vue`。对于文件的内容，你可以简单地删除大部分，我们稍后会构建一些新的内容。目前像这样就可以了：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To string it all back together, we can update the `App.vue` file so the `RouterLink`
    component points to `/search` instead of `/about`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些内容重新组合在一起，我们可以更新`App.vue`文件，使`RouterLink`组件指向`/search`而不是`/about`。
- en: 'To be clear: you have to use the path that we’ve configured in the router file.
    The `RouterView` component is used to render the matched component based on the
    current route. It acts as a placeholder where the corresponding component is rendered.
    Whenever the route changes, the `RouterView` component will be automatically updated
    to render the new component. Remember slots? Consider `RouterView` as sort of
    a dynamic slot that can hold an entire view.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确：你必须使用我们在路由文件中配置的路径。`RouterView`组件用于根据当前路由渲染匹配的组件。它充当占位符，在相应组件渲染的地方。每当路由发生变化时，`RouterView`组件将自动更新以渲染新组件。还记得插槽吗？将`RouterView`视为一种动态插槽，可以容纳整个视图。
- en: '`RouterLink` in turn is used to create navigation links in your application
    and triggers navigation to the given route when clicked. The `to` attribute of
    `RouterLink` specifies the path or name of the target route.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouterLink`用于在应用程序中创建导航链接，并在点击时触发到指定路由的导航。`RouterLink`的`to`属性指定目标路由的路径或名称。'
- en: 'Let’s clean up the parts of the default configuration we don’t need anymore:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们清理掉我们不再需要的默认配置部分：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since our `ComicsOverview.vue` component is ready, we can add it to `HomeView.vue`,
    replacing the `TheWelcome.vue` part:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`ComicsOverview.vue`组件已经准备好了，我们可以将其添加到`HomeView.vue`中，替换掉`TheWelcome.vue`部分：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you now run the app, you can navigate between the home page, which loads
    the comics overview, and the almost empty search page.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你可以在主页（加载漫画概览）和几乎为空的搜索页面之间导航。
- en: We’ll continue to work on getting more information into our application, because
    our application is limited now to just showing the first page of the API results.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续努力将更多信息添加到我们的应用程序中，因为我们的应用程序目前仅限于显示API结果的首页。
- en: Optional parameters
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选参数
- en: If you analyzed the network request coming from the Marvel API, you may have
    noticed that the comics we are showing are but the tip of the iceberg. There are
    a multitude of comics, and because of that volume, they are not being sent in
    one response. The API offers paged results. We can modify our app to mirror the
    features of the API!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你分析了来自漫威API的网络请求，你可能已经注意到我们显示的漫画只是冰山一角。有大量的漫画，由于数量庞大，它们不会在一个响应中发送。API提供了分页结果。我们可以修改我们的应用程序以反映API的功能！
- en: 'If we open the router file, we can add an optional parameter to a route. It
    parses and exposes the value to be used in your application. The notation for
    a parameter (or *param* for short) is to prefix the name with a colon. We’ll add
    a param called `page` to the `home` route:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开路由文件，我们可以在路由中添加一个可选参数。它解析并公开要用于应用程序的值。参数（或简称*param*）的表示法是在名称前加冒号。我们将向`home`路由添加一个名为`page`的参数：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We have introduced a slight bug in our application. The application now *always
    expects a parameter*. For the home page, this is not always the case! The param
    should be optional. To mark a param as optional, we add a question mark as a suffix:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序中引入了一个轻微的bug。现在应用程序*总是期望一个参数*。对于主页来说，这并不总是如此！参数应该是可选的。为了标记参数为可选，我们在其后添加一个问号作为后缀：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Hooray! We’ve successfully added an optional parameter. We can now introduce
    pagination to our comics overview.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 欢呼！我们已经成功添加了一个可选参数。现在我们可以将分页引入到漫画概览中。
- en: Paging Dr Strange
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 呼叫斯特兰奇博士
- en: The `vue` router exposes itself as a composable. A composable is a Vue superpower,
    used to encapsulate stateful logic for easy reuse. This means that the router
    composable, in this case, holds the state of the router, which we can use in any
    component!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`vue`路由器将自己暴露为一个可组合式组件。可组合式组件是Vue的一个超级功能，用于封装可复用的状态逻辑。这意味着在这个例子中，路由器可组合式组件持有路由的状态，我们可以在任何组件中使用它！'
- en: 'This means we can open our `ComicsOverview.vue` file directly to implement
    pagination. Let’s take a look at the `script` tag of the component and add a few
    lines: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.2-ComicsOverview.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.2-ComicsOverview.vue)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以直接打开我们的`ComicsOverview.vue`文件来实现分页。让我们看看组件的`script`标签并添加几行：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.2-ComicsOverview.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.2-ComicsOverview.vue)
- en: First, we’re importing the composable (*line 4*) and register it to the route
    constant (*line 12*). Then we’re adding two reactive variables (*lines 16, 17*)
    to track the page information. We access the parameter via the `route.params`
    object. Since we named the variable page we can access the corresponding property
    on the method. We use the `+route.params.page` (*lines 19-21*) as shorthand to
    convert the value to a numeric type, and we store it in the reactive `currentPage`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入可组合式组件（*第4行*）并将其注册到路由常量（*第12行*）。然后我们添加两个响应式变量（*第16行、第17行*）来跟踪页面信息。我们通过`route.params`对象访问参数。由于我们命名了变量，我们可以访问方法上的相应属性。我们使用`+route.params.page`（*第19-21行*）作为简写来将值转换为数值类型，并将其存储在响应式的`currentPage`中。
- en: Then, in `getComics`, we use the data coming from the endpoint to actualize
    the values (*lines* *27, 28*).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`getComics`中，我们使用来自端点数据来实际化值（*第27行、第28行*）。
- en: Now that we know how many pages there are and what page we are on, we can use
    these properties to provide a simple `Pagination` component.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了有多少页以及我们目前在哪一页，我们可以使用这些属性来提供一个简单的`Pagination`组件。
- en: A simple pagination component
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的分页组件
- en: 'So, let’s create a new component called `Pagination.vue` and add the following
    contents: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.3-Pagination.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.3-Pagination.vue)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们创建一个新的组件，命名为`Pagination.vue`，并添加以下内容：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.3-Pagination.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.3-Pagination.vue)
- en: 'It should be pretty self-explanatory by now: we’re adding the relevant props
    (for more flexibility, we provide a `path` property as well) and, based on our
    current page, we can render the links to the first, previous, or next and last
    page links and show the pagination status.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，应该已经很直观了：我们添加了相关的属性（为了更大的灵活性，我们还提供了一个`path`属性），并且根据我们的当前页，我们可以渲染到第一页、上一页、下一页或最后一页的链接，并显示分页状态。
- en: 'I would like to point out the aria-hidden property, which we use to mark decorative
    elements that add no value for screen readers. Now, we’ll add it to the `ComicsOverview.vue`
    component by importing it and pasting the template under the overview of comics
    cards:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我想指出的是`aria-hidden`属性，我们用它来标记对屏幕阅读器无价值的装饰性元素。现在，我们将通过导入并将其粘贴在漫画卡片概述下添加到`ComicsOverview.vue`组件中：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That works! We can click to the next page, but nothing happens. That’s because
    our API doesn’t support pagination yet. Let’s look into adding it as a feature,
    so we’ll open the `marvelApi.ts` file. First, we’ll add the option for pagination
    to `useComics`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 那是有效的！我们可以点击到下一页，但什么也没有发生。这是因为我们的API还没有支持分页功能。让我们看看如何添加这个功能，所以我们将打开`marvelApi.ts`文件。首先，我们将为`useComics`添加分页选项：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We’re simply accepting a page number, and we’ll use the predefined `ITEMS_PER_PAGE`
    to determine the offset (which is the way the Marvel API deals with pagination).
    Then, we store the query parameter and add it to the `requestURI`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是接受一个页码，然后我们将使用预定义的`ITEMS_PER_PAGE`来确定偏移量（这是漫威API处理分页的方式）。然后，我们存储查询参数并将其添加到`requestURI`。
- en: 'Now, we can flip over to the `ComicsOverview` component again to implement
    the pagination and connect the route parameter to the API request. To accomplish
    this, we add the following to the script block:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以再次切换到`ComicsOverview`组件，以实现分页并将路由参数连接到API请求。为了完成这个任务，我们在脚本块中添加以下内容：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can simply add the page now to the `getComics` request and pass it down to
    the `useComics` composable. We do this `onMounted`, for when you enter the application
    from a URL directly. We also add a watch function, that keeps track of the `route.params.page`
    and requests a new page once the value changes. We’re using the quick conversion
    to numeric here as well, as you can see by the plus sign.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以简单地将页面添加到`getComics`请求中，并将其传递给`useComics`可组合组件。我们在`onMounted`时这样做，即当你直接从URL进入应用程序时。我们还添加了一个监视函数，它跟踪`route.params.page`的变化，并在值改变时请求新页面。正如你所看到的加号，我们在这里也使用了快速转换为数字。
- en: With all of this in place, we can now browse through all 2,746 pages! As an
    extra exercise, why not figure out if you can expand the pagination component
    to show multiple pages.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些准备就绪之后，我们现在可以浏览所有2,746页！作为一个额外的练习，为什么不尝试扩展分页组件以显示多个页面。
- en: Once you’re ready to move forward, we’ll refactor our app to use composables.
    They are functions that encapsulate (stateful) logic.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你准备好向前推进，我们将重构我们的应用程序以使用可组合组件。它们是封装（有状态的）逻辑的函数。
- en: Composables, assemble!
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可组合组件，集合！
- en: 'Let’s take a look at how we can leverage our composables and refactor the app
    to expand the functionalities a bit. Composables are all about reusability: it’s
    their superpower in the Vue space, so let’s put our previously created composable
    into action.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何利用我们的可组合组件并重构应用程序以扩展一些功能。可组合组件都是关于可重用性：这是它们在Vue空间中的超级力量，所以让我们将我们之前创建的可组合组件投入实际应用。
- en: First, we will work on refactoring the `useComics` composable, where we will
    lightly apply the clean code principles. In our context, this will translate to
    applying the single responsibility principle and writing small and cohesive functions
    with meaningful names.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将对`useComics`可组合组件进行重构，我们将轻柔地应用清洁代码原则。在我们的上下文中，这相当于应用单一责任原则，并编写小型且结构紧凑的函数，具有有意义的名称。
- en: Refactoring useComics
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构useComics
- en: We’ll refactor in a non-destructive way too, leaving the existing `useComic`
    composable functional until we’re ready to update that too.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以非破坏性的方式进行重构，直到我们准备好更新现有的`useComic`可组合组件。
- en: 'We’ll first move the static constants out of the function to the upper scope.
    We’ll also import additional types that we will reference in functions. This way,
    we can still access them, but they are available throughout the file. I make it
    a practice to group these types of values at the top of the file for easy future
    reference:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将静态常量从函数中移出，放到更高的作用域。我们还将导入将在函数中引用的附加类型。这样，我们仍然可以访问它们，但它们在整个文件中都是可用的。我习惯于将这些类型的值放在文件顶部，以便于未来的参考：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we think about what our new composables should do and have in common, we
    can identify the following activities: determining the pagination, determining
    a search query, constructing the Marvel Developer API URL, and fetching and returning
    data. We’ll create short, separate functions for each activity. These are not
    composables, and we won’t expose them outside of the file.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们思考我们的新可组合组件应该做什么以及它们有什么共同点，我们可以确定以下活动：确定分页、确定搜索查询、构建漫威开发者API URL、获取并返回数据。我们将为每个活动创建简短、独立的函数。这些不是可组合组件，我们不会在文件外部暴露它们。
- en: 'Let’s add the `getPagination` function, which accepts page number and translates
    it to a string translating the page to an **offset** (in line with what the Marvel
    API would expect):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加`getPagination`函数，它接受页码并将其转换为字符串，将页码转换为**偏移量**（符合漫威API的预期）：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To construct an additional string containing a search query, we add the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建一个包含搜索查询的额外字符串，我们添加以下内容：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The next addition is a function to construct the request URI, combining the
    static constants with the output of the `getPagination` and `getQuery` function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个添加的是构建请求URI的函数，它将静态常量与`getPagination`和`getQuery`函数的输出相结合：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And we’ll add a function to do a request and return the result. In this case,
    we could potentially reuse this, so we can write it as if it were a composable,
    using the `use` prefix:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一个执行请求并返回结果的函数。在这种情况下，我们可能可以重用这个函数，所以我们可以将其编写为可组合组件，使用`use`前缀：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, we can string all of the functions together in a composable that will
    allow us to interact with the Marvel Developer API:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在一个组合式中将所有函数串联起来，这将使我们能够与漫威开发者API进行交互：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, we’ve created a function that can either return comics or characters,
    this will depend on the path variable we provide. Since the Marvel Developer API
    has similar mechanics for every endpoint, we were able to make a useful abstraction
    of the options we need.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们创建了一个函数，它可以返回漫画或角色，这取决于我们提供的路径变量。由于漫威开发者API对每个端点都有类似的机制，我们能够对所需的选项做出有用的抽象。
- en: 'The code we’ve added to the `MavelAPI.ts` file looks like this: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.4-MarvelAPI.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.4-MarvelAPI.ts)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到`MavelAPI.ts`文件中的代码如下：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.4-MarvelAPI.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.4-MarvelAPI.ts)
- en: We’ve expanded the file with abstractions to retrieve data from the endpoint,
    where we can reuse functions that are generic while being able to request specific
    content.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加抽象来扩展文件，以从端点检索数据，这样我们就可以重用通用的函数，同时能够请求特定内容。
- en: Let’s investigate incorporating these functionalities into our application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查将这些功能整合到我们的应用中。
- en: Reassembling functionalities
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新组装功能
- en: 'Now, we can update our existing `useComics` composable to build on top of this
    foundation. As you can see, we’re now able to reduce the contents of the composable
    to a single line of code, providing only the path and current page:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更新现有的`useComics`组合式，在此基础上构建。正如你所见，我们现在能够将组合式的代码内容缩减到一行，只提供路径和当前页：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: By running our code, the existing overview of comics with pagination should
    remain fully functional. This is a testament to writing clean code rather than
    the power of composables. It enables us to implement new, useful code with relative
    ease. In our next composable, we’ll request a different type of information, as
    we will describe in the function.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行我们的代码，带有分页的现有漫画概览应该保持完全功能。这是编写干净代码而不是组合式力量的证明。它使我们能够相对容易地实现新的、有用的代码。在我们的下一个组合式中，我们将请求不同类型的信息，正如我们将在函数中描述的那样。
- en: 'The way we will interact with the search API is to provide the correct path
    to the API and, in our case, we’ll use the `nameStartsWith` way of searching.
    We’ll provide it, together with a dynamic search value, as part of the query:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与搜索API交互的方式是提供正确的API路径，在我们的案例中，我们将使用`nameStartsWith`方式进行搜索。我们将将其与动态搜索值一起作为查询的一部分提供：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This time, as you can see, we’ve changed the expected response type to `Characters`
    instead of `Comics`. Our IDE will be able to make a distinction between the two
    types when we’re interacting with these composables.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，正如你所见，我们将预期的响应类型更改为`Characters`而不是`Comics`。当我们与这些组合式交互时，我们的IDE将能够区分这两种类型。
- en: We now have our two composables ready for use in the app. The way we refactored
    our file is something of a natural process in coding. Over time, requirements
    will change, so it is only logical that the code changes with it. Having our code
    split into small, focused functions will make it easier to understand and modify
    in the future.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个组合式准备在应用中使用。我们重构文件的方式在编码中是一种自然的过程。随着时间的推移，需求会发生变化，因此代码随之变化是合乎逻辑的。将我们的代码拆分成小型、专注的函数将使我们在未来更容易理解和修改。
- en: When using composables, we normally follow the same practice of providing simple-to-use
    functions and rather splitting them into separate ones than combining them into
    one.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用组合式时，我们通常遵循提供简单易用函数的相同做法，而不是将它们组合成一个。
- en: If you’re interested in applying composables, I recommend checking out [https://vueuse.org/](https://vueuse.org/).
    It hosts a collection of ready-to-use composables for everyday problems in Vue
    applications.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣于应用组合式，我建议查看[https://vueuse.org/](https://vueuse.org/)。它托管了一个用于Vue应用中日常问题的现成组合式集合。
- en: At this point, we’ve seen how the combination of a clean code mindset, combined
    with specific composables have helped us refactor our application’s code into
    individual parts that are more readable and maintainable. We’ve also experienced
    refactoring code. Sometimes we refactor due to shifting needs, sometimes we just
    want to make existing code more readable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到，将清晰的代码思维与特定的可组合组件相结合，如何帮助我们重构应用程序代码，将其分解成更易于阅读和维护的各个部分。我们也亲身体验了代码重构的过程。有时我们重构代码是因为需求的变化，有时我们只是想让现有的代码更易于阅读。
- en: Let’s now look at adding more types of data to our application!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看如何向我们的应用程序添加更多类型的数据！
- en: Managing the roster
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理名单
- en: With our brand new composable, we have easy access to more data from the Marvel
    Developer API! We’ll move onto creating the Vue components that will allow the
    user interface to deal with searching.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们全新的可组合组件，我们可以轻松访问来自漫威开发者API的更多数据！我们将继续创建Vue组件，这将使用户界面能够处理搜索操作。
- en: 'We’ll first create a variant of the `ComicCard.vue` named `CharacterCard.vue`.
    The component will be a bit simpler, so you can either paste the following contents
    in the file or create a copy of the `ComicCard.vue` and update it to match the
    contents:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将创建一个名为`CharacterCard.vue`的`ComicCard.vue`的变体。该组件将稍微简单一些，因此您可以将以下内容粘贴到文件中，或者创建`ComicCard.vue`的一个副本并更新它以匹配以下内容：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There’s nothing special going on here. We’re expecting a single property character,
    and that should match the type. We can therefore easily map the underlying properties
    to a simple HTML template.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有发生什么特别的事情。我们期望一个名为character的单个属性，并且它应该匹配类型。因此，我们可以轻松地将底层属性映射到一个简单的HTML模板中。
- en: 'Next, we’ll create the main component to host all the user interface elements.
    We’ll create a file called `SearchCharacter.vue`, and we’ll start with just the
    template. This too should look familiar after creating `ComicsOverview.vue`. I’ve
    highlighted the key differences: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.5-SearchCharacter.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.5-SearchCharacter.vue)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个主要组件来托管所有用户界面元素。我们将创建一个名为`SearchCharacter.vue`的文件，并且我们将从模板开始。在创建了`ComicsOverview.vue`之后，这也应该看起来很熟悉。我已经高亮了关键差异：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.5-SearchCharacter.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.5-SearchCharacter.vue)
- en: We’re providing a meaningful message when the data is loading (*line 3*), and
    we’re showing results in a different matter, namely a `CharacterCard` (*lines
    8-12*). In `Pagination`, we have provided the current path (*line 16*), and we’ve
    added a more specific message when no data is returned (*lines 25-28*).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据正在加载时（*第3行*），我们提供了一个有意义的消息，并且以不同的方式显示结果，即`CharacterCard`（*第8-12行*）。在`Pagination`中，我们提供了当前路径（*第16行*），并且在没有返回数据时添加了一个更具体的消息（*第25-28行*）。
- en: Now, we’ll implement a way of inputting a search query to lead into the `SearchCharacter`
    presentation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现一种输入搜索查询的方法，以便将其传递到`SearchCharacter`展示。
- en: Searching for heroes
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索英雄
- en: Searching is an isolated, specific action, so in line with the Single File Components
    philosophy, we are going to create a specific component for this!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索是一个隔离的、特定的动作，因此按照单文件组件的哲学，我们将为这个动作创建一个特定的组件！
- en: 'Let’s create a form component by creating a new file called `SearchForm.vue`.
    Start with the `script` tag, and I’ll explain some new things along the way:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个名为`SearchForm.vue`的新文件来创建一个表单组件。从`script`标签开始，我会在过程中解释一些新内容：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There are two interesting things going on. The first highlighted line defines
    an `emit`. Emitting happens if we want to pass something (an event) upwards in
    the scope. Props go down, emits go up. By using the `defineEmits`, we wrap it
    so that Vue can keep track of the event at runtime and we’re assigning it the
    name `searchSubmit`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正在进行着两件有趣的事情。第一行高亮定义了一个`emit`。当我们要在作用域内向上传递某些内容（一个事件）时，就会发生emit。Props向下传递，emits向上传递。通过使用`defineEmits`，我们将其包装起来，这样Vue可以在运行时跟踪事件，并将其命名为`searchSubmit`。
- en: Next, we have a function called `search` that does nothing but emit the event
    by referencing its name and passing `query.value` as a parameter. In our parent
    component, we will be able to catch the event and its value.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个名为`search`的函数，它除了通过引用其名称并传递`query.value`作为参数来触发事件外，什么都不做。在我们的父组件中，我们将能够捕获该事件及其值。
- en: 'It’s time to add the template. Let’s start as simply as possible:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候添加模板了。让我们尽可能简单开始：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here too, two things are important to note. The `v-on:submit.stop` statement
    is a built-in method that prevents the actual form from being submitted as an
    HTML form (which would lead to refreshing the page). Instead, on submit, it calls
    the `search` function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里也有两点需要注意。`v-on:submit.stop` 语句是一个内置方法，它阻止实际的表单作为 HTML 表单提交（这会导致页面刷新）。相反，在提交时，它调用
    `search` 函数。
- en: In order to have any value reference, we can use the `v-model` to bind the value
    of query to the input field. This gives you two-way databinding.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有任何值引用，我们可以使用 `v-model` 将查询值绑定到输入字段。这为你提供了双向数据绑定。
- en: Adding search
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加搜索
- en: 'Although the form works, it doesn’t feel like an app: we still have to manually
    submit the form. Let’s upgrade the `SearchForm` before moving on to showing the
    results. We’ll use a watcher to monitor the value of the query and trigger the
    `search` function when it has changed.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然表单可以工作，但它感觉不像一个应用：我们仍然需要手动提交表单。在展示结果之前，让我们升级 `SearchForm`。我们将使用观察者来监视查询值的变化，并在它发生变化时触发
    `search` 函数。
- en: 'We’ll update the code in the `script` tag to match the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新 `script` 标签中的代码以匹配以下内容：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It’s easy to understand the importing of the watch function and defining the
    watcher. And instead of directly calling the search function, the watcher calls
    `debouncedSearch`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 理解导入 `watch` 函数和定义观察者并不难。而且，而不是直接调用搜索函数，观察者调用 `debouncedSearch`。
- en: Firing requests to an API is expensive in terms of resources. By debouncing
    the function, we run a timer of, in this case 500 milliseconds (ms). When the
    timer runs out, we then call the `search` function, which in turn emits the `searchSubmit`
    event. If, however, the `debouncedSearch` function is called before the timer
    was cleared, we simply reset the timer and wait another 500 ms.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 向 API 发送请求在资源方面是昂贵的。通过防抖函数，我们运行一个计时器，在本例中为 500 毫秒（ms）。当计时器结束时，我们然后调用 `search`
    函数，该函数反过来发出 `searchSubmit` 事件。然而，如果 `debouncedSearch` 函数在计时器清除之前被调用，我们只需重置计时器并等待另一个
    500 毫秒。
- en: An overview with superpowers
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超级能力的概述
- en: 'We can finally assemble the `SearchCharacter` component. Let’s start with the
    `script` tag, since we left it out when we first started: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.6-SearchCharacter.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.6-SearchCharacter.vue)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于可以组装 `SearchCharacter` 组件了。让我们从 `script` 标签开始，因为我们第一次开始时遗漏了它：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.6-SearchCharacter.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.6-SearchCharacter.vue)
- en: Apart from importing our utilities and components, the core of the component
    is to trigger the search action on the Marvel Developer API. The `getCharacterSearch`
    (*lines 20-34*) takes care of updating the reactive values to translate to the
    UI and calculate the pagination. Its core is using our composable to retrieve
    the results, which are passed to the reactive data property.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 除了导入我们的实用工具和组件之外，组件的核心是在 Marvel 开发者 API 上触发搜索操作。`getCharacterSearch`（*第 20-34
    行*）负责更新响应式值以转换为 UI 并计算分页。其核心是使用我们的可组合结构检索结果，这些结果传递给响应式数据属性。
- en: The `searchReset` function (*lines 36-41*) makes sure we can always return to
    the initial state, for instance, when you’d want to clear the UI or when somebody
    searches for an empty value.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`searchReset` 函数（*第 36-41 行*）确保我们总能回到初始状态，例如，当你想要清除 UI 或有人搜索空值时。'
- en: 'In the template itself, we only need to add the `SearchForm` so that our users
    can find their favorite hero from the Marvel Universe:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板本身中，我们只需要添加 `SearchForm`，这样我们的用户就可以从漫威宇宙中找到他们最喜欢的英雄：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We have extended the app now with the very useful search function. This means
    we can put our new composable structure to the test. It allows us to focus on
    the implementation of the search form with debouncing, rather than fetching the
    data.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经通过非常有用的搜索功能扩展了应用。这意味着我们可以测试我们的新可组合结构。它允许我们专注于搜索表单的实现，包括防抖，而不是获取数据。
- en: We’ve seen how our abstractions have helped to expand features with minimal
    effort. All we’ve built so far has mostly been about a “happy flow,” where the
    individual parts work as expected. Since we’re depending on a third-party API,
    we have no control over its stability and have to prepare for cases where the
    data is not returned. We’ll focus on error handling in the next section.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到我们的抽象如何以最小的努力扩展功能。到目前为止，我们所构建的几乎都是关于“愉快流程”，其中各个部分按预期工作。由于我们依赖于第三方API，我们无法控制其稳定性，必须为数据未返回的情况做好准备。在下一节中，我们将重点关注错误处理。
- en: A different vision
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的视角
- en: At this point, our app is functioning just fine. We can improve our app experience
    by making sure we can handle situations when the API returns an error. Let’s see
    how we can make our app a bit more robust in that sense.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用程序运行良好。我们可以通过确保我们可以处理API返回错误的情况来改善我们的应用程序体验。让我们看看我们如何使我们的应用程序在这方面更加健壮。
- en: 'We’ll add a page that will be able to display errors to the user when they
    occur. Let’s start with a new file in the `views` folder called `ErrorView.vue`.
    Just create a template with the following contents:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个页面，当发生错误时能够向用户显示错误。让我们从`views`文件夹中的新文件`ErrorView.vue`开始。只需创建以下内容的模板：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We’ll circle back to this file later. We can now at least create a new route
    in the `router/index.ts` file, which just duplicates similar logic from the `search`
    route:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会回到这个文件。现在我们至少可以在`router/index.ts`文件中创建一个新的路由，它只是从`search`路由复制类似的逻辑：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If we then navigate to the `/error` route in the app, we should see our `errorpage`.
    Since the data is coming from an external API, we can’t control it. This makes
    it an obvious weakness in the app.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们导航到应用程序中的`/error`路由，我们应该看到我们的`errorpage`。由于数据来自外部API，我们无法控制它。这使得它成为应用程序中的一个明显弱点。
- en: 'On top of that, it is common practice to code defensively. If we look at the
    `marvelApi` composable file, we can add some safeguards around the composables
    that we’re using in the app:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，编写防御性代码是常见的做法。如果我们查看`marvelApi`组合式文件，我们可以在应用程序中使用的组合式周围添加一些安全措施：
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You could also consider adding these `try`/`catch` blocks on `useFetch` and
    `useMarvelAPI`. On error, the error will propagate upwards through the call stack,
    which means it will be caught at the highest level.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以考虑在`useFetch`和`useMarvelAPI`上添加这些`try`/`catch`块。在发生错误时，错误将通过调用堆栈向上传播，这意味着它将在最高级别被捕获。
- en: We’re going to simulate erroneous behavior in order to develop for these unforeseen
    circumstances. An easy way of doing this is to go to your `.env` file and temporarily
    rename the value of the `VITE_APP_MARVEL_API_PUBLIC` variable to `VITE_APP_MARVEL_API_PUBLIC_ERROR`.
    We will change it back once we’re done! If you run the app, it will not be able
    to request anything, and you will see the error message we’ve set in the console.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将模拟错误行为，以便为这些不可预见的情况进行开发。一种简单的方法是进入您的`.env`文件，并将`VITE_APP_MARVEL_API_PUBLIC`变量的值临时重命名为`VITE_APP_MARVEL_API_PUBLIC_ERROR`。完成后我们将将其改回！如果您运行应用程序，它将无法请求任何内容，您将在控制台看到我们设置的错误消息。
- en: Handling the error
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理错误
- en: Now we’ll focus on dealing with the error in a user-friendly way. Let’s start
    with the `ComicsOverview.vue` file. We’ll wrap the contents of the `getComics`
    function with another `try`/`catch` block.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将专注于以用户友好的方式处理错误。让我们从`ComicsOverview.vue`文件开始。我们将用另一个`try`/`catch`块包裹`getComics`函数的内容。
- en: 'In this case, the user cannot recover the state from this error, so it doesn’t
    make sense to remain on this page, since it’s completely broken. We’ll redirect
    the user to our error page instead. This means we’ll import the `useRouter` composable
    from `vue-router` and instantiate it on the component. We’ll modify file and specifically
    the `getComics` function accordingly: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.7-ComicsOverview.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.7-ComicsOverview.vue)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，用户无法从这种错误中恢复状态，因此留在该页面上没有意义，因为它已经完全损坏。我们将用户重定向到我们的错误页面。这意味着我们将从`vue-router`导入`useRouter`组合式并在组件上实例化它。我们将相应地修改文件，特别是`getComics`函数：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.7-ComicsOverview.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.7-ComicsOverview.vue)
- en: We’re importing (*line 4*) and registering the router (*line 14*) and use the
    `router` to redirect to a new route when an error occurs (*lines 27-29*).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在（*第4行*）导入并注册路由（*第14行*），并在发生错误时使用`router`重定向到新路由（*第27-29行*）。
- en: 'Next, we’ll create a component to show in the `ErrorView.vue`. Let’s create
    a new component called `ErrorMessage.vue` with some static content:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个在`ErrorView.vue`中显示的组件。让我们创建一个名为`ErrorMessage.vue`的新组件，其中包含一些静态内容：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And we’ll update `ErrorView.vue` to load the component:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将更新`ErrorView.vue`以加载该组件：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we run our code, we should get redirected to the `/error` path as long as
    the API treats us as if we’re not authorized. We’ll add `errorhandling` to `SearchCharacter.vue`
    as well in similar fashion:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行我们的代码，只要API将我们视为未授权，我们应该会被重定向到`/error`路径。我们也将以类似的方式在`SearchCharacter.vue`中添加`errorhandling`：
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this case, after you’ve attempted a search, the app will redirect to the
    same page. It would be nice if we could provide a bit of context to our user,
    so they can better understand what went wrong. Fortunately, we have access to
    the error message we’ve thrown in the `catch` block.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在你尝试搜索之后，应用将重定向到同一页面。如果能为我们用户提供一些上下文，让他们更好地理解出了什么问题，那就太好了。幸运的是，我们可以访问我们在`catch`块中抛出的错误消息。
- en: Adding query parameters
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加查询参数
- en: We’ll modify the `router.push` action so that it passes some additional information
    to the destination.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改`router.push`动作，使其向目的地传递一些额外的信息。
- en: 'It’s an easy change that we’ll apply to both the `ComicsOverview.vue` and the
    `SearchCharacter.vue` line. Let’s change this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的更改，我们将将其应用到`ComicsOverview.vue`和`SearchCharacter.vue`的行上。让我们更改这个：
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And we’ll change it so that it provides information on the `query` parameter:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将修改它，使其提供有关`query`参数的信息：
- en: '[PRE44]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this case, we’ll pass the message from the error message as a `query` parameter
    to the route. Note that it is not meant to send a large amount of text, but it
    serves as a good example of using the `query` parameters.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将把错误消息中的信息作为`query`参数传递给路由。请注意，这并不是为了发送大量文本，但它是一个很好的使用`query`参数的例子。
- en: 'Lastly, we can modify the `ErrorMessage.vue` file to read into the `query`
    parameter in order to show it on the component. We can achieve that by reading
    into the route by utilizing the `useRoute` composable once the component is mounted.
    The file would look like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以修改`ErrorMessage.vue`文件，以便读取`query`参数并将其显示在组件上。我们可以通过在组件挂载后利用`useRoute`可组合式来读取路由来实现这一点。文件将看起来像这样：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If you now end up in the error state, you should see a message stating more
    accurately what went wrong. Don’t forget to rename your `VITE_APP_MARVEL_API_PUBLIC`
    variable once you’re done!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在处于错误状态，你应该看到一个更准确地说明出了什么问题的消息。完成操作后，别忘了重命名你的`VITE_APP_MARVEL_API_PUBLIC`变量！
- en: At this point we’ve made good progress on pretty common techniques and principles.
    In this chapter, we have introduced composables to the app, which bring reusable
    functionalities. We’ve also added client side routing and were able to create
    links in our apps’ user interface as well as apply dynamic routing and passing
    additional parameters.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在一些相当常见的技巧和原则上已经取得了良好的进展。在本章中，我们向应用中引入了可组合式，这带来了可重用的功能。我们还添加了客户端路由，并能够在我们的应用程序用户界面中创建链接，以及应用动态路由和传递额外的参数。
- en: As an extra bonus, we’ve introduced basic error handling and learned a bit more
    about favorite Marvel comic books.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的奖励，我们介绍了基本的错误处理，并对喜欢的漫威漫画书籍有了一些了解。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we’ve learned how to add multiple pages and navigate by several
    means: by using the router-link component or manipulating the routes programmatically.
    We’ve created composables in order to use and reuse logic within our application.
    For a better user experience, we learned how we can handle errors in a user-friendly
    manner.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何添加多个页面，并通过多种方式导航：使用router-link组件或通过编程方式操作路由。我们创建了可组合式，以便在应用程序中使用和重用逻辑。为了提供更好的用户体验，我们学习了如何以用户友好的方式处理错误。
- en: In our next chapter, we’ll build an application using Vuetify, a third-party
    component library. Component libraries allow us to speed up development by making
    use of ready-made components. In addition, we’ll introduce an application state
    using Pinia, where we can modularly store data (or a state) to be shared between
    components throughout our application.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用Vuetify构建一个应用程序，这是一个第三方组件库。组件库允许我们通过使用现成的组件来加速开发。此外，我们还将介绍使用Pinia的应用程序状态，我们可以将数据（或状态）模块化存储，以便在整个应用程序中共享组件之间的数据。
- en: 'Part 2: Intermediate Projects'
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：中级项目
- en: In this part, you will iterate on using external APIs to build data-rich applications.
    You will also learn how to handle more complex application state, apply the basics
    of data storage and retrieval, and identify when and how to use short-term storage
    or long-term, persistent storage solutions. You will be introduced to using web
    technologies to build applications beyond the web and deploy them anywhere.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，你将学习如何迭代使用外部API来构建数据丰富的应用程序。你还将了解如何处理更复杂的应用程序状态，应用数据存储和检索的基本知识，以及何时以及如何使用短期存储或长期持久化存储解决方案。你将了解到如何使用网络技术构建超越网络的应用程序并将它们部署到任何地方。
- en: 'This part has the following chapters:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 5*](B19563_05.xhtml#_idTextAnchor130), *Building a Recipe App with
    Vuetify*'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B19563_05.xhtml#_idTextAnchor130)，*使用Vuetify构建食谱应用*'
- en: '[*Chapter 6*](B19563_06.xhtml#_idTextAnchor162), *Creating a Fitness Tracker
    with Data Visualization*'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B19563_06.xhtml#_idTextAnchor162)，*使用数据可视化创建健身追踪器*'
- en: '[*Chapter 7*](B19563_07.xhtml#_idTextAnchor204), *Building a Multi-Platform
    Expense Tracker Using Quasar*'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B19563_07.xhtml#_idTextAnchor204)，*使用Quasar构建多平台支出追踪器*'
