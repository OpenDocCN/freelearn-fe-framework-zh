<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Tabs - Grouping Content into Tab Sections</h1>
                </header>
            
            <article>
                
<p>In this chapter, you'll learn about the following recipes:</p>
<ul>
<li>AppBar integration</li>
<li>Tab alignment</li>
<li>Rendering tabs based on state</li>
<li>Abstracting tab content</li>
<li>Tab navigation with routes</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>The<span> </span><kbd>Tabs</kbd><span> Material-UI component is used to organize content on your screen. The tabs are organized in a horizontal fashion and they should feel natural for your users. You can use tabs any time your screen has lots of content that could be split into different category sections.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AppBar integration</h1>
                </header>
            
            <article>
                
<p><kbd>AppBar</kbd> components can be used with the <kbd>Tabs</kbd> component. You can do this so that the tab buttons are rendered within an App Bar. This provides a container for your tab buttons—by default, there is nothing surrounding them.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that you have a <kbd>Tabs</kbd> component with three <kbd>Tab</kbd> buttons. Instead of rendering the tabs so that they look as though they're floating on the screen, you can wrap them in an <kbd>AppBar</kbd> component to give them a contained look and feel. Here's the code:</p>
<pre>import React, { useState } from 'react';<br/><br/>import { withStyles } from '@material-ui/core/styles';<br/>import AppBar from '@material-ui/core/AppBar';<br/>import Tabs from '@material-ui/core/Tabs';<br/>import Tab from '@material-ui/core/Tab';<br/>import Typography from '@material-ui/core/Typography';<br/><br/>const styles = theme =&gt; ({<br/>  root: {<br/>    flexGrow: 1,<br/>    backgroundColor: theme.palette.background.paper<br/>  },<br/>  tabContent: {<br/>    padding: theme.spacing.unit * 2<br/>  }<br/>});<br/><br/>function AppBarIntegration({ classes }) {<br/>  const [value, setValue] = useState(0);<br/><br/>  const onChange = (e, value) =&gt; {<br/>    setValue(value);<br/>  };<br/><br/>  return (<br/>    &lt;div className={classes.root}&gt;<br/>      &lt;AppBar position="static"&gt;<br/>        &lt;Tabs value={value} onChange={onChange}&gt;<br/>          &lt;Tab label="Item One" /&gt;<br/>          &lt;Tab label="Item Two" /&gt;<br/>          &lt;Tab label="Item Three" /&gt;<br/>        &lt;/Tabs&gt;<br/>      &lt;/AppBar&gt;<br/>      {value === 0 &amp;&amp; (<br/>        &lt;Typography component="div" className={classes.tabContent}&gt;<br/>          Item One<br/>        &lt;/Typography&gt;<br/>      )}<br/>      {value === 1 &amp;&amp; (<br/>        &lt;Typography component="div" className={classes.tabContent}&gt;<br/>          Item Two<br/>        &lt;/Typography&gt;<br/>      )}<br/>      {value === 2 &amp;&amp; (<br/>        &lt;Typography component="div" className={classes.tabContent}&gt;<br/>          Item Three<br/>        &lt;/Typography&gt;<br/>      )}<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>export default withStyles(styles)(AppBarIntegration);</pre>
<p>When the screen first loads, you'll see the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/09960806-49a4-4d67-976e-75b0667b6abe.png" style="width:20.17em;height:6.50em;"/></p>
<p>When you click on one of the tab buttons, the selected tab changes, along with the content <span>underneath</span> the tabs. For example, clicking on the <span class="packt_screen">ITEM THREE</span> tab results in this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e7b18d8b-8848-4de1-b7fe-04f5edcb640b.png" style="width:19.58em;height:6.25em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>Tabs</kbd> and <kbd>Tab</kbd> components are rendered inside the <kbd>AppBar</kbd> component. Usually, <kbd>AppBar</kbd> has a <kbd>Toolbar</kbd> component as its child, but <kbd>Tab</kbd> can work too:</p>
<pre>&lt;AppBar position="static"&gt;<br/>  &lt;Tabs value={value} onChange={onChange}&gt;<br/>    &lt;Tab label="Item One" /&gt;<br/>    &lt;Tab label="Item Two" /&gt;<br/>    &lt;Tab label="Item Three" /&gt;<br/>  &lt;/Tabs&gt;<br/>&lt;/AppBar&gt;</pre>
<p class="mce-root"/>
<p>Your component has a <kbd>value</kbd> state that is used to keep track of the selected tab. The <kbd>onChange()</kbd> handler is used to update this state; it gets set to the current index of the selected tab. Then, you can use the <kbd>value</kbd> state to determine which content to render below the <kbd>AppBar</kbd> component:</p>
<pre>{value === 0 &amp;&amp; (<br/>  &lt;Typography<br/>    component="div"<br/>    className={classes.tabContent}<br/>  &gt;<br/>    Item One<br/>  &lt;/Typography&gt;<br/>)}<br/>{value === 1 &amp;&amp; (<br/>  &lt;Typography<br/>    component="div"<br/>    className={classes.tabContent}<br/>  &gt;<br/>    Item Two<br/>  &lt;/Typography&gt;<br/>)}<br/>{value === 2 &amp;&amp; (<br/>  &lt;Typography<br/>    component="div"<br/>    className={classes.tabContent}<br/>  &gt;<br/>    Item Three<br/>  &lt;/Typography&gt;<br/>)}</pre>
<p>If the first tab is selected, then the value is <kbd>0</kbd> and the <kbd>Item One</kbd> text is rendered. The same logic follows for the other two tabs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>If you want tabs but you don't want the indicator that's rendered <span>underneath</span> the text, you can set it to be the same color as the <kbd>AppBar</kbd> component. This is done using the <kbd>indicatorColor</kbd> property, as follows:</p>
<pre>&lt;Tabs<br/>  value={value}<br/>  onChange={this.onChange}<br/>  indicatorColor="primary"<br/>&gt;<br/>  &lt;Tab label="Item One" /&gt;<br/>  &lt;Tab label="Item Two" /&gt;<br/>  &lt;Tab label="Item Three" /&gt;<br/>&lt;/Tabs&gt;</pre>
<p>By setting the <kbd>indicatorColor</kbd> value to <kbd>primary</kbd>, the indicator should now be the same color as the <kbd>AppBar</kbd> component:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b21a3313-39ab-43f7-a191-f791bc18cc2a.png" style="width:19.83em;height:6.67em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>Tabs</kbd> API documentation: <a href="https://material-ui.com/api/tabs/">https://material-ui.com/api/tabs/</a></li>
<li><kbd>Tabs</kbd> demos: <a href="https://material-ui.com/demos/tabs/">https://material-ui.com/demos/tabs/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tab alignment</h1>
                </header>
            
            <article>
                
<p>The <kbd>Tabs</kbd> component has two properties to help you align your tab buttons. The <kbd>centered</kbd> property centers the tabs, while the <kbd>fullWidth</kbd> property spreads out the tabs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that you have three basic tabs using the following code:</p>
<pre>import React, { useState } from 'react';<br/><br/>import { withStyles } from '@material-ui/core/styles';<br/>import Tabs from '@material-ui/core/Tabs';<br/>import Tab from '@material-ui/core/Tab';<br/><br/>const styles = theme =&gt; ({<br/>  root: {<br/>    flexGrow: 1,<br/>    backgroundColor: theme.palette.background.paper<br/>  }<br/>});<br/><br/>function TabAlignment({ classes }) {<br/>  const [value, setValue] = useState(0);<br/><br/>  const onChange = (e, value) =&gt; {<br/>    setValue(value);<br/>  };<br/><br/>  return (<br/>    &lt;div className={classes.root}&gt;<br/>      &lt;Tabs value={value} onChange={onChange}&gt;<br/>        &lt;Tab label="Item One" /&gt;<br/>        &lt;Tab label="Item Two" /&gt;<br/>        &lt;Tab label="Item Three" /&gt;<br/>      &lt;/Tabs&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>export default withStyles(styles)(TabAlignment);</pre>
<p>Here's what you should see when the screen first loads:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/39fbb81c-8587-4e7d-baef-56929e5508ce.png" style="width:40.83em;height:4.50em;"/></p>
<p>By default, tabs are aligned to the left. You can center your tabs by setting the <kbd>centered</kbd> property, as follows:</p>
<pre>&lt;Tabs value={value} onChange={onChange} centered&gt;<br/>  &lt;Tab label="Item One" /&gt;<br/>  &lt;Tab label="Item Two" /&gt;<br/>  &lt;Tab label="Item Three" /&gt;<br/>&lt;/Tabs&gt;</pre>
<p>Here's what centered tabs look like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d8af98bd-1853-465b-9ba1-86100051bcbf.png" style="width:39.67em;height:4.67em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>When your tabs are centered, all of the empty space goes to the left and right of the tabs. The alternative is setting the <kbd>variant</kbd> property to <kbd>fullWidth</kbd>:</p>
<pre>&lt;Tabs value={value} onChange={onChange} variant="fullWidth"&gt;<br/>  &lt;Tab label="Item One" /&gt;<br/>  &lt;Tab label="Item Two" /&gt;<br/>  &lt;Tab label="Item Three" /&gt;<br/>&lt;/Tabs&gt;</pre>
<p>Here's what full width tabs look like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e9bf778b-ce3f-4224-b2a3-36a7f5cb8fa5.png" style="width:18.42em;height:3.83em;"/></p>
<p>The tabs are centered, but they're spaced evenly to cover the width of the screen.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>centered</kbd> property is just a convenient way of specifying the <kbd>justifyContent</kbd> style on the <kbd>Tabs</kbd> component. Whenever there is a property to style Material-UI components in a specific way, you should use it instead of applying your own styles. Future versions of the library could include fixes that rely on the property that you'll miss out on.</p>
<p>Another reason to style components using the property is that Material-UI might behave differently depending on how other properties are set. For example, with the <kbd>Tabs</kbd> component, you can't set the <kbd>centered</kbd> property while the <kbd>scrollable</kbd> property is set to true; Material-UI checks for this and handles it.</p>
<p>The <kbd>fullWidth</kbd> value of the <kbd>variant</kbd> property is actually passed to the <kbd>Tab</kbd> component, which alters the styles it uses based on this value. The result is the even spacing of tabs within the container element.</p>
<div class="packt_tip">You can set the <kbd>centered</kbd> and <kbd>variant</kbd> properties at the same time. However, <kbd>centered</kbd> isn't necessary if <kbd>variant</kbd> has a value of <kbd>fullWidth</kbd>. Using both is harmless though.</div>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>The centered layout for tabs works well on smaller screens, while the full width layout looks good on larger screens. You can use Material-UI utilities that tell you about breakpoint changes. You can then use this information to change the alignment of your tabs.</p>
<p>Here's a modified version of this example:</p>
<pre>import React, { useState } from 'react';<br/>import compose from 'recompose/compose';<br/><br/>import { withStyles } from '@material-ui/core/styles';<br/>import withWidth from '@material-ui/core/withWidth';<br/>import Tabs from '@material-ui/core/Tabs';<br/>import Tab from '@material-ui/core/Tab';<br/><br/>const styles = theme =&gt; ({<br/>  root: {<br/>    flexGrow: 1,<br/>    backgroundColor: theme.palette.background.paper<br/>  }<br/>});<br/><br/>function TabAlignment({ classes, width }) {<br/>  const [value, setValue] = useState(0);<br/><br/>  const onChange = (e, value) =&gt; {<br/>    setValue(value);<br/>  };<br/><br/>  return (<br/>    &lt;div className={classes.root}&gt;<br/>      &lt;Tabs<br/>        value={value}<br/>        onChange={onChange}<br/>        variant={['xs', 'sm'].includes(width) ? null : 'fullWidth'}<br/>        centered<br/>      &gt;<br/>        &lt;Tab label="Item One" /&gt;<br/>        &lt;Tab label="Item Two" /&gt;<br/>        &lt;Tab label="Item Three" /&gt;<br/>      &lt;/Tabs&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>export default compose(<br/>  withWidth(),<br/>  withStyles(styles)<br/>)(TabAlignment);</pre>
<p>Now when you resize your screen, the alignment properties of the grid can change in response to breakpoint changes. Let's break down these changes from the bottom up, starting with the <kbd>variant</kbd> property value:</p>
<pre>variant={['xs', 'sm'].includes(width) ? null : 'fullWidth'}</pre>
<p>The value will be <kbd>fullWidth</kbd> if the <kbd>width</kbd> property is anything but the <kbd>xs</kbd> or <kbd>sm</kbd> breakpoint. In other words, if it's a larger screen, the value will be <kbd>fullWidth</kbd>.</p>
<p>Next, you need the width property to be passed to your component somehow. You can use the <kbd>withWidth()</kbd> utility from Material-UI. It works like <kbd>withStyles()</kbd> in that it returns a new component with new properties assigned to it. The component returned by <kbd>withWidth()</kbd> will update its <kbd>width</kbd> prop any time the breakpoint changes. For example, if the user resizes their screen from <kbd>sm</kbd> to <kbd>md</kbd>, this will trigger a width change and <kbd>fullWidth</kbd> will change from false to true.</p>
<p>To use the <kbd>withWidth()</kbd> component—along with the <kbd>withStyles()</kbd> component—you can use the <kbd>compose()</kbd> function from <kbd>recompose</kbd>. This function makes your code more readable when you're applying several higher-order functions that decorate your component:</p>
<pre>export default compose(<br/>  withWidth(),<br/>  withStyles(styles)<br/>)(TabAlignment);</pre>
<p>You could call <kbd>withWidth(withStyles(styles))(TabAlignment)</kbd> if you really don't want to use <kbd>recompose</kbd>, but as a general rule, I like to use it any time more than one higher-order function is involved.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>Tabs</kbd> demos: <a href="https://material-ui.com/demos/tabs/">https://material-ui.com/demos/tabs/</a></li>
<li><kbd>Tabs</kbd> API documentation: <a href="https://material-ui.com/api/tabs/">https://material-ui.com/api/tabs/</a></li>
<li>Tools for composing React components: <a href="https://github.com/acdlite/recompose/">https://github.com/acdlite/recompose/</a></li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rendering tabs based on state</h1>
                </header>
            
            <article>
                
<p>Tabs in your React application might be driven by data. If so, you can set tab data in the state of your component to have them render initially and update if anything changes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that you have some data that determines the tabs to render in your app. You can set this data in the state of your component and use it to render the <kbd>Tab</kbd> components, as well as the tab content when tab selections are made. Here's the code:</p>
<pre>import React, { useState } from 'react';<br/><br/>import { makeStyles } from '@material-ui/styles';<br/>import Tabs from '@material-ui/core/Tabs';<br/>import Tab from '@material-ui/core/Tab';<br/>import Typography from '@material-ui/core/Typography';<br/><br/>const useStyles = makeStyles(theme =&gt; ({<br/>  root: {<br/>    flexGrow: 1,<br/>    backgroundColor: theme.palette.background.paper<br/>  },<br/>  tabContent: {<br/>    padding: theme.spacing(2)<br/>  }<br/>}));<br/><br/>export default function RenderingTabsBasedOnState() {<br/>  const classes = useStyles();<br/>  const [tabs, setTabs] = useState([<br/>    {<br/>      active: true,<br/>      label: 'Item One',<br/>      content: 'Item One Content'<br/>    },<br/>    {<br/>      active: false,<br/>      label: 'Item Two',<br/>      content: 'Item Two Content'<br/>    },<br/>    {<br/>      active: false,<br/>      label: 'Item Three',<br/>      content: 'Item Three Content'<br/>    }<br/>  ]);<br/><br/>  const onChange = (e, value) =&gt; {<br/>    setTabs(<br/>      tabs<br/>        .map(tab =&gt; ({ ...tab, active: false }))<br/>        .map((tab, index) =&gt; ({<br/>          ...tab,<br/>          active: index === value<br/>        }))<br/>    );<br/>  };<br/><br/>  const active = tabs.findIndex(tab =&gt; tab.active);<br/>  const content = tabs[active].content;<br/><br/>  return (<br/>    &lt;div className={classes.root}&gt;<br/>      &lt;Tabs value={active} onChange={onChange}&gt;<br/>        {tabs<br/>          .map(tab =&gt; (<br/>            &lt;Tab<br/>              key={tab.label}<br/>              label={tab.label}<br/>            /&gt;<br/>          ))}<br/>      &lt;/Tabs&gt;<br/>      &lt;Typography component="div" className={classes.tabContent}&gt;<br/>        {content}<br/>      &lt;/Typography&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</pre>
<p>When you first load the screen, you'll see the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/59bf0bed-1616-4cc2-9921-b16103e6f1da.png" style="width:16.08em;height:5.50em;"/></p>
<p>If you click on the <span class="packt_screen">ITEM TWO</span> tab, here's what you'll see:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bdbaebd1-78ec-4887-b5e3-2a8142bc7904.png" style="width:17.42em;height:5.75em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's start by looking at the state of your component that drives the <kbd>tabs</kbd> that are rendered:</p>
<pre>const [tabs, setTabs] = useState([<br/>  {<br/>    active: true,<br/>    label: 'Item One',<br/>    content: 'Item One Content'<br/>  },<br/>  {<br/>    active: false,<br/>    label: 'Item Two',<br/>    content: 'Item Two Content'<br/>  },<br/>  {<br/>    active: false,<br/>    label: 'Item Three',<br/>    content: 'Item Three Content'<br/>  }<br/>]);</pre>
<p>The <kbd>tabs</kbd> state is an array, and each object within it represents a tab to be rendered. The <kbd>active</kbd> Boolean property determines which tab is <kbd>active</kbd>. The <kbd>label</kbd> property is what is rendered as the actual tab button and the content is rendered below the tabs when the tab is clicked on.</p>
<p>Next, let's take a look at the markup used to render the <kbd>tabs</kbd> and the content:</p>
<pre>&lt;Tabs value={active} onChange={onChange}&gt;<br/>  {tabs.map(tab =&gt; &lt;Tab label={tab.label} /&gt;)}<br/>&lt;/Tabs&gt;<br/>&lt;Typography component="div" className={classes.tabContent}&gt;<br/>  {content}<br/>&lt;/Typography&gt;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Instead of manually rendering <kbd>Tab</kbd> components, you're iterating over the <kbd>tabs</kbd> state to render each tab. For the selected content, you now only have to render one <kbd>Typography</kbd> component that references <kbd>content</kbd>.</p>
<p>Let's take a look at the two <kbd>active</kbd> and <kbd>content</kbd> values, as follows:</p>
<pre>const active = tabs.findIndex(tab =&gt; tab.active);<br/>const content = tabs[active].content;</pre>
<p>The <kbd>active</kbd> constant is the index of the active tab. This value is passed to the <kbd>value</kbd> property of the <kbd>Tabs</kbd> component. It's also used by the <kbd>content</kbd> value—the content of the active tab. Both of these constants simplify the markup that your component needs to render.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Now that you're controlling your tabs with <kbd>state</kbd>, you can control more aspects of your rendered tabs. For instance, you could add <kbd>disabled</kbd> and <kbd>hidden</kbd> states to each tab. You could also place an <kbd>icon</kbd> property to render in your tab state. Here's a new version of the <kbd>tabs</kbd> state:</p>
<pre>const [tabs, setTabs] = useState([<br/>  {<br/>    active: true,<br/>    label: 'Home',<br/>    content: 'Home Content',<br/>    icon: &lt;HomeIcon /&gt;<br/>  },<br/>  {<br/>    active: false,<br/>    label: 'Settings',<br/>    content: 'Settings Content',<br/>    icon: &lt;SettingsIcon /&gt;<br/>  },<br/>  {<br/>    active: false,<br/>    disabled: true,<br/>    label: 'Search',<br/>    content: 'Search Content',<br/>    icon: &lt;SearchIcon /&gt;<br/>  },<br/>  {<br/>    active: false,<br/>    hidden: true,<br/>    label: 'Add',<br/>    content: 'AddContent',<br/>    icon: &lt;AddIcon /&gt;<br/>  }<br/>]);</pre>
<p>Now you have the ability to render <kbd>disabled</kbd> tabs that cannot be clicked on—as is the case with the <span class="packt_screen">SEARCH</span> tab. You can also hide tabs completely by setting <kbd>hidden</kbd> to <kbd>true</kbd>—as is the case with the <span class="packt_screen">Add</span> tab. Every tab now has an icon as well. Let's see what this looks like when you load the screen:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d1c63de0-6440-4891-8cb8-2e87825e78ff.png" style="width:14.67em;height:6.58em;"/></p>
<p>The icons for every tab are rendered as expected, even for the <span><span class="packt_screen">SEARCH</span></span> tab, which has been marked as <kbd>disabled</kbd>. There's no <span class="packt_screen">Add</span> tab because it was marked as <kbd>hidden</kbd>. Let's take a look at the changes to the <kbd>Tabs</kbd> markup that were necessary to accommodate these new state values:</p>
<pre>&lt;Tabs value={active} onChange={onChange}&gt;<br/>  {tabs<br/>    .filter(tab =&gt; !tab.hidden)<br/>    .map(tab =&gt; (<br/>      &lt;Tab<br/>        key={tab.label}<br/>        disabled={tab.disabled}<br/>        icon={tab.icon}<br/>        label={tab.label}<br/>      /&gt;<br/>    ))}<br/>&lt;/Tabs&gt;</pre>
<p>The <kbd>disabled</kbd> and <kbd>icon</kbd> properties of <kbd><span>Tab</span></kbd> are passed directly from the tab in your component state. The <kbd>filter()</kbd> call was added to remove tabs that are marked as hidden.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>Tabs</kbd> API documentation: <a href="https://material-ui.com/api/tabs/">https://material-ui.com/api/tabs/</a></li>
<li><a href="https://material-ui.com/api/tab/"/></li>
<li><kbd>Tabs</kbd> demos: <a href="https://material-ui.com/demos/tabs/">https://material-ui.com/demos/tabs/</a></li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Abstracting tab content</h1>
                </header>
            
            <article>
                
<p>If your application uses tabs in several places, you can create abstractions that simplify the markup involved with rendering tabs and tab content. Instead of having tab content defined outside of the tabs component, why not have everything be self-contained and easier to read?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that your app uses tabs in several places throughout your app, and you want to simplify the markup used to create the tabs and the tab content. In the places where you use tabs, you just want to be able to render the content and not have to worry about handing state for the active tab. Here's some code that creates two new components that simplify the <strong><span>JavaScript XML</span></strong> (<strong>JSX</strong>) required for rendering tab content:</p>
<pre>import React, { Fragment, Children, useState } from 'react';<br/><br/>import { withStyles } from '@material-ui/core/styles';<br/>import Tabs from '@material-ui/core/Tabs';<br/>import Tab from '@material-ui/core/Tab';<br/>import Typography from '@material-ui/core/Typography';<br/><br/>const styles = theme =&gt; ({<br/>  root: {<br/>    flexGrow: 1,<br/>    backgroundColor: theme.palette.background.paper<br/>  },<br/>  tabContent: {<br/>    padding: theme.spacing(2)<br/>  }<br/>});<br/><br/>function TabContainer({ children }) {<br/>  const [value, setValue] = useState(0);<br/><br/>  const onChange = (e, value) =&gt; {<br/>    setValue(value);<br/>  };<br/><br/>  return (<br/>    &lt;Fragment&gt;<br/>      &lt;Tabs value={value} onChange={onChange}&gt;<br/>        {Children.map(children, child =&gt; (<br/>          &lt;Tab label={child.props.label} /&gt;<br/>        ))}<br/>      &lt;/Tabs&gt;<br/>      {Children.map(children, (child, index) =&gt;<br/>        index === value ? child : null<br/>      )}<br/>    &lt;/Fragment&gt;<br/>  );<br/>}<br/><br/>const TabContent = withStyles(styles)(({ classes, children }) =&gt; (<br/>  &lt;Typography component="div" className={classes.tabContent}&gt;<br/>    {children}<br/>  &lt;/Typography&gt;<br/>));<br/><br/>const AbstractingTabContent = withStyles(styles)(({ classes }) =&gt; (<br/>  &lt;div className={classes.root}&gt;<br/>    &lt;TabContainer&gt;<br/>      &lt;TabContent label="Item One"&gt;Item One Content&lt;/TabContent&gt;<br/>      &lt;TabContent label="Item Two"&gt;Item Two Content&lt;/TabContent&gt;<br/>      &lt;TabContent label="Item Three"&gt;Item Three Content&lt;/TabContent&gt;<br/>    &lt;/TabContainer&gt;<br/>  &lt;/div&gt;<br/>));<br/><br/>export default AbstractingTabContent;</pre>
<p>When you load the screen, you'll see three tabs rendered with the first tab selected by default. The content of the first tab is also visible. The following screenshot shows what it looks like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e048c474-bfd1-4b15-932a-08fafd552787.png" style="width:15.83em;height:5.42em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's start by looking at the markup used to render the tabs in this following example:</p>
<pre>&lt;TabContainer&gt;<br/>  &lt;TabContent label="Item One"&gt;Item One Content&lt;/TabContent&gt;<br/>  &lt;TabContent label="Item Two"&gt;Item Two Content&lt;/TabContent&gt;<br/>  &lt;TabContent label="Item Three"&gt;Item Three Content&lt;/TabContent&gt;<br/>&lt;/TabContainer&gt;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This markup is much more concise than using the <kbd>Tab</kbd> and <kbd>Tabs</kbd> components directly. This approach also handles rendering the content of the selected tab. Everything is self-contained with this approach.</p>
<p>Next, let's take a look at the <kbd>TabContainer</kbd> component:</p>
<pre>function TabContainer({ children }) {<br/>  const [value, setValue] = useState(0);<br/><br/>  const onChange = (e, value) =&gt; {<br/>    setValue(value);<br/>  };<br/><br/>  return (<br/>    &lt;Fragment&gt;<br/>      &lt;Tabs value={value} onChange={onChange}&gt;<br/>        {Children.map(children, child =&gt; (<br/>          &lt;Tab label={child.props.label} /&gt;<br/>        ))}<br/>      &lt;/Tabs&gt;<br/>      {Children.map(children, (child, index) =&gt;<br/>        index === value ? child : null<br/>      )}<br/>    &lt;/Fragment&gt;<br/>  );<br/>}</pre>
<p>The <kbd>TabContainer</kbd> component handles the state of the selected tab and changing the state when a different tab is selected. This component renders a <kbd>Fragment</kbd> component so that it can place the selected tab content after the <kbd>Tabs</kbd> component. It's using <kbd>Children.map()</kbd> to render the individual <kbd>Tab</kbd> components. The label of the tab comes from the <kbd>label</kbd> property of the child. In this example, there are three children (<kbd>TabContent</kbd>). The next call to <kbd>Children.map()</kbd> renders the content of the selected tab. This is based on the <kbd>value</kbd> state—if the child index matches, it's the <kbd>active</kbd> content. Otherwise, it gets mapped to <kbd>null</kbd> and nothing is rendered.</p>
<p>Lastly, let's take a look at the <kbd>TabContent</kbd> component:</p>
<pre>const TabContent = withStyles(styles)(({ classes, children }) =&gt; (<br/>  &lt;Typography component="div" className={classes.tabContent}&gt;<br/>    {children}<br/>  &lt;/Typography&gt;<br/>));</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p><kbd>TabContent</kbd> takes care of styling the <kbd>Typography</kbd> component and renders the child text within. Although the <kbd>label</kbd> property is passed to <kbd>TabContent</kbd>, it doesn't actually use it; instead, it's used by <kbd>TabContainer</kbd> when rendering tabs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>You can add a <kbd>value</kbd> property to the <kbd>TabsContainer</kbd> component so that you can set whichever tab to activate initially. For example, you might want the second tab to be <kbd>active</kbd> instead of the first tab when the screen first loads. To do this, you'll have to add a default property value for <kbd>value</kbd>, call <kbd>setValue()</kbd> if the <kbd>value</kbd> state hasn't been set yet, and remove <kbd>value</kbd> from the initial state:</p>
<pre>function TabContainer({ children, value: valueProp }) {<br/>  const [value, setValue] = useState();<br/><br/>  const onChange = (e, value) =&gt; {<br/>    setValue(value);<br/>  };<br/><br/>  if (value === undefined) {<br/>    setValue(valueProp);<br/>  }<br/><br/>  return (<br/>    &lt;Fragment&gt;<br/>      &lt;Tabs value={value} onChange={onChange}&gt;<br/>        {Children.map(children, child =&gt; (<br/>          &lt;Tab label={child.props.label} /&gt;<br/>        ))}<br/>      &lt;/Tabs&gt;<br/>      {Children.map(children, (child, index) =&gt;<br/>        index === value ? child : null<br/>      )}<br/>    &lt;/Fragment&gt;<br/>  );<br/>}<br/><br/>TabContainer.defaultProps = {<br/>  value: 0<br/>};</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The default property is necessary because the <kbd>value</kbd> state is now undefined by default. The <kbd>setValue()</kbd> method is called if the <kbd>value</kbd> state is undefined. If it is, then you can set it by passing it the <kbd>value</kbd> property value.</p>
<p>Now, you can pass this property to your component to change the initially-active tab:</p>
<pre>&lt;TabContainer value={1}&gt;<br/>  &lt;TabContent label="Item One"&gt;Item One Content&lt;/TabContent&gt;<br/>  &lt;TabContent label="Item Two"&gt;Item Two Content&lt;/TabContent&gt;<br/>  &lt;TabContent label="Item Three"&gt;Item Three Content&lt;/TabContent&gt;<br/>&lt;/TabContainer&gt;</pre>
<p>The value property is set to <kbd>1</kbd>. It's a zero-based index, which means that the second tab will be active by default:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3e1099f3-0513-4a71-a2f5-af4903b1a7ed.png" style="width:30.92em;height:5.33em;"/></p>
<p>When the user starts clicking on other tabs, the <kbd>value</kbd> state updates as expected—only the initially-active tab is impacted by this change.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>Tabs</kbd> API documentation: <a href="https://material-ui.com/api/tabs/">https://material-ui.com/api/tabs/</a></li>
<li><kbd>Tabs</kbd> demos: <a href="https://material-ui.com/demos/tab/">https://material-ui.com/demos/tab/</a></li>
<li>Working with React child components: <a href="https://reactjs.org/docs/react-api.html#reactchildren">https://reactjs.org/docs/react-api.html#reactchildren</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tab navigation with routes</h1>
                </header>
            
            <article>
                
<p>You can base your tab content on routes in a routing solution, such as <kbd>react-router</kbd>. To do this, you have to make your tab buttons into links, and you need to have <kbd>Route</kbd> components below the <kbd>Tabs</kbd> component to render the current URL.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that your app has three URLs and you want tabs as the navigation mechanism to navigate between the routes. The first step is turning the <kbd>Tab</kbd> buttons into links. The second step is having <kbd>Route</kbd> components render the appropriate tab content, based on which one was clicked on. Here's the code:</p>
<pre>import React, { useState } from 'react';<br/>import { Route, Link } from 'react-router-dom';<br/><br/>import { withStyles } from '@material-ui/core/styles';<br/>import AppBar from '@material-ui/core/AppBar';<br/>import Tabs from '@material-ui/core/Tabs';<br/>import Tab from '@material-ui/core/Tab';<br/>import Typography from '@material-ui/core/Typography';<br/><br/>const styles = theme =&gt; ({<br/>  root: {<br/>    flexGrow: 1,<br/>    backgroundColor: theme.palette.background.paper<br/>  },<br/>  tabContent: {<br/>    padding: theme.spacing(2)<br/>  }<br/>});<br/><br/>function TabNavigationWithRoutes({ classes }) {<br/>  const [value, setValue] = useState(0);<br/><br/>  const onChange = (e, value) =&gt; {<br/>    setValue(value);<br/>  };<br/><br/>  return (<br/>    &lt;div className={classes.root}&gt;<br/>      &lt;AppBar position="static"&gt;<br/>        &lt;Tabs value={value} onChange={onChange}&gt;<br/>          &lt;Tab label="Item One" component={Link} to="/" /&gt;<br/>          &lt;Tab label="Item Two" component={Link} to="/page2" /&gt;<br/>          &lt;Tab label="Item Three" component={Link} to="/page3" /&gt;<br/>        &lt;/Tabs&gt;<br/>      &lt;/AppBar&gt;<br/>      &lt;Route<br/>        exact<br/>        path="/"<br/>        render={() =&gt; (<br/>          &lt;Typography component="div" className={classes.tabContent}&gt;<br/>            Item One<br/>          &lt;/Typography&gt;<br/>        )}<br/>      /&gt;<br/>      &lt;Route<br/>        exact<br/>        path="/page2"<br/>        render={() =&gt; (<br/>          &lt;Typography component="div" className={classes.tabContent}&gt;<br/>            Item Two<br/>          &lt;/Typography&gt;<br/>        )}<br/>      /&gt;<br/>      &lt;Route<br/>        exact<br/>        path="/page3"<br/>        render={() =&gt; (<br/>          &lt;Typography component="div" className={classes.tabContent}&gt;<br/>            Item Three<br/>          &lt;/Typography&gt;<br/>        )}<br/>      /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>export default withStyles(styles)(TabNavigationWithRoutes);</pre>
<p>When you load the screen, the first tab should be selected and the first tab content should be rendered:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fdbe0165-c323-49ce-88ad-4aa37321aee5.png" style="width:29.17em;height:5.17em;"/></p>
<p>If you click on the <span class="packt_screen">ITEM TWO</span> tab, you'll be taken to the <kbd>/page2</kbd> URL. This results in the active <kbd>Route</kbd> component changing the tab content, and the changed tab state changes the selected tab:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f376d9f6-76c1-42d7-9caf-2adc0dd7315c.png" style="width:32.83em;height:5.58em;"/></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The state portion of your component remains the same as any other component that uses the <kbd>Tabs</kbd> component. The <kbd>onChange</kbd> event changes the <kbd>value</kbd> state, which is passed to <kbd>Tabs</kbd> as a property to mark the selected tab.</p>
<p>Let's take a closer look at the <kbd>Tab</kbd> components:</p>
<pre>&lt;Tabs value={value} onChange={onChange}&gt;<br/>  &lt;Tab label="Item One" component={Link} to="/" /&gt;<br/>  &lt;Tab label="Item Two" component={Link} to="/page2" /&gt;<br/>  &lt;Tab label="Item Three" component={Link} to="/page3" /&gt;<br/>&lt;/Tabs&gt;</pre>
<p>A major difference with this implementation compared to something more standard is that you're using <kbd>Link</kbd> as the component property value. The <kbd>Link</kbd> component, from <kbd>react-router-dom</kbd>, is used to make the tab button into a link that the router will process. The <kbd>to</kbd> property is actually passed to <kbd>Link</kbd>, which is how it knows where the link should take the user.</p>
<p>Below the <kbd>Tabs</kbd> component are the routes that render the tab content, based on the tab that the user has clicked on. Let's take a look at one of these Routes:</p>
<pre>&lt;Route<br/>  exact<br/>  path="/"<br/>  render={() =&gt; (<br/>    &lt;Typography<br/>      component="div"<br/>      className={classes.tabContent}<br/>    &gt;<br/>      Item One<br/>    &lt;/Typography&gt;<br/>  )}<br/>/&gt;</pre>
<p>The content that is rendered below the tab is based on the current URL, not the <kbd>value</kbd> state of your component. The <kbd>value</kbd> state is only used to control the state of the selected tab.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Given that the active tab depends on the active route, you could completely remove any tab-related state. First, you create a <kbd>TabContainer</kbd> component to render the <kbd>Tabs</kbd> component:</p>
<pre>const TabContainer = ({ value }) =&gt; (<br/>  &lt;AppBar position="static"&gt;<br/>    &lt;Tabs value={value}&gt;<br/>      &lt;Tab label="Item One" component={Link} to="/" /&gt;<br/>      &lt;Tab label="Item Two" component={Link} to="/page2" /&gt;<br/>      &lt;Tab label="Item Three" component={Link} to="/page3" /&gt;<br/>    &lt;/Tabs&gt;<br/>  &lt;/AppBar&gt;<br/>);</pre>
<p>Instead of supplying an <kbd>onChange()</kbd> handler to the <kbd>Tabs</kbd> component, the <kbd>value</kbd> property is passed from <kbd>TabContainer</kbd>. Now, you can <kbd>render</kbd> this component in each <kbd>Route</kbd> component, passing the appropriate <kbd>value</kbd> property:</p>
<pre>const TabNavigationWithRoutes = withStyles(styles)(({ classes }) =&gt; (<br/>  &lt;div className={classes.root}&gt;<br/>    &lt;Route<br/>      exact<br/>      path="/"<br/>      render={() =&gt; (<br/>        &lt;Fragment&gt;<br/>          &lt;TabContainer value={0} /&gt;<br/>          &lt;Typography component="div" className={classes.tabContent}&gt;<br/>            Item One<br/>          &lt;/Typography&gt;<br/>        &lt;/Fragment&gt;<br/>      )}<br/>    /&gt;<br/>    &lt;Route<br/>      exact<br/>      path="/page2"<br/>      render={() =&gt; (<br/>        &lt;Fragment&gt;<br/>          &lt;TabContainer value={1} /&gt;<br/>          &lt;Typography component="div" className={classes.tabContent}&gt;<br/>            Item Two<br/>          &lt;/Typography&gt;<br/>        &lt;/Fragment&gt;<br/>      )}<br/>    /&gt;<br/>    &lt;Route<br/>      exact<br/>      path="/page3"<br/>      render={() =&gt; (<br/>        &lt;Fragment&gt;<br/>          &lt;TabContainer value={2} /&gt;<br/>          &lt;Typography component="div" className={classes.tabContent}&gt;<br/>            Item Three<br/>          &lt;/Typography&gt;<br/>        &lt;/Fragment&gt;<br/>      )}<br/>    /&gt;<br/>  &lt;/div&gt;<br/>));<br/><br/>export default TabNavigationWithRoutes;</pre>
<p>There's no more confusing the component state with the current <kbd>Route</kbd> and how the two interact. Everything is handled by the route.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>Tabs</kbd> API documentation: <a href="https://material-ui.com/api/tabs/">https://material-ui.com/api/tabs/</a></li>
<li><kbd>Tabs</kbd> demos: <a href="https://material-ui.com/demos/tabs/">https://material-ui.com/demos/tabs/</a></li>
<li>React Router documentation: <a href="https://reacttraining.com/react-router/">https://reacttraining.com/react-router/</a></li>
</ul>


            </article>

            
        </section>
    </body></html>