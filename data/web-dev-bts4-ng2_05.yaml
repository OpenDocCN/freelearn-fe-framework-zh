- en: Chapter 5. Routing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。路由
- en: Many web applications require more than one page or view, and Angular is well
    equipped to handle this with its router. The router uses JavaScript code and manages
    the navigation between views as users perform application tasks. In this chapter,
    we will take a look at how we can create static routes, as well as routes containing
    parameters, and how to configure them. We will also discover some of the pitfalls
    we might face. In this chapter, we will set up the top navigation with Angular.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Web应用程序需要多个页面或视图，Angular很好地配备了其路由器来处理这一点。路由器使用JavaScript代码并在用户执行应用程序任务时管理视图之间的导航。在本章中，我们将看看如何创建静态路由，以及包含参数的路由，以及如何配置它们。我们还将发现一些可能会遇到的问题。在本章中，我们将使用Angular设置顶部导航。
- en: 'At the end of the chapter, you will have a solid understanding of the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将对以下内容有扎实的理解：
- en: Component router
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件路由器
- en: Router configuration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器配置
- en: Router link and router outlet
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器链接和路由器出口
- en: Creating components and navigation for our application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的应用程序创建组件和导航
- en: Modern web applications
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代Web应用程序
- en: You've heard about **Single-Page Applications** ( **SPA** ) many times, but
    why develop web applications like that? What are the benefits?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经多次听说过**单页应用程序**（**SPA**），但为什么要开发这样的Web应用程序？有什么好处吗？
- en: The main idea for using SPAs is quite simple—users would like to use web applications
    which look like and behave like native applications. An SPA is a web application
    that loads a single HTML page and dynamically updates it as the user interacts
    with multiple components on it. Some of the components support many states, such
    as open, collapsed, and so on. Implementing all of these features with server-side
    rendering is hard to do, therefore much of the work happens on the client side,
    in JavaScript. This is achieved by separating data from the presentation of data
    by having a model layer that handles data and a view layer that reads from the
    models.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SPAs的主要想法非常简单-用户希望使用看起来和行为像本机应用程序的Web应用程序。 SPA是一个Web应用程序，它加载单个HTML页面，并在用户与其上的多个组件交互时动态更新它。一些组件支持许多状态，例如打开，折叠等。使用服务器端渲染实现所有这些功能很难做到，因此大部分工作发生在客户端，即JavaScript中。这是通过通过具有处理数据的模型层和从模型读取的视图层来将数据与数据的呈现分离来实现的。
- en: This idea brings some level of complexity to the code and often results in changing
    people's minds about the development process. Now we start thinking about the
    conceptual parts of the application, file and module structures, performance issues
    over bootstrapping, and so on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法给代码带来了一定程度的复杂性，并经常导致改变人们对开发过程的看法。现在我们开始考虑应用程序的概念部分，文件和模块结构，引导性能问题等。
- en: Routing
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: Since we are making an SPA and we don't want any page refreshes, we'll use the
    routing capabilities of Angular. The routing module is a crucial part of Angular.
    From one side it helps to update the URL of the browser as the user navigates
    through the application. From another side, it allows changes to the URL of the
    browser to drive navigation through the web application, thus allowing the user
    to create bookmarks to locations deep within the SPA. As a bonus, we can split
    the application into multiple bundles and load them on demand.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在制作SPA，并且不希望有任何页面刷新，因此我们将使用Angular的路由功能。路由模块是Angular的重要部分。一方面，它有助于在用户浏览应用程序时更新浏览器的URL。另一方面，它允许更改浏览器的URL以通过Web应用程序进行导航，从而允许用户创建书签以深入SPA中的位置。作为奖励，我们可以将应用程序拆分为多个包并按需加载它们。
- en: With the introduction of HTML 5, browsers acquired the ability to create programmatically
    new browser history entries that change the displayed URL without the need for
    a new request. This is achieved using the `pushState` method of history that exposes
    the browser's navigational history to JavaScript. So now, instead of relying on
    the anchor hack to navigate routes, modern frameworks can count on `pushState`
    to perform history manipulation without reloads.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 随着HTML 5的引入，浏览器获得了通过编程方式创建新的浏览器历史记录条目的能力，而不需要新的请求来改变显示的URL。这是通过使用历史记录的`pushState`方法来实现的，它将浏览器的导航历史记录暴露给JavaScript。因此，现代框架不再依赖锚点技巧来导航路由，而是可以依靠`pushState`来执行历史记录操作而无需重新加载。
- en: The Angular router uses this model to interpret a browser URL as an instruction
    to navigate to a client-generated view. We can pass optional parameters along
    to the view component to help it decide what specific content to present.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Angular路由器使用这个模型来将浏览器URL解释为导航到客户端生成的视图的指令。我们可以传递可选参数给视图组件，以帮助它决定呈现什么具体内容。
- en: 'Let''s start with the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下开始：
- en: Open Terminal, create the folder `ecommerce` and move in.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，创建文件夹`ecommerce`并进入。
- en: Copy the content of the project from the folder `chapter_5/1.ecommerce-seed`
    into the new project.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目文件夹`chapter_5/1.ecommerce-seed`中的内容复制到新项目中。
- en: 'Run the following script to install NPM modules:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下脚本安装NPM模块：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Start the TypeScript watcher and lite server with following command:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启动TypeScript监视器和轻量级服务器：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This script opens the web browser and navigates to the welcome page of the project.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本打开了网页浏览器并导航到项目的欢迎页面。
- en: Routing path
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由路径
- en: 'Before we begin, let''s plan out exactly what routes we''re going to need for
    the Dream Bean grocery store website:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们确切地规划一下梦幻豆杂货店网站所需的路由：
- en: The welcome view uses the `/#/welcome` path. It is going to be our entry point
    for the application, which will list all categories in a grid and slideshow.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欢迎视图使用`/#/welcome`路径。这将是我们应用程序的入口点，它将以网格和幻灯片放映方式列出所有类别。
- en: The products view utilizes the `/#/products` path. We'll be able to see the
    goodies within the chosen category there.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品视图利用`/#/products`路径。我们将能够在选择的类别中看到商品。
- en: We show the products view on `/#/product/:id` . Here, we will display information
    about the product. The `:id` here and in the next example is a token for a route
    parameter. We will talk about it later in this chapter.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`/#/product/:id`上显示产品视图。在这里，我们将显示关于产品的信息。这里和下一个示例中的`:id`是路由参数的标记。我们将在本章后面讨论它。
- en: The `/#/cart` path is where we will see the cart view list all items in the
    user's shopping cart.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/#/cart`路径是我们将在其中看到购物车视图列出用户购物车中的所有商品的地方。'
- en: In the checkout view with the `/#/checkout/:id` path, we will include a form
    that will allow a user to add contact information; it also provides the order
    information and purchase conditions.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`/#/checkout/:id`路径的结账视图中，我们将包括一个表单，允许用户添加联系信息；它还提供订单信息和购买条件。
- en: These are all of our essential routes; now let's take a look at how we can create
    them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们所有必要的路由；现在让我们看看如何创建它们。
- en: Installing the router
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装路由器
- en: 'The router is packaged as a module inside Angular, but it is not a part of
    the Angular core, so we need to manually include it inside the bootstrapping configuration
    in the `systemjs.config.js` file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器被打包为Angular内的一个模块，但它不是Angular核心的一部分，所以我们需要在`systemjs.config.js`文件的引导配置中手动包含它：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The base URL
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本URL
- en: 'If we have decided to use routing, then we should add the `base` element as
    the first child in the `head` tag. The reference in this tag resolves relative
    URLs and hyperlinks, and tells the router how to compose navigation URLs. For
    our project, I assigned the `"/"` to the `href` of the `base` element, because
    the `app` folder is the application root:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定使用路由，则应将“base”元素作为“head”标记中的第一个子元素添加。此标记中的引用解析相对URL和超链接，并告诉路由器如何组成导航URL。对于我们的项目，我将“/”分配给“base”元素的“href”，因为“app”文件夹是应用程序根目录：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we deploy the application to the server within a particular context, such
    as `portal` , then we must change this value accordingly:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将应用程序部署到特定上下文的服务器上，例如“portal”，那么我们必须相应地更改这个值：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The Angular router
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular路由器
- en: 'The actual routing from one view to another happens with the help of the **Angular
    router** . It is an optional service, and represents the component view for a
    specific URL. It has its own library package, and we must import from it before
    use:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个视图实际路由到另一个视图是通过**Angular路由器**完成的。这是一个可选的服务，并表示特定URL的组件视图。它有自己的库包，我们必须在使用之前从中导入：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The router configuration
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由器配置
- en: The application must have only one router. We should configure it so that it
    knows how to map the browser's URL to the corresponding `Route` and determine
    the component to display. The primary way to do that uses the `RouterModule.forRoot`
    function with an array of routes which bootstraps the application with it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序只能有一个路由器。我们应该配置它，以便它知道如何将浏览器的URL映射到相应的“Route”并确定要显示的组件。这样做的主要方法是使用带有路由数组的“RouterModule.forRoot”函数，它用它引导应用程序。
- en: Creating basic routes
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基本路由
- en: 'Create the file `app.routes.ts` and import necessary elements from the router
    package:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 创建文件“app.routes.ts”并从路由器包中导入必要的元素：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now create the constants to keep the application routes:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建常量以保持应用程序路由：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We define the array of route objects that describe how to navigate. Each route
    maps a URL `path` to a `component` to display. The router parses and constructs
    the URL, helping us to use the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了描述导航方式的路由对象数组。每个路由将一个URL“路径”映射到要显示的“组件”。路由器解析和构造URL，帮助我们使用以下内容：
- en: Path references to the base element, eliminating the necessity of using leading
    splashes
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对基本元素的路径引用，消除了使用前导斜杠的必要性
- en: Absolute path
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绝对路径
- en: Query parameters
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询参数
- en: 'The second item in the router configuration points only to `products` , but
    as I mentioned earlier, we''ll be able to see the goodies within the chosen category
    there. It sounds like the information we would like to include in our URL is optional:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器配置中的第二项只指向“products”，但正如我之前提到的，我们将能够在选择的类别中看到商品。听起来我们想要在我们的URL中包含的信息是可选的：
- en: We can leave the request without extra information to get all the products
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在不带额外信息的情况下离开请求以获取所有产品
- en: We can use the particular category to fetch the products belonging to it
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用特定类别来获取属于该类别的产品
- en: These kinds of parameters do not fit easily into a URL path, so, usually, it
    is complicated or impossible to create the pattern matching required to translate
    an incoming URL to a named route. Fortunately, the Angular router supports the
    **URL** **query string** for conveying any arbitrary information during navigation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的参数不容易适应URL路径，因此通常很难或不可能创建所需的模式匹配，以将传入的URL转换为命名路由。幸运的是，Angular路由器支持**URL**
    **查询字符串**，用于在导航期间传递任意信息。
- en: Router parameters
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由器参数
- en: The third element in the `routes` array has an `id` in its path. It is a token
    for a **route** **parameter** ; the value corresponding with the view component
    will use it to find and present the product information. In our example, the URL
    `'product/20'` keeps the value `20` of the `id` parameter. The `ProductComponent`
    can use this value to find and display the product with an ID equaling `20` .
    This route is commented out because we don't have the `ProductComponent` implemented
    yet.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes`数组中的第三个元素在其路径中有一个`id`。这是一个**路由参数**的标记；与视图组件对应的值将使用它来查找和呈现产品信息。在我们的示例中，URL
    `''product/20''`保留了`id`参数的值`20`。`ProductComponent`可以使用这个值来查找并显示ID等于`20`的产品。这个路由被注释掉，因为我们还没有实现`ProductComponent`。'
- en: Route versus query parameters
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由参数与查询参数
- en: 'Here are the general rules to help you choose what parameters to use. Use the
    route parameters when the following conditions are met:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一般规则，帮助您选择要使用的参数。当满足以下条件时，请使用路由参数：
- en: The value is required
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该值是必需的
- en: The value is necessary for navigation to another route
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该值对于导航到另一个路由是必要的
- en: 'Use the query parameters when the following conditions are met:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当满足以下条件时，请使用查询参数：
- en: The value is optional
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该值是可选的
- en: The value is complex or contains multivariance
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该值是复杂的或包含多变量。
- en: Register routing in bootstrap
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在引导中注册路由
- en: 'In the end, we should use the `RouterModule.forRoot` method to return a new
    instance of `RouterModule` containing the configured and ready-to-use router service
    provider and required routing libraries:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该使用`RouterModule.forRoot`方法返回一个包含配置和准备就绪的路由服务提供程序和所需路由库的新`RouterModule`实例：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After that, we need to register the returned module in `AppModule` :'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要在`AppModule`中注册返回的模块：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Redirecting routes
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重定向路由
- en: 'Usually, when a user types the address of the Dream Bean website, he/she provides
    the website domain name: [http://www.dreambean.com](http://www.dreambean.com)
    .'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当用户输入Dream Bean网站的地址时，他/她提供网站域名：[http://www.dreambean.com](http://www.dreambean.com)。
- en: 'This URL does not match any configured routes, and Angular cannot show any
    component at that moment. The user must click on some link to navigate to the
    view, or we can teach the configuration to display the particular route with the
    help of the `redirectTo` property:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此URL不匹配任何配置的路由，并且Angular此刻无法显示任何组件。用户必须点击某个链接以导航到视图，或者我们可以教会配置使用`redirectTo`属性显示特定路由：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After those changes, if the user navigates to the original URL, the router translates
    from the initial URL (`''` ) to the default URL (`'welcome'` ) and displays the
    Welcome View.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这些更改之后，如果用户导航到原始URL，路由器将从初始URL（`''`）转换为默认URL（`'welcome'`）并显示欢迎视图。
- en: 'The redirected route has a required property, `pathMatch` , to tell the router
    how to match the URL to the path. We have two options for this value:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向的路由具有一个必需属性`pathMatch`，告诉路由器如何将URL与路径匹配。对于这个值，我们有两个选项：
- en: The `full` shows that the selected route must match the entire URL
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`full`表示所选路由必须与整个URL匹配'
- en: The `prefix` dictates to the router to match the redirect route to any URL that
    begins with the prefixed value in the `path` .
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prefix`指示路由器将重定向路由与以`path`中的前缀值开头的任何URL匹配。'
- en: Router outlet
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由出口
- en: Now, once we have settled the router configuration, it's time to present some
    components on the screen. But wait—we need a place for them, and this is why the
    router outlet is coming to the stage.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦我们解决了路由器配置，就该在屏幕上展示一些组件了。但等等——我们需要一个地方放它们，这就是为什么路由出口要登场了。
- en: 'The `RouterOutlet` is a placeholder that Angular dynamically fills based on
    the application''s route. The `RouterOutlet` is the part of the `RouterModule`
    imported before, so we don''t need to import it elsewhere. Here is a wireframe
    that splits the SPA into three rows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouterOutlet`是Angular动态填充的占位符，根据应用的路由。`RouterOutlet`是之前导入的`RouterModule`的一部分，所以我们不需要在其他地方导入它。这是一个将SPA分成三行的线框图：'
- en: '![Router outlet](Image00098.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![路由出口](Image00098.jpg)'
- en: The wireframe of the SPA
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: SPA的线框图
- en: In the first row, we keep the `NavigationComponent` ; in the last row, the footer
    container. All space in between is the place where the `RouterOutlet` will display
    the corresponding view.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们保留`NavigationComponent`；在最后一行，是页脚容器。中间的所有空间是`RouterOutlet`将显示相应视图的地方。
- en: Welcome View
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 欢迎视图
- en: 'We configured the application routes and added them to the `AppModule` , so
    now we need to create the Welcome View because it is a crucial part of the routing.
    Create a `welcome` folder and two files inside `welcome.component.html` and `welcome.component.ts`
    . Now move the content of `app.component.html` between the `navbar` and the footer
    into `welcome.component.html` and replace it. Markup represents the `RouterOutlet`
    as a component:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置了应用程序路由并将它们添加到`AppModule`，所以现在我们需要创建欢迎视图，因为它是路由的重要部分。创建一个`welcome`文件夹，并在其中创建两个文件`welcome.component.html`和`welcome.component.ts`。现在将`app.component.html`的内容移动到`welcome.component.html`中，并替换它。标记将`RouterOutlet`表示为一个组件：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Copy and paste the following content into the `welcome.component.ts` :'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容复制粘贴到`welcome.component.ts`中：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'I moved almost all code from the `AppComponent` into `WelcomeComponent` , and
    it dramatically reduced its size:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我将几乎所有的代码从`AppComponent`中移动到`WelcomeComponent`中，并且它的大小大大减小了。
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: I used the link to navigate from Welcome View to the products view with a selected
    category instead of making a call to the `selectCategory` method, so I deleted
    the last one as well.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用链接从欢迎视图导航到带有选定类别的产品视图，而不是调用`selectCategory`方法，所以我也删除了最后一个。
- en: The footer component
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 页脚组件
- en: 'Now, when you have an idea how to create a component, you can do it yourself.
    Create the `footer` folder, `footer.component.ts` , and `footer.component.html`
    . Here, the source code of the `footer.component.ts` is the following :'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你知道如何创建一个组件时，你可以自己动手做。创建`footer`文件夹，`footer.component.ts`和`footer.component.html`。这里，`footer.component.ts`的源代码如下：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, it looks the same as other components that we created before.
    Move the content of the footer container from the `application.component.html`
    into the `footer.component.html` and replace it with the `FooterComponent` tag,
    so now the HTML of our application looks pretty neat:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它看起来和我们之前创建的其他组件一样。将`application.component.html`中的页脚容器的内容移动到`footer.component.html`中，并用`FooterComponent`标签替换它，现在我们应用的HTML看起来非常整洁：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The category data
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类别数据
- en: 'I kept the category data as part of the `AppComponent` because it was a quick
    and obvious way at the moment when we started development. Now, as application
    grows, it''s time to move all category data into the category file. Open the `category.ts`
    file and copy the following source code there:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我将类别数据保留为`AppComponent`的一部分，因为在我们开始开发时，这是一种快速明显的方式。现在，随着应用程序的增长，是时候将所有类别数据移动到类别文件中了。打开`category.ts`文件，将以下源代码复制到那里：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `getCategories` function returns the list of categories. The `getCategory`
    returns the category found by the ID or throws a `CategoryNotFoundException` .
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`getCategories`函数返回类别列表。`getCategory`返回根据ID找到的类别，或抛出`CategoryNotFoundException`。'
- en: Category card view
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分类卡视图
- en: 'Let''s open the `category-card.component.html` file and change the markup as
    follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`category-card.component.html`文件，并将标记更改如下：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When a user clicks on the **Browse** button, Angular calls the `filterProducts`
    method with a category specified as a parameter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**浏览**按钮时，Angular会调用带有指定类别参数的`filterProducts`方法。
- en: 'Open the `category-card.component.ts` file, import the `Router` from the library,
    and add the reference in the constructor of the component:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`category-card.component.ts`文件，从库中导入`Router`，并在组件的构造函数中添加引用：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Pay attention to the `filterProducts` method. We use a router configured in
    the bootstrapping of the application and available in this component. Because
    we decided to use query parameters, I invoked a navigation method and passed the
    same name as the second parameter object. We can convey any information and Angular
    will convert it into the query string of URL like so:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`filterProducts`方法。我们在应用程序的引导中使用了一个配置好的路由器，并且在这个组件中可用。因为我们决定使用查询参数，所以我调用了一个导航方法，并传递了相同的名称作为第二个参数对象。我们可以传递任何信息，Angular会将其转换为URL的查询字符串，就像这样：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We are done with the Welcome View and are now moving to the Products View.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了欢迎视图，现在转到产品视图。
- en: The product data
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产品数据
- en: 'We don''t use the back end server to return the products data yet, so let''s
    create the `product.ts` file with the following content:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有使用后端服务器返回产品数据，所以让我们创建`product.ts`文件，内容如下：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you look closely, you will find a similarity to the `category.ts` file. I'm
    just following the naming conventions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细看，你会发现与`category.ts`文件有相似之处。我只是遵循命名约定。
- en: Products View
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产品视图
- en: The Products View provides a listing of all goodies within the chosen category.
    From it, a customer can see all product information, and add any of the listed
    products to his or her shopping cart. A user can also navigate to any of the provided
    categories or use the **Quick Shop** feature to search products by name.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 产品视图提供了所选类别中所有商品的列表。从中，客户可以查看所有产品信息，并将列出的任何产品添加到他或她的购物车中。用户还可以导航到任何提供的类别，或使用**Quick
    Shop**功能按名称搜索产品。
- en: '![Products View](Image00099.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![产品视图](Image00099.jpg)'
- en: The wireframe of the products view
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 产品视图的线框图
- en: 'The layout of this component is a composition of two columns:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件的布局是由两列组成的：
- en: The first column contains the **Quick Shop** and list of **Categories**
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一列包含**Quick Shop**和**类别**列表
- en: The second column is a nested column combined into rows
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二列是一个嵌套的列，组合成行
- en: Quick shop component
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速购物组件
- en: This one is an `input-group` field for searching and using `Quick Shop` to see
    the products available in the grocery. We use the URL query string for conveying
    the search information as we did for the category because we don't know what the
    user will type into the search field. Create the `product` folder where we will
    add all components and services belonging to `product.`
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于搜索的`input-group`字段，并使用`Quick Shop`来查看杂货店中的产品。我们使用URL查询字符串来传递搜索信息，就像我们为类别所做的那样，因为我们不知道用户会在搜索字段中输入什么。创建`product`文件夹，我们将在其中添加所有属于`product`的组件和服务。
- en: 'Let''s create `product-search.component.html` in the `product` folder with
    the following markup:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`product`文件夹中创建`product-search.component.html`，内容如下：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'I use the Bootstrap 4 `input-groups` with a button inside the `Card` component.
    The template reference variable `search` grants us direct access to an input element
    so that we can use the text value in the `searchProduct` method when a user types
    the product name and clicks on the **Go!** button. Create the `product-search.component.ts`
    file and create the `ProductSearch` component similar to a `CategoryCard` one:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了Bootstrap 4的`input-groups`，里面有一个按钮在`Card`组件中。模板引用变量`search`使我们直接访问输入元素，这样当用户输入产品名称并点击**Go!**按钮时，我们可以在`searchProduct`方法中使用文本值。创建`product-search.component.ts`文件，并创建类似于`CategoryCard`的`ProductSearch`组件：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'I use the navigation method of `Router` to search for a product by name with
    the following URL:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`Router`的导航方法通过以下URL搜索产品名称：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![Quick shop component](Image00100.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![快速购物组件](Image00100.jpg)'
- en: Now, we are ready to create the `CategoryList` component so that the user can
    use it to select the category.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备创建`CategoryList`组件，以便用户可以使用它来选择类别。
- en: List of categories component
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类别列表组件
- en: 'In [Chapter 3](text00047.html#page "Chapter 5. Routing") , *Advanced Bootstrap
    Components and Customization* , we introduced the flexible Bootstrap 4 `list-group`
    component. `Categories` is a list of unordered items, so we can use this particular
    one to render categories quickly. I use the same mechanism to update the URL with
    the specific category that we used in `CategoryCard` component. Create `category-list.component.html`
    in the `category` folder with the following markup:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](text00047.html#page "第5章 路由")中，*高级Bootstrap组件和自定义*，我们介绍了灵活的Bootstrap
    4 `list-group`组件。`Categories`是一个无序项目列表，所以我们可以使用这个特定的列表来快速渲染类别。我使用相同的机制来更新URL，使用`CategoryCard`组件中使用的特定类别。在`category`文件夹中创建`category-list.component.html`，内容如下：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `Card` component wraps the `list-group` . The built-in `NgFor` directive
    helps to organize iteration through categories to display the items. Create the
    `category-list.component.ts` , and copy and paste the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Card`组件包装了`list-group`。内置的`NgFor`指令帮助组织对类别的迭代，以显示项目。创建`category-list.component.ts`，并复制并粘贴以下代码：'
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We use the `getCategories` function from the `category` file to assign all of
    them to the `categories` variable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`category`文件中的`getCategories`函数将它们全部分配给`categories`变量。
- en: Update the CategoryModule
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新CategoryModule
- en: 'You should update the `CategoryModule` with the new component as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该按照以下方式更新`CategoryModule`：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: I have exported the `CategoryListComponent` because we will use it in other
    modules.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我导出了`CategoryListComponent`，因为我们将在其他模块中使用它。
- en: Router links
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由链接
- en: Most of the time, the users navigate between views as a result of an action
    that they have performed on a link, such as a click happening on an anchor tag.
    We can bind the router to the links on a page, so that when the user clicks on
    the link, it will navigate to the appropriate application view.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，用户在页面之间导航是由于他们在链接上执行的操作，比如单击锚标签。我们可以将路由器绑定到页面上的链接，这样当用户单击链接时，它将导航到适当的应用程序视图。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The router logs activity in the history journal of the browser so that the back
    and forward buttons work as expected.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器在浏览器的历史日志中记录活动，以便返回和前进按钮按预期工作。
- en: The Angular team introduced a `RouterLink` directive to the anchor tag to bind
    it to the template expression containing the array of route link parameters. Let's
    create the `Product Card` component with the help of `RouterLink` .
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Angular团队引入了`RouterLink`指令到锚标签，将其绑定到包含路由链接参数数组的模板表达式。让我们借助`RouterLink`创建`Product
    Card`组件。
- en: Product card
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品卡
- en: 'I suppose it is a good idea to present the product as a card. I create the
    `product-card.component.html` in the `product` folder with the following markup:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为将产品呈现为卡片是一个好主意。我在`product`文件夹中创建了`product-card.component.html`，内容如下：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In our code, the `RouterLink` binds in the anchor tag. Pay attention to the
    template expression we bind to the `routerLink` . Obviously, it is an array, which
    means that we can add more than one item, and Angular will combine them to build
    the URL. We can specify all the pieces of the route exclusively, like `"product/1"`
    , but I intentionally leave them as separated items of an array as it''s easy
    to maintain. Let''s parse it:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，`RouterLink`绑定在锚标签中。注意我们绑定到`routerLink`的模板表达式。显然，它是一个数组，这意味着我们可以添加多个项目，Angular将它们组合起来构建URL。我们可以单独指定路由的所有部分，比如`"product/1"`，但我故意将它们留作数组的分离项目，因为这样更容易维护。让我们解析一下：
- en: The first item identifies the parent root `"/product"` path
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一项标识父根`"/product"`路径
- en: There are no parameters for this parent element, such as `"product/groups/1"`
    , so we are done with it
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于这个父元素没有参数，比如`"product/groups/1"`，所以我们完成了
- en: The second item identifies the child route for the product and requires the
    ID
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二项标识产品的子路由，并需要ID
- en: The navigation with `RouterLink` is very flexible, so we can write an application
    with multiple levels of routing with a link parameters array.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouterLink`的导航非常灵活，因此我们可以使用链接参数数组编写具有多级路由的应用程序。'
- en: 'Create a `product-card.component.ts` in the `product` folder. The `RouterLink`
    belongs to `RouterModule` , so it''s available on markup now. Copy and paste the
    following code into the `product-card.component.ts` :'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在`product`文件夹中创建一个`product-card.component.ts`。`RouterLink`属于`RouterModule`，所以现在可以在标记上使用它。复制并粘贴以下代码到`product-card.component.ts`中：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We will bind the data from `ProductGreedComponent` into the instance of `ProductCardComponent`
    via the `product` property.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`ProductGreedComponent`绑定数据到`ProductCardComponent`的实例中，通过`product`属性。
- en: Products grid component
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品网格组件
- en: 'We need to show the products as a grid with three columns and multiple rows.
    The card component is the most suitable one to display the product information
    and navigate to the product view. All of the cards in the row must have the same
    width and height. How can we display them in a particular place inside the parent
    grid layout? Let''s create `product-grid.component.html` and `product-grid.component.ts`
    files in the `product` folder. Copy and paste the following code into the `product-grid.component.ts`
    file:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以三列和多行的网格形式显示产品。卡片组件是显示产品信息并导航到产品视图的最合适的组件。行中的所有卡片必须具有相同的宽度和高度。我们如何在父网格布局的特定位置显示它们？让我们在`product`文件夹中创建`product-grid.component.html`和`product-grid.component.ts`文件。复制并粘贴以下代码到`product-grid.component.ts`文件中：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Card groups
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卡片组
- en: 'We can use the **Bootstrap 4 Card** groups to present multiple cards as a single
    attached element with equal width and height. We need only include all cards within
    a parent element marked with the `card-group` class. Copy and paste the following
    code into the `product-grid.component.html` file:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**Bootstrap 4 Card**组来呈现多个卡片作为单个附加元素，具有相等的宽度和高度。我们只需要将所有卡片放在带有`card-group`类的父元素中。复制并粘贴以下代码到`product-grid.component.html`文件中：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The result is not what I want because some cards are attached to each other:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 结果不是我想要的，因为一些卡片彼此附着：
- en: '![Card groups](Image00101.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: ！[卡片组](Image00101.jpg)
- en: Card columns
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卡片列
- en: 'Another layout is `card-columns` from Bootstrap 4\. It allows you to display
    multiple cards in each column. Each card inside a column is stacked on top of
    another. Include all cards within a `card-columns` class. Copy and paste the following
    code into the `product-grid.component.html` file:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个布局是来自Bootstrap 4的`card-columns`。它允许您在每列中显示多个卡片。每列中的每张卡片都堆叠在另一张卡片上。在`card-columns`类中包含所有卡片。复制并粘贴以下代码到`product-grid.component.html`文件中：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The result looks quite funny:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来很有趣：
- en: '![Card columns](Image00102.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: ！[卡片列](Image00102.jpg)
- en: Card desks
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卡片桌
- en: 'The last layout is a card desk from Bootstrap 4\. It is similar to the Card
    group, except the cards aren''t attached to each other. This one requires two
    wrapping elements: `card-deck-wrapper` and a `card-deck` . It uses table styles
    for the sizing and the gutters on `card-deck` . The `card-deck-wrapper` is used
    to negative margin out the border-spacing on the `card-deck` .'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的布局是来自Bootstrap 4的卡片桌。它类似于卡片组，只是卡片之间没有连接。这需要两个包装元素：`card-deck-wrapper`和`card-deck`。它使用表格样式来设置`card-deck`的大小和间距。`card-deck-wrapper`用于在`card-deck`上消除边框间距。
- en: 'Let''s move back to the `product-card.component.html` file and update it with
    the following content:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`product-card.component.html`文件，并使用以下内容进行更新：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The Card Desk works perfectly enough with one row, so we expose the `products`
    input in `ProductCardComponent` :'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 卡片桌足够完美地使用一行，所以我们在`ProductCardComponent`中公开`products`输入：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `setClasses` method helps change the card's background if the product has
    a `special` price. We call the `buy` method when the user clicks on the **Buy
    Now** button.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`setClasses`方法帮助更改卡片的背景，如果产品有`special`价格。当用户点击**立即购买**按钮时，我们调用`buy`方法。'
- en: 'With all of that in place, we can update the markup of the `ProductGridComponent`
    :'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一切，我们可以更新`ProductGridComponent`的标记：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Quite neat, isn't it?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 相当整洁，不是吗？
- en: 'But before we use our pretty component, we need to transform an array of products
    into an array of rows with three products per line. Please pay attention to the
    code in the constructor of the `ProductGridComponent` :'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 但在使用我们漂亮的组件之前，我们需要将产品数组转换为每行三个产品的数组。请注意`ProductGridComponent`构造函数中的代码：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We split the products into multiple rows containing a maximum of three columns.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将产品分成多行，每行最多包含三列。
- en: Combine them all together
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将它们全部组合在一起
- en: Now we create the component that will combine all of  our other product components
    to display them in a place provided by the router outlet tag. Will you please
    welcome the `ProductListComponent` !
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建一个组件，将所有其他产品组件组合起来，以便在路由器出口标记提供的位置显示它们。请欢迎`ProductListComponent`！
- en: 'Create a `product-list.component.ts` file with the following content:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`product-list.component.ts`文件，内容如下：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, create the `product-list.component.html` , and copy and paste the next
    markup:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建`product-list.component.html`，并复制并粘贴下一个标记：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, it draws the `ProductSearchComponent` and `CategoryListComponent`
    in the first column and the `ProductGridComponent` in the second one, which corresponds
    to our wireframe.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它在第一列中绘制了`ProductSearchComponent`和`CategoryListComponent`，在第二列中绘制了`ProductGridComponent`，这与我们的线框相对应。
- en: The product module
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产品模块
- en: 'The last two cents in the `product` folder are the `ProductModule` . Create
    the `product.module.ts` file as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在`product`文件夹中的最后两个角色是`ProductModule`。创建`product.module.ts`文件如下：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It imports the `CategoryModule` as well as system modules. We declare and export
    all of the four components that we created before.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 它导入了`CategoryModule`以及系统模块。我们声明并导出了之前创建的所有四个组件。
- en: Update the AllModule
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新AllModule
- en: 'Now, with `CategoryModule` and `ProductModule` in place, we need make all of
    their components available to the application so that we can import them into
    the `AppModule` :'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了`CategoryModule`和`ProductModule`，我们需要使它们所有的组件都可用于应用程序，以便我们可以将它们导入到`AppModule`中：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `NavbarComponent` , `FooterComponent` , and `WelcomeComponent` belong to
    the `AppModule` directly.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavbarComponent`，`FooterComponent`和`WelcomeComponent`直接属于`AppModule`。'
- en: Tip
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can find the source code at `chapter_5/2.ecommerce-router` .
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`chapter_5/2.ecommerce-router`找到源代码。
- en: 读累了记得休息一会哦~
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
- en: Router change events
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由更改事件
- en: 'As we mentioned when looking at router configuration, the `ProductListComponent`
    can represent the Product View when a user navigates to the URL like the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在查看路由器配置时提到的，当用户导航到以下URL时，`ProductListComponent`可以表示产品视图：
- en: '[PRE40]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Or
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE41]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `ActivatedRouter` class contains the information about a route associated
    with a component loaded in an outlet. We can subscribe to route change events
    to inform the `ProductGridComponent` about the changes happening in the query
    parameters of the URL. Open the `product-grid.component.ts` file, import `ActivatedRouter`
    from the library, and inject it into the `router` property of the constructor.
    Now we can subscribe to the route changes:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActivatedRouter`类包含与加载在出口中的组件相关联的路由信息。我们可以订阅路由更改事件，以通知`ProductGridComponent`有关URL查询参数发生的变化。打开`product-grid.component.ts`文件，从库中导入`ActivatedRouter`，并将其注入到构造函数的`router`属性中。现在我们可以订阅路由更改：'
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code, we are listening to the changes that happen only in `queryParams`
    and using them to filter data in the  `getProducts` function. Later, with the
    help of the `transform` method, we will translate the filtered products in the
    data appropriate to the display.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们正在监听只在`queryParams`中发生的更改，并使用它们来过滤`getProducts`函数中的数据。稍后，借助`transform`方法，我们将把过滤后的产品转换成适合显示的数据。
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Lastly, we must change the signature of the `getProducts` function because
    now we may pass two parameters:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须改变`getProducts`函数的签名，因为现在我们可以传递两个参数：
- en: '[PRE44]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This function filters data by category, searches text, or leaves it as is,
    depending on the parameters that we send to the function. Save the code, and try
    to play with the filtered data:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数根据我们发送给函数的参数，可以按类别过滤数据，搜索文本，或保持原样。保存代码，尝试使用过滤后的数据进行操作：
- en: '![Router change events](Image00103.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![路由器更改事件](Image00103.jpg)'
- en: Routing strategies
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由策略
- en: 'All of our essential routes have been configured, and we now have access to
    a separate view for all of them. That''s great, but maybe you are not happy with
    the path following the `#` symbol in the URL. As I mentioned, modern web browsers
    support the `pushState` technique to help change a location and history in the
    browser without a request to the server. The `Router` uses this method to build
    the URL. The Angular router uses a different `LocationStrategy` to provide support
    for both old and new ways:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经配置了所有必要的路由，并且现在可以访问它们的单独视图。这很棒，但也许你不喜欢URL中跟随`#`符号的路径。正如我提到的，现代web浏览器支持`pushState`技术，可以在不向服务器发送请求的情况下改变浏览器的位置和历史记录。`Router`使用这种方法来构建URL。Angular路由器使用不同的`LocationStrategy`来支持新旧两种方式：
- en: The `PathLocationStrategy` provides the default, HTML 5 style based on `pushState`
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PathLocationStrategy`提供了默认的基于`pushState`的HTML 5样式'
- en: The `HashLocationStrategy` utilizes the hash in the URL style
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HashLocationStrategy`利用URL样式中的哈希符号。'
- en: Choosing the strategy is crucial for future development because it won't be
    easy to change it later, so it is better do it at the right time. You can use
    the `HashLocationStrategy` if your server doesn't support the ability to redirect
    to a fallback page when a route is not found. Likely, the `lite-server` we use
    in our development supports this feature.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 选择策略对于未来的开发至关重要，因为以后更改它不会很容易，所以最好在合适的时候做。如果您的服务器不支持在找不到路由时重定向到备用页面的能力，您可以使用`HashLocationStrategy`。我们在开发中使用的`lite-server`可能支持这个功能。
- en: 'Open the `app.module.ts` file and import the strategy from the common module:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`app.module.ts`文件，从common模块导入策略：
- en: '[PRE45]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We are registering the `PathLocationStrategy` or `HashLocationStrategy` as
    a provider to the `LocationStrategy` :'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`PathLocationStrategy`或`HashLocationStrategy`注册为`LocationStrategy`的提供者：
- en: '[PRE46]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Save it and check how the application works within and without hash in the browser's
    URL.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并检查应用程序在浏览器URL中是否有或没有哈希的工作方式。
- en: '![Routing strategies](Image00104.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![路由策略](Image00104.jpg)'
- en: Tip
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can find the source code at `chapter_5/3.ecommerce-router-search` .
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`chapter_5/3.ecommerce-router-search`找到源代码。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we transformed our application from a single page into a multipage
    view and multiroute app that we can build on the Dream Bean grocery store. We
    started by planning out the essential routes in our application before writing
    any lines of code.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将我们的应用程序从单页面转变为多页面视图和多路由应用程序，我们可以在 Dream Bean 杂货店上构建。在编写任何代码之前，我们首先规划了应用程序中的基本路由。
- en: We then built static and dynamic routes containing parameters.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们构建了包含参数的静态和动态路由。
- en: Finally, we looked at how we can remove the `#` symbol from the URL using HTML
    5's `pushState` and how we can link both types of routes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看了如何使用HTML 5的`pushState`来删除URL中的`#`符号，以及如何链接两种类型的路由。
- en: In [Chapter 6](text00058.html#page "Chapter 6. Dependency Injection") , *Dependency
    Injection* , we will talk about dependency injection, which teaches the readers
    how to decouple the requirements of an application and how to create a consistent
    source of data as a service. Plus, we will continue to build the project we started
    to develop in previous chapters.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](text00058.html#page "第6章. 依赖注入")中，*依赖注入*，我们将讨论依赖注入，教读者如何解耦应用程序的需求，以及如何创建一个一致的数据源作为服务。此外，我们将继续构建我们在前几章中开始开发的项目。
