<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Writing Modules, Directives, and Pipes with TypeScript</h1>
                </header>
            
            <article>
                
<p class="mce-root">Modularity is essential for building large software systems, and Angular projects are not an exception to this. When our app starts growing, managing its different members in one entry module starts becoming really difficult and confusing. It becomes more challenging when you have a lot of services, directives, and pipes. Speaking of directives and pipes, we will take some time to discuss their use cases and examples in this chapter, while taking a journey in managing our application better with modules.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Directives</h1>
                </header>
            
            <article>
                
<p>DOM manipulation is not always best handled in components. Components should be as lean as possible; this way, things are kept simple and your code can easily be moved around and reused. So, where should we handle DOM manipulation then? The answer is directives. Just like you should take data manipulation tasks to services, best practices suggest you take heavy DOM manipulations to directives.</p>
<p>There are three types of directives in Angular:</p>
<ul>
<li>Components</li>
<li>Attribute directives</li>
<li>Structural directives</li>
</ul>
<p>Yes, components! Components are qualified directives. They are directives with a direct access to the template being manipulated. We have already seen components enough in this book; let's focus on the attribute and structural directives.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Attribute directives</h1>
                </header>
            
            <article>
                
<p>This category of directives is known for adding behavioral features to the DOM but not removing or adding any DOM content. Things such as changing appearance, showing or hiding elements, manipulating elements' attributes, and so on.</p>
<p>To better understand attribute directives, let's build some UI directives that are applied to component templates. These directives will change the behavior of the DOM when they are applied.</p>
<p>Create a new directive in a fresh project with the following command:</p>
<pre><strong>ng generate directive ui-button</strong></pre>
<p>This will create an empty directive in the app folder with the following content:</p>
<pre>import { Directive } from '@angular/core';<br/><br/>@Directive({<br/>  selector: '[appUiButton]'<br/>})<br/>export class UiButtonDirective {<br/>  constructor() {}<br/>}</pre>
<p>The <kbd>Directive</kbd> decorator is first imported from the <kbd>@angular/core</kbd> module. The decorator is used on any class that is expected to act as a directive. Just like decorators on components, the directive decorator takes an object with a selector property. When this selector is applied to the DOM, the behavior of the directive is exhibited.</p>
<p>The behavior we are trying to achieve in this example entails styling a completely unstyled button with just a single attribute. Let's assume that we have the following button in our app component:</p>
<pre>&lt;div class="container"&gt;<br/>  &lt;button&gt;Click!!&lt;/button&gt;<br/>&lt;/div&gt;</pre>
<p>This is just a simple boring button on the screen:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-337 image-border" height="792" src="assets/4c27b9ac-8bbe-47d1-8d4c-fc4668eefec0.png" width="1363"/></div>
<p>To use the attribute directive we just created, add it as a <em>value-less</em> attribute to the button:</p>
<pre>&lt;button appUiButton&gt;Click!!&lt;/button&gt;</pre>
<p>Next, find a way to access the button element from the <kbd>directive</kbd> class. We need this access to be able to apply styles to the button, right from the class. Thanks to the <kbd>ElementRef</kbd> class, which, when injected to the directive via the constructor, gives us access to the native element, which is where the button element can be accessed:</p>
<pre>import { Directive, ElementRef } from '@angular/core';<br/><br/>@Directive({<br/>  selector: '[appUiButton]'<br/>})<br/>export class UiButtonDirective {<br/>  constructor(el: ElementRef) {<br/>    <br/>  }<br/>}</pre>
<p>It is injected and resolved into the <kbd>el</kbd> property. We can access the button element from the property:</p>
<pre>import { Directive, ElementRef } from '@angular/core';<br/><br/>@Directive({<br/>  selector: '[appUiButton]'<br/>})<br/>export class UiButtonDirective {<br/>  constructor(el: ElementRef) {<br/>    el.nativeElement.style.backgroundColor = '#ff00a6';<br/>  }<br/>}</pre>
<p>The <kbd>nativeElement</kbd> property gives you access to the element that the attribute directive was applied to. You can then treat the value like a DOM API, which is why we can access the <kbd>style</kbd> and <kbd>backgroundColor</kbd> properties:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-338 image-border" height="795" src="assets/7cd2e5f0-0729-4fff-968a-b6968f9e5506.png" width="1365"/></div>
<p>You can see that the pink background was applied effectively. Let's make the button more interesting with more styles, right from the directive:</p>
<pre>import { Directive, ElementRef } from '@angular/core';<br/><br/>@Directive({<br/>  selector: '[appUiButton]'<br/>})<br/>export class UiButtonDirective {<br/>  constructor(el: ElementRef) {<br/>    Object.assign(el.nativeElement.style, {<br/>      backgroundColor: '#ff00a6',<br/>      padding: '7px 15px',<br/>      fontSize: '16px',<br/>      color: '#fff',<br/>      border: 'none',<br/>      borderRadius: '4px'<br/>    })<br/>  }<br/>}</pre>
<p>Instead of setting the values using several dots, we just use the <kbd>Object.assign</kbd> method to reduce the amount of code we have to write. Now, we have a prettier button in the browser, completely styled with a directive:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-339 image-border" height="310" src="assets/fef31767-c6f0-4eb3-ae1b-ab8a2f6942bd.png" width="520"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling events in directives</h1>
                </header>
            
            <article>
                
<p>Directives are so flexible that they allow you to apply different states, based on events triggered by the user. For instance, we can add a hover behavior to the button where a different color (say black) is applied to the button when the mouse cursor moves over the button:</p>
<pre>import { <br/>  Directive, <br/>  ElementRef, <br/>  HostListener } from '@angular/core';<br/><br/>@Directive({<br/>  selector: '[appUiButton]'<br/>})<br/>export class UiButtonDirective {<br/>  constructor(private el: ElementRef) {<br/>    Object.assign(el.nativeElement.style, {<br/>      backgroundColor: '#ff00a6',<br/>      ...<br/>    })<br/>  }<br/><br/>  @HostListener('mouseenter') onMouseEnter() {<br/>    this.el.nativeElement.style.backgroundColor = '#000';<br/>  }<br/> <br/>  @HostListener('mouseleave') onMouseLeave() {<br/>    this.el.nativeElement.style.backgroundColor = '#ff00a6';<br/>  }<br/>}</pre>
<p>We introduced a few members to this file:</p>
<ul>
<li>We import <kbd>HostListener</kbd>, a decorator that extends a method in the class. It turns the method into an event listener attached to the native element. The decorator takes an argument of the event type.</li>
<li>We define two methods on <kbd>onMouseEnter</kbd> and <kbd>onMouseLeave</kbd> and then decorate the methods with <kbd>HostListener</kbd>. These methods change the background colors of the button when a hover occurs.</li>
</ul>
<p>Here is what the behavior looks like when we hover the mouse over the button:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-340 image-border" height="814" src="assets/8495e131-6c3b-4e47-8bf6-619d6415048c.png" width="1362"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dynamic attribute directives</h1>
                </header>
            
            <article>
                
<p>What if we, the authors of this directive, are the final consumers? What if another developer is reusing the directive as an API? How do we make it flexible enough with dynamic values? When you ask yourself these questions while writing directives, then it's time to make it dynamic.</p>
<p>All this while, we have been using the directive without any value. We can actually use attribute values to receive inputs into the directive:</p>
<pre>&lt;button appUiButton bgColor="red"&gt;Click!!&lt;/button&gt;</pre>
<p>We added a new attribute, <kbd>bgColor</kbd>, which is not a directive but an input property. The property is used to send dynamic values to the directive, as follows:</p>
<pre>import { <br/>  Directive, <br/>  ElementRef, <br/>  HostListener, <br/>  Input,<br/>  OnInit } from '@angular/core';<br/><br/>@Directive({<br/>  selector: '[appUiButton]'<br/>})<br/>export class UiButtonDirective implements OnInit {<br/>  @Input() bgColor: string;<br/>  @Input() hoverBgColor: string;<br/>  constructor(private el: ElementRef) {}<br/><br/>  ngOnInit() {<br/>    Object.assign(this.el.nativeElement.style, {<br/>      backgroundColor: this.bgColor || '#ff00a6',<br/>      padding: '7px 15px',<br/>      fontSize: '16px',<br/>      color: '#fff',<br/>      border: 'none',<br/>      borderRadius: '4px'<br/>    })<br/>  }<br/><br/>  @HostListener('mouseenter') onMouseEnter() {<br/>    console.log(this.bgColor);<br/>    this.el.nativeElement.style.backgroundColor = this.hoverBgColor || '#000';<br/>  }<br/> <br/>  @HostListener('mouseleave') onMouseLeave() {<br/>    this.el.nativeElement.style.backgroundColor = this.bgColor || '#ff00a6';<br/>  }<br/>}</pre>
<p>Here are the changes we introduced:</p>
<ul>
<li>Two <kbd>Input</kbd> decorated properties--<kbd>bgColor</kbd> and <kbd>bgHoverColor</kbd>--are introduced to serve as the flow of dynamic values from the template to the directive.</li>
<li>The setup of this directive is moved from the constructor to the <kbd>ngOnInit</kbd> method. This is because the input decorator is set by Angular's change detection, which doesn't happen in a constructor, thereby making <kbd>bgColor</kbd> and <kbd>bgHoverColor</kbd> undefined when we try to access them from the constructor.</li>
<li>When setting up the styles, rather than hardcoding the value of <kbd>backgroundColor</kbd>, we use the value received via <kbd>bgColor</kbd>. We also have a fallback value just in case the developer forgets to include the attribute.</li>
<li>The same thing happens to the mouse-enter and mouse-leave events.</li>
</ul>
<p>Now, the button visuals are affected by dynamic values:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-341 image-border" height="814" src="assets/95a00373-e877-40f1-8669-cb1b1bd41e35.png" width="1360"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Structural directives</h1>
                </header>
            
            <article>
                
<p>Structural directives have a lot in common with attribute directives, in terms of how they are created, but they are very different in how they are expected to behave. A structural directive, unlike an attribute directive, is expected to create or remove a DOM element. This is different from using a CSS display property to show or hide an element. In this case, the element is still in the DOM tree but is not visible to the end user when hidden.</p>
<p>A good example is <kbd>*ngIf</kbd>. When an element is removed from the DOM using an <kbd>*ngIf</kbd> structural directive, the directive both disappears from the screen and gets deleted from the DOM tree.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why the difference?</h1>
                </header>
            
            <article>
                
<p>The way you control the visibility of DOM elements could have a great impact on the performance of your applications.</p>
<p>Take for instance, you have an accordion that is expected to be clicked by the user to show more information. The user might decide to hide the accordion's content after viewing the content and, at a later time, come back to reopen it for references. It starts becoming obvious that the accordion's content has the tendency of being displayed and hidden at any time.</p>
<p>When this is the case, it is best that we use an attribute directive that doesn't hide/remove the accordion content but rather just hides it. This makes it really fast to show and hide again when needed. Using a structural directive such as <kbd>*ngIf</kbd> keeps creating and destroying a part of the DOM tree, which can be very expensive if the DOM content being controlled is huge.</p>
<p>On the other hand, when you have some content you're sure the user will view only once or a maximum of two times, it is better to make use of a structural directive such as <kbd>*ngIf</kbd>. This way, your DOM is not littered with lots of unused HTML contents.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The deal with asterisks</h1>
                </header>
            
            <article>
                
<p>The asterisks that precede all the structural directives are very important. The <kbd>*ngIf</kbd> and <kbd>*ngFor</kbd> directives refuse to work when you remove the asterisks from them, implying that the asterisks are required. The question, therefore, is this: why do the asterisks have to be there?</p>
<p>They are syntactic sugar in Angular, meaning that they don't have to be written this way. This is how they actually look:</p>
<pre>&lt;div template="ngIf true"&gt;<br/>  &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Nesciunt non perspiciatis consequatur sapiente provident nemo similique. Minus quo veritatis ratione, quaerat dolores optio facilis dolor nemo, tenetur, obcaecati quibusdam, doloremque.&lt;/p&gt;<br/>&lt;/div&gt;</pre>
<p>This template attribute is, in turn, translated into the following by Angular:</p>
<pre><span class="tag">&lt;ng-template</span><span class="pln"> [</span><span class="atn">ngIf</span><span class="pln">]</span><span class="pun">=</span><span class="atv">"true"</span><span class="tag">&gt;<br/>  &lt;div template="ngIf true"&gt;<br/>    &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit....&lt;/p&gt;<br/>  &lt;/div&gt;<br/></span>&lt;/ng-template&gt;</pre>
<p>See how <kbd>ngIf</kbd> has now become a normal Angular property but is injected into a template. When the value is <kbd>false</kbd>, the template is removed (not hidden) from the DOM tree. Writing such directives this way is just a lot of code to write, so Angular added the syntactic sugar to simplify how we write the <kbd>ngIf</kbd> directive:</p>
<pre>&lt;div *ngIf="true"&gt;<br/>  &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Nesciunt non perspiciatis consequatur sapiente provident nemo similique.&lt;/p&gt;<br/>&lt;/div&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating structural directives</h1>
                </header>
            
            <article>
                
<p>We have already seen how to use structural directives from our previous examples. How do we create them? We create them in the same way we created the attribute directive, by running the following command in your terminal:</p>
<pre><strong>ng generate directive when</strong></pre>
<p>Yes, we are naming the directive <kbd>when</kbd>. This directive does exactly what <kbd>*ngIf</kbd> does, so, hopefully, it will help you better understand the internals of the directive you've already used.</p>
<p>Update the directive with the following:</p>
<pre>import { <br/>  Directive, <br/>  Input, <br/>  TemplateRef, <br/>  ViewContainerRef } from '@angular/core';<br/><br/>@Directive({<br/>  selector: '[appWhen]'<br/>})<br/>export class WhenDirective {<br/>  constructor(<br/>    private templateRef: TemplateRef&lt;any&gt;,<br/>    private viewContainer: ViewContainerRef) { }<br/>}</pre>
<p>We introduced a few members you're not familiar with yet. <kbd>TemplateRef</kbd> is a reference to the <kbd>ng-template</kbd> template that we saw earlier, in which the DOM content we are controlling is contained. <kbd>ViewContainerRef</kbd> is a reference to the view itself.</p>
<p>When using the <kbd>appWhen</kbd> directive in the view, it's expected to take a condition such as <kbd>ngIf</kbd>. To receive such a condition, we need to create a decorated <kbd>Input</kbd> setter method:</p>
<pre>export class WhenDirective {<br/>  private hasView = false;<br/><br/>  constructor(<br/>    private templateRef: TemplateRef&lt;any&gt;,<br/>    private viewContainer: ViewContainerRef) { }<br/><br/>  @Input() set appWhen(condition: boolean) {<br/>    if (condition &amp;&amp; !this.hasView) {<br/>      this.viewContainer.createEmbeddedView(this.templateRef);<br/>      this.hasView = true;<br/>    } else if (!condition &amp;&amp; this.hasView) {<br/>      this.viewContainer.clear();<br/>      this.hasView = false;<br/>    }<br/>  }<br/>}</pre>
<p>The setter method in the directive checks whether the value resolves to <kbd>true</kbd> and then displays the content and creates the view if it's yet to be created. The reverse becomes the case when the value resolves to <kbd>false</kbd>.</p>
<p>Let's test the directive by clicking the button we were to toiling within the attribute directives section. When the button is clicked, it toggles a property to <kbd>true</kbd> or <kbd>false</kbd>. This property is bound to the value of the directive we created.</p>
<p>Update the app component class with the following:</p>
<pre>export class AppComponent {<br/>  toggle = false;<br/>  updateToggle() {<br/>    this.toggle = !this.toggle;<br/>  }<br/>}</pre>
<p>The <kbd>updateToggle</kbd> method is bound to the button in order to flip the value of <kbd>toggle</kbd> when clicked by the user. Here is what the app component HTML looks like:</p>
<pre>&lt;h3 <br/>  style="text-align:center" <br/>  *appWhen="toggle"<br/> &gt;Hi, cute directive&lt;/h3&gt;<br/><br/>&lt;button <br/>  appUiButton <br/>  bgColor="red" <br/>  (click)="updateToggle()"<br/>&gt;Click!!&lt;/button&gt;</pre>
<p>Once you click the button, it shows or hides the text by adding or removing it from the screen:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-342 image-border" height="806" src="assets/3ba02da5-84b0-4609-ac7e-631d82b634c4.png" width="1362"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pipes</h1>
                </header>
            
            <article>
                
<p>Another interesting template feature that we have not discussed yet are pipes. Pipes allow you to format the template content in-place, right in the template. Instead of formatting content in the component, you could just write a pipe to do so for you right in the template. Here is a perfect example for a pipe:</p>
<pre>&lt;div class="container"&gt;<br/>  &lt;h2&gt;{{0.5 | percent}}&lt;/h2&gt;<br/>&lt;/div&gt;</pre>
<p>Adding the <kbd>| percent</kbd> after a decimal figure changes the value to a percentage representation, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-343 image-border" height="723" src="assets/8ccef630-dbac-4d8d-982b-1a1e67e5ad0e.png" width="1143"/></div>
<p>Here is another example with one of the case pipes:</p>
<pre>&lt;div class="container"&gt;<br/>  &lt;h2&gt;{{0.5 | percent}}&lt;/h2&gt;<br/>  &lt;h3&gt;{{'this is uppercase' | uppercase}}&lt;/h3&gt;<br/>&lt;/div&gt;</pre>
<p>The <kbd>uppercase</kbd> pipe transforms a text string to uppercase. Here is the output of the preceding code sample:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-344 image-border" height="313" src="assets/1655112a-fdf8-404c-9a96-d6063cffaf9b.png" width="494"/></div>
<p>Some pipes take arguments, which help fine-tune the behavior of the pipe when applied to some content. An example of such pipes is the currency pipe, which takes an argument to define which currency a content will be formatted with:</p>
<pre>&lt;h2&gt;{{50.989 | currency:'EUR':true}}&lt;/h2&gt;</pre>
<p>The following screenshot shows a nicely formatted value:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-345 image-border" height="270" src="assets/41576b5a-4a7a-48cc-92e8-ef5f2995ebb4.png" width="427"/></div>
<p>The pipe takes two arguments separated by a colon (<kbd>:</kbd>). The first argument is the currency that we set to Euro. The second argument is a Boolean value that indicates the kind of currency symbol shown. Because the value is <kbd>true</kbd>, the Euro symbol is shown. Here is the output when the value is <kbd>false</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-346 image-border" height="273" src="assets/10f6ee42-d0fd-4ed7-a6cd-2d9f1dd96ae2.png" width="436"/></div>
<p>Instead of using the symbol, it just precedes the value with the currency code (EUR).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating pipes</h1>
                </header>
            
            <article>
                
<p>We have seen what we can use pipes for and where we can use them. The next thing we need to understand is how to create our own custom pipes using TypeScript classes. First, run the following command to generate an empty pipe:</p>
<pre><strong>ng generate pipe reverse</strong></pre>
<p>Then, update the generated class file with the following:</p>
<pre>import { Pipe, PipeTransform } from '@angular/core';<br/><br/>@Pipe({<br/>  name: 'reverse'<br/>})<br/>export class ReversePipe implements PipeTransform {<br/><br/>  transform(value: any, args?: any): any {<br/>    return value.split('').reverse().join('');<br/>  }<br/><br/>}</pre>
<p>This example takes a string and returns the reversed version of the string. The <kbd>ReversePipe</kbd> class implements a <kbd>PipeTransform</kbd> interface, which defines a <kbd>transform</kbd> method that must be created with a certain signature, as seen previously.</p>
<p>The class is decorated with a <kbd>Pipe</kbd> decorator, which takes a config object as an argument. The object must define a <kbd>name</kbd> property, which serves as the identifier for the pipe when applied to a template. In our case, the name of the pipe is <kbd>reverse</kbd>.</p>
<p>You can now apply your custom pipe to the template:</p>
<pre>&lt;h3&gt;{{'watch me flip' | reverse}}&lt;/h3&gt; </pre>
<p>When you view the example, the text is reversed, so it now starts with <span class="packt_screen">p</span> and ends with <span class="packt_screen">w</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-347 image-border" height="317" src="assets/70355d3c-9e20-42dd-815a-7797aafa89d7.png" width="512"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Passing arguments to pipes</h1>
                </header>
            
            <article>
                
<p>We saw how to create pipes, but we also have it at the back of our minds that pipes take arguments. How do we add these arguments to our custom pipes?</p>
<p>The generated pipe could already be giving you hints from the previous example because of the optional <kbd>args</kbd> parameter passed to the transform method:</p>
<pre>transform(value: any, args?: any): any {<br/>    ...<br/>}</pre>
<p>Assuming that we want to define whether the reverse of the string is applied letter-to-letter or word-to-word, the best way to give the pipe user this control is through arguments. Here is an updated example:</p>
<pre>export class ReversePipe implements PipeTransform {<br/><br/>  transform(value: any, args?: any): any {<br/>    if(args){<br/>      return value.split(' ').reverse().join(' ');<br/>    } else {<br/>      return value.split('').reverse().join('');<br/>    }<br/>  }<br/><br/>}</pre>
<p>When the argument supplied is <kbd>true</kbd>, we reverse the string by words, not letters. This is done by splitting the string in places where there are white spaces, not empty strings. When it's <kbd>false</kbd>, we split at empty strings, which reverses the string based on letters.</p>
<p>We can now use the pipe while passing it an argument:</p>
<pre>&lt;h2&gt;{{'watch me flip' | reverse:true}}&lt;/h2&gt; </pre>
<p>This is the resulting output:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-348 image-border" height="331" src="assets/bab69d1f-d381-4538-827e-1b9d38be6c4d.png" width="541"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modules</h1>
                </header>
            
            <article>
                
<p>We mentioned modules at the beginning of this article and how they help us organize our project. With that in mind, take a look at this app module:</p>
<pre>import { BrowserModule } from '@angular/platform-browser';<br/>import { NgModule } from '@angular/core';<br/><br/>import { AppComponent } from './app.component';<br/>import { UiButtonDirective } from './ui-button.directive';<br/>import { WhenDirective } from './when.directive';<br/><br/>@NgModule({<br/>  declarations: [<br/>    AppComponent,<br/>    UiButtonDirective,<br/>    WhenDirective<br/>  ],<br/>  imports: [<br/>    BrowserModule<br/>  ],<br/>  providers: [],<br/>  bootstrap: [AppComponent]<br/>})<br/>export class AppModule { }</pre>
<p>Here is a module from the directive:</p>
<pre>examples:import { BrowserModule } from '@angular/platform-browser';<br/>import { NgModule } from '@angular/core';<br/><br/>import { AppComponent } from './app.component';<br/>import { ReversePipe } from './reverse.pipe';<br/><br/>@NgModule({<br/>  declarations: [<br/>    AppComponent,<br/>    ReversePipe<br/>  ],<br/>  imports: [<br/>    BrowserModule<br/>  ],<br/>  providers: [],<br/>  bootstrap: [AppComponent]<br/>})<br/>export class AppModule { }</pre>
<p>If you paid so much attention to details, you may have noticed that we never added <kbd>UiButtonDirective</kbd> or <kbd>WhenDirective</kbd> in the directive. Neither did we add <kbd>ReversePipe</kbd> in the pipe example. These additions are automated for all the members when your run the <kbd>generate</kbd> command, except for services.</p>
<p>For all the members you create, that is, components, directives, pipes, and services, you need to include them where they belong in a module.</p>
<p>A module (usually referred to as <kbd>NgModule</kbd>) is a class that is decorated with the <kbd>NgModule</kbd> decorator. This decorator takes a config object that tells Angular about the members created in the app and where they belong to.</p>
<p>Here are the different properties:</p>
<ul>
<li><kbd>declarations</kbd>: Components, directives, and pipes must be defined in the <kbd>declarations</kbd> array for them to be exposed to the app. Failure to do so will log errors to your console, telling you that the omitted member is not recognized.</li>
<li><kbd>imports</kbd>: The app module is not the only module that exists. You can have smaller and simpler modules that group related task members together. In this case, you still need to import the smaller modules to the app module. The <kbd>imports</kbd> array is where you do that. These smaller modules are usually referred to as feature modules. A feature module can also be imported to another feature module.</li>
<li><kbd>providers</kbd>: If you have services that abstract specific tasks and need to be injected via dependency injection into the app, you need to specify such services in the <kbd>providers</kbd> array.</li>
<li><kbd>bootstrap</kbd>: The <kbd>bootstrap</kbd> array is only declared in the entry module, which is usually the app module. This array defines which component should be launched first or which component serves as the entry point of your app. The value is always <kbd>AppComponent</kbd> because that is the entry point.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>You learned a lot of concepts, ranging from directives and pipes to modules. You learned the different types of directives (attribute and structural) and how to create each of them. We also discussed how arguments are passed to pipes while creating them. In the next chapter, we will talk about routing in Angular applications and how TypeScript plays a significant role.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>