- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Understanding React Essentials
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解React基础知识
- en: Welcome to this fundamental chapter of our React essentials guide! This chapter
    serves as a solid foundation for your journey into the exciting world of React
    development. We will delve into the fundamental concepts of React and provide
    you with the essential knowledge needed to kickstart your React projects with
    confidence.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到我们React基础知识指南的基本章节！本章为您进入激动人心的React开发世界奠定了坚实的基础。我们将深入探讨React的基本概念，并为您提供启动React项目所需的基本知识，让您有信心地开始。
- en: In this chapter, we will explore how to think in components, a crucial mindset
    for building reusable and modular **user interfaces** (**UIs**). You will learn
    the art of breaking your application down into smaller, self-contained components,
    enabling you to create maintainable and scalable code bases. By understanding
    this fundamental concept, you will be equipped with the skills to architect robust
    and flexible React applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何以组件的方式思考，这是构建可重用和模块化**用户界面**（**UIs**）的关键心态。您将学习将应用程序分解成更小、自包含组件的艺术，从而能够创建可维护和可扩展的代码库。通过理解这一基本概念，您将具备构建强大和灵活的React应用程序的技能。
- en: Additionally, we will introduce you to the most commonly used Hooks in React,
    such as `useState`, `useEffect`, and more. These Hooks are powerful tools that
    allow you to manage state, handle side effects, and tap into React’s lifecycle
    methods within functional components. By mastering these Hooks, you will have
    the ability to create dynamic and interactive UIs effortlessly.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将向您介绍React中最常用的Hooks，例如`useState`、`useEffect`等。这些Hooks是强大的工具，允许您在函数组件中管理状态、处理副作用，并访问React的生命周期方法。通过掌握这些Hooks，您将能够轻松地创建动态和交互式的UI。
- en: By the end of this chapter, you will be well prepared to explore more advanced
    topics and tackle real-world React challenges in the subsequent chapters of our
    guide. So, buckle up and get ready to embark on an exciting journey into the world
    of React.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将准备好探索更高级的主题，并在指南的后续章节中应对真实的React挑战。所以，系好安全带，准备好开始一段激动人心的React世界之旅。
- en: 'So, in this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主题：
- en: Understanding static components in React
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解React中的静态组件
- en: Creating components with props
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性创建组件
- en: Breaking down UIs into components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将UI分解为组件
- en: Managing internal state in React
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React中管理内部状态
- en: Understanding the rendering process
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解渲染过程
- en: Exploring common React Hooks
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索常见的React Hooks
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A GitHub repository has been created to host all the code we discuss in the
    book. For this chapter, you can find it under [https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch2](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch2).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 已创建一个GitHub仓库来托管本书中讨论的所有代码。对于本章，您可以在[https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch2](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch2)找到它。
- en: Understanding static components in React
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解React中的静态组件
- en: React applications are built on components. A **component** can range from a
    simple function returning an HTML snippet to a more complex one that interacts
    with network requests, dynamically generates HTML tags, and even auto-refreshes
    based on backend service changes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: React应用程序是基于组件构建的。一个**组件**可以从一个简单的返回HTML片段的函数到更复杂的组件，它可以与网络请求交互，动态生成HTML标签，甚至根据后端服务的变化自动刷新。
- en: 'Let’s start with a basic scenario and define a **static component**. In React,
    a static component (also known as presentational components or dumb components)
    refers to a component that doesn’t have any state and doesn’t interact with the
    data or handle any events. It is a component that only renders the UI based on
    the props it receives. Here’s an example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本场景开始，定义一个**静态组件**。在React中，静态组件（也称为展示组件或哑组件）指的是没有状态且不与数据交互或处理任何事件的组件。它是一个仅根据接收到的属性渲染UI的组件。以下是一个示例：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This static component closely resembles the corresponding HTML snippet, which
    uses the `<article>` tag to structure content with a title and a paragraph:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个静态组件与相应的HTML片段非常相似，它使用`<article>`标签来结构化带有标题和段落的内联内容：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While encapsulating static HTML in a component is useful, there may be a need
    for the component to represent different articles, not just a specific one. Just
    as we pass parameters to a function to make it more versatile, we can pass parameters
    into a component to make it useful in different contexts. That can be done with
    props, which we will discuss in the next section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在组件中封装静态HTML很有用，但可能需要组件代表不同的文章，而不仅仅是特定的某篇。就像我们传递参数给函数以使其更灵活一样，我们也可以将参数传递给组件，使其在不同的上下文中有用。这可以通过props来实现，我们将在下一节中讨论。
- en: Creating components with props
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用属性创建组件
- en: In React, components can receive input in the form of properties, which are
    commonly referred to as props. **Props** allow us to pass data from a parent component
    to its child components. This mechanism enables components to be reusable and
    adaptable, as they can receive different sets of props to customize their behavior
    and appearance.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，组件可以通过属性接收输入，这些属性通常被称为props。**Props**允许我们将数据从父组件传递到子组件。这种机制使得组件可以重用和适应，因为它们可以接收不同的props集合来定制其行为和外观。
- en: Props are essentially JavaScript objects containing key-value pairs, where the
    keys represent the prop names and the values contain the corresponding data. These
    props can include various types of data, such as strings, numbers, Booleans, or
    even functions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Props本质上是由键值对组成的JavaScript对象，其中键代表属性名，值包含相应的数据。这些属性可以包括各种类型的数据，如字符串、数字、布尔值，甚至是函数。
- en: By passing props to a component, we can control its rendering and behavior dynamically.
    This allows us to create flexible and composable components that can be easily
    composed together to build complex UIs.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向组件传递props，我们可以动态地控制其渲染和行为。这使我们能够创建灵活且可组合的组件，可以轻松组合在一起来构建复杂的UI。
- en: Now, let’s move beyond a static component and see how we can make it more generic
    by using props. Suppose we want to display a list of blog posts, each with a heading
    and a summary. In HTML, we would manually write the HTML fragments. However, with
    React components, we can dynamically generate these HTML fragments using JavaScript.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们超越静态组件，看看我们如何通过使用props使其更具通用性。假设我们想要显示一系列博客文章，每篇都有标题和摘要。在HTML中，我们会手动编写HTML片段。然而，使用React组件，我们可以使用JavaScript动态生成这些HTML片段。
- en: 'First, let’s start with the basic structure:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从基本结构开始：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can then pass the desired `heading` and `summary` values to the `Article`
    component:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将所需的`heading`和`summary`值传递给`Article`组件：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Or, we could define another `Article` component:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以定义另一个`Article`组件：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By using props, we can pass different values to the `heading` and `summary`
    props when we use the `Article` component. This makes the component versatile
    and reusable, as it can be used to display various articles with different titles
    and summaries based on the provided props.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用属性，当我们使用`Article`组件时，我们可以向`heading`和`summary`属性传递不同的值。这使得组件更加灵活和可重用，因为它可以根据提供的属性显示具有不同标题和摘要的各种文章。
- en: Props are a fundamental concept in React that allows us to customize and configure
    components, making them dynamic and adaptable to different data or requirements.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Props是React中的一个基本概念，它允许我们自定义和配置组件，使它们具有动态性和适应性，以适应不同的数据或需求。
- en: A component can have any number of props, although it’s recommended to keep
    them to a manageable amount, preferably no more than five or six. This helps maintain
    clarity and understandability, as having too many props can make the component
    harder to comprehend and extend.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组件可以有任意数量的属性，尽管建议将它们保持在可管理的数量，最好不超过五到六个。这有助于保持清晰和可理解性，因为属性过多会使组件更难理解和扩展。
- en: Breaking down UIs into components
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将UI分解为组件
- en: 'Let’s examine a more complex UI and explore how to break it down into components
    and implement them separately. In this example, we will use a weather application:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察一个更复杂的UI，并探讨如何将其分解为组件并单独实现。在这个例子中，我们将使用一个天气应用程序：
- en: '![Figure 2.1: A weather application](img/B21103_02_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1：天气应用程序](img/B21103_02_01.jpg)'
- en: 'Figure 2.1: A weather application'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：天气应用程序
- en: 'The entire application can be defined as a `WeatherApplication` component,
    which includes several subcomponents:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 整个应用程序可以定义为一个`WeatherApplication`组件，它包括几个子组件：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Each subcomponent can perform various tasks, such as fetching data from a remote
    server, conditionally rendering a drop-down list, or auto-refreshing periodically.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子组件可以执行各种任务，例如从远程服务器获取数据、条件性地渲染下拉列表或定期自动刷新。
- en: 'For example, a `SearchBox` component might have the following structure:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个`SearchBox`组件可能有以下结构：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `search-results` section will only appear when data is fetched from the
    search query.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在从搜索查询获取数据时，`search-results`部分才会出现。
- en: 'On the other hand, a `Weather` component could be more straightforward, rendering
    whatever is passed to it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一个`Weather`组件可能更简单，渲染传递给它的任何内容：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When implementing components in real-world scenarios, it is crucial to pay attention
    to styling and refine the HTML structure with meticulous detail. Additionally,
    components should effectively manage their own state, ensuring consistency and
    responsiveness across renders.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际场景中实现组件时，注意样式并细致地完善HTML结构至关重要。此外，组件应有效地管理自己的状态，确保渲染的一致性和响应性。
- en: By grasping the concept of components and their proper structuring in React,
    you gain the ability to construct dynamic and reusable UI elements that contribute
    to the overall functionality and organization of your application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过掌握组件及其在React中的适当结构化概念，您可以构建动态和可重用的UI元素，这些元素有助于您应用程序的整体功能和组织。
- en: As you advance in your React development journey, don’t forget to polish the
    visual presentation through styling and consider efficient state management techniques
    to enhance the performance and interactivity of your components.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的React开发之旅中不断进步时，不要忘记通过样式美化视觉呈现，并考虑有效的状态管理技术来提高组件的性能和交互性。
- en: 'A complete `Weather` component could be something like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的`Weather`组件可能如下所示：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The code snippet defines two types: `Weather` and `WeatherType`. The `Weather`
    type represents the weather data with two properties: `main` (string) and `temperature`
    (number). The `WeatherType` type represents the structure of the weather data
    for a specific location, with a `name` property (string) for the location name
    and a `weather` property of the `Weather` type.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段定义了两种类型：`Weather`和`WeatherType`。`Weather`类型表示带有两个属性（`main`（字符串）和`temperature`（数字））的天气数据。`WeatherType`类型表示特定位置的天气数据结构，具有一个`name`属性（字符串）用于位置名称和一个`weather`属性，该属性为`Weather`类型。
- en: The `WeatherCard` component receives the name and weather props of the `WeatherType`
    type. Inside the component, it renders a `div` container with a dynamic class
    based on the `weather.main` value.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeatherCard`组件接收`WeatherType`类型的名称和天气属性。在组件内部，它渲染一个基于`weather.main`值的动态类别的`div`容器。'
- en: When working on complex UIs, it is crucial to break them down into smaller,
    manageable components. Each component should represent a separate concept, and
    they can be combined together using **JSX** (**JavaScript Extension**), similar
    to writing HTML code. While props are useful for passing data to components, there
    are situations where we need to maintain data within a component itself. This
    is where states come into play, allowing us to manage and update data internally.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理复杂的UI时，将它们分解成更小、更易于管理的组件至关重要。每个组件应代表一个独立的概念，并且可以使用**JSX**（**JavaScript扩展**）将它们组合在一起，类似于编写HTML代码。虽然props对于向组件传递数据很有用，但有时我们需要在组件内部本身维护数据。这就是状态发挥作用的地方，它允许我们内部管理和更新数据。
- en: Managing internal state in React
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React中管理内部状态
- en: '**State** in React refers to the internal data that components can hold and
    manage. It allows components to store and update information, enabling dynamic
    UI updates, interactivity, and data persistence. State is a fundamental concept
    in React that helps build responsive and interactive applications.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态**在React中指的是组件可以持有和管理的内部数据。它允许组件存储和更新信息，从而实现动态UI更新、交互性和数据持久性。状态是React中的一个基本概念，有助于构建响应性和交互式应用程序。'
- en: Applications feature various state types, such as a Boolean for toggle status,
    a loading state for network requests, or a user-input string for queries. We’ll
    explore the `useState` Hook, ideal for maintaining local state within a component
    across re-renders. React **Hooks** are a feature introduced in React 16.8 that
    enables functional components to have state and lifecycle features (we’ll discuss
    Hooks in more detail in the *Exploring common React Hooks* section later).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序具有各种状态类型，例如用于切换状态的布尔值、用于网络请求的加载状态，或用于查询的用户输入字符串。我们将探索 `useState` 钩子，它非常适合在组件的重新渲染之间维护本地状态。React
    **Hooks** 是在 React 16.8 中引入的一个特性，它使函数组件能够拥有状态和生命周期特性（我们将在后面的 *探索常见 React Hooks*
    部分更详细地讨论 Hooks）。
- en: 'Let’s begin by using a simple Hook for internal state management to understand
    how it maintains data within a component. For example, the following `SearchBox`
    component can be implemented with something like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用一个简单的钩子来管理内部状态开始，以了解它是如何在一个组件内维护数据的。例如，以下 `SearchBox` 组件可以这样实现：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code snippet showcases that `SearchBox` includes an input field, a search
    button, and a display area for search results. The `useState` Hook is used to
    create a state variable called `query`, initialized as an empty string. The `handleChange`
    function captures the user’s input and updates the query state accordingly. Then,
    `component` renders the input field with the current value of `query`, a search
    button, and a `div` tag as a container displaying the search results.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段展示了 `SearchBox` 包含一个输入字段、一个搜索按钮和一个用于显示搜索结果的显示区域。`useState` 钩子用于创建一个名为 `query`
    的状态变量，初始化为空字符串。`handleChange` 函数捕获用户的输入并相应地更新查询状态。然后，`component` 渲染输入字段，显示 `query`
    的当前值，一个搜索按钮，以及一个用作容器显示搜索结果的 `div` 标签。
- en: 'Note here the `useState` Hook is used to manage state within the `SearchBox`
    component:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里，`useState` 钩子被用于在 `SearchBox` 组件中管理状态：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s explain this code a little more specifically:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更具体地解释一下这段代码：
- en: '`useState<string>("")`: This line declares a state variable called query and
    initializes it with an empty string (`""`)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useState<string>("")`：这一行声明了一个名为 `query` 的状态变量，并用空字符串（`""`）初始化它'
- en: '`const [query, setQuery]`: This syntax uses array destructuring to assign the
    state variable (`query`) and its corresponding update function (`setQuery`) to
    variables with the same names'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const [query, setQuery]`：这个语法使用数组解构将状态变量（`query`）及其相应的更新函数（`setQuery`）分配给具有相同名称的变量'
- en: 'Now, we have the state and the setter function bound to the input box. As we
    enter a city name in the input box, the `search-results` area is automatically
    updated, along with the input value. Although there are multiple re-renders occurring
    as we type, the state value persists throughout the process:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了状态和绑定到输入框的设置函数。当我们输入城市名称到输入框时，`search-results` 区域会自动更新，同时输入值也会更新。尽管在我们输入时会发生多次重新渲染，但状态值在整个过程中保持不变：
- en: '![Figure 2.2: Managing state with useState](img/B21103_02_02.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2：使用 useState 管理状态](img/B21103_02_02.jpg)'
- en: 'Figure 2.2: Managing state with useState'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：使用 useState 管理状态
- en: The `useState` Hook is excellent for managing internal state, yet real-world
    projects often require handling various other state types. As applications expand,
    managing global-level data shared across multiple components, such as from parent
    to children, becomes necessary. We’ll discuss different mechanisms for this kind
    of state management in later sections.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState` 钩子非常适合管理内部状态，但在现实世界的项目中，经常需要处理各种其他状态类型。随着应用程序的扩展，管理跨多个组件共享的全局级数据，例如从父组件到子组件，变得必要。我们将在后面的章节中讨论这种状态管理的不同机制。'
- en: Now that we have gained an understanding of how props and state enable us to
    create dynamic components, it is important to explore how changes in data impact
    the rendering process in React. By understanding this process, we can take steps
    to optimize our code for improved efficiency and performance.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何通过 props 和状态来创建动态组件，那么探索数据变化如何影响 React 中的渲染过程就变得很重要了。通过理解这个过程，我们可以采取措施来优化我们的代码，以提高效率和性能。
- en: Understanding the rendering process
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解渲染过程
- en: 'When the data that a React component relies on changes, whether it is through
    updated props or a modified state, React needs to update the UI to reflect those
    changes. The process is called **rendering**, and is composed of the following
    steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 React 组件依赖的数据发生变化时，无论是通过更新的 props 还是修改的状态，React 都需要更新 UI 以反映这些变化。这个过程被称为
    **渲染**，它由以下步骤组成：
- en: '**Initial render**: When a functional component is first rendered, it generates
    a virtual representation of the component’s UI. This virtual representation describes
    the structure and content of the UI elements.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始渲染**：当函数组件首次渲染时，它生成组件 UI 的虚拟表示。这个虚拟表示描述了 UI 元素的结构和内容。'
- en: '**State and props changes**: When there are changes in the component’s state
    or props, React re-evaluates the component’s function body. It performs a diffing
    algorithm to compare the previous and new function bodies, identifying the differences
    between them.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态和属性变化**：当组件的状态或属性发生变化时，React 重新评估组件的函数体。它执行 diffing 算法来比较之前和新的函数体，确定它们之间的差异。'
- en: Note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In React, a **diffing** algorithm is an internal mechanism that compares previous
    and new virtual **Document Object Model** (**DOM**) representations of a component
    and determines the minimal set of changes needed to update the actual DOM.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，**diffing** 算法是一个内部机制，它比较组件之前和新的虚拟 **文档对象模型**（**DOM**）表示，并确定更新实际 DOM
    所需的最小更改集。
- en: '**Reconciliation**: React determines which parts of the UI need to be updated
    based on the differences identified during the diffing process. It updates only
    those specific parts of the UI, keeping the rest unchanged.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协调**：React 根据在 diffing 过程中识别出的差异确定 UI 需要更新的部分。它只更新 UI 的特定部分，保持其余部分不变。'
- en: '**Re-rendering**: React re-renders the component by updating the virtual representation
    of the UI. It generates a new virtual DOM based on the updated function body,
    replacing the previous virtual DOM.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重新渲染**：React 通过更新 UI 的虚拟表示来重新渲染组件。它根据更新的函数体生成新的虚拟 DOM，替换之前的虚拟 DOM。'
- en: '**DOM update**: Finally, React efficiently updates the real DOM to reflect
    the changes in the virtual DOM. It applies the necessary DOM manipulations, such
    as adding, removing, or updating elements, to make the UI reflect the updated
    state and props.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DOM 更新**：最后，React 高效地更新实际的 DOM 以反映虚拟 DOM 的变化。它应用必要的 DOM 操作，如添加、删除或更新元素，使
    UI 反映更新的状态和属性。'
- en: This process ensures that the UI remains in sync with the component’s state
    and props, enabling a reactive and dynamic UI. React’s efficient rendering approach
    minimizes unnecessary DOM manipulations and provides a performant rendering experience
    in functional components.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程确保 UI 与组件的状态和属性保持同步，实现响应式和动态的 UI。React 的高效渲染方法最小化了不必要的 DOM 操作，并在函数组件中提供高性能的渲染体验。
- en: In this book, we will explore situations where writing high-performance code
    is crucial, ensuring that components only re-render when necessary while preserving
    unchanged parts. Achieving this requires utilizing Hooks effectively and employing
    various techniques to optimize rendering.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将探讨编写高性能代码至关重要的场景，确保组件仅在必要时重新渲染，同时保留未更改的部分。实现这一点需要有效地利用 Hooks 并采用各种技术来优化渲染。
- en: In an application, data management is essential, but we also encounter side
    effects such as network requests, DOM events, and the need for data sharing among
    components. To tackle these challenges, React provides a range of commonly used
    Hooks that serve as powerful tools for building applications. Let’s explore these
    Hooks and see how they can greatly assist us in our development process.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，数据管理至关重要，但我们也会遇到副作用，如网络请求、DOM 事件以及组件间数据共享的需求。为了应对这些挑战，React 提供了一系列常用的
    Hooks，它们是构建应用程序的强大工具。让我们探索这些 Hooks 并看看它们如何极大地帮助我们开发过程。
- en: Exploring common React Hooks
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索常见的 React Hooks
- en: We briefly talked about Hooks in the *Managing internal state in React* section.
    In addition, Hooks allow for code reuse, improved readability, and easier testing
    by separating concerns and making component logic more modular.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *管理 React 中的内部状态* 部分简要介绍了 Hooks。此外，Hooks 允许代码重用，提高可读性，并通过分离关注点使组件逻辑更模块化，从而简化测试。
- en: Let’s discuss a few of the most common Hooks in this section. Please be aware
    that in this chapter, we are focusing on the most used Hooks. As we progress through
    the book, we will delve into several more advanced applications of these Hooks.
    Regarding the last Hook, `useContext`, we will initially explore its basic usage
    at the end of this section to provide an introductory understanding. In later
    chapters, we’ll employ `useContext` in more complex scenarios, allowing for a
    deeper and more practical grasp of its functionality.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们讨论一些最常见的 Hooks。请注意，在本章中，我们专注于最常用的 Hooks。随着我们阅读本书的进展，我们将深入探讨这些 Hooks
    的更多高级应用。关于最后一个 Hook，`useContext`，我们将在本节末尾初步探讨其基本用法，以提供入门级理解。在后面的章节中，我们将更复杂地使用
    `useContext`，以便更深入和更实际地掌握其功能。
- en: useState
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useState
- en: 'We have already seen the basic usage of `useState` Hook previously in this
    chapter. You can define as many states as you like inside a component, and it’s
    quite common to do so in real-world projects. For example, a login form might
    include a username, a password, and a **Remember Me** flag. All these states need
    to be remembered before the user clicks the submit (**Login**) button:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中已经看到了 `useState` Hook 的基本用法。你可以在组件内部定义任意多的状态，这在实际项目中非常常见。例如，一个登录表单可能包括用户名、密码以及一个
    **记住我** 标志。在用户点击提交（**登录**）按钮之前，所有这些状态都需要被记住：
- en: '![Figure 2.3: Login form](img/B21103_02_03.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3：登录表单](img/B21103_02_03.jpg)'
- en: 'Figure 2.3: Login form'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3：登录表单
- en: 'Based on the UI, we’ll need three different states for the username, password,
    and a Boolean flag for **Remember Me**, like so:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用户界面，我们需要为用户名、密码以及一个表示 **记住我** 的布尔标志准备三个不同的状态，如下所示：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the code snippet, we have to manage three different states, so it uses the
    `useState` Hook to manage state for the `username`, `password`, and `rememberMe`
    fields. The component renders input fields for username and password, a checkbox
    for **Remember Me**, and a **Login** button. User input updates the corresponding
    state variables, enabling the capture of form data.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中，我们必须管理三个不同的状态，因此使用 `useState` Hook 来管理 `username`、`password` 和 `rememberMe`
    字段的状态。组件渲染用户名和密码的输入字段、一个用于 **记住我** 的复选框以及一个 **登录** 按钮。用户输入更新相应的状态变量，从而捕获表单数据。
- en: useEffect
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useEffect
- en: In React, a side effect refers to any code that is not directly related to rendering
    a component but has an impact outside the component’s scope. Side effects often
    involve interacting with external resources, such as making API calls, modifying
    the underlying DOM (not using the normal React virtual DOM), subscribing to event
    listeners, or managing timers.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，副作用指的是任何与渲染组件直接无关但影响组件范围外代码的代码。副作用通常涉及与外部资源交互，例如进行 API 调用、修改底层 DOM（不使用正常的
    React 虚拟 DOM）、订阅事件监听器或管理计时器。
- en: React provides a built-in Hook called `useEffect` to handle side effects within
    functional components. The `useEffect` Hook allows you to perform side effects
    after rendering or when specific dependencies change.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: React 提供了一个名为 `useEffect` 的内置 Hook，用于在函数组件中处理副作用。`useEffect` Hook 允许你在渲染后或特定依赖项更改时执行副作用。
- en: By using the `useEffect` Hook, you can ensure that side effects are executed
    at the appropriate times during the component’s lifecycle. This helps maintain
    the consistency and integrity of the application while separating side effects
    from the core rendering logic.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `useEffect` Hook，你可以确保在组件的生命周期中适当的时间执行副作用。这有助于保持应用程序的一致性和完整性，同时将副作用与核心渲染逻辑分离。
- en: 'Let’s take a look at a typical use case of `useEffect`. We created an `Article`
    component in the *Creating components with props* section; now, let’s make a list
    of articles. Normally, an article list could return from some API calls; in JSON
    format, for example. We can use the `useEffect` Hook to send the request and set
    state once the response is returned from an API call, like so:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `useEffect` 的一个典型用法。我们在 *使用属性创建组件* 部分创建了一个 `Article` 组件；现在，让我们制作一个文章列表。通常，文章列表可以从一些
    API 调用中返回；例如，以 JSON 格式。我们可以使用 `useEffect` Hook 在 API 调用返回响应后发送请求并设置状态，如下所示：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The code snippet demonstrates the usage of the `useEffect` Hook in a React
    functional component. Let’s break it down:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段展示了在 React 函数组件中使用 `useEffect` Hook 的用法。让我们分解一下：
- en: '`useEffect(() => { ... }, []);`: This line declares the `useEffect` Hook and
    provides two arguments. The first argument is a callback function that contains
    the side effect code to be executed. The second argument is an array of dependencies
    that determines when the side effect should be triggered. An empty array, `[]`,
    indicates that the side effect should only run once during the initial render.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useEffect(() => { ... }, []);`：这一行声明了`useEffect`钩子，并提供了两个参数。第一个参数是一个回调函数，其中包含要执行的副作用代码。第二个参数是一个依赖项数组，它决定了何时触发副作用。一个空数组`[]`表示副作用应该只在初始渲染期间运行一次。'
- en: '`const fetchArticles = async () => { ... }`: This line declares an asynchronous
    function called `fetchArticles`. Inside this function, an API call is made to
    fetch data from the `/``api/articles` endpoint.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const fetchArticles = async () => { ... }`：这一行声明了一个名为`fetchArticles`的异步函数。在这个函数内部，对`/api/articles`端点进行了API调用以获取数据。'
- en: '`fetch("/api/articles")...`: This line uses the `fetch` function to make a
    `GET` request to the specified API endpoint. The response is then processed using
    promises (`then`) to extract the JSON data.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch("/api/articles")...`：这一行使用`fetch`函数向指定的API端点发出`GET`请求。然后使用承诺（`then`）处理响应，以提取JSON数据。'
- en: '`setArticles(data)`: This line updates the component’s state variable articles
    with the retrieved data using the `setArticles` function. This will trigger a
    re-render of the component with the updated data.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setArticles(data)`：这一行使用`setArticles`函数更新组件的状态变量`articles`，使用检索到的数据。这将触发组件使用更新后的数据重新渲染。'
- en: '`fetchArticles()`: This line invokes the `fetchArticles` function, triggering
    the API call and updating the article’s state.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetchArticles()`：这一行调用了`fetchArticles`函数，触发了API调用并更新了文章的状态。'
- en: Once we have these articles, we can then use the `array.map` collection API
    to generate a list of articles.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这些文章，我们就可以使用`array.map`集合API生成文章列表。
- en: It’s worth mentioning that when strict mode is on, in development, React runs
    setup and cleanup one extra time before the actual setup. In practice, you can
    wrap the whole application inside the `StrictMode` built-in component from React,
    and your components will re-render an extra time to find bugs caused by impure
    rendering along with other checks.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，当严格模式开启时，在开发过程中，React会在实际设置之前额外运行一次设置和清理。实际上，你可以将整个应用程序包裹在React的内置组件`StrictMode`中，这样你的组件将额外渲染一次以查找由不纯渲染引起的错误以及其他检查。
- en: Also, note that the second parameter of `useEffect` is critical. We used an
    empty array previously as we don’t want the effect to trigger each time, but there
    are cases we would like to perform the effect whenever one of the dependencies
    changes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意`useEffect`的第二个参数是关键的。我们之前使用了一个空数组，因为我们不希望每次都触发效果，但有些情况下我们希望在依赖项之一发生变化时执行效果。
- en: 'For example, let’s say we have an `ArticleDetail` component, and whenever the
    `id` prop of the article changes, we need to re-fetch the data and re-render:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个`ArticleDetail`组件，每当文章的`id`属性发生变化时，我们需要重新获取数据并重新渲染：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Inside the `useEffect` Hook, the `fetchArticleDetail` function is defined to
    handle the API call. It fetches the article details based on the provided `id`
    prop, converts the response to JSON, and updates the article state using `setArticle`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在`useEffect`钩子内部，定义了`fetchArticleDetail`函数来处理API调用。它根据提供的`id`属性获取文章详情，将响应转换为JSON，并使用`setArticle`更新文章状态。
- en: The effect is triggered when the `id` prop changes. Upon successful retrieval
    of the article data, the `Article` component is rendered with the `heading` and
    `summary` properties from the article state.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当`id`属性发生变化时，效果被触发。在成功检索到文章数据后，`Article`组件将使用文章状态中的`heading`和`summary`属性进行渲染。
- en: An essential feature of the `useEffect` Hook for handling side effects is the
    cleanup mechanism. When using `useEffect`, it’s recommended to return a cleanup
    function that React will call upon the component’s unmounting. For instance, if
    you set up a timer within `useEffect`, you should provide a function that clears
    this timer as the return value. This ensures proper resource management and prevents
    potential memory leaks in your application.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect`钩子处理副作用的一个基本特性是清理机制。当使用`useEffect`时，建议返回一个清理函数，React将在组件卸载时调用它。例如，如果你在`useEffect`中设置了一个计时器，你应该提供一个函数来清除这个计时器作为返回值。这确保了适当的资源管理，并防止了应用程序中潜在的内存泄漏。'
- en: 'For example, let’s say we have a component that needs to execute an effect
    1 second after the initial rendering, as seen here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个组件需要在初始渲染后1秒执行一个效果，如下所示：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So, within the `Timer` component, the `useEffect` Hook is used to handle a side
    effect. As the component mounts, a `setTimeout` function is set up to log the
    message `time is up` after a delay of `1000` milliseconds. The `useEffect` Hook
    then returns a cleanup function to prevent memory leaks. This cleanup function
    uses `clearTimeout` to clear the timer identified by `timerId` when the component
    unmounts.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`Timer`组件中，`useEffect` Hook被用来处理副作用。当组件挂载时，设置一个`setTimeout`函数，在延迟`1000`毫秒后记录消息`time
    is up`。然后`useEffect` Hook返回一个清理函数以防止内存泄漏。这个清理函数使用`clearTimeout`在组件卸载时清除由`timerId`标识的计时器。
- en: 'For the `ArticleDetail` example, the complete version with the cleanup function
    would be something like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`ArticleDetail`示例，带有清理函数的完整版本可能如下所示：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this code snippet, an `AbortController` component is used within a `useEffect`
    Hook to manage the lifecycle of a network request. When the component mounts,
    the `useEffect` Hook triggers, creating a new instance of `AbortController` and
    extracting its signal. This signal is passed to the `fetch` function, linking
    the request to the controller.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，使用`useEffect` Hook在组件内部使用`AbortController`组件来管理网络请求的生命周期。当组件挂载时，`useEffect`
    Hook被触发，创建一个新的`AbortController`实例并提取其信号。这个信号被传递给`fetch`函数，将请求链接到控制器。
- en: If the component unmounts before the request completes, the cleanup function
    is called, using the `abort` method of the controller to cancel the ongoing fetch
    request. This prevents potential issues such as updating the state of an unmounted
    component, ensuring better performance and avoiding memory leaks.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件在请求完成之前卸载，则会调用清理函数，使用控制器的`abort`方法取消正在进行的获取请求。这可以防止潜在的更新已卸载组件的状态等问题，确保更好的性能并避免内存泄漏。
- en: Let’s now turn our attention to another crucial Hook that enhances performance
    by preventing unnecessary function creation during re-renders.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向另一个关键的Hook，它通过防止在重新渲染期间创建不必要的函数来提高性能。
- en: useCallback
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useCallback
- en: 'The `useCallback` Hook in React is used to memoize and optimize the creation
    of callback functions. It is particularly useful when passing callbacks to child
    components or when using callbacks as dependencies in other Hooks. You can see
    it in action here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: React中的`useCallback` Hook用于记忆化和优化回调函数的创建。它在将回调传递给子组件或在其他Hooks中将回调作为依赖项时特别有用。您可以在以下操作中看到它的作用：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `useCallback` Hook takes two arguments:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`useCallback` Hook接受两个参数：'
- en: '`callback`: This is the function that you want to memoize. It can be an inline
    function or a function reference.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback`：这是您想要记忆化的函数。它可以是内联函数或函数引用。'
- en: '`dependencies`: This is an array of dependencies that the memoized callback
    depends on. If any of the dependencies change, the callback will be recreated.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dependencies`：这是一个数组，包含记忆化回调所依赖的依赖项。如果任何依赖项发生变化，回调将被重新创建。'
- en: 'Let’s explore a practical example. We require an editor component to modify
    the summary of an article. Whenever a user types a character, the summary needs
    to be updated, triggering a re-render. However, this re-rendering can result in
    the creation of a new function each time, which can impact performance. To mitigate
    this, we can utilize the `useCallback` Hook to optimize the rendering process
    and avoid unnecessary function recreations:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一个实际例子。我们需要一个编辑器组件来修改文章的摘要。每当用户输入一个字符时，摘要需要更新，触发重新渲染。然而，这种重新渲染可能会导致每次创建一个新的函数，这可能会影响性能。为了减轻这种情况，我们可以利用`useCallback`
    Hook来优化渲染过程并避免不必要的函数重新创建：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the `ArticleEditor` component, `useCallback` is used to memoize the `submitChange`
    function, which asynchronously makes a `POST` request to update an article, using
    the `fetch` API. This optimization with `useCallback` ensures that `submitChange`
    is only recreated when the `id` prop changes, enhancing performance by reducing
    unnecessary recalculations.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ArticleEditor`组件中，使用`useCallback`来记忆化`submitChange`函数，该函数异步使用`fetch` API发送`POST`请求以更新文章。这种使用`useCallback`的优化确保了只有当`id`属性改变时，`submitChange`才会被重新创建，通过减少不必要的重新计算来提高性能。
- en: 'The component then renders `ArticleForm`, passing `submitChange` as a prop
    for handling form submissions:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 组件随后渲染`ArticleForm`，将`submitChange`作为属性传递以处理表单提交：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`ArticleForm` uses the `useState` Hooks to track the summary state. When the
    form is submitted, `handleSubmit` prevents the default form action and calls `onSubmit`
    with the current summary. The `handleSummaryChange` function, optimized with `useCallback`,
    updates the summary state based on the `textarea` input. This use of `useCallback`
    ensures the function doesn’t get recreated unnecessarily on each render, improving
    performance.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArticleForm` 使用 `useState` 钩子来跟踪摘要状态。当表单提交时，`handleSubmit` 阻止默认表单操作，并使用当前摘要调用
    `onSubmit`。`handleSummaryChange` 函数通过 `useCallback` 优化，根据 `textarea` 输入更新摘要状态。这种使用
    `useCallback` 的方法确保函数在每次渲染时不会不必要地重新创建，从而提高性能。'
- en: The React Context API
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React Context API
- en: The **React Context API** is a feature that allows you to pass data directly
    through the component tree, without having to pass props down manually at every
    level. This comes in handy when your application has global data that many components
    share, or when you have to pass data through components that don’t necessarily
    need the data but have to pass it down to their children.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**React Context API** 是一个功能，允许您直接通过组件树传递数据，而无需在每一级手动传递属性。当您的应用程序具有许多组件共享的全局数据，或者当您需要通过不需要数据的组件传递数据时，这非常有用。'
- en: For example, imagine that we are creating an application that includes a dark
    or light theme, depending on the current time (for instance, if it’s daytime,
    we use light mode). We would need to set the theme at the root level.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们正在创建一个应用程序，该应用程序包括根据当前时间（例如，如果是白天，我们使用浅色模式）的深色或浅色主题。我们需要在根级别设置主题。
- en: 'So, first, we define a type `ThemeContextType` and create a context instance
    `ThemeContext` of the type:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，我们定义一个类型 `ThemeContextType` 并创建一个该类型的上下文实例 `ThemeContext`：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we create a `ThemeProvider` component, which will use a React state to
    manage the current theme:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个 `ThemeProvider` 组件，该组件将使用 React 状态来管理当前主题：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we can use the `ThemeProvider` component in our application:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在我们的应用程序中使用 `ThemeProvider` 组件：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In any component in our application, we can now access the current theme:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用程序的任何组件中，我们现在都可以访问当前主题：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this setup, `ThemeContext` provides the current theme to any components in
    the tree that are interested in it. The theme is stored in a state variable in
    the `ThemeProvider` component, which is the root component of the app.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种设置中，`ThemeContext` 将当前主题提供给任何对其感兴趣的应用程序树中的组件。主题存储在 `ThemeProvider` 组件的状态变量中，它是应用程序的根组件。
- en: 'The provided code may not offer much utility since the theme cannot be modified.
    However, by utilizing the Context API, you can define a modifier that allows children
    nodes to alter the status. This mechanism proves highly beneficial for data sharing,
    making it a valuable tool. Let’s modify the context interface a little bit:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的代码可能不会提供很多实用性，因为主题无法修改。然而，通过利用 Context API，您可以定义一个修改器，允许子节点更改状态。这种机制对于数据共享非常有用，使其成为一个有价值的工具。让我们稍微修改一下上下文接口：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We added a `toggleTheme` function in the context so that the component can modify
    the `theme` value when needed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上下文中添加了一个 `toggleTheme` 函数，以便组件在需要时可以修改 `theme` 值。
- en: 'To implement the provider, we can utilize the `useState` Hook to define an
    internal state. By exposing the setter function, the children components can utilize
    it to update the value of the theme:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现提供者，我们可以使用 `useState` 钩子来定义内部状态。通过暴露设置函数，子组件可以利用它来更新主题的值：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And then, in the calling site, it’s straightforward to use the `useContext`
    Hook to access values in the context:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在调用位置，使用 `useContext` 钩子访问上下文中的值是直接的：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, whenever we click the **Toggle** button, it will change the theme and
    trigger a re-render:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每次我们点击 **切换** 按钮时，它将更改主题并触发重新渲染：
- en: '![Figure 2.4: Using a theme context](img/B21103_02_04.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4：使用主题上下文](img/B21103_02_04.jpg)'
- en: 'Figure 2.4: Using a theme context'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4：使用主题上下文
- en: In React, the Context API allows you to create and manage global state that
    can be accessed by components throughout your application. This capability enables
    you to combine multiple context providers, each representing a different slice
    or aspect of your application’s state.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，Context API 允许您创建和管理可以在整个应用程序中访问的全局状态。这种能力使您能够组合多个上下文提供者，每个提供者代表应用程序状态的不同部分或方面。
- en: 'By using separate context providers, such as one for security, another for
    logging, and potentially others, you can organize and share related data and functionality
    efficiently. Each context provider encapsulates a specific concern, making it
    easier to manage and update related state without impacting other parts of the
    application:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用单独的上下文提供者，例如用于安全性的一个，用于日志记录的另一个，以及可能的其他提供者，您可以有效地组织和共享相关数据和功能。每个上下文提供者封装了特定的关注点，这使得管理并更新相关状态变得更加容易，而不会影响应用程序的其他部分：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This example demonstrates the usage of React’s Context API to create and combine
    multiple context providers within an application component. `InteractionContext.Provider`,
    `SecurityContext.Provider`, and `LoggingContext.Provider` are used to wrap the
    children components and provide the respective context values.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了在应用程序组件中使用 React 的 Context API 创建和组合多个上下文提供者的用法。`InteractionContext.Provider`、`SecurityContext.Provider`
    和 `LoggingContext.Provider` 用于包装子组件并提供相应的上下文值。
- en: There are several additional built-in Hooks available in React that are used
    less frequently. In the following chapters, we will introduce these Hooks as needed,
    focusing on the ones that are most relevant to the topics at hand.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: React 中还有几个其他内置的 Hooks，使用频率较低。在接下来的章节中，我们将根据需要介绍这些 Hooks，重点关注与当前主题最相关的那些。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this introductory chapter, we covered essential concepts of React and laid
    the groundwork for your React development journey. We explored the concept of
    thinking in components, emphasizing the importance of breaking down applications
    into reusable and modular pieces. By adopting this mindset, you’ll be able to
    create maintainable and scalable code bases.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本介绍性章节中，我们介绍了 React 的基本概念，并为您的 React 开发之旅奠定了基础。我们探讨了组件化思维的概念，强调了将应用程序拆分为可重用和模块化部分的重要性。通过采用这种思维方式，您将能够创建可维护和可扩展的代码库。
- en: Furthermore, we introduced you to the most commonly used Hooks in React, such
    as `useState` and `useEffect`, which empower you to manage state and handle side
    effects efficiently within functional components. These Hooks provide the flexibility
    and power to build dynamic and interactive UIs.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们向您介绍了 React 中最常用的 Hooks，如 `useState` 和 `useEffect`，这些 Hooks 使您能够在函数组件中高效地管理状态和处理副作用。这些
    Hooks 提供了灵活性和强大的功能，以构建动态和交互式的用户界面。
- en: By mastering the fundamental principles of React and familiarizing yourself
    with the concept of thinking in components, you are now well prepared to dive
    deeper into the world of React development. In the upcoming chapters, we will
    explore more advanced topics and tackle real-world challenges, enabling you to
    become a proficient React developer.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过掌握 React 的基本原理并熟悉组件化思维的概念，您现在已为深入 React 开发世界做好了充分准备。在接下来的章节中，我们将探讨更多高级主题并解决现实世界的挑战，使您能够成为一名熟练的
    React 开发者。
- en: Remember – React is a powerful tool that opens endless possibilities for creating
    modern and robust web applications. In the upcoming chapter, we will delve into
    the process of breaking down a design into smaller components and explore effective
    strategies for organizing these components. We will emphasize the importance of
    reusability and flexibility, ensuring that our components are adaptable to future
    changes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 记住——React 是一个强大的工具，它为创建现代且健壮的 Web 应用程序打开了无限可能。在接下来的章节中，我们将深入探讨将设计拆分为更小组件的过程，并探讨组织这些组件的有效策略。我们将强调重用性和灵活性，确保我们的组件能够适应未来的变化。
