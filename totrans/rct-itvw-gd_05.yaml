- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Concepts of ReactJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every web developer should have in-depth knowledge of React fundamentals, core
    concepts, Hooks, and router navigations to build a successful career in the React
    technology stack. But if you want to elevate your React skills to the next level,
    you should be able to build production-level apps by applying advanced React concepts
    such as portals, error boundaries, concurrent rendering features, profilers, and
    more. While some of these concepts were introduced a long time ago and improved
    with new features in each major release, other advanced concepts have only been
    introduced in recent releases.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will understand the advanced concepts of ReactJS so that
    you can use them in various real-time use cases. Advanced concepts such as error
    boundaries, portals, concurrent rendering, and suspense, as well as code quality
    and performance optimization-related features such as strict mode, static type
    checking, and profilers, will be discussed to cover the interview questions for
    mid-level to senior developer candidates. At the end, we will quickly explore
    some questions related to React Native that are meant for mobile environments
    such as iOS and Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring portals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding error boundaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing asynchronous actions with the Suspense API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing rendering performance using concurrent rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging React applications with the Profiler API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strict mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static type checking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React in mobile environments and its features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main objective of this chapter is to give you a clear understanding of React’s
    advanced concepts and tackle interview questions that are asked to test the advanced
    skill levels of any job aspirant.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring portals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, it is quite common to use model windows or popups on web pages to
    quickly grab the user’s attention. They help notify the user of some important
    information or ask the user to enter their input. But the implementation of these
    widgets is challenging in large apps since it involves writing complex CSS code
    and handling the DOM hierarchy. Fortunately, React provides the portals feature
    to solve these kinds of use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Portals were introduced in 2017 and were first seen in React version 16\. They
    are used to render React components outside of the DOM hierarchy. The usage of
    portals is not typical, but they are helpful in specific use cases, as you will
    see in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: What are portals? How do you create them?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React portals allow you to render children into a DOM node that exists outside
    of the parent DOM hierarchy. Even though you render a child component outside
    the parent, the parent-child relationship still exists between the components.
  prefs: []
  type: TYPE_NORMAL
- en: 'A React portal can be created by calling the `createPortal` function, which
    is imported from the `react-dom` package. This function accepts two mandatory
    arguments and one optional argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Children`: Any JSX code that can be rendered with React.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOMNode`: The DOM node where you need to render the portal’s content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Key`: A unique identifier to distinguish the portal inside the component tree.
    This is optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example of a modal window shows how a portal is created at a
    particular DOM node outside the root tree hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the portal returns a React node that can be rendered
    anywhere in the component tree. In this example, the returned node is going to
    be a modal widget. This modal has been appended to the document body and is available
    at the same level as the `root` node in the HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is common practice to name the top-level node `root` because everything inside
    it will be managed by React. Applications built with React alone usually have
    a single root node. But if you are integrating React into an existing application,
    you might have many isolated root DOM nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any React component can use the preceding portal as a child component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There is no restriction on the number of portals that can be used in a particular
    component or an application. Using portals, you can also render React components
    into non-React server markup such as static or server-rendered pages and non-React
    DOM nodes that are managed outside of React.
  prefs: []
  type: TYPE_NORMAL
- en: What are the common use cases of portals?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In applications where you can see the child components visually breaking off
    of the parent container, portals can be useful. The most common use cases are
    listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modal windows or dialogue components**: Portals can be used to create large
    dialogues or modal windows that float over the rest of the web page without you
    having to worry about the parent component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`overflow:hidden` or `z-index` styling, then tooltips created inside the portal
    won’t be cut off from their parent container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loaders**: When a background task such as fetching data from a database is
    in progress, it is sensible to show a loading screen on the modern web. This helps
    block the user from interacting with the application until the background task
    has been completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Popovers**: Popovers are useful for quickly providing context information
    to the user. For example, profile cards can be used to display user profile information
    without the need to click and visit the profile itself. You can just read the
    details by hovering over the icon or button elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cookie alerts**: It is possible to create cookie alerts (or banners) so that
    visitors can choose what cookies are allowed to track while they’re visiting the
    website.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Drop-down menus**: If the drop-down menus are displayed inside a parent component
    that has hidden overflow styling, it can be created as a portal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: By moving the child components outside the main component tree, the rendering
    performance will be optimized as the components aren’t re-rendering for each state
    update. Moreover, it provides the flexibility of abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: How does event bubbling work inside portals?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though a portal exists somewhere in the DOM tree, the portal retains its
    position in the React component tree by supporting all component features, such
    as accessing props, state, context, and event propagation. This means event bubbling
    also works with portals.
  prefs: []
  type: TYPE_NORMAL
- en: 'The behavior of event bubbling in portals is similar to how a React child component
    fires events inside the component tree. The events that are fired from a portal
    will propagate upwards to ancestors in the containing React tree, even though
    those elements are not ancestors in the DOM tree. For example, in the following
    HTML code, the parent component under the main root (`#main-root`) can catch an
    uncaught bubbling event from a sibling node (`#dialog-root`) that’s been implemented
    using portals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Event bubbling in portals follows the React tree but not the DOM tree.
  prefs: []
  type: TYPE_NORMAL
- en: What accessibility precautions are taken care of in portals?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to ensure that React applications built with portals are accessible,
    even for people with disabilities. For example, keyboard focus should work naturally
    when you move the focus between the modal window and the parent web page. The
    modal dialogues that are created as part of portals should follow the WAI-ARIA
    modal authoring practices ([https://www.w3.org/WAI/ARIA/apg/patterns/dialog-modal/](https://www.w3.org/WAI/ARIA/apg/patterns/dialog-modal/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the guidelines for achieving keyboard accessibility are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When the dialog or modal is open, the focus moves to an element inside the dialog.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tabbing the focusable elements should only cycle through the dialog elements.
    The focus should not skip the dialog that has been opened.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After pressing the *Esc* key, the dialog should close.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are going to use a third-party library to create the modals, you need
    to make sure that the package follows the required accessibility guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: You will always encounter unexpected errors while building applications. These
    errors can occur in several ways, such as via network requests, invoking third-party
    APIs, accessing nested object properties that don’t exist, and so on. Error boundaries
    are mainly used in React applications to handle these kinds of errors.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding error boundaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In React applications, you can handle errors in two possible ways. The first
    approach is using a `try..catch` block to handle the errors in an imperative code
    block, similar to regular event handlers. The second approach is to use **error
    boundaries**. These are used to deal with declarative component code that will
    render on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The React team introduced error boundaries as part of React version 16\. No
    official component has been created for error boundaries in the React library,
    so you need to create the error boundary component on your own.
  prefs: []
  type: TYPE_NORMAL
- en: What are error boundaries?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Error boundaries are just React components with a certain list of tasks. They
    are used to catch JavaScript errors that can occur in their child component tree,
    log those specific errors, and redirect the screen to the fallback UI to recover
    from the error state. This component helps prevent the entire component tree from
    crashing just because of an error that happened somewhere in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Error boundaries catch errors during rendering, in life cycle methods, and
    in the constructors of the entire component tree below them. An error boundary
    can be created with a class component by defining either or both of the following
    life cycle methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`static getDerivedStateFromError`: This method is used to render a fallback
    UI after an error has been thrown'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentDidCatch`: This method is used to log error information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An error boundary can be created using these two methods to protect the application
    from crashing. This is how it is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `getDerivedStateFromError` method will be invoked if an error occurs in
    the rendering phase of any life cycle method. In this method, you can update the
    error state flag variable’s value to reflect the fallback UI in the next render.
    Based on the error state variable, the `render` method will update the UI on the
    screen. At the same time, the same error can be reported to the logging service
    for debugging purposes using the `componentDidCatch` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the error boundary has been created, it can be used as a regular React
    component. The error boundary component needs to be wrapped around the top-level
    React component where you suspect any kind of possible bugs. The usage of the
    component looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding error boundary catches any error thrown within the `MyComponent`
    component tree and prevents the application from crashing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can also wrap error boundaries for individual components with a different
    set of error messages to prevent them from breaking other parts of the page. The
    decision of error boundary design depends on the business requirements and UX
    design.
  prefs: []
  type: TYPE_NORMAL
- en: If the enclosed error boundary failed to catch the error, the error will propagate
    to the next closest error boundary around it. This behavior is similar to a `catch()`
    block, which propagates an error to the next nearest catch block.
  prefs: []
  type: TYPE_NORMAL
- en: Popular testing frameworks such as Jest can be used to write unit tests for
    error boundaries similar to any other React component. The unit test should simulate
    the error in the React component (to which the error boundary is wrapped) and
    verify that the error boundary can catch errors and renders the fallback UI properly
    or not. It is also possible to verify the error boundary using React DevTools
    by forcing the selected component into an error (red button) state.
  prefs: []
  type: TYPE_NORMAL
- en: Is it possible to create an error boundary as a function component?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the time of writing, it is not possible to create an error boundary as a
    function component using the latest React version – that is, you can only create
    an error boundary using a class component. Moreover, you can avoid writing an
    error boundary class altogether by reusing the `react-error-boundary` ([https://github.com/bvaughn/react-error-boundary](https://github.com/bvaughn/react-error-boundary))
    package from the community.
  prefs: []
  type: TYPE_NORMAL
- en: When do error boundaries not work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Error boundaries do not catch errors in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onClick`, `onChange`, and others) aren’t used during the rendering phase,
    error boundaries won’t be required to recover the UI from errors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setTimeout`, `requestAnimationFrame`, and others'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server-side rendering**: React doesn’t support error boundaries on a server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When there’s an error inside the error boundary**: React cannot catch errors
    thrown in the error boundary itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may need to opt for a regular JavaScript `try..catch` statement or `promise#catch()`
    block to handle errors for the aforementioned cases except for the last one, where
    you need to make sure no errors occur in the error boundary.
  prefs: []
  type: TYPE_NORMAL
- en: Just like error boundaries are used to display a fallback UI for any error caught
    in the application, the Suspense API is used to display a fallback UI until its
    children have finished loading.
  prefs: []
  type: TYPE_NORMAL
- en: Managing asynchronous actions with the Suspense API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Suspense feature was introduced in React version 16, alongside error boundaries.
    Initially, it was only meant to be used with the `lazy` API for code splitting
    and could not be used for server-side rendering. React18 improved the Suspense
    API so that it can support many use cases, including server-side rendering and
    asynchronous operations such as data fetching.
  prefs: []
  type: TYPE_NORMAL
- en: What is the Suspense API? How do you use it?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Suspense API is used to display a fallback UI such as a loading indicator
    until its children are ready to render. The suspense component accepts a `fallback`
    prop to render an alternative UI if its children have not finished rendering.
    You can wrap your application with a suspense component either at the top level
    or individual sections of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s learn how to use the Suspense feature by looking at the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a simple use case of loading blog posts from a specific author. Here,
    the blog posts component (that is, `<Posts/>)` suspends while fetching the list
    of posts. Before the content is ready to be displayed, React switches to the closest
    suspense boundary to display the fallback loading indicator (that is, `<Loading
    />`) in place of displaying the list of posts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Once the blog post data has been fetched, React switches back to displaying
    the actual blog post data.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also defer updating the list and display state content until the new
    results are ready. This alternative UI pattern is possible by passing a query
    to the `useDeferredValue` Hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In traditional applications, you need to use the `isLoading` data flag variable
    to indicate whether data fetching has finished or not and display the respective
    content on the screen. However, if you use the Suspense feature, React automatically
    determines whether to display the fallback UI or component data, without depending
    on any additional flag.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Only suspense-enabled frameworks have integrations with the Suspense feature
    to communicate loading states to React.
  prefs: []
  type: TYPE_NORMAL
- en: Can I use the suspense component for any kind of data fetching?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The suspense component cannot detect data fetching inside an effect or event
    handler. It can only be used for the following suspense-enabled data sources:'
  prefs: []
  type: TYPE_NORMAL
- en: Data fetching with suspense-enabled opinionated frameworks such as Relay, Next.js,
    Remix, and Hydrogen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy-loading component code with the `lazy` API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Suspense feature without a framework is not supported at the time
    of writing. However, there is a plan from the React team to provide an official
    API to integrate data sources with the suspense component in future versions.
  prefs: []
  type: TYPE_NORMAL
- en: How do you prevent unnecessary fallbacks during an update?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the visible UI is replaced with a fallback, there will be a flashing user
    experience. This is not a good UX experience. This situation happens when a state
    update causes a component to suspend, but the nearest suspense boundary is already
    showing some fallback content to the user. You can avoid these unnecessary fallbacks
    by marking the state updates as non-urgent using the `startTransition` API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an example of navigating pages in an application and applying a transition
    for the page update to prevent unnecessary fallbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: During the transition, React will wait for the content to be loaded without
    retriggering the suspense fallback UI to hide the already revealed content.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: React only prevents unnecessary fallbacks for non-urgent updates. It will not
    delay the render for any urgent updates.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, React was only able to handle one task at a time and the render
    process was synchronous. Once the task had been started, it could not be interrupted.
    This is called blocking rendering. Later, this issue was fixed by introducing
    concurrent mode, which can interrupt the task if there is another urgent task.
    Concurrent mode was introduced as an experimental feature and replaced by the
    concurrent rendering feature in React version 18.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing rendering performance using concurrent rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React 18 introduced the concurrent renderer, which makes the rendering process
    asynchronous and ensures it can be interrupted, paused, resumed, and even abandoned.
    As a result, React can respond to user interactions quickly, even if it is in
    the middle of a heavy rendering task.
  prefs: []
  type: TYPE_NORMAL
- en: New features such as suspense, streaming server rendering, and transitions are
    powered by concurrent rendering.
  prefs: []
  type: TYPE_NORMAL
- en: How do you enable concurrent rendering in React?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, you need to update both the `react` and `react-dom` packages to version
    18\. After that, you need to replace the deprecated `ReactDOM.render` method with
    the `ReactDOM.createRoot` method. Concurrent rendering will be enabled automatically
    in whichever parts of your application you use concurrent features such as suspense,
    streaming server rendering, and transitions.
  prefs: []
  type: TYPE_NORMAL
- en: As the application becomes complex, you need to spend a significant amount of
    time analyzing the application’s performance. It is especially crucial to measure
    the application performance’s characteristics before delivering it to customers.
    Even though you can use the browser’s User Timing API (Web API) to measure the
    rendering cost of your components, there are better alternatives that have been
    created by the React team. The Profiler API, for example, helps identify performance
    bottlenecks in React applications.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging React applications with the Profiler API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are benchmarking a React application’s performance, then tracking how
    many times your components are re-rendered and the cost of each re-rendering will
    help you identify the defecting areas or parts in the application. React provides
    two different ways to measure the application’s rendering performance: the **React
    Profiler API** and the **React DevTools** profiler tab. The React Profiler API
    is recommended considering that it supports the Suspense feature.'
  prefs: []
  type: TYPE_NORMAL
- en: How do you measure rendering performance?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'React provides the Profiler API to measure the rendering performance of a component
    tree programmatically. The component has two props: the `id` prop, which is used
    to identify the part of the UI being measured, and the `onRender` callback, which
    is called every time the tree updates.'
  prefs: []
  type: TYPE_NORMAL
- en: The callback receives arguments such as `id`, `phase`, `actualDuration`, `baseDuration`,
    `startTime`, and `commitTime`, which are used to log the rendering time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you are suspicious of the rendering performance of an author biography
    component that exists inside an online bookstore application, and you would like
    to profile the component. In this case, the `AuthorBio` component needs to be
    wrapped with the `Profiler` component, along with the `onRender` callback. This
    will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can also use multiple `Profiler` components to measure the different parts
    of your application.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript provided strict mode as a new feature in ECMAScript5 to enforce the
    restricted version of JavaScript. This feature brings stricter rules when you
    write code and throws errors if you violate them. Strict mode can be enabled by
    adding a `use strict` line at the top of your file. Similarly, React provides
    the `StrictMode` component as a development-only tool, which is used to enforce
    stricter warnings and checks while writing React code.
  prefs: []
  type: TYPE_NORMAL
- en: Strict mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The React team introduced strict mode as a debugging tool to identify potential
    bugs or issues in a web application. This tool is available as the `StrictMode`
    component in the React API. It doesn’t render any UI that is similar to the `Fragment`
    component. This feature is only applicable to development mode – it won’t impact
    behavior in production. This section focuses on the important strict mode concepts
    and questions that might be asked in the interview.
  prefs: []
  type: TYPE_NORMAL
- en: How do you enable strict mode?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can enable strict mode for an entire app by wrapping it around the root
    component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also only use strict mode in certain parts of the application (that
    is, not the entire application) where you think there is a high possibility of
    bugs. Consider strict mode for the main body of the page of an application. It
    should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Most of the time, React developers face issues with improper logic in the rendering
    section, as well as issues with missing cleanup code inside effects Hooks. These
    types of bugs can easily be identified with strict mode.
  prefs: []
  type: TYPE_NORMAL
- en: Can you describe the list of development-only checks enabled by strict mode?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Strict mode enables the following list of development-only checks to find commonly
    occurring bugs during early development:'
  prefs: []
  type: TYPE_NORMAL
- en: Components will re-render one more time to find the bugs that were caused by
    impure rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components will rerun effects one more time to find the bugs that were caused
    by missing cleanup for the effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components will be verified for the usage of deprecated APIs and will notify
    the users with warnings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These checks are applicable for development purposes only. They won’t have any
    impact on the production builds.
  prefs: []
  type: TYPE_NORMAL
- en: What functions are called twice in the double rendering process of strict mode?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Strict mode calls the following list of functions twice in development mode:'
  prefs: []
  type: TYPE_NORMAL
- en: The function’s component body, excluding code inside event handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The functions that are passed to Hook, such as `useState`, `useReducer`, and
    `useMemo`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State updater functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class component methods such as `constructor`, `render`, `shouldComponentUpdate`,
    and `getDerivedStateFromProps`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your function is impure, running it twice in development mode will impact
    the expected output. This result helps you identify any bugs in your code as early
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from strict mode, you can also use static type checking in React applications
    to avoid bugs and errors that appear at runtime. As your application grows, you
    can catch many bugs using type checking.
  prefs: []
  type: TYPE_NORMAL
- en: Static type checking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React is based on JavaScript and JavaScript is a loosely typed language. So,
    we don’t get the default static type-checking feature in React.
  prefs: []
  type: TYPE_NORMAL
- en: In its older versions (<15.5), React had `PropTypes` validators so that it could
    perform simple type checking in applications. Post that, this library was moved
    out from React’s core module and created as a separate library, `prop-types` ([https://www.npmjs.com/package/prop-types](https://www.npmjs.com/package/prop-types)).
    Nowadays, `PropTypes` are not commonly used in modern React applications. Even
    though static type checking is not mandatory in React, you might encounter some
    questions related to static type checking in the interview.
  prefs: []
  type: TYPE_NORMAL
- en: What are the benefits of static type checking?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many benefits of static type checking in JavaScript applications.
    Some of these are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Can identify type errors before runtime (that is, errors at compile time)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can detect bugs and errors in the early stages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimized and easy to read
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better IDE support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can generate documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is cheaper to fix bugs if you identify them as early as possible.
  prefs: []
  type: TYPE_NORMAL
- en: How do you implement static type checking in React applications?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In React, there are multiple ways to implement static type checking, but the
    following two ways are the best:'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two static type checkers help identify certain types of errors, even before
    you run your code. Since TypeScript is robust and has the most community support,
    let’s see how it can be implemented in React.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript was created by Microsoft and is considered a typed superset of JavaScript.
    It comes with its own compiler and can catch errors and bugs at build time. It
    supports JSX and can use React hooks without any problems. Nowadays, TypeScript
    can be supported by major frameworks just by appending various options, as listed
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next.js:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remix:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Gatsby:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expo:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are not using any of these frameworks, you need to follow the following
    manual steps to set up TypeScript in React applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm` or the `yarn` package manager:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`tsconfig.json` by generating the file using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The frequently used options are the source directory for TypeScript files and
    generated JavaScript files for the output folder. The configuration looks like
    this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can add more configuration options, as described here: [https://www.typescriptlang.org/docs/handbook/tsconfig-json.html](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html).
    TypeScript’s React starter provides this configuration file with a good set of
    rules.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.ts` extension or the `.tsx` extension for files that contain JSX code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DefinitelyTyped` ([https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped))
    repository or creating a local declaration file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you can build your TypeScript project with the `tsc` command, which is
    available through the TypeScript package.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, React was mainly used for web development. Nowadays, it can be used
    for mobile, desktop, and VR apps too. React Native is a separate library that
    was created to support mobile devices. It is based on the same concepts as React
    but uses native components instead of web components to render on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: React in mobile environments and its features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Facebook initially chose to make its services available on mobile devices,
    it decided to run mobile pages based on HTML5 instead of building native apps,
    which was preferred by many tech giants at that time. However, it ended up with
    UX and performance overhead issues.
  prefs: []
  type: TYPE_NORMAL
- en: In 2013, the Facebook team found a method of generating UI elements for iOS
    apps by using JavaScript. This idea was successful for mobile applications and
    later, React Native was supported for Android devices too.
  prefs: []
  type: TYPE_NORMAL
- en: This section will focus on React Native, so that we can go beyond ReactJS concepts
    and cover important topics related to architecture, navigation, and its differences
    from ReactJS, which might be expected in React interviews.
  prefs: []
  type: TYPE_NORMAL
- en: What is React Native?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React Native is a popular JavaScript-based mobile app framework for building
    natively rendered mobile applications for iOS, Android, and Windows. The main
    advantage of this library is that you can use one code base that runs on multiple
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: The Facebook team open sourced React Native in 2015\. After only a few years,
    this library became one of the top solutions for mobile development and is now
    used in popular mobile apps such as Facebook, Instagram, Skype, Uber, and others.
  prefs: []
  type: TYPE_NORMAL
- en: What are the differences between React and React Native?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'React Native is based on the React library and they share many concepts. But
    there are a few major differences, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **React** | **React Native** |'
  prefs: []
  type: TYPE_TB
- en: '| It is used to develop web applications | It is used to develop mobile applications
    |'
  prefs: []
  type: TYPE_TB
- en: '| It uses the `react-router` library to navigate pages | It uses an in-built
    navigator library to navigate pages |'
  prefs: []
  type: TYPE_TB
- en: '| A virtual DOM is used to render the web pages | A native API is used to render
    the pages |'
  prefs: []
  type: TYPE_TB
- en: '| React uses HTML, CSS, and JavaScript to create a user interface | React Native
    uses native components and APIs to build apps |'
  prefs: []
  type: TYPE_TB
- en: '| It uses JavaScript and CSS libraries for animation | It comes with built-in
    animation libraries |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.1: React versus React Native'
  prefs: []
  type: TYPE_NORMAL
- en: So, React Native is an additional library built on top of React library to create
    native apps and this native library has its own architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Can you describe the React Native architecture based on the threading model?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fabric is the new rendering architecture that was created by the Facebook team
    and even their app is backed by this renderer. The core principles of this architecture
    are unifying the renderer logic in C++ and optimizing the interoperability between
    host platforms. It is based on the threading model, similar to the old architecture,
    but it functions differently to optimize the user experience better than native
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: In the old architecture, React Native bridge was used to communicate between
    JavaScript and native modules. But it has its limitations – for example, communication
    can only happen through asynchronous operations and it is required to serialize
    or deserialize the data as JSON. This bridge component was replaced with **JavaScript
    Interface** (**JSI**) in the new architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at how the various components communicate in the new rendering
    architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Fabric rendering architecture](img/Figure_05.01_B18603.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Fabric rendering architecture'
  prefs: []
  type: TYPE_NORMAL
- en: 'Three parallel threads run in every React app, irrespective of whether the
    old or new renderer is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UI thread or main thread**: This thread is responsible for handling iOS and
    Android host views. It handles some native interactions, such as tapping on a
    button, user gesture events, scrolling, and others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JS thread**: This thread is responsible for handling all the logic of your
    React Native application. It takes care of all the DOM hierarchy operations written
    in the code and executes them. After that, the code is sent to the native module
    thread for optimizations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shadow or background thread**: This thread is responsible for layout calculations
    such as positions and the height and width of elements and then transforming them
    into native elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the old architecture, the bridge component was used to communicate between
    the JS thread and the UI thread asynchronously by serializing and deserializing
    the data. As a result, memory management and application performance became overloaded.
    In the new architecture, the bridge component has been replaced with JSI for efficient
    communication between native and JavaScript code. JSI is a lightweight layer where
    methods written in C++ can be used by the JavaScript engine, such as **JavaScript
    Core** (**JSC**) or Hermes, to directly invoke or call methods in the native code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The workflow of the new architecture is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks an app icon of a mobile application, the Fabric rendering
    system directly loads the native side instead of opening native modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rendering system notifies the JS thread once it is ready. After that, the
    JS thread loads the final bundle, named `main.bundle.js`, which consists of JavaScript
    code, React logic, and its components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The JS code is invoked through the ref native function, which has been exposed
    as an object using the JSI API to Fabric.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The yoga engine inside the shadow thread performs layout calculations, converting
    from the Flexbox-based style into the host layout, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the components are rendered on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Additionally, two new components have been added to the new architecture: `Turbo
    module` and `CodeGen`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Turbo module` is an improved version of the native module (it exists in the
    old architecture) that communicates between JavaScript and platform-native code
    by lazily loading the modules to improve the startup performance. The `CodeGen`
    static type checker helps communicate dynamic JavaScript code and JSI code written
    as statically typed C++.'
  prefs: []
  type: TYPE_NORMAL
- en: How do you perform navigations in React Native?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React Native uses the `react-navigation` library to navigate between pages in
    native applications. The transition between multiple screens is managed by various
    kinds of navigators, such as stack navigators, drawer navigators, and tab navigators.
    While navigating between multiple screens, you can also pass data between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'React Navigation is made up of core utilities that are used by navigators to
    create the navigation structure in your app. The package can be installed using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Each navigator in React Navigation lives in its own library. For example, if
    you want to use the `native-stack` navigator, it should be installed separately
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The stack navigator provides a way for your app to transition between screens
    and manage navigation history. This behavior is similar to how a web browser handles
    navigation history. It also provides gestures and animations that you might expect
    in Android and iOS devices while navigating the pages within the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of an organization’s website navigation menu items that
    have been created based on the stack navigator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created a stacked navigation menu to redirect users
    to important screens of the website, such as the home and services pages.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you can nest navigators using the Navigation API.
  prefs: []
  type: TYPE_NORMAL
- en: What are the benefits of the new architecture?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The new architecture of React Native brings several benefits in terms of user
    experience, code quality, performance, and extensibility. We have compiled a few
    of them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Better interoperability**: In the old architecture, there was a layout jump
    issue when you try to embed a React view into the host view. This was because
    the React Native layout was asynchronous. The new renderer provides improved interoperability
    by rendering React pages synchronously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better data fetching behavior**: The data fetching user experience has been
    improved with the integration of React’s Suspense feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type safety**: Code generation ensures type safety between the JS and platform
    layers. It uses JavaScript component declarations to generate C++ structs to hold
    the props. The code generated from the JS specification must be typed through
    Flow or TypeScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Synchronous execution**: This improves the user experience. Now, it is possible
    to execute the functions synchronously rather than asynchronously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency**: JavaScript can invoke functions that are executed on different
    threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shared C++ code**: The new renderer is implemented in C++. As a result, it
    is possible to write platform-agnostic code and share it between platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved performance**: In the new rendering architecture, all the limitations
    of a particular platform can be identified, and solutions have been provided for
    working with both iOS and Android. Initially, the view flattening solution was
    only available on Android, but it is now available by default for both platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Faster startup**: Since the host components are lazily initialized by default,
    there will be a faster startup time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: The component’s behavior is consistent across platforms because
    the new render system is cross-platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Less overhead**: You don’t need to perform serialization or deserialization
    between JavaScript and the UI layer anymore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot achieve these benefits with the old architecture.
  prefs: []
  type: TYPE_NORMAL
- en: What is view flattening?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The declarative and composition characteristics of the React API allow you to
    create deep React Element Trees, where most of the nodes only affect the layout
    of a screen instead of rendering on the screen. These nodes are called **layout-only**
    nodes. Large amounts of layout-only nodes lead to poor performance during rendering.
  prefs: []
  type: TYPE_NORMAL
- en: The renderer implements the view flattening algorithm to improve performance.
    View flattening is an optimization algorithm that’s used by the React Native renderer
    to avoid deep layout trees. This mechanism merges or flattens these types of layout-only
    nodes and reduces the depth of the host view hierarchy displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process can be explained with `MyLogoComponent`, which contains view container
    components with margin and padding styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, two host views (that is, `<View style={..}>`) have been
    added between the container and the actual content of the component to apply structural
    styling for the inner content.
  prefs: []
  type: TYPE_NORMAL
- en: The view flattening algorithm is integrated as a part of the **diffing** stage
    of the renderer and merges the styling of the second and third views into the
    first view. This way, it avoids the need to create and render two extra host views.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how the native screen appeared without deep layout
    trees using this mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: Native screen with merged views](img/Figure_05.02_B18603.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Native screen with merged views'
  prefs: []
  type: TYPE_NORMAL
- en: There won’t be any visible changes after this view flattening algorithm has
    been applied.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered some of the important fundamental concepts of React
    Native that you might encounter in React job interviews. You might be asked about
    these to test your knowledge of the React technology stack. This section also
    brings you to the end of this chapter, where we covered a wide range of advanced
    topics in the React ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered a list of advanced concepts that you might encounter in
    a ReactJS interview. We began by covering new features such as portals, which
    handle modal windows, error boundaries, which prevent the app from crashing due
    to errors, and the Suspense feature, which displays an alternative UI for heavily
    time-consuming background tasks. After that, we covered topics related to concurrent
    rendering, which supports features that improve the rendering performance, followed
    by the Profiler API, which can be used to detect the rendering cost of specific
    parts of an application.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we discussed development-only features such as strict mode and static
    types, which help us avoid any possible bugs and errors encountered in the code.
    Finally, we introduced React in mobile environments and React Native and its differences
    with ReactJS, as well as its internals and rendering architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we have helped you learn advanced concepts, their significance,
    and their best practices in React development. As a result, this book will improve
    your React skill set so that you become an expert and stand out in the competitive
    job market.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will understand popular state management solutions in
    React. We will start by looking at Flux patterns and the Redux architecture so
    that you understand the foundation of Redux. After that, we will cover important
    topics such as core principles, various components, handling asynchronous requests,
    middleware, and debugging Redux applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Going Beyond React and Advanced Topics'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will learn about the popular React.js state library Redux
    and why having a global state store in our projects can be extremely beneficial,
    compared to using a local state. We will also take a look at the numerous ways
    to use CSS within a React.js application and how each method has its pros and
    cons.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will be testing and debugging as we learn of the different ways we
    can use testing to make our code more reliable. Finally, we will learn about the
    React.js libraries Next.js, Gatsby, and Remix, seeing how they can help us to
    build React.js applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18603_06.xhtml#_idTextAnchor209), *Redux: The Best State Management
    Solution*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18603_07.xhtml#_idTextAnchor239), *Different Approaches to Apply
    CSS in React.js*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18603_08.xhtml#_idTextAnchor257), *Testing and Debugging the
    React Application*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18603_09.xhtml#_idTextAnchor276), *Rapid Development with the
    Next.js, Gatsby, and Remix Frameworks*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
