<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Keep Your App Healthy with Tests and Jest</h1>
                </header>
            
            <article>
                
<p class="mce-root">An important part of any application developer's life is making sure that their application runs properly the first time, every time. That can be a difficult thing to do as applications get more complicated; what might have previously required just a few minutes and a single line of code to clean up or fix might instead start taking hours, days, or even weeks (or longer) to try to fix! In addition, if you're trying to build up your application and make it work cleanly and effectively.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>The history of testing React applications</li>
<li>Different ways to run React tests</li>
<li>A brief introduction to Jest</li>
<li>A brief introduction to the test watcher</li>
<li>How to write tests</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The why and when of testing</h1>
                </header>
            
            <article>
                
<p>You might be wondering why we've started tackling our tests so late in our application. Generally speaking, when you're just starting out in your projects, you might wait a little bit to see how your application shakes out before you start verifying its behavior with tests. That being said, we're now also at a really good point to start shoring up our project and make it something that we can deploy to production with confidence!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The history of testing React</h1>
                </header>
            
            <article>
                
<p>Again, it's great to understand the history of the toolset to understand why certain features or libraries are being used. When people were just getting started with React, ideas and standards around testing were absolutely all over the place. Some people used weird combinations of libraries that had all sorts of names, such as night-something, mocha, or some other random framework. You had to figure out mocking libraries, test harnesses, and user interface test frameworks.</p>
<p>It was absolutely <em>exhausting</em>, and inevitably any framework and setup you were using would either fall out of favor or fall out of date and you'd have to turn around and start learning a new one every few weeks! Even worse, if you asked a ton of different people what their particular test setup was, you'd get at least that many different answers!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">About Jest</h1>
                </header>
            
            <article>
                
<p>Jest was the React team's answer to the constant question of <em>what test harness should we use for our React application?</em> You'd always get a different answer depending on who you asked, and sometimes you'd have to use multiple harnesses just to get features you wanted, which led to a ton of bloat and developer confusion about which one was the correct one to use at any given time!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Analyzing the structure of Jest tests</h1>
                </header>
            
            <article>
                
<p class="mce-root">The best place for us to get started is to take a look at the default standard test that comes with any new Create React App project, and that is the test for our <kbd>App</kbd> component, located at <kbd>src/App.test.js</kbd>:</p>
<pre class="mce-root">import React from 'react';<br/>import ReactDOM from 'react-dom';<br/>import App from './App';<br/><br/>it('renders without crashing', () =&gt; {<br/>  const div = document.createElement('div');<br/>  ReactDOM.render(&lt;App /&gt;, div);<br/>  ReactDOM.unmountComponentAtNode(div);<br/>});</pre>
<p>Well, this isn't a particularly <em>exciting</em> test by any stretch of the imagination. As the name implies, this test just verifies that the <kbd>App</kbd> component can be rendered on the page without any major hiccups or errors. This test might seem kind of superfluous, but it actually serves an incredibly important purpose: it remains as a sanity check for your application!</p>
<p>Think about it: if your main application or component couldn't render without any other more complicated checks, then your project is very, very broken! It helps us check whether we're accidentally excluding things or introducing significantly breaking changes to our project in a way that keeps us all sane! Let's also verify that this actually does work the way we expect even with our changes right now:</p>
<pre><strong>$ yarn test</strong></pre>
<p>When we run this, we should expect to see some output in our console window that tells us a little more about what tests were run, what tests passed, what failed, and other metadata about our test run as well:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-292 image-border" src="Images/f2b2fb64-8cba-44a9-8349-019c80868546.png" style="width:29.25em;height:15.00em;" width="390" height="201"/></p>
<p>Just like that, clean and working tests! Now, that by itself is really cool, but let's take a few minutes to analyze the previous output window!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Exploring the test output</h1>
                </header>
            
            <article>
                
<p>Right now, if we just look at the previous output without any context, it may not make a ton of sense! Let's start off by taking a look at the first line after the test, which talks about our <span class="packt_screen">Test Suites</span>:</p>
<pre><strong>Test Suites: 1 passed, 1 total</strong></pre>
<p class="mce-root">Jest allows us to run and organize our tests in a number of different and helpful ways! For example, our tests can be run by suites; suites being larger groupings of tests. We'll explore this line of output a little further later on when we have more than a single test, but right now we only have one test suite, and thus we've only run a single test suite:</p>
<pre><strong>Tests: 1 passed, 1 total</strong></pre>
<p>We ran a single test, and that single test passed! This allows us to also keep track of what tests were run as our application code changed; we may not need to run every single test in every single suite across the board when we make minor changes! Instead, we can focus on the tests that would be affected by whatever the change was, so you may see this as being less than the total number of tests in your suites:</p>
<pre><strong>Snapshots: 0 total</strong></pre>
<p>Snapshots are a different feature entirely with Jest. Snapshots are a way to tell Jest that <em>given input X, the rendered component should look exactly like this</em>. We'll explore this in greater detail later! The following line indicates how long our tests took to run:</p>
<pre><strong>Time: 3.986s</strong></pre>
<p>This is important to note, as sometimes you might introduce some code to your application that makes your application incredibly slow! This can help you catch those sneaky performance-ruining bits of code in your application. Your tests will essentially be your early-warning system against poorly-performing algorithms! We will get the following output:</p>
<pre><strong>Ran all test suites.</strong><br/><strong>Watch Usage: Press w to show more.</strong></pre>
<p>Finally, we get some output that tells us a little bit about what tests ran and what else we can do. We can also hit <em>w</em> here to get more options about what we can do with our test runner and watcher:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-293 image-border" src="Images/92a3d97a-e583-4719-9168-686a13069455.png" style="width:28.33em;height:11.25em;" width="407" height="162"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A development test workflow with the F key</h1>
                </header>
            
            <article>
                
<p>When we hit <em>w</em>, we get a new list of commands that we can run to continue with our test suite and do more for it. We've already explored these options a little bit, but it's worth reiterating the work that we can (and should) do during development and talk a little bit about <em>when</em> to use these tests as well!</p>
<p>The first major one is the following:</p>
<pre><strong>Press f to run only failed tests</strong></pre>
<p>We'll use this one <em>a lot</em>. Often when you're developing complex applications you might introduce changes that break your test suite, or you might be going with more of a test-driven development approach, in which case you'll be working with broken tests and then fixing things in your application or in your tests until the tests pass again! If that's the case, you'll be using this command a lot, so get comfortable with it early! If we try to run this now without any failed tests, we'll get the following output:</p>
<pre><strong>No failed test found.</strong><br/><strong>Press `f` to quit "only failed tests" mode.</strong><br/><br/><strong>Watch Usage: Press w to show more.</strong></pre>
<p>This makes sense. We had no failed tests, so of course it wouldn't find any and thus wouldn't run any tests. We can make this work for us, though, by introducing a failing test intentionally and then running our full test suite, followed by just the failed tests! We can simulate this very quickly by returning back to <kbd>src/App.js</kbd> and commenting out the <kbd>export</kbd> statement at the bottom of the code:</p>
<pre>// export default App;</pre>
<p>Now if you restart your tests, you will get one failing test! We should be able to hit <em>F</em> and it will rerun the single failing test (and we can repeat this process over and over, as well). Now if we uncomment that line and save the file, if we rerun our test suite (either automatically or manually using <em>F</em>), we should be back to a fully-working test suite!</p>
<p><span>There's another reason to get comfortable with rerunning failed tests: you should get comfortable with the idea of writing tests that intentionally fail until you make the test pass, or passes unless you comment or intentionally break the code! If you make code changes that should break your tests but the test still passes, that means your tests aren't actually testing the behavior of your application correctly!</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">It's time to add some new tests!</h1>
                </header>
            
            <article>
                
<p>We have a pretty good understanding of our initial test, but there's so much more we can learn by writing new tests! We'll start off by testing the absolute simplest component that we've written so far: our <kbd>Todo</kbd> component! You'll notice a pattern with how we have to name our tests to have Jest pick them up appropriately: we'll create a test for our <kbd>Todo</kbd> component (in <kbd>src/Todo.js</kbd>) as <kbd>src/Todo.test.js</kbd>! We'll almost always want to start off our tests by mimicking the structure in <kbd>App.test.js</kbd>, so we'll start off by doing almost the same things:</p>
<pre>import React from "react";<br/>import ReactDOM from "react-dom";<br/>import Todo from "./Todo";<br/><br/>it("renders without crashing", () =&gt; {<br/> const div = document.createElement("div");<br/> ReactDOM.render(&lt;Todo /&gt;, div);<br/> ReactDOM.unmountComponentAtNode(div);<br/>});</pre>
<p>After rerunning our <span class="packt_screen">Test Suite</span> (you may have to exit out of the test watcher with <em>Q</em> and rerun <kbd>yarn test</kbd>), you should get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-294 image-border" src="Images/3bf82bda-648b-4260-8270-fdb8e35861e5.png" style="width:37.67em;height:24.42em;" width="501" height="325"/></p>
<p>So it ran our <kbd>src/Todo.test.js</kbd> test that we just added, and it's a new test suite as well! Let's expand out our tests since right now they're not really doing anything. To do that, however, we'll need to add a few more libraries to our test suite! We'll want to add <kbd>enzyme</kbd> (for shallow rendering); <kbd>enzyme</kbd> is a React v16.x adapter, and React's test <kbd>renderer</kbd> to our application. We can do so with one quick <kbd>yarn</kbd> command:</p>
<pre><strong>$ yarn add --dev react-test-renderer enzyme enzyme enzyme-adapter-react-16</strong></pre>
<p class="mce-root"><kbd>enzyme</kbd> adds a lot to our test suite and makes it that much easier to work with, so it's honestly worth it to include <kbd>enzyme</kbd> as a baseline to our test suite! In fact, it's so helpful that it's included on some of the default React/Jest test documentation! Now, just including these by themselves won't do everything we need, so we'll also need to create a test setup file to initialize Enzyme. Create <kbd>src/setupTests.js</kbd> and give it the following body:</p>
<pre>// setup file<br/>import { configure } from 'enzyme';<br/>import Adapter from 'enzyme-adapter-react-16';<br/><br/>configure({ adapter: new Adapter() });</pre>
<p>Having done that, we can start tackling some real test code! We'll need to open up <kbd>src/Todo.test.js</kbd>, where we can add some code at the top which will give us the ability to take advantage of the <kbd>enzyme</kbd> shallow <kbd>renderer</kbd>! We'll also need <kbd>react-test-renderer</kbd> of the <kbd>renderer()</kbd> function, since we'll use that to create snapshots:</p>
<pre>import React from "react";<br/>import ReactDOM from "react-dom";<br/>import { shallow } from "enzyme";<br/>import renderer from "react-test-renderer";<br/><br/>import Todo from "./Todo";</pre>
<p class="mce-root">Now we have everything we need to begin writing our tests. Before we start writing our tests, I generally begin by throwing all of our tests into a big <kbd>describe</kbd> function, so let's start off there by moving the test that we already wrote inside of our <kbd>describe</kbd> block:</p>
<pre class="mce-root">describe(Todo, () =&gt; {<br/>  it("renders without crashing", () =&gt; {<br/>    const div = document.createElement("div");<br/>    ReactDOM.render(&lt;Todo /&gt;, div);<br/>    ReactDOM.unmountComponentAtNode(div);<br/>  });<br/>});</pre>
<p>Rerun the tests and we should be back to green and two suites and two tests:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-295 image-border" src="Images/8ec90fbe-3f03-486e-a24e-a9a01c10b22c.png" style="width:28.42em;height:16.17em;" width="369" height="210"/></p>
<p class="mce-root">Describe is a way of blocking together related tests, whether by functionality, concept, or otherwise. You have a few ways to declare a describe block. You can either use a string to specify the name of a test, or you can use a valid <kbd>Class</kbd> or <kbd>Component</kbd> name.</p>
<p class="mce-root">Now, if we want to start making our tests a little more complicated, we'll also need to do some basic setup stuff, since if you remember from our <kbd>Todo</kbd> component, we have a few functions that need to get passed down into our child component. Let's take a look at the default <span><kbd>props</kbd> </span><span>of our <kbd>Todo</kbd>:</span></p>
<pre>    this.state = {<br/>      done: false<br/>    };</pre>
<p>And the function body of the <kbd>removeTodo</kbd> prop:</p>
<pre>  removeTodo() {<br/>    this.props.removeTodo(this.props.description);<br/>  }</pre>
<p>Description is easy; that's just a string that we need to pass in. <kbd>removeTodo(...)</kbd>, on the other hand, is more complicated. It's a function that doesn't live as part of this component; instead, it lives inside of the parent and is passed in! So, how do we deal with that?</p>
<p>Simple, we can <em>mock</em> a function with Jest! Mocking a function basically makes a fake function that keeps track of when it's called. We'll also need to perform a <strong>shallow render</strong> of our component to verify how the component appears in the DOM overall. We'll talk a little more about this in a minute, but for right now add the following at the top of the describe block:</p>
<pre>  const description = "New Todo";<br/>  const mockRemoveTodo = jest.fn();<br/>  const component = shallow(<br/>    &lt;Todo description={description} removeTodo={mockRemoveTodo} /&gt;<br/>  );</pre>
<p>As you can see from the previous example, <kbd>jest.fn()</kbd> allows us to create a mocked function. Mocking a function, as mentioned previously, doesn't do anything in particular. It pretends to be a function, sees who is trying to use that function, and also keeps track of things, such as fake arguments or sets up fake return values for the function. This is good if we want to verify that the <kbd>removeTodo</kbd> in our <kbd>props</kbd> actually does anything at all but we don't care that it performs a specific behavior.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing a generic snapshot test</h1>
                </header>
            
            <article>
                
<p class="mce-root">T<span>alking about writing tests is one thing, but let's actually start implementing our tests. I typically approach test-writing in the following way:</span></p>
<ul>
<li class="mce-root">Write a generic snapshot test</li>
<li class="mce-root">Write some subcomponent-specific tests</li>
<li class="mce-root">Check content</li>
<li class="mce-root">Check interactions</li>
</ul>
<p>Snapshot tests can be used to verify initial state renders and renders after specific conditions are met. This works by grabbing a representation of your component, storing that, and then using it for future tests. This can be tricky when you have components that are changing constantly, but can be incredibly handy when your components are stable and shouldn't be getting modified often. Let's write our <kbd>snapshot</kbd> test:</p>
<pre>  it("renders and matches our snapshot", () =&gt; {<br/>    const component = renderer.create(&lt;Todo description="Yo" /&gt;);<br/>    const tree = component.toJSON();<br/>    expect(tree).toMatchSnapshot();<br/>  });</pre>
<p class="mce-root">Remember the <kbd>renderer</kbd> we had to <kbd>import</kbd> from <kbd>react-test-renderer</kbd>? This is where we use it! We create a <kbd>Todo</kbd> component via JSX and pass that into the <kbd>renderer.create()</kbd> function. We then grab the component structure, transform it into JSON, and verify that it matches the appropriate snapshot from a previous run. This is another early warning system to help catch when someone changes the component but doesn't do anything to update the tests! Let's take a look at the results in our <span class="packt_screen">Test Suite</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-296 image-border" src="Images/9dc30b06-4cdd-4310-bfd0-2ec10cd121d9.png" style="width:30.50em;height:16.67em;" width="395" height="217"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing tests for content</h1>
                </header>
            
            <article>
                
<p>We'll also need to make sure that when properties are passed in that modify what's displayed to the user, those properties actually make it into the fully-rendered function! We have a <kbd>description</kbd> variable that we already set at the top of our describe block. Before we jump too far, we need to write a quick test for our shallow render to make sure that is also working functionally!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What’s a shallow render?</h1>
                </header>
            
            <article>
                
<p>A shallow render is basically just a fake render of the component where it only renders the root-level component and nothing else. It's the most minimal rendition of any component that you can use for a test, so we should always use that before we jump into anything else! Let's write our shallow render test first:</p>
<pre>  it("renders a Todo component", () =&gt; {<br/>    expect(component.contains(&lt;div className="Todo" /&gt;));<br/>  });</pre>
<p>This is a simple test. It just ensures that we render out a <kbd>div</kbd> with a CSS class of <kbd>Todo</kbd>, which is the root <kbd>div</kbd> that gets rendered when we instantiate our <kbd>Todo</kbd> component in JSX. Otherwise, there are no major surprises here! Following that, we'll need to write some tests that make sure these <kbd>props</kbd> passed in make it into the <kbd>component</kbd>:</p>
<pre>  it("contains the description", () =&gt; {<br/>    expect(component.text()).toContain(description);<br/>  });</pre>
<p class="mce-root">We already created the shallow rendered version of the <kbd>component</kbd>, so we're grabbing that component, analyzing the rendered <kbd>text</kbd> that would get added to the DOM if it were a real render, and then making sure that whatever we put in the description made it in there!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Testing interactions</h1>
                </header>
            
            <article>
                
<p>The last step is to test the actual interactions in your component! We'll need to be able to target each of our buttons, though. If you think back to our <kbd>Todo</kbd> component's <kbd>render()</kbd> function, there are two buttons that get created:</p>
<pre>  render() {<br/>    return (<br/>      &lt;div className={this.cssClasses()}&gt;<br/>        {this.state.description}<br/>        &lt;br /&gt;<br/>        &lt;button onClick={this.markAsDone}&gt;Mark as Done&lt;/button&gt;<br/>        &lt;button onClick={this.removeTodo}&gt;Remove Me&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }</pre>
<p>Without any modifications, it would actually be difficult for us to specifically target either of the actual buttons. We'll want a way to target each <kbd>button</kbd> separately from each other, so let's go into the <kbd>Todo</kbd> component and add a unique <kbd>className</kbd> to each button! Add <kbd>MarkDone className</kbd> to the first <kbd>button</kbd> and <kbd>RemoveTodo className</kbd> to the second <kbd>button</kbd> in the render function in <kbd>src/Todo.js</kbd>, just like the following code:</p>
<pre>  render() {<br/>    return (<br/>      &lt;div className={this.cssClasses()}&gt;<br/>        {this.props.description}<br/>        &lt;br /&gt;<br/>        &lt;button className="MarkDone" onClick={this.markAsDone}&gt;<br/>          Mark as Done<br/>        &lt;/button&gt;<br/>        &lt;button className="RemoveTodo" onClick={this.removeTodo}&gt;<br/>          Remove Me<br/>        &lt;/button&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }</pre>
<p>Save this code and the tests will rerun and it fails? But why? We haven't changed the tests yet! Refer the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-297 image-border" src="Images/ff519430-4309-4b51-b4a4-fe51e57b89d4.png" style="width:66.08em;height:46.83em;" width="793" height="562"/></p>
<p class="mce-root">This is actually doing exactly what it's supposed to! We made some modifications to our component that changed how the component got rendered out. In our case, we're totally okay with these changes, so we'll use another one of our test-watcher commands to update the <kbd>snapshot</kbd>! Hit <em>u</em> and our <kbd>snapshot</kbd> will get updated and our tests will go back to passing! Finally, we can go back to finishing up our tests for interaction!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Completing our interactivity tests</h1>
                </header>
            
            <article>
                
<p class="mce-root">Now that we can isolate each of the buttons, we can test what happens when each of them is clicked! We'll need to start off by verifying our <kbd>MarkDone button</kbd> marks that <kbd>Todo</kbd> as done, which we can do via checking the <kbd>state</kbd>, as well! Let's take a look at the test and then we'll talk about what it does:</p>
<pre>  it("marks the Todo as done", () =&gt; {<br/>    component.find("button.MarkDone").simulate("click");<br/>    expect(component.state("done")).toEqual(true);<br/>  });</pre>
<p>The easiest way to reason about these tests is to say them out loud. If we were to test this behavior as a human, we'd say, find the button that marks the <kbd>Todo</kbd> as done, click on that button, and then we should expect that <kbd>Todo</kbd> to be complete! Our code does precisely that! It <em>finds</em> the component via a CSS selector that grabs the button that has a CSS class attached to it of <kbd>MarkDone</kbd> (remember our <kbd>render()</kbd> function changes earlier). We then simulate a <kbd>"click"</kbd> event sent to that <kbd>button</kbd> which targets the <kbd>onClick</kbd> handler. Finally, we have to use the <kbd>state()</kbd> function to grab a value out of the component's state, which for us is the <kbd>"done"</kbd> property in the <kbd>state</kbd>! If that's now <kbd>true</kbd>, then we're golden and our tests work!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Returning to our mocked function</h1>
                </header>
            
            <article>
                
<p>We talked a lot about our function mocks but then focused on a bunch of other tests; now it's time for us to revisit our mocked function and actually test it out! Basically, all we need to do is to use a helper function to verify that our mock has been called:</p>
<pre>  it("calls the mock remove function", () =&gt; {<br/>    component.find("button.RemoveTodo").simulate("click");<br/>    expect(mockRemoveTodo).toHaveBeenCalled();<br/>  });</pre>
<p>We had our <kbd>mockRemoveTodo</kbd> function that we had put back up in the top of our describe block:</p>
<pre>const mockRemoveTodo = jest.fn();</pre>
<p class="mce-root">We've already seen the <kbd>simulate</kbd> call in a previous test, so all we do is create the expectation that our mock function has been called, and that's it! With that, we have a very thorough test suite for our <kbd>Todo</kbd> component, and everything we do from here are just slightly more complicated variations of the same tests! <span>Seven total <span class="packt_screen">Tests</span>, two <span class="packt_screen">Test Suites</span>, and one <span class="packt_screen">Snapshots</span> test—</span><span>all</span><span> working perfectly! Refer the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-298 image-border" src="Images/e1812bab-ea68-4fd4-8536-611a2b305a1d.png" style="width:35.42em;height:16.42em;" width="453" height="210"/></p>
<p>Before we move on, let's verify the full test suite for <kbd>src/Todo.test.js</kbd>:</p>
<pre>import React from "react";<br/>import ReactDOM from "react-dom";<br/>import { shallow } from "enzyme";<br/>import renderer from "react-test-renderer";<br/><br/>import Todo from "./Todo";<br/><br/>describe(Todo, () =&gt; {<br/>  const description = "New Todo";<br/>  const mockRemoveTodo = jest.fn();<br/>  const component = shallow(<br/>    &lt;Todo description={description} removeTodo={mockRemoveTodo} /&gt;<br/>  );<br/><br/>  it("renders without crashing", () =&gt; {<br/>    const div = document.createElement("div");<br/>    ReactDOM.render(&lt;Todo /&gt;, div);<br/>    ReactDOM.unmountComponentAtNode(div);<br/>  });<br/><br/>  it("renders and matches our snapshot", () =&gt; {<br/>    const component = renderer.create(&lt;Todo description="Yo" /&gt;);<br/>    const tree = component.toJSON();<br/>    expect(tree).toMatchSnapshot();<br/>  });<br/><br/>  it("renders a Todo component", () =&gt; {<br/>    expect(component.contains(&lt;div className="Todo" /&gt;));<br/>  });<br/><br/>  it("contains the description", () =&gt; {<br/>    expect(component.text()).toContain(description);<br/>  });<br/><br/>  it("marks the Todo as done", () =&gt; {<br/>    component.find("button.MarkDone").simulate("click");<br/>    expect(component.state("done")).toEqual(true);<br/>  });<br/><br/>  it("calls the mock remove function", () =&gt; {<br/>    component.find("button.RemoveTodo").simulate("click");<br/>    expect(mockRemoveTodo).toHaveBeenCalled();<br/>  });<br/>});</pre>
<p>Let's now add some tests for <kbd>TodoList</kbd> as well!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding tests for TodoList</h1>
                </header>
            
            <article>
                
<p>We'll start off by adding a framework to put the rest of our <kbd>TodoList</kbd> tests on! We'll need our standard imports and tests for rendering, snapshots, and shallow components! We'll start off with this scaffold for <kbd>src/TodoList.test.js</kbd>:</p>
<pre>import React from "react";<br/>import ReactDOM from "react-dom";<br/>import { shallow } from "enzyme";<br/>import renderer from "react-test-renderer";<br/><br/>import TodoList from "./TodoList";<br/>import NewTodo from "./NewTodo";<br/>import Todo from "./Todo";<br/><br/>describe(TodoList, () =&gt; {<br/>  const component = shallow(&lt;TodoList /&gt;);<br/><br/>  it("renders without crashing", () =&gt; {<br/>    const div = document.createElement("div");<br/>    ReactDOM.render(&lt;TodoList /&gt;, div);<br/>    ReactDOM.unmountComponentAtNode(div);<br/>  });<br/><br/>  it("renders and matches our snapshot", () =&gt; {<br/>    const component = renderer.create(&lt;TodoList /&gt;);<br/>    const tree = component.toJSON();<br/>    expect(tree).toMatchSnapshot();<br/>  });<br/><br/>  it("renders a TodoList component", () =&gt; {<br/>    expect(component.contains(&lt;div className="TodoList" /&gt;));<br/>  });<br/>});</pre>
<p class="mce-root">We covered these tests previously, so there's not much we'll need to jump into, but we will want to make sure that, since our <kbd>render()</kbd> call includes a <kbd>NewTodo</kbd> component and we've imported that <kbd>component</kbd> at the top of our file, we have a test that verifies there's a single <kbd>NewTodo</kbd> in the tree:</p>
<pre>  it("includes a NewTodo component", () =&gt; {<br/>    expect(component.find(NewTodo)).toHaveLength(1);<br/>  });</pre>
<p>We'll also need to verify how many <kbd>Todo</kbd> components appear in our <kbd>TodoList</kbd>, but there's a little bit of a more complicated problem we have to solve with this test. If you remember, the state's <kbd>"items"</kbd> property in <kbd>TodoList</kbd> determines what <kbd>Todo</kbd>s should appear, so we'll check the state versus the component's <kbd>find</kbd> function to see that the two are in sync with each other:</p>
<pre>  it("renders the correct number of Todo components", () =&gt; {<br/>    const todoCount = component.state("items").length;<br/>    expect(component.find(Todo)).toHaveLength(todoCount);<br/>  });</pre>
<p>Our <kbd>component</kbd> already gets rendered out via the <kbd>shallow()</kbd> call, so we'll use the <kbd>state()</kbd> call to verify the length of the items and find the equal number of <kbd>Todo</kbd> components. We'll also need to test our <span><kbd>addTodo</kbd> function of</span> <kbd>TodoList</kbd>:</p>
<pre>  it("adds another Todo when the addTodo function is called", () =&gt; {<br/>    const before = component.find(Todo).length;<br/>    component.instance().addTodo("A new item");<br/>    const after = component.find(Todo).length;<br/>    expect(after).toBeGreaterThan(before);<br/>  });</pre>
<p>There's some new functionality in here that might be slightly complicated, so let's talk a little bit about it! We start off by finding out how many Todos already exist, since after we add another item we should expect that to be what we started with, plus another one! After that, we'll want to call <kbd>addTodo()</kbd> on the component, but to do that we need to jump down into the actual <span>living context of</span> <kbd>component</kbd>. We can do that via the <kbd>instance()</kbd> call, which allows us to call any function on the <kbd>component</kbd> without having to simulate any button clicks! After we call <kbd>addTodo</kbd>, we grab the list of all of the Todos that exist on the function and expect it to be more than what we originally started with! This is a really important and great way to write our tests; we never hardcode the number of Todos or anything else; instead, we check relative values after events happen! This eliminates weird scenarios where someone changes the default or initial state for our components and breaks our tests as a direct result!</p>
<p class="mce-root">Finally, we need to implement a <kbd>removeTodo</kbd> test, which is just the reverse operation from the test we previously wrote:</p>
<pre class="mce-root">  it("removes a Todo from the list when the remove todo function is called", () =&gt; {<br/>    const before = component.find(Todo).length;<br/>    const removeMe = component.state("items")[0];<br/>    component.instance().removeTodo(removeMe);<br/>    const after = component.find(Todo).length;<br/>    expect(after).toBeLessThan(before);<br/>  });</pre>
<p>The only notable difference is the fact that <kbd>removeTodo</kbd> needs an actual item to remove, so we have to grab one of the items out of the list and remove that specifically by passing that value into the <kbd>removeTodo</kbd> function!</p>
<p class="mce-root">After all is said and done, we should have a full test suite for <kbd>TodoList.test.js</kbd> that looks like this:</p>
<pre>import React from "react";<br/>import ReactDOM from "react-dom";<br/>import { shallow } from "enzyme";<br/>import renderer from "react-test-renderer";<br/><br/>import TodoList from "./TodoList";<br/>import NewTodo from "./NewTodo";<br/>import Todo from "./Todo";<br/><br/>describe(TodoList, () =&gt; {<br/>  const component = shallow(&lt;TodoList /&gt;);<br/><br/>  it("renders without crashing", () =&gt; {<br/>    const div = document.createElement("div");<br/>    ReactDOM.render(&lt;TodoList /&gt;, div);<br/>    ReactDOM.unmountComponentAtNode(div);<br/>  });<br/><br/>  it("renders and matches our snapshot", () =&gt; {<br/>    const component = renderer.create(&lt;TodoList /&gt;);<br/>    const tree = component.toJSON();<br/>    expect(tree).toMatchSnapshot();<br/>  });<br/><br/>  it("renders a TodoList component", () =&gt; {<br/>    expect(component.contains(&lt;div className="TodoList" /&gt;));<br/>  });<br/><br/>  it("includes a NewTodo component", () =&gt; {<br/>    expect(component.find(NewTodo)).toHaveLength(1);<br/>  });<br/><br/>  it("renders the correct number of Todo components", () =&gt; {<br/>    const todoCount = component.state("items").length;<br/>    expect(component.find(Todo)).toHaveLength(todoCount);<br/>  });<br/><br/>  it("adds another Todo when the addTodo function is called", () =&gt; {<br/>    const before = component.find(Todo).length;<br/>    component.instance().addTodo("A new item");<br/>    const after = component.find(Todo).length;<br/>    expect(after).toBeGreaterThan(before);<br/>  });<br/><br/>  it("removes a Todo from the list when the remove todo function is called", () =&gt; {<br/>    const before = component.find(Todo).length;<br/>    const removeMe = component.state("items")[0];<br/>    component.instance().removeTodo(removeMe);<br/>    const after = component.find(Todo).length;<br/>    expect(after).toBeLessThan(before);<br/>  });<br/>});</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding tests for NewTodo</h1>
                </header>
            
            <article>
                
<p>At last, we can add our final test suite and make sure <kbd>NewTodo</kbd> is covered as well. For the most part, we'll work with the same skeleton we already have and have used before. Create <kbd>src/NewTodo.test.js</kbd> and give it the following skeleton:</p>
<pre>import React from "react";<br/>import ReactDOM from "react-dom";<br/>import { shallow } from "enzyme";<br/>import renderer from "react-test-renderer";<br/><br/>import NewTodo from "./NewTodo";<br/><br/>describe(NewTodo, () =&gt; {<br/>  const mockAddTodo = jest.fn();<br/>  const component = shallow(&lt;NewTodo addTodo={mockAddTodo} /&gt;);<br/><br/>  it("renders without crashing", () =&gt; {<br/>    const div = document.createElement("div");<br/>    ReactDOM.render(&lt;NewTodo addTodo={mockAddTodo} /&gt;, div);<br/>    ReactDOM.unmountComponentAtNode(div);<br/>  });<br/><br/>  it("renders and matches our snapshot", () =&gt; {<br/>    const component = renderer.create(&lt;NewTodo addTodo={mockAddTodo} /&gt;);<br/>    const tree = component.toJSON();<br/>    expect(tree).toMatchSnapshot();<br/>  });<br/><br/>  it("renders a Todo component", () =&gt; {<br/>    expect(component.contains(&lt;div className="NewTodo" /&gt;));<br/>  });<br/>});</pre>
<p>We'll also want to modify the tests we wrote that check our content, since we should at least make sure that the there's still a text field and a <kbd>button</kbd> as part of the form:</p>
<pre>it('contains the form', () =&gt; {<br/>  expect(component.find('input')).toHaveLength(1);<br/>  expect(component.find('button')).toHaveLength(1);<br/>});</pre>
<p class="mce-root">We’ll also want to test our mocked <kbd>addTodo</kbd> function:</p>
<pre class="mce-root">  it("calls the passed in addTodo function when add button is clicked", () =&gt; {<br/>    component.find("button").simulate("click");<br/>    expect(mockAddTodo).toBeCalled();<br/>  });</pre>
<p>This is essentially identical to what we did in the <kbd>Todo</kbd> component suite. We'll need a test for our <kbd>handleUpdate</kbd> function, which should modify the <kbd>"item" state</kbd> property to the faked <kbd>input</kbd> value:</p>
<pre>  it("updates the form when keys are pressed", () =&gt; {<br/>    const updateKey = "New Todo";<br/>    component.instance().handleUpdate({ target: { value: updateKey } });<br/>    expect(component.state("item")).toEqual(updateKey);<br/>  });</pre>
<p>The structure of the <kbd>handleUpdate</kbd> argument is a little wacky, so we need to make sure we're passing in an object that's compatible with the <kbd>handleUpdate</kbd> function that we wrote, which is as follows:</p>
<pre>  handleUpdate(event) {<br/>    this.setState({ item: event.target.value });<br/>  }</pre>
<p class="mce-root">We then use the <kbd>state</kbd> function to verify that <kbd>"item"</kbd> now matches what we passed in! We'll close out our test-writing escapade by verifying that when the button to add an item is clicked that the value in the <kbd>"item" state</kbd> key is reset to blank:</p>
<pre> it("blanks out the Todo Name when the button is clicked", () =&gt; {<br/> const updateKey = "I should be empty";<br/> component.instance().handleUpdate({ target: { value: updateKey } });<br/> expect(component.state("item")).toEqual(updateKey);<br/> component.find("button").simulate("click");<br/> expect(component.state("item")).toHaveLength(0);<br/> });</pre>
<p class="mce-root">We need to verify that we're being thorough with our test by making sure the component has a value first and then is reset to blank. If we don't, we wouldn't have any way to verify that our test was working the way we're expecting!</p>
<p>The full test suite is provided here:</p>
<pre>import React from "react";<br/>import ReactDOM from "react-dom";<br/>import { shallow } from "enzyme";<br/>import renderer from "react-test-renderer";<br/><br/>import NewTodo from "./NewTodo";<br/><br/>describe(NewTodo, () =&gt; {<br/> const mockAddTodo = jest.fn();<br/> const component = shallow(&lt;NewTodo addTodo={mockAddTodo} /&gt;);<br/><br/> it("renders without crashing", () =&gt; {<br/> const div = document.createElement("div");<br/> ReactDOM.render(&lt;NewTodo addTodo={mockAddTodo} /&gt;, div);<br/> ReactDOM.unmountComponentAtNode(div);<br/> });<br/><br/> it("renders and matches our snapshot", () =&gt; {<br/> const component = renderer.create(&lt;NewTodo addTodo={mockAddTodo} /&gt;);<br/> const tree = component.toJSON();<br/> expect(tree).toMatchSnapshot();<br/> });<br/><br/> it("renders a Todo component", () =&gt; {<br/> expect(component.contains(&lt;div className="NewTodo" /&gt;));<br/> });<br/><br/> it("contains the form", () =&gt; {<br/> expect(component.find("input")).toHaveLength(1);<br/> expect(component.find("button")).toHaveLength(1);<br/> });<br/><br/> it("calls the passed in addTodo function when add button is clicked", () =&gt; {<br/> component.find("button").simulate("click");<br/> expect(mockAddTodo).toBeCalled();<br/> });<br/><br/> it("updates the form when keys are pressed", () =&gt; {<br/> const updateKey = "New Todo";<br/> component.instance().handleUpdate({ target: { value: updateKey } });<br/> expect(component.state("item")).toEqual(updateKey);<br/> });<br/><br/> it("blanks out the Todo Name when the button is clicked", () =&gt; {<br/> const updateKey = "I should be empty";<br/> component.instance().handleUpdate({ target: { value: updateKey } });<br/> expect(component.state("item")).toEqual(updateKey);<br/> component.find("button").simulate("click");<br/> expect(component.state("item")).toHaveLength(0);<br/> });<br/>});</pre>
<p class="mce-root">The final result of all of our tests, if you've been following along, should be the following <span class="packt_screen">Test Suite</span> results:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-299 image-border" src="Images/960d844d-732f-4983-8f63-9b2c25383d67.png" style="width:30.08em;height:16.17em;" width="488" height="261"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">Testing is something that's absolutely critical to the overall health of your application! It ensures your development cycles are sane and your deploys are not incredibly dangerous. Your behavior can be tested, verified, and you can be confident in what your application is doing at any point in time without ever needing to open up a browser!</p>
<p>This is something that used to be a nightmare to do. The React test setup was a function that people generally hated given how much of a time commitment it took and how finicky it ended up being after the setup was done. One misstep or bad configuration change and the entire test harness framework could fall apart completely!</p>
<p>Be prepared to write a lot of tests if you write a production-ready React application! It's a great software engineering practice to be do whenever you're doing anything code-wise, and React is no different!</p>
<p>In the next chapter, we'll dive into cleaning up the visual design of our project with the new CSS module and the SASS support that's built into Create React App's latest version, and we'll incorporate a major CSS framework as well!</p>


            </article>

            
        </section>
    </div>



  </body></html>