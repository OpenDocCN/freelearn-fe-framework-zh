<html><head></head><body>
		<div id="_idContainer037">
			<h1 id="_idParaDest-124"><em class="italic"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.1.1">Chapter 10</span></em><span class="koboSpan" id="kobo.2.1">: Use Case Scenario 4 – React Tracked</span></h1>
			<p><span class="L2-L3-bullet-characters"><span class="koboSpan" id="kobo.3.1">React Tracked (</span></span><a href="https://react-tracked.js.org"><span class="koboSpan" id="kobo.4.1">https://react-tracked.js.org</span></a><span class="koboSpan" id="kobo.5.1">) is a library for state usage tracking that optimizes re-renders automatically based on property access. </span><span class="koboSpan" id="kobo.5.2">It provides the same functionality to eliminate extra re-renders as Valtio, which we discussed in </span><a href="B17780_09_Final_VK_ePub.xhtml#_idTextAnchor116"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.7.1">,</span><em class="italic"><span class="koboSpan" id="kobo.8.1"> Use Case Scenario 3 – Valtio</span></em><span class="koboSpan" id="kobo.9.1">. </span></p>
			<p><span class="koboSpan" id="kobo.10.1">React Tracked can be used with other state management libraries. </span><span class="koboSpan" id="kobo.10.2">The primary use case is </span><strong class="source-inline"><span class="koboSpan" id="kobo.11.1">useState</span></strong><span class="koboSpan" id="kobo.12.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.13.1">useReducer</span></strong><span class="koboSpan" id="kobo.14.1">, but it can also be used with Redux (</span><a href="https://redux.js.org"><span class="koboSpan" id="kobo.15.1">https://redux.js.org</span></a><span class="koboSpan" id="kobo.16.1">), Zustand (discussed in </span><a href="B17780_07_Final_VK_ePub.xhtml#_idTextAnchor092"><em class="italic"><span class="koboSpan" id="kobo.17.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.18.1">, </span><em class="italic"><span class="koboSpan" id="kobo.19.1">Use Case Scenario 1 – Zustand</span></em><span class="koboSpan" id="kobo.20.1">), and other similar libraries.</span></p>
			<p><span class="koboSpan" id="kobo.21.1">In this chapter, we will again discuss optimizing re-renders with state usage tracking and compare related libraries. </span><span class="koboSpan" id="kobo.21.2">We will learn two usages of React Tracked, one with </span><strong class="source-inline"><span class="koboSpan" id="kobo.22.1">useState</span></strong><span class="koboSpan" id="kobo.23.1"> and the other with React Redux (</span><a href="https://react-redux.js.org"><span class="koboSpan" id="kobo.24.1">https://react-redux.js.org</span></a><span class="koboSpan" id="kobo.25.1">). </span><span class="koboSpan" id="kobo.25.2">We will wrap up with a look at how React Tracked will work with the future version of React.</span></p>
			<p><span class="koboSpan" id="kobo.26.1">In this chapter, we will cover the following topics:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.27.1">Understanding React Tracked</span></li>
				<li><span class="koboSpan" id="kobo.28.1">Using React Tracked with </span><strong class="source-inline"><span class="koboSpan" id="kobo.29.1">useState</span></strong><span class="koboSpan" id="kobo.30.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.31.1">useReducer</span></strong></li>
				<li><span class="koboSpan" id="kobo.32.1">Using React Tracked with React Redux</span></li>
				<li><span class="koboSpan" id="kobo.33.1">Future prospects</span></li>
			</ul>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.34.1">Technical requirements</span></h1>
			<p><span class="koboSpan" id="kobo.35.1">You are expected to have a moderate amount of knowledge about React, including React Hooks. </span><span class="koboSpan" id="kobo.35.2">Refer to the official site, </span><a href="https://reactjs.org"><span class="koboSpan" id="kobo.36.1">https://reactjs.org</span></a><span class="koboSpan" id="kobo.37.1">, to learn more.</span></p>
			<p><span class="koboSpan" id="kobo.38.1">In some code, we use TypeScript (</span><a href="https://www.typescriptlang.org"><span class="koboSpan" id="kobo.39.1">https://www.typescriptlang.org</span></a><span class="koboSpan" id="kobo.40.1">), and you should have basic knowledge of it.</span></p>
			<p><span class="koboSpan" id="kobo.41.1">The code in this chapter is available on GitHub: </span><a href="https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_10"><span class="koboSpan" id="kobo.42.1">https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_10</span></a><span class="koboSpan" id="kobo.43.1">.</span></p>
			<p><span class="koboSpan" id="kobo.44.1">To run the code snippets, you need a React environment – for example, Create React App (</span><a href="https://create-react-app.dev"><span class="koboSpan" id="kobo.45.1">https://create-react-app.dev</span></a><span class="koboSpan" id="kobo.46.1">) or CodeSandbox (</span><a href="https://codesandbox.io"><span class="koboSpan" id="kobo.47.1">https://codesandbox.io</span></a><span class="koboSpan" id="kobo.48.1">).</span></p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.49.1">Understanding React Tracked</span></h1>
			<p><span class="koboSpan" id="kobo.50.1">We have been</span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.51.1"> learning about several global state libraries, but React Tracked is slightly different from the ones we have learned about so far. </span><span class="koboSpan" id="kobo.51.2">React Tracked doesn't provide state functionality, but what it does provide is render optimization functionality. </span><span class="koboSpan" id="kobo.51.3">We call this functionality </span><strong class="bold"><span class="koboSpan" id="kobo.52.1">state usage tracking</span></strong><span class="koboSpan" id="kobo.53.1">.</span></p>
			<p><span class="koboSpan" id="kobo.54.1">Let's recap how React Context behaves because one of the use cases of state usage tracking in React Tracked is for a React Context.</span></p>
			<p><span class="koboSpan" id="kobo.55.1">Suppose we define a Context with </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">createContext</span></strong><span class="koboSpan" id="kobo.57.1"> as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.58.1">const NameContext = createContext([</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.59.1">  { firstName: 'react', lastName: 'hooks' },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.60.1">  () =&gt; {},</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.61.1">]);</span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">createContext</span></strong><span class="koboSpan" id="kobo.63.1"> takes an initial value, which is an array in this case. </span><span class="koboSpan" id="kobo.63.2">The first item in the array is an initial state object. </span><span class="koboSpan" id="kobo.63.3">The second item in the array, </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">() =&gt; {}</span></strong><span class="koboSpan" id="kobo.65.1">, is a dummy updating function.</span></p>
			<p><span class="koboSpan" id="kobo.66.1">The reason we put such an array as the initial value is to match the return value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">useState</span></strong><span class="koboSpan" id="kobo.68.1">. </span><span class="koboSpan" id="kobo.68.2">We often define </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">NameProvider</span></strong><span class="koboSpan" id="kobo.70.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">useState</span></strong><span class="koboSpan" id="kobo.72.1"> for a global state:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.73.1">const NameProvider = ({ children }) =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.74.1">  &lt;NameContext.Provider</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.75.1">    value={</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.76.1">      useState({ firstName: 'react', lastName: 'hooks' })</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.77.1">    }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.78.1">  &gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.79.1">    {children}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.80.1">  &lt;/NameContext.Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.81.1">};</span></p>
			<p><span class="koboSpan" id="kobo.82.1">You should usually use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">NameProvider</span></strong><span class="koboSpan" id="kobo.84.1"> component in a root component or some component close to it.</span></p>
			<p><span class="koboSpan" id="kobo.85.1">Now that we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">NameProvider</span></strong><span class="koboSpan" id="kobo.87.1"> component, we can consume it under its tree. </span><span class="koboSpan" id="kobo.87.2">To consume the Context value, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">useContext</span></strong><span class="koboSpan" id="kobo.89.1">. </span><span class="koboSpan" id="kobo.89.2">Let's assume we only need </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">firstName</span></strong><span class="koboSpan" id="kobo.91.1"> and define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">useFirstName</span></strong><span class="koboSpan" id="kobo.93.1"> hook:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.94.1">const useFirstName = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.95.1">  const [{ firstName }] = useContext(NameContext);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.96.1">  return firstName;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.97.1">};</span></p>
			<p><span class="koboSpan" id="kobo.98.1">This works fine. </span><span class="koboSpan" id="kobo.98.2">However, there's</span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.99.1"> a possibility of extra re-renders. </span><span class="koboSpan" id="kobo.99.2">If we update only </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">lastName</span></strong><span class="koboSpan" id="kobo.101.1"> without changing </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">firstName</span></strong><span class="koboSpan" id="kobo.103.1">, the new Context value will be propagated and </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">useContext(NameContext)</span></strong><span class="koboSpan" id="kobo.105.1"> triggers a re-render. </span><span class="koboSpan" id="kobo.105.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">useFirstName</span></strong><span class="koboSpan" id="kobo.107.1"> hook only reads </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">firstName</span></strong><span class="koboSpan" id="kobo.109.1"> from the Context value. </span><span class="koboSpan" id="kobo.109.2">Hence, this becomes an extra re-render.</span></p>
			<p><span class="koboSpan" id="kobo.110.1">This behavior is obvious from an implementation point of view. </span><span class="koboSpan" id="kobo.110.2">But from a developer's point of view, it doesn't seem ideal because it only uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">firstName</span></strong><span class="koboSpan" id="kobo.112.1"> from the Context value. </span><span class="koboSpan" id="kobo.112.2">From the developer's point of view, the expectation would be that it doesn't depend on other properties – in this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">lastName</span></strong><span class="koboSpan" id="kobo.114.1">.</span></p>
			<p><span class="koboSpan" id="kobo.115.1">State usage tracking is the feature that realizes this expected behavior. </span><span class="koboSpan" id="kobo.115.2">If we only use </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">firstName</span></strong><span class="koboSpan" id="kobo.117.1"> in the state object, we expect the hook to trigger re-renders only when </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">firstName</span></strong><span class="koboSpan" id="kobo.119.1"> changes. </span><span class="koboSpan" id="kobo.119.2">This can be accomplished with proxies.</span></p>
			<p><span class="koboSpan" id="kobo.120.1">React Tracked allows us to define a hook called </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">useTracked</span></strong><span class="koboSpan" id="kobo.122.1">, which can be used instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">useContext(NameContext)</span></strong><span class="koboSpan" id="kobo.124.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">useTracked</span></strong><span class="koboSpan" id="kobo.126.1"> wraps the state with proxies and tracks its usage. </span><span class="koboSpan" id="kobo.126.2">The expected usage of </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">useTracked</span></strong><span class="koboSpan" id="kobo.128.1"> looks like the following:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.129.1">const useFirstName = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.130.1">  const [{ firstName }] = useTracked();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.131.1">  return firstName;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.132.1">};</span></p>
			<p><span class="koboSpan" id="kobo.133.1">The usage doesn't differ from the usage of </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">useContext(NameContext)</span></strong><span class="koboSpan" id="kobo.135.1">. </span><span class="koboSpan" id="kobo.135.2">This is the whole point of state usage tracking. </span><span class="koboSpan" id="kobo.135.3">Our code looks just as usual, but behind the scenes, it tracks the state usage and optimizes renders automatically.</span></p>
			<p><span class="koboSpan" id="kobo.136.1">Automatic render optimization was discussed in </span><a href="B17780_09_Final_VK_ePub.xhtml#_idTextAnchor116"><em class="italic"><span class="koboSpan" id="kobo.137.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.138.1">, </span><em class="italic"><span class="koboSpan" id="kobo.139.1">Use Case Scenario 3 – Valtio</span></em><span class="koboSpan" id="kobo.140.1">. </span><span class="koboSpan" id="kobo.140.2">React Tracked and Valtio use the same state usage tracking feature. </span><span class="koboSpan" id="kobo.140.3">Actually, they use the same internal library, which is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">proxy-compare</span></strong><span class="koboSpan" id="kobo.142.1">: </span><a href="https://github.com/dai-shi/proxy-compare"><span class="koboSpan" id="kobo.143.1">https://github.com/dai-shi/proxy-compare</span></a><span class="koboSpan" id="kobo.144.1">.</span></p>
			<p><span class="koboSpan" id="kobo.145.1">In this section, we </span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.146.1">revisited state usage tracking and learned how it can optimize re-renders. </span><span class="koboSpan" id="kobo.146.2">In the next section, we will learn how to use React Tracked with </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">useState</span></strong><span class="koboSpan" id="kobo.148.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">useReducer</span></strong><span class="koboSpan" id="kobo.150.1">.</span></p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.151.1">Using React Tracked with useState and useReducer</span></h1>
			<p><span class="koboSpan" id="kobo.152.1">The primary use</span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.153.1"> case of React Tracked is to replace a use case of React Context. </span><span class="koboSpan" id="kobo.153.2">The API in React Tracked is specifically designed for this use case.</span></p>
			<p><span class="koboSpan" id="kobo.154.1">We will explore two usages with </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">useState</span></strong><span class="koboSpan" id="kobo.156.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">useReducer</span></strong><span class="koboSpan" id="kobo.158.1">. </span><span class="koboSpan" id="kobo.158.2">First, let's learn about the usage with </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">useState</span></strong><span class="koboSpan" id="kobo.160.1">.</span></p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.161.1">Using React Tracked with useState</span></h2>
			<p><span class="koboSpan" id="kobo.162.1">Before </span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.163.1">exploring</span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.164.1"> the usage of React Tracked with </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">useState</span></strong><span class="koboSpan" id="kobo.166.1">, let's revisit how we can create a global state with React Context.</span></p>
			<p><span class="koboSpan" id="kobo.167.1">We first create a custom hook, which calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">useState</span></strong><span class="koboSpan" id="kobo.169.1"> with an initial state value:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.170.1">const useValue = () =&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.171.1">  useState({ count: 0, text: "hello" });</span></p>
			<p><span class="koboSpan" id="kobo.172.1">Defining the custom hook is good for TypeScript because you can grab the type with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">typeof</span></strong><span class="koboSpan" id="kobo.174.1"> operator.</span></p>
			<p><span class="koboSpan" id="kobo.175.1">The following is a definition of our Context:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.176.1">const StateContext = createContext&lt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.177.1">  ReturnType&lt;typeof useValue&gt; | null</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.178.1">&gt;(null);</span></p>
			<p><span class="koboSpan" id="kobo.179.1">It has a type annotation in TypeScript. </span><span class="koboSpan" id="kobo.179.2">The default value is </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">null</span></strong><span class="koboSpan" id="kobo.181.1">.</span></p>
			<p><span class="koboSpan" id="kobo.182.1">To use the Context, we need a </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">Provider</span></strong><span class="koboSpan" id="kobo.184.1"> component. </span><span class="koboSpan" id="kobo.184.2">The following is a custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">Provider</span></strong><span class="koboSpan" id="kobo.186.1"> that uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">useValue</span></strong><span class="koboSpan" id="kobo.188.1"> for the Context value:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.189.1">const Provider = ({ children }: { children: ReactNode }) =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.190.1">  &lt;StateContext.Provider value={useValue()}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.191.1">    {children}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.192.1">  &lt;/StateContext.Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.193.1">);</span></p>
			<p><span class="koboSpan" id="kobo.194.1">This is a</span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.195.1"> component </span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.196.1">that injects the </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">StateContext.Provider</span></strong><span class="koboSpan" id="kobo.198.1"> component. </span><span class="koboSpan" id="kobo.198.2">As we defined </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">useValue</span></strong><span class="koboSpan" id="kobo.200.1"> separately, the implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">Provider</span></strong><span class="koboSpan" id="kobo.202.1"> can use </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.203.1">it in </span><strong class="bold"><span class="koboSpan" id="kobo.204.1">JavaScript Syntax Extension</span></strong><span class="koboSpan" id="kobo.205.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.206.1">JSX</span></strong><span class="koboSpan" id="kobo.207.1">).</span></p>
			<p><span class="koboSpan" id="kobo.208.1">To consume the Context's value, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">useContext</span></strong><span class="koboSpan" id="kobo.210.1">. </span><span class="koboSpan" id="kobo.210.2">We define a custom hook as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.211.1">const useStateContext = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.212.1">  const contextValue = useContext(StateContext);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.213.1">  if (contextValue === null) {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.214.1">    throw new Error("Please use Provider");</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.215.1">  }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.216.1">  return contextValue;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.217.1">};</span></p>
			<p><span class="koboSpan" id="kobo.218.1">This custom hook checks the existence of </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">Provider</span></strong><span class="koboSpan" id="kobo.220.1"> by comparing </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">contextValue</span></strong><span class="koboSpan" id="kobo.222.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">null</span></strong><span class="koboSpan" id="kobo.224.1">. </span><span class="koboSpan" id="kobo.224.2">If it's </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">null</span></strong><span class="koboSpan" id="kobo.226.1">, it throws an error, and developers will notice that </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">Provider</span></strong><span class="koboSpan" id="kobo.228.1"> is missing.</span></p>
			<p><span class="koboSpan" id="kobo.229.1">Now, it's time to define some components for the app. </span><span class="koboSpan" id="kobo.229.2">The first component is </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">Counter</span></strong><span class="koboSpan" id="kobo.231.1">, which shows </span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.232.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">count</span></strong><span class="koboSpan" id="kobo.234.1"> property of the state as well as a button to increment</span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.235.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">count</span></strong><span class="koboSpan" id="kobo.237.1"> value:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.238.1">const Counter = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.239.1">  const [state, setState] = useStateContext();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.240.1">  const inc = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.241.1">    setState((prev) =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.242.1">      ...prev,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.243.1">      count: prev.count + 1,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.244.1">    }));</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.245.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.246.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.247.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.248.1">      count: {state.count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.249.1">      &lt;button onClick={inc}&gt;+1&lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.250.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.251.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.252.1">};</span></p>
			<p><span class="koboSpan" id="kobo.253.1">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">useStateContext</span></strong><span class="koboSpan" id="kobo.255.1"> returns a tuple of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">state</span></strong><span class="koboSpan" id="kobo.257.1"> value and the updating function. </span><span class="koboSpan" id="kobo.257.2">This is exactly the same as what </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">useValue</span></strong><span class="koboSpan" id="kobo.259.1"> returns.</span></p>
			<p><span class="koboSpan" id="kobo.260.1">Next, we define the second component, </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">TextBox</span></strong><span class="koboSpan" id="kobo.262.1">, which shows an input field for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">text</span></strong><span class="koboSpan" id="kobo.264.1"> property of the state:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.265.1">const TextBox = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.266.1">  const [state, setState] = useStateContext();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.267.1">  const setText = (text: string) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.268.1">    setState((prev) =&gt; ({ ...prev, text }));</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.269.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.270.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.271.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.272.1">      &lt;input</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.273.1">        value={state.text}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.274.1">        onChange={(e) =&gt; setText(e.target.value)}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.275.1">      /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.276.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.277.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.278.1">};</span></p>
			<p><span class="koboSpan" id="kobo.279.1">We</span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.280.1"> again </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.281.1">use </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">useStateContext</span></strong><span class="koboSpan" id="kobo.283.1"> and get the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">state</span></strong><span class="koboSpan" id="kobo.285.1"> value and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">setState</span></strong><span class="koboSpan" id="kobo.287.1"> function. </span><span class="koboSpan" id="kobo.287.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">setText</span></strong><span class="koboSpan" id="kobo.289.1"> function takes a string argument and invokes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">setState</span></strong><span class="koboSpan" id="kobo.291.1"> function.</span></p>
			<p><span class="koboSpan" id="kobo.292.1">Finally, we define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">App</span></strong><span class="koboSpan" id="kobo.294.1"> component, which has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">Provider</span></strong><span class="koboSpan" id="kobo.296.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">Counter</span></strong><span class="koboSpan" id="kobo.298.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">TextBox</span></strong><span class="koboSpan" id="kobo.300.1"> components in it:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.301.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.302.1">  &lt;Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.303.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.304.1">      &lt;Counter /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.305.1">      &lt;Counter /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.306.1">      &lt;TextBox /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.307.1">      &lt;TextBox /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.308.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.309.1">  &lt;/Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.310.1">);</span></p>
			<p><span class="koboSpan" id="kobo.311.1">How does this app behave? </span><span class="koboSpan" id="kobo.311.2">The Context handles the state object as a whole, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">useContext</span></strong><span class="koboSpan" id="kobo.313.1"> will trigger re-renders when the state object changes. </span><span class="koboSpan" id="kobo.313.2">Even if only a single property changes in the state object, all </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">useContext</span></strong><span class="koboSpan" id="kobo.315.1"> hooks trigger re-renders. </span><span class="koboSpan" id="kobo.315.2">This means that if we click a button in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">Counter</span></strong><span class="koboSpan" id="kobo.317.1"> component, it increments the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">count</span></strong><span class="koboSpan" id="kobo.319.1"> property of the state object, and it causes both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">Counter</span></strong><span class="koboSpan" id="kobo.321.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">TextBox</span></strong><span class="koboSpan" id="kobo.323.1"> components to re-render. </span><span class="koboSpan" id="kobo.323.2">While the </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">Counter</span></strong><span class="koboSpan" id="kobo.325.1"> component re-renders with the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">count</span></strong><span class="koboSpan" id="kobo.327.1"> value, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">TextBox</span></strong><span class="koboSpan" id="kobo.329.1"> component re-renders with the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">text</span></strong><span class="koboSpan" id="kobo.331.1"> value. </span><span class="koboSpan" id="kobo.331.2">This is an extra re-render.</span></p>
			<p><span class="koboSpan" id="kobo.332.1">The extra re-render behavior with Context is expected, and if we want to avoid it, we should split it into smaller pieces. </span><span class="koboSpan" id="kobo.332.2">Refer to </span><a href="B17780_03_Final_VK_ePub.xhtml#_idTextAnchor049"><em class="italic"><span class="koboSpan" id="kobo.333.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.334.1">, </span><em class="italic"><span class="koboSpan" id="kobo.335.1">Sharing the Component State with Context</span></em><span class="koboSpan" id="kobo.336.1">, to learn more about best practices with React Context.</span></p>
			<p><span class="koboSpan" id="kobo.337.1">Now, what does it look like with React Tracked? </span><span class="koboSpan" id="kobo.337.2">Let's convert the previous example to a new example with</span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.338.1"> React </span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.339.1">Tracked. </span><span class="koboSpan" id="kobo.339.2">First, we import </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">createContainer</span></strong><span class="koboSpan" id="kobo.341.1"> from the React Tracked library:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.342.1">import { createContainer } from "react-tracked";</span></p>
			<p><span class="koboSpan" id="kobo.343.1">We then use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">useValue</span></strong><span class="koboSpan" id="kobo.345.1"> hook defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">const useValue = () =&gt; useState({ count: 0, text: "hello" });</span></strong><span class="koboSpan" id="kobo.347.1"> and call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">createContainer</span></strong><span class="koboSpan" id="kobo.349.1"> function:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.350.1">const { Provider, useTracked } = </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.351.1">  createContainer(useValue);</span></p>
			<p><span class="koboSpan" id="kobo.352.1">From the results, </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">Provider</span></strong><span class="koboSpan" id="kobo.354.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">useTracked</span></strong><span class="koboSpan" id="kobo.356.1"> are extracted. </span><span class="koboSpan" id="kobo.356.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">Provider</span></strong><span class="koboSpan" id="kobo.358.1"> component can be used in the same way as in the previous example of this section. </span><span class="koboSpan" id="kobo.358.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">useTracked</span></strong><span class="koboSpan" id="kobo.360.1"> hook can be used in the same way as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">useStateContext</span></strong><span class="koboSpan" id="kobo.362.1"> hook we defined in the previous example of this section.</span></p>
			<p><span class="koboSpan" id="kobo.363.1">Using the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">useTracked</span></strong><span class="koboSpan" id="kobo.365.1"> hook, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">Counter</span></strong><span class="koboSpan" id="kobo.367.1"> component becomes as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.368.1">const Counter = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.369.1">  const [state, setState] = useTracked();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.370.1">  const inc = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.371.1">    setState(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.372.1">      (prev) =&gt; ({ ...prev, count: prev.count + 1 })</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.373.1">    );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.374.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.375.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.376.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.377.1">      count: {state.count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.378.1">      &lt;button onClick={inc}&gt;+1&lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.379.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.380.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.381.1">};</span></p>
			<p><span class="koboSpan" id="kobo.382.1">We</span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.383.1"> simply </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.384.1">replaced </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">useStateContext</span></strong><span class="koboSpan" id="kobo.386.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">useTracked</span></strong><span class="koboSpan" id="kobo.388.1">. </span><span class="koboSpan" id="kobo.388.2">The rest of the code is the same.</span></p>
			<p><span class="koboSpan" id="kobo.389.1">Likewise, the following is the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">TextBox</span></strong><span class="koboSpan" id="kobo.391.1"> component:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.392.1">const TextBox = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.393.1">  const [state, setState] = useTracked();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.394.1">  const setText = (text: string) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.395.1">    setState((prev) =&gt; ({ ...prev, text }));</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.396.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.397.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.398.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.399.1">      &lt;input</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.400.1">        value={state.text}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.401.1">        onChange={(e) =&gt; setText(e.target.value)}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.402.1">      /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.403.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.404.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.405.1">};</span></p>
			<p><span class="koboSpan" id="kobo.406.1">The only change is the replacement of </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">useStateContext</span></strong><span class="koboSpan" id="kobo.408.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">useTracked</span></strong><span class="koboSpan" id="kobo.410.1">.</span></p>
			<p><span class="koboSpan" id="kobo.411.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">App</span></strong><span class="koboSpan" id="kobo.413.1"> component is </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.414.1">exactly</span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.415.1"> the same as in the previous example of this section, using the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">Provider</span></strong><span class="koboSpan" id="kobo.417.1"> component:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.418.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.419.1">  &lt;Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.420.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.421.1">      &lt;Counter /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.422.1">      &lt;Counter /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.423.1">      &lt;TextBox /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.424.1">      &lt;TextBox /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.425.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.426.1">  &lt;/Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.427.1">);</span></p>
			<p><span class="koboSpan" id="kobo.428.1">How does this new app behave? </span><span class="koboSpan" id="kobo.428.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">state</span></strong><span class="koboSpan" id="kobo.430.1"> object returned by </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">useTracked</span></strong><span class="koboSpan" id="kobo.432.1"> is tracked, which means the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">useTracked</span></strong><span class="koboSpan" id="kobo.434.1"> hook remembers which properties of </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">state</span></strong><span class="koboSpan" id="kobo.436.1"> are accessed. </span><span class="koboSpan" id="kobo.436.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">useTracked</span></strong><span class="koboSpan" id="kobo.438.1"> hook will trigger a re-render only if the accessed properties are changed. </span><span class="koboSpan" id="kobo.438.2">Hence, if you click a button in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">Counter</span></strong><span class="koboSpan" id="kobo.440.1"> component, only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">Counter</span></strong><span class="koboSpan" id="kobo.442.1"> component re-renders, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">TextBox</span></strong><span class="koboSpan" id="kobo.444.1"> component doesn't re-render, as shown here:</span></p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<span class="koboSpan" id="kobo.445.1"><img src="image/Figure_10.1_B17780.jpg" alt="Figure 10.1 – A screenshot of the app with React Tracked and useState "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.446.1">Figure 10.1 – A screenshot of the app with React Tracked and useState</span></p>
			<p><span class="koboSpan" id="kobo.447.1">Essentially, what we changed is </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">createContainer</span></strong><span class="koboSpan" id="kobo.449.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">createContext</span></strong><span class="koboSpan" id="kobo.451.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">useTracked</span></strong><span class="koboSpan" id="kobo.453.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">useStateContext</span></strong><span class="koboSpan" id="kobo.455.1">. </span><span class="koboSpan" id="kobo.455.2">The result gives us optimized re-renders. </span><span class="koboSpan" id="kobo.455.3">This is the state usage tracking feature.</span></p>
			<p><span class="koboSpan" id="kobo.456.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">useValue</span></strong><span class="koboSpan" id="kobo.458.1"> custom </span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.459.1">hook </span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.460.1">we passed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">createContainer</span></strong><span class="koboSpan" id="kobo.462.1"> function can be anything as long as it returns a tuple such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">useState</span></strong><span class="koboSpan" id="kobo.464.1">. </span><span class="koboSpan" id="kobo.464.2">Let's look at another example using </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">useReducer</span></strong><span class="koboSpan" id="kobo.466.1">.</span></p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.467.1">Using React Tracked with useReducer</span></h2>
			<p><span class="koboSpan" id="kobo.468.1">In this</span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.469.1"> example, we</span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.470.1"> use </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">useReducer</span></strong><span class="koboSpan" id="kobo.472.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">useState</span></strong><span class="koboSpan" id="kobo.474.1">. </span><span class="koboSpan" id="kobo.474.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">useReducer</span></strong><span class="koboSpan" id="kobo.476.1"> hook is an advanced hook with more features, but it's mostly syntactic difference. </span><span class="koboSpan" id="kobo.476.2">Refer to the </span><em class="italic"><span class="koboSpan" id="kobo.477.1">Exploring the similarity and difference between useState and useReducer</span></em><span class="koboSpan" id="kobo.478.1"> section in </span><a href="B17780_01_Final_VK_ePub.xhtml#_idTextAnchor012"><em class="italic"><span class="koboSpan" id="kobo.479.1">Chapter 1</span></em></a><span class="koboSpan" id="kobo.480.1">, </span><em class="italic"><span class="koboSpan" id="kobo.481.1">What Is Micro State Management with React Hooks?</span></em><span class="koboSpan" id="kobo.482.1">, for more detailed discussions.</span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.483.1">Important Note about useReducer</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.484.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">useReducer</span></strong><span class="koboSpan" id="kobo.486.1"> hook is an official React hook. </span><span class="koboSpan" id="kobo.486.2">It takes a reducer function to update states. </span><span class="koboSpan" id="kobo.486.3">A reducer function is a programming pattern, not related to React or even JavaScript. </span><span class="koboSpan" id="kobo.486.4">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">useReducer</span></strong><span class="koboSpan" id="kobo.488.1"> hook applies the pattern to states. </span><span class="koboSpan" id="kobo.488.2">The reducer function in React is popularized by Redux. </span><span class="koboSpan" id="kobo.488.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">useReducer</span></strong><span class="koboSpan" id="kobo.490.1"> covers Redux's use cases in terms of the reduce pattern. </span><span class="koboSpan" id="kobo.490.2">However, it doesn't cover the other Redux use cases, such as React Redux and store enhancer or middleware. </span><span class="koboSpan" id="kobo.490.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">useReducer</span></strong><span class="koboSpan" id="kobo.492.1"> hook accepts any kind of actions unlike Redux, which requires an action to be an object with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">type</span></strong><span class="koboSpan" id="kobo.494.1"> property.</span></p>
			<p><span class="koboSpan" id="kobo.495.1">The new </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">useValue</span></strong><span class="koboSpan" id="kobo.497.1"> hook uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">useReducer</span></strong><span class="koboSpan" id="kobo.499.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">useEffect</span></strong><span class="koboSpan" id="kobo.501.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">useReducer</span></strong><span class="koboSpan" id="kobo.503.1"> is defined with a reducer function and an initial state. </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">useEffect</span></strong><span class="koboSpan" id="kobo.505.1"> has a function that logs the state </span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.506.1">value</span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.507.1"> to the console. </span><span class="koboSpan" id="kobo.507.2">The following is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">useValue</span></strong><span class="koboSpan" id="kobo.509.1"> code in TypeScript:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.510.1">const useValue = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.511.1">  type State = { count: number; text: string };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.512.1">  type Action =</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.513.1">    | { type: "INC" }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.514.1">    | { type: "SET_TEXT"; text: string };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.515.1">  const [state, dispatch] = useReducer(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.516.1">    (state: State, action: Action) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.517.1">      if (action.type === "INC") {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.518.1">        return { ...state, count: state.count + 1 };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.519.1">      }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.520.1">      if (action.type === "SET_TEXT") {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.521.1">        return { ...state, text: action.text };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.522.1">      }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.523.1">      throw new Error("unknown action type");</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.524.1">    },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.525.1">    { count: 0, text: "hello" }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.526.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.527.1">  useEffect(() =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.528.1">    console.log("latest state", state);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.529.1">  }, [state]);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.530.1">  return [state, dispatch] as const;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.531.1">};</span></p>
			<p><span class="koboSpan" id="kobo.532.1">The reducer function accepts action types of </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">INC</span></strong><span class="koboSpan" id="kobo.534.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">SET_TEXT</span></strong><span class="koboSpan" id="kobo.536.1">. </span><span class="koboSpan" id="kobo.536.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">useEffect</span></strong><span class="koboSpan" id="kobo.538.1"> hook is used in</span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.539.1"> console logging, but it's not limited to it. </span><span class="koboSpan" id="kobo.539.2">For</span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.540.1"> example, it can interact with remote resources. </span><span class="koboSpan" id="kobo.540.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">useValue</span></strong><span class="koboSpan" id="kobo.542.1"> hook returns a tuple of </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">state</span></strong><span class="koboSpan" id="kobo.544.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">dispatch</span></strong><span class="koboSpan" id="kobo.546.1">. </span><span class="koboSpan" id="kobo.546.2">As long as the return tuple follows this shape, we can implement the hook as we like. </span><span class="koboSpan" id="kobo.546.3">For example, we could use more than one </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">useState</span></strong><span class="koboSpan" id="kobo.548.1"> hook.</span></p>
			<p><span class="koboSpan" id="kobo.549.1">Using the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">useValue</span></strong><span class="koboSpan" id="kobo.551.1"> hook, we run </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">createContainer</span></strong><span class="koboSpan" id="kobo.553.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.554.1">const { Provider, useTracked } = createContainer(useValue);</span></p>
			<p><span class="koboSpan" id="kobo.555.1">The way we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">createContainer</span></strong><span class="koboSpan" id="kobo.557.1"> doesn't change, even if we change </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">useValue</span></strong><span class="koboSpan" id="kobo.559.1">.</span></p>
			<p><span class="koboSpan" id="kobo.560.1">Using the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">useTracked</span></strong><span class="koboSpan" id="kobo.562.1"> hook, we implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">Counter</span></strong><span class="koboSpan" id="kobo.564.1"> component:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.565.1">const Counter = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.566.1">  const [state, dispatch] = useTracked();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.567.1">  const inc = () =&gt; dispatch({ type: "INC" });</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.568.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.569.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.570.1">      count: {state.count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.571.1">      &lt;button onClick={inc}&gt;+1&lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.572.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.573.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.574.1">};</span></p>
			<p><span class="koboSpan" id="kobo.575.1">Because </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">useTracked</span></strong><span class="koboSpan" id="kobo.577.1"> returns the same shaped tuple as </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">useValue</span></strong><span class="koboSpan" id="kobo.579.1"> returns, we name the second item in the tuple </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">dispatch</span></strong><span class="koboSpan" id="kobo.581.1">, which is a function that dispatches an action. </span><span class="koboSpan" id="kobo.581.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">Counter</span></strong><span class="koboSpan" id="kobo.583.1"> component</span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.584.1"> dispatches</span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.585.1"> an </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">INC</span></strong><span class="koboSpan" id="kobo.587.1"> action.</span></p>
			<p><span class="koboSpan" id="kobo.588.1">Next is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">TextBox</span></strong><span class="koboSpan" id="kobo.590.1"> component:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.591.1">const TextBox = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.592.1">  const [state, dispatch] = useTracked();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.593.1">  const setText = (text: string) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.594.1">    dispatch({ type: "SET_TEXT", text });</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.595.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.596.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.597.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.598.1">      &lt;input</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.599.1">        value={state.text}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.600.1">        onChange={(e) =&gt; setText(e.target.value)}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.601.1">      /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.602.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.603.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.604.1">};</span></p>
			<p><span class="koboSpan" id="kobo.605.1">Likewise, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">dispatch</span></strong><span class="koboSpan" id="kobo.607.1"> function is used for a </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">SET_TEXT</span></strong><span class="koboSpan" id="kobo.609.1"> action.</span></p>
			<p><span class="koboSpan" id="kobo.610.1">Finally, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">App</span></strong><span class="koboSpan" id="kobo.612.1"> component:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.613.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.614.1">  &lt;Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.615.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.616.1">      &lt;Counter /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.617.1">      &lt;Counter /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.618.1">      &lt;TextBox /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.619.1">      &lt;TextBox /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.620.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.621.1">  &lt;/Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.622.1">);</span></p>
			<p><span class="koboSpan" id="kobo.623.1">The behavior of the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">App</span></strong><span class="koboSpan" id="kobo.625.1"> component is exactly the same as the previous one. </span><span class="koboSpan" id="kobo.625.2">The difference between the examples with </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">useState</span></strong><span class="koboSpan" id="kobo.627.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">useReducer</span></strong><span class="koboSpan" id="kobo.629.1"> is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">useValue</span></strong><span class="koboSpan" id="kobo.631.1"> returns a tuple of </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">state</span></strong><span class="koboSpan" id="kobo.633.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">dispatch</span></strong><span class="koboSpan" id="kobo.635.1">; thus </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">useTracked</span></strong><span class="koboSpan" id="kobo.637.1"> also returns a tuple of </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">state</span></strong><span class="koboSpan" id="kobo.639.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">dispatch</span></strong><span class="koboSpan" id="kobo.641.1">.</span></p>
			<p><span class="koboSpan" id="kobo.642.1">The reason why React Tracked can optimize re-renders is not only state usage tracking but also its internal library called </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">use-context-selector</span></strong><span class="koboSpan" id="kobo.644.1"> (</span><a href="https://github.com/dai-shi/use-context-selector"><span class="koboSpan" id="kobo.645.1">https://github.com/dai-shi/use-context-selector</span></a><span class="koboSpan" id="kobo.646.1">). </span><span class="koboSpan" id="kobo.646.2">It allows us to subscribe to the Context value with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">selector</span></strong><span class="koboSpan" id="kobo.648.1"> function. </span><span class="koboSpan" id="kobo.648.2">This subscription bypasses the limitations of React Context.</span></p>
			<p><span class="koboSpan" id="kobo.649.1">In this section, we saw a </span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.650.1">basic </span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.651.1">example with bare React Context, and two examples with React Tracked with </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">useState</span></strong><span class="koboSpan" id="kobo.653.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">useReducer</span></strong><span class="koboSpan" id="kobo.655.1">. </span><span class="koboSpan" id="kobo.655.2">In the next section, we will learn a usage of React Tracked with React Redux, which uses the state usage tracking feature without </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">use-context-selector</span></strong><span class="koboSpan" id="kobo.657.1">.</span></p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.658.1">Using React Tracked with React Redux</span></h1>
			<p><span class="koboSpan" id="kobo.659.1">The primary</span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.660.1"> use case of React Tracked is to replace a use case of React Context. </span><span class="koboSpan" id="kobo.660.2">This is done by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">use-context-selector</span></strong><span class="koboSpan" id="kobo.662.1"> internally.</span></p>
			<p><span class="koboSpan" id="kobo.663.1">React Tracked exposes a low-level function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">createTrackedSelector</span></strong><span class="koboSpan" id="kobo.665.1"> to cover non-React Context use cases. </span><span class="koboSpan" id="kobo.665.2">It takes a hook called </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">useSelector</span></strong><span class="koboSpan" id="kobo.667.1"> and returns a hook called </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">useTrackedState</span></strong><span class="koboSpan" id="kobo.669.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.670.1">const useTrackedState = createTrackedSelector(useSelector);</span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">useSelector</span></strong><span class="koboSpan" id="kobo.672.1"> is a hook that takes a selector function and returns the result of the selector function. </span><span class="koboSpan" id="kobo.672.2">It will trigger re-renders when the result changes. </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">useTrackedState</span></strong><span class="koboSpan" id="kobo.674.1"> is a hook that returns an entire state wrapped in proxies to track the </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">state</span></strong><span class="koboSpan" id="kobo.676.1"> usage.</span></p>
			<p><span class="koboSpan" id="kobo.677.1">Let's look at a concrete example with React Redux. </span><span class="koboSpan" id="kobo.677.2">This provides a </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">useSelector</span></strong><span class="koboSpan" id="kobo.679.1"> hook, and it's straightforward to apply </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">createTrackedSelector</span></strong><span class="koboSpan" id="kobo.681.1">.</span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.682.1">Important Note about React Redux</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.683.1">React Redux uses React Context internally, but it doesn't use Context for propagating a state value. </span><span class="koboSpan" id="kobo.683.2">It uses React Context for dependency injection, and the state propagation is done by subscription. </span><span class="koboSpan" id="kobo.683.3">React Redux's </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">useSelector</span></strong><span class="koboSpan" id="kobo.685.1"> is optimized to re-render only if the selector result changes. </span><span class="koboSpan" id="kobo.685.2">This is not possible with Context propagation at the time of writing. </span><span class="koboSpan" id="kobo.685.3">There are many other libraries that take the same approach, and in fact, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">use-context-selector</span></strong><span class="koboSpan" id="kobo.687.1"> UserLand solution is the same too.</span></p>
			<p><span class="koboSpan" id="kobo.688.1">First, we import some </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.689.1">functions from libraries, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">redux</span></strong><span class="koboSpan" id="kobo.691.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">react-redux</span></strong><span class="koboSpan" id="kobo.693.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">react-tracked</span></strong><span class="koboSpan" id="kobo.695.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.696.1">import { createStore } from "redux";</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.697.1">import {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.698.1">  Provider,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.699.1">  useDispatch,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.700.1">  useSelector,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.701.1">} from "react-redux";</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.702.1">import { createTrackedSelector } from "react-tracked";</span></p>
			<p><span class="koboSpan" id="kobo.703.1">The first two import lines are a traditional React Redux setup. </span><span class="koboSpan" id="kobo.703.2">The third line is our addition.</span></p>
			<p><span class="koboSpan" id="kobo.704.1">Next, we define a Redux store with </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">initialState</span></strong><span class="koboSpan" id="kobo.706.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">reducer</span></strong><span class="koboSpan" id="kobo.708.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.709.1">type State = { count: number; text: string };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.710.1">type Action =</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.711.1">  | { type: "INC" }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.712.1">  | { type: "SET_TEXT"; text: string };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.713.1">const initialState: State = { count: 0, text: "hello" };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.714.1">const reducer = (state = initialState, action: Action) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.715.1">  if (action.type === "INC") {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.716.1">    return { ...state, count: state.count + 1 };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.717.1">  }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.718.1">  if (action.type === "SET_TEXT") {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.719.1">    return { ...state, text: action.text };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.720.1">  }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.721.1">  return state;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.722.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.723.1">const store = createStore(reducer);</span></p>
			<p><span class="koboSpan" id="kobo.724.1">This is one traditional</span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.725.1"> way to create a Redux store. </span><span class="koboSpan" id="kobo.725.2">Note that it has nothing to do with React Tracked, and any way of creating a Redux store would work.</span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">createTrackedSelector</span></strong><span class="koboSpan" id="kobo.727.1"> allows us to create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">useTrackedState</span></strong><span class="koboSpan" id="kobo.729.1"> hook from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">useSelector</span></strong><span class="koboSpan" id="kobo.731.1"> hook, which is imported directly from </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">react-redux</span></strong><span class="koboSpan" id="kobo.733.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.734.1">const useTrackedState = </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.735.1">  createTrackedSelector&lt;State&gt;(useSelector);</span></p>
			<p><span class="koboSpan" id="kobo.736.1">We need to explicitly type the hook with </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">&lt;State&gt;</span></strong><span class="koboSpan" id="kobo.738.1">.</span></p>
			<p><span class="koboSpan" id="kobo.739.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">useTrackedState</span></strong><span class="koboSpan" id="kobo.741.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">Counter</span></strong><span class="koboSpan" id="kobo.743.1"> component is defined as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.744.1">const Counter = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.745.1">  const dispatch = useDispatch();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.746.1">  const { count } = useTrackedState();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.747.1">  const inc = () =&gt; dispatch({ type: "INC" });</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.748.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.749.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.750.1">      count: {count} &lt;button onClick={inc}&gt;+1&lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.751.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.752.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.753.1">};</span></p>
			<p><span class="koboSpan" id="kobo.754.1">This should be mostly like a normal React Redux pattern except for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">useTrackedState</span></strong><span class="koboSpan" id="kobo.756.1"> line. </span><span class="koboSpan" id="kobo.756.2">In React Redux, it would be as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.757.1">  const count = useSelector((state) =&gt; state.count);</span></p>
			<p><span class="koboSpan" id="kobo.758.1">The change may seem trivial, but with </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">useSelector</span></strong><span class="koboSpan" id="kobo.760.1">, developers have more control and responsibility for re-renders, whereas with </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">useTrackedState</span></strong><span class="koboSpan" id="kobo.762.1">, the hook controls re-renders automatically.</span></p>
			<p><span class="koboSpan" id="kobo.763.1">Likewise, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">TextBox</span></strong><span class="koboSpan" id="kobo.765.1"> component </span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.766.1">is implemented as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.767.1">const TextBox = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.768.1">  const dispatch = useDispatch();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.769.1">  const state = useTrackedState();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.770.1">  const setText = (text: string) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.771.1">    dispatch({ type: "SET_TEXT", text });</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.772.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.773.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.774.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.775.1">      &lt;input</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.776.1">        value={state.text}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.777.1">        onChange={(e) =&gt; setText(e.target.value)}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.778.1">      /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.779.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.780.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.781.1">};</span></p>
			<p><span class="koboSpan" id="kobo.782.1">Again, we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">useTrackedState</span></strong><span class="koboSpan" id="kobo.784.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">useSelector</span></strong><span class="koboSpan" id="kobo.786.1"> for automatic render optimization. </span><span class="koboSpan" id="kobo.786.2">To explain how automatic render optimization is useful, let's imagine that </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">TextBox</span></strong><span class="koboSpan" id="kobo.788.1"> takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">showCount</span></strong><span class="koboSpan" id="kobo.790.1"> prop property, which is a Boolean value to show the </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">count</span></strong><span class="koboSpan" id="kobo.792.1"> value in </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">state</span></strong><span class="koboSpan" id="kobo.794.1">. </span><span class="koboSpan" id="kobo.794.2">We </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.795.1">can modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">TextBox</span></strong><span class="koboSpan" id="kobo.797.1"> component as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.798.1">const TextBox = ({ showCount }: { showCount: boolean }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.799.1">  const dispatch = useDispatch();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.800.1">  const state = useTrackedState();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.801.1">  const setText = (text: string) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.802.1">    dispatch({ type: "SET_TEXT", text });</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.803.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.804.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.805.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.806.1">      &lt;input</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.807.1">        value={state.text}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.808.1">        onChange={(e) =&gt; setText(e.target.value)}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.809.1">      /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.810.1">      {showCount &amp;&amp; &lt;span&gt;{state.count}&lt;/span&gt;}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.811.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.812.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.813.1">};</span></p>
			<p><span class="koboSpan" id="kobo.814.1">Note that we didn't change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">useTrackedState</span></strong><span class="koboSpan" id="kobo.816.1"> line at all. </span><span class="koboSpan" id="kobo.816.2">With a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">useSelector</span></strong><span class="koboSpan" id="kobo.818.1">, implementing the same behavior would be difficult.</span></p>
			<p><span class="koboSpan" id="kobo.819.1">Finally, the following is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">App</span></strong><span class="koboSpan" id="kobo.821.1"> component to combine all components:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.822.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.823.1">  &lt;Provider store={store}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.824.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.825.1">      &lt;Counter /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.826.1">      &lt;Counter /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.827.1">      &lt;TextBox /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.828.1">      &lt;TextBox /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.829.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.830.1">  &lt;/Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.831.1">);</span></p>
			<p><span class="koboSpan" id="kobo.832.1">This is exactly the same as using normal React Redux without React Tracked. </span><span class="koboSpan" id="kobo.832.2">The re-renders are optimized</span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.833.1"> in this app, which means clicking a button only triggers the </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">Counter</span></strong><span class="koboSpan" id="kobo.835.1"> component to re-render, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">TextBox</span></strong><span class="koboSpan" id="kobo.837.1"> component won't re-render, as shown in the following figure:</span></p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<span class="koboSpan" id="kobo.838.1"><img src="image/Figure_10.2_B17780.jpg" alt="Figure 10.2 – A screenshot of the app with React Tracked and React Redux "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.839.1">Figure 10.2 – A screenshot of the app with React Tracked and React Redux</span></p>
			<p><span class="koboSpan" id="kobo.840.1">In this section, we learned how to use React Tracked with a non-React Context use case. </span><span class="koboSpan" id="kobo.840.2">Next, we will discuss what</span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.841.1"> React Tracked can look like with a future version of React.</span></p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.842.1">Future prospects</span></h1>
			<p><span class="koboSpan" id="kobo.843.1">The implementation</span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.844.1"> of React Tracked depends on two internal libraries:</span></p>
			<ul>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">proxy-compare</span></strong><span class="koboSpan" id="kobo.846.1"> (</span><a href="https://github.com/dai-shi/proxy-compare"><span class="koboSpan" id="kobo.847.1">https://github.com/dai-shi/proxy-compare</span></a><span class="koboSpan" id="kobo.848.1">)</span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">use-context-selector</span></strong><span class="koboSpan" id="kobo.850.1"> (</span><a href="https://github.com/dai-shi/use-context-selector"><span class="koboSpan" id="kobo.851.1">https://github.com/dai-shi/use-context-selector</span></a><span class="koboSpan" id="kobo.852.1">)</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.853.1">As we learned in the </span><em class="italic"><span class="koboSpan" id="kobo.854.1">Using React Tracked with useState and useReducer</span></em><span class="koboSpan" id="kobo.855.1"> section and the </span><em class="italic"><span class="koboSpan" id="kobo.856.1">Using React Tracked with React Redux</span></em><span class="koboSpan" id="kobo.857.1"> section, there are two ways to use React Tracked. </span><span class="koboSpan" id="kobo.857.2">The first way is via React Context with </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">createContainer</span></strong><span class="koboSpan" id="kobo.859.1"> and the second is via React Redux with </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">createTrackedSelector</span></strong><span class="koboSpan" id="kobo.861.1">. </span><span class="koboSpan" id="kobo.861.2">The base function is </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">createTrackedSelector</span></strong><span class="koboSpan" id="kobo.863.1">, which is implemented with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">proxy-compare</span></strong><span class="koboSpan" id="kobo.865.1"> library. </span><span class="koboSpan" id="kobo.865.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">createContainer</span></strong><span class="koboSpan" id="kobo.867.1"> function is a higher abstraction, which is implemented with </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">createTrackedSelector</span></strong><span class="koboSpan" id="kobo.869.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">use-context-selector</span></strong><span class="koboSpan" id="kobo.871.1"> library.</span></p>
			<p><span class="koboSpan" id="kobo.872.1">In terms of the use of Context in React Tracked, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">use-context-selector</span></strong><span class="koboSpan" id="kobo.874.1"> library is important. </span><span class="koboSpan" id="kobo.874.2">What is the role of </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">use-context-selector</span></strong><span class="koboSpan" id="kobo.876.1">? </span><span class="koboSpan" id="kobo.876.2">It provides a </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">useContextSelector</span></strong><span class="koboSpan" id="kobo.878.1"> hook. </span><span class="koboSpan" id="kobo.878.2">As we learned in the </span><em class="italic"><span class="koboSpan" id="kobo.879.1">Understanding Context</span></em><span class="koboSpan" id="kobo.880.1"> section in </span><a href="B17780_03_Final_VK_ePub.xhtml#_idTextAnchor049"><em class="italic"><span class="koboSpan" id="kobo.881.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.882.1">, </span><em class="italic"><span class="koboSpan" id="kobo.883.1">Sharing the Component State with Context</span></em><span class="koboSpan" id="kobo.884.1">, React Context is designed so that all Context consumer components re-render when the Context value is changed. </span><span class="koboSpan" id="kobo.884.2">There is a proposal to improve the Context behavior – </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">useContextSelector</span></strong><span class="koboSpan" id="kobo.886.1">. </span><span class="koboSpan" id="kobo.886.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">use-context-selector</span></strong><span class="koboSpan" id="kobo.888.1"> library is a Userland library that emulates the proposed </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">useContextSelector</span></strong><span class="koboSpan" id="kobo.890.1"> hook as much as possible.</span></p>
			<p><span class="koboSpan" id="kobo.891.1">It's very uncertain at the point of writing, but a future version of React may implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">useContextSelector</span></strong><span class="koboSpan" id="kobo.893.1">, or a similar form of it. </span><span class="koboSpan" id="kobo.893.2">In this situation, React Tracked can easily migrate from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">use-context-selector</span></strong><span class="koboSpan" id="kobo.895.1"> library to a native </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">useContextSelector</span></strong><span class="koboSpan" id="kobo.897.1">. </span><span class="koboSpan" id="kobo.897.2">Hopefully, this should give full compatibility with React features.</span></p>
			<p><span class="koboSpan" id="kobo.898.1">Abstracting </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">use-context-selector</span></strong><span class="koboSpan" id="kobo.900.1"> away in the implementation of React Tracked helps migration. </span><span class="koboSpan" id="kobo.900.2">If React has an official </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">useContextSelector</span></strong><span class="koboSpan" id="kobo.902.1"> hook in the future, React Tracked can migrate without changing its public API. </span><span class="koboSpan" id="kobo.902.2">In this implementation design, </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">createTrackedSelector</span></strong><span class="koboSpan" id="kobo.904.1"> is a building block function in React Tracked, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">createContainer</span></strong><span class="koboSpan" id="kobo.906.1"> is a glue function. </span><span class="koboSpan" id="kobo.906.2">Exporting both functions allows us to have both usages.</span></p>
			<p><span class="koboSpan" id="kobo.907.1">In this section, we</span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.908.1"> discussed the implementation design of React Tracked and how it can migrate to a possible future version of React.</span></p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.909.1">Summary</span></h1>
			<p><span class="koboSpan" id="kobo.910.1">In this chapter, we learned about a library – React Tracked. </span><span class="koboSpan" id="kobo.910.2">This library has two purposes. </span><span class="koboSpan" id="kobo.910.3">One purpose is to replace the use case of React Context. </span><span class="koboSpan" id="kobo.910.4">The other purpose is to enhance the selector hook provided by some other libraries, such as React Redux.</span></p>
			<p><span class="koboSpan" id="kobo.911.1">Technically, the React Tracked library is not a global state library. </span><span class="koboSpan" id="kobo.911.2">It's to be used with state functions, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">useState</span></strong><span class="koboSpan" id="kobo.913.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">useReducer</span></strong><span class="koboSpan" id="kobo.915.1">, or Redux. </span><span class="koboSpan" id="kobo.915.2">All React Tracked provides is a feature to optimize re-renders.</span></p>
			<p><span class="koboSpan" id="kobo.916.1">In the next chapter, we will compare the three libraries for global state, namely Zustand, Jotai, and Valtio, and discuss global state patterns to wrap up this book.</span></p>
		</div>
	</body></html>