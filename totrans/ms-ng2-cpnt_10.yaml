- en: Chapter 10. Making Things Pluggable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'm a huge fan of plugin architectures. Besides their tremendously positive
    effect on your application and scope management, they are also a lot of fun to
    develop. I'd recommend integrating a plugin architecture in their library or application
    to anyone who asks me. A good plugin architecture allows you to write a concise
    application core and provide additional functionality via plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Designing your whole application in a way that it allows you to build a plugin
    architecture has a great effect on the extensibility of your system. This is because
    you're making your application open for extensibility but closing it for modification.
  prefs: []
  type: TYPE_NORMAL
- en: While authoring my open source projects, I also experienced that a plugin architecture
    helps you manage the scope of your project. Sometimes, a requested feature is
    really nice and helpful, but it will still bloat the library core. Instead of
    bloating your whole application or library with such features, you can simply
    write a plugin to get the job done.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will create our own plugin architecture that will help us
    extend the features of our application without bloating its core. We'll first
    build the plugin API in the core of our application and then use the API to implement
    a nice little agile plugin, which helps us to estimate tasks using story points.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing a plugin architecture, based on the Angular ecosystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a decorator-based plugin API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `ComponentResolver` and `ViewContainerRef` to instantiate plugin components
    into predefined slots in our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a plugin-loading mechanism using SystemJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a reactive approach in our plugin architecture to enable plug and play
    style plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an agile plugin to record story points using the new plugin API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugin architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At a higher level, a plugin architecture should fulfil at least the following
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extensibility**: The main idea behind plugins is to allow the extension of
    the core functionality using isolated bundles of code. A great plugin architecture
    allows you to extend the core seamlessly and without noticeable performance losses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portability**: Plugins should be isolated enough so that they can be plugged
    into the system during runtime. There shouldn''t be a necessity to rebuild a system
    to enable plugins. Ideally, plugins can even be loaded at any time during runtime.
    They can be deactivated and activated and should not cause the system to run into
    an inconsistent state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composability**: A plugin system should allow the use of many plugins in
    parallel and allow an extension of the system by compositing multiple plugins
    together. Ideally, the system also includes dependency management, plugin version
    management, and plugin intercommunication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a lot of different approaches on how to implement a plugin architecture.
    Although these approaches can vary a lot, there's almost always a mechanism in
    place that provides unified extension points. Without this, it will be hard to
    extend a system uniformly.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ve worked with some plugin architectures in the past, and besides using
    existing plugin mechanisms, I''ve also enjoyed designing some of them myself.
    The following list should provide an idea about some of the approaches that you
    can use when designing a plugin system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DSL**: Using domain-specific languages is one way to implement a pluggable
    architecture. After you''ve implemented the core of your application, you can
    develop an API or even a scripting language that allows you to develop further
    features using this DSL. A lot of video game engines and CG applications rely
    on this approach. Although this approach is very flexible, it can also lead to
    performance issues quickly, and it''s prone to introducing complexity. Mostly,
    the prerequisites to implement such an architecture are to expose very low-level
    core operations (such as adding UI elements, configuring process flows, and so
    on) into the DSL, which does not provide clear boundaries and extension points
    but is extremely flexible. Some examples of DSL-based plugin systems are most
    of Adobe''s CG applications, 3D Studio Max, and Maya, but also game engines, such
    as Unreal Engine or the Real Virtuality Engine from Bohemia Interactive Studio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The core is the plugin system**: Another approach is to build such a sophisticated
    plugin architecture that it fulfils all the outlined requirements in the previous
    listing (extensibility, portability, and composability) and even some more sophisticated
    requirements on top. The core of your application is one large plugin system.
    Then, you start to implement everything as a plugin. Even the core concerns of
    your application will be implemented as plugins. A perfect example of this approach
    is the Eclipse IDE with its Equinox core. The problem with this approach is that
    you''re likely to run into performance problems as your application grows. As
    everything is a plugin, optimization is quite tricky, and plugin compatibility
    can make the application unstable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event-based extension points**: Also, a great way to provide extensibility
    of a system is by opening up the pipeline of your system to input from outside.
    Imagine that for every important step in your application, you notify the outside
    world about the step and allow interception before the application continues with
    processing. In this manner, a plugin will just be an adapter that listens for
    these pipeline events of your application and then modifies the behavior as required.
    A plugin itself can also emit events, which then can be processed by other plugins
    again. This architecture is really flexible, as it allows you to change the behavior
    of your core functionality without introducing too much complexity. It''s also
    fairly easy to implement this approach even after you''ve finished your core without
    any thoughts about a plugin system. I''ve been following this approach in my open
    source project Chartist and, so far, I''ve had very good results with it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plugin interfaces**: An application can expose a set of interfaces that define
    certain extension points. This approach is heavily used in the Java framework
    where it''s known as **Service Provider Interface** (**SPI**). Providers implement
    a certain contract, which allows the core system to rely on an interface rather
    than an implementation. These providers can then be cycled back into the system
    where they are made available to the framework and other providers. Although this
    is probably the safest way to provide extensibility in terms of uniformness, it''s
    also the most rigid one. A plugin will never be allowed to do anything else that
    was specified in the contract of the interfaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see that all four approaches vary a lot. From the top-most, which provides
    extreme flexibility at the cost of complexity and stability, to the bottom-most,
    which is very robust but also rigid.
  prefs: []
  type: TYPE_NORMAL
- en: The approach that you choose when implementing a plugin system heavily depends
    on the requirements for your application. If you do not plan on building an application
    that comes bundled in various flavors and where multiple versions for completely
    different concerns should exist, the approaches to the bottom of the preceding
    listing are probably more likely the ones that you should follow.
  prefs: []
  type: TYPE_NORMAL
- en: Pluggable UI components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The system that we''re going to build in this chapter borrows a lot of mechanisms
    that are already present in the Angular framework. In order to implement extensibility
    using plugins, we rely on the following core concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: We use directives to indicate extension points in the UI, which we call plugin
    slots. These plugin slot directives will be responsible for the dynamic instantiation
    of plugin components and will insert them into the application UI at the given
    position.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugins expose components using a concept that we call plugin placements. Plugin
    placements declare what components of a plugin should be placed into which plugin
    slots in the application. We also use plugin placements to decide the order in
    which components from different plugins should be inserted into the plugin slots.
    For this, we'll use a property called **priority**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the dependency injection of Angular to provide the instantiated plugin
    information into the plugin components. As the plugin components will be placed
    in a spot where there's already an injector present, they will be able to inject
    surrounding components and dependencies in order to connect to the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the following illustration to picture the architecture of our
    plugin system before we start implementing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pluggable UI components](img/image00349.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The plugin architecture that we'll implement in this chapter using some basic
    UML and cardinality annotations
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the different entities in this diagram and quickly explain what
    they do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PluginConfig`: This ES7 decorator is the key element when implementing a plugin.
    By annotating a plugin class using this decorator, we can store meta-information
    about the plugin, which will be used later by our plugin system. The metadata
    includes the plugin name, a description, and the placement information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PluginData`: This is an aggregation class that is used by the plugin system
    to couple the information about an instantiated plugin with the placement information
    (where plugin components should be instantiated). This entity is exposed in dependency
    injection once a plugin component is created. Any plugin component can make use
    of this entity to gather information about the instantiation or to gain access
    to the plugin instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PluginService`: This is the service used to glue our plugin system together.
    It''s mainly used to load plugins, remove plugins, or used by the `PluginSlot`
    directive to gather plugin components together that are relevant for creation
    in the plugin slot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PluginSlot`: This directive is used to mark UI extension points in our application.
    Wherever we''d like to make it possible for plugins to hook into our application
    user interface, we''ll place this directive. Plugin slots need to be named, and
    plugins use placement information to reference slots by their name. This way a
    plugin can provide different components for different slots in our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PluginComponent`: These are regular Angular components that come bundled with
    a plugin implementation. A plugin can provide multiple components configured on
    the plugin using a `PluginPlacement` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PluginPlacement`: This is used in the plugin configuration where a plugin
    can have multiple placement configurations. Each placement entity consist of a
    reference to a component, the name of the slot where the component should be instantiated,
    and a priority number that helps the plugin system to order plugin components
    correctly when multiple components get instantiated in the same slot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Plugin`: This is the actual plugin class when implementing a plugin. The class
    contains the plugin configuration annotated using the `PluginConfig` decorator.
    The plugin class is instantiated once in the application and is also shared across
    the plugin components using the dependency injection of Angular. Therefore, this
    class is also a good place to share data between plugin components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we have an overview of what we're going to build on a higher level. Our
    plugin system is very rudimentary, but it will support things such as hot loading
    plugins (plug and play style) and other nice features. In the next topic, we'll
    start by implementing the plugin API core components.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the plugin API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the less complex entities of our plugin API. We create a
    new `lib/plugin/plugin.js` file to create the `PluginConfig` decorator and the
    `PluginPlacement` class, which stores the information where plugin components
    should be placed. We also create the `PluginData` class in this file, which is
    used to inject plugin runtime information into plugin components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PluginConfig` decorator contains the very simple logic of accepting a
    configuration parameter, which will then be stored on the annotated class (the
    constructor function) on the `_pluginConfig` property. If you need a refresher
    on how decorators work, it''s maybe a good time to read the decorator topic in
    [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Component-Based User Interfaces"),
    *Component-Based User Interfaces*, again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PluginPlacement` class represents the configuration object to expose plugin
    components into different plugin slots in the application UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `PluginData` class represents the plugin runtime information that was created
    during instantiation of the plugin as well as one `PluginPlacement` object. This
    class will be used by the `PluginService` to convey information about plugin components
    to the plugin slots in the application.
  prefs: []
  type: TYPE_NORMAL
- en: These three classes are the main interaction points when implementing a plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simple example plugin, to get a picture of how we can use
    the `PluginConfig` decorator and the `PluginPlacement` class to configure a plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using the `PluginConfig` decorator, implementing a new plugin is a breeze. We
    decide the name, description, and where we'd like to place plugin components in
    the application at design time.
  prefs: []
  type: TYPE_NORMAL
- en: Our plugin system uses named `PluginSlot` directives to indicate extension points
    in our application component tree. In the `PluginPlacement` objects, we reference
    the Angular components built into the plugin and indicate in which slot they should
    be placed by referencing the plugin slot name. The priority of the placement will
    tell the plugin slot how to order the plugin component when created. This gets
    important when components of different plugins get created in the same plugin
    slot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let''s dive right into the core of our plugin architecture by implementing
    the plugin service. We''ll create a new `lib/plugin/plugin-service.js` file and
    create a new `PluginService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we will create an injectable service, we'll annotate our `PluginService`
    class using the `@Injectable` annotation. We use the RxJS `ReplaySubject` type
    in order to emit events on any changes of the activated plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the constructor of our service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, we initialize a new empty `plugins` array. This will be the list of active
    plugins, which contains runtime plugin data such as the URL where the plugin was
    loaded from, the plugin type (constructor of the class), a shortcut to the configuration
    stored on the plugin (created by the `PluginConfig` decorator) and finally, the
    instance of the plugin class itself.
  prefs: []
  type: TYPE_NORMAL
- en: We also add a `change` member that we initialize with a new RxJS `ReplaySubject`.
    We'll use this subject in order to emit the list of active plugins once it changes.
    This allows us to build our plugin system in a reactive way and enable plug and
    play style plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a last action in the constructor, we call the `loadPlugins` method of the
    service. This will perform the initial loading with the registered plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `loadPlugins` method asynchronously loads a file with the name `plugins.js`
    from the root path of our application using SystemJS. The `plugins.js` file is
    expected to default export an array, which contains preconfigured paths to plugins
    that should be loaded with the application startup. This allows us to configure
    the plugins that we're already aware of and which should be present by default.
    Using a separate and asynchronously loaded file for this configuration gives us
    a better separation from the main application. We can run the same application
    code but using a different `plugins.js` file and control what plugins should be
    present by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `loadPlugins` method then loads each plugin using the URL present in the
    `plugins.js` file by calling the `loadPlugin` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `loadPlugin` method is responsible for the loading and instantiation of
    individual plugin modules. It will take the URL of a plugin module as parameter
    and uses `System.import` to dynamically load the plugin module. The benefits we
    get from using `System.import` for this job is that we can load both, already
    existing modules in the bundled application as well as remote URL's using HTTP
    requests. This makes our plugin system very portable, and we can even load modules
    during runtime from a different server, from NPM or even GitHub. Of course, SystemJS
    also supports different module formats, such as ES6 modules or CommonJS modules,
    as well as different transpilers if the modules are not already transpiled.
  prefs: []
  type: TYPE_NORMAL
- en: After the plugin module is successfully loaded, we bundle all information about
    the loaded plugin together into a `pluginData` object. We can then add this information
    to our `plugins` array and emit a new event on our `ReplaySubject` to notify interested
    parties about the change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll need a method to gather the `PluginPlacement` data from all
    our plugins and filter them by a slot name. This gets important when our plugin
    slots need to know which components they should instantiate. Plugins can expose
    any number of components into any number of application plugin slots. This function
    will be used by our plugin slots when they need to know which of the exposed Angular
    components are relevant to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is already it for the `PluginService` class so far, and we created the
    core of our plugin system. In the next chapter, we will deal with the plugin slots
    and look at how we can instantiate plugin components dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating plugin components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, it's time to look at the second major piece of our plugin architecture,
    which is the `PluginSlot` directive that is responsible for the instantiation
    of plugin components in the right spots.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get to implement the directive though, let's look at how we can instantiate
    a component dynamically in Angular. We already covered instantiating views that
    can contain components in [Chapter 7](part0049.xhtml#aid-1ENBI2 "Chapter 7. Components
    for User Experience"), *Components for User Experience*. In the infinite scroll
    directive, we used the `ViewContainerRef` to instantiate template elements. However,
    we have a different use case here. We'd like to instantiate a single component
    into an existing view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ViewContainerRef` object also provides us with a solution to this problem.
    Let''s look at a very basic example on how to use the `ViewContainerRef` object
    to instantiate a component. In the following example, we make use of four new
    concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `@ViewChild` with `read` options set to `{read: ViewContainerRef}` to
    query for view container instead of the element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `ComponentResolver` instance to obtain the factory of the component,
    which we want to instantiate dynamically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `ReflectiveInjector` to create a new child injector that is used for our
    instantiated component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `ViewContainerRef.createComponent` to instantiate a component and attach
    it to the underlying view of the view container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following code example shows how we can dynamically create a component using
    the `ViewContainerRef` instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Injected into the constructor of the `App` component, we can later use `ComponentResolver`
    to resolve the `HelloWorld` component. We use the `@ViewChild` decorator to query
    for the heading element in the `App` component. Usually, this would give us the
    `ElementRef` object that is associated with the view element. However, as we need
    the view container associated with the element, we can use the `{read: ViewContainerRef}`
    options to obtain the `ViewContainerRef` object instead.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `AfterViewInit` lifecycle hook, we first call the `resolveComponent`
    method on the `ComponentResolver` instance. This call returns a promise, which
    resolves to an object of the `ComponentFactory` type. Angular uses component factories
    internally in order to create components.
  prefs: []
  type: TYPE_NORMAL
- en: After the promise has been resolved, we can now use the `createComponent` method
    on the view container of our heading element to create our `HelloWorld` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `createComponent` method of the `ViewContainerRef` object
    in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ViewContainerRef.createComponent` | This method will create a component
    that is based on the component factory provided in the `componentFactory` parameter.
    The compiled component will then be attached to the view container at a specific
    position provided by the `index` parameter.The following are the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`componentFactory`: This is the component factory, which will be used to create
    a new component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Index`: This is the optional parameter to specify the position in the view
    container at which the created component should be inserted. If this parameter
    is not specified, the component will be inserted at the last position in the view
    container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Injector`: This is an optional parameter that allows you to specify a custom
    injector for the created component. This allows you to provide additional dependencies
    for the created component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`projectableNodes`: This is an optional parameter to specify nodes for content
    projection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method returns a promise that is resolved when the instantiated component
    is compiled. The `Promise` resolves to a `ComponentRef` object, which can also
    be used to destroy the component again later on. |
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, a component created with the `ViewContainerRef.createComponent`
    method will inherit the injector from the parent component, which makes this process
    context aware. However, the `injector` parameter of the `createComponent` method
    is especially useful when you want to provide additional dependencies into the
    component that are not present on any parent injector.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go back to our `PluginSlot` directive that is responsible for the instantiation
    of relevant plugin components.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s think about the high-level requirements of our `PluginSlot` directive
    before we dive into the code:'
  prefs: []
  type: TYPE_NORMAL
- en: The plugin slot should contain a name input property so that this name can be
    referenced from plugins that want to provide components for the slot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The directive needs to react on changes of the `PluginService` and re-evaluate
    what plugin components need to be placed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the initialization of the plugin slot, we need to obtain a list of the `PluginData`
    objects that are relevant to this particular slot. We should consult the `getPluginData`
    method of `PluginService` in order to get this list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the obtained list of the relevant `PluginData` objects, we'll be able
    to instantiate components that are associated with the placement information using
    the `ViewContainerRef` object of our directive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create our `PluginSlot` directive on the `lib/plugin/plugin-slot.js`
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `name` input in our directive is very important for our plugin mechanism.
    By providing a name to the directive, we can define named extension points in
    our UI and later use this name in the `PluginPlacement` data of the plugin configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, we first inject the `ViewContainerRef` object, which is
    a reference to the view container of the directive. As we want to use the view
    container of the directive directly, there's no need to use `@ViewChild` here.
    If we want the view container of the current directive, we can simply use injection.
    We'll use this reference while we're instantiating components using the `ViewContainerRef.createComponent`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: In order to resolve components and their factory, we inject the `ComponentResolver`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: The `PluginService` is injected for two reasons. First, we'd like to subscribe
    to any changes on the list of active plugins, and secondly, we use it to obtain
    relevant `PluginData` objects for this slot.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `componentRefs` member to keep track of already instantiated plugin
    components. This will help us destroy them later on when a plugin gets deactivated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we create a new subscription to `PluginService` and store the subscription
    into the `pluginChangeSubscription` member field. On any changes of the activated
    plugin list, we execute the `initialize` method on our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the four parts of the initialize method in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we check whether this plugin slot already contains instantiated plugin
    components in the `componentRefs` member. If this is the case, we use the detach
    method of the `ComponentRef` objects to remove all existing instances. After this,
    we initialize the `componentRefs` member with an empty array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `getPluginData` method of `PluginService` to obtain a list of the
    `PluginData` objects that are relevant for this particular slot. We pass the name
    of this slot to the method, so the `PluginService` will already provide us with
    a filtered list of plugin components that are interested to be placed in our slot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As there could be many plugins queueing for placement in our slot, we are using
    the priority property of the `PluginPlacement` objects to sort the list of the
    `PluginData` objects. This will ensure that plugin components with higher priority
    will be placed before the ones with a lower priority. This is a nice extra feature
    that will come in handy when we deal with a lot of plugins fighting for space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last code part in our `initialize` method calls the `instantiatePluginComponent`
    method for each `PluginData` object in our list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s create the `instantiatePluginComponent` method, which is called
    as a last step in the `initialize` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This method is responsible for the instantiation of an individual plugin component.
    Now, we can use the knowledge that we gained in this topic about the `ViewContainerRef.createComponent`
    method and the `ComponentResolver` object to instantiate components dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the inherited providers from the component where this plugin
    slot is placed, we'd like to provide `PluginData` to the injector of the instantiated
    plugin component. Using Angular's `provide` function, we can specify `pluginData`
    to resolve for any injection on the `PluginData` type.
  prefs: []
  type: TYPE_NORMAL
- en: The `ReflectiveInjector` class provides us with some static methods that are
    used to create injectors. We can use the `parentInjector` member on our view container
    to obtain the injector that is present in the plugin slot context. Then, we use
    the static `resolveAndCreate` method on the `ReflectiveInjector` class in order
    to create a new child injector.
  prefs: []
  type: TYPE_NORMAL
- en: In the first parameter of the `resolveAndCreate` method, we can provide a list
    of providers. Those providers will be resolved and made available in our new child
    injector. The second parameter of the `resolveAndCreate` method accepts the parent
    injector of the newly-created child injector.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use the `createComponent` method of the `ViewContainerRef` object
    to instantiate the plugin component. As a second parameter to the `createComponent`
    method call, we need to pass the position in the view container. Here, we make
    use of the `length` property of our view container in order to place it at the
    very end. In the third parameter, we override the default injector of the component
    with our custom child injector. On success, we add the created `ComponentRef`
    object to our list of instantiated components.
  prefs: []
  type: TYPE_NORMAL
- en: Finalizing our plugin architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Congratulations, you've just built your own plugin architecture using Angular!
    We created a plugin API that can be used to create new plugins using the `PluginConfig`
    decorator. `PluginService` manages the whole plugin loading and provides the `PluginData`
    objects to the slots in our application using custom injectors. The `PluginSlot`
    directive can be used in the task management application to mark extension points
    in the user interface. Using the inheriting nature of the dependency injection
    in Angular, plugin components will be able to access whatever they require from
    their environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will create our first plugin using the plugin architecture
    that we just created.
  prefs: []
  type: TYPE_NORMAL
- en: Building an Agile plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we created a simple but effective plugin architecture,
    and we will now use this plugin API to build our first plugin in the task management
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into the plugin details, we should first agree on where to make
    our application extensible. Our plugin system is based on the `PluginSlot` directives,
    which should be placed somewhere in our component tree so that plugins can expose
    components to these slots. For now, we decide to make two spots in our application
    extensible:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TaskInfo`: In the list of tasks displayed in a project, we currently render
    `Task` components. Besides the title of the task, the `Task` component displays
    additional information such as the task number, the date of creation, and milestones,
    as well as efforts information where applicable. This additional information is
    rendered on the `Task` component using the `TaskInfos` subcomponent. This is a
    good spot to provide extensibility for plugins so that they can add additional
    task information, which will be displayed on the task list overview.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TaskDetail`: Another great spot to provide extensibility is the `ProjectTaskDetails`
    component. This is where we can edit the details of a task, which makes it a great
    component to open up for extension by plugins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Besides adding the `PluginSlot` directive to the directives list of the `TaskInfos`
    component, we modify the template located at `lib/task-list/task/task-infos/task-infos.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After including the `PluginSlot` directive and by setting the name input property
    to `task-info`, we provide an extension point for plugins where they can provide
    additional components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s apply the same changes to the `ProjectTaskDetails` component template
    in `lib/project/project-task-details/project-task-details.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Right before the end of the task details content element, we include another
    plugin slot with the name `task-detail`. By providing components for this slot,
    plugins can hook into the edit view of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so our extension points are set up for plugins to provide additional components
    on a task level. You can see that preparing these spots using the `PluginSlot`
    directive is really a piece of cake.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can look into the implementation of our Agile plugin, which will make
    use of the extension points that we just exposed.
  prefs: []
  type: TYPE_NORMAL
- en: The agile plugin that we will create will provide functionality to log story
    points on tasks. Story points are commonly used in Agile project management. They
    should provide a sense for complexity, and they are relative to a so-called reference
    story. If you want to know more about Agile project management and how to estimate
    using story points, I really recommend the book, *Agile Estimating and Planning*
    by Mike Cohn.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with our plugin class and the necessary configuration. We create
    the plugin outside our regular `lib` folder, just to indicate the portable nature
    of plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a new `AgilePlugin` class on the `plugins/agile/agile.js` path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The plugin class forms the central entry point of our plugin. We use the `PluginConfig`
    decorator, which we created as part of our plugin API. Besides the name and description,
    we also need to configure any placements where we map plugin components to application
    plugin slots. However, as we haven't got any plugin component yet to expose, our
    list remains empty for the moment.
  prefs: []
  type: TYPE_NORMAL
- en: It's also important to note that a plugin module always needs to default export
    the plugin class. This is just how we've implemented the plugin-loading mechanisms
    in our `PluginService` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking back at these two lines in the `loadPlugin` method of `PluginService`
    shows you that we rely on the default export of plugin modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When the plugin module is successfully loaded, we obtain the default export
    by referencing the `default` property on the module.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we created our plugin entry module. This acts as a plugin configuration
    container, and it is not related to Angular in any way. Using the placements configuration,
    we can then expose our plugin Angular components once we've created them.
  prefs: []
  type: TYPE_NORMAL
- en: Agile task info component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's move on to the first Agile plugin component that we want to expose. First,
    we create the component, which will be exposed into the slot with the name `task-info`.
    Below the task title on the task list, our Agile information component should
    display the stored story points.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a new `Component` class on the `plugins/agile/agile-task-info/agile-task-info.js`
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we implemented a regular component here. There's nothing special
    about this component at all.
  prefs: []
  type: TYPE_NORMAL
- en: We import the `Task` component to get the type information to inject it in our
    constructor. As the plugin slot is placed inside of the `TaskInfos` component,
    which, in fact, is always a child of a `Task` component, this is a safe injection.
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor, we then take the injected `Task` component and extract the
    task data into a local `task` member.
  prefs: []
  type: TYPE_NORMAL
- en: We also borrow the `task-infos__info` class of the `TaskInfos` component in
    order to get the same look like other task information that is already present
    on the task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the template of the `AgileTaskInfo` component that is
    located in the same path in the `agile-task-info.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Following the same mark-up that we used in the `TaskInfo` component, we display
    the `storyPoints` tasks if present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, now we can expose the plugin component in the plugin configuration
    using a `PluginPlacement` object. Let''s make the necessary modification to our
    `agile.js` module file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we include a new `PluginPlacement` object in our plugin configuration,
    which maps our `AgileTaskInfo` component to be exposed into the application plugin
    slot with the name `task-info`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Agile task info component](img/image00350.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Task info displaying additional information that is provided by our Agile plugin
  prefs: []
  type: TYPE_NORMAL
- en: This would already be enough for the plugin to work. However, as we don't have
    any data filled as `storyPoints` on our tasks, this plugin wouldn't really show
    us anything at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: Agile task details component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create another plugin component, which can be used to enter story points.
    For this, we will create a new `AgileTaskDetail` component on the `plugins/agile/agile-task-detail/agile-task-detail.js`
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing really fancy with this component either. Our target slot is
    the `task-detail` plugin slot, which is placed inside the `ProjectTaskDetails`
    component. Therefore, it's safe for both the `ProjectTaskDetails` and `Project`
    components to be injected into our plugin component. The `ProjectTaskDetails`
    component is used to obtain the task data in context. We use `LiveDocument` that
    is stored on the `Project` component to persist any changes that we make to the
    task data of the project.
  prefs: []
  type: TYPE_NORMAL
- en: We reuse an `Editor` component to obtain user input and store the input data
    in the `onStoryPointsSaved` call-back. This is the same mechanism we know from
    other areas where we use the `Editor` component. When the story points get edited,
    we first update the task data model that is stored in the `ProjectTaskDetails`
    component. After this, we can use the `LiveDocument` `persist` method to save
    the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the template of our `AgileTaskDetail` component in the `plugins/agile/agile-task-detail/agile-task-detail.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We create a direct binding from the `content` input property of our editor to
    the `storyPoints` property of the task data.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an edit is saved, we call the `onStoryPointsSaved` callback with the updated
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Agile task details component](img/image00351.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Task details displaying the new Agile story points that are exposed by our Agile
    plugin
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we expose our newly-created plugin component using a new `PluginPlacement`
    object on the plugin configuration, we''ll enhance the component one more time.
    This would be nice if we provide two buttons on the component that allows the
    user to increase or decrease the story points to the next common story point value
    in range. As we already stored the list of common story points on the `Agile`
    plugin class, let''s see how we can make use of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: While we previously injected the `Project` and `ProjectTaskDetails` components
    that are provided by the component level injectors, we now make use of the providers
    that we added during instantiation in our `PluginSlot` directive. Here, we provided
    `PluginData`, which we can now use to get a reference back to the plugin component.
  prefs: []
  type: TYPE_NORMAL
- en: The next higher or lower story point value is found by `increaseStoryPoints`
    and `decreaseStoryPoints`. This is done by searching the list of common story
    points that are stored on our `AgilePlugin` class. Using the plugin class instance
    that is present on the injected `PluginData`, we can easily access this list.
    After storing the modified story points, we then use the `LiveDocument` instance
    of the project component to persist the adjusted story points.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the template of our `AgileTaskDetail` component, we simply add two buttons
    that allow the user to increase or decrease the story points that are based on
    our newly-created methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, let''s now add the `AgileTaskDetail` component to the plugin configuration
    using a new `PluginPlacement` object, which references the `task-detail` plugin
    slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Isn't this great? You created a fully-portable plugin that enables the management
    of Agile story points on tasks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Agile task details component](img/image00352.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The task details view with story points and additional increase/decrease buttons
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing that is left is to add the plugin to the list of plugins that
    should be loaded initially by the `PluginService` directive. For this, we''ll
    create a `plugins.js` file on the root of our application and add the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we launch our application, the plugin will be loaded by the `PluginService`
    and `PluginSlot` directives will instantiate the Agile plugin components where
    appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Recapitulating on our first plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well done! You successfully implemented your first plugin! In this section,
    we used the API of our plugin architecture to create a plugin to manage Agile
    story points. We used the `PluginPlacement` class to map our plugin components
    to different slots in the UI of our application. We also made use of the `PluginData`
    object that is provided to each instantiated component in the plugin slot in order
    to access the plugin instance.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of implementing functionality like this inside a plugin should
    be obvious. We added an additional feature to our application without building
    up additional dependencies. Our Agile feature is completely portable. Third-party
    developers can write independent plugins, and they can be loaded by our system.
    This is a big advantage, and it helps us keep our core slim while providing great
    extensibility.
  prefs: []
  type: TYPE_NORMAL
- en: Managing plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already built the core of the plugin architecture and a first plugin that
    runs in this system. We can use the `plugins.js` file on the root of our application
    to register plugins. The system is actually fully functional already. However,
    it would be nice to provide a way to manage our plugins during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will build a new routable component, which will list all
    active plugins in the system. After we've done this, we'll also add some elements
    which allow users to unload active plugins as well as load new plugins during
    runtime. Due to the reactive nature of our plugin system, the browser does not
    need to be refreshed in order for newly-loaded plugins to become active. The moment
    a plugin is loaded, it will immediately be made available to relevant plugin slots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a new `ManagePlugins` component class on the `lib/manage-plugins/manage-plugins.js`
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Our `ManagePlugins` component is quite simple. We inject the `PluginService`
    into the constructor of the component and set the member field plugins to point
    to the change observable of `PluginService`. As we'll always get the latest plugin
    list emitted by this observable, we can then simply use the `async` pipe in the
    view to subscribe to the observable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the template of our new component in `lib/manage-plugins/manage-plugins.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We use an HTML table to display the list of active plugins. On the table body
    rows, we use the `NgFor` directive to iterate over the list of active plugins,
    which we subscribe to using the `async` pipe.
  prefs: []
  type: TYPE_NORMAL
- en: In the plugin objects, we got everything worth displaying already present. By
    iterating over the `PluginPlacement` objects that are stored on the `config` property
    on the plugin data, we can even display the slot names where our plugins provide
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the only thing left to do to enable our new component is to make it routable
    and to add it to the navigation of our application. Let''s make the necessary
    modification in the `lib/app.js` module for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We added a new route, so let''s add it to our navigation in `lib/app.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In a new `Admin` navigation section, we add a new `navigation-item` that links
    to the newly-created "plugins" route:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing plugins](img/image00353.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our new ManagePlugins component displaying a table of active plugins and their
    exposed placements
  prefs: []
  type: TYPE_NORMAL
- en: Loading new plugins at runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already have everything in place to provide a page to see all active plugins.
    However, we said that it would be nice to be able to manage this list. A user
    should be able to remove active plugins as well as manually load additional plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add these capabilities to our `ManagePlugins` component. Before we can
    do this, we''ll need an additional method on our `PluginService` class, which
    is the part responsible for the loading of plugins. So far, we didn''t consider
    the functionality to remove active plugins. Let''s open `PluginService` in `lib/plugin/plugin-service.js`
    to add this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Well, this was easy! We provide a new `removePlugin` method, which takes a plugin
    name as parameter. We then look up the plugin in the `plugins` array, and if a
    plugin was found with this name, we remove it from the list. Additionally, after
    we've removed the plugin, we emit a `change` event with the updated list. As all
    plugin slots in the application are subscribed to this change observable, they
    will update and reinitialize relevant plugin components automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now apply the necessary changes to our `ManagePlugins` component class
    in order to not only remove plugins but also to load additional plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, we also store the `PluginService` on our component. In the `removePlugin`
    and the `loadPlugin` functions, we delegate to the `PluginService` to take the
    necessary actions.
  prefs: []
  type: TYPE_NORMAL
- en: The `loadPlugin` method will receive an `ElementRef` object that points to the
    input field, where the user enters the URL from which we load a new plugin. We
    can pass the value of the input field to the `loadPlugin` method of `PluginService`,
    which deals with the rest. We also set the input field value to an empty string
    once we've submitted this call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open the template at `lib/manage-plugins/manage-plugins.html` to apply
    the required changes in the view of our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We added an additional button for every listed plugin in the table, which contains
    a binding expression that calls the `removePlugin` method with the currently iterated
    plugin name.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also added a new section after the listed plugins to load new plugins. In
    this section, we use an input field to enter the plugin URL as well as a button
    to execute the loading. Using a `loadUrlRef` local view reference, we can pass
    a reference to the input DOM element to the `loadPlugin` method on our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading new plugins at runtime](img/image00354.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A completed ManagePlugins component with the ability to remove and load plugin
    modules at runtime
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have everything in place to manage our plugins. Plugins initially loaded
    from URLs present in the root `plugins.js` file can now be unloaded using the
    REMOVE button in the plugins listing. New plugins can be loaded and activated
    by entering the URL of a plugin, which could be a local URL, bundled and mapped
    module, or even a remote URL on a different server.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at different approaches on how to implement a plugin
    architecture. We then created our own design for a plugin architecture that leverages
    some Angular mechanisms and works on the concept of UI extension points that we
    call slots.
  prefs: []
  type: TYPE_NORMAL
- en: We implemented a plugin API that provides great developer experience by leveraging
    ES7 decorators to make the configuration of new plugins a piece of cake. We implemented
    the core of our plugin system using a service to load and unload plugins that
    are based on the SystemJS module loader. This allowed us to make use of the advanced
    loading possibilities that are provided by SystemJS. Plugins can be transpiled
    in real time, can be located on a local URL, remote URL, or even be bundled into
    the main application.
  prefs: []
  type: TYPE_NORMAL
- en: We implemented our first plugin, which provides some components to manage Agile
    story points on our tasks. The plugin was created outside our regular project
    `lib` folder, which should underline the portable nature of our plugin system.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we created a new routable component to manage plugins at runtime. Due
    to the reactive nature of our plugin system, plugins can be loaded and unloaded
    during application runtime without any unwanted side-effects.
  prefs: []
  type: TYPE_NORMAL
- en: When you're playing with the source code of this chapter, I highly recommend
    that you play with the loading mechanism of our plugin architecture. The flexibility
    that we achieved with very little effort is fantastic. You can unload the Agile
    plugin and load it again by providing the URL to the plugin main module. You can
    even try to place the whole plugins folder onto a remote server and load the plugin
    from there. Just make sure that you consider the necessary **Cross-Origin Resource
    Sharing** (**CORS**) headers.
  prefs: []
  type: TYPE_NORMAL
- en: The whole code for this chapter can be found in the ZIP file of the book resources
    that you can download from Packt Publishing. You can refer to the *Downloading
    the example code* section in the *Preface* of the book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and last chapter of this book, we'll look at how we can test the
    components that we've created so far. So, stay tuned for this overdue topic!
  prefs: []
  type: TYPE_NORMAL
