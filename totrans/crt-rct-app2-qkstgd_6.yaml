- en: Simulate Your Backend with a Proxy API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we''ve been working through building up our application, we''ve done a ton
    of really great work but nearly all of it has been in this weird state where the
    data all lives completely inside of our React application. The reality is that
    this won''t be true for most projects you work on, so we''ll want to do a little
    bit of work to try to put the state of our Create React App project outside of
    React itself. To do that, we can take advantage of another feature in our Create
    React App world: proxy backends!'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we'll need to spend a little bit of time talking about how we can
    actually get the data from that backend server into our Create React App project!
    A backend without a frontend isn't particularly useful, and vice versa! Similarly,
    a developer who has no understanding of either direction will be in a difficult
    situation, where they are designing systems with no sense of how they would need
    to interact with each other!
  prefs: []
  type: TYPE_NORMAL
- en: The simulated backend server we'll be building will act as the design document
    for our frontend developers to follow. It's not meant to be the final backend
    that we'll actually use, but rather, it will function as the framework that other
    developers can work with to better understand how to properly interact with our
    frontend and how to build a backend API that doesn't require us to completely
    rebuild our frontend!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the proxy feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a quick `Express.js` server that should have a small footprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning a little bit about the React component methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting data in or out of our backend proxy via Fetch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating our tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating a backend server with the proxy API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've been building up our application over time with Create React App, but
    we've kept it almost entirely a frontend-only application. That's all well and
    good, but the reality is that you will probably be building an application that
    has a server behind it! The good news is that creating a simulated backend in
    Create React App projects remains as simple as possible while still giving you
    a good feel for how things would translate into a real-world scenario or project!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the backend API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned, pretending there is a backend to our Create React App project
    requires very little effort and gets us back into development incredibly quickly.
    For us to take advantage of this, we''ll need to first set up a `"proxy"` in our
    `package.json` file. A proxy is a way for us to tell Create React App that any
    requests we make should go to this other server when it may look like we''re making
    requests locally, instead. Let''s start with configuring our project and then
    move on to implementing this further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also want to add a command to run and execute our server that we can
    easily run via `yarn`, so we''ll also need to update the `"scripts"` section of
    `package.json` to include a new command. We''ll arbitrarily name it `"backend"`
    so that when we''re ready to run our server, we just run the `yarn backend` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This by itself won''t actually do anything. We''ll need to implement a `server`
    behind the scenes that can actually respond and react to any of the API calls
    that we''re making along the way. We''ll need another library in our project to
    do that, though, since by itself we can''t just simulate an API. We''ll need to
    add another library to our project that can handle the server and `HTTP` functionality. I
    personally prefer using `Express.js` for this, so we''ll use that as our library
    of choice for this project. In our command window, we''ll add express via `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We then create a new file in the root of our Create React App project called
    `server.js`. This will act as the code that will serve all of the the requests
    that our application will be making to simulate a real-world scenario. Our server
    will not actually be stateful; instead, we will simulate that behavior through
    static data returned from our little, fake API.
  prefs: []
  type: TYPE_NORMAL
- en: This section is going to be a little heavier on Node.js and Express concepts
    than React, since we need to be able to set up a quick server to act as our simulated
    backend!
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start off with a basic skeleton for our server, which will do a little
    bit of setup work that `express` requires from us. In `server.js`, in our root
    directory of our project, we will have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We'll start off by loading Express into our server project. We'll need to pull
    this into our project via a `require()` statement rather than an `import()` statement,
    since we will be running this via Node. Next, we'll need to build out our server
    in our app variable, which is the instantiation of the `express.js` code. We'll
    also set the port that we'll run this on, which is the port we specified in our
    proxy configuration. I tend to pick ports in multiples of 1,000, but you can use
    whatever port numbers you personally prefer!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll need to tell our app to use the express JSON middleware, which will
    let us react and respond to JSON post body statements later on (we'll need this
    when we go to create a new `Todo` item in our server). After that, we have our
    first example of a route in our express server. This just returns, in JSON, an
    empty body when someone makes a request to the root of our proxy API backend.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s spend a few minutes talking a little bit more about the structure of a
    route in express. While we won’t get into the full details and write the whole
    thing out from start to finish, it is worth at least understanding what a route
    is and how it is written in Express to avoid any confusion later on.
  prefs: []
  type: TYPE_NORMAL
- en: A route is structured and written as `(the name of the express() variable).(HTTP
    method)(“path”, (request_variable, response_variable)` and then a function off
    of that. Every route should end with sending something back to the requester,
    and, in our case (since we’re writing a little API), it should be sending back
    some JSON.
  prefs: []
  type: TYPE_NORMAL
- en: This is enough for us to do right now; we'll be expanding on this configuration
    later on in this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Middleware is a pipeline of functions that are executed in between the time
    the server sees the request, the request goes into the proper route, and then
    is returned back to the sender. In this case, all JSON bodies are converted into
    JSON so that we can read from them without a lot of extra code each time.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll need to set up a listener for our application. We'll listen to
    the port that we specified earlier, and then specify a function that is to be
    executed when the app finishes listening on that port. In our case, we'll just
    have a little message that logs out letting us know that the server is set up
    and running correctly!
  prefs: []
  type: TYPE_NORMAL
- en: This code is very minimal, but as a result of how minimal it is, it also requires
    some maintenance. For example, every time you make a change in the code, you will
    need to restart your backend server (not the Create React App project, though).
  prefs: []
  type: TYPE_NORMAL
- en: Figuring out our backend requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To figure out how we''ll need to structure our API, it helps to take another
    look at the UI to identify different types of functions that can occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39a2dbaa-8c05-40e4-a160-439cd93de7c0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Looking at that UI, can you figure out what we need? We need representations
    of `Todo` items and a way to get the current list of them, and we need a way to
    change their state, to delete items, or to add new items. We''ll start off simple
    by implementing our index of Todos, but that will require an initial step of figuring
    out the data structure we''re going to use. First, we''ll need an object for each
    `todo`. Each `todo` will need the same representation as their internal objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also need a representation of some instances of internal `id`, so our
    new object would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let's start off by constructing this in the server so we can get a good feel
    for how to handle this in the other actions later!
  prefs: []
  type: TYPE_NORMAL
- en: Building the Todos index API request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, back in `server.js`, we''ll need to put together our list of `Todo`
    items. You''ll likely recognize these from the `Todo` items that we''ve used previously,
    with the exception of the fact that we now also have some `id` in the items as
    well. This is a closer representation to what we''d see normally in a server,
    where the items would not only contain their normal attributes but also form of
    primary keys as well. We''ll store these as a `const` since we don''t want to
    be able to accidentally overwrite them later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To `get` these Todos out via the server, we''ll need to create a new route
    to an endpoint, `/api/todos`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'First, you''ll need to start up the backend using `yarn backend`. Next, if
    we send a request via some network tool to send `HTTP` requests (for example,
    using Postman), we should be able to verify the results by making a `GET` request
    to `http://localhost:4000/api/todos`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1cc3c876-0284-41bd-8478-ea11bb19449d.png)'
  prefs: []
  type: TYPE_IMG
- en: We can also delete the `app.get("/"...)` line, since we no longer require that
    code.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of ways to simulate requests to your backend. Similar to choices
    on code editors, Postman is my tool of choice for manually sending `HTTP` requests
    to verify the results, or you may already have tools available to you, such as
    CURL! Whatever you prefer to use should work just fine.
  prefs: []
  type: TYPE_NORMAL
- en: Building the add Todo API request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll also need to be able to create new Todos. To do that, we'll implement
    the next portion of our API, where we will create a route in `server.js` that
    is able to handle receiving an `HTTP` post with a body. Remember that line of
    code from earlier, where we instructed express to use the JSON middleware? The
    code for this isn't very complicated either. We specify to express that we can
    accept an `HTTP` post and give it the standard `req`, `res` arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'From there, since we only have a few items in our `Todo` list, we give the
    new `Todo` an `id` of the length of that list plus one, and then we fill it up
    with the rest of the body that is passed in by the user, using the object spread
    operator! As follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, to verify that we''re doing things correctly, we''ll send a quick test
    via Postman with a `Todo` body and verify that we get sent back the list of Todos,
    plus the new one that we post in! Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11a5cd23-4615-4e7f-a508-1de0e94aa4f6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That''s all we need to add a new `Todo`, so now we can move on to the next
    piece of functionality: deleting a `Todo`!'
  prefs: []
  type: TYPE_NORMAL
- en: Building the remove Todo API request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deleting a `Todo` is equally simple! Much like accepting a post route, we have
    to accept a delete route and specify an `id` in the body. This will allow us to
    use a URL such as `/api/todos/3`, where `3` would be the `id` of the `Todo` we
    want to delete! We can access `params` in the URL via `req.params.[the name of
    the param]`. In the following case, the name of the param we specify is `:id`,
    which means the variable we can access is `req.params.id`!
  prefs: []
  type: TYPE_NORMAL
- en: 'From there, we just `filter` out the instances of `id` that don''t match and
    call it a day! Remember that any `params` URLs are passed in as strings; that''s
    why we do a quick `parseInt()` on the `id` before our `filter` function! As follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll run it in Postman and verify the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4650f2af-6eb4-4e3c-b0e5-42c2a0119957.png)'
  prefs: []
  type: TYPE_IMG
- en: The React component life cycle for mounting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to understand the React component life cycle for mounting components
    as well, since we'll need to hook into that later as part of hooking everything
    back up to our application. There are two main categories of phases when dealing
    with React components. The first is the **Render Phase**, where React is concerned
    about how the initial component is created and rendered to the page. You should
    keep these clean and without side-effects, so, as an example, we would not include
    any calls to our backend to fill in data or components on the page. The functions
    that are most commonly used here are `constructor()` and `render()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second phase, however, is the phase where we can modify things after the
    fact. The main function to mention here is `componentDidMount()`, which is where
    we can (and will) fire off requests to our backend server. The diagram for these
    calls might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6af7a1b1-a73c-4fd2-ac2e-686c497629d9.png)'
  prefs: []
  type: TYPE_IMG
- en: Where to put API requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Based on that, we will have to create a `componentDidMount()` function that
    will contain the code that we need to fire off requests to our backend server,
    instead of sticking them in `constructor()` or in some other function! This ensures
    that our component will update and mount in a sane manner!
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with your proxy server with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've written all of the code that we need for now on the server side
    of things, we'll need to modify our `TodoList` component to actually make calls
    out to the service that we wrote! The great news is that, yet again, everything
    we need to be able to do this already exists for us in our Create React App project!
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also a good opportunity for us to talk about another modern Javascript
    function: `Async`/`Await`!'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Async/Await
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to fetch data out of the server, the best tool for us to do that
    is by using some new Javascript syntax around asynchronous actions and calls!
  prefs: []
  type: TYPE_NORMAL
- en: 'This is called `Async`/`Await`, and is a method of performing operations that
    don''t require our application to completely hang, but will wait for results while
    processing other data. If you''re familiar with promises, you might be familiar
    with code that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is fine, but there is a better way to do this. This code can get particularly
    messy the larger it grows, and even more so if we introduce different branches
    or failure criteria and conditions we need to account for. Eventually, a mess
    of promises can turn into code that is just impossible to trace through when things
    go wrong, and we want to avoid that if we can.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Fetch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The good news is that Fetch is also an incredibly simple library to work with!
    The syntax for it is simple and clear enough that it should be easy to understand
    what it does pretty quickly. Of course, that begs the question: what is Fetch?'
  prefs: []
  type: TYPE_NORMAL
- en: The short answer is that Fetch is an `HTTP` request mechanism that has been
    made a first-class citizen in the Javascript world. The long answer is that Fetch
    is an attempt by the Javascript community and contributors to handle `HTTP` requests
    from Javascript code in a standardized way, instead of the multiple hundreds (or
    maybe even thousands) of different choices that all require their own implementations,
    patterns, configurations, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Fetch’s utility stems from it being ubiquitous and part of the Javascript language
    standard, although not every browser supports it fully yet. As such, instead of
    picking some other random library to work with, it is much easier for us to rely
    instead on the standard, knowing full well that the skills learned as you work
    with Fetch should transfer just fine into any other libraries that you might pick
    up and start using.
  prefs: []
  type: TYPE_NORMAL
- en: Getting our list of Todos from the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get Todos, we'll need to change how our state is built out. If you think
    back to our earliest implementations of the `TodoList` component, we built all
    of our Todos as an array of strings and then allowed our `Todo` component to do
    the rest of the work. This ends up not being a great model when we’re actually
    getting information in and out of our server, so we’ll want to transition ourselves
    over from relying on simple strings to store the information about the Todos to
    a model where the data structures for the Todos match both their component implementations
    and their data representations on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start modifying `TodoList` to fit our new world, we''ll want to start with
    a blank list of Todos and a flag to capture whether the data has been loaded yet
    or not. In `src/TodoList/TodoList.js` add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This `loaded` flag is actually pretty important; without it, we run into a scenario
    where when the page first loads, either the page looks blank or it displays *No
    items*, when in reality it just hasn’t loaded the full list of items yet! To create
    a better user experience, we’ll instead want to rely on a flag that tells the
    application whether it has completed loading and displays a message about that
    to the user, instead of relying on whether the `items state` property has values
    in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember from our server, `Todo` items will now be populated from the
    data structure that we created in our server file, so they can no longer just
    be the descriptions. This will require us to restructure some of our code, so
    we''ll go back through and fix up the code that is broken by this change. First,
    let''s add a new item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s easier for us to break `newItem` into a separate variable and then pass
    that into the `setState()` call, otherwise we’d end up making that line of code
    really long and also very fragile in regards to any data-structure changes that
    might happen along the way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We also do a similar operation with our `removeTodo` call. We’ll move our list
    of filtered items, based on the description. Next, is our `renderItems()` call,
    which is also going to check the new state variable to see whether the data has
    been loaded from the server yet. Also, we’re going to pass in a few new properties
    to our `Todo` component to make it respect our data structure. Specifically, we’ll
    pass in the `id`, `done`, and `critical` flags to allow those to be set in `Todo`
    as part of the passed-in `props`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we''re passing in some new props to the `Todo` components, which
    means we''ll need to modify those to allow `state` to be set via `props` for whether
    a `Todo` is done and whether a `Todo` is critical. Open up `src/Todo/Todo.js`
    and we''ll take care of that really quickly in the `constructor()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Head back to `src/TodoList/TodoList.js`, and let''s start writing our `Async`/`Await`
    functionality. We''ll create a new function that is part of the React standard
    component life cycle, `componentDidMount()`, where we will declare it as an `async`
    function. Remember that any place we want to use `await` in our code, we have
    to do so inside of a function that has been declared as `async`! We''ll start
    off with a simple body so that we can verify how it all works first, and then
    we''ll flesh it out a little more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll need to use `fetch` to make the request to our simulated backend,
    where we will `await` the results of `fetch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Remember that we are proxying requests to a different backend through Create
    React App! As a result, we don't need to specify a port or host, since it is pretending
    to be the same port/host.
  prefs: []
  type: TYPE_NORMAL
- en: This backend server is meant to act as a placeholder for when you build a backend
    onto the same application or service as where this code runs for minimum latency.
    This is a great model for when you're building the frontend for something but
    the backend isn't fully built yet!
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also need to take those results and convert them into JSON if we want
    to do anything with them, which is also an `async` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, don''t forget that our server returns data back in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'So finally, we need to replace the state of items to the new state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And there we are! Now when the page refreshes, you should see the same list
    of components as before but now the data comes from our simulated backend instead!
    This should leave the full body of this function looking like the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Creating a new Todo on the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll also want to be able to create a new `Todo` by using `HTTP` post to
    create a new `Todo`. This will also be an `async` function since we’ll be making
    an `async` call to `fetch` to send data. Since posting via `HTTP` is more complicated
    than getting, we’ll also need to specify some options into our `fetch` call. Specifically,
    we can configure the call by specifying the `HTTP` method (`POST` in our case),
    the headers (just an accept `header` for JSON data, which is the same as what
    we’d normally use to communicate with any JSON API), and the body of what we’re
    posting to the server, which is just the data structure of a new `Todo`. If it
    is successful, we will add the new `Todo` onto our state and call it a day. Back
    in `src/TodoList/TodoList.js`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Deleting a Todo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deleting a `Todo` is going to be very similar to creating a `Todo`, so there’s
    not actually that much that we have to describe here. The biggest and most important
    things are that the method is set to `DELETE` and the `id` of the `Todo` we want
    to delete is passed in via the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also need to change how the `removeTodo` function is called from `src/Todo/Todo.js`,
    so open that file up and change the argument that it passes in to be by the Todo''s
    `id` instead of by its description! As follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This should get us most of the functionality that we want, but the problem we
    have right now is that our code is not nearly as simple to test as we'd like.
    In fact, we actually have a few failing tests that we'll need to fix up!
  prefs: []
  type: TYPE_NORMAL
- en: Getting back to passing tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tests are failing. We'll start by hitting *u* to update our snapshots, then
    move on to working with our code to fix up the rest of the tests. The good news
    is that our tests for the `Todo` component are really easy to fix up! Remember
    that our `Todo` component takes in a few other properties to initialize now; as
    per our test, it really only takes in the `description` and `removeTodo` properties.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the Todo test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to change our initialization of the shallow-rendered component to take
    in the `id`, `critical`, and `done` properties instead! In `src/Todo/Todo.test.js`,
    we''ll change the first failing test suite by changing the `const component` statement
    to include these additional properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Rerun the tests and now we should only be down to a single failing test suite!
    Unfortunately, this will also be the hardest test suite to fix!
  prefs: []
  type: TYPE_NORMAL
- en: Fixing our last failing test suite through refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, our code now brings us into a scenario where our components are
    actually really hard to test appropriately. We have the code that has to fetch
    data off the backend mixed in with the code that initializes our components, as
    well as being mixed in with the behaviors when buttons are clicked! That's no
    good, so we'll need to fix this!
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that the easiest way for us to fix this up doesn't require
    a mountain of effort; instead, it requires us to just move some of the code around
    in a way that would make it more extensible. The first operation we'll need to
    perform is moving all of our code that interacts with the backend into its own
    separate service library!
  prefs: []
  type: TYPE_NORMAL
- en: The service library pattern is a great pattern for when you need to lock down
    behaviors and interactions with external services into simpler APIs that make
    it easier for your code, or other people's code, to interact efficiently with
    a backend server!
  prefs: []
  type: TYPE_NORMAL
- en: Building service libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start off by moving all of our API calls into a new file, `src/TodoService.js`.
    We''ll start with the simplest call, which is the call to `fetchTodos` items from
    the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've written our `fetchTodos()` function as an `async` function that,
    for the most part, does what it did originally. The only major different here
    is that we've changed the `return` statement to not just send back the list of
    `todos` from the server, but also the `HTTP` status code from the server!
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll implement the call to create a `Todo` on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this post is almost identical to what you saw previously, except with
    the modification around the `return` statement. Finally, we''ll move on to the
    delete call on our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve added a few functions, so we''ll `export` them at the end of the service
    library. All we need to do is `export` these three functions as named functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Implementing our service library in TodoList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our `TodoService` library, we have to go back to our `src/TodoList/TodoList.js`
    file and find all of the areas where we used to have the `fetch` code written
    into our component. We''ll need to start off at the top of our file by importing
    those three named functions from our `TodoService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll need to go into our `componentDidMount()` function, where we''ll
    modify it to call the `fetchTodos()` function instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at how nice and clean that function is now! This is definitely a move
    for the better, no matter what! Now, let''s move on to our `addTodo()` function
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll modify our `removeTodo()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This will get us most of the way back toward fixing our failing tests, but the
    last place we need to get some work done is in the failing tests themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Finally fixing our last failing test suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, head on over to the failing test suite, `src/TodoList/TodoList.test.js`,
    where we will need to create something in Jest called a **mock library**. A mock
    library is basically just a way for us to tell Jest that we need to fake the behavior
    of a particular `import` module so that, whenever it is used, our fake mock functions
    will be used instead. This will allow us to mock the behavior of the entire service
    library that we wrote, allowing us to test our components and verify functionality
    without needing tests that actually make calls to some backend API somewhere!
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start the top of our test file, underneath our `import` statements,
    by adding the library mock and three `mock` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We're writing these in a way that the functions will always work, always return
    an empty list of `todos`, and will always return a fake `HTTP` status `200` code!
    With that out of the way, we can clean up our failing tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two tests that are failing are doing so because the behavior is erratic
    when we''re dealing with non-async tests that deal with `async` functionality!
    We can instead write our tests—similar to how we write the rest of our function
    calls—to be `async` functions! Think about the structure of a test declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to instead make that test async-capable, we would instead write
    our test declaration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Bearing that in mind, let''s take a look at the corrected function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s not dramatically different from the test we had previously, with the
    addition of the call to `addTodo()` requiring an `await` statement. Now let''s
    take a look at our test for `removeTodo()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You might get an error message about the first test, the test where it tries
    to render a component without crashing. Our new `async`/`await` additions make
    this test no longer viable, so just delete it! Run the tests now, and we should
    see the follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There we are, back to a fully-passing suite of tests!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we spent a fair amount of time exploring our options for making,
    simulating, and running a backend server alongside our Create React App project.
    This allows us to pass projects off to other teams where they know the implicit
    data structure contracts that need to exist as part of the development process
    between frontend and backend development teams.
  prefs: []
  type: TYPE_NORMAL
- en: We also spent a good chunk of time exploring our options for retrieving data
    from inside a React project out to a server! This is only one possible option
    for implementation out of many; in general, Javascript projects tend to have a
    ton of different (and all equally good in their own rights) ways to implement
    a lot of common functionality. Using Fetch and a service library is just one possible
    way to do this, but it's a way that I've personally found a lot of success with
    and tend to stick with, unless I see a need to do something more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll explore some of the more progressive options for
    supporting a web application in a way that supports both mobile users and users
    with poor internet connections: progressive web apps! Create React App ships with
    really great support for building progressive web applications right out of the
    gate, so we''ll take a deep dive into building a progressive web app, what functionality
    and opportunities that affords us, and how we can take advantage of that to make
    a truly modern React application, all while remaining inside the confines of our
    Create React App project!'
  prefs: []
  type: TYPE_NORMAL
