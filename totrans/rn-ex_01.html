<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">First Project - Creating a Basic To-Do List App</h1>
            </header>

            <article>
                
<p>Having set up our environment for React Native development in the preface, let's start developing the application. Throughout this book, I'll refer to this application by the project name I began with--<kbd>Tasks</kbd>. In this chapter, we will cover the following topics:</p>
<ul>
<li>Planning the features that a to-do list app should have</li>
<li>Basic project architecture</li>
<li>Introducing <kbd>StyleSheet</kbd>, the React Native component for working with styles</li>
<li>An overview of Flexbox, a layout mode inspired by CSS for styling in React Native</li>
<li>Become acquainted with ES6, the new JavaScript syntax we will be writing our code in</li>
<li>Creating the building blocks of <kbd>Tasks</kbd> with <kbd>TextInput</kbd>, <kbd>ListView</kbd>, <kbd>AsyncStorage</kbd>, <kbd>Input</kbd>, state, and props</li>
<li>Learning about the iOS Simulator's <span class="packt_screen">Developer</span> menu, which can help us during the writing of our app</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Initializing a new project</h1>
            </header>

            <article>
                
<p>With the React Native SDK already installed, initializing a new React Native project is as simple as using the following command line:</p>
<pre>
<strong>react-native init Tasks</strong> 
</pre>
<p>Let the React Native command line interface do its work for a few moments, then open the directory titled <kbd>Tasks</kbd> once it is completed.</p>
<p>From there, running your app in iOS Simulator is as easy as typing the following command:</p>
<pre>
<strong>react-native run-ios</strong> 
</pre>
<p>This will start a process to build and compile your React Native app, launch the iOS Simulator, import your app to the Simulator, and start it. Whenever you make a change to the app, you will be able to reload and see those changes immediately.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Feature planning</h1>
            </header>

            <article>
                
<p>Before writing any code, I'd like to take the time to plan out what I want to accomplish in my project and scope out a <strong>minimum viable product</strong> (<strong>MVP</strong>) to aim for prior to building out any advanced functionalities. This helps with the prioritization of what key components of our app are necessary to have a functioning prototype so that we can have something up and running.</p>
<p>For me, the MVP is a fantastic way to quantify my ideas into something I can interact with and use to validate any assumptions I have, or catch any edge cases, while spending the minimum amount of time necessary on coming to those conclusions. Here's how I approach feature planning:</p>
<ul>
<li>What does the product I'm building do?</li>
<li>Ideally, what are some of the highlighting features that make this application stand out?</li>
<li>Which of the features on the preceding list are necessary to have a working product? Once you know the necessary features, cut out everything that doesn't give you the bare-bones functionality.</li>
<li>Give some thought to its design, but don't stress on every single detail just yet.</li>
</ul>
<p>With these intentions in mind, here's what I've come up with:</p>
<ul>
<li>This is an application that will let me create and track a list of tasks that I have. These can be as small as a shopping list or as big as long-term goals.</li>
<li>I'd like to set a reminder for each unique task so that I can get to each one in an orderly fashion. Ideally, the items on the list can be grouped into categories. Category grouping could perhaps be simplified by something like icons. This way, I can also sort and filter my list by icons.</li>
<li>The only things that are necessary from the beginning are that I can use a text input field to type a task, have it rendered onto a list of items, and mark them off as they are completed; everything else is secondary.</li>
</ul>
<p>Now that we've got a clearer picture of our app, let's break down some actionable steps we can take to make it a reality:</p>
<ol>
<li>Let's <em>generate a list of default items</em>. These don't have to be manually entered as we just want to see our list populated in the app itself.</li>
<li>After that, your users should be able to <em>input their own tasks</em> using a text field and the native keyboard.</li>
<li>Next, I'd like to <em>make that list scrollable</em> in case my list of tasks spans past an entire vertical screen's height.</li>
<li>Then, we should <em>let items be marked as complete</em> with some sort of visual indicator.</li>
</ol>
<p>That's it! These are the four goals we currently have. As I previously mentioned, everything else is secondary for the time being. For now, we just want to get an MVP up and running, and then we will tweak it to our hearts' content later.</p>
<p>Let's move ahead and start thinking about architecture.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Project architecture</h1>
            </header>

            <article>
                
<p>The next important thing I'd like to tackle is architecture; this is about how our React Native app will be laid out. While the projects we build for this book are meant to be done individually, I firmly believe that it is important to always write and architect code in a manner that expects the next person to look at it to be an axe-murderer with a short temper. The idea here is to make it simple for anyone to look at your application's structure and be able to follow along.</p>
<p>First, let's take a look at how the React Native CLI scaffolds our project; comments on each relevant file are noted to the right-hand side of the double slashes (<kbd>//</kbd>):</p>
<pre>
|Tasks // root folder<br/>|__Android*<br/>|__ios*<br/>|__node_modules<br/>|__.buckconfig<br/>|__.flowconfig<br/>|__.gitignore<br/>|__.watchmanconfig<br/>|__index.android.js // Android entry point<br/>|__index.ios.js // iOS entry point<br/>|__package.json // npm package list
</pre>
<p>The <kbd>Android</kbd> and <kbd>iOS</kbd> folders will go several layers deep, but this is all part of its scaffolding and something we will not need to concern ourselves with at this point.</p>
<p>Based on this layout, we see that the entry point for the iOS version of our app is <kbd>index.ios.js</kbd> and that a specific <kbd>iOS</kbd> folder (and <kbd>Android</kbd> for that matter) is generated.</p>
<p>Rather than using these platform-specific folders to store components that are only applicable to one platform, I'd like to propose a folder named <kbd>app</kbd> alongside these which will encapsulate all the logic that we write.</p>
<p>Within this <kbd>app</kbd> folder, we'll have subfolders that contain our components and assets. With components, I'd like to keep its style sheet coupled alongside the JS logic within its own folder.</p>
<p>Additionally, component folders should never be nested--it ends up being way too confusing to follow and search for something. Instead, I prefer to use a naming convention that makes it immediately obvious what one component's relation to its parent/child/sibling happens to be.</p>
<p>Here's how my proposed structure will look:</p>
<pre>
|Tasks <br/>|__app <br/>|____components <br/>|______TasksList <br/>|________index.js <br/>|________styles.js <br/>|______TasksListCell <br/>|________index.js <br/>|________styles.js <br/>|______TasksListInput <br/>|________index.js <br/>|________styles.js <br/>|____images <br/>|__Android <br/>|__ios <br/>|__node_modules <br/>|__.buckconfig <br/>|__.flowconfig <br/>|__.gitignore <br/>|__.watchmanconfig <br/>|__index.android.js <br/>|__index.ios.js <br/>|__package.json 
</pre>
<p>From just a quick observation, you might be able to infer that <kbd>TasksList</kbd> is the component that deals with our list of tasks shown on the screen. <kbd>TasksListCell</kbd> will be each individual row of that list, and <kbd>TasksListInput</kbd> will deal with the keyboard input field.</p>
<p>This is very bare-bones and there are optimizations that we can make. For example, we can think about things such as platform-specific extensions for iOS and Android, as well as building in further architecture for Redux; but for the purpose of this specific app, we will just start with the basics.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">StyleSheet</h1>
            </header>

            <article>
                
<p>React Native's core visual components accept a prop called <kbd>style</kbd> and the names and values more or less match up with CSS's naming conventions, with one major exception--kebab-case is swapped out for camelCase, similar to how things are named in JavaScript. For example, a CSS property of <kbd>background-color</kbd> will translate to <kbd>backgroundColor</kbd> in React Native.</p>
<p>For readability and reuse, it's beneficial to break off inline styling into its own <kbd>styles</kbd> object by defining all of our styles into a <kbd>styles</kbd> object using React Native's <kbd>StyleSheet</kbd> component to create a style object and reference it within our component's <kbd>render</kbd> method.</p>
<p>Taking it a step further, with larger applications, it's best to separate the style sheet into its own JavaScript file for readability's sake. Let's take a look at how each of these compare, using a very annotated version of the Hello World sample that's generated for us. These samples will contain only the code necessary to make my point.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Inline styles</h1>
            </header>

            <article>
                
<p>An inline style is one that is defined within the markup of your code. Check this sample out:</p>
<pre>
class Tasks extends Component { <br/>  render () { <br/>    return ( <br/>      &lt;View style = {{ flex: 1, justifyContent: 'center',  <br/>        alignItems: 'center', backgroundColor: '#F5FCFF'  <br/>      }}&gt; <br/>        &lt;Text style = {{ fontSize: 20, textAlign:  <br/>          'center', margin: 10 }}&gt; <br/>          Welcome to React Native! <br/>        &lt;/Text&gt; <br/>      &lt;/View&gt; <br/>    ) <br/>  } <br/>} 
</pre>
<p>In the preceding code, you can see how inline style can create a very convoluted and confusing mess, especially when there are several style properties that we want to apply to each component. It's not practical for us to write our styles like this in a large-scale application, so let's break apart the styles into a <kbd>StyleSheet</kbd> object.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">With StyleSheet, within the same file</h1>
            </header>

            <article>
                
<p>This is how a component accesses a <kbd>StyleSheet</kbd> created in the same file:</p>
<pre>
class Tasks extends Component { <br/>  render () { <br/>    return ( <br/>      &lt;View style = { styles.container }&gt; <br/>        &lt;Text style = { styles.welcome }&gt; <br/>          Welcome to React Native! <br/>        &lt;/Text&gt; <br/>      &lt;/View&gt; <br/>    ) <br/>  } <br/>} <br/><br/>const styles = StyleSheet.create({ <br/>  container: { <br/>    flex: 1, <br/>    justifyContent: 'center', <br/>    alignItems: 'center', <br/>    backgroundColor: '#F5FCFF' <br/>  }, <br/>  welcome: { <br/>    fontSize: 20, <br/>    textAlign: 'center', <br/>    margin: 10 <br/>  } <br/>)}; 
</pre>
<p>This is much better. We're moving <span>our</span> styles into an object we can reference without having to rewrite the same inline styles over and over. However, the problem we face is an extraordinarily long file with a lot of application logic, where a future maintainer might have to scroll through lines and lines of code to get to the styles. We can take it one step further and separate the styles into their own module.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">StyleSheet as an imported module</h1>
            </header>

            <article>
                
<p>In your component, you can import your styles, as shown:</p>
<pre>
import styles from './styles.js'; <br/><br/>class Tasks extends Component { <br/>  render(){ <br/>    return ( <br/>      &lt;View style = { styles.container }&gt; <br/>        &lt;Text style = { styles.welcome }&gt; <br/>          Welcome to React Native! <br/>        &lt;/Text&gt; <br/>      &lt;/View&gt; <br/>    ) <br/>  } <br/>} <br/>
</pre>
<p>Then, you can define them in a separate file:</p>
<pre>
const styles = StyleSheet.create({ <br/>  container: { <br/>    flex: 1, <br/>    justifyContent: 'center', <br/>    alignItems: 'center', <br/>    backgroundColor: '#F5FCFF' <br/>  }, <br/>  welcome: { <br/>    fontSize: 20, <br/>    textAlign: 'center', <br/>    margin: 10 <br/>  } <br/>)}; <br/><br/>export default styles; 
</pre>
<p>This is much better. By encapsulating our style logic into its own file, we are separating our concerns and making it easier for everyone to read it.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Flexbox</h1>
            </header>

            <article>
                
<p>One thing you might have noted in our <kbd>StyleSheet</kbd> is a property called <kbd>flex</kbd>. This pertains to Flexbox, a CSS layout system that provides consistency in your layout across different screen sizes. Flexbox in React Native works similar to its CSS specification, with only a couple of differences. The most important differences to be noted are that the default <kbd>flex</kbd> direction has been flipped to <kbd>column</kbd> on React Native, as opposed to <kbd>row</kbd> on the Web, aligning items, by default, to the <kbd>stretch</kbd> property for React Native instead of <kbd>flex-start</kbd> in the browser, and the <kbd>flex</kbd> parameter only supports a single number as its value in React Native.</p>
<p>We will pick up a lot on Flexbox as we go through these projects; we'll start by taking a look at just the basics.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">flex</h1>
            </header>

            <article>
                
<p>The <kbd>flex</kbd> property of your layout works a bit differently from how it operates in CSS. In React Native, it accepts a single digit number. If its number is a positive number (meaning greater than 0), the component that has this property will become flexible.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">flexDirection</h1>
            </header>

            <article>
                
<p>Your layout also accepts a property called <kbd>flexDirection</kbd>. There are four options for this: <kbd>row</kbd>, <kbd>row-reverse</kbd>, <kbd>column</kbd>, and <kbd>column-reverse</kbd>. These options dictate the direction that the children of your flex container will be laid out in.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Writing in ES6</h1>
            </header>

            <article>
                
<p><strong>ECMAScript version 6</strong> (<strong>ES6</strong>) is the latest specification of the JavaScript language. It is also referred to as ES2016. It brings new features and syntax to JavaScript, and they are the ones you should be familiar with to be successful in this book.</p>
<p>Firstly, <kbd>require</kbd> statements are now <kbd>import</kbd> statements. They are used to <kbd>import</kbd> functions, object, and so on from an external module or script. In the past, to include React in a file, we would write something like this:</p>
<pre>
var React = require('react'); <br/>var Component = React.Component; 
</pre>
<p>Using ES6 <kbd>import</kbd> statements, we can rewrite it to this:</p>
<pre>
import React, { Component } from 'react'; 
</pre>
<p>The importing of <kbd>Component</kbd> around a curly brace is called destructuring assignment. It's an assignment syntax that lets us extract specific data from an array or object into a variable. With <kbd>Component</kbd> imported through destructuring assignment, we can simply call <kbd>Component</kbd> in our code; it's automatically declared as a variable with the exact same name.</p>
<p>Next up, we're replacing <kbd>var</kbd> with two different statements: <kbd>let</kbd> and <kbd>const</kbd>. The first statement, <kbd>let</kbd>, declares a block-scoped variable whose value can be mutated. The second statement, <kbd>const</kbd>, declares another block-scoped variable whose value cannot change through reassignment nor redeclaration.</p>
<p>In the prior syntax, exporting modules used to be done using <kbd>module.exports</kbd>. In ES6, this is done using the <kbd>export default</kbd> statement.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Building the app</h1>
            </header>

            <article>
                
<p>Going back to our list from a few pages back, this is the first thing I'd like to do with the app:</p>
<ul>
<li>Let's generate a list of default items. These don't have to be manually entered; we just want to see our list populated in the app itself.</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">ListView</h1>
            </header>

            <article>
                
<p>While looking at the documentation for React Native's components, you may note a component named <kbd>ListView</kbd>. This is a core component that is meant to display vertically scrolling lists of data.</p>
<p>Here's how <kbd>ListView</kbd> works. We will create a data source, fill it up with an array of data blobs, create a <kbd>ListView</kbd> component with that array as its data source, and pass it some JSX in its <kbd>renderRow</kbd> callback, which will take the data and render a row for each blob within the data source.</p>
<p>On a high level, here is how it looks:</p>
<pre>
class TasksList extends Component { <br/>  constructor (props) { <br/><br/>    super (props); <br/><br/>    const ds = new ListView.DataSource({ <br/>      rowHasChanged: (r1, r2) =&gt; r1 !== r2 }); <br/><br/>    this.state = { <br/>      dataSource: ds.cloneWithRows(['row 1', 'row 2']) <br/>    }; <br/>  } <br/><br/>  render () { <br/>    return ( <br/>      &lt;ListView <br/>        dataSource = { this.state.dataSource } <br/>        renderRow = { (rowData) =&gt; &lt;Text&gt;  <br/>          { rowData } &lt;/Text&gt; } <br/>      /&gt; <br/>    ); <br/>  } <br/>} 
</pre>
<p>Let's look at what's going on. In the <kbd>constructor</kbd> of our component, we create an instance of <kbd>ListViewDataSource</kbd>. The constructor for a new <kbd>ListViewDataSource</kbd> accepts, as a parameter, an argument that can contain any of these four:</p>
<ul>
<li><kbd>getRowData(dataBlob</kbd>, <kbd>sectionID</kbd>, <kbd>rowID)</kbd></li>
<li><kbd>getSectionHeaderData(dataBlob</kbd>, <kbd>sectionID)</kbd></li>
<li><kbd>rowHasChanged(previousRowData</kbd>, <kbd>nextRowData)</kbd></li>
<li><kbd>sectionHeaderHasChanged(previousSectionData</kbd>, <kbd>nextSectionData)</kbd></li>
</ul>
<p>The <kbd>getRowData</kbd> is a function that gets the data required to render the row. You can customize the function however you like as you pass it in to the constructor of <kbd>ListViewDataSource</kbd>, but <kbd>ListViewDataSource</kbd> will provide a default if you don't specify.</p>
<p>The <kbd>getSectionHeaderData</kbd> is a function that accepts a blob of data and a section ID and returns just the data needed to render a section header. Like <kbd>getRowData</kbd>, it provides a default if not specified.</p>
<p>The <kbd>rowHasChanged</kbd> is a function that serves as a performance optimization designed to only re-render any rows that have their source data changed. Unlike <kbd>getRowData</kbd> and <kbd>getSectionHeaderData</kbd>, you will need to pass your own version of <kbd>rowHasChanged</kbd>. The preceding example, which takes in the current and previous values of the row and returns a Boolean to show if it has changed, is the most common implementation.</p>
<p>The <kbd>sectionHeaderHasChanged</kbd> is an optional function that compares the section headers' contents to determine whether they need to be re-rendered.</p>
<p>Then, in our <kbd>TasksView</kbd> constructor, our state receives a property of <kbd>dataSource</kbd> whose value is equal to calling <kbd>cloneWithRows</kbd> on the <kbd>ListViewDataSource</kbd> instance we created earlier. <kbd>cloneWithRows</kbd> takes in two parameters: a <kbd>dataBlob</kbd> and <kbd>rowIdentities</kbd>. The <kbd>dataBlob</kbd> is any arbitrary blob of data passed to it, and <kbd>rowIdentities</kbd> represents a two-dimensional array of row identifiers. The <kbd>rowIdentities</kbd> is an optional parameter--it isn't included in the preceding sample code. Our sample code passes a hardcoded blob of data--two strings: <kbd>'row 1'</kbd> and <kbd>'row 2'</kbd>.</p>
<p>It's also important to mention right now that the data within our <kbd>dataSource</kbd> is immutable. If we want to change it later, we'll have to extract the information out of the <kbd>dataSource</kbd>, mutate it, and then replace the data within the <kbd>dataSource</kbd>.</p>
<p>The <kbd>ListView</kbd> component itself, which is rendered in our <kbd>TasksList</kbd>, can accept a number of different properties. The most important one, which we're using in our example, is <kbd>renderRow</kbd>.</p>
<p>The <kbd>renderRow</kbd> function takes data from the <kbd>dataSource</kbd> of your <kbd>ListView</kbd> and returns a component to render for each row of data in your <kbd>dataSource</kbd>. In our preceding example, <kbd>renderRow</kbd> takes each string inside our <kbd>dataSource</kbd> and renders it in a <kbd>Text</kbd> component.</p>
<p>With the preceding code, here is how <kbd>TasksList</kbd> will render. Because we have not yet styled it, you will see that the iOS Status Bar overlaps the first row:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1423 image-border" height="512" src="assets/image_01_001-1.png" width="299"/></div>
<p>Great! There's not much to see, but we accomplished something: we created a <kbd>ListView</kbd> component, passed it some data, and got that data to be rendered on our screen. Let's take a step back and create this component in our application properly.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating the TasksList component</h1>
            </header>

            <article>
                
<p>Going back to the proposed file structure from earlier, your project should look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-592 image-border" height="334" src="assets/Screen-Shot-2017-01-03-at-11.03.09-PM.png" width="189"/></div>
<p>Let's start by writing our first component--the <kbd>TasksList</kbd> module.</p>
<p>The first thing we will need to do is import our dependency on React:</p>
<pre>
import React, { Component } from 'react'; 
</pre>
<p>Then, we'll import just the building blocks we need from the React Native (<kbd>react-native</kbd>) library:</p>
<pre>
import { <br/>  ListView, <br/>  Text <br/>} from 'react-native'; 
</pre>
<p>Now, let's write the component. The syntax for creating a new component in ES6 is as follows:</p>
<pre>
export default class TasksList extends Component { <br/>  ... <br/>} 
</pre>
<p>From here, let's give it a constructor function to fire during its creation:</p>
<pre>
export default class TasksList extends Component { <br/>  constructor (props) { <br/>    super (props); <br/>    const ds = new ListView.DataSource({ <br/>     rowHasChanged: (r1, r2) =&gt; r1 !== r2 <br/>    }); <br/><br/>    this.state = { <br/>     dataSource: ds.cloneWithRows([ <br/>        'Buy milk', <br/>        'Walk the dog', <br/>        'Do laundry', <br/>        'Write the first chapter of my book' <br/>      ]) <br/>    }; <br/>  } <br/>} 
</pre>
<p>Our constructor sets up a <kbd>dataSource</kbd> property in the <kbd>TasksList</kbd> state as equal to an array of hardcoded strings. Again, our first goal is to simply render a list on the screen.</p>
<p>Next up, we'll utilize the <kbd>render</kbd> method of the <kbd>TasksList</kbd> component to do just that:</p>
<pre>
  render () { <br/>    return ( <br/>      &lt;ListView <br/>        dataSource={ this.state.dataSource } <br/>        renderRow={ (rowData) =&gt;  <br/>          &lt;Text&gt; { rowData } &lt;/Text&gt; } <br/>      /&gt; <br/>    ); <br/>  } 
</pre>
<p>Consolidated, the code should look like this:</p>
<pre>
// Tasks/app/components/TasksList/index.js <br/><br/>import React, { Component } from 'react'; <br/><br/>import { <br/>  ListView, <br/>  Text <br/>} from 'react-native'; <br/><br/>export default class TasksList extends Component { <br/>  constructor (props) { <br/>    super (props); <br/><br/>    const ds = new ListView.DataSource({ <br/>      rowHasChanged: (r1, r2) =&gt; r1 !== r2 <br/>    }); <br/><br/>    this.state = { <br/>      dataSource: ds.cloneWithRows([ <br/>        'Buy milk', <br/>        'Walk the dog', <br/>        'Do laundry', <br/>        'Write the first chapter of my book' <br/>      ]) <br/>    }; <br/>  } <br/><br/>  render () { <br/>    return ( <br/>      &lt;ListView <br/>        dataSource={ this.state.dataSource } <br/>        renderRow={ (rowData) =&gt; <br/>          &lt;Text&gt;{ rowData }&lt;/Text&gt; } <br/>      /&gt; <br/>    ); <br/>  } <br/>} 
</pre>
<p>Great! That should do it. However, we need to link this component over to our application's entry point. Let's hop over to <kbd>index.ios.js</kbd> and make some changes.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Linking TasksList to index</h1>
            </header>

            <article>
                
<p>Our iOS app's entry point is <kbd>index.ios.js</kbd> and everything that it renders starts from here. Right now, if you launch iOS Simulator using the <kbd>react-native run-ios</kbd> command, you will see the same Hello World sample application that we were acquainted with in the preface.</p>
<p>What we need to do right now is link the <kbd>TasksList</kbd> component we just built to the <kbd>index</kbd> and remove all the unnecessary JSX automatically generated for us. Let's go ahead and clear nearly everything in the <kbd>render</kbd> method of our <kbd>Tasks</kbd> component, except the top layer <kbd>View</kbd> container. When you're done, it should look like this:</p>
<pre>
class Tasks extends Component { <br/>  render () { <br/>    return ( <br/>      &lt;View style={styles.container}&gt; <br/>      &lt;/View&gt; <br/>    ); <br/>  } <br/>} 
</pre>
<p>We'll want to insert <kbd>TasksList</kbd> within that <kbd>View</kbd> container. However, before we do that, we have to give the <kbd>index</kbd> file access to that component. Let's do so using an <kbd>import</kbd> statement:</p>
<pre>
import TasksList from './app/components/TasksList'; 
</pre>
<p>While this <kbd>import</kbd> statement just points to the folder that our <kbd>TasksList</kbd> component is in, React Native intelligently looks for a file named <kbd>index</kbd> and assigns it what we want.</p>
<p>Now that <kbd>TasksList</kbd> is readily available for us to use, let's include it in the <kbd>render</kbd> method for <kbd>Tasks</kbd>:</p>
<pre>
export default class Tasks extends Component { <br/>  render () { <br/>    return ( <br/>      &lt;View style={styles.container}&gt; <br/>        &lt;TasksList /&gt; <br/>      &lt;/View&gt; <br/>    ); <br/>  } <br/>} 
</pre>
<p>If you don't have an iOS Simulator running anymore, let's get it back up and running using the <kbd>react-native run-ios</kbd> command from before. Once things are loaded, this is what you should see:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1432 image-border" height="490" src="assets/image_01_003-1.png" width="272"/></div>
<p>This is awesome! Once it's loaded, let's open up the iOS Simulator <span class="packt_screen">Developer</span> menu by pressing <em><span class="KeyPACKT">Command</span></em> + <em><span class="KeyPACKT">D</span></em> on your keyboard and search for an option that will help us save some time during the creation of our app.</p>
<p>At the end of this section, your <kbd>index.ios.js</kbd> file should look like this:</p>
<pre>
// Tasks/index.ios.js <br/><br/>import React, { Component } from 'react'; <br/>import { <br/>  AppRegistry, <br/>  StyleSheet, <br/>  View <br/>} from 'react-native'; <br/><br/>import TasksList from './app/TasksList'; <br/><br/>export default class Tasks extends Component { <br/>  render() { <br/>    return ( <br/>      &lt;View style={styles.container}&gt; <br/>        &lt;TasksList /&gt; <br/>      &lt;/View&gt; <br/>    ); <br/>  } <br/>} 
</pre>
<p>The following code renders the <kbd>TasksList</kbd> component:</p>
<pre>
const styles = StyleSheet.create({ <br/>  container: { <br/>    flex: 1, <br/>    justifyContent: 'center', <br/>    alignItems: 'center', <br/>    backgroundColor: '#F5FCFF', <br/>  } <br/>}); <br/><br/>AppRegistry.registerComponent('Tasks', () =&gt; Tasks); 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">The iOS Simulator Developer menu</h1>
            </header>

            <article>
                
<p>When you open the <span class="packt_screen">Developer</span> menu, you'll see the following options:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1433 image-border" height="354" src="assets/image_01_004-1.png" width="191"/></div>
<p>I would like to go through some of the options available in this menu, which will help you make the development of your applications a lot smoother. Some of the options are not covered here, but are available for you to read about in the React Native documentation.</p>
<p>First, we will cover the options for reloading:</p>
<ul>
<li><span class="packt_screen">Reload</span>: This reloads your application code. Similar to using <em><span class="KeyPACKT">Command</span></em> + <em><span class="KeyPACKT">R</span></em> on the keyboard, the <span class="packt_screen">Reload</span> option takes you to the beginning of your application flow.</li>
<li><span class="packt_screen">Enable Live Reload</span>: Turning Live Reload on will result in your application automatically performing a reload action whenever your code has changed while you save a file in your project. Live Reload is great because you can enable it once and have your app show you its latest changes whenever you save your file. It's important to know that both <span class="packt_screen">Reload</span> and <span class="packt_screen">Enable Live Reload</span> perform a <em>full</em> reload of your application, including resetting your application state.</li>
<li><span class="packt_screen">Enable Hot Reloading</span>: Hot Reloading is a new feature introduced in React Native in March 2016. If you've worked with React on the Web, this term might be familiar to you. The idea of a Hot Reload is to keep your app running and to inject new code at runtime, which prevents you from losing your application state like with a <span class="packt_screen">Reload</span> (or, by extension, <span class="packt_screen">Enable Live Reload</span>).
<ul>
<li>One of the bottlenecks of building a feature with Live Reload turned on is when you work on a feature several layers deep and rely on your application's state to properly note changes to it. This adds several seconds to the feedback loop of writing and reloading your application. A Hot Reload solves this issue, letting your feedback loop be reduced to less than a second or two.</li>
<li class="packt_nosymbol">Something to be aware of with Hot Reloading is that, in its current iteration, it's not perfect. The React Native documentation notes that, in some instances, you will need to use a regular <span class="packt_screen">Reload</span> to reset your app when Hot Reloading fails.</li>
</ul>
</li>
</ul>
<p>It's equally important to know that if you ever add new assets to your application or modify native Objective-C/Swift or Java/C++ code, your application will need to be fully rebuilt before the changes will take effect.</p>
<p>The next set of options have to do with debugging:</p>
<ul>
<li><span class="packt_screen">Debug JS Remotely</span>: Enabling this will open up Chrome on your machine and take you to a Chrome tab that will allow you to use Chrome Developer Tools to debug your application.</li>
<li><span class="packt_screen">Show Inspector</span>: Similar to inspecting an element on the Web, you can use the <span class="packt_screen">Inspector</span> in React Native development to inspect any element of your application and have it open up parts of your code and the source code that affect that element. You can also view the performance of each specific element this way.</li>
</ul>
<p>Using the <span class="packt_screen">Developer</span> menu, we will enable Hot Reloading. It will give us the quickest feedback loop on the code we're writing, allowing us to move efficiently.</p>
<p>Now that we've got Hot Reloading enabled and a basic list of tasks rendering to the screen, it's time to think about an input--we'll come back to styling later.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">TextInput</h1>
            </header>

            <article>
                
<p>The second goal for building out an MVP was as follows:</p>
<ul>
<li>Our users should be able to input their own tasks using a text field and the native keyboard</li>
</ul>
<p>To successfully create this input, we have to break down the problem into some necessary requirements:</p>
<ul>
<li>We need to have an input field that will spring up our keyboard to type with</li>
<li>The keyboard should hide itself when we tap outside of it</li>
<li>When we successfully add a task, it needs to be added to <kbd>dataSource</kbd> in <kbd>TasksList</kbd>, which is stored in its state</li>
<li>The list of tasks needs to be stored locally in the application so that a state reset doesn't delete the entire list of tasks we've created</li>
<li>There're also a couple of forks in the road we should address:
<ul>
<li>What happens when the user hits <span class="KeyPACKT">return</span> on the keyboard? Does that automatically create a task? Alternatively, do we implement and support a line break?</li>
<li>Is there a dedicated <em>Add this task</em> button?</li>
<li>Does the successful act of adding a task cause the keyboard to go away, requiring the user to tap on the input field again? Alternatively, do we allow the user to keep adding tasks until they tap outside the keyboard?</li>
<li>How many characters do we support? How long is too long for a task? What kind of feedback is presented to the user of our software if they exceed that limit?</li>
</ul>
</li>
</ul>
<p>This is a lot to take in, so let's take it one step at a time! I will propose that we ignore the big decisions for now and have the simple act of having an input on the screen, and then having that input be added to our list of tasks.</p>
<p>Since input should be saved to state and then rendered in the <kbd>ListView</kbd>, it makes sense for the input component to be a sibling of the <kbd>ListView</kbd>, allowing them to share the same state.</p>
<p>Architecturally, this is how the <kbd>TasksList</kbd> component will look:</p>
<pre>
|TasksList <br/>|__TextInput <br/>|__ListView <br/>|____RowData <br/>|____RowData <br/>|____... <br/>|____RowData 
</pre>
<p>React Native has a <kbd>TextInput</kbd> component in its API that fulfills our need for a keyboard input. Its code is customizable and will allow us to take input and add it to our list of tasks.</p>
<p>This <kbd>TextInput</kbd> component can accept a multitude of props. I have listed the ones we will use here, but the documentation for React Native will provide much more depth:</p>
<ul>
<li><kbd>autoCorrect</kbd>: This is a Boolean that turns autocorrection on and off. It is set to <kbd>true</kbd> by default</li>
<li><kbd>onChangeText</kbd>: This is a callback that is fired when the input field's text changes. The value of the component is passed as an argument to the callback</li>
<li><kbd>onSubmitEditing</kbd>: This is a callback that is fired when a single-line input's submit button is pressed</li>
<li><kbd>returnKeyType</kbd>: This sets the title of the return key to one of many different strings; <kbd>done</kbd>, <kbd>go</kbd>, <kbd>next</kbd>, <kbd>search</kbd>, and <kbd>send</kbd> are the five that work across both the platforms</li>
</ul>
<p>We can break down the task at hand into a couple of bite-sized steps:</p>
<ul>
<li>Update container styling in <kbd>index.ios.js</kbd> so that its contents take up the entire screen and not just the center</li>
<li>Add a <kbd>TextInput</kbd> component to our <kbd>TasksList</kbd> component's <kbd>render</kbd> method</li>
<li>Create a submit handler for the <kbd>TextInput</kbd> component that will take the value of the text field and add it to <kbd>ListView</kbd></li>
<li>Clear the contents of the <kbd>TextInput</kbd> once submitted, leaving a blank field for the next task to be added</li>
</ul>
<p>Take some time to try and add this first feature into our app! In the next section, I will share some screenshots of my results and break down the code I wrote for it.</p>
<p>Here's a screen to show how my input looks at this stage:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1434 image-border" height="425" src="assets/image_01_005-1.png" width="248"/></div>
<p>It meets the four basic requirements listed in the preceding section: the contents aren't centered on the screen, a <kbd>TextInput</kbd> component is rendered at the top, the submit handler takes the value of the <kbd>TextInput</kbd> component and adds it to the <kbd>ListView</kbd>, and the contents of the <kbd>TextInput</kbd> are emptied once that happens.</p>
<p>Let's look at the code to see how I tackled it--yours may be different!:</p>
<pre>
// Tasks/index.ios.js <br/><br/>import React, { Component } from 'react'; <br/>import { <br/>  AppRegistry, <br/>  View <br/>} from 'react-native'; <br/><br/>import TasksList from './app/components/TasksList'; <br/><br/>export default class Tasks extends Component { <br/>  render() { <br/>    return ( <br/>      &lt;View&gt; <br/>        &lt;TasksList /&gt; <br/>      &lt;/View&gt; <br/>    ); <br/>  } <br/>} <br/><br/>AppRegistry.registerComponent('Tasks', () =&gt; Tasks);
</pre>
<p>This is the updated styling for <kbd>TasksList</kbd>:</p>
<pre>
// Tasks/app/components/TasksList/styles.js<br/><br/>import { StyleSheet } from 'react-native'; <br/><br/>const styles = StyleSheet.create({ <br/>  container: { <br/>    flex: 1 <br/>  } <br/>}); <br/><br/>export default styles; 
</pre>
<p>What I did here was remove the <kbd>justifyContent</kbd> and <kbd>alignItems</kbd> properties of the container so that items weren't constrained to just the center of the display.</p>
<p>Moving on to the <kbd>TasksList</kbd> component, I made a couple of major changes:</p>
<pre>
// Tasks/app/components/TasksList/index.js <br/><br/>import React, { Component } from 'react'; <br/><br/>import { <br/>  ListView, <br/>  Text, <br/>  TextInput, <br/>  View <br/>} from 'react-native'; <br/><br/>import styles from './styles'; <br/><br/>export default class TasksList extends Component { <br/>  constructor (props) { <br/>    super (props); <br/><br/>    const ds = new ListView.DataSource({ <br/>      rowHasChanged: (r1, r2) =&gt; r1 !== r2 <br/>    }); <br/><br/>    this.state = { <br/>      ds: new ListView.DataSource({ <br/>        rowHasChanged: (r1, r2) =&gt; r1 !== r2 <br/>      }), <br/>      listOfTasks: [], <br/>      text: '' <br/>    }; <br/>  } 
</pre>
<p>The constructor now saves three things to state: our local instance of <kbd>ListView.DataSource</kbd>, an empty string to keep track of the value of <kbd>TextInput</kbd>, and an array to store the list of tasks.</p>
<p>The <kbd>render</kbd> function creates a reference to a <kbd>dataSource</kbd> that we will use for our <kbd>ListView</kbd> component, cloning the <kbd>listOfTasks</kbd> array stored in state. Once again, the <kbd>ListView</kbd> just presents plain text:</p>
<pre>
  render () { <br/>    const dataSource = <br/>    this.state.ds.cloneWithRows(this.state.listOfTasks); 
</pre>
<p>The <kbd>TextInput</kbd> component has a couple of options. It binds the <kbd>value</kbd> of its input field to the <kbd>text</kbd> value of our state, changing it repeatedly as the field is edited. On submitting it by pressing the <em>done</em> key on the keyboard, it fires a callback called <kbd>_addTask</kbd>:</p>
<pre>
    return ( <br/>      &lt;View style={ styles.container }&gt; <br/>        &lt;TextInput <br/>          autoCorrect={ false } <br/>          onChangeText={ (text) =&gt; this._changeTextInputValue(text) } <br/>          onSubmitEditing={ () =&gt; this._addTask() } <br/>          returnKeyType={ 'done' } <br/>          style={ styles.textInput } <br/>          value={ this.state.text } <br/>        /&gt; 
</pre>
<p>It renders a <kbd>ListView</kbd> component with the <kbd>_renderRowData</kbd> method being responsible for returning each individual row of the component:</p>
<pre>
        &lt;ListView <br/>          dataSource={ dataSource } <br/>          enableEmptySections={ true } <br/>          renderRow={ (rowData) =&gt; this._renderRowData(rowData) } <br/>        /&gt; <br/>      &lt;/View&gt; <br/>    ); <br/>  } 
</pre>
<p>I like to start the name of methods that I personally create in a React component with an underscore so that I can visually distinguish them from the default life cycle methods.</p>
<p>The <kbd>_addTask</kbd> method uses the array spread operator introduced in ES6 to create a new array and copy over an existing array's values, adding the newest task to the list at the end. Then, we assign it to the <kbd>listOfTasks</kbd> property in state. Remember that we have to treat our component state as an immutable object and simply pushing to it will be an anti-pattern:</p>
<pre>
_addTask () { <br/>    const listOfTasks = [...this.state.listOfTasks, this.state.text]; <br/><br/>    this.setState({ <br/>      listOfTasks <br/>    }); <br/><br/>    this._changeTextInputValue('' <br/>  } 
</pre>
<p>Finally, we call <kbd>_changeTextInputValue</kbd> so that the <kbd>TextInput</kbd> box is emptied:</p>
<pre>
  _changeTextInputValue (text) { <br/>    this.setState({ <br/>      text <br/>    }); <br/>  } 
</pre>
<pre>
  _renderRowData (rowData) { <br/>    return ( <br/>      &lt;Text&gt;{ rowData }&lt;/Text&gt; <br/>    ) <br/>  } <br/>} 
</pre>
<p>For now, just returning the name of the to-do list item is fine.</p>
<p>When setting the <kbd>listOfTasks</kbd> property in the <kbd>_addTask</kbd> method and the <kbd>text</kbd> property in <kbd>_changeTextInputValue</kbd>, I'm using a new notation feature of ES6, called shorthand property names, to assign a value to a key with the same name as the value. This is the same as if I were to write as follows:</p>
<pre>
this.setState({ <br/>  listOfTasks: listOfTasks, <br/>  text: text <br/>}) 
</pre>
<p>Moving on, you might note that, as you refresh the application, you lose your state! This is impractical for a to-do list app, since we should never expect the user to re-enter the same list whenever they re-open the app. What we want is to store this list of tasks locally in the device so that we can access it whenever needed. This is where <kbd>AsyncStorage</kbd> comes into play.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">AsyncStorage</h1>
            </header>

            <article>
                
<p>The <kbd>AsyncStorage</kbd> component is a simple key-value store that is globally available to your React Native application. It's persistent, meaning that data within <kbd>AsyncStorage</kbd> will continue to exist through quitting or restarting the application or your phone. If you've worked with HTML <kbd>LocalStorage</kbd> and <kbd>SessionStorage</kbd>, <kbd>AsyncStorage</kbd> will seem familiar. It's powerful for light usage, but Facebook recommends that you use an abstraction layer on top of <kbd>AsyncStorage</kbd> for anything more than that.</p>
<p>As the name implies, <kbd>AsyncStorage</kbd> is asynchronous. If you haven't yet been introduced to asynchronous JavaScript, this means the methods of this storage system can run concurrently with the rest of your code. The methods of <kbd>AsyncStorage</kbd> return a <kbd>Promise</kbd>--an object that represents an operation that hasn't yet completed, but is expected to in the future.</p>
<p>Each of the methods in <kbd>AsyncStorage</kbd> can accept a callback function as an argument, and will fire that callback once the <kbd>Promise</kbd> is fulfilled. This means that we can write our <kbd>TasksList</kbd> component to work around these promises, saving and retrieving our array of tasks when needed.</p>
<p>One final thing about <kbd>AsyncStorage</kbd> though--it's a simple key-value store. It expects a string for both its key and value, which means that we'll need to transform the data we send using <kbd>JSON.stringify</kbd> to turn the array into a string when sending it into storage and <kbd>JSON.parse</kbd> to transform it back into an array when retrieving it.</p>
<p>Play with <kbd>AsyncStorage</kbd> and update your <kbd>TasksList</kbd> component to support it. Here are some goals you'll want to have with <kbd>AsyncStorage</kbd>:</p>
<ul>
<li>Once <kbd>TasksList</kbd> is loaded, we want to see whether any tasks exist locally in storage. If they do, present this list to the user. If they don't, start off with an empty array for storage. Data should always persist through a restart.</li>
<li>When a task is entered, we should update the list of tasks, save the updated list into <kbd>AsyncStorage</kbd>, and then update the <kbd>ListView</kbd> component.</li>
</ul>
<p>Here's the code I ended up writing:</p>
<pre>
// TasksList/app/components/TasksList/index.js<br/><br/>... <br/>import { <br/>  AsyncStorage, <br/>  ... <br/>} from 'react-native'; <br/>... 
</pre>
<p>Import the <kbd>AsyncStorage</kbd> API from the React Native SDK.</p>
<pre>
export default class TasksList extends Component { <br/>  ... <br/>  componentDidMount () { <br/>    this._updateList(); <br/>  } 
</pre>
<p>Call the <kbd>_updateList</kbd> method during the <kbd>componentDidMount</kbd> life cycle.</p>
<pre>
  ... <br/>  async _addTask () { <br/>    const listOfTasks = [...this.state.listOfTasks, this.state.text]; <br/><br/>    await AsyncStorage.setItem('listOfTasks', <br/>    JSON.stringify(listOfTasks)); <br/><br/>    this._updateList(); <br/>  } 
</pre>
<p>Update <kbd>_addTask</kbd> to use the <kbd>async</kbd> and <kbd>await</kbd> keywords as well as <kbd>AsyncStorage</kbd>. Refer to the following for details on using <kbd>async</kbd> and <kbd>await</kbd>:</p>
<pre>
  ... <br/>  async _updateList () { <br/>    let response = await AsyncStorage.getItem('listOfTasks'); <br/>    let listOfTasks = await JSON.parse(response) || []; <br/><br/>    this.setState({ <br/>      listOfTasks <br/>    }); <br/><br/>    this._changeTextInputValue(''); <br/>  } <br/>} 
</pre>
<p>What we are doing with <kbd>AsyncStorage</kbd> in <kbd>_updateTask</kbd> is grabbing the value locally stored using the <kbd>listOfTasks</kbd> key. From here, we parse the result, transforming the string back into an array. Then, we check to see whether the array exists and set it to an empty array if it returns <kbd>null</kbd>. Finally, we set the state of our component by updating <kbd>listOfTasks</kbd> and firing <kbd>_changeTextInputValue</kbd> to reset <kbd>TextInput</kbd> value.</p>
<p>The preceding example also uses the new <kbd>async</kbd> and <kbd>await</kbd> keywords that are part of the ES7 specification proposal and readily available to use with React Native.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Using the Async and Await keywords</h1>
            </header>

            <article>
                
<p>Normally, to deal with an asynchronous function, we would chain some promises to it in order to grab our data. We can write <kbd>_updateList</kbd>, like this:</p>
<pre>
_updateList () { <br/>  AsyncStorage.getItem('listOfTasks'); <br/>    .then((response) =&gt; {fto <br/>      return JSON.parse(response); <br/>    }) <br/>    .then((parsedResponse) =&gt; { <br/>      this.setState({ <br/>        listOfTasks: parsedResponse <br/>      }); <br/>    }); <br/>} 
</pre>
<p>However, this can become quite complicated. Instead, we will use the <kbd>async</kbd> and <kbd>await</kbd> keywords to create a simpler solution:</p>
<pre>
async _updateList () { <br/>  let response = await AsyncStorage.getItem('listOfTasks'); <br/>  let listOfTasks = await JSON.parse(response) || []; <br/><br/>  this.setState({ <br/>    listOfTasks <br/>  }); <br/><br/>  this._changeTextInputValue(''); <br/>} 
</pre>
<p>The <kbd>async</kbd> keyword in front of <kbd>_updateList</kbd> declares it as an asynchronous function. It automatically returns promises for us and can take advantage of the <kbd>await</kbd> keyword to tell the JS interpreter to temporarily exit the asynchronous function and resume running when the asynchronous call is completed. This is great for us because we can express our intent in a sequential order in a single function and still receive the exact same results that we would enjoy with a promise.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Custom RenderRow component</h1>
            </header>

            <article>
                
<p>The final thing on our list to have a usable minimum viable product is to allow each task to be marked as complete. This is where we'll create the <kbd>TasksListCell</kbd> component and render that in our <kbd>renderRow</kbd> function of <kbd>ListView</kbd> instead of just the text.</p>
<p>Our goals for this component should be as follows:</p>
<ul>
<li>Accept text from the parent component as a prop, rendering it in <kbd>TasksListCell</kbd></li>
<li>Update <kbd>listOfTasks</kbd> to take in an array of objects rather than an array of strings, allowing each object to track the name of the task and whether or not it's completed</li>
<li>Provide some sort of visual indicator when a task is tapped, marking it as complete both visually and within the task's <kbd>data</kbd> object, so this persists through application reloads</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Custom RenderRow example</h1>
            </header>

            <article>
                
<p>Let's look at how I created this component:</p>
<pre>
// Tasks/app/components/TasksList/index.js <br/><br/>... <br/>import TasksListCell from '../TasksListCell'; <br/>... <br/>export default class TasksList extends Component { <br/>  ... <br/>  async _addTask () { <br/>    const singleTask = { <br/>      completed: false, <br/>      text: this.state.text <br/>    } 
</pre>
<p>Firstly, tasks are now represented as objects within the array. This allows us to add properties to each task, such as its completed state, and leaves room for future additions.</p>
<pre>
    const listOfTasks = [...this.state.listOfTasks, singleTask]; <br/>    await AsyncStorage.setItem('listOfTasks', <br/>    JSON.stringify(listOfTasks)); <br/>    this._updateList(); <br/>  } <br/>  ... <br/>  _renderRowData (rowData, rowID) { <br/>    return ( <br/>      &lt;TasksListCell <br/>        completed={ rowData.completed } <br/>        id={ rowID } <br/>        onPress={ (rowID) =&gt; this._completeTask(rowID) } <br/>        text={ rowData.text } <br/>      /&gt; <br/>    ) <br/>  } <br/>  ... <br/>} 
</pre>
<p>The <kbd>_renderRowData</kbd> method is also updated to render a new <kbd>TasksListCell</kbd> component. Four <kbd>props</kbd> are shared to <kbd>TasksListCell</kbd>: the task's completed state, its row identifier (provided by <kbd>renderRow</kbd>), a callback to alter the task's completed state, and the details of that task itself.</p>
<p>Here's how that <kbd>TasksListCell</kbd> component was written:</p>
<pre>
// Tasks/app/components/TasksListCell/index.js <br/><br/>import React, { Component, PropTypes } from 'react'; <br/><br/>import { <br/>  Text, <br/>  TouchableHighlight, <br/>  View <br/>} from 'react-native'; <br/><br/>export default class TasksListCell extends Component { <br/>  static propTypes = { <br/>    completed: PropTypes.bool.isRequired, <br/>    id: PropTypes.string.isRequired, <br/>    onLongPress: PropTypes.func.isRequired, <br/>    onPress: PropTypes.func.isRequired, <br/>    text: PropTypes.string.isRequired <br/>  } 
</pre>
<p>Use <kbd>PropTypes</kbd> to explicitly declare the data this component expects to be given. Read on for an explanation on prop validation in React.</p>
<pre>
  constructor (props) { <br/>    super (props); <br/>  } <br/><br/>  render () { <br/>    const isCompleted = this.props.completed ? 'line-through' : 'none'; <br/>    const textStyle = { <br/>      fontSize: 20, <br/>      textDecorationLine: isCompleted <br/>    }; 
</pre>
<p>Use a ternary operator to calculate styling for a task if it is completed.</p>
<pre>
    return ( <br/>      &lt;View&gt; <br/>        &lt;TouchableHighlight <br/>          onPress={ () =&gt; this.props.onPress(this.props.id) } <br/>          underlayColor={ '#D5DBDE' } &gt; <br/>          &lt;Text style={ textStyle }&gt;{ this.props.text }&lt;/Text&gt; <br/>        &lt;/TouchableHighlight&gt; <br/>      &lt;/View&gt; <br/>    ) <br/>  } <br/>} 
</pre>
<p>The preceding component provides a <kbd>TouchableHighlight</kbd> for each task on the list, giving us visual opacity feedback when an item is tapped on. It also fires the <kbd>_completeTask</kbd> method of <kbd>TasksListCell</kbd>, which subsequently calls the <kbd>onPress</kbd> prop that was passed to it and makes a visual change to the style of the cell, marking it <em>completed</em> with a <em>line through</em> the horizontal center of the task.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Prop validation in React</h1>
            </header>

            <article>
                
<p>By declaring a propTypes object for a component, I can specify the expected props and their types for a given component. This is helpful for future maintainers of our code and provides helpful warnings when props are incorrectly entered or missing.</p>
<p>To take advantage of prop validation, first import the <kbd>PropTypes</kbd> module from React:</p>
<pre>
import { PropTypes } from 'react'; 
</pre>
<p>Then, in our component, we give it a static property of <kbd>propTypes</kbd>:</p>
<pre>
class Example extends Component { <br/>  static propTypes = { <br/>    foo: PropTypes.string.isRequired, <br/>    bar: PropTypes.func, <br/>    baz: PropTypes.number.isRequired <br/>  } <br/>} 
</pre>
<p>In the preceding example, <kbd>foo</kbd> and <kbd>baz</kbd> are the required props for the <kbd>Example</kbd> component. <kbd>foo</kbd> is expected to be a string, while <kbd>baz</kbd> is expected to be a number. <kbd>bar</kbd>, on the other hand, is expected to be a function but is not a required prop.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Moving beyond MVP</h1>
            </header>

            <article>
                
<p>Now that we have a very bare-bones MVP completed, the next goal is to add some features to the application so that it's fully-fledged.</p>
<p>Here's what I wrote earlier regarding some nice-to-have features:</p>
<div class="packt_tip">I'd like to set a reminder for each unique task so that I can get to each one in an orderly fashion. Ideally, the items on the list can be grouped into categories. Category grouping could perhaps be simplified by something like icons. This way, I can also sort and filter my list by icons.</div>
<p>In addition to the features, we should tweak the styling of the application so that it looks better. In my sample code, the app's components conflict with the iOS's status bar and the rows aren't formatted at all. We should give the app its own identity.</p>
<p>The next chapter will dive deeper into our MVP and transform it into a fully-featured and styled application. We'll also look at things we would do differently if the app were written for Android instead.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>In this chapter, you started out strong by planning a minimum viable product version of a to-do list app, complete with adding tasks to the list and marking them as completed. Then, you learned about basic styling in React Native with Flexbox and became acquainted with new syntax and functionalities of the ES6 specification. You also discovered the iOS simulator debugging menu, which is a helpful tool for writing apps.</p>
<p>Afterward, you created a <kbd>ListView</kbd> component to render an array of items, and then implemented a <kbd>TextInput</kbd> component to save user input and render that into the <kbd>Listview</kbd>. Then, you used <kbd>AsyncStorage</kbd> to persist the data added to the app by the user, utilizing the new <kbd>async</kbd> and <kbd>await</kbd> keywords to write clean asynchronous functions. Finally, you implemented a <kbd>TouchableHighlight</kbd> cell that marks tasks as completed.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>