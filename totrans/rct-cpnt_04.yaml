- en: Chapter 4. Styling and Animating Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 组件的样式和动画
- en: In the last chapter, you learned how persist pages even after reloading the
    page or restarting the browser. We're at the point now where this could start
    to be a useful system for us. Unfortunately, it still looks rough and unstyled.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何在重新加载页面或重启浏览器后持久化页面。现在，这已经开始成为对我们有用的系统了。不幸的是，它仍然看起来很粗糙，没有样式。
- en: That's because, up until now, we've almost completely ignored styles in our
    components. In this chapter, we will change all that!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，到目前为止，我们几乎完全忽略了组件中的样式。在本章中，我们将改变所有这些！
- en: You will learn how to add custom styles and class names to component elements.
    We'll add animations to new and old components. We'll even learn how to combine
    the two to create highly reusable styles and animation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何为组件元素添加自定义样式和类名。我们将为新旧组件添加动画。我们甚至将学习如何将两者结合起来创建高度可重用的样式和动画。
- en: Adding new pages
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新页面
- en: So far, we are able to change and remove pages from our content management system.
    We ended the last chapter by seeding our local storage with a serialized array,
    so we could see it in action. Let's take a step back and make a way to create
    new pages through the interface.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们能够更改和从我们的内容管理系统移除页面。我们在上一章结束时通过在本地存储中播种序列化数组来结束，这样我们就可以看到它的实际效果。让我们退一步，通过界面创建新页面的方法。
- en: 'First, we''ll add an `insert` method and update the `constructor` method of
    `Backend`:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加一个`insert`方法并更新`Backend`的`constructor`方法：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The page `id` values aren't really important to us outside the context of our
    React components. So, it's fine to regenerate them as the pages are loaded from
    local storage. We keep track of the internal `id` value, so new pages can be assigned
    a new `id` value when they are created.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 页面`id`值对我们来说并不重要，除了在React组件的上下文中。因此，当页面从本地存储加载时，重新生成它们是完全可以的。我们跟踪内部`id`值，以便在创建新页面时为新页面分配一个新的`id`值。
- en: The `insert` method pushes a new page object onto the list of pages. We then
    update the `pages` data in local storage so it's available the next time we need
    the pages. And, as with the `update` and `delete` methods, we emit an `update`
    event, so all concerned components will update their state.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert`方法将一个新的页面对象推送到页面列表中。然后我们更新本地存储中的`pages`数据，以便在下次需要页面时可用。并且，与`update`和`delete`方法一样，我们发出一个`update`事件，以便所有相关的组件都会更新其状态。'
- en: 'We can use this `insert` method in `PageAdmin`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`PageAdmin`中使用这个`insert`方法：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `render` method, add the following code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在`render`方法中，添加以下代码：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Along with the rest of the code we wrote, the interface looks like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们编写的其他代码外，界面看起来是这样的：
- en: '![Adding new pages](img/5268_04_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![添加新页面](img/5268_04_01.jpg)'
- en: Adding styles to components
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为组件添加样式
- en: There are a number of ways we could improve the appearance of our components.
    Let's take the `PageView` component, for example. What would make it better? Perhaps
    if we increased the font size and used a sans serif font, the titles would be
    clearer to read. Perhaps we could increase the margin around each page.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方法可以改善我们组件的外观。以`PageView`组件为例。什么可以使它变得更好？也许如果我们增加字体大小并使用无衬线字体，标题将更容易阅读。也许我们可以增加每页周围的边距。
- en: 'There are a few different ways to style our components. The first is by adding
    styles inline to the `render` method in `PageView`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种不同的方式来样式化我们的组件。第一种是在`PageView`的`render`方法中内联添加样式：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can define a set of styles for each element we want our component to render.
    For the outer `div` element, we define a font size and family. For the `label`
    title, we tell the browser not to wrap text. For each button, we add margins.
    Each style object may be overwritten through properties, owing to the `var value
    = value1 || value2` notation. That's shorthand for saying if `value1` is undefined,
    use `value2`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为想要我们的组件渲染的每个元素定义一组样式。对于外部的`div`元素，我们定义字体大小和家族。对于`label`标题，我们告诉浏览器不要换行。对于每个按钮，我们添加边距。每个样式对象都可以通过属性覆盖，归因于`var
    value = value1 || value2`的表示法。这是说如果`value1`是未定义的，则使用`value2`的简写。
- en: 'We should also apply those styles to the list items, so the numbers appear
    in the same manner as the titles:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该将这些样式应用到列表项上，以便数字以与标题相同的方式显示：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note how there are two sets of braces for the `style` object? That's how we
    define objects as properties. In this case, it's an object of styles we want applied
    to each list item.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`style`对象有两对花括号？这就是我们定义对象作为属性的方式。在这种情况下，它是一个我们想要应用于每个列表项的样式对象。
- en: Changing and reverting
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改和撤销
- en: 'Now we can style our edit form. Let''s replace the modification indicator (asterisk)
    with a button that will simulate the save action:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为我们的编辑表单设置样式。让我们将修改指示符（星号）替换为一个模拟保存操作的按钮：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This gives the illusion that clicking on the **Save** button will save something,
    when the save happens regardless. This poses an interesting question—should we
    make the **Cancel** button cancel the edit? Because right now it's just a back
    button masquerading as a cancel button. We should also define an `onSave` function
    to pass to this component.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这给人一种点击**保存**按钮会保存一些内容的错觉，而保存实际上已经发生。这提出了一个有趣的问题——我们应该让**取消**按钮取消编辑吗？因为现在它只是一个伪装成取消按钮的后退按钮。我们还应该定义一个`onSave`函数并将其传递给这个组件。
- en: To do that, we'd have to track its initial state. But where would we get this
    initial state? The `PageEditor` component receives the page details through properties,
    so the current state is the same in `PageEditor` as it is in `Backend`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要跟踪其初始状态。但我们在哪里可以获得这个初始状态呢？`PageEditor`组件通过属性接收页面详情，所以当前状态在`PageEditor`中与在`Backend`中相同。
- en: 'Perhaps we should store the state when `PageView` is hidden and `PageEditor`
    is shown:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们应该在`PageView`隐藏和`PageEditor`显示时存储状态：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When the page enters edit mode, we store the unedited title. We should change
    the `onCancel` method to actually cancel a change:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面进入编辑模式时，我们存储未编辑的标题。我们应该将`onCancel`方法更改为实际取消更改：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When the `onCancel` property is called, we set the page title to the unedited
    title we stored earlier. We need to bind this new `onSave` method in the constructor:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`onCancel`属性时，我们将页面标题设置为之前存储的未编辑标题。我们需要在构造函数中绑定这个新的`onSave`方法：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This assures that `this` refers to the page component when the `onSave` property
    is later called. We''ll need to pass this new method to the `PageEditor` component
    in the form of a property:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了当稍后调用`onSave`属性时，`this`指的是页面组件。我们需要将这个新方法以属性的形式传递给`PageEditor`组件：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, instead of both the `PageEditor` buttons calling `this.props.onCancel`,
    they can call their applicable methods:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`PageEditor`的两个按钮不再调用`this.props.onCancel`，而是可以调用它们适用的方法：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Animating new components
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画新组件
- en: At the moment, new pages are just appearing. There's no subtle animation to
    ease them in. Let's change that!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，新页面只是出现。没有微妙的动画来缓解它们的进入。让我们改变这一点！
- en: We will use a new React component for this, and we can find it in the add-ons
    build of React. Go back to the React scripts you downloaded in the first chapter
    and replace all references to `react.js` with `react-with-addons.js`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个新的React组件来完成这个任务，我们可以在React的附加组件构建中找到它。回到你在第一章下载的React脚本，将所有对`react.js`的引用替换为`react-with-addons.js`。
- en: 'This gives us access to a new component called `CSSTransitionGroup`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够访问一个名为`CSSTransitionGroup`的新组件：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This new container component watches for changes in its children. When new
    child components are added, they are given a couple of CSS class names, which
    can apply CSS animation. We need to add this animation to the corresponding CSS
    styles:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的容器组件会监视其子组件的变化。当添加新的子组件时，它们会被赋予几个CSS类名，这些类名可以应用CSS动画。我们需要将这个动画添加到相应的CSS样式：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since we specified `transitionName="page"`, React adds `page-enter` and `page-leave`
    to the `Page` components, as they enter and leave `PageAdmin`. Note how `150ms`
    in our styles matches `transitionEnterTimeout={150}`? They need to be the same.
    React adds classes such as `page-enter-active` for those `150ms`, and then removes
    them. This ensures that transitions only happen once.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们指定了`transitionName="page"`，React在`Page`组件进入和离开`PageAdmin`时添加了`page-enter`和`page-leave`，注意我们样式中的`150ms`与`transitionEnterTimeout={150}`匹配？它们需要相同。React为这`150ms`添加了类名，如`page-enter-active`，然后移除它们。这确保了过渡只发生一次。
- en: Working with CSS transitions
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CSS过渡效果
- en: It's a great time to talk about CSS transitions. We have used them to fade and
    slide new `Page` components in from the left. If you're unfamiliar with how they
    generally work, the code might be confusing and difficult to change.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是讨论CSS过渡的好时机。我们已使用它们从左侧淡入和滑动新的`Page`组件。如果你不熟悉它们通常的工作方式，代码可能会让人困惑且难以更改。
- en: 'There are a few things you should know. The first is that you can transition
    individual CSS properties or all of them at once:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有几件事情你应该知道。第一点是你可以过渡单个CSS属性或所有属性：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this example, we only want to transition the background color. The font
    size will immediately jump from `16px` to `18px`. Alternatively, we can transition
    all CSS properties:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只想过渡背景颜色。字体大小将立即从 `16px` 跳跃到 `18px`。或者，我们也可以过渡所有 CSS 属性：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We''ve already seen transition duration, albeit briefly. We can use `ms` or
    `s` as units for these:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了过渡持续时间，尽管只是简短地提到了。我们可以使用 `ms` 或 `s` 作为这些的单元：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then there are timing functions. These control how the animation gets from
    0% to 100%. They''re sometimes called curves because of how they''re often demonstrated:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是时间函数。这些控制动画如何从 0% 到 100%。它们有时被称为曲线，因为它们通常是这样展示的：
- en: '![Working with CSS transitions](img/5268_04_02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![与 CSS 过渡一起工作](img/5268_04_02.jpg)'
- en: Linear is the most basic of these timing functions, moving evenly from 0% to
    100%. It's also the default `timing` function.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 线性是这些时间函数中最基本的，它均匀地从 0% 移动到 100%。它也是默认的 `timing` 函数。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: You can see these demonstrated at [http://easings.net](http://easings.net).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [http://easings.net](http://easings.net) 看到这些示例。
- en: You can also define your own curve, in the `cubic-bezier(x1, y1, x2, y2)` form.
    That's a bit advanced for now, but it's good to know in any case.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以定义自己的曲线，形式为 `cubic-bezier(x1, y1, x2, y2)`。这目前有点高级，但无论如何都是好的。
- en: 'Transitions can also be delayed, so they only happen after the desired amount
    of time:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡也可以延迟，因此它们只在经过一定时间后才会发生：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Altogether, these styles look like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，这些样式看起来是这样的：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As in the previous section, you can bundle all of these properties together
    into a smaller set:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你可以将这些属性捆绑成一个更小的集合：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Not all properties can be transitioned. Properties need to have some form of
    granularity. Some common properties are as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有属性都可以进行过渡。属性需要有一定的粒度。以下是一些常见的属性：
- en: '`background` (applies to color and position)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`背景`（应用于颜色和位置）'
- en: '`border` (applies to color, width, and spacing)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`边框`（应用于颜色、宽度和间距）'
- en: '`bottom`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`底部`'
- en: '`clip`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`裁剪`'
- en: '`color`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`颜色`'
- en: '`crop`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`裁剪`'
- en: '`font` (applies to size and weight)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`字体`（应用于大小和粗细）'
- en: '`height`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`高度`'
- en: '`left`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`左边距`'
- en: '`letter-spacing`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`字母间距`'
- en: '`line-height`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`行高`'
- en: '`margin`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`外边距`'
- en: '`max-height`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`最大高度`'
- en: '`max-width`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`最大宽度`'
- en: '`min-height`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`最小高度`'
- en: '`min-width`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`最小宽度`'
- en: '`opacity`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`不透明度`'
- en: '`outline` (applies to color, offset, and width)'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`轮廓`（应用于颜色、偏移和宽度）'
- en: '`padding`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`内边距`'
- en: '`right`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`右边距`'
- en: '`text-indent`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`文本缩进`'
- en: '`text-shadow`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`文本阴影`'
- en: '`top`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`顶部`'
- en: '`vertical-align`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`垂直对齐`'
- en: '`visibility`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`可见性`'
- en: '`width`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`宽度`'
- en: '`word-spacing`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`单词间距`'
- en: '`z-index`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`z-index`'
- en: Organizing styles with Sass
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Sass 组织样式
- en: Style sheets are a great alternative to inline component styles. CSS is wonderfully
    expressive as a language for finding and applying visual characteristics to elements.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 样式表是内联组件样式的优秀替代品。CSS 作为一种寻找并应用于元素视觉特性的语言，非常具有表现力。
- en: Unfortunately, it also has drawbacks. The biggest drawback to CSS is that all
    styles are in global scope. Some styles are inherited, and styles applied to elements
    often collide (and cancel each other out).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，它也有缺点。CSS 的最大缺点是所有样式都在全局范围内。一些样式是继承的，并且应用于元素的样式经常冲突（并相互抵消）。
- en: In small doses, the collisions are avoidable or manageable. In large doses,
    these collisions can cripple productivity. As a stop-gap, CSS supports the `!important`
    keyword. This often leads to ugly hacks, as everyone wants their styles to be
    the most important.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在小剂量下，碰撞是可以避免或管理的。在大剂量下，这些碰撞可能会削弱生产力。作为一种权宜之计，CSS 支持使用 `!important` 关键字。这通常会导致丑陋的解决方案，因为每个人都希望他们的样式是最重要的。
- en: In addition to this, common values need to be repeated. Until recently, CSS
    didn't even support calculated values. If we wanted an element to have an absolute
    width (for example) in relation to other elements, we had to use JavaScript.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还需要重复常见的值。直到最近，CSS 甚至不支持计算值。如果我们想使元素相对于其他元素具有绝对宽度（例如），我们必须使用 JavaScript。
- en: These are some of the problems Sass aims to solve. It's a CSS superset language
    (CSS + other features), so it's easy to learn, that is, once you know CSS.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 Sass 试图解决的问题之一。它是一种 CSS 扩展语言（CSS + 其他特性），因此易于学习，也就是说，一旦你了解了 CSS。
- en: 'Sass style sheets need to be compiled to CSS style sheets before they can be
    used in the browser. Installing a Sass compiler is easy; execute the following
    command to install it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Sass 样式表在使用浏览器之前需要编译成 CSS 样式表。安装 Sass 编译器很容易；执行以下命令来安装它：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After that''s done, we''re able to compile Sass style sheets (files ending
    in `.scss`) with the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们就可以使用以下命令编译 Sass 样式表（以 `.scss` 结尾的文件）：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Consider the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding code will be turned into CSS, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将被转换为CSS，如下所示：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you prefer to compile React components in the browser and want to do the
    same with Sass, then you can install the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢在浏览器中编译React组件，并且想用Sass做同样的事情，那么你可以安装以下内容：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, you need to add the following elements to the head of your page:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要将以下元素添加到页面的头部：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is a bit of JavaScript to look for the `style` elements with `type="text/sass"`.
    The contents of each of these style elements is passed through `sass.js` and saved
    back into the style elements. Their type is changed back to `text/css`, so the
    browser will recognize the styles as CSS.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段JavaScript代码，用于查找具有`type="text/sass"`的`style`元素。每个这些样式元素的内容都通过`sass.js`传递，并保存回样式元素。它们的类型被改回`text/css`，这样浏览器就会识别这些样式为CSS。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You should only use this method in development. It creates a lot of work for
    the browser, which can be avoided by pre-compiling Sass for a production environment
    (using tools such as Grunt, Gulp, and webpack).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该只在开发中使用这种方法。它会给浏览器带来很多工作，这可以通过在生产环境中预先编译Sass（使用如Grunt、Gulp和webpack等工具）来避免。
- en: Alternatives
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替代方案
- en: There are a few other ways in which we can style and animate React components,
    and they all deal with the issue in subtly different ways.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以用几种其他方式来样式化和动画化React组件，并且它们都以微妙不同的方式处理这个问题。
- en: CSS modules
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS模块
- en: '**CSS modules** allow you to define styles that only apply in a local context
    to individual elements. They look like regular CSS styles, but when they''re applied
    to components, they are altered so that the class names given to components are
    unique. You can read more about CSS modules at [http://glenmaddern.com/articles/css-modules](http://glenmaddern.com/articles/css-modules).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**CSS模块**允许你定义只适用于局部上下文中单个元素的样式。它们看起来像常规CSS样式，但当它们应用于组件时，会被修改，使得分配给组件的类名是唯一的。你可以在[http://glenmaddern.com/articles/css-modules](http://glenmaddern.com/articles/css-modules)上了解更多关于CSS模块的信息。'
- en: React style
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React样式
- en: '**React style** is a way of creating inline styles as slightly enhanced objects.
    It lacks support for a few common CSS selectors, but does a good job otherwise.
    You can read more about it at [https://github.com/js-next/react-style](https://github.com/js-next/react-style).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**React样式**是一种创建内联样式的方式，作为略微增强的对象。它不支持一些常见的CSS选择器，但在其他方面做得很好。你可以在[https://github.com/js-next/react-style](https://github.com/js-next/react-style)上了解更多关于它的信息。'
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to style React components great and small.
    We used inline styles, CSS style sheets, and even Sass style sheets. You also
    learned how to animate child components in and out of view using CSS transitions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何对React组件进行大小样式化。我们使用了内联样式、CSS样式表，甚至Sass样式表。你还学习了如何使用CSS过渡来动画化子组件的进入和退出视图。
- en: Finally, we looked briefly at a couple of alternative technologies, which do
    the same things we did in this chapter but in slightly different ways. You may
    prefer one of these methods over all the others, but what is important is to recognize
    that there are many methods we can use to style and animate components.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简要地查看了一些替代技术，这些技术以略有不同的方式完成了我们在本章中做的事情。你可能更喜欢这些方法中的任何一个，但重要的是要认识到我们可以使用许多方法来样式化和动画化组件。
- en: In the next chapter, we will put all these skills to use as we dive into material
    design. There's lots of styling and animation to come!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把这些技能应用到深入研究材料设计中。接下来会有很多样式化和动画化的内容！
