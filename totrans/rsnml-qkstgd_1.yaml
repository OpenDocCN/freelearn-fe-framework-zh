- en: Introduction to ReasonML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last decade has seen numerous paradigm shifts in the way we build user interfaces.
    Web applications have moved from server-side frameworks to client-side frameworks
    in order to provide better user experiences. Devices and browsers have become
    powerful enough to run robust client-side applications, and the JavaScript language
    itself has seen many improvements over the years. Progressive web apps provides
    a native-like user experience and WebAssembly allows for native-like performance on
    the web platform. An increasing number of applications are being built for the
    browser, resulting in larger client-side codebases needing to be maintained.
  prefs: []
  type: TYPE_NORMAL
- en: During this period, several frameworks, libraries, tools, and general best practices
    gained and then lost popularity, resulting in **JavaScript fatigue** for many
    developers. Companies are becoming increasingly cautious in committing to newer
    technologies due to their impact on hiring and retaining engineering talent, as
    well as productivity and maintainability. It can be an expensive mistake if you
    introduce the wrong technology (or the right technology at the wrong time) to
    your team.
  prefs: []
  type: TYPE_NORMAL
- en: For many companies and developers, React has proven to be a solid choice. In
    2013, Facebook made the library open source after having used it internally since
    2011\. They challenged us to rethink best practices ([https://www.youtube.com/watch?v=DgVS-zXgMTk&feature=youtu.be](https://www.youtube.com/watch?v=DgVS-zXgMTk&feature=youtu.be))
    and it has since taken over frontend development ([https://medium.freecodecamp.org/yes-react-is-taking-over-front-end-development-the-question-is-why-40837af8ab76](https://medium.freecodecamp.org/yes-react-is-taking-over-front-end-development-the-question-is-why-40837af8ab76)).
    Encapsulating markup, behavior, and style into reusable components has become
    a huge productivity and maintainability win. The abstraction of the DOM has allowed
    for components to be simple, declarative functions of its props that are easy
    to reason about, compose, and test.
  prefs: []
  type: TYPE_NORMAL
- en: Via React, Facebook has done an incredible job educating the frontend-developer
    community on traditional functional programming paradigms that make it easier
    to reason about and maintain code. And now, Facebook believes the time is right
    for ReasonML.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a two-year chart from [npmtrends.com](https://www.npmtrends.com/) that
    shows the number of weekly npm downloads for some of the top JavaScript libraries
    and frameworks. ReactJS looks to be a clear winner and has reached over 2,500,000
    downloads per week:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5957f88-9ae0-4aaa-ba2a-f1ec78579b88.png)'
  prefs: []
  type: TYPE_IMG
- en: npmtrends.com
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Discuss what ReasonML is and what problems it tries to solve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand some of the reasons why Facebook chose ReasonML as the future of
    ReactJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment with ReasonML in an online playground and examine its compiled (JavaScript)
    output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is ReasonML?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reason is a layer of syntax & tooling on top of OCaml, a language Facebook uses
    actively. Jordan [Walke] started the concept of Reason before React, in fact.
    We’re taking it and using it as an actual frontend language (among other uses)
    because we think that after three and half years, the React experiment has succeeded
    and people are now ready for Reason...
  prefs: []
  type: TYPE_NORMAL
- en: – Cheng Lou, January, 2017
  prefs: []
  type: TYPE_NORMAL
- en: ([https://www.reactiflux.com/transcripts/cheng-lou/](https://www.reactiflux.com/transcripts/cheng-lou/))
  prefs: []
  type: TYPE_NORMAL
- en: Let's expand on this quote. ReasonML is not a new language; it's a new syntax
    for the OCaml language that is meant to be familiar to JavaScript developers.
    Reason, as we'll call it from now on, has the exact same AST as OCaml, so Reason
    and OCaml only differ by syntax. The semantics are the same. By learning Reason,
    you're also learning OCaml. In fact, there's a command-line tool that converts
    between OCaml and Reason syntax, called `refmt`, which formats Reason/OCaml code
    similar to JavaScript's prettier—in fact, prettier was inspired by `refmt`.
  prefs: []
  type: TYPE_NORMAL
- en: OCaml is a general-purpose programming language with an emphasis on expressiveness
    and safety. It was initially released in 1996 and has an advanced type system
    that helps catch your mistakes without getting in the way. Like JavaScript, OCaml
    features garbage collection for automatic memory management and first-class functions
    that can be passed around as arguments to other functions.
  prefs: []
  type: TYPE_NORMAL
- en: Reason is also a toolchain that makes getting started easier for those coming
    from a JavaScript background. This toolchain allows us to take advantage of both
    the JavaScript and OCaml ecosystems. We will dive deeper here in [Chapter 2](4e4e3057-fca6-4c81-b6a7-05575aeeace3.xhtml),
    *Setting Up a Development Environment*. For now, we'll experiment directly in
    the online playground by visiting Reason's online playground at [https://reasonml.github.io/try](https://reasonml.github.io/try).
  prefs: []
  type: TYPE_NORMAL
- en: 'Try typing in this Hello World example into the online playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two things you''ll notice:'
  prefs: []
  type: TYPE_NORMAL
- en: The OCaml syntax is automatically generated in the lower-left section of the
    editor (not shown)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Reason/OCaml code is compiled to JavaScript directly in the browser:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You may be wondering how the Reason/OCaml code is being compiled from within
    the browser. BuckleScript, Reason's partner project, compiles the OCaml AST to
    JavaScript. Since Reason and OCaml both get converted into the same OCaml AST,
    BuckleScript supports both Reason and OCaml. Furthermore, since BuckleScript is
    itself written in OCaml, it can be compiled to JavaScript and run directly in
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inspecting the compiled JavaScript reveals just how readable it is. Looking
    closer, you''ll notice that the compiled output has also been optimized: within
    the `console.log` statement, the `"Hello World"` string has been inlined directly
    instead of using the `message` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: BuckleScript, using features of the OCaml type-system and compiler implementation
    is able to provide many optimizations during offline compilation, allowing the
    runtime code to be extremely fast.
  prefs: []
  type: TYPE_NORMAL
- en: – BuckleScript docs
  prefs: []
  type: TYPE_NORMAL
- en: ([https://bucklescript.github.io/bucklescript/Manual.html#_why_bucklescript](https://bucklescript.github.io/bucklescript/Manual.html#_why_bucklescript)[)](https://bucklescript.github.io/bucklescript/Manual.html#_why_bucklescript)
  prefs: []
  type: TYPE_NORMAL
- en: 'Notably, BuckleScript also supports string interpolation ([https://bucklescript.github.io/docs/en/common-data-types.html#interpolation](https://bucklescript.github.io/docs/en/common-data-types.html#interpolation)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Why Reason?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What makes Reason so compelling? What can Reason do that TypeScript or Flow
    cannot? Is it just about having a static type-checker? These are some of the questions
    I had when first getting started with Reason.
  prefs: []
  type: TYPE_NORMAL
- en: Support for immutability and purity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reason isn't just about having a static type system. Also important is the fact
    that Reason is immutable by default. Immutability is an important concept in functional
    programming. In practice, using immutable data structures (data structures that
    can't change) results in safer, easier-to-reason-about, and more maintainable
    code than their mutable counterparts. This will be a recurring theme throughout
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Purity is another important concept in functional programming. A function is
    said to be pure if its output is determined only by its input, without observable
    side-effects. In other words, a pure function doesn''t do anything outside of
    returning a value. The following is an example of a pure function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And, this is an example of an impure function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The side-effect in this case is writing to the browser's console. That's why,
    in our preceding `Hello World` example, BuckleScript included the `/* Not a pure
    module */` comment at the end of the compiled output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mutating a global variable is also a side-effect. Consider the following JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The global object was mutated, and now its `total` property is `42`. We now
    have to be aware of all areas where this `globalObject` is mutated whenever using
    it. Forgetting that this object is both global and mutable can lead to hard-to-debug
    problems. One idiomatic solution to this problem is to move `globalObject` into
    a module where it's no longer global. This way, only that module has access to
    it. However, we'd still need to be aware of all areas within this module that
    can update the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `globalObject` was immutable instead, there would be no way to mutate it.
    Therefore, we wouldn''t need an awareness of all the areas that can mutate `globalObject`,
    since there wouldn''t be any of these areas. We''ll see that, with Reason, it''s
    fairly simple and natural to build real applications in this way by creating updated
    copies of the original data. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The syntax feels quite natural. As we'll see later in this book, immutability—changing
    by returning updated copies instead of applying destructive changes in place—fits
    the React/Redux way of doing things quite well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original `foo` was not mutated; it was shadowed. Once shadowed, the old
    `foo` binding is unavailable. Bindings can be shadowed in local scopes as well
    as global scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to mutate `foo` results in a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can see that immutability and purity are related topics. Having a language
    that supports immutability allows you to program in a pure way without side-effects.
    However, what if there are times when purity would cause the code to become more
    complex and harder to reason about than using side-effects? You may be relieved
    to learn that Reason (interchangeable with OCaml throughout the rest of this book)
    is a pragmatic language that let's us cause side-effects when needed.
  prefs: []
  type: TYPE_NORMAL
- en: The key thing when using a language like [Reason] is not to avoid side-effects,
    because avoiding side-effects is equivalent to avoiding doing anything useful.
    It turns out, in reality, programs don't just *compute* things, they *do *things.
    They send messages and they write files and they do all sorts of stuff. The doing
    of things is automatically involving side-effects. The thing that a language which
    supports purity gives you, is it gives you the ability to, by and large, segment
    out the part that is side-effecting to clear and controlled areas of your code,
    and that makes it much easier to reason about.
  prefs: []
  type: TYPE_NORMAL
- en: – Yaron Minsky
  prefs: []
  type: TYPE_NORMAL
- en: ([https://www.youtube.com/watch?v=-J8YyfrSwTk&feature=youtu.be&t=47m29s](https://www.youtube.com/watch?v=-J8YyfrSwTk&feature=youtu.be&t=47m29s))
  prefs: []
  type: TYPE_NORMAL
- en: It's also important to know that immutability doesn't come at the cost of performance.
    Under the hood, there are optimizations in place that keeps Reason's immutable
    data structures fast.
  prefs: []
  type: TYPE_NORMAL
- en: Module system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reason has a sophisticated module system that allows for modular development
    and code organization. All modules are globally available in Reason, and module
    interfaces can be used to hide implementation details when needed. We will be
    exploring this concept in [Chapter 5](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml),
    *Effective ML*.
  prefs: []
  type: TYPE_NORMAL
- en: Type system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reason's type system is sound, which means that, once compiled, there won't
    be runtime type errors. There is no `null` in the language, nor are there any
    bugs related to `null`. In JavaScript, when something is of the `number` type,
    it can also be `null`. Reason uses a special type for things that can also be
    `null`, and forces the developer to handle those cases appropriately by refusing
    to compile otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've already written some, albeit basic, Reason code without even talking
    about types. Reason infers types automatically. As we'll learn throughout this
    book, the type system is a tool that provides guarantees without getting in our
    way, and when used properly, can allow us to offload things to the compiler that
    we used to keep in our heads.
  prefs: []
  type: TYPE_NORMAL
- en: Reason's support for immutable programming, sound type system, and sophisticated
    module system are big parts of why Reason is so great, and there's something to
    be said about using all of these features together in one language that was built
    with these features in mind. When Facebook initially released React, they asked
    us to give it five minutes ([https://signalvnoise.com/posts/3124-give-it-five-minutes](https://signalvnoise.com/posts/3124-give-it-five-minutes))
    and, hopefully, that same frame of mind will pay off here as well.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building React applications with Reason is a lovely experience and, what's more,
    since OCaml is able to compile to native, we will be able to use these same skills
    to build apps that compile to assembly, iOS/Android, and much more. In fact, Jared
    Forsyth has already created a game called Gravitron ([https://github.com/jaredly/gravitron](https://github.com/jaredly/gravitron))
    that compiles to iOS, Android, web, and macOS from one Reason codebase. That being
    said, the frontend JavaScript story is much more polished as of this writing.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reason may take some time to get comfortable with, but you can think of this
    time as an investment in the maintenance and confidence of your future product.
    Although languages with gradual type systems, such as TypeScript, may be easier
    to get started with, they don't provide the sorts of guarantees that a sound type
    system such as Reason's can provide. Reason's true benefits cannot be completely
    conveyed within simple examples, and only really shine when they save you time
    and energy in reasoning about, refactoring, and maintaining your code. Put it
    this way; if someone told me they were 99% sure a spider wasn't in my bed, I would
    still have to check the entire bed because I don't like bugs!
  prefs: []
  type: TYPE_NORMAL
- en: As long as you're 100% in Reason and your code compiles, the type system guarantees
    there will be no runtime type errors. It's true that when you are interoperating
    with non-Reason code (JavaScript, for example), you introduce the possibility
    of runtime type errors. Reason's sound type system allows you to trust that the
    Reason parts of the application won't cause runtime type errors, which therefore
    allows you to focus extra attention on ensuring that these areas of the application
    are safe. In my experience, programming in a dynamic language can feel noticeably
    dangerous. Reason on the other hand feels like it always has your back.
  prefs: []
  type: TYPE_NORMAL
- en: Interoperability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That being said, sometimes—and especially when first learning about type systems—you
    may be unsure as to how to get your code to compile. Reason, through BuckleScript,
    allows you to drop down to raw JavaScript when you need to, either via bindings
    or directly inside your Reason (`.re`) files. This gives you the freedom to figure
    things out as you go along in JavaScript, and then once you're ready, convert
    that section of the code to type-safe Reason.
  prefs: []
  type: TYPE_NORMAL
- en: BuckleScript also lets us bind to idiomatic JavaScript in a very reasonable
    way. As you'll learn in [Chapter 4](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml),
    *BuckleScript, Belt, and Interoperability*, BuckleScript is an incredibly powerful
    part of Reason.
  prefs: []
  type: TYPE_NORMAL
- en: ES2030
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing in Reason feels like writing in a future version of JavaScript. Some
    Reason language features, including the pipe operator ([https://github.com/tc39/proposal-pipeline-operator](https://github.com/tc39/proposal-pipeline-operator)) and
    pattern matching ([https://github.com/tc39/proposal-pattern-matching](https://github.com/tc39/proposal-pattern-matching)),
    are currently being proposed to the TC39 Committee to add into the JavaScript
    language. With Reason, we can take advantage of these features, and much more,
    today.
  prefs: []
  type: TYPE_NORMAL
- en: Community
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Reason community is, hands down, one of the most helpful, supportive, and
    inclusive communities I've ever been a part of. If you have a question, or are
    stuck on something, the Reason Discord channel is the place to go for realtime
    support.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reason Discord channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/reasonml](https://discord.gg/reasonml)'
  prefs: []
  type: TYPE_NORMAL
- en: Often, when starting with a new technology, talking to someone with experience
    for five minutes can save you hours of frustration. I've personally asked questions
    at all hours of the day (and night) and am so incredibly grateful for and amazed
    by how quickly someone helps me out. Take a moment to join the Discord channel,
    introduce yourself, ask questions, and share your feedback on how to make Reason
    better!
  prefs: []
  type: TYPE_NORMAL
- en: The Future of ReactJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In practice, few real-world applications use just ReactJS. Additional technologies,
    such as Babel, ESLint, Redux, Flow/TypeScript, and Immutable.js, are typically
    brought in to help increase the maintainability of a codebase. Reason replaces
    the need for these additional technologies with its core language features.
  prefs: []
  type: TYPE_NORMAL
- en: ReasonReact is a Reason library that binds to ReactJS and provides a simpler,
    safer way to build ReactJS components. Just like ReactJS is just JavaScript, ReasonReact
    is just Reason. Additionally, it's easy to incrementally adopt because it was
    made by the same person who created ReactJS.
  prefs: []
  type: TYPE_NORMAL
- en: ReasonReact comes with a built in router, Redux-like data management, and JSX.
    You'll feel quite at home coming from a ReactJS background.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to mention that Reason/ReasonReact is already being used by several
    companies in production, including within one of the largest codebases in the
    world. Facebook's messenger.com codebase is already over 50% converted to ReasonReact.
  prefs: []
  type: TYPE_NORMAL
- en: Every ReasonReact feature has been extensively tested on the messenger.com codebase.
  prefs: []
  type: TYPE_NORMAL
- en: – Cheng Lou
  prefs: []
  type: TYPE_NORMAL
- en: ([https://reason.town/reason-philosophy](https://reason.town/reason-philosophy))
  prefs: []
  type: TYPE_NORMAL
- en: As a result, new releases of Reason and ReasonReact come with code mods that
    automate much, if not all, of the upgrade process for your code base. New features
    are thoroughly tested internally at Facebook before they're released to the public,
    and this results in a pleasant developer experience.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Reason
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ask yourself whether the following is a statement or an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In JavaScript, it's a statement, but in Reason, it's an expression. Another
    example of an expression is `4 + 3`, which can also be represented as `4 + (2
    + 1)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many things in Reason are expressions, including control structures such as `if-else`,
    `switch`, `for` and `while`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have ternaries in Reason. Here is another way to express the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Even anonymous block scopes are expressions that evaluate to the last line''s
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A `tuple` is an immutable data structure that can hold different types of values
    and can be of any length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use what we know so far and dive right in with the `FizzBuzz` example
    from Reason''s online playground. `FizzBuzz` was a popular interview question
    to determine whether a candidate is able to code. The challenge is to write a
    problem that prints the numbers from `1` to `100`, but instead prints `Fizz` for
    multiples of three, `Buzz` for multiples of five, and `FizzBuzz` for multiples
    of both three and five:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, `fizzbuzz` is a function that accepts an integer and returns a string.
    An imperative `for` loop logs its output to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Reason, a function''s last expression becomes the function''s return value.
    The `switch` expression is the only `fizzbuzz` expression, so whatever that evaluates
    to becomes the output of `fizzbuzz`. Like JavaScript, the `switch` evaluates an
    expression and the first matched case gets its branch executed. In this case,
    the `switch` evaluates the tuple expression: `(i mod 3, i mod 5)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Given `i=1`, `(i mod 3, i mod 5)` becomes `(1, 1)`. Since `(1, 1)` isn't matched
    by `(0, 0)`, `(0, _)`, or `(_, 0)`, in that order, the last case of `_` (that
    is, *anything*) is matched, and `"1"` is returned. Similarly, `fizzbuzz` returns
    `"2"` when given `i=2`. When given `i=3`, `"Fizz"` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we could have implemented `fizzbuzz` using `if-else`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: However, the switch version is much more readable. And as we'll see later in
    this chapter, the switch expression, also called **pattern matching**, is much
    more powerful than we've seen so far.
  prefs: []
  type: TYPE_NORMAL
- en: Data structures and types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A type is a set of values. More concretely, `42` has the `int` type because
    it''s a value that''s contained in the set of integers. A float is a number that
    includes a decimal point, that is, `42.` and `42.0`. In Reason, integers and floating
    point numbers have separate operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The same is true for `-.`, `-`, `*.`, `*`, `/.`, and `/`.
  prefs: []
  type: TYPE_NORMAL
- en: Reason uses double quotes for the `string` type and single quotes for the `char` type.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our own types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also create our types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how we create a person of the `person` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also annotate any expression with its type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use pattern matching on our person:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use a record instead of a tuple for our person. Records are similar
    JavaScript objects except they''re much lighter and are immutable by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use pattern matching on records too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Like JavaScript, `{name: "Zoe", age: age}` can be represented as `{name: "Zoe",
    age}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a new record from an existing one using the spread ( `...` )
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Records require type definitions before they can be used. Otherwise, the compiler
    will error with something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'A record must be the same shape as its type. Therefore, we cannot add arbitrary
    fields to our `person` record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Tuples and records are examples of product types. In our recent examples, our `person` type
    required both an `int` and an `age`. Almost all of JavaScript's data structures
    are product types; one exception is the `boolean` type, which is either `true`
    or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reason''s variant type, which is an example of a sum type, allows us to express
    this or that. We can define the `boolean` type as a variant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can have as many constructors as we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`Yes`, `No`, and `Maybe` are called constructors because we can use them to
    construct values. They''re also commonly called **tags**. Because these tags can
    construct values, variants are both a type and a data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And, of course, we can pattern match on `decision`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to forget to handle a case, the compiler would warn us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As we'll learn in [Chapter 2](4e4e3057-fca6-4c81-b6a7-05575aeeace3.xhtml), *Setting
    Up a Development Environment*, the compiler can be configured to turn this warning
    into an error. Let's see one way to help make our code more resilient to future
    refactors by taking advantage of these exhaustiveness checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following example where we are tasked with calculating the price of
    a concert venue''s seat given its section. Floor seats are $55, while all other
    seats are $45:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If, later, the concert venue allows the sale of seats in the orchestra pit
    area for $65, we would first add another constructor to `seat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: However, due to the usage of the catch-all `_` case, our compiler doesn't complain
    after this change. It would be much better if it did since that would help us
    during our refactoring process. Stepping through compiler messages after changing
    type definitions is how Reason (and the ML family of languages in general) makes
    refactoring and extending code a safer, more pleasant process. This is, of course,
    not limited to variant types. Adding another field to our `person` type would
    also result in the same process of stepping through compiler messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we should reserve using `_` for an infinite number of cases (such
    as our `fizzbuzz` example). We can refactor `getSeatPrice` to use explicit cases
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we welcome the compiler nicely informing us of our unhandled case and
    then add it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now imagine that each seat, even ones in the same section (that is,
    ones that have the same tag) can have different prices. Well, Reason variants
    can also hold data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can access this data with pattern matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Variants are not just limited to one piece of data. Let''s imagine that we
    want our `seat` type to store its price as well as whether it''s still available.
    If it''s not available, it should store the ticket holder''s information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Before explaining what the `option` type is, let''s have a look at its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `''a` in the preceding code is called a **type variable**. Type variables
    always start with a `''`. This type definition uses a type variable so that it
    could work for any type. If it didn''t, we would need to create a `personOption` type
    that would only work for the `person` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: What if we wanted an option for another type as well? Instead of repeating this
    type declaration over and over, we declare a polymorphic type. A polymorphic type
    is a type that includes a type variable. The `'a` (pronounced alpha) type variable
    will be swapped with `person` in our example. Since this type definition is so
    common, it's included in Reason's standard library, so there's no need to declare
    the `option` type in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jumping back to our `seat` example, we store its price as an `int` and its
    holder as an `option(person)`. If there''s no holder, it''s still available. We
    could have an `isAvailable` function that would take a `seat` and return a `bool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a step back and look at the implementations of `getSeatPrice` and
    `isAvailable`. It''s a shame that both functions need to be aware of the different
    constructors when they don''t have anything to do with the price or availability
    of the seat. Taking another look at our `seat` type, we see that `(int, option(person))`
    is repeated for each constructor. Also, there isn''t really a nice way to avoid
    using the `_` case in `isAvailable`. These are all signs that another type definition
    might serve our needs better. Let''s remove the arguments from the `seat` type
    and rename it `section`. We''ll declare a new record type, called `seat`, with
    fields for `section`, `price`, and `person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now, our `getSeatPrice` and `isAvailable` functions have a higher signal-to-noise
    ratio, and don't need to change when the `section` type changes.
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, `_` is used to prefix a variable to prevent the compiler from
    warning us about the variable being unused.
  prefs: []
  type: TYPE_NORMAL
- en: Making Invalid States Impossible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that we''d like to add a field to `seat` to hold the date a seat
    was purchased:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ve introduced the possibility of an invalid state in our code. Here''s
    an example of such a state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In theory, the `dateSold` field should only hold a date when the `person` field
    holds a ticket holder. The ticket has a sold date, but no owner. We could look
    through our imaginary implementation to verify that this state would never happen,
    but there would still be the possibility that we missed something, or that some
    minor refactor introduced a bug that was overlooked.
  prefs: []
  type: TYPE_NORMAL
- en: Since we now have the power of Reason's type system at our disposal, let's offload
    this work to the compiler. We are going to use the type system to enforce invariants
    in our code. If our code breaks these rules, it won't compile.
  prefs: []
  type: TYPE_NORMAL
- en: 'One giveaway that this invalid state could exist is the use of `option` types
    within our record field. In these cases, there may be a way to use a variant instead
    such that each constructor only holds the relevant data. In our case, our sold-date
    and ticket-holder data should only exist when the seat has been sold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Check out our new `status` type. The `Available` constructor holds no data,
    and `Sold` holds the sold date as well as the ticket holder.
  prefs: []
  type: TYPE_NORMAL
- en: With this `seat` type, there's no way to represent the previous invalid state
    of having a sold date without a ticket holder. It's also a good sign that our
    `seat` type no longer includes `option` types.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got a feel for what Reason is and what problems it tries
    to solve. We saw how Reason's type inference removes much of the burden associated
    with statically-typed languages. We learned that the type system is a tool that
    can be used to provide codebases with powerful guarantees that provide an excellent
    developer experience. While Reason may take some time to get used to, it's well
    worth the investment for medium-sized to larger codebases.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn about Reason's toolchain when we set up our
    development environment. In [Chapter 3](21586d11-fa31-446f-99f1-dae3beecdb9b.xhtml),
    *Creating ReasonReact Components*, we'll start to build an application that we'll
    use throughout the rest of this book. By the end of this book, you'll be comfortable
    building real-world React applications in Reason.
  prefs: []
  type: TYPE_NORMAL
