<html><head></head><body>
  <div id="_idContainer228" class="Basic-Text-Frame">
    <h1 class="chapterNumber">26</h1>
    <h1 id="_idParaDest-298" class="chapterTitle">Using Animations</h1>
    <p class="normal">Animations can be used to improve the user experience in mobile applications. They usually help users to quickly recognize that something has changed, or help them focus on what is important. They improve the user experience and user satisfaction. Also, animations are simply fun to look at. For example, the heartbeat reaction in the Instagram app when you like a post or the Snapchat ghost animation when refreshing a page.</p>
    <p class="normal">There are a couple of different approaches to processing and controlling animations in React Native. Firstly, we will take a look at animation tools that we can use, discover their pros and cons, and compare them. Then, we will implement several examples to get to know APIs better.</p>
    <p class="normal">We’ll cover the following topics in this chapter: </p>
    <ul>
      <li class="bulletList">Using React Native Reanimated</li>
      <li class="bulletList">Animating layout components </li>
      <li class="bulletList">Animating component styles</li>
    </ul>
    <h1 id="_idParaDest-299" class="heading-1">Technical requirements</h1>
    <p class="normal">You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter26"><span class="url">https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter26</span></a>.</p>
    <h1 id="_idParaDest-300" class="heading-1">Using React Native Reanimated</h1>
    <p class="normal">In the React Native<a id="_idIndexMarker880"/> world, we have a lot of libraries and approaches to animate our components, including the <a id="_idIndexMarker881"/>built-in <strong class="keyWord">Animated API</strong>. But in this chapter, I would like to opt for a library called <strong class="keyWord">React Native Reanimated</strong> and compare it with the Animated API to learn why it is the best choice.</p>
    <h1 id="_idParaDest-301" class="heading-1">The Animated API</h1>
    <p class="normal">The <strong class="keyWord">Animated API</strong> is the <a id="_idIndexMarker882"/>most common tool used to animate components in React Native. It has a set of methods that help you to create an animation object, control its state, and process it. The main benefit is that it can be used with any component, and not just animated components such as View or Text. </p>
    <p class="normal">But, at the same time, this API has been implemented in the old architecture of React Native. Asynchronous communications between JavaScript and UI Native threads are used with the Animated API, delaying updates by at least one frame and lasting approximately 16 ms. Sometimes, the delay may last even longer if the JavaScript thread is running React’s diff algorithm and comparing or processing network requests simultaneously. The problem of dropped or delayed frames can be solved with the React Native Reanimated library, which is based on the new architecture and processes all business logic from the JavaScript thread in the UI thread.</p>
    <h2 id="_idParaDest-302" class="heading-2">React Native Reanimated</h2>
    <p class="normal"><strong class="keyWord">React Native Reanimated</strong> can<a id="_idIndexMarker883"/> be utilized to provide a more exhaustive abstraction of the Animated API to use with React Native. It provides an imperative API with multistage animations and custom transitions, while at the same time providing a declarative API that can be used to describe simple animations and transitions in a similar way to how CSS transitions work. It’s built on top of React Native Animated and reimplements it on the Native thread. This allows you to use the familiar JavaScript language while taking advantage of the most high performance and simple API.</p>
    <p class="normal">Furthermore, React Native Reanimated defines worklets, which are JavaScript functions that can be synchronously executed within the UI thread. This allows instant animations without having to wait for a new frame. Let’s take a look at what a simple worklet looks like: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span> <span class="hljs-title">simpleWorklet</span>() {
  <span class="hljs-string">"worklet"</span>;
  <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-string">"Hello from UI thread"</span>);
}
</code></pre>
    <p class="normal">The only thing that is needed for the <code class="inlineCode">simpleWorklet</code> function to get called inside the UI thread is to add the <code class="inlineCode">worklet</code> directive at the top of the <code class="inlineCode">function</code> block. </p>
    <p class="normal">React Native Reanimated provides a variety of hooks and methods that help us handle animations:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">useSharedValue</code>: This hook returns a <code class="inlineCode">SharedValue</code> instance, which is the main stateful data object that lives in the UI thread context and has a similar concept to <code class="inlineCode">Animated.Value</code> in the core Animated API. A Reanimated animation is triggered when <code class="inlineCode">SharedValue</code> is changed. The key benefit is that updates to shared values can be synchronized across the React Native and UI threads without triggering a re-render. This enables complex animations to run smoothly at 60 FPS without blocking the JS thread.</li>
      <li class="bulletList"><code class="inlineCode">useDerivedValue</code>: This hook creates a new shared value that automatically updates whenever the shared values used in its calculation change. It allows you to create shared values that depend on other shared values, while keeping them all reactive. <code class="inlineCode">useDerivedValue</code> is used to create a <strong class="keyWord">derived</strong> state in a worklet that <a id="_idIndexMarker884"/>runs on the UI thread based on updates to the source shared values. This derived state can then drive animations or other side effects without triggering a re-render on the JS thread.</li>
      <li class="bulletList"><code class="inlineCode">useAnimatedStyle</code>: The hook allows you to create a style object with the ability to animate its properties based on shared values. It maps shared value updates to the corresponding view properties. <code class="inlineCode">useAnimatedStyle</code> is the main way to connect shared values to views and enable smooth animations running on the UI thread.</li>
      <li class="bulletList"><code class="inlineCode">withTiming</code>, <code class="inlineCode">withSpring</code>, <code class="inlineCode">withDecay</code>: These are animation utility methods that update a shared value in a smooth, animated way using various curves and physics. They allow you to define animations declaratively by specifying the target value and animation configuration.</li>
    </ul>
    <p class="normal">We have learned what React Native Reanimated is and how it is different from the Animated API. Next, let’s try to install it and apply it to our app.</p>
    <h2 id="_idParaDest-303" class="heading-2">Installing the React Native Reanimated library</h2>
    <p class="normal">To install the React Native <a id="_idIndexMarker885"/>Reanimated library, run this command inside your Expo project:</p>
    <pre class="programlisting con"><code class="hljs-con">expo install react-native-reanimated
</code></pre>
    <p class="normal">After the installation is complete, we need to add the <strong class="keyWord">Babel</strong> plugin to <code class="inlineCode">babel.config.js</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-variable">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">api</span>) {
  api.<span class="hljs-title">cache</span>(<span class="hljs-literal">true</span>);
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">presets</span>: [<span class="hljs-string">'babel-preset-expo'</span>],
    <span class="hljs-attr">plugins</span>: [<span class="hljs-string">'react-native-reanimated/plugin'</span>],
  };
};
</code></pre>
    <p class="normal">The main purpose of that plugin is to convert our JavaScript worklet functions into functions that will work in the UI thread.</p>
    <p class="normal">After you add the Babel plugin, restart your development server and clear the bundler cache:</p>
    <pre class="programlisting con"><code class="hljs-con">expo start --clear
</code></pre>
    <p class="normal">This section has introduced us to the React Native Reanimated library. We have found out why it is better than the built-in Animated API. In the next sections, we will use it in real examples.</p>
    <h1 id="_idParaDest-304" class="heading-1">Animating layout components </h1>
    <p class="normal">A common use<a id="_idIndexMarker886"/> case is animating the entering and exiting layouts of your components. This means that when your component renders for the first time and when you unmount your component, it appears animated. React Native Reanimated is an API that lets you animate layouts and add animations such as <code class="inlineCode">FadeIn</code>, <code class="inlineCode">BounceIn</code>, and <code class="inlineCode">ZoomIn</code>.</p>
    <p class="normal">React Native Reanimated also provides a special <code class="inlineCode">Animated</code> component that is the same as the <code class="inlineCode">Animated</code> component in the Animated API, but with additional props:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">entering</code>: Accepts a predefined animation when the component mounts and renders </li>
      <li class="bulletList"><code class="inlineCode">exiting</code>: Accepts the same animation object, but it will be called when the component unmounts</li>
    </ul>
    <p class="normal">Let’s create a simple to-do list with a button for creating tasks and a feature that allows us to delete tasks when we click on them.</p>
    <div class="note">
      <p class="normal">It’s impossible to see animations in screenshots, so I suggest you open the code and try to implement the animations to see the results.</p>
    </div>
    <p class="normal">Firstly, let’s take a look at the main screen of our to-do list app and how the items are rendering at<a id="_idIndexMarker887"/> the moment:</p>
    <figure class="mediaobject"><img src="../Images/B19636_26_01.png" alt="Picture 1"/></figure>
    <p class="packt_figref">Figure 26.1: To-do list</p>
    <p class="normal">This is a simple example with a list of task items and one button for adding new tasks. When we quickly press the <strong class="screenText">Add</strong> button several times, the list items come from the left side of the screen <a id="_idIndexMarker888"/>with an animation:</p>
    <figure class="mediaobject"><img src="../Images/B19636_26_02.png" alt="Picture 2"/></figure>
    <p class="packt_figref">Figure 26.2: To-do list with animated rendering</p>
    <p class="normal">The magic is implemented in the <code class="inlineCode">TodoItem</code> component. Let’s take a look at it:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title">TodoItem</span> = (<span class="hljs-params">{ id, title, onPress }</span>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">Animated.View</span><span class="hljs-tag"> </span><span class="hljs-attr">entering</span><span class="hljs-tag">=</span><span class="hljs-string">{SlideInLeft}</span>
<span class="hljs-tag">      </span><span class="hljs-attr">exiting</span><span class="hljs-tag">=</span><span class="hljs-string">{SlideOutRight}</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">TouchableOpacity</span><span class="hljs-tag"> </span><span class="hljs-attr">onPress</span><span class="hljs-tag">=</span><span class="hljs-string">{()</span><span class="hljs-tag"> =&gt;</span> onPress(id)}
        style={styles.todoItem}&gt;
        <span class="hljs-tag">&lt;</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>{title}<span class="hljs-tag">&lt;/</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">TouchableOpacity</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">Animated.View</span><span class="hljs-tag">&gt;</span>
  );
};
</code></pre>
    <p class="normal">As you can see, there is no complicated logic, and there isn’t too much code. We just take the <code class="inlineCode">Animated</code> component <a id="_idIndexMarker889"/>as the root of animation and pass predefined animations from the React Native Reanimated library to the <code class="inlineCode">entering</code> and <code class="inlineCode">exiting</code> props.</p>
    <p class="normal">To see how the items disappear from the screen, we need to press the to-do items so the exiting animation will run. I’ve pressed a few items and tried to catch the result in the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B19636_26_03.png" alt="Picture 3"/></figure>
    <p class="packt_figref">Figure 26.3: Deleting to-do items from the screen</p>
    <p class="normal">Let’s examine <a id="_idIndexMarker890"/>the <code class="inlineCode">App</code> component to see the entire picture:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">App</span>() {
  <span class="hljs-keyword">const</span> [todoList, setTodoList] = <span class="hljs-title">useState</span>([]);
  <span class="hljs-keyword">const</span> <span class="hljs-title">addTask</span> = () =&gt; {
    <span class="hljs-title">setTodoList</span>([
      ...todoList,
      { <span class="hljs-attr">id</span>: <span class="hljs-title">String</span>(<span class="hljs-keyword">new</span> <span class="hljs-title">Date</span>().<span class="hljs-title">getTime</span>()), <span class="hljs-attr">title</span>: <span class="hljs-string">"New task"</span>
        },
    ]);
  };
  <span class="hljs-keyword">const</span> <span class="hljs-title">deleteTask</span> = (<span class="hljs-params">id</span>) =&gt; {
    <span class="hljs-title">setTodoList</span>(todoList.<span class="hljs-title">filter</span>(<span class="hljs-function">(</span><span class="hljs-params">todo</span><span class="hljs-function">) =&gt;</span> todo.<span class="hljs-property">id</span> !== id));
  };
</code></pre>
    <p class="normal">We have created a <code class="inlineCode">todoList</code> state using the <code class="inlineCode">useState</code> hook and handler functions for adding and deleting tasks. Next, let’s take a look at how the animation will be applied to the layout:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">View</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{styles.container}</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">View</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{{</span><span class="hljs-tag"> </span><span class="hljs-attr">flex:</span><span class="hljs-tag"> </span><span class="hljs-attr">1</span><span class="hljs-tag"> }}&gt;</span>
        {todoList.map(({ id, title }) =&gt; (
          <span class="hljs-tag">&lt;</span><span class="hljs-name">TodoItem</span><span class="hljs-tag"> </span><span class="hljs-attr">key</span><span class="hljs-tag">=</span><span class="hljs-string">{id}</span><span class="hljs-tag"> </span><span class="hljs-attr">id</span><span class="hljs-tag">=</span><span class="hljs-string">{id}</span><span class="hljs-tag"> </span><span class="hljs-attr">title</span><span class="hljs-tag">=</span><span class="hljs-string">{title}</span>
<span class="hljs-tag">            </span><span class="hljs-attr">onPress</span><span class="hljs-tag">=</span><span class="hljs-string">{deleteTask}</span><span class="hljs-tag"> /&gt;</span>
        ))}
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">View</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">Button</span><span class="hljs-tag"> </span><span class="hljs-attr">onPress</span><span class="hljs-tag">=</span><span class="hljs-string">{addTask}</span><span class="hljs-tag"> </span><span class="hljs-attr">title</span><span class="hljs-tag">=</span><span class="hljs-string">"Add"</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">View</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">In this example, we learned a simple way to apply animations to make our app look better. However, the React Native Reanimated library is a lot more powerful than we imagined. The next<a id="_idIndexMarker891"/> example illustrates how we can animate and create our own animations by applying them directly to the styles of our components.</p>
    <h1 id="_idParaDest-305" class="heading-1">Animating component styles</h1>
    <p class="normal">In a more complex <a id="_idIndexMarker892"/>example, I suggest creating a button with beautiful tappable feedback. This button will be built using the <code class="inlineCode">Pressable</code> component that we learned about in <em class="chapterRef">Chapter 23</em>, <em class="italic">Responding to User Gestures</em>. This component accepts the <code class="inlineCode">onPressIn</code>, <code class="inlineCode">onLongPress</code>, and <code class="inlineCode">onPressOut</code> events. As a result of these events, we will be able to see how our touches will be reflected on the button.</p>
    <p class="normal">Let’s start by defining <code class="inlineCode">SharedValue</code> and <code class="inlineCode">AnimatedStyle</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">const</span> radius = <span class="hljs-title">useSharedValue</span>(<span class="hljs-number">30</span>);
  <span class="hljs-keyword">const</span> opacity = <span class="hljs-title">useSharedValue</span>(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">const</span> scale = <span class="hljs-title">useSharedValue</span>(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">const</span> color = <span class="hljs-title">useSharedValue</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> backgroundColor = <span class="hljs-title">useDerivedValue</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title">interpolateColor</span>(color.<span class="hljs-property">value</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-string">"orange"</span>,      <span class="hljs-string">"red"</span>]);
     });
  <span class="hljs-keyword">const</span> animatedStyles = <span class="hljs-title">useAnimatedStyle</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">opacity</span>: opacity.<span class="hljs-property">value</span>,
      <span class="hljs-attr">borderRadius</span>: radius.<span class="hljs-property">value</span>,
      <span class="hljs-attr">transform</span>: [{ <span class="hljs-attr">scale</span>: scale.<span class="hljs-property">value</span> }],
      <span class="hljs-attr">backgroundColor</span>: backgroundColor.<span class="hljs-property">value</span>,
    };
  }, []);
</code></pre>
    <p class="normal">In order to animate style properties, we have created a <code class="inlineCode">SharedValue</code> object using the <code class="inlineCode">useSharedValue</code> hook. It takes default values as an argument. Next, we created the style object with the <code class="inlineCode">useAnimatedStyle</code> hook. The hook accepts the callback that should return a style object. The <code class="inlineCode">useAnimatedStyle</code> hook is similar to the <code class="inlineCode">useMemo</code> hook, but all calculations are performed in the UI thread and all <code class="inlineCode">SharedValue</code> changes will invoke the hook to recalculate the <a id="_idIndexMarker893"/>style object. The background color of the button was created using <code class="inlineCode">useDerivedValue</code> by interpolating between orange and red to provide a smooth transition.</p>
    <p class="normal">Next, let’s create handler functions that will update the style properties in relation to the pressing state of the button:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">const</span> <span class="hljs-title">onPressIn</span> = () =&gt; {
    radius.<span class="hljs-property">value</span> = <span class="hljs-title">withSpring</span>(<span class="hljs-number">20</span>);
    opacity.<span class="hljs-property">value</span> = <span class="hljs-title">withSpring</span>(<span class="hljs-number">0.7</span>);
    scale.<span class="hljs-property">value</span> = <span class="hljs-title">withSpring</span>(<span class="hljs-number">0.9</span>);
  };
  <span class="hljs-keyword">const</span> <span class="hljs-title">onLongPress</span> = () =&gt; {
    scale.<span class="hljs-property">value</span> = <span class="hljs-title">withSpring</span>(<span class="hljs-number">0.8</span>);
    color.<span class="hljs-property">value</span> = <span class="hljs-title">withSpring</span>(<span class="hljs-number">1</span>);
  };
  <span class="hljs-keyword">const</span> <span class="hljs-title">onPressOut</span> = () =&gt; {
    radius.<span class="hljs-property">value</span> = <span class="hljs-title">withSpring</span>(<span class="hljs-number">30</span>);
    opacity.<span class="hljs-property">value</span> = <span class="hljs-title">withSpring</span>(<span class="hljs-number">1</span>);
    scale.<span class="hljs-property">value</span> = <span class="hljs-title">withSpring</span>(<span class="hljs-number">1</span>, { <span class="hljs-attr">damping</span>: <span class="hljs-number">50</span> });
    color.<span class="hljs-property">value</span> = <span class="hljs-title">withSpring</span>(<span class="hljs-number">0</span>);
  };
</code></pre>
    <p class="normal">The first handler, <code class="inlineCode">onPressIn</code>, updates <code class="inlineCode">borderRadius</code>, <code class="inlineCode">opacity</code>, and <code class="inlineCode">scale</code> from their default values. We also update these values using <code class="inlineCode">withSpring</code>, which makes updating styles smoother. Like the first handler, other ones will also update the style of the button but in different ways. <code class="inlineCode">onLongPress</code> turns the button red and makes it smaller. <code class="inlineCode">onPressOut</code> resets all values to their default values.</p>
    <p class="normal">We’ve implemented <a id="_idIndexMarker894"/>all necessary logic and can now apply it to the layout:</p>
    <pre class="programlisting code"><code class="hljs-code">    &lt;<span class="hljs-title">View</span> style={styles.<span class="hljs-property">container</span>}&gt;
      <span class="hljs-tag">&lt;</span><span class="hljs-name">Animated.View</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{[styles.buttonContainer,</span>
<span class="hljs-tag">        </span><span class="hljs-attr">animatedStyles</span><span class="hljs-tag">]}&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">Pressable</span>
<span class="hljs-tag">          </span><span class="hljs-attr">onPressIn</span><span class="hljs-tag">=</span><span class="hljs-string">{onPressIn}</span>
<span class="hljs-tag">          </span><span class="hljs-attr">onPressOut</span><span class="hljs-tag">=</span><span class="hljs-string">{onPressOut}</span>
<span class="hljs-tag">          </span><span class="hljs-attr">onLongPress</span><span class="hljs-tag">=</span><span class="hljs-string">{onLongPress}</span>
<span class="hljs-tag">          </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{styles.button}</span>
<span class="hljs-tag">        &gt;</span>
          <span class="hljs-tag">&lt;</span><span class="hljs-name">Text</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{styles.buttonText}</span><span class="hljs-tag">&gt;</span>Press me<span class="hljs-tag">&lt;/</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;/</span><span class="hljs-name">Pressable</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">Animated.View</span><span class="hljs-tag">&gt;</span>
    &lt;/<span class="hljs-title">View</span>&gt;
</code></pre>
    <p class="normal">Finally, let’s take a look at the result:</p>
    <figure class="mediaobject"><img src="../Images/B19636_26_04.png" alt="Picture 4"/></figure>
    <p class="packt_figref">Figure 26.4: Button with default, pressed, and long-pressed styles</p>
    <p class="normal">In <em class="italic">Figure 26.4</em>, you can see<a id="_idIndexMarker895"/> the three states of the button: default, pressed, and long-pressed.</p>
    <h1 id="_idParaDest-306" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we’ve learned how to use the React Native Reanimated library to add animations to the layout and components. We’ve gone through the basic principles of the library and found out how it works under the hood and how it executes code inside the UI thread without using Bridge to connect JavaScript and Native layers of the app.</p>
    <p class="normal">We also went through two examples using the React Native Reanimated library. In the first example, we learned how to apply a layout animation using predefined declarative animations to get our component to appear and disappear beautifully. In the second example, we animated the button’s styles with the <code class="inlineCode">useSharedValue</code> and <code class="inlineCode">useAnimatedStyle</code> hooks.</p>
    <p class="normal">Skills to animate components and layout will help you make your app more beautiful and responsive. In the next chapter, we’ll learn about controlling images in our apps.</p>
  </div>
</body></html>