- en: Architectural Overview and Building a Simple App in Angular
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular的架构概述和构建简单应用
- en: It doesn't matter if you are new to AngularJS or new to Angular. If you want
    to quickly develop great web apps with rich UIs and with the features of Angular
    components, templates, and services, you need to master Angular, and this book
    is for you.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是新手还是对AngularJS或Angular都不熟悉。如果您想快速开发具有丰富UI和Angular组件、模板和服务功能的优秀Web应用程序，您需要掌握Angular，这本书就是为您准备的。
- en: Angular is a JavaScript framework that enables developers to build web and mobile
    applications. Applications built with Angular can target any device, such as mobiles,
    tablets, and desktops. Angular is not an incremental version of AngularJS. It
    was completely rewritten with improved Dependency Injection, dynamic loading,
    and simpler routing, and recommends that developers use TypeScript and leverage
    OOPS, static typing, generics, and lambdas.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是一个JavaScript框架，使开发人员能够构建Web和移动应用程序。使用Angular构建的应用程序可以针对任何设备，如手机、平板电脑和台式电脑。Angular不是AngularJS的增量版本。它完全重写了改进的依赖注入、动态加载和更简单的路由，并建议开发人员使用TypeScript并利用面向对象编程、静态类型、泛型和lambda。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Angular architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular架构
- en: Basics of TypeScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript的基础知识
- en: Building a simple application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个简单的应用程序
- en: Angular architecture
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular架构
- en: Before we discuss architecture, let's see what's new in Angular. The primary
    focus of Angular is mobiles, as it is important to consider the performance and
    loading time of the application on a mobile phone. Many modules are decoupled
    from the Angular core, leaving only the modules that are definitely core; removing
    unwanted modules from Angular core leads to better performance.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论架构之前，让我们看看Angular的新功能。Angular的主要重点是移动设备，因为重要的是要考虑应用程序在手机上的性能和加载时间。许多模块已经从Angular核心中解耦，只留下了绝对核心的模块；从Angular核心中移除不需要的模块可以提高性能。
- en: Angular targets ES6 and leverages TypeScript as a development script language
    that enables compile time checks for types, rather than at runtime. TypeScript
    provides additional information about classes when instantiating them by annotating
    metadata to the classes. You can also use ES5 and Dart as the development language.
    There is an improved version of Dependency Injection that supports child injectors
    and instance scope. Router was rewritten completely and the component router was
    introduced. The Component Directive, the Decorator Directive, and the Template
    Directive are supported in Angular. The $scope has been completely removed from
    Angular.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的目标是ES6，并利用TypeScript作为开发脚本语言，可以在编译时对类型进行检查，而不是在运行时。TypeScript在实例化类时提供了关于类的额外信息，通过为类注释元数据。您也可以使用ES5和Dart作为开发语言。有一个改进的依赖注入版本，支持子注入器和实例范围。路由器被完全重写，引入了组件路由器。Angular支持组件指令、装饰器指令和模板指令。$scope已经完全从Angular中移除。
- en: 'The architecture of Angular comprises **Modules**, **Components**, **Templates**,
    **Metadata**, **Directives**, and **Services**:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的架构包括**模块**、**组件**、**模板**、**元数据**、**指令**和**服务**。
- en: '![](assets/32caa67c-98c9-4d0b-bf2f-36f862ab6133.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/32caa67c-98c9-4d0b-bf2f-36f862ab6133.png)'
- en: NgModules
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgModules
- en: Angular framework has various libraries that are grouped as modules in order
    to build an application. Angular applications are modular in nature and are constructed
    by assembling various modules. Modules may have components, services, functions,
    and/or values. Some modules may have a collection of other modules and are known
    as library modules.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Angular框架有各种库，这些库被分组为模块，以构建应用程序。Angular应用程序具有模块化的特性，并通过组装各种模块来构建。模块可能包含组件、服务、函数和/或值。一些模块可能包含其他模块的集合，被称为库模块。
- en: 'Angular packages, such as `core`, `common`, `http`, and `router` that are prefixed
    with `@angular` comprise many modules. We import what our application needs from
    these library modules as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Angular包，如`core`，`common`，`http`和`router`，它们以`@angular`为前缀，包含许多模块。我们从这些库模块中导入我们的应用程序需要的内容，如下所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we import `Http` and `Response` from the library module, `@angular/http`.
    `@angular/http` refers to a folder in the Angular package. Any module defined
    to be exported can be imported into another module by referring to the filename
    of the module.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从库模块`@angular/http`中导入`Http`和`Response`。`@angular/http`指的是Angular包中的一个文件夹。可以通过引用模块的文件名将任何定义为导出的模块导入到另一个模块中。
- en: 'Note: this import statement was introduced in ES2015 and is used to import
    objects or function that are exported from other modules or scripts'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这个导入语句是在ES2015中引入的，用于导入从其他模块或脚本导出的对象或函数
- en: 'However, we can also refer to the folder as we referred to `@angular/http`.
    This can be achieved by adding an `index.ts` file to the folder and adding the
    code to export modules from the folder. This is a best practice suggested by Angular''s
    style guide and is called the barrel technique:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们也可以像我们引用`@angular/http`一样引用文件夹。这可以通过在文件夹中添加一个`index.ts`文件并添加代码来从文件夹中导出模块来实现。这是Angular风格指南建议的最佳实践，称为桶技术：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is the export statement in the `index.ts` found in `@angular/http`. The
    statement means that it exports all the modules in HTTP and that they can be imported
    to our application wherever needed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在`@angular/http`中找到的`index.ts`中的导出语句。该语句意味着它导出HTTP中的所有模块，并且它们可以在我们的应用程序中根据需要导入。
- en: When we write an Angular application, we start by defining an `AppComponent`
    (not necessarily with the same name) and exporting it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写一个Angular应用程序时，我们首先定义一个`AppComponent`（不一定要使用相同的名称）并导出它。
- en: Components
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件
- en: 'A component is a class that has properties and methods to be used in the view.
    These properties and methods exposed to view enable the view to interact with
    components. We code logic that supports the view in the component class:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是一个具有属性和方法的类，用于在视图中使用。这些暴露给视图的属性和方法使视图能够与组件交互。我们在组件类中编写支持视图的逻辑：
- en: '![](assets/43c035d9-7a54-4859-9299-d8eb48f73541.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/43c035d9-7a54-4859-9299-d8eb48f73541.png)'
- en: 'For example, next is a component class book that has a `properties` title and
    author and a `getPubName` method that returns the name of the book:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，接下来是一个组件类book，它具有`properties`标题和作者以及一个`getPubName`方法，该方法返回书的名称：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note: We will be using TypeScript in all our examples in this book.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在本书的所有示例中，我们将使用TypeScript。
- en: The life cycle of a component is managed by Angular according to user interactions
    with the application. We can also add an `event` method that will be fired according
    to the state changes of the component. These `event` methods are known as life
    cycle hooks and are optional.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的生命周期由Angular根据用户与应用程序的交互来管理。我们还可以添加一个根据组件状态变化触发的`event`方法。这些`event`方法称为生命周期钩子，是可选的。
- en: We will learn in detail about components in [Chapter 5](57d46335-212e-47fc-b817-828b7f684476.xhtml),
    *Implementing Angular Routing and Navigation*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第5章](57d46335-212e-47fc-b817-828b7f684476.xhtml)中详细了解组件，“实现Angular路由和导航”。
- en: Templates
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: 'Templates can be thought of as a representation of a component that is visualized
    according to the UI/UX needs of an application. A component will have a template
    associated with it. The template is responsible for displaying and updating data
    according to user events:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 模板可以被视为根据应用程序的UI/UX需求可视化的组件的表示。一个组件将有一个与之关联的模板。模板负责根据用户事件显示和更新数据：
- en: '![](assets/d2f3477c-a8d3-4260-8393-bf9ef72718aa.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d2f3477c-a8d3-4260-8393-bf9ef72718aa.png)'
- en: 'Here is a simple template that displays the title and author of a book:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的模板，用于显示书籍的标题和作者：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the title and author values wrapped in curly braces will be supplied by
    the associated component instance.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，用花括号括起来的标题和作者值将由相关组件实例提供。
- en: We will discuss templates and their syntax in detail in [Chapter 8](1dfecab5-25d2-47a0-88a2-eac2cece692e.xhtml),
    *Template and Data Binding Syntax*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第8章](1dfecab5-25d2-47a0-88a2-eac2cece692e.xhtml)中详细讨论模板及其语法，*模板和数据绑定语法*。
- en: Metadata
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元数据
- en: 'A class can be turned into a component by annotating it with `@Component` and
    passing the necessary metadata, such as `selector`, `template`, or `templateUrl`.
    Angular considers a class as a component only after attaching metadata to it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`@Component`对类进行注释并传递必要的元数据，如`selector`、`template`或`templateUrl`，可以将类转换为组件。只有在向类附加元数据后，Angular才会将其视为组件：
- en: '![](assets/a5ede5bd-7d8a-412f-ad70-7076b5d69a58.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a5ede5bd-7d8a-412f-ad70-7076b5d69a58.png)'
- en: 'Let''s revisit the `BookComponent` class we defined earlier. Angular does not
    consider this class as a component unless we annotate it. TypeScript leverages
    the ES7 feature by providing a way to decorate a class with metadata as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新访问一下我们之前定义的`BookComponent`类。除非我们对其进行注释，否则Angular不会将此类视为组件。TypeScript利用ES7功能，提供了一种用元数据装饰类的方法，如下所示：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we have decorated the `BookComponent` class with `@Component` and attached
    metadata selector and `templateUrl`. It means that, wherever Angular sees the
    special `<book-detail/>` tag in the view, it will create an instance of `BookComponent`
    and render the view assigned to `templateUrl`, which is `book.component.html`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们用`@Component`装饰了`BookComponent`类，并附加了选择器和`templateUrl`的元数据。这意味着，无论在视图中的哪里，Angular都会看到特殊的`<book-detail/>`标签，并创建一个`BookComponent`实例，并呈现分配给`templateUrl`的视图，即`book.component.html`。
- en: A decorator provided by TypeScript is a function that takes configuration parameters
    that are used by Angular to create an instance of the component and render the
    associated view. Configuration parameters may also have information about directives
    and providers, which will be made available by Angular when the component is created.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript提供的装饰器是一个函数，它接受配置参数，这些参数由Angular用于创建组件实例并呈现相关视图。配置参数还可能包含有关指令和提供者的信息，在创建组件时，Angular将使其可用。
- en: Data Binding
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据绑定
- en: 'Data Binding is one of the core responsibilities of developers when writing
    code to bind data to the user interface and update changing data according to
    user interactions with the user interface. Angular has reduced the burden of writing
    large amounts of code to handle Data Binding:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定是开发人员在编写代码时的核心责任之一，用于将数据绑定到用户界面，并根据用户与用户界面的交互更新变化的数据。Angular减轻了编写大量代码来处理数据绑定的负担：
- en: '![](assets/59d7cea0-56cd-4202-8001-837ecfaf9461.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/59d7cea0-56cd-4202-8001-837ecfaf9461.png)'
- en: 'Angular handles Data Binding by coordinating with templates and components.
    The templates provide instructions to Angular on how and what to bind. There are
    two types of binding in Angular: globally One-way Data Binding and Two-way Data
    Binding. One-way Data Binding deals with either binding data from the component
    to the DOM or from the DOM to the component. Two-way Data Binding deals with both
    sides of communication, that is, the component to the DOM and the DOM to the component.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Angular通过与模板和组件协调来处理数据绑定。模板向Angular提供了如何以及绑定什么的指令。在Angular中有两种类型的绑定：全局单向数据绑定和双向数据绑定。单向数据绑定处理从组件到DOM或从DOM到组件的数据绑定。双向数据绑定处理通信的双方，即组件到DOM和DOM到组件。
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, `book.title` wrapped in double curly braces deals with One-way Data Binding.
    The value of book title, if available in the component instance, will be displayed
    in the view. `book.author`, assigned to the `ngModel` property of the input element,
    deals with Two-way Data Binding. If the component instance has a value in the
    author property, then it will be assigned to the input elements, and if the value
    is changed by the user in the input control, then the updated value will be available
    in the component instance.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`book.title`用双大括号包裹，处理单向数据绑定。如果组件实例中有书名的值，它将显示在视图中。`book.author`赋给输入元素的`ngModel`属性，处理双向数据绑定。如果组件实例中的作者属性有值，它将被赋给输入元素，如果用户在输入控件中更改了值，更新后的值将在组件实例中可用。
- en: We will learn in detail about Data Binding in [Chapter 8](1dfecab5-25d2-47a0-88a2-eac2cece692e.xhtml),
    *Template and Data Binding Syntax*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第8章](1dfecab5-25d2-47a0-88a2-eac2cece692e.xhtml)中详细学习数据绑定，*模板和数据绑定语法*。
- en: Directives
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令
- en: 'A directive is instructions or guidelines for rendering a template. A class
    decorated with `@Directive` to attached metadata is called a directive. There
    are three types of directive supported by Angular, namely Component Directive,
    Structural Directive, and Attribute Directive:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 指令是用于渲染模板的指令或指导方针。一个带有`@Directive`装饰的类附加了元数据，被称为指令。Angular支持三种类型的指令，即组件指令、结构指令和属性指令：
- en: '![](assets/691c7928-e999-4ce4-bc82-fa0b8b6c6c4d.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/691c7928-e999-4ce4-bc82-fa0b8b6c6c4d.png)'
- en: 'A component is one form of a directive with a template that is decorated with
    `@Component`: it is actually an extended `@Directive` with a template feature:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是带有模板的指令的一种形式，它被装饰为`@Component`：实际上它是一个带有模板特性的扩展`@Directive`：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Structural Directives manipulate the DOM elements and alter their structure
    by adding, removing, and replacing DOM elements. The following code snippet uses
    two Structural Directives:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 结构指令通过添加、删除和替换DOM元素来操作DOM元素并改变它们的结构。以下代码片段使用了两个结构指令：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, the `div` element has a `*ngFor` directive that iterates through the books
    collection object and replaces the title of each book.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`div`元素有一个`*ngFor`指令，它遍历books集合对象并替换每本书的标题。
- en: 'An Attribute Directive helps to update the behavior or the appearance of an
    element. Let''s use the Attribute Directive to set the font size of a paragraph.
    The following code snippet shows an HTML statement implemented with an Attribute
    Directive:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 属性指令有助于更新元素的行为或外观。让我们使用属性指令来设置段落的字体大小。以下代码片段显示了一个使用属性指令实现的HTML语句：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We need to implement a class annotated with `@Directive` along with the selector
    for the directive. This class should be implemented with the instructions on the
    behavior of the directive:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现一个带有`@Directive`注解的类，以及指令的选择器。这个类应该包含指令行为的指令：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, Angular will look for elements with the `[myFontsize]` directive and sets
    the font size to `16`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Angular将查找带有`[myFontsize]`指令的元素，并将字体大小设置为`16`。
- en: 'It is necessary to pass the `myFontSize` directive to the declarations metadata
    of `@NgModule` as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 需要将`myFontSize`指令传递给`@NgModule`的declarations元数据，如下所示：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will discuss directives in detail in [Chapter 6](a3ceef84-7c5a-4a37-9bd6-a401096f958e.xhtml),
    *Creating Directives and Implementing Change Detection*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](a3ceef84-7c5a-4a37-9bd6-a401096f958e.xhtml)中详细讨论指令，*创建指令和实现变更检测*。
- en: Services
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: 'Services are user-defined classes used to solve problems. Angular recommends
    only having template-specific codes in components. A component''s responsibility
    is to enrich the UI/UX in the Angular application and delegate business logic
    to services. Components are consumers of services:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是用户定义的用于解决问题的类。Angular建议只在组件中包含特定于模板的代码。组件的责任是丰富Angular应用程序中的UI/UX，并将业务逻辑委托给服务。组件是服务的消费者：
- en: '![](assets/db5db7b5-cee5-43bd-bdf5-a54751faacbf.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/db5db7b5-cee5-43bd-bdf5-a54751faacbf.png)'
- en: 'Application-specific or business logic such as persisting application data,
    logging errors, and file storage should be delegated to services, and components
    should consume the respective services to deal with the appropriate business or
    application-specific logic:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序特定或业务逻辑，如持久化应用程序数据、记录错误和文件存储，应该委托给服务，组件应该消费相应的服务来处理适当的业务或应用程序特定逻辑：
- en: '![](assets/02804b2d-fc90-43cf-819d-ee823fb3f51a.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/02804b2d-fc90-43cf-819d-ee823fb3f51a.png)'
- en: For example, we can have a service called `BookService` that deals with inserting
    new books, editing or deleting existing books, and fetching a list of all the
    books available.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以有一个名为`BookService`的服务，用于插入新书籍，编辑或删除现有书籍，并获取所有可用书籍的列表。
- en: We will see more about services in [Chapter 11](3fdebb29-fbfb-4c2e-9985-d5b7771fcffa.xhtml),
    *Implementing Angular Pipes*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第11章](3fdebb29-fbfb-4c2e-9985-d5b7771fcffa.xhtml)中更多地了解服务，*实现Angular管道*。
- en: Dependency Injection
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: 'When an instance of a class is created, supplying the required dependencies
    of that class for it to function properly is called Dependency Injection. Angular
    provides a modern and improved version of Dependency Injection:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建类的实例时，为其正常运行提供所需的依赖项称为依赖注入。Angular提供了依赖注入的现代和改进版本：
- en: '![](assets/51888c08-2111-4385-90e5-fcbc57d1ed80.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/51888c08-2111-4385-90e5-fcbc57d1ed80.png)'
- en: 'In Angular, the injector maintains the containers to hold the instances of
    the dependencies and serves them as and when required. If the instance of a dependency
    is not available in the container, then the injector creates an instance of the
    dependency and serves it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，注入器维护容器来保存依赖项的实例，并在需要时提供它们。如果依赖项的实例在容器中不可用，则注入器将创建依赖项的实例并提供它：
- en: '![](assets/4e33b01c-c3c2-4235-8a42-7d7bbe5fe6cb.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4e33b01c-c3c2-4235-8a42-7d7bbe5fe6cb.png)'
- en: 'As stated earlier, components have logic that is related to templates and mostly
    consume services to perform business logic. So, components depend on services.
    When we write code for components, we create a parameter constructor that takes
    the service as an argument. It means that creating an instance of the component
    depends on the service parameter in the constructor. Angular requests that the
    injector provide the instance of the service in the parameter of the constructor
    of the component. The injector will serve the instance of the requested service,
    if available; otherwise, it creates a new one and serves it:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，组件具有与模板相关的逻辑，并且大多数情况下消费服务以执行业务逻辑。因此，组件依赖于服务。当我们为组件编写代码时，我们创建一个带有服务作为参数的构造函数。这意味着创建组件的实例取决于构造函数中的服务参数。Angular要求注入器在组件的构造函数参数中提供服务的实例。如果可用，注入器将提供所请求服务的实例；否则，它将创建一个新的实例并提供它：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this code snippet, the `:` symbol comes from TypeScript and is not Angular
    syntactical sugar. The `private` keyword is also from TypeScript and enables assigning
    the passed constructor to the class instance automatically. The type information
    is used to infer the type to be injected. The `BookComponent` has a dependency
    to `BookService` and is injected in the constructor. So when an instance of the
    `BookComponent` is created, Angular will also make sure the instance of `BookService`
    is readily available for the `BookComponent` instance to consume.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，`:` 符号来自 TypeScript，并不是 Angular 语法糖。`private` 关键字也来自 TypeScript，并且可以自动将传递的构造函数分配给类实例。类型信息用于推断要注入的类型。`BookComponent`
    依赖于 `BookService` 并在构造函数中注入。因此，当创建 `BookComponent` 的实例时，Angular 也会确保 `BookService`
    的实例对于 `BookComponent` 实例来说是可用的。
- en: 'The injector has knowledge of the dependencies to be created from providers
    that are configured with the required dependency types when bootstrapping the
    application or when decorating the components, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注射器知道要从提供程序创建的依赖项，并在引导应用程序或装饰组件时配置所需的依赖项类型，如下所示：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code snippet adds `BookService` as a provider to the bootstrap
    function. The injector will create an instance of `BookService` and keep it available
    in the container for the entire application to inject whenever it''s requested:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段将 `BookService` 添加为引导函数的提供程序。注射器将创建 `BookService` 的实例，并在整个应用程序中保持其可用性，以便在请求时注入：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code snippet adds `BookService` as a provider in the metadata
    of the component. The injector will create an instance of `BookService` when it
    encounters a request to create an instance of `BookComponent`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段将 `BookService` 添加为组件的元数据提供程序。当遇到创建 `BookComponent` 实例的请求时，注射器将创建 `BookService`
    的实例。
- en: We will discuss Dependency Injection and hierarchical Dependency Injection in
    detail in [Chapter 12](998d521f-cf30-4688-9763-12878fcd23e9.xhtml), *Implementing
    Angular Services.*
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第12章](998d521f-cf30-4688-9763-12878fcd23e9.xhtml)中详细讨论依赖注入和分层依赖注入，*实现 Angular
    服务*。
- en: Basics of TypeScript
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript 的基础知识
- en: TypeScript is a superset of JavaScript and is an open source language developed
    by Microsoft. Code written in TypeScript will be compiled to JavaScript and executed
    on any browser or server running `Node.js`. TypeScript is actually a type of JavaScript.
    TypeScript helps to improve the quality of code you write in JavaScript. If we
    use external libraries, we need to use type definition files for the imported
    libraries. Type definition files provide JavaScript tooling support and also enable
    compile time checks, code refactoring, and variable renaming support by inferring
    the structure of the code. TypeScript is evolving and keeps adding additional
    features aligned with the ES2016 specification and later.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 是 JavaScript 的超集，是由 Microsoft 开发的开源语言。用 TypeScript 编写的代码将被编译为 JavaScript，并在运行
    `Node.js` 的任何浏览器或服务器上执行。TypeScript 实际上是 JavaScript 的一种类型。TypeScript 有助于提高您在 JavaScript
    中编写的代码的质量。如果我们使用外部库，我们需要使用导入库的类型定义文件。类型定义文件提供 JavaScript 工具支持，并通过推断代码结构来启用编译时检查、代码重构和变量重命名支持。TypeScript
    正在不断发展，并不断添加与 ES2016 规范和以后对齐的其他功能。
- en: 'There are various editors available on the market that write TypeScript code
    and compile them using a TypeScript compiler. These editors take care of compiling
    your TypeScript into JavaScript. Some popular editors are shown here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有各种编辑器可以编写 TypeScript 代码，并使用 TypeScript 编译器进行编译。这些编辑器负责将您的 TypeScript 编译为
    JavaScript。这里显示了一些流行的编辑器：
- en: Visual Studio
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio
- en: Visual Studio Code
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: Sublime text
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sublime text
- en: Atom
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Atom
- en: Eclipse
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse
- en: Emacs
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Emacs
- en: WebStorm
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebStorm
- en: Vim
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vim
- en: 'You can also download TypeScript as a `Node.js` package by executing the following
    command in the Node.js command-line tool to install TypeScript globally:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过在Node.js命令行工具中执行以下命令来将TypeScript作为`Node.js`包下载到全局：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To transpile the TypeScript code into JavaScript, you can execute the following
    command in the command-line tool:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要将TypeScript代码转译为JavaScript，您可以在命令行工具中执行以下命令：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, `tsc` is the TypeScript compiler that converts a TypeScript file into
    a JavaScript file. `mytypescriptfile` is the name of your TypeScript code file
    and `.ts` is the extension of the TypeScript file. On executing the `tsc` command,
    it generates a `.js` file with the same name as the `.ts` source file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`tsc`是TypeScript编译器，它将TypeScript文件转换为JavaScript文件。`mytypescriptfile`是您的TypeScript代码文件的名称，`.ts`是TypeScript文件的扩展名。执行`tsc`命令时，它会生成一个与`.ts`源文件同名的`.js`文件。
- en: We will be using Visual Studio Code editor for our sample code demos in this
    chapter. Let us see basic features of TypeScript with examples.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Visual Studio Code编辑器进行示例代码演示。让我们看看TypeScript的基本特性，并举例说明。
- en: Basic types
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本类型
- en: Let's explore some of the basic types in TypeScript and how to use them. Basic
    types include primitive types such as number, string, boolean, and array in TypeScript.
    JavaScript only validates types during runtime, but TypeScript validates variable
    types during compile time and greatly reduces the possibility of typecast issues
    during runtime.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索TypeScript中一些基本类型以及如何使用它们。基本类型包括原始类型，如数字、字符串、布尔和数组。JavaScript只在运行时验证类型，但TypeScript在编译时验证变量类型，并大大减少了运行时类型转换问题的可能性。
- en: Number type
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字类型
- en: 'The number type represents floating point values. It can hold values such as
    decimal, binary, hexadecimal, and octal literals:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 数字类型表示浮点值。它可以保存十进制、二进制、十六进制和八进制文字等值：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Boolean type
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔类型
- en: 'The Boolean type is a very simple type that can hold either of two values,
    true or false. This Boolean type is used to maintain the state in a variable:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔类型是一个非常简单的类型，可以保存两个值中的任一个，true或false。这种布尔类型用于在变量中维护状态：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, the `isSaved` variable of type Boolean is assigned with the value true.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，布尔类型的`isSaved`变量被赋值为true。
- en: String
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: 'The string data type can hold a sequence of characters. Declaring and initializing
    the string variable is very simple, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串数据类型可以保存一系列字符。声明和初始化字符串变量非常简单，如下所示：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we declared a variable named `authorName` as a string, and it is assigned
    the value `Rajesh Gunasundaram`. TypeScript supports surrounding the string value
    with either a double quotes (") or single quotes (').
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个名为`authorName`的变量，类型为字符串，并赋值为`Rajesh Gunasundaram`。TypeScript支持用双引号（"）或单引号（'）括起字符串值。
- en: Array
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'The array data type is meant to hold a collection of values of specific types.
    In TypeScript, we can define arrays in two ways, which are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 数组数据类型旨在保存特定类型的值的集合。在TypeScript中，我们可以以以下两种方式定义数组：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This statement declares an array variable of the number type using square brackets
    ([]) after the data type number, and it is assigned with a series of even numbers
    from 2 to 10\. The second way to define array is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此语句使用方括号（[]）在数据类型数字后声明了一个数字类型的数组变量，并将其赋值为从2到10的一系列偶数。定义数组的第二种方式如下：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This statement uses the generic array type, which uses the Array keyword followed
    by angle brackets (<>) that wrap the number data type.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此语句使用了通用数组类型，它使用Array关键字后跟尖括号（<>）来包裹数字数据类型。
- en: Enum
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: 'The enum data type will have a named set of values. We use enumerators to give
    user-friendly names to constants that identify certain values:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举数据类型将具有一组命名的值。我们使用枚举器为标识某些值的常量提供用户友好的名称：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we have the `Day` enum variable, which holds a series of values that represent
    each day of the week. The second statement shows how to access a particular enum
    value in a day and assign it to another variable.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有`Day`枚举变量，它保存了代表每周每天的一系列值。第二个语句展示了如何访问特定的枚举值，并将其赋值给另一个变量。
- en: Any
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任意
- en: 'The any data type is a dynamic data type that can hold any value. TypeScript
    throws compile time errors if you assign a string variable to an integer variable.
    If you are not sure about what value a variable is going to hold and you would
    like to opt out of compiler-checking for the type in the assignment, you can use
    the any data type:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 任意数据类型是一个动态数据类型，可以容纳任何值。如果将字符串变量赋给整数变量，TypeScript会抛出编译时错误。如果不确定一个变量将要容纳什么值，并且希望在赋值时退出编译器对类型的检查，可以使用任意数据类型：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we used an array of the any type so that it can hold any type, such as
    numbers, strings, and booleans.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了任意类型的数组，以便它可以容纳任何类型，比如数字、字符串和布尔值。
- en: Void
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Void
- en: 'Void is actually nothing. It can be used as the return type of a function to
    declare that this function will not return any value:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Void实际上什么都不是。它可以用作函数的返回类型，声明这个函数不会返回任何值：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Classes
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: A class is an extensible template that is used to create objects with member
    variables to hold the state of the object and member functions that deal with
    the behavior of the object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 类是一个可扩展的模板，用于创建具有成员变量以保存对象状态和成员函数以处理对象行为的对象。
- en: 'JavaScript only supports function-based and prototype-based inheritance to
    build reusable components. ECMAScript 6 provides the syntactic sugar of using
    classes in supporting object-oriented programming. However, not all browsers understand
    ES6 and we need transpilers, such as TypeScript, that compile the code down to
    JavaScript and target ES5, which is compatible with all browsers and platforms:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript只支持基于函数和基于原型的继承来构建可重用的组件。ECMAScript 6提供了使用类的语法糖来支持面向对象编程。然而，并非所有浏览器都理解ES6，我们需要转译器，比如TypeScript，将代码编译成JavaScript并针对ES5，这与所有浏览器和平台兼容：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This `Customer` class has three members: a name property, a constructor, and
    a `logCustomer` method. The last statement outside the customer class creates
    an instance of the customer class using the `new` keyword.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Customer`类有三个成员：一个name属性，一个构造函数和一个`logCustomer`方法。在customer类外部的最后一个语句使用`new`关键字创建了一个customer类的实例。
- en: Interfaces
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: An interface is an abstract type that defines the behavior of a class. An interface
    is a contract that abstracts the implementation. An interface provides a type
    definition for an object that can be exchanged between clients. This enables the
    client to only exchange an object that is complied with the interface type definition.
    Otherwise, we get a compile time error.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是定义类行为的抽象类型。接口是抽象实现的契约。接口为可以在客户端之间交换的对象提供了类型定义。这使得客户端只能交换符合接口类型定义的对象。否则，我们会得到一个编译时错误。
- en: 'In TypeScript, interfaces define contracts for an object within your code and
    the code outside your project. Let''s see how to use TypeScript with an example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，接口定义了代码内部和项目外部对象的契约。让我们看一个使用TypeScript的例子：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The type checker verifies the `addCustomer` method call and examines its parameter.
    `addCustomer` expects an object with the name property of the string type. But
    the client that calls `addCustomer` is passed an object with two parameters, `id`
    and `name`, respectively.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器验证了`addCustomer`方法调用并检查了它的参数。`addCustomer`期望一个具有字符串类型的name属性的对象。但调用`addCustomer`的客户端传递了一个具有两个参数`id`和`name`的对象。
- en: However, the compiler does not check the `id` property as it is not available
    in the parameter type of the `addCustomer` method. It only matters for the compiler
    that the required properties are present.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编译器不会检查`id`属性，因为它不在`addCustomer`方法的参数类型中。对于编译器来说，只要求的属性存在即可。
- en: 'Let''s rewrite the method applying `interface` as a parameter type as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写应用`interface`作为参数类型的方法如下：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we declared the `Customer` interface with the name parameter, and we modified
    the `addCustomer` signature to accept the parameter of the type `Customer` interface.
    The remaining statements are same as in the previous code snippet. The compiler
    only checks for the shape of the object as TypeScript implements the structural
    type system. It will not check whether the object we are passing implements the
    `Customer` interface. It only looks for the `name` property of the `string` type
    in the parameter and then allows it, if it's present.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们用`Customer`接口声明了`name`参数，并修改了`addCustomer`签名以接受`Customer`接口类型的参数。其余语句与前面的代码片段相同。编译器只检查对象的形状，因为TypeScript实现了结构类型系统。它不会检查我们传递的对象是否实现了`Customer`接口。它只查找参数中`string`类型的`name`属性，然后允许它存在。
- en: Optional properties using an interface
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用接口的可选属性
- en: 'In some scenarios, we may want to pass values only for minimal parameters.
    In such cases, we can define the properties in an interface as optional properties,
    as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能只想为最小的参数传递值。在这种情况下，我们可以将接口中的属性定义为可选属性，如下所示：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, the bonus property has been defined as an optional property by concatenating
    a question mark (?) at the end of the name property.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，通过在`name`属性末尾添加问号（?），将`bonus`属性定义为可选属性。
- en: Function type interfaces
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数类型接口
- en: 'We just saw how to define properties in interfaces. Similarly, we can also
    define function types in interfaces. We can define function types in interfaces
    by just giving the signature of the function with the return type. Note that,
    in the following code snippet, we have not added the function name:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到如何在接口中定义属性。类似地，我们也可以在接口中定义函数类型。我们可以通过给出函数的签名和返回类型来在接口中定义函数类型。请注意，在下面的代码片段中，我们没有添加函数名：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we have `AddCustomerFunc` ready. Let''s define an interface variable called
    `AddCustomerFunc` and assign a function of the same signature to it as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了`AddCustomerFunc`。让我们定义一个名为`AddCustomerFunc`的接口变量，并将一个具有相同签名的函数分配给它，如下所示：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The parameter name in the function signature can vary, but not the data type.
    For example, we can alter the `fn` and `ln` function parameters of the string
    type as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 函数签名中的参数名称可以变化，但数据类型不能变化。例如，我们可以修改字符串类型的`fn`和`ln`函数参数如下：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: So, if we change the data type of the parameter or the return type of the function
    here, the compiler will throw an error about the parameter not matching or the
    return type not matching with the `AddCustomerFunc` interface.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们在这里改变参数的数据类型或函数的返回类型，编译器将抛出关于参数不匹配或返回类型与`AddCustomerFunc`接口不匹配的错误。
- en: Array type interfaces
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组类型接口
- en: 'We can also define an interface for array types. We can specify the data type
    for the index array and the data type to the array item as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为数组类型定义一个接口。我们可以指定索引数组的数据类型和数组项的数据类型如下：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'TypeScript supports two types of index: number and string. This array type
    interface also stipulates that the return type of the array should match the declaration.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript支持两种索引类型：数字和字符串。这种数组类型接口还规定了数组的返回类型应与声明相匹配。
- en: Class type interfaces
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类类型接口
- en: 'Class type interfaces define the contract for classes. A class that implements
    an interface should meet the requirement of the interface:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 类类型接口定义了类的契约。实现接口的类应该满足接口的要求：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The class type interface only deals with public members of the class. So, it
    is not possible to add private members to the interface.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 类类型接口只处理类的公共成员。因此，不可能向接口添加私有成员。
- en: Extending interfaces
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展接口
- en: 'Interfaces can be extended. Extending an interface makes it share the properties
    of another interface, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以被扩展。扩展接口使其共享另一个接口的属性，如下所示：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, the `Employee` interface extends the `Manager` interface and shares its
    `hasPower` with the `Employee` interface.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Employee`接口扩展了`Manager`接口，并与`Employee`接口共享其`hasPower`。
- en: Hybrid type interfaces
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合类型接口
- en: 'Hybrid type interfaces are used when we want to use the object both as a function
    and an object. We can call an object like a function if it implements a hybrid
    type interface, or we can use it as an object and access its properties. This
    type of interface enables you to use an interface as an object and a function,
    as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 混合类型接口用于当我们希望将对象既用作函数又用作对象时。如果实现了混合类型接口，我们可以像调用函数一样调用对象，或者我们可以将其用作对象并访问其属性。这种类型的接口使您能够将接口用作对象和函数，如下所示：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Inheritance
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: Inheritance is the concept of inheriting behaviors from another class or object.
    It helps to achieve code reusability and build a hierarchy in relationships of
    classes or objects. Also, inheritance helps you to cast similar classes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是从另一个类或对象继承行为的概念。它有助于实现代码的重用性，并建立类或对象之间的关系层次结构。此外，继承帮助您转换类似的类。
- en: JavaScript, by targeting ES5, doesn't support classes, and so class inheritance
    is impossible to implement. However, we can implement prototype inheritance instead
    of class inheritance. Let's explore inheritance in ES5 with examples.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript以ES5为目标，不支持类，因此无法实现类继承。但是，我们可以实现原型继承而不是类继承。让我们通过示例来探索ES5中的继承。
- en: 'First, create a function named `Animal` as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`Animal`的函数如下：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, we created a function named `Animal` with two methods: `sleep` and `eat`.
    Now, let''s extend this `Animal` function using the prototype as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`Animal`的函数，其中包含两个方法：`sleep`和`eat`。现在，让我们使用原型扩展这个`Animal`函数，如下所示：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we can create an instance of `Animal` and call the extended function,
    `bark`, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个`Animal`实例，并调用扩展函数`bark`，如下所示：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can use the `Object.Create` method to clone a prototype of the parent and
    create a child object. Then, we can extend the child object by adding methods.
    Let''s create an object named `Dog` and inherit it from `Animal`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Object.Create`方法克隆父级的原型并创建一个子对象。然后，我们可以通过添加方法来扩展子对象。让我们创建一个名为`Dog`的对象，并从`Animal`继承它：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, let''s clone the prototype of `Animal` and inherit all the behavior in
    the `Dog` function. Then, we can call the `Animal` method using the `Dog` instance,
    as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们克隆`Animal`的原型，并继承`Dog`函数中的所有行为。然后，我们可以使用`Dog`实例调用`Animal`方法，如下所示：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Inheritance in TypeScript
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript中的继承
- en: We just saw how to implement an inheritance in JavaScript using a prototype.
    Now, we will see how an inheritance can be implemented in TypeScript, which is
    basically ES6 inheritance.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何使用原型在JavaScript中实现继承。现在，我们将看到如何在TypeScript中实现继承，这基本上是ES6继承。
- en: 'In TypeScript, similar to extending interfaces, we can also extend a class
    by inheriting another class, as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，类似于扩展接口，我们也可以通过继承另一个类来扩展类，如下所示：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we are able to access the methods of `SimpleCalculator` using the instance
    of `ComplexCalculator` as it extends `SimpleCalculator`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以使用`ComplexCalculator`的实例来访问`SimpleCalculator`的方法，因为它扩展了`SimpleCalculator`。
- en: Private and public modifiers
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有和公共修饰符
- en: 'In TypeScript, all members in a class are `public` by default. We have to add
    the `private` keyword explicitly to control the visibility of the members, and
    this useful feature is not available in JavaScript:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，类中的所有成员默认都是`public`的。我们必须显式添加`private`关键字来控制成员的可见性，而这个有用的特性在JavaScript中是不可用的。
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that in the `SimpleCalculator` class, we defined `x` and `y` as private
    properties, which will not be visible outside the class. In `ComplexCalculator`,
    we defined `x` and `y` using parameter properties. These `Parameter` properties
    will enable us to create and initialize a member in one statement. Here, `x` and
    `y` are created and initialized in the constructor itself without writing any
    further statements inside it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`SimpleCalculator`类中，我们将`x`和`y`定义为私有属性，这些属性在类外部不可见。在`ComplexCalculator`中，我们使用参数属性定义了`x`和`y`。这些参数属性将使我们能够在一个语句中创建和初始化成员。在这里，`x`和`y`在构造函数中创建和初始化，而不需要在其中编写任何进一步的语句。
- en: Accessors
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问器
- en: 'We can also implement getters and setters to the properties to control accessing
    them from the client. We can intercept a process before setting a value to a property
    variable or before getting a value of the property variable:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以实现对属性的getter和setter，以控制从客户端访问它们。我们可以在设置属性变量的值之前或获取属性变量的值之前拦截一个过程：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, the setter for the `name` property ensures that the customer name can
    be updated. Otherwise, it shows an alert message to the effect that it is not
    possible.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`name`属性的setter确保客户名称可以更新。否则，它会显示一个警报消息，说明这是不可能的。
- en: Static properties
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态属性
- en: 'These properties are not instance-specific and are accessed by a class name
    instead of using the `this` keyword:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性不是特定于实例的，并且通过类名而不是使用`this`关键字来访问：
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, we declared a static variable called `bonusPercentage` that is accessed
    using the class name `Customer` in the `calculateBonus` method. This `bonusPercentage`
    property is not instance-specific.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个名为`bonusPercentage`的静态变量，它在`calculateBonus`方法中使用`Customer`类名进行访问。这个`bonusPercentage`属性不是特定于实例的。
- en: Modules
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: JavaScript is a powerful and dynamic language. With dynamic programming in JavaScript,
    we need to structure and organize the code so that it will make its maintainability
    easier and also enable us to easily locate the code for a specific functionality.
    We can organize code by applying a modular pattern. Code can be separated into
    various modules, and relevant code can be put in each module.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种强大而动态的语言。使用JavaScript进行动态编程时，我们需要结构化和组织代码，以使其易于维护，并且还能够轻松地找到特定功能的代码。我们可以通过应用模块化模式来组织代码。代码可以分成各种模块，并且相关的代码可以放在每个模块中。
- en: 'TypeScript made it easier to implement modular programming using the module
    keyword. Modules enable you to control the scope of variables, code reusability,
    and encapsulation. TypeScript supports two types of module: internal and external
    modules.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript通过使用模块关键字更容易实现模块化编程。模块使您能够控制变量的范围、代码的可重用性和封装性。TypeScript支持两种类型的模块：内部模块和外部模块。
- en: Namespaces
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: 'We can create namespaces in TypeScript using the namespace keyword as follows.
    All the classes defined under namespace will be scoped under this namespace and
    will not be attached to the global scope:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用namespace关键字在TypeScript中创建命名空间。在命名空间下定义的所有类都将在此命名空间下进行作用域限定，并且不会附加到全局范围：
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To make the `Product` class available for access outside the `namespace`, we
    need to add an `export` keyword when defining the `Product` class, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`Product`类在`namespace`之外可用，我们需要在定义`Product`类时添加`export`关键字，如下所示：
- en: '[PRE45]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can also share namespaces across files by adding a reference statement at
    the beginning of the code in the referring files, as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过在引用文件的开头添加引用语句来跨文件共享命名空间，如下所示：
- en: '[PRE46]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Modules
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: 'TypeScript also supports modules As we deal with a large number of external
    JavaScript libraries, this modularity will really help us organize our code. Using
    the import statement, we can import modules as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript还支持模块，因为我们处理大量外部JavaScript库，这种模块化将帮助我们组织我们的代码。使用import语句，我们可以导入模块，如下所示：
- en: '[PRE47]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we just imported the previously created module, Inventory, created an
    instance of `Product` and assigned it to the variable `p`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们刚刚导入了先前创建的模块Inventory，创建了`Product`的一个实例并将其分配给变量`p`。
- en: Functions
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: JavaScript, which follows the ES5 specs, does not support classes and modules.
    However, we tried to scope variables and modularity using functional programming
    in JavaScript. Functions are the building blocks of an application in JavaScript.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循ES5规范的JavaScript不支持类和模块。但是，我们尝试使用JavaScript中的函数式编程来限定变量和模块化。函数是JavaScript应用程序的构建块。
- en: 'Though TypeScript supports classes and modules, functions play a key role in
    defining a specific logic. We can define both named functions and anonymous functions
    in JavaScript as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管TypeScript支持类和模块，但函数在定义特定逻辑方面起着关键作用。我们可以在JavaScript中定义命名函数和匿名函数，如下所示：
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In TypeScript, we define functions with the type of the parameters and the
    return type using function arrow notation, which is also supported in ES6, as
    follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，我们使用函数箭头表示法定义参数的类型和返回类型，这也是ES6中支持的，如下所示：
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Optional and default parameters
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选和默认参数
- en: 'Say, for example, we have a function with three parameters, and sometimes we
    may only pass values for the first two parameters in the function. In TypeScript,
    we can handle such scenarios using the optional parameter. We can define the first
    two parameters as normal and the third parameter as optional, as given in the
    following code snippet:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有一个带有三个参数的函数，有时我们可能只在函数中传递前两个参数的值。在TypeScript中，我们可以使用可选参数来处理这种情况。我们可以将前两个参数定义为正常参数，将第三个参数定义为可选参数，如下面的代码片段所示：
- en: '[PRE50]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, `middleName` is the optional parameter, and it can be ignored when calling
    the `function`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`middleName`是可选参数，当调用`function`时可以忽略它。
- en: 'Now, let''s see how to set default parameters in a function. If a value is
    not supplied to a parameter in the function, we can define it to take the default
    value that is configured:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在函数中设置默认参数。如果在函数中没有提供参数的值，我们可以定义它以采用配置的默认值：
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, `middleName` is the default parameter that will have `No Middle Name`
    by default if the value is not supplied by the caller.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`middleName`是默认参数，如果调用者没有提供值，它将默认为`No Middle Name`。
- en: Rest parameter
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 剩余参数
- en: 'Using the rest parameter, you can pass an array of values to the function.
    This can be used in scenarios where you are not sure about how many values will
    be supplied to the function:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用剩余参数，您可以将值数组传递给函数。这可以用于您不确定将向函数提供多少值的情况：
- en: '[PRE52]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, note that the `restOfClient` rest parameter is prefixed with an ellipsis
    (...), and it can hold an array of strings. In the caller of the function, only
    the value of the first parameter that is supplied will be assigned to the `firstClient`
    parameter, and the remaining values will be assigned to `restOfClient` as array
    values.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，请注意`restOfClient`剩余参数前面带有省略号(...)，它可以保存一个字符串数组。在函数的调用者中，只有提供的第一个参数的值将被赋给`firstClient`参数，其余的值将被赋给`restOfClient`作为数组值。
- en: Generics
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: 'Generics are very useful for developing reusable components that can work against
    any data type. So, the client that consumes this component will decide what type
    of data it should act upon. Let''s create a simple function that returns whatever
    data is passed to it:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型对于开发可重用的组件非常有用，可以针对任何数据类型进行操作。因此，消费该组件的客户端将决定它应该对哪种类型的数据进行操作。让我们创建一个简单的函数，返回传递给它的任何数据：
- en: '[PRE53]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As you can see, we need individual methods to process each data type. We can
    implement them in a single function using the any data type, as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们需要单独的方法来处理每种数据类型。我们可以使用任意数据类型在一个函数中实现它们，如下所示：
- en: '[PRE54]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This is similar to generics. However, we don't have control over the return
    type. If we pass a number and we can't predict whether the number will be returned
    or not by the function, the return type can be of any type.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这与泛型类似。但是，我们无法控制返回类型。如果我们传递一个数字，我们无法预测函数是否会返回该数字，返回类型可以是任何类型。
- en: 'Generics offers a special variable of type `T`. Applying this type to the function
    as follows enables the client to pass the data type they would like this function
    to process:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型提供了一个特殊的`T`类型变量。将这种类型应用于函数，使客户端能够传递他们希望这个函数处理的数据类型：
- en: '[PRE55]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'So, the client can call this function for various data types as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，客户端可以按照以下方式调用这个函数来处理各种数据类型：
- en: '[PRE56]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note that the data type to be processed is passed by wrapping it in angle brackets
    (<>) in the function call.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在函数调用中，要处理的数据类型是通过尖括号（<>）包裹传递的。
- en: Generic interfaces
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型接口
- en: 'We can also define generic interfaces using the `T` type variable, as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`T`类型变量定义泛型接口，如下所示：
- en: '[PRE57]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, we defined a generic interface and the `myFunc` variable of the `GenericFunc`
    type, passing the number data type for the `T` type variable. Then, this variable
    is assigned with a function named `func`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个泛型接口和`GenericFunc`类型的`myFunc`变量，将数字数据类型传递给`T`类型变量。然后，将这个变量赋值给一个名为`func`的函数。
- en: Generic classes
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型类
- en: 'Similar to generic interfaces, we can also define generic classes. We define
    classes with a generic type in angle brackets (<>) as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 与泛型接口类似，我们也可以定义泛型类。我们使用尖括号（<>）定义带有泛型类型的类，如下所示：
- en: '[PRE58]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, the generic class is instantiated by passing the generic data type as
    number. So, the add function will process and add two variables of type number
    passed as parameters.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，通过传递数字作为泛型数据类型来实例化泛型类。因此，add函数将处理并添加作为参数传递的两个数字类型的变量。
- en: Decorators
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: Decorators enable us to extend a class or object by adding behaviors without
    modifying code. Decorators wrap the class with extra functionality. Decorators
    can be attached to a class, property, method, parameter, and accessor. In ECMAScript
    2016, decorators are proposed to modify the behavior of a class. Decorators are
    prefixed with the `@` symbol and a decorator name that resolves to a function
    called at runtime.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器使我们能够通过添加行为来扩展类或对象，而无需修改代码。装饰器为类添加额外功能。装饰器可以附加到类、属性、方法、参数和访问器上。在ECMAScript
    2016中，装饰器被提议用于修改类的行为。装饰器以`@`符号和在运行时调用的函数解析为装饰器名称。
- en: 'The following code snippet shows the authorize function, and it can be used
    as the `@authorize` decorator on any other class:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了授权函数，并且它可以作为`@authorize`装饰器应用于任何其他类：
- en: '[PRE60]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Class decorators
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类装饰器
- en: 'Class decorators are declared above the class declaration. Class decorators
    can observe, modify, and replace a class'' definition that it is decorated by
    applying to the constructor of that class. The signature of `ClassDecorator` in
    TypeScript is as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 类装饰器在类声明之前声明。类装饰器可以观察、修改和替换被其应用于的类的定义，通过应用于该类的构造函数。TypeScript中`ClassDecorator`的签名如下：
- en: '[PRE61]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Consider a `Customer` class; we would like that class to be frozen. Its existing
    properties should not be removed or new properties should not be added.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个`Customer`类；我们希望该类被冻结。其现有属性不应被移除，也不应添加新属性。
- en: 'We can create a separate class that can take any object and freeze it. We can
    then decorate the customer class with `@freezed` to prevent adding new properties
    or removing the existing properties from the class:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个单独的类，可以接受任何对象并将其冻结。然后我们可以用`@freezed`装饰客户类，以防止向类添加新属性或删除现有属性：
- en: '[PRE62]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The preceding class takes four arguments in the `firstname` and `lastname`
    constructors. The following are the code snippets of the function written for
    the `@freezed` decorator:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类在`firstname`和`lastname`构造函数中接受四个参数。以下是为`@freezed`装饰器编写的函数的代码片段：
- en: '[PRE63]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here, the freezed decorator takes `target`, which is the `Customer` class that
    is being decorated, and freezes it when it gets executed.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，freezed装饰器接受`target`，即被装饰的`Customer`类，并在执行时将其冻结。
- en: Method decorators
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法装饰器
- en: 'Method decorators are declared before the method declaration. This decorator
    is used to modify, observe, or replace a method definition and is applied to the
    property descriptor for the method. The following code snippet shows a simple
    class with an applied method decorator:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 方法装饰器在方法声明之前声明。此装饰器用于修改、观察或替换方法定义，并应用于方法的属性描述符。以下代码片段显示了一个简单的类，其中应用了方法装饰器：
- en: '[PRE64]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `Hello` class has the `increment` method that increments a number supplied
    to its parameter. Note that the `increment` method is decorated with the `@logging`
    decorator to log input and output of the increment method. The following is the
    code snippet of the `logging` function:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hello`类具有`increment`方法，该方法递增其参数提供的数字。请注意，`increment`方法使用`@logging`装饰器进行装饰，以记录递增方法的输入和输出。以下是`logging`函数的代码片段：'
- en: '[PRE65]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The method decorator function takes three arguments: `target`, `key`, and `value`.
    `target` holds the method that is being decorated; `key` holds the name of the
    method being decorated; and `value` is the property descriptor of the specified
    property if it exists on the object.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 方法装饰器函数接受三个参数：`target`，`key`和`value`。`target`保存被装饰的方法；`key`保存被装饰方法的名称；`value`是对象上存在的指定属性的属性描述符。
- en: The logging method gets invoked when the increment method is called and it logs
    the value to the console.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用递增方法时，logging方法被调用，并将值记录到控制台。
- en: Accessor decorators
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问器装饰器
- en: 'Accessor decorators are prefixed before the accessor declaration. These decorators
    are used to observe, modify, or replace an accessor definition and are applied
    to the property descriptor. The following code snippet shows a simple class with
    the applied accessor decorator applied:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 访问器装饰器在访问器声明之前加上前缀。这些装饰器用于观察、修改或替换访问器定义，并应用于属性描述符。以下代码片段显示了一个简单的类，其中应用了访问器装饰器：
- en: '[PRE66]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In this class, we decorate the get accessor of `firstname` and `lastname` with
    `@logging` and pass `boolean` to enable or disable logging. The following code
    snippet shows the function for the `@logging` decorator:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们使用`@logging`装饰器修饰了`firstname`和`lastname`的获取器，并传递了`boolean`来启用或禁用日志记录。以下代码片段显示了`@logging`装饰器的函数：
- en: '[PRE67]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `logging` function sets the Boolean value to the logging property descriptor.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`logging`函数将布尔值设置为日志属性描述符。'
- en: Property decorators
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性装饰器
- en: 'Property decorators are prefixed to property declarations. They actually redefine
    the property decorated by adding extra behavior. The signature of `PropertyDecorator`
    in the TypeScript source code is as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 属性装饰器是前缀到属性声明的。它们实际上通过添加额外的行为来重新定义被装饰的属性。在TypeScript源代码中，`PropertyDecorator`的签名如下：
- en: '[PRE68]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The following is a code snippet of a class with a property decorator applied
    to a property:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个类的代码片段，其中应用了属性装饰器：
- en: '[PRE69]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In this code, the `firstname` property is decorated with the `@hashify` property
    decorator. Now, we will see the code snippet of the `@hashify` property decorator
    function:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`firstname`属性被`@hashify`属性装饰器修饰。现在，我们将看到`@hashify`属性装饰器函数的代码片段：
- en: '[PRE70]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `_value` holds the value of the property that is being decorated. Both
    getter and setter functions will have access to the variable `_value` and here
    we can manipulate the `_value` by adding extra behaviors. I have concatenated
    # in the getter to return a hash-tagged `firstname`. Then we delete the original
    property from the class prototype using the `delete` operator. A new property
    will be created with the original property name with the extra behavior.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`_value`保存了被装饰属性的值。获取器和设置器函数都可以访问变量`_value`，在这里我们可以通过添加额外的行为来操纵`_value`。我已经在获取器中连接了#来返回带有哈希标记的`firstname`。然后我们使用`delete`运算符从类原型中删除原始属性。将创建一个带有原始属性名称和额外行为的新属性。'
- en: Parameter decorators
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数装饰器
- en: 'Parameter decorators are prefixed to parameter declarations, and they are applied
    to a function for a class constructor or a method declaration. The signature of
    `ParameterDecorator` is as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 参数装饰器是前缀到参数声明的，并且它们应用于类构造函数或方法声明的函数。`ParameterDecorator`的签名如下：
- en: '[PRE71]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, let''s define the `Customer` class and use a parameter decorator to decorate
    a parameter in order to make it required and validate whether the value has been
    served:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义`Customer`类，并使用参数装饰器来修饰参数，以使其成为必需参数，并验证值是否已被提供：
- en: '[PRE72]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Here, the name parameter has been decorated with `@logging`. The parameter
    decorator implicitly takes three inputs, namely `prototype` of the class that
    has this decorator, the `name` of the method that has this decorator, and the
    `index` of the parameter that is being decorated. The `logging` function implementation
    of the parameter decorator is as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，名称参数已被`@logging`修饰。参数装饰器隐式接受三个输入，即具有此装饰器的类的`prototype`，具有此装饰器的方法的`name`，以及被装饰的参数的`index`。参数装饰器的`logging`函数实现如下：
- en: '[PRE73]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Here, `target` is the class that has the decorator, `key` is the function name,
    and `index` contains the parameter index. This code just logs `target`, `key`,
    and `index` to the console.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`target`是具有装饰器的类，`key`是函数名称，`index`包含参数索引。这段代码只是将`target`、`key`和`index`记录到控制台。
- en: Building a simple application
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个简单的应用程序
- en: 'I assume that you have installed Node.js, npm, and Visual Studio Code and are
    ready to use them for development. Now let us create an Angular application by
    cloning the Git repository and performing the following steps:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设您已经安装了Node.js、npm和Visual Studio Code，并准备好用它们进行开发。现在让我们通过克隆Git存储库并执行以下步骤来创建一个Angular应用程序：
- en: 'Open the `Node.Js` command prompt and execute the following command:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Node.Js`命令提示符并执行以下命令：
- en: '[PRE74]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Open the cloned `my-angular` application using Visual Studio Code. This command
    will clone the Angular quickstart repository and creates an Angular application
    named my-angular for you with all the boilerplate codes required.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Visual Studio Code打开克隆的`my-angular`应用程序。此命令将克隆Angular快速启动存储库，并为您创建一个名为my-angular的Angular应用程序，其中包含所需的所有样板代码。
- en: '![](assets/5da2b9fa-3474-4251-8eb6-9debbfc749e9.png)Folder structure of the
    my-angular application.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/5da2b9fa-3474-4251-8eb6-9debbfc749e9.png)my-angular应用程序的文件夹结构。'
- en: The folder structure and the boilerplate code are organized according to the
    official style guide in [https://angular.io/docs/ts/latest/guide/style-guide.html](https://angular.io/docs/ts/latest/guide/style-guide.html).
    The `src` folder has the code files related to application logic, and the `e2e`
    folder has the files related to end-to-end testing. Don't worry about other files
    in the application now. Let's focus on `package.json` for now
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹结构和样板代码按照官方样式指南[https://angular.io/docs/ts/latest/guide/style-guide.html](https://angular.io/docs/ts/latest/guide/style-guide.html)进行组织。`src`文件夹包含与应用程序逻辑相关的代码文件，`e2e`文件夹包含与端到端测试相关的文件。现在不要担心应用程序中的其他文件。让我们现在专注于`package.json`。
- en: 'Click on the `package.json` file, and it will have information about the configurations
    of the metadata and project dependencies. Here is the content of the `package.json`
    file:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`package.json`文件，它将包含有关元数据和项目依赖项配置的信息。以下是`package.json`文件的内容：
- en: '[PRE75]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now we need to run the `npm install` command in a command window, navigating
    to the `application` folder to install the required dependencies specified in
    `package.json`:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在命令窗口中运行`npm install`命令，导航到`application`文件夹中，以安装`package.json`中指定的所需依赖项：
- en: '![](assets/0b300ed3-b49c-4a93-98da-6389bc785f06.png)Execute the npm command
    to install dependencies specified in package.json.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/0b300ed3-b49c-4a93-98da-6389bc785f06.png)执行npm命令以安装`package.json`中指定的依赖项。'
- en: 'Now, you will have all the dependencies added to the project under the `node_modules`
    folder, as shown in this screenshot:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将在`node_modules`文件夹下添加所有依赖项，如此屏幕截图所示：
- en: '![](assets/a27dbcd1-b21b-474b-9b5a-0f19338af727.png)Dependencies under the
    `node_modules` folder.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/a27dbcd1-b21b-474b-9b5a-0f19338af727.png)`node_modules`文件夹下的依赖项。'
- en: 'Now, let''s run this application. To run it, execute the following command
    in the command window:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行这个应用程序。要运行它，在命令窗口中执行以下命令：
- en: '[PRE76]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Running this command builds the application, starts the lite server, and hosts
    the application onto it.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将构建应用程序，启动lite服务器，并将应用程序托管到其中。
- en: 'Open any browser and navigate to `http://localhost:3000/`; and you will get
    the following page displayed, which is rendered through our Angular application:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 打开任何浏览器，导航到`http://localhost:3000/`；您将看到以下页面显示，这是通过我们的Angular应用程序呈现的：
- en: '![](assets/6bd1dcf5-d898-42c8-a473-4f0ac641b844.png)Activating the debug window
    in Visual Studio Code.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/6bd1dcf5-d898-42c8-a473-4f0ac641b844.png)在Visual Studio Code中激活调试窗口。'
- en: 'Let''s now walk through the content of `index.html`. Here is the content of
    `index.html`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们浏览`index.html`的内容。以下是`index.html`的内容：
- en: '[PRE77]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Notice that scripts are loaded using `System.js`. `System.js` is the module
    loader that loads modules during runtime.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，脚本是使用`System.js`加载的。`System.js`是在运行时加载模块的模块加载器。
- en: Voila! Finally, our first Angular app is up-and-running. So far, we have seen
    how to create an Angular application by cloning the official quickstart repository
    from GitHub. We ran the application and saw it in the browser successfully.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！终于，我们的第一个Angular应用程序已经启动运行。到目前为止，我们已经看到了如何通过从GitHub克隆官方快速启动存储库来创建Angular应用程序。我们运行了应用程序，并成功在浏览器中看到了它。
- en: Summary
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Wow! This has been a great introduction, hasn't it? We started by learning about
    Angular's architecture. We discussed various artifacts of Angular's architecture.
    Then we dived into the basics of TypeScript. We have seen basic types with examples.
    We have also learned about writing classes, using interfaces, and implementing
    them in classes. We have also learned about inheritance.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这是一个很棒的介绍，不是吗？我们从学习Angular的架构开始。我们讨论了Angular架构的各种构件。然后我们深入了解了TypeScript的基础知识。我们已经看到了一些基本类型和示例。我们还学习了如何编写类，使用接口，并在类中实现它们。我们还学习了继承。
- en: We have learned about structuring our code by using modules and namespaces.
    We have also covered some advanced topics of TypeScript such as modifiers, accessors,
    static properties, generics, and decorators
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了通过使用模块和命名空间来构建我们的代码。我们还涵盖了一些TypeScript的高级主题，如修饰符、访问器、静态属性、泛型和装饰器。
- en: And finally, we created a simple application using Angular and TypeScript. This
    chapter has equipped you with what you need to develop Angular applications using
    TypeScript with the syntactic sugar it has provided.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用Angular和TypeScript创建了一个简单的应用程序。本章为您提供了使用TypeScript开发Angular应用程序所需的知识，使用了它提供的语法糖。
- en: In the next chapter, we will discuss migrating AngularJS apps to Angular.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论将AngularJS应用迁移到Angular。
