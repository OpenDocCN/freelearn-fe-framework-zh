- en: '*Chapter 2*: Exploring Different Rendering Strategies'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：探索不同的渲染策略'
- en: When talking about rendering strategies, we refer to how we serve a web page
    (or a web application) to a web browser. There are frameworks, such as Gatsby
    (as seen in the previous chapter), that are incredibly good at serving statically
    generated pages. Other frameworks will make it easy to create server-side rendered
    pages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到渲染策略时，我们指的是我们如何向网络浏览器提供网页（或网络应用程序）。有一些框架，如Gatsby（如前一章所示），在提供静态生成的页面方面非常好。其他框架将使创建服务器端渲染的页面变得容易。
- en: But Next.js brings those concepts to a whole new level, letting you decide which
    page should be rendered at build time and which should be served dynamically at
    runtime, regenerating the entire page for each request making certain parts of
    your applications incredibly dynamic. The framework also allows you to decide
    which components should exclusively be rendered on the client side, making your
    development experience extremely satisfying.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但Next.js将这些概念提升到了全新的水平，让你决定哪些页面应该在构建时渲染，哪些应该在运行时动态提供，为每个请求重新生成整个页面，使应用程序的某些部分变得极其动态。该框架还允许你决定哪些组件应该仅客户端渲染，使你的开发体验非常满意。
- en: 'In this chapter, we''ll have a closer look at:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地了解：
- en: How to dynamically render a page for each request using server-side rendering
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用服务器端渲染为每个请求动态渲染页面
- en: Different ways to render certain components on the client side only
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端仅渲染某些组件的不同方式
- en: Generating static pages at build time
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建时生成静态页面
- en: How to regenerate static pages in production using incremental static regeneration
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用增量静态重新生成在生产中重新生成静态页面
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To run the code examples in this chapter, make sure you have Node.js and `npm`
    installed on your machine. As an alternative, you can use an online IDE such as
    [https://repl.it](https://repl.it) or [https://codesandbox.io](https://codesandbox.io).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码示例，请确保你的机器上已安装Node.js和`npm`。作为替代方案，你可以使用在线IDE，如[https://repl.it](https://repl.it)或[https://codesandbox.io](https://codesandbox.io)。
- en: 'You can find the code for this chapter in the GitHub repository: [https://github.com/PacktPublishing/Real-World-Next.js](https://github.com/PacktPublishing/Real-World-Next.js).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub仓库中找到本章的代码：[https://github.com/PacktPublishing/Real-World-Next.js](https://github.com/PacktPublishing/Real-World-Next.js)。
- en: Server-side rendering (SSR)
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端渲染（SSR）
- en: Even though **server-side rendering** (**SSR**) sounds like a new term in the
    developer's vocabulary, it is actually the most common way for serving web pages.
    If you think of languages such as PHP, Ruby, or Python, they all render the HTML
    on the server before sending it to the browser, which will make the markup dynamic
    once all the JavaScript contents have been loaded.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 即使**服务器端渲染**（**SSR**）在开发者的词汇中听起来像是一个新术语，但实际上它是提供网页最常见的方式。如果你想到PHP、Ruby或Python这样的语言，它们都会在发送到浏览器之前在服务器上渲染HTML，一旦所有JavaScript内容都加载完毕，这将使标记动态化。
- en: Well, Next.js does the same thing by dynamically rendering an HTML page on the
    server for each request, then sending it to the web browser. The framework will
    also inject its own scripts to make the server-side rendered pages dynamic in
    a process called **hydration**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，Next.js通过在每个请求上动态在服务器上渲染一个HTML页面，然后将其发送到网络浏览器来做同样的事情。该框架还会注入它自己的脚本，通过一个称为**激活**的过程使服务器端渲染的页面动态化。
- en: 'Imagine you''re building a blog and you want to display all the articles written
    by a specific author on a single page. This can be a great use case for SSR: a
    user wants to access this page, so the server renders it and sends the resulting
    HTML to the client. At this point, the browser will download all the scripts requested
    by the page and hydrate the DOM, making it interactive without any kind of page
    refresh or glitch (you can read more about React hydration at [https://reactjs.org/docs/react-dom.html#hydrate](https://reactjs.org/docs/react-dom.html#hydrate)).
    From this point, thanks to React hydration, the web app can also become a **single-page
    application** (**SPA**), taking all the advantages of both **client-side rendering**
    (**CSR**) (as we''ll see in the next section) and SSR.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在构建一个博客，你希望在单个页面上显示特定作者撰写的所有文章。这可以是一个很好的SSR用例：用户想要访问这个页面，所以服务器渲染它，并将生成的HTML发送到客户端。在这个时候，浏览器将下载页面请求的所有脚本，并使DOM活跃，使其在没有页面刷新或故障的情况下交互（你可以在[https://reactjs.org/docs/react-dom.html#hydrate](https://reactjs.org/docs/react-dom.html#hydrate)上了解更多关于React
    hydration的信息）。从这一点开始，多亏了React hydration，Web应用也可以成为一个**单页应用**（**SPA**），同时拥有**客户端渲染**（**CSR**）（我们将在下一节中看到）和SSR的所有优势。
- en: 'Talking about the advantages of adopting a specific rendering strategy, SSR
    provides multiple benefits over the standard React CSR:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到采用特定渲染策略的优势，SSR相对于标准的React CSR提供了多个好处：
- en: '**More secure web apps**: Rendering a page on the server side means that activities
    such as managing cookies, calling private APIs, and data validation happen on
    the server, so we will never expose private data to the client.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更安全的Web应用**：在服务器端渲染页面意味着诸如管理cookies、调用私有API和数据验证等活动都在服务器上发生，因此我们永远不会将私有数据暴露给客户端。'
- en: '**More compatible websites**: The website will be available even if the user
    has disabled JavaScript or uses an older browser.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更兼容的网站**：即使用户禁用了JavaScript或使用较旧的浏览器，网站也将可用。'
- en: '**Enhanced search engine optimization**: Since the client will receive the
    HTML content as soon as the server renders and sends it, the search engine spiders
    (bots that crawl the web pages) will not need to wait for the page to be rendered
    on the client side. This will improve your web app''s SEO score.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强搜索引擎优化**：由于客户端将在服务器渲染并发送HTML内容后立即接收，搜索引擎蜘蛛（爬取网页的机器人）将不需要等待页面在客户端渲染。这将提高你的Web应用的SEO评分。'
- en: Despite those great advantages, there are times where SSR might not be the best
    solution for your website. In fact, with SSR, you will need to deploy your web
    application to a server that will re-render a page as soon as it's required. As
    we'll see later, with both CSR and **static site generation** (**SSG**), you can
    deploy static HTML files to any cloud provider, such as Vercel or Netlify, for
    free (or at a meager cost); if you're already deploying your web app using a custom
    server, you have to remember that an SSR app will always lead to a more significant
    server workload and maintenance costs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这些巨大的优势，但在某些情况下，SSR可能不是你网站的最佳解决方案。事实上，使用SSR，你需要将你的Web应用部署到服务器，该服务器将在需要时重新渲染页面。正如我们稍后看到的，使用CSR和**静态站点生成**（**SSG**），你可以免费（或以微小的成本）将静态HTML文件部署到任何云服务提供商，如Vercel或Netlify；如果你已经使用自定义服务器部署你的Web应用，你必须记住，SSR应用将始终导致更大的服务器工作负载和维护成本。
- en: Another thing to keep in mind when you want to server-side render your pages
    is that you're adding some latency to each request; your pages might need to call
    some external API or data source, and they'll call it for every page render. Navigating
    between server-side rendered pages will always be a bit slower than navigating
    between client-side rendered or statically served pages.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要在服务器端渲染你的页面时，还有一点需要记住，那就是你为每个请求增加了一些延迟；你的页面可能需要调用一些外部API或数据源，并且它们会在每次页面渲染时调用。在服务器端渲染的页面之间导航总是会比在客户端渲染或静态服务页面之间导航慢一些。
- en: Of course, Next.js provides some great features for improving navigation performances,
    as we'll see in [*Chapter 3*](B16985_03_Final_SB_epub.xhtml#_idTextAnchor038),
    *Next.js Basics and Built-In Components*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Next.js提供了一些很棒的功能来提高导航性能，正如我们将在[*第3章*](B16985_03_Final_SB_epub.xhtml#_idTextAnchor038)，“Next.js基础和内置组件”中看到的。
- en: 'Another thing to consider is that by default, a Next.js page is statically
    generated at build time. If we want to make it more dynamic by calling an external
    API, a database, or other data sources, we will need to export a particular function
    from our page:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件需要考虑的事情是，默认情况下，Next.js 页面在构建时是静态生成的。如果我们想通过调用外部 API、数据库或其他数据源来使其更具动态性，我们需要从我们的页面导出特定的函数：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, the page only prints the `div`. It doesn''t need to call external
    APIs or any other data source to work, and its content will always be the same
    for each request. But now, let''s pretend that we want to greet the user on every
    request; we will need to call a REST API on the server to get some specific user
    information and pass the result to the client using the Next.js flow. We will
    do that by using the reserved `getServerSideProps` function:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，页面只打印了 `div`。它不需要调用外部 API 或其他任何数据源来工作，并且其内容对于每个请求都是相同的。但现在，让我们假设我们想在每个请求上问候用户；我们需要在服务器上调用一个
    REST API 来获取一些特定的用户信息，并使用 Next.js 流将其结果传递给客户端。我们将通过使用保留的 `getServerSideProps`
    函数来完成这项工作：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding example, we used the Next.js reserved `getServerSideProps`
    function for making a REST API call on the server side for each request. Let''s
    break it down into small steps so that we can better understand what we''re doing:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了 Next.js 保留的 `getServerSideProps` 函数，在每个请求的服务器端进行 REST API 调用。让我们将其分解成小步骤，以便我们更好地理解我们在做什么：
- en: We start by exporting an async function called `getServerSideProps`. During
    the build phase, Next.js will look for every page exporting this function and
    make them dynamically server-side rendered for each request. All the code written
    within this function scope will always be executed on the server side.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先导出一个名为 `getServerSideProps` 的异步函数。在构建阶段，Next.js 会查找每个导出此函数的页面，并使它们针对每个请求进行动态服务器端渲染。在这个函数作用域内编写的所有代码都将始终在服务器端执行。
- en: Inside the `getServerSideProps` function, we return an object containing a property
    called `props`. This is required because Next.js will inject those props inside
    our `page` component, making them available both on the client and server side.
    In case you're wondering, we don't need to polyfill the fetch API when we use
    it on the server side, as Next.js already does that for us.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `getServerSideProps` 函数内部，我们返回一个包含名为 `props` 的属性的对象。这是必需的，因为 Next.js 会将这些属性注入到我们的
    `page` 组件中，使它们在客户端和服务器端都可用。如果你想知道，当我们使用它时，我们不需要 polyfill fetch API，因为 Next.js
    已经为我们做了这件事。
- en: We then refactor the `IndexPage` function, which now accepts a `props` parameter
    containing all the props passed from the `getServerSideProps` function.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们重构了 `IndexPage` 函数，现在它接受一个 `props` 参数，包含从 `getServerSideProps` 函数传递的所有属性。
- en: And that's all! After we ship this code, Next.js will always dynamically render
    our `IndexPage` on the server, calling an external API and showing different results
    as soon as we make changes in our data source.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！在我们发布这段代码后，Next.js 将始终在服务器上动态渲染我们的 `IndexPage`，调用外部 API，并在我们更改数据源时立即显示不同的结果。
- en: As seen at the beginning of this section, SSR provides some significant advantages
    but has some caveats. If you want to use any component that relies on browser-specific
    APIs, you will need to render it on the browser explicitly because, by default,
    Next.js renders the entire page content on the server, which does not expose certain
    APIs, such as `window` or `document`. So here comes the concept of CSR.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节开头所见，SSR 提供了一些显著的优势，但也存在一些注意事项。如果你想使用任何依赖于浏览器特定 API 的组件，你将需要显式地在浏览器上渲染它，因为默认情况下，Next.js
    在服务器上渲染整个页面内容，这不会暴露某些 API，如 `window` 或 `document`。因此，出现了 CSR 的概念。
- en: Client-side rendering (CSR)
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端渲染（CSR）
- en: As seen in the previous chapter, a standard React app is rendered once the JavaScript
    bundle has been transferred from the server to the client.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所见，一个标准的 React 应用在 JavaScript 包从服务器传输到客户端后才会渲染。
- en: 'If you''re familiar with **create-react-app** (**CRA**), you may have noticed
    that right before the web app renders, the whole web page is entirely white. That''s
    because the server only serves a very basic HTML markup, which contains all the
    required scripts and styles to make our web app dynamic. Let''s take a closer
    look at that HTML generated by CRA:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 **create-react-app**（**CRA**），你可能已经注意到在网页渲染之前，整个网页都是完全白色的。这是因为服务器只提供了一个非常基本的
    HTML 标记，其中包含所有必要的脚本和样式，使我们的网页动态化。让我们更仔细地看看 CRA 生成的那个 HTML：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, we can only find one `div` inside the `body` tag: `<div id="root"></div>`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们只能在`body`标签内找到一个`div`：`<div id="root"></div>`。
- en: During the build phase, `create-react-app` will inject the compiled JavaScript
    and CSS files into this HTML page and use the `root` div as a target container
    for rendering the whole application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建阶段，`create-react-app`会将编译后的JavaScript和CSS文件注入到这个HTML页面中，并使用`root` div作为渲染整个应用的目标容器。
- en: That means that once we publish this page to any hosting provider (Vercel, Netlify,
    Google Cloud, AWS, and so on), the first time we call the desired URL, our browser
    will first render the preceding HTML. Then, following the `script` and `link`
    tags contained in the preceding markup (injected by CRA at build time), the browser
    will render the whole application, making it available for any sort of interaction.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一旦我们将这个页面发布到任何托管提供商（Vercel、Netlify、Google Cloud、AWS等），第一次调用所需的URL时，我们的浏览器将首先渲染前面的HTML。然后，根据前面标记（在构建时由CRA注入）中的`script`和`link`标签，浏览器将渲染整个应用，使其可用于任何类型的交互。
- en: 'The main advantages of CSR are:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: CSR的主要优势是：
- en: '**It makes your app feel like a native app**: Downloading the whole JavaScript
    bundle means that you already have every page of your web app downloaded in your
    browser. If you want to navigate to a different page, it will swap the page content
    instead of downloading new content from the server. You don''t need to refresh
    the page to update its content.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**让你的应用感觉像原生应用**：下载整个JavaScript包意味着你已经在浏览器中下载了你的Web应用的每一页。如果你想导航到不同的页面，它会交换页面内容而不是从服务器下载新内容。你不需要刷新页面来更新其内容。'
- en: '**Page transitions made easy**: Client-side navigation allows us to switch
    from one page to another without reloading the browser window. This comes in handy
    when you want to show some cool transitions between pages with ease because you
    don''t have any reload that might interrupt your animations.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**页面过渡变得简单**：客户端导航允许我们在不重新加载浏览器窗口的情况下从一个页面切换到另一个页面。当你想轻松地展示页面间的酷炫过渡效果时，这非常有用，因为你没有任何重新加载可能会打断你的动画。'
- en: '**Lazy loading and performances**: With CSR, the browser will only render the
    minimum HTML markup required for the web app to work. If you have a modal that
    appears once the user clicks on a button, its HTML markup is not present on the
    HTML page. It will be created dynamically by React once the button click event
    occurs.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**懒加载和性能**：使用CSR，浏览器将只渲染Web应用工作所需的最低HTML标记。如果你有一个在用户点击按钮后出现的模态框，其HTML标记不会出现在HTML页面上。它将在按钮点击事件发生时由React动态创建。'
- en: '**Less server-side workload**: Given that the whole rendering phase is delegated
    to the browser, the server only needs to send a very basic HTML page to the client.
    You then don''t need a very powerful server; indeed, there are cases where you
    can host your web app on **serverless** environments, such as AWS Lambda, Firebase,
    and so on.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少服务器端工作量**：由于整个渲染阶段都委托给了浏览器，服务器只需要向客户端发送一个非常基本的HTML页面。因此，你不需要一个非常强大的服务器；实际上，有些情况下你可以在无服务器环境中托管你的Web应用，例如AWS
    Lambda、Firebase等。'
- en: But all those benefits come at a cost. As we've previously seen, the server
    only sends an empty HTML page. If the user's internet connection is slow, the
    downloading of JavaScript and CSS files will take some seconds to complete, leaving
    the user waiting with an empty screen for several moments.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但所有这些好处都是要付出代价的。正如我们之前看到的，服务器只发送一个空的HTML页面。如果用户的互联网连接速度慢，JavaScript和CSS文件的下载将需要几秒钟才能完成，让用户在空屏幕上等待几秒钟。
- en: This will also affect your web app SEO score; the search engine spiders will
    reach your page and will find it empty. Google bots, for instance, will wait for
    the JavaScript bundle to be transferred but will assign a low-performance score
    to your website because of their waiting time.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这也会影响你的Web应用SEO评分；搜索引擎蜘蛛会到达你的页面，并发现它是空的。例如，谷歌机器人将等待JavaScript包被传输，但由于他们的等待时间，将给你的网站分配一个低性能评分。
- en: By default, Next.js renders all the React components inside a given page on
    the server side (as seen in the previous section) or at build time. In the first
    chapter, under the Moving from React to *Next.js* section, we saw that the Node.js
    runtime doesn't expose some browser-specific APIs, such as `window` or `document`,
    or HTML elements, such as `canvas`, so if you try to render any component that
    needs access to those APIs, the rendering process will crash.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: There are many different ways to avoid those kinds of problems with Next.js,
    demanding the rendering of specific components to the browser.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Using the React.useEffect hook
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you're coming from a React version before 16.8.0, you may be used to the
    `componentDidMount` method of the `React.Component` class. With more modern versions
    of React, which emphasize the usage of `React.useEffect` hook. It will let you
    perform side effects (such as data fetching and manual DOM changes) inside your
    function components, and it will do it after the component has been mounted. That
    means that with Next.js, the `useEffect` callback will run on the browser after
    React hydration, letting you perform certain actions only on the client side.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s pretend that we want to display a code snippet on a web
    page using the Highlight.js library, making it easy to highlight and make code
    more readable. We could just create a component called `Highlight`, which would
    look as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While this piece of code would perfectly run on a client-side React app, it
    will crash during the rendering or build phase on Next.js because Highlight.js
    needs the `document` global variable, which does not exist in Node.js, as it's
    exposed by browsers only.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily fix this by wrapping all the `hljs` calls in the `useEffect`
    hook:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That way, Next.js will render the HTML markup returned by our component, inject
    the Highlight.js script into our page, and, once the component is mounted on the
    browser, it will call the library functions on the client side.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use that exact approach for rendering a component exclusively
    on the client side by using both `React.useEffect` and `React.useState` together:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That way, the `Highlight` component will be rendered on the browser exclusively.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Using the process.browser variable
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way of avoiding the server-side process crashing when using browser-specific
    APIs is to conditionally execute scripts and components depending on the `process.browser`
    global variable. Indeed, Next.js appends this incredibly useful property to Node.js''
    `process` object. It is a Boolean value set to `true` when the code runs on the
    client side and `false` when running on the server. Let''s see how it works:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you try to run the preceding example, you will notice that for a brief moment,
    the browser will show the following text: **You''re currently running on the server-side**;
    it will be replaced by the **You''re currently running on the client-side** text
    as soon as React hydration occurs.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Using dynamic component loading
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用动态组件加载
- en: As we saw in the first chapter, Next.js extends React functionalities by adding
    some great built-in components and utility functions. One of these is called `dynamic`,
    and it's one of the most interesting modules provided by the framework.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第一章中看到的，Next.js通过添加一些优秀的内置组件和实用函数来扩展React的功能。其中之一被称为`dynamic`，这是框架提供的最有趣的模块之一。
- en: 'Remember the Highlight.js component that we built to understand how to render
    a component on the browser using the `React.useEffect` hook? Here is another way
    to render it using the Next.js `dynamic` function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们构建的Highlight.js组件，以了解如何使用`React.useEffect`钩子在浏览器上渲染组件吗？这里还有另一种使用Next.js的`dynamic`函数来渲染它的方法：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With the preceding code, we''re importing our `Highlight` component via `ssr:
    false` option. That way, Next.js won''t try to render that component on the server
    and we''ll have to wait for React hydration to make it available on the browser.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码中，我们通过`ssr: false`选项导入我们的`Highlight`组件。这样，Next.js就不会尝试在服务器上渲染该组件，我们则需要等待React激活过程使其在浏览器上可用。'
- en: CSR can be a fantastic alternative to SSR for building very dynamic web pages.
    If you're working on a page that doesn't need to be indexed by search engines,
    it could make sense to first load your application's JavaScript, and then, from
    the client side, fetch any necessary data from the server; this would lighten
    the server-side workload since this approach does not involve SSR and your application
    could scale better.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: CSR（客户端渲染）可以是构建非常动态的Web页面的SSR（服务器端渲染）的一个绝佳替代方案。如果你正在处理一个不需要被搜索引擎索引的页面，那么首先加载应用程序的JavaScript，然后从客户端获取任何必要的数据，这可能是有意义的；这种方法可以减轻服务器端的工作负载，因为这种方法不涉及SSR，并且你的应用程序可以更好地扩展。
- en: So, here's a question – if we need to build a dynamic page and SEO is not really
    important (admin pages, private profile pages, and so on), why don't we just send
    a static page to the client and load all the data once the page has been transferred
    to the browser? We'll explore this possibility in the next section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里有一个问题——如果我们需要构建一个动态页面，而SEO（搜索引擎优化）并不是特别重要（例如管理页面、私有个人资料页面等），为什么我们不直接向客户端发送一个静态页面，并在页面传输到浏览器后一次性加载所有数据呢？我们将在下一节探讨这种可能性。
- en: Static site generation
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态站点生成
- en: 'So far, we''ve seen two different ways of rendering our web apps: on the client
    side and server side. Next.js gives us a third option called **static site generation**
    (**SSG**).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了两种渲染我们的Web应用的不同方式：客户端和服务器端。Next.js为我们提供了一个名为**静态站点生成**（**SSG**）的第三种选择。
- en: With SSG, we will be able to pre-render some specific pages (or even the whole
    website if necessary) at build time; that means that when we're building our web
    app, there might be some pages that won't change their content very often, so
    it makes sense for us to serve them as static assets. Next.js will render these
    pages during the build phase and will always serve that specific HTML that, just
    like SSR, will become interactive thanks to the React hydration process.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SSG（静态站点生成），我们将在构建时能够预渲染一些特定的页面（如果需要，甚至整个网站）；这意味着在我们构建我们的Web应用时，可能会有一些页面内容不会经常改变，因此将它们作为静态资源提供服务是有意义的。Next.js将在构建阶段渲染这些页面，并且始终提供那个特定的HTML，就像SSR一样，将得益于React的激活过程而变得交互式。
- en: 'SSG brings a lot of advantages when compared to both CSR and SSR:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与CSR（客户端渲染）和SSR（服务器端渲染）相比，SSG带来了许多优势：
- en: '**Easy to scale**: Static pages are just HTML files that can be served and
    cached easily by any **content delivery network** (from now on, **CDN**). But
    even if you want to serve them using your own web server, it will result in a
    very low workload, given that no hard computations are needed for serving a static
    asset.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于扩展**：静态页面只是可以被任何内容分发网络（以下简称**CDN**）轻松提供和缓存的HTML文件。但即使你想使用自己的Web服务器来提供服务，由于不需要为提供静态资源进行复杂计算，这也会导致非常低的工作负载。'
- en: '**Outstanding performances**: As said before, the HTML is pre-rendered at build
    time, so both the client and server can bypass the runtime rendering phase for
    each request. The web server will send the static file and the browser will just
    display it, as easy as that. No data fetching is required on the server side;
    everything we need is already pre-rendered inside the static HTML markup, and
    that reduces the potential latency for each request.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卓越的性能**：正如之前所说，HTML是在构建时预渲染的，因此客户端和服务器都可以绕过每个请求的运行时渲染阶段。Web服务器将发送静态文件，浏览器只需显示它，就这么简单。服务器端不需要进行数据获取；我们需要的所有内容都已经预渲染在静态HTML标记中，这减少了每个请求的潜在延迟。'
- en: '**More secure requests**: We don''t need to send any sensitive data to the
    web server for rendering the page, and that makes life a bit harder for malicious
    users. No access to APIs, databases, or other private information is required
    because every piece of information needed is already part of the pre-rendered
    page.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更安全的请求**：我们不需要向Web服务器发送任何敏感数据来渲染页面，这使得恶意用户的生活变得有些困难。不需要访问API、数据库或其他私人信息，因为所需的所有信息都已经包含在预渲染的页面中。'
- en: SSG is probably one of the best solutions for building performant and highly
    scalable frontend applications. The biggest concern about this rendering technique
    is that once the page has been built, the content will remain the same until the
    next deployment.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: SSG可能是构建高性能和高度可扩展的前端应用的最佳解决方案之一。关于这种渲染技术的最大担忧是，一旦页面构建完成，内容将保持不变，直到下一次部署。
- en: 'For instance, let''s pretend that we''re writing a blog post and we misspell
    a word in the title. Using other static site generators, such as Gatsby or Jekyll,
    we would need to rebuild the whole website to change just a word in a blog post
    title because we would need to repeat the data fetching and rendering phase at
    build time. Remember what we said at the beginning of this section: statically
    generated pages are created at build time and served as static assets for each
    request.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们正在撰写一篇博客文章，但在标题中拼写了一个单词。使用其他静态站点生成器，如Gatsby或Jekyll，我们需要重建整个网站来更改博客文章标题中的一个单词，因为我们需要在构建时重复数据获取和渲染阶段。记住我们在本节开头所说的话：静态生成的页面是在构建时创建的，并且作为每个请求的静态资源提供。
- en: 'While this is true for other static site generators, Next.js provides a unique
    approach for solving this problem: **incremental static regeneration** (**ISR**).
    Thanks to ISR, we can specify at the page level how long Next.js should wait before
    re-rendering a static page updating its content.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这对于其他静态站点生成器也是正确的，但Next.js提供了一种独特的解决方案来解决这个问题：**增量静态再生**（**ISR**）。得益于ISR，我们可以在页面级别指定Next.js在重新渲染更新内容的静态页面之前应该等待多长时间。
- en: For instance, let's say that we want to build a page showing some dynamic content,
    but the data fetching phase, for some reason, takes too long to succeed. This
    would lead to bad performance, giving our users a terrible user experience. A
    combination of SSG and ISR would solve this problem by taking a hybrid approach
    between SSR and SSG.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要构建一个显示一些动态内容的页面，但由于某种原因，数据获取阶段需要太长时间才能成功。这将导致性能不佳，给我们的用户带来糟糕的用户体验。SSG和ISR的组合通过采用SSR和SSG之间的混合方法来解决这个问题。
- en: 'Let''s pretend we''ve built a very complex dashboard that can handle a lot
    of data… but the REST API request for this data is taking up to a few seconds
    to succeed. In that case, we are lucky because that data won''t change a lot during
    this time, so we can **cache** it for up to 10 minutes (600 seconds) using SSG
    and ISR:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们已经构建了一个非常复杂的仪表板，它可以处理大量数据……但获取这些数据的REST API请求可能需要几秒钟才能成功。在这种情况下，我们很幸运，因为在这段时间内，这些数据不会变化太多，所以我们可以使用SSG和ISR将其**缓存**长达10分钟（600秒）：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''re now using a function called `getStaticProps`, which looks similar to
    the `getServerSideProps` one that we saw in the previous section. As you may have
    guessed, `getStaticProps` is used at build time by Next.js for getting the data
    and rendering the page, and it won''t be called again until the next build. As
    said before, while this can be incredibly powerful, it comes with a cost: if we
    want to update the page content, we have to rebuild the entire website.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用一个名为`getStaticProps`的函数，它看起来与我们在上一节中看到的`getServerSideProps`函数相似。正如你可能已经猜到的，`getStaticProps`由Next.js在构建时用于获取数据和渲染页面，并且直到下一次构建之前不会再次调用。正如之前所说，虽然这可以非常强大，但它也有代价：如果我们想更新页面内容，我们必须重建整个网站。
- en: To avoid the whole website rebuild, Next.js recently introduced an option called
    `revalidate`, which can be set inside the returning object of our `getStaticProps`
    function. It indicates after how many seconds we should rebuild the page once
    a new request arrives.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免整个网站重建，Next.js最近引入了一个名为`revalidate`的选项，它可以在我们的`getStaticProps`函数的返回对象中设置。它表示在收到新请求后，我们应该过多少秒重建页面。
- en: 'In the preceding code, we''ve set our `revalidate` option to `600` seconds,
    so Next.js will behave as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将我们的`revalidate`选项设置为`600`秒，因此Next.js将如下行为：
- en: Next.js fills the page with the results of `getStaticProps` at build time, statically
    generating the page during the build process.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Next.js在构建时使用`getStaticProps`的结果填充页面，在构建过程中静态生成页面。
- en: In the first 10 minutes, every user will access the exact same static page.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最初的10分钟内，每位用户都将访问完全相同的静态页面。
- en: After 10 minutes, if a new request occurs, Next.js will server-side render that
    page, re-execute the `getStaticProps` function, save and cache the newly rendered
    page as a static asset, overriding the previous one created at build time.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 10分钟后，如果发生新的请求，Next.js将在服务器端渲染该页面，重新执行`getStaticProps`函数，保存并缓存新渲染的页面作为静态资产，覆盖在构建时创建的先前的页面。
- en: Every new request, within the next 10 minutes, will be served with that new
    statically generated page.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来的10分钟内，每个新的请求都将使用那个新静态生成的页面进行服务。
- en: '*Remember that the ISR process is lazy, so if no requests occur after 10 minutes,
    Next.js won''t rebuild its pages.*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*请记住，ISR过程是懒惰的，所以如果10分钟后没有发生任何请求，Next.js不会重建其页面。*'
- en: In case you're wondering, at the moment there's no way of forcing ISR revalidation
    via the API; once your website has been deployed, you'll have to wait the length
    of the expiration time set in the `revalidate` option for the page to be rebuilt.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有所疑问，目前还没有通过API强制ISR重新验证的方法；一旦你的网站已经部署，你必须等待在`revalidate`选项中设置的过期时间长度，页面才能重建。
- en: Static-site generation is a great way to create fast and secure web pages, but
    sometimes we might want to have more dynamic content. Thanks to Next.js, we can
    always decide which page should be rendered at build time (SSG) or request time
    (SSR). We can take the best of both approaches by using SSG + ISR, making our
    pages a "hybrid" between SSR and SSG, and that's a game-changer for modern web
    development.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 静态站点生成是一种创建快速和安全的网页的绝佳方式，但有时我们可能想要有更多动态的内容。多亏了Next.js，我们总是可以决定在构建时间（SSG）或请求时间（SSR）渲染哪个页面。通过使用SSG
    + ISR，我们可以取两者之长，使我们的页面成为SSR和SSG之间的“混合”体，这对现代Web开发来说是一个变革性的突破。
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've seen three different rendering strategies and why Next.js
    brings them to a whole new level with its hybrid rendering approach. We've also
    seen the benefits of these strategies, when we want to use them, and how they
    can affect the user experience or the server workload. We will always keep an
    eye on these rendering methodologies during the following chapters, adding more
    and more examples and use cases for each of them. They are the core concepts behind
    the choice of using Next.js as a framework.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了三种不同的渲染策略，以及Next.js如何通过其混合渲染方法将它们提升到全新的水平。我们还看到了这些策略的好处，当我们想要使用它们时，以及它们如何影响用户体验或服务器负载。在接下来的章节中，我们将始终关注这些渲染方法，为每个方法添加越来越多的示例和用例。它们是选择使用Next.js作为框架背后的核心概念。
- en: In the next chapter, we're going to have a closer look at some of the most useful
    built-in Next.js components, its routing system, and how to manage metadata dynamically
    for improving both SEO and user experience.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地探讨一些最有用的内置Next.js组件，其路由系统，以及如何动态管理元数据以改善SEO和用户体验。
