- en: '@ngrx/store + @ngrx/effects for State Management'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@ngrx/store + @ngrx/effects用于状态管理'
- en: Managing state in any app can become troubling as the app scales over time.
    We want to have full confidence over the predictability of our app's behavior
    and getting a hang of its state is key to gaining that confidence.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序随着时间的推移而扩展，管理任何应用程序中的状态可能会变得麻烦。我们希望对应用程序行为的可预测性有充分的信心，并且掌握其状态是获得这种信心的关键。
- en: State can be broadly defined as the particular condition that someone or something
    is in at a specific time. With regard to our app, the state can encompass whether
    our player is playing or not, whether the recorder is recording or not, and whether
    the track list UI is in mixing mode or not.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 状态可以广义地定义为某人或某物在特定时间的特定状态。就我们的应用程序而言，状态可以包括我们的播放器是否正在播放，录音机是否正在录音，以及曲目列表UI是否处于混音模式。
- en: Storing state in a single spot allows you to know exactly what the state of
    the app is at any given moment. Without a single store, you usually wind up with
    state buried throughout different components and services, which often leads to
    two or more different versions of state as features are built out. This unwieldy
    growth of state becomes even more troublesome as different features need to interact
    with each other, which may or may not necessarily depend on each other.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 将状态存储在一个地方可以让您在任何给定时刻准确知道应用程序的状态。没有单一的存储，通常会导致状态分散在不同的组件和服务中，这往往会导致随着功能的构建而产生两个或更多不同版本的状态。随着不同的功能需要相互交互，这种笨重的状态增长变得更加麻烦，这些功能可能或可能不一定依赖于彼此。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding what Redux is
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Redux是什么
- en: Understanding what ngrx is and how it relates to Redux
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解ngrx是什么以及它与Redux的关系
- en: Defining state for an app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为应用程序定义状态
- en: Integrating @ngrx/store to manage state
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成@ngrx/store来管理状态
- en: Understanding what @ngrx/effects are
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解@ngrx/effects是什么
- en: Integrating side effects to aid our state management
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成副作用以帮助我们的状态管理
- en: Going from *inactive to reactive* with our code base (Mike Ryan/Brandon Roberts^(TM))
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从*不活跃到*响应式*的代码库（Mike Ryan/Brandon Roberts^(TM)）
- en: Understanding Redux and integrating @ngrx/store
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Redux并集成@ngrx/store
- en: Redux is an open source library that defines itself as a predictable state container
    for JavaScript apps. The concepts are not exactly new, but the details were developed
    by Dan Abramov in 2015 who was influenced by Facebook's Flux and the functional
    programming language, Elm. It quickly gained popularity among the React community
    as it was used throughout Facebook.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Redux是一个开源库，它将自己定义为JavaScript应用程序的可预测状态容器。这些概念并不是全新的，但细节是由Dan Abramov在2015年开发的，他受到了Facebook的Flux和函数式编程语言Elm的影响。它很快在React社区中变得流行，因为它在Facebook中被广泛使用。
- en: 'We don''t want to redefine what Redux is, so we will quote directly from the
    Redux repo ([https://github.com/reactjs/redux](https://github.com/reactjs/redux)):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想重新定义Redux是什么，所以我们将直接引用Redux仓库（[https://github.com/reactjs/redux](https://github.com/reactjs/redux)）中的内容：
- en: The whole state of your app is stored in an object tree inside a single *store*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序的整个状态存储在单个*store*内的对象树中。
- en: The only way to change the state tree is to emit an *action*, an object describing
    what happened.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 改变状态树的唯一方法是发出一个*action*，描述发生了什么。
- en: To specify how the actions transform the state tree, you write pure *reducers*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定操作如何转换状态树，您需要编写纯*reducers*。
- en: That's it!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！
- en: The concept is fairly simple and quite brilliant. You emit actions (which are
    simple string typed objects with a payload representing the data to be passed
    along) against the system, which wind up hitting a reducer (a pure function) to
    define how state is transformed by these actions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念相当简单，而且非常聪明。您对系统发出动作（这些动作是简单的字符串类型对象，带有表示要传递的数据的有效负载），这些动作最终会触发一个减速器（一个纯函数），定义这些动作如何转换状态。
- en: It's important not to confuse transform with mutate. One of the fundamental
    concepts of Redux is that all state is **immutable**; hence, each reducer is a
    **pure** function.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是不要混淆转换和突变。Redux的一个基本概念是所有状态都是**不可变的**；因此，每个减速器都是一个**纯**函数。
- en: A pure function always returns the same results given the same parameters. Its
    execution does not depend on the state of the system as a whole [[https://en.wikipedia.org/wiki/Pure_function](https://en.wikipedia.org/wiki/Pure_function)].
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数在给定相同参数的情况下总是返回相同的结果。它的执行不依赖于系统作为整体的状态[[https://en.wikipedia.org/wiki/Pure_function](https://en.wikipedia.org/wiki/Pure_function)]。
- en: So, although a reducer transforms state, it does not mutate it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管减速器转换状态，但它不会改变状态。
- en: In depth, engineering studies have been done on change detection systems and
    how object equality/reference checks are superior in speed when compared to object
    comparison checks on deeply nested properties. We won't go into detail for the
    reasons for this, but immutability of your app's data flow has significant impact
    on how you can fine-tune its performance, especially with regard to Angular.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 深入的工程研究已经对变更检测系统以及对象相等性/引用检查在速度上的优势进行了研究，与深度嵌套属性的对象比较检查相比。我们不会详细介绍这一点，但是应用程序数据流的不可变性对于您如何调整其性能有重大影响，特别是关于Angular。
- en: Along with performance enhancements, the concepts of Redux further enhance decoupling
    across your entire code base, leading to the reduction of various dependencies
    spread throughout. With the power of actions describing the various interactions
    our app entails, we no longer need to inject explicit service dependencies to
    execute its APIs. Instead, we can simply emit actions and the principles of Redux
    will work for us to propagate and handle the necessary functionality our app demands,
    all the while maintaining a single and dependable source of truth.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了性能增强之外，Redux的概念进一步增强了整个代码库的解耦，从而减少了分散在各处的各种依赖关系。通过描述我们的应用程序涉及的各种交互的动作的力量，我们不再需要注入显式的服务依赖来执行其API。相反，我们可以简单地发出动作，Redux的原则将为我们传播和处理应用程序需求的必要功能，同时保持一个单一可靠的真相来源。
- en: What is @ngrx/store?
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@ngrx/store是什么？'
- en: Early in the rewrite of Angular (from 1.x to 2.x+), a core team member turned
    developer advocate at Google, Rob Wormald, developed **ngrx/store** as an "*RxJS
    powered state management [system] for Angular applications, inspired by Redux."*
    The key point in that phrase is the term "**RxJS"**. Hence the name **ngrx** derives
    its name from joining "**ng"** for A**ng**ular with "**rx"** from **Rx**JS. The
    open source library quickly gained highly-talented contributors such as Mike Ryan,
    Brian Troncone, and Brandon Roberts and took off to become an extremely intelligent
    and powerful state management system for modern Angular applications.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular的重写过程中（从1.x到2.x+），谷歌的核心团队成员、开发者倡导者Rob Wormald开发了**ngrx/store**作为“*由RxJS驱动的Angular应用程序状态管理[系统]，灵感来自于Redux。”*该短语中的关键点是“**RxJS**”一词。因此，**ngrx**的名称来源于将“**ng**”（代表Angular）与“**rx**”（来自**Rx**JS）相结合。这个开源库迅速吸引了像Mike
    Ryan、Brian Troncone和Brandon Roberts这样的高素质贡献者，并成为现代Angular应用程序的极其智能和强大的状态管理系统。
- en: Although it is heavily inspired by Redux and utilizes the same concepts, it
    is uniquely different in making RxJS a first-class citizen in how the system is
    wired. It brings **Observables** full circle throughout all the concepts of Redux,
    enabling truly **reactive** user interfaces and apps.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它受到Redux的重大启发并利用了相同的概念，但它在如何连接系统中使RxJS成为一等公民方面是独特的不同。它将**Observables**完全贯穿于Redux的所有概念中，实现了真正的**响应式**用户界面和应用程序。
- en: 'If all these concepts are new to you, Brian Troncone''s thorough post will
    definitely help you gain more understanding as we won''t be able to cover every
    detail of ngrx here. Please see this post:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些概念对你来说都是新的，Brian Troncone的详细帖子肯定会帮助你更好地理解，因为我们无法在这里涵盖ngrx的每个细节。请参阅此帖子：
- en: '[https://gist.github.com/btroncone/a6e4347326749f938510](https://gist.github.com/btroncone/a6e4347326749f938510)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://gist.github.com/btroncone/a6e4347326749f938510](https://gist.github.com/btroncone/a6e4347326749f938510)'
- en: Designing the state model
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计状态模型
- en: 'Before integrating ngrx, it''s good to first think about the various aspects
    of state throughout your app in addition to which module they might pertain to.
    With our app, here''s a reasonable starter list (*not meant to be complete or
    thorough at this point*):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成ngrx之前，首先要考虑应用程序中状态的各个方面，以及它们可能涉及的模块。对于我们的应用程序，这是一个合理的起始清单（*此时不打算完整或全面*）：
- en: '`CoreModule`:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoreModule`:'
- en: '`user: any;` user-related state:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user: any;` 与用户相关的状态：'
- en: '`recentUsername: string`; most recently used successful username'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recentUsername: string`; 最近使用的成功用户名'
- en: '`current: any`; authenticated user (if there is one)'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current: any`; 已认证的用户（如果有的话）'
- en: '`MixerModule`:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MixerModule`:'
- en: '`mixer: any`: mixer-related state'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mixer: any`: 混音器相关的状态'
- en: '`compositions: Array<IComposition>`; list of user-saved compositions'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compositions: Array<IComposition>`; 用户保存的作曲列表'
- en: '`activeComposition: CompositionModel`; the active composition'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activeComposition: CompositionModel`; 活动的作曲'
- en: '`PlayerModule`:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerModule`:'
- en: '`player: any`; various aspects of player state.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`player: any`; 播放器状态的各个方面。'
- en: '`playing: boolean`; whether audio is playing or not.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playing: boolean`; 音频是否正在播放。'
- en: '`duration: number`; total duration of playback.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`duration: number`; 播放的总持续时间。'
- en: '`completed: boolean`; whether playback reached the end and is completed. This
    will help determine the difference between when the user stops playback or when
    it autostops due to the player reaching the end.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`completed: boolean`; 播放是否达到结尾并已完成。这将有助于区分用户停止播放和播放器因达到结尾而自动停止的区别。'
- en: '`seeking: boolean`; whether playback seeking is in progress.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seeking: boolean`; 是否正在进行播放的搜索。'
- en: '`RecorderModule`:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecorderModule`:'
- en: '`recorder: RecordState`; recording state represented simply by an enum'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recorder: RecordState`; 用枚举简单表示的录音状态'
- en: 'No module in particular, just state we want to observe:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 没有特定的模块，只是我们想要观察的状态：
- en: '`ui: any`; user interface state'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ui: any`; 用户界面状态'
- en: '`trackListViewType: string`; the currently active view toggle for track listing'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trackListViewType: string`; 曲目列表的当前活动视图切换'
- en: The key point here is not to worry about getting this exactly right the first
    time. It's hard to know the precise state model when you first build an app, and
    it will most likely change a bit over time and that's okay.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键点是不要担心第一次就完全正确地得到这一点。在首次构建应用程序时很难知道精确的状态模型，而且它很可能会随着时间的推移而稍微改变，这没关系。
- en: State for our app is better known at this time because we have already built
    a working app, so this is a tad bit easier. Typically, mapping this out before
    you build an app is more difficult; however, again, don't worry about getting
    it right the first time! You can easily refactor and tweak it over time.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序的状态在这个时候更容易知道，因为我们已经构建了一个可工作的应用程序。通常，在构建应用程序之前进行映射会更加困难；然而，同样，不要担心第一次就得到正确！您可以随时进行重构和调整。
- en: Let's take this state and work it into our app with ngrx.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这个状态和ngrx一起应用到我们的应用程序中。
- en: Installing and integrating @ngrx/store
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和集成@ngrx/store
- en: 'We want to first install `@ngrx/store`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要安装`@ngrx/store`：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can now provide the single store to our app via the `StoreModule`. We define
    these initial slices of state in our `CoreModule`, which will be available when
    the app boots, while each lazy loaded feature module adds its own state and reducers
    later when needed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过`StoreModule`向我们的应用程序提供单一存储。我们在`CoreModule`中定义了这些初始状态片段，在应用程序启动时可用，而每个延迟加载的功能模块在需要时会添加自己的状态和减速器。
- en: Providing the initial app state excluding any lazily loaded module state
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供初始应用程序状态，不包括任何延迟加载的模块状态
- en: We want to start by defining the initial app state, excluding any lazily loaded
    feature module state. Since our `CoreModule` provides `AuthService`, which deals
    with handling our user, we will consider the **user** slice a fundamental key
    to our app's initial state.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是定义初始应用程序状态，不包括任何延迟加载的功能模块状态。由于我们的`CoreModule`提供了`AuthService`，处理我们的用户，我们将把**user**片段视为应用程序初始状态的基本关键。
- en: In particular, let's begin by defining the shape of our user state.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，让我们首先定义我们的用户状态的形状。
- en: 'Create `app/modules/core/states/user.state.ts`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`app/modules/core/states/user.state.ts`：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our user state is very simple. It contains a `recentUsername` representing a
    string of the most recently successfully authenticated username (useful if the
    user were to log out and return to log in later). Then, we have **current**, which
    will represent a user object if authenticated, or null if not. We also include
    a `loginCanceled` boolean since we surmise it may be useful for analyzing user
    interaction if we were to start reporting state as analytics data.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户状态非常简单。它包含一个`recentUsername`，表示最近成功验证的用户名的字符串（如果用户注销并稍后返回登录，则此信息很有用）。然后，我们有**current**，如果经过身份验证，则表示用户对象，如果没有，则为null。我们还包括一个`loginCanceled`布尔值，因为我们推测如果我们开始报告状态作为分析数据，这可能对分析用户交互很有用。
- en: Any data points around authentication can be critical to understanding our app's
    user base. For example, it might be insightful to learn whether or not requiring
    authentication to record was causing more canceled logins than signups, which
    may have a direct affect on user retention.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕身份验证的任何数据点都可能对了解我们应用程序的用户群体至关重要。例如，了解是否要求记录身份验证是否导致取消登录比注册更多，这可能会直接影响用户留存。
- en: 'To be consistent with our approach throughout this book, also create `app/modules/core/states/index.ts`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与本书中的方法保持一致，还要创建`app/modules/core/states/index.ts`：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s create our user actions; create `app/modules/core/actions/user.action.ts`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的用户动作；创建`app/modules/core/actions/user.action.ts`：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, follow up with our standard; create `app/modules/core/actions/index.ts`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照我们的标准，创建`app/modules/core/actions/index.ts`：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Okay now, what''s going on with those actions?! Here''s what we''ve defined:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在那些动作是怎么回事？！这就是我们定义的内容：
- en: '`INIT`: To initialize the user right when the app launches. In other words,
    this action will be used to check persistence and restore a user object onto the
    app''s state at launch time.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INIT`: 在应用程序启动时初始化用户。换句话说，这个动作将用于检查持久性，并在启动时将用户对象恢复到应用程序状态中。'
- en: '`LOGIN`: Begin the login sequence. In our app, this will show the login dialog.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOGIN`: 开始登录序列。在我们的应用程序中，这将显示登录对话框。'
- en: '`LOGIN_SUCCESS`: Since login is asynchronous, this action will dispatch once
    login is complete.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOGIN_SUCCESS`: 由于登录是异步的，这个动作将在登录完成后触发。'
- en: '`LOGIN_CANCELED`: If the user cancels login.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOGIN_CANCELED`: 如果用户取消登录。'
- en: '`LOGOUT`: When user logs out.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOGOUT`: 当用户注销时。'
- en: '`UPDATED`: We will use this as a simple action to update our user state. This
    will generally not be dispatched directly, but will be used in the reducer we''ll
    create in a moment.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`已更新`：我们将使用这个简单的动作来更新我们的用户状态。通常不会直接分发，而是将在我们马上创建的 reducer 中使用。'
- en: The formalities you see here provide a consistent and strongly-typed structure.
    By utilizing a namespace, we are able to uniquely identify this set of actions
    with a name, `UserActions`. This allows the interior naming to remain the same
    across many other namespaced actions we will create for the lazy loaded modules
    state, providing a great standard to work with. The `CATEGORY` is necessary because
    every action must be unique, not just in this set of actions but across the entire
    app. The interfaces help provide good intelligence when using our actions, in
    addition to type safety. The various action classes help ensure that all actions
    dispatched are new instances and provide a powerful way to strongly type our action
    payloads. This also makes our code easy to refactor down the line. The last utility
    in our structure is the union type at the bottom, which helps our reducer determine
    the applicable actions it should be concerned with.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您在这里看到的规范提供了一致和强类型的结构。通过使用命名空间，我们能够使用名称 `UserActions` 唯一标识这组动作，这使得内部命名能够在我们为惰性加载的模块状态创建的许多其他命名空间动作中保持相同，提供了一个很好的标准。`CATEGORY`
    是必需的，因为每个动作必须是唯一的，不仅在这组动作中，而且在整个应用程序中。接口在使用我们的动作时提供了良好的智能，除了类型安全性。各种动作类有助于确保所有分发的动作都是新实例，并提供了一种强类型化我们的动作负载的强大方式。这也使得我们的代码易于以后重构。我们结构中的最后一个实用程序是底部的联合类型，它帮助我们的
    reducer 确定它应该关注的适用动作。
- en: 'Speaking of that reducer, let''s create it now: `app/modules/core/reducers/user.reducer.ts`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 说到那个 reducer，让我们现在创建它：`app/modules/core/reducers/user.reducer.ts`：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The reducer is incredibly simple. As mentioned, it is a pure function that takes
    in the existing state along with an action and returns a new state (as a new Object
    unless it's the default starting case). This maintains immutability and keeps
    things quite elegant. The `UPDATED` action will always be the last in any action
    chain to fire off and ultimately change the user state. In this case, we'll keep
    things simple and allow our `UPDATED` action to be the only action that actually
    changes the user state. The other actions will set up a chain, whereby they end
    up dispatching `UPDATED` if they need the user state to change. You could certainly
    set up more cases here based on our actions to change the state; however, in our
    app, this will be the only action that ultimately changes the user state.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Reducer 非常简单。如前所述，它是一个纯函数，接受现有状态和一个动作，并返回一个新状态（作为一个新对象，除非它是默认的起始情况）。这保持了不可变性并保持了事物的优雅。`已更新`
    动作将始终是任何动作链中的最后一个，最终触发并改变用户状态。在这种情况下，我们将保持简单，并允许我们的 `已更新` 动作是实际改变用户状态的唯一动作。其他动作将建立一个链，它们最终会分发
    `已更新`，如果它们需要改变用户状态。基于我们的动作来改变状态，你当然可以在这里设置更多的情况；然而，在我们的应用中，这将是最终改变用户状态的唯一动作。
- en: '*Action chain?* What on earth do we mean by an *Action chain*?! You may be
    wondering how we wire these actions to interplay with each other if needed?'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*动作链？* 什么是 *动作链*？！如果需要，我们是如何将这些动作连接起来相互作用的？'
- en: Installing and integrating @ngrx/effects
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和集成 @ngrx/effects
- en: 'Without redefining, let''s look at the description of @ngrx/effects straight
    from the repo ([https://github.com/ngrx/effects](https://github.com/ngrx/effects)):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不重新定义，让我们直接从存储库（[https://github.com/ngrx/effects](https://github.com/ngrx/effects)）中查看
    @ngrx/effects 的描述：
- en: In `@ngrx/effects`, effects are the sources of actions. You use the `@Effect()`
    decorator to hint which observables on a service are action sources, and `@ngrx/effects`
    automatically merges your action streams, letting you subscribe them to store.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在`@ngrx/effects`中，effects是actions的来源。您可以使用`@Effect()`装饰器来提示服务上的哪些observables是action
    sources，`@ngrx/effects`会自动合并您的action流，让您订阅它们到store。
- en: To help you compose new action sources, `@ngrx/effects` exports an action observable
    service that emits every action dispatched in your application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您编写新的action sources，`@ngrx/effects`导出了一个action observable服务，该服务会发出应用程序中分发的每个action。
- en: In other words, we can chain our actions together with effects to provide powerful
    data flow composition throughout our app. They allow us to insert behavior that
    should take place between when an action is dispatched and before the state is
    ultimately changed. The most common use case is to handle HTTP requests and/or
    other asynchronous operations; however, they have many useful applications.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们可以使用effects将我们的actions链接在一起，以在整个应用程序中提供强大的数据流组合。它们允许我们插入应该在action分发之间和状态最终改变之前发生的行为。最常见的用例是处理HTTP请求和/或其他异步操作；然而，它们有许多有用的应用。
- en: 'To use, let''s first install `@ngrx/effects`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们安装`@ngrx/effects`：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now let's take a look at what our user actions look like in an effect chain.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看我们的用户actions在effect链中是什么样子的。
- en: Real quickly, though, to remain consistent with our naming structure, let's
    rename `auth.service.ts` to `user.service.ts`. It helps when we have a naming
    standard that is consistent across the board.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，为了保持与我们的命名结构一致，让我们将`auth.service.ts`重命名为`user.service.ts`。在整个应用程序中保持一致的命名标准会很有帮助。
- en: 'Now, create `app/modules/core/effects/user.effect.ts`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建`app/modules/core/effects/user.effect.ts`：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We have clarified the intent of our data flow concerning our `UserService`
    and delegated the responsibility to this effect chain. This allows us to compose
    our data flow in a clear and consistent manner with a great deal of flexibility
    and power. For instance, our `InitAction` chain now allows us to automatically
    initialize the user via the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经澄清了关于我们的`UserService`的数据流意图，并将责任委托给了这个effect链。这使我们能够以清晰一致的方式组合我们的数据流，具有很大的灵活性和强大的功能。例如，我们的`InitAction`链现在允许我们通过以下方式自动初始化用户：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Earlier, we were calling a private method--`this._init()`--inside the service
    constructor; however, we no longer need explicit calls like that as effects are
    run and queued up once the module is bootstrapped. The `.startWith` operator will
    cause the observable to fire off one single time (at the point of module creation),
    allowing the init sequence to be executed at a particularly opportune time, when
    our app is initializing. Our initialization sequence is the same as we were previously
    handling in the service; however, this time we''re taking into consideration our
    new `recentUsername` persisted value (if one exists). We then end the init sequence
    with a `UserActions.UpdatedAction`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们在服务构造函数中调用了一个私有方法--`this._init()`；然而，现在我们不再需要像那样显式调用，因为effects会在模块启动时运行和排队。`.startWith`操作符将使observable在一个特定的时间点触发一次（在模块创建时），允许初始化序列在一个特别合适的时间执行，当我们的应用程序正在初始化时。我们的初始化序列与我们之前在服务中处理的相同；然而，这次我们考虑了我们的新的`recentUsername`持久化值（如果存在）。然后，我们用`UserActions.UpdatedAction`结束初始化序列。
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that there''s no effect chain wired to `UserActions.ActionTypes.UPDATED`.
    This is because there are no side effects that should occur by the time that `Action`
    occurs. Since there are no more side effects, the observable sequence ends up
    in the reducer that has a `switch` statement to handle it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`UserActions.ActionTypes.UPDATED`没有连接到效果链。这是因为在`Action`发生时不应该发生任何副作用。由于没有更多的副作用，可观察序列最终进入具有`switch`语句来处理它的减速器：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This takes the payload (which is typed as the shape of the user state, `IUserState`)
    and overwrites the values in the existing state to return a brand new user state.
    Importantly, `Object.assign` allows any existing values in the source object to
    not be overridden unless explicitly defined by the incoming payload. This allows
    only new incoming payload values to be reflected on our state, while still maintaining
    the existing values.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将采用有效负载（其类型为用户状态的形状，`IUserState`）并覆盖现有状态中的值，以返回全新的用户状态。重要的是，`Object.assign`允许源对象中的任何现有值不被覆盖，除非传入有效负载明确定义。这样一来，只有新的传入有效负载值会反映在我们的状态上，同时保持现有值。
- en: The rest of our `UserEffect` chain is fairly self-explanatory. Primarily, it's
    handling much of what the service was previously handling, with the exception
    of prompting the login dialog, which the effect chain is utilizing the service
    method to do. However, it's worth mentioning that we can go so far as to completely
    remove this service as the contents of the `promptLogin` method can easily be
    carried out directly in our effect now.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`UserEffect`链的其余部分相当不言自明。主要是处理服务以前处理的大部分内容，除了提示登录对话框，效果链正在利用服务方法来执行。然而，值得一提的是，我们甚至可以完全删除这个服务，因为`promptLogin`方法的内容现在可以直接在我们的效果中执行。
- en: When deciding if you should handle more logic in your effect or a designated
    service, it really comes down to personal preference and/or scalability. If you
    have rather lengthy service logic and more than a couple of methods to handle
    logic while working with effects, creating a designated service will help greatly.
    You can scale more functionality into the service without diluting the clarity
    of your effects chain.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定是否应该在您的效果或指定服务中处理更多逻辑时，这实际上取决于个人偏好和/或可扩展性。如果您有相当长的服务逻辑，并且有多个方法来处理逻辑，同时使用效果，创建指定的服务将会有很大帮助。您可以将更多功能扩展到服务中，而不会削弱效果链的清晰度。
- en: Lastly, unit testing will be easier with a designated service with more logic.
    In this case, our logic is fairly simple; however, we'll leave the `UserService`
    for example purposes as well as best practice.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用具有更多逻辑的指定服务进行单元测试将更容易。在这种情况下，我们的逻辑相当简单；然而，出于示例目的以及最佳实践，我们将保留`UserService`。
- en: Speaking of, let's take a look at how simplified our `UserService` looks now
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这个，让我们看看我们的`UserService`现在看起来多么简化。
- en: 'in `app/modules/core/services/user.service.ts`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app/modules/core/services/user.service.ts`中：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It's much cleaner now. Okay, so how do we let our app know about all this new
    goodness?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在清洁多了。好的，那么我们如何让我们的应用程序知道所有这些新的好处呢？
- en: 'First, let''s follow one of our standards by adding an index to our entire
    core module; add `app/modules/core/index.ts`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们按照我们的标准之一，在整个核心模块中添加一个索引；添加`app/modules/core/index.ts`：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We simply export all the goodies our core module now provides, including the
    module itself.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需导出核心模块现在提供的所有好东西，包括模块本身。
- en: 'Then, open `app/modules/core/core.module.ts` to finish our wiring:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开`app/modules/core/core.module.ts`来完成我们的连接：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here we ensure that we define our `user` state key to use the `userReducer`
    and register it with `StoreModule`. We then call `EffectsModule.forRoot()`, with
    a collection of singleton effect providers to register like our `UserEffects`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们确保定义我们的`user`状态键来使用`userReducer`并将其注册到`StoreModule`。然后我们调用`EffectsModule.forRoot()`，使用一组单例效果提供者进行注册，就像我们的`UserEffects`一样。
- en: Now, let's take a look at how this improves the rest of the code base since
    we were undoubtedly injecting the `UserService` (previously named `AuthService`)
    in a couple of places.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这如何改进代码库的其余部分，因为我们无疑在一些地方注入了`UserService`（以前名为`AuthService`）。
- en: 'We were previously injecting `AuthService` in `AppComponent` to ensure that
    Angular''s dependency injection constructed it early on when the app was bootstrapped,
    creating the necessary singleton our app needed. However, with `UserEffects` automatically
    running now on bootstrap, which in turn injects (now renamed) `UserService`, we
    no longer need this rather silly necessity anymore, so, we can update `AppComponent`
    as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以前在`AppComponent`中注入`AuthService`，以确保在应用程序引导时早早地构建Angular的依赖注入，创建我们应用程序所需的必要单例。然而，现在`UserEffects`在引导时自动运行，然后注入（现在更名为）`UserService`，我们不再需要这种愚蠢的必要性，因此，我们可以按照以下方式更新`AppComponent`：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In one swoop, our code base is now getting smarter and slimmer. Let's keep going
    to see other benefits of our ngrx integration.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码库现在变得更加智能和精简。让我们继续看看ngrx集成的其他好处。
- en: 'Open `app/auth-guard.service.ts`, and we can now make the following simplifications:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`app/auth-guard.service.ts`，我们现在可以进行以下简化：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When activating the `/record` route, we dispatch the `LoginAction` every time
    since we require an authenticated user to use the recording features. Our login
    effects chain properly handles if the user is already authenticated, so all we
    need to do is set up our state subscription to react accordingly.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 激活`/record`路由时，我们每次都会分派`LoginAction`，因为我们需要经过身份验证的用户才能使用录制功能。我们的登录效果链会正确处理用户是否已经经过身份验证，所以我们只需要设置我们的状态订阅以相应地做出反应。
- en: Ngrx is flexible, and how you set up your actions and effects chains is purely
    up to you.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Ngrx是灵活的，你如何设置你的动作和效果链完全取决于你。
- en: Providing lazily loaded feature module state
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供延迟加载的功能模块状态
- en: 'We can now build out the scalable ngrx structure into our various feature modules,
    which will provide state. Starting with `MixerModule`, let''s modify `app/modules/mixer/mixer.module.ts`
    with the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将可扩展的ngrx结构构建到我们的各种功能模块中，这将提供状态。从`MixerModule`开始，让我们修改`app/modules/mixer/mixer.module.ts`如下：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we are defining what the `MixerModule` state will provide. Now, let's
    define its shape; create
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在定义`MixerModule`状态将提供什么。现在，让我们定义它的形状；创建
- en: '`app/modules/mixer/states/mixer.state.ts`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/modules/mixer/states/mixer.state.ts`：'
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To be consistent with our approach throughout this book, also create `app/modules/mixer/states/index.ts`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与本书中的方法保持一致，还要创建`app/modules/mixer/states/index.ts`：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s create our mixer actions; create `app/modules/mixer/actions/mixer.action.ts`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的混音器动作；创建`app/modules/mixer/actions/mixer.action.ts`：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Similar to our UserActions, we will also use an `INIT` action to autoinitialize
    this state with user-saved compositions (or our sample demo composition to start).
    Here''s a quick rundown:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的UserActions类似，我们还将使用`INIT`动作来自动初始化此状态，使用用户保存的组合（或我们的示例演示组合）进行初始化。以下是一个快速概述：
- en: '`INIT`: To initialize the mixer right when the app launches. Just as we did
    with `UserActions`, this action will be used to check persistence and restore
    any user-saved compositions onto the mixer state at launch time.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INIT`：在应用程序启动时初始化混音器。就像我们使用`UserActions`一样，此动作将用于检查持久性并在启动时将任何用户保存的组合恢复到混音器状态。'
- en: '`ADD`: Show the add new composition dialog.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD`：显示添加新组合对话框。'
- en: '`EDIT`: Edit a composition''s name by prompting a dialog.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EDIT`：通过提示对话框编辑组合的名称。'
- en: '`SAVE`: Save compositions.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SAVE`：保存组合。'
- en: '`CANCEL`: General action to cancel out of any effect chain.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CANCEL`：取消任何效果链的一般操作。'
- en: '`SELECT`: Select a composition. We will use this action to drive the Angular
    router to the main selected composition view.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT`：选择一个组合。我们将使用这个操作来驱动Angular路由到主选定的组合视图。'
- en: '`OPEN_RECORD`: Handle the preparation of opening the recording view, including
    checking for authentication, pausing playback if playing, and opening in modal
    or routing to it.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPEN_RECORD`：处理准备打开记录视图，包括检查认证、暂停播放（如果正在播放）并在模态框中打开或路由到它。'
- en: '`UPDATE`: Initiate an update to a composition.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPDATE`：启动对组合的更新。'
- en: '`UPDATED`: This will generally not be dispatched directly, but used at the
    end of an effect sequence that the reducer will pick up to finally change the
    mixer state.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPDATED`：这通常不会直接分发，而是在效果序列的最后使用，reducer会最终改变混音器状态。'
- en: 'Now, we can create the reducer that is similar to our user reducer:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个类似于我们用户reducer的reducer：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After this, let''s create our `MixerEffects` at `app/modules/mixer/effects/mixer.effect.ts`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，让我们在`app/modules/mixer/effects/mixer.effect.ts`中创建我们的`MixerEffects`：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Probably, the most interesting effect is the`openRecord$` chain. We use `@Effect({
    dispatch: false })` to indicate that it should not dispatch any actions at the
    end as we are using it to execute work directly, such as checking whether the user
    is authenticated or if `activeComposition` contains tracks to conditionally open
    record view in a modal or as a route. We make use of another operator:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '可能，最有趣的效果是`openRecord$`链。我们使用`@Effect({ dispatch: false })`来指示它在最后不应该分发任何操作，因为我们使用它来直接执行工作，比如检查用户是否已经认证，或者`activeComposition`是否包含轨道，以有条件地在模态框中或作为路由打开记录视图。我们使用了另一个操作符：'
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This allows us to insert an arbitrary action without affecting the sequence
    of events. In this case, we ensure that playback is always paused when the user
    attempts to open a record view (since they can attempt to open the record view
    while playback is playing). We are presenting a few more advanced usage options
    with this chain, just to show what is possible. We are also stepping ahead a bit
    since we have not shown the creation of `PlayerActions` yet; however, we will
    just be presenting a couple of highlights in this chapter.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够插入任意操作而不影响事件序列。在这种情况下，我们确保当用户尝试打开记录视图时始终暂停播放（因为他们可能在播放时尝试打开记录视图）。我们在这个链中展示了一些更高级的使用选项，只是为了展示可能性。我们也稍微超前了一点，因为我们还没有展示`PlayerActions`的创建；然而，在本章中我们只会呈现一些亮点。
- en: 'With this effect chain, we can simplify our `MixerService` with the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个效果链，我们可以简化我们的`MixerService`如下：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We've simplified the service logic, leaving most of the result handling work
    inside the effects chain. You might decide to leave the service with more logic and
    keep the effects chain simpler; however, we have designed this setup as an example
    to show more alternate setups with how flexible ngrx is.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简化了服务逻辑，将大部分结果处理工作留在了效果链内。您可能决定保留服务更多的逻辑，并保持效果链更简单；然而，我们设计了这个设置作为一个示例，以展示ngrx的灵活性。
- en: 'To finish up our lazy loaded state handling, ensure that these effects are
    run; when `MixerModule` loads, we can make these adjustments to the module:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的懒加载状态处理，请确保这些效果被运行；当`MixerModule`加载时，我们可以对模块进行以下调整：
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s look at how this improves our component handling, starting with `app/modules/mixer/components/mixer.component.ts`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这如何改进我们的组件处理，从`app/modules/mixer/components/mixer.component.ts`开始：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This time, inside `ngOnInit`, we just set up the component to be reactive to
    our mixer's state by setting the composition to the `activeComposition`. This
    is guaranteed to always be whichever composition the user has currently selected
    and is working on. We dispatch our `OpenRecordAction` inside the `record` method,
    passing along the proper `ViewContainerRef` and a track if the user is rerecording.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，在`ngOnInit`中，我们只需设置组件对我们混音器状态的响应性，将组合设置为`activeComposition`。这保证始终是用户当前选择并正在操作的组合。我们在`record`方法中分派我们的`OpenRecordAction`，传递适当的`ViewContainerRef`和用户是否正在重新录制的轨道。
- en: 'Next up is the simplification of `app/modules/mixer/components/mix-list.component.ts`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是简化`app/modules/mixer/components/mix-list.component.ts`：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have removed the `MixerService` injection and made it reactive by setting
    up a state Observable--`mixer$`--and integrated our `MixerActions`. This lightens
    up the component, making it easier to test and maintain since it no longer has
    an explicit dependency on the `MixerService`, which was previously being used
    for view bindings as well. If we take a look at the view, we can now utilize Angular''s
    async pipe to gain access to the user-saved compositions via the state:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经移除了`MixerService`的注入，并通过设置状态Observable--`mixer$`--并集成我们的`MixerActions`，使其变得响应式。这减轻了组件的负担，使其更容易测试和维护，因为它不再显式依赖于`MixerService`，以前用于视图绑定。如果我们看一下视图，现在我们可以利用Angular的异步管道来通过状态访问用户保存的组合：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'From the official documentation: Angular''s async pipe subscribes to an Observable
    or Promise and returns the latest value it has emitted. When a new value is emitted,
    the async pipe marks the component to be checked for changes. When the component
    gets destroyed, the async pipe unsubscribes automatically to avoid potential memory
    leaks.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方文档：Angular的异步管道订阅Observable或Promise并返回它发出的最新值。当发出新值时，异步管道会标记组件以进行更改检查。当组件被销毁时，异步管道会自动取消订阅，以避免潜在的内存泄漏。
- en: This is truly remarkable and incredibly handy, allowing us to create reactive
    components that're highly maintainable and flexible.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是非常了不起和非常方便，使我们能够创建高度可维护和灵活的响应式组件。
- en: Inspect the code! Exploring more on your own
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查代码！自己探索更多
- en: Since a lot of what we saw earlier are the exact same principles applied to
    the rest of our code base, instead of increasing the size of this book further,
    we invite you to explore the rest of the ngrx integration in the same chapter
    branch on the accompanying code repository to this book.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前看到的很多内容都是应用于我们代码库的其他部分的相同原则，而不是进一步增加本书的篇幅，我们邀请您在本书附带的代码存储库的同一章节分支中探索其余的ngrx集成。
- en: Looking through the actual code, running it, and even stepping through it will
    hopefully give you a solid understanding of how ngrx fits into your app and the
    many advantages it can bring.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览实际代码，运行它，甚至逐步执行它，希望能让您对ngrx如何适应您的应用程序以及它可以带来的许多优势有一个扎实的理解。
- en: The community is lucky to have members like Rob Wormald, Mike Ryan, Brian Troncone,
    Brandon Roberts, and more, who have helped make ngrx so nice to use, so a **huge
    thank you to all the contributors**!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 社区很幸运能有像Rob Wormald，Mike Ryan，Brian Troncone，Brandon Roberts等成员，他们帮助使ngrx的使用变得如此愉快，因此**非常感谢所有的贡献者**！
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Hopefully, you are starting to see a pattern of simplification and clarity to
    the data flow while integrating ngrx. It has helped reduce code, while improving
    data flow by providing consistent effect chains to various actions, which may
    need to occur anywhere (from lazy loaded modules or not). By reducing the overhead
    of managing explicit injected dependencies throughout and instead relying on Store
    and Actions to initiate the appropriate work, we are increasing the maintainability
    and scalability of our app. On top of all that, it is paving a pathway to effective
    testability, which we will cover in [Chapter 12](part0136.html#41MCG0-289fe2426d594f99a90e4363b2c9c34d),
    *Unit Testing*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您开始看到在集成ngrx时简化和澄清数据流的模式。它有助于减少代码，同时通过为各种操作提供一致的效果链来改进数据流，这些操作可能需要在任何地方发生（从惰性加载的模块或其他地方）。通过减少在整个过程中管理显式注入的依赖项的开销，而是依赖Store和Actions来启动适当的工作，我们正在增加应用程序的可维护性和可扩展性。最重要的是，它为有效的可测试性铺平了道路，我们将在《第12章》《单元测试》中进行介绍。
- en: This chapter highlighted the additional advantages when combining NativeScript
    with Angular by opening up integration potential with rich libraries such as ngrx to
    improve our app's architecture and data flow.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本章突出了将NativeScript与Angular相结合的额外优势，通过打开与丰富库（如ngrx）的集成潜力，改进我们的应用程序架构和数据流。
- en: It's been a long time coming, and we couldn't be more excited about [Chapter
    11](part0131.html#3STPM0-289fe2426d594f99a90e4363b2c9c34d), *Polish with SASS*, coming
    up next. Finally, we are ready to polish our app to give it that special spark!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个漫长的过程，我们对接下来的《第11章》《使用SASS进行波兰语》感到非常兴奋。最终，我们准备好了，要打磨我们的应用程序，赋予它特别的火花！
