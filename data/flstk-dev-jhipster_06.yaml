- en: Testing and Continuous Integration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和持续集成
- en: Now that we have scaffolded and developed our e-commerce application, it's time
    to make it ready for deployment to our production environment. Before that, there
    are two important aspects of engineering that we need to look at, *quality* and
    *stability*. In this chapter, we will see how this can be achieved using modern
    DevOps practices, such as continuous integration and automated testing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经搭建并开发了我们的电子商务应用程序，是时候让它为部署到我们的生产环境做好准备。在此之前，我们需要关注两个重要的工程方面，*质量* 和 *稳定性*。在本章中，我们将探讨如何使用现代
    DevOps 实践，如持续集成和自动化测试来实现这一点。
- en: 'We will also see the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看到以下内容：
- en: Fixing and running tests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复和运行测试
- en: '**CI**/**CD** (**continuous integration**/**continuous deployment**) tools'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CI**/**CD**（**持续集成**/**持续部署**）工具'
- en: Setting up CI with Jenkins using the JHipster CI-CD sub-generator
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JHipster CI-CD 子生成器设置 CI
- en: '**DevOps** is a software engineering practice that unifies software development
    (Dev) and software operation (Ops). The main focus of DevOps is automation and
    monitoring at all stages of software engineering, such as development, integration,
    testing, deployment, and infrastructure management. DevOps is one of the most
    trending engineering practices of this decade, and continuous integration and
    continuous deployment are two of its core aspects.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**DevOps** 是一种将软件开发（Dev）和软件运营（Ops）统一在一起的软件工程实践。DevOps 的主要重点是软件工程所有阶段的自动化和监控，如开发、集成、测试、部署和基础设施管理。DevOps
    是本十年最受欢迎的工程实践之一，持续集成和持续部署是其核心方面之二。'
- en: Fixing and running tests
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复和运行测试
- en: Before we dive into continuous integration tools, let's first make sure that
    our tests are working and still pass after the changes we made in the previous
    chapter. In an ideal world, where software development is done using practices
    such as **TDD** (**Test-driven development**), writing and fixing tests is done
    along with the development of the code, and specs are written before you develop
    the actual code. You should try to follow this practice so that you write failing
    tests first for an expected result, and then develop code that will make the tests
    pass. Since our tests were autogenerated by JHipster we can at least make sure
    that they are working when we make changes to the generated code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究持续集成工具之前，让我们首先确保我们的测试在上一章所做的更改后仍然可以正常工作并通过。在一个理想的世界里，如果软件开发是使用诸如 **TDD**（**测试驱动开发**）之类的实践进行的，那么编写和修复测试是与代码的开发同时进行的，规范是在实际开发代码之前编写的。你应该尝试遵循这一实践，以便首先编写失败的测试以实现预期的结果，然后开发使测试通过的代码。由于我们的测试是由
    JHipster 自动生成的，我们至少可以确保在修改生成的代码时它们是正常工作的。
- en: JHipster can also generate performance tests using Gatling for the entities.
    It is very useful, and a must if you are developing a high-availability and high-volume
    website. This can be enabled when creating the application. See [http://www.jhipster.tech/running-tests/](http://www.jhipster.tech/running-tests/) for
    more details.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 还可以使用 Gatling 为实体生成性能测试。这非常有用，如果你正在开发一个高可用性和高流量的网站，这是必须的。这可以在创建应用程序时启用。有关更多详细信息，请参阅
    [http://www.jhipster.tech/running-tests/](http://www.jhipster.tech/running-tests/)。
- en: 'Let''s run our unit and integration tests to see if any of them fail:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的单元测试和集成测试，看看是否有任何失败的测试：
- en: Head over to your terminal and navigate to the online-store folder first.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先转到你的终端，并导航到 online-store 文件夹。
- en: 'Let''s first run the server-side tests using Gradle:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先使用 Gradle 运行服务器端测试：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that JHipster generates both unit tests and integration tests for the server
    side. The unit tests, files named `*UnitTest.java`, are simple JUnit tests intended
    for unit testing functions. The integration tests, files named `*IntTest.java`,
    are intended for testing a Spring component using the entire Spring environment.
    They are run with the `SpringRunner` class and normally start up the Spring environment,
    configure all the required beans, and run the test.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，JHipster 为服务器端生成单元测试和集成测试。单元测试，文件名为 `*UnitTest.java`，是简单的 JUnit 测试，用于单元测试功能。集成测试，文件名为
    `*IntTest.java`，旨在使用整个 Spring 环境测试 Spring 组件。它们使用 `SpringRunner` 类运行，通常启动 Spring
    环境，配置所有必需的 bean，并运行测试。
- en: 'Some of our tests failed with the following error trace:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一些测试失败，出现以下错误跟踪：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You could also run the tests from your IDE so that you have a better error message
    and failure report. Select the entire `src/test` folder, right-click, and select
    Run all tests.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以从您的 IDE 中运行测试，以便您有更好的错误信息和失败报告。选择整个 `src/test` 文件夹，右键单击，并选择运行所有测试。
- en: 'These are expected to fail as we changed the `Resource` classes for these entities
    in the previous chapter to handle authorizations, and the failure means that it''s
    working perfectly. Fortunately, it''s not difficult to fix the tests using Spring.
    We can use the `@WithMockUser` annotation provided by the Spring test context
    to provide a mock user for our tests. Add the annotation with user details as
    highlighted in the following code to all the failing test classes:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些测试预期会失败，因为我们已经在上一章将这些实体的 `Resource` 类更改为处理授权，失败意味着它运行得非常完美。幸运的是，使用 Spring
    修复测试并不困难。我们可以使用 Spring 测试上下文提供的 `@WithMockUser` 注解为我们的测试提供一个模拟用户。将以下代码中突出显示的用户详细信息添加到所有失败的测试类中：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are providing a mock user with the `ADMIN` role here. Add the same to `OrderItemResourceIntTest`, `ProductOrderResourceIntTest`,
    and `ShipmentResourceIntTest`. Run the tests again and they should pass.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里提供了一个具有 `ADMIN` 角色的模拟用户。同样添加到 `OrderItemResourceIntTest`、`ProductOrderResourceIntTest`
    和 `ShipmentResourceIntTest` 中。再次运行测试，它们应该通过。
- en: Commit the changes made by running `git commit -am "fix server side tests with mockUser"`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `git commit -am "fix server side tests with mockUser"` 提交所做的更改。
- en: 'Now let''s make sure our client-side Karma unit tests are working. Since we
    didn''t make any logic changes on the client-side there shouldn''t be any failures.
    Run the following command:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们确保我们的客户端 Karma 单元测试正在运行。由于我们在客户端没有进行任何逻辑更改，因此不应该有任何失败。运行以下命令：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'All tests should pass. Let''s head over to `src/test/javascript/spec/app/entities/product/product.component.spec.ts`. We
    use the Jasmine Framework for our tests. The existing test has the following structure.
    The `beforeEach` block sets up the Angular `TestBed`:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有测试都应该通过。让我们转到 `src/test/javascript/spec/app/entities/product/product.component.spec.ts`。我们使用
    Jasmine 框架进行测试。现有的测试具有以下结构。`beforeEach` 块设置了 Angular `TestBed`：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now let''s make sure our protractor `e2e` tests are working. Run the following
    commands in two separate terminals. Start the server first. Let''s clear the database
    as well by a running clean task so that tests run on a fresh setup. Since we are
    running a clean task we also need to run the `webpackBuildDev` task to rebuild
    the client side:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们确保我们的 protractor `e2e` 测试正在运行。在两个不同的终端中运行以下命令。首先启动服务器。让我们通过运行清理任务来清除数据库，以便测试在全新设置上运行。由于我们正在运行清理任务，我们还需要运行
    `webpackBuildDev` 任务来重新构建客户端：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now run the e2e tests:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行 e2e 测试：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you prefer not to run scripts via Yarn or NPM, you could also run them via
    Gradle using the node integration provided by JHipster. For example, instead of
    `yarn e2e`, you could run `./gradlew yarn_e2e`, and instead of `yarn test` you
    could run `./gradlew yarn_test`. This is useful if you do not want to install
    NodeJS and Yarn and want everything to be managed for you by Gradle. If you choose
    Maven instead of Gradle the same feature is available for that as well.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想通过 Yarn 或 NPM 运行脚本，您也可以通过 Gradle 使用 JHipster 提供的节点集成来运行它们。例如，您可以使用 `./gradlew
    yarn_e2e` 代替 `yarn e2e`，并使用 `./gradlew yarn_test` 代替 `yarn test`。如果您不想安装 NodeJS
    和 Yarn，并且希望 Gradle 为您管理一切，这很有用。如果您选择 Maven 而不是 Gradle，该功能也适用于 Maven。
- en: 'All tests should pass here as well. But if you look at the generated `e2e`
    tests, for example, look at `src/test/javascript/e2e/entities/customer.spec.ts`,
    you will see that a test is commented out. Some tests are commented out during
    generation if an entity has a required relationship field, as we would have to
    create a relationship first and set its value for the test to work. Let''s focus
    on only the `Customer` page test. Uncomment the test named should create and save
    Customers and change the `describe` function to `fdescribe` on the test file,
    so that only this test file is executed:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有测试都应该在这里通过。但如果您查看生成的 `e2e` 测试，例如，查看 `src/test/javascript/e2e/entities/customer.spec.ts`，您会看到有一个测试被注释掉了。如果实体有一个必需的关系字段，在生成过程中会注释掉一些测试，因为我们必须首先创建关系并设置其值，以便测试能够运行。让我们只关注
    `Customer` 页面的测试。取消注释名为 should create and save Customers 的测试，并将测试文件中的 `describe`
    函数更改为 `fdescribe`，以便只执行此测试文件：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now execute `yarn e2e` and we should see one failing test. First, let''s fix
    the email field by providing a valid email format:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在执行 `yarn e2e`，我们应该看到一个失败的测试。首先，让我们通过提供有效的电子邮件格式来修复电子邮件字段：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run `yarn e2e` again and this time it should pass. But since we have a one-to-one
    relationship between user and customer the test will fail if we run it again,
    hence we need to delete the row created after it. Let''s add a test case for a
    delete action. In the `CustomerComponentsPage` class defined in the file (if you
    are using JHipster 5, this class will be available under `src/test/javascript/e2e/page-objects/customer-page-object.ts`),
    add a new property and methods as follows:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行 `yarn e2e` 并这次它应该会通过。但由于用户和客户之间存在一对一的关系，如果我们再次运行它，测试将失败，因此我们需要删除它之后创建的行。让我们添加一个删除操作的测试用例。在文件中定义的
    `CustomerComponentsPage` 类（如果你使用的是 JHipster 5，这个类将在 `src/test/javascript/e2e/page-objects/customer-page-object.ts`
    下可用）中，添加以下新的属性和方法：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now add `expect(customerComponentsPage.getTable().isPresent()).toBeTruthy();`
    as the last line in our previous test to confirm if the row was created. Then
    add the following test to delete the row:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将 `expect(customerComponentsPage.getTable().isPresent()).toBeTruthy();` 添加为之前测试的最后一行，以确认是否创建了行。然后添加以下测试以删除该行：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run `yarn e2e` again to verify. Do not forget to remove the `fdescribe` from
    the file so that all tests get executed. Congratulations! You added you first
    protractor `e2e` tests.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行 `yarn e2e` 以验证。不要忘记从文件中移除 `fdescribe`，以便所有测试都能执行。恭喜！你添加了你的第一个 Protractor
    `e2e` 测试。
- en: Similarly, fix the commented out `e2e` tests in other files under `src/test/javascript/e2e/entities`
    as well. This is part of the *next steps* assignment.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，修复 `src/test/javascript/e2e/entities` 下其他文件中注释掉的 `e2e` 测试。这是 *下一步操作* 的一部分。
- en: Continuous integration
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: Having automated testing ensures that we are creating bug-free code, and also
    ensures that there are no regressions introduced from new code. JHipster helps
    to an extent, by creating unit and integration tests for the generated code, but
    in real use cases, it won't be sufficient. We would have to add server-side unit
    tests for the business logic that we introduce and integration tests for new APIs
    we add. You will also have to add more unit tests for business logic handled on
    the client side and `e2e` tests, as JHipster only generates a few sample tests
    for you and doesn't know anything about your business logic.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试确保我们创建的代码没有错误，同时也确保没有从新代码中引入回归。JHipster 通过为生成的代码创建单元和集成测试在一定程度上有所帮助，但在实际使用案例中，这还不够。我们还需要为引入的业务逻辑添加服务器端单元测试，并为新添加的
    API 添加集成测试。你还需要为客户端处理的企业逻辑添加更多单元测试和 `e2e` 测试，因为 JHipster 只为你生成少量示例测试，并且对您的业务逻辑一无所知。
- en: The more tests you have, more confident you will be changing code, with fewer
    chances of regression.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你拥有的测试越多，你在更改代码时就越有信心，回归的可能性就越小。
- en: Testing and continuous integration is an integral part of full-stack development
    and is an important aspect of DevOps. Testing should be considered as important
    as developing features to build a quality product. Continuous integration is nothing
    more than continuously merging and testing your new code changes in an isolated
    environment against your master/main/stable codebase to identify potential bugs
    and regression. It is achieved by running automated unit, integration, end-to-end,
    and other test suites against the code. For example, if you are working with Git,
    these are typically run for every commit you make to your master branch and/or
    for every pull request, you create.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 测试和持续集成是全栈开发的一个组成部分，也是 DevOps 的重要方面。测试应该被视为与构建高质量产品时开发功能同等重要。持续集成不过是持续地将你的新代码更改合并并测试到隔离环境中，与你的
    master/main/stable 代码库进行对比，以识别潜在的错误和回归。这是通过运行针对代码的自动化单元、集成、端到端和其他测试套件来实现的。例如，如果你使用
    Git，这些测试通常会在你向 master 分支提交每次更改时以及你创建的每个 pull request 时运行。
- en: Once we have automated tests, we can make use of continuous integration practices
    to make sure that any new code we introduce doesn't cause any regression in our
    stable code base. This will give us the confidence to merge new code and deploy
    that to production.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了自动化测试，我们可以利用持续集成实践来确保我们引入的新代码不会对我们的稳定代码库造成任何回归。这将给我们合并新代码并将其部署到生产环境的信心。
- en: Modern DevOps teams often go a step further and do continuous delivery (continuous integration
    + continuous deployment). They often define CI/CD pipelines, which continuously integrate,
    test, and deploy code to production in a fully automated way.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现代DevOps团队通常会更进一步，进行持续交付（持续集成 + 持续部署）。他们通常会定义 CI/CD 管道，以完全自动化的方式持续集成、测试和将代码部署到生产环境中。
- en: Teams with a good continuous integration and continuous deployment setup can
    deliver more features more frequently with fewer bugs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有良好持续集成和持续部署设置的团队可以更频繁地交付更多功能，同时出现更少的错误。
- en: Have I stressed the importance of continuous integration enough?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我是否已经足够强调了持续集成的重要性？
- en: CI/CD tools
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI/CD 工具
- en: JHipster provides excellent support for the well-known CI/CD tools. Let's take
    a look at the options available first.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 为知名的 CI/CD 工具提供了出色的支持。让我们首先看看可用的选项。
- en: Jenkins
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins
- en: Jenkins ([https://jenkins.io/](https://jenkins.io/)) is one of the leading CI/CD
    tools out there. It is free and open source. It is an automation server written
    in Java and supports integration with various version control tools, such as Git,
    CVS, SVN, and so on. Jenkins has a huge plugin ecosystem and this makes it one
    of the most flexible platforms. Jenkins can be used for building projects, running
    automated tests, automating deployment, and so on. It is available as an executable
    binary for various platforms and as Docker images. Blue Ocean is the latest UI
    interface for Jenkins giving it a much-needed breath of fresh air. Jenkins has
    the concept of a pipeline, achieved by using multiple plugins and a Groovy DSL
    to define the CI/CD pipeline. Jenkins pipeline plugins provide a comprehensive
    DSL-based configuration that can be defined in a file called a `Jenkinsfile`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins ([https://jenkins.io/](https://jenkins.io/)) 是领先的 CI/CD 工具之一。它是免费和开源的。这是一个用
    Java 编写的自动化服务器，支持与各种版本控制工具集成，如 Git、CVS、SVN 等。Jenkins 拥有庞大的插件生态系统，这使得它成为最灵活的平台之一。Jenkins
    可以用于构建项目、运行自动化测试、自动化部署等。它作为各种平台的可执行二进制文件和 Docker 镜像提供。Blue Ocean 是 Jenkins 的最新
    UI 接口，为它带来了急需的新鲜空气。Jenkins 有管道的概念，通过使用多个插件和 Groovy DSL 来定义 CI/CD 管道。Jenkins 管道插件提供了一种基于
    DSL 的全面配置，可以在名为 `Jenkinsfile` 的文件中定义。
- en: Travis CI
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Travis CI
- en: Travis CI ([https://travis-ci.org/](https://travis-ci.org/)) is an open source
    hosted **PaaS** (**Platform as a Service**) solution for CI/CD. It is free for
    public/OSS projects and needs a subscription for use by private/enterprise projects.
    It supports applications written in a variety of languages and platforms, and
    is heavily used by open source projects, including JHipster, for their continuous
    integration needs. It has excellent integration with version control tools and
    offers an enterprise version as well. It is very easy to set up and use, and has
    a simple YAML-based configuration. Advanced setups are typically done using shell
    scripts that can be triggered by the YAML configuration using hooks.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Travis CI ([https://travis-ci.org/](https://travis-ci.org/)) 是一个开源的托管 **PaaS（平台即服务**）
    解决方案，用于 CI/CD。对于公共/OSS 项目是免费的，而对于私人/企业项目则需要订阅。它支持用各种语言和平台编写的应用程序，并且被包括 JHipster
    在内的开源项目广泛用于持续集成需求。它与版本控制工具有很好的集成，并提供企业版本。它非常容易设置和使用，具有简单的基于 YAML 的配置。高级设置通常使用可以通过钩子由
    YAML 配置触发的 shell 脚本来完成。
- en: GitLab CI
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitLab CI
- en: GitLab CI ([https://about.gitlab.com/features/gitlab-ci-cd/](https://about.gitlab.com/features/gitlab-ci-cd/))
    is a CI/CD solution available as part of GitLab, a web UI on top of Git. It is
    well integrated into the platform and is an excellent choice when using GitLab.
    It is free and open source for use by public projects and has an enterprise version
    as well. It has both a hosted solution and binaries to be used on-premises.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 'GitLab CI ([https://about.gitlab.com/features/gitlab-ci-cd/](https://about.gitlab.com/features/gitlab-ci-cd/))
    是 GitLab 的一部分 CI/CD 解决方案，GitLab 是 Git 之上的一个 Web UI。它与平台良好集成，当使用 GitLab 时是一个极佳的选择。对于公共项目它是免费和开源的，同时也有企业版本。它既有托管解决方案，也有用于本地部署的二进制文件。 '
- en: CircleCI
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CircleCI
- en: CircleCI ([https://circleci.com/](https://circleci.com/)) is another open source
    CI/CD solution that offers both a hosted PaaS and on-premises option. It has free
    options for small teams and subscription plans for bigger teams and enterprises.
    The configuration is simple and YAML-based, similar to Travis CI. It provides
    options to choose different OS environments for the builds and is very easy to
    set up.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: CircleCI ([https://circleci.com/](https://circleci.com/)) 是另一个提供托管 PaaS 和本地选项的开源
    CI/CD 解决方案。它为小型团队提供免费选项，并为大型团队和企业提供订阅计划。配置简单，基于 YAML，类似于 Travis CI。它提供了选择不同操作系统环境进行构建的选项，并且非常容易设置。
- en: Setting up Jenkins
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Jenkins
- en: 'Let''s use Jenkins as the CI tool for our application. We first need to set
    up a local Jenkins instance:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Jenkins 作为我们应用程序的 CI 工具。我们首先需要设置一个本地 Jenkins 实例：
- en: If you are already familiar with Docker, you can use the official Docker image
    provided by Jenkins and can skip the following steps.  The Docker image will be
    automatically generated by JHipster when creating the CD/CI pipeline in the following
    section. Visit [http://www.jhipster.tech/setting-up-ci-jenkins2/](http://www.jhipster.tech/setting-up-ci-jenkins2/)
    for more details.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉Docker，你可以使用Jenkins提供的官方Docker镜像，并可以跳过以下步骤。Docker镜像将在下一节创建CD/CI流水线时由JHipster自动生成。有关更多详细信息，请访问[http://www.jhipster.tech/setting-up-ci-jenkins2/](http://www.jhipster.tech/setting-up-ci-jenkins2/)。
- en: Let's download the latest binary from [http://mirrors.jenkins.io/war-stable/latest/jenkins.war](http://mirrors.jenkins.io/war-stable/latest/jenkins.war).
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从[http://mirrors.jenkins.io/war-stable/latest/jenkins.war](http://mirrors.jenkins.io/war-stable/latest/jenkins.war)下载最新的二进制文件。
- en: Now open a terminal and navigate to the folder where the file was downloaded.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开一个终端，导航到文件下载的文件夹。
- en: Execute `java -jar jenkins.war --httpPort=8989` from the terminal to start a
    Jenkins server. The port should not conflict with our application port. The default
    password will be printed on the console. Make a copy of it.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从终端执行`java -jar jenkins.war --httpPort=8989`以启动一个Jenkins服务器。端口号不应与我们的应用程序端口冲突。默认密码将在控制台上打印出来。请复制它。
- en: Navigate to [https://localhost:8989](http://localhost:8989) and paste the password
    copied before.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到[https://localhost:8989](http://localhost:8989)，并粘贴之前复制的密码。
- en: Click on the Install suggested plugins button on the next page and wait for
    the plugin installation to complete.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下一页上的“安装建议插件”按钮，并等待插件安装完成。
- en: Create an admin user on the next page and complete.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一页创建一个管理员用户并完成。
- en: Now that our Jenkins server is ready, let's go ahead and create a Jenkins pipeline
    for our project.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了Jenkins服务器，让我们继续为我们的项目创建一个Jenkins流水线。
- en: Creating a Jenkins pipeline using JHipster
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JHipster创建Jenkins流水线
- en: 'We can create the `Jenkinsfile` for our project using the `ci-cd sub-generator`
    from JHipster:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用JHipster的`ci-cd sub-generator`来为我们的项目创建`Jenkinsfile`：
- en: 'In a terminal, navigate to the online-store folder first. Now run the following
    command:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，首先导航到`online-store`文件夹。现在运行以下命令：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You will be asked to select from a list of options as follows:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将需要从以下列表中选择一个选项：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s select Jenkins pipeline from it. Next, we will have an option to choose
    additional stages:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从其中选择Jenkins流水线。接下来，我们将有一个选项来选择额外的阶段：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s skip this, as we won''t be needing these for now, and proceed. Next,
    we will be asked if we need to automatically deploy to Heroku from our CI/CD pipeline:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们跳过这一步，因为我们现在不需要这些，然后继续。接下来，我们将被询问是否需要从CI/CD流水线自动部署到Heroku：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's choose this option as we will need it later. Once the option is selected
    JHipster will generate the files and log the following output on the console.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们选择这个选项，因为我们稍后会用到它。一旦选择了选项，JHipster将生成文件并在控制台上记录以下输出。
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you want to use Travis instead of Jenkins you can do so by choosing the Travis
    option and then publishing the repository to GitHub as a public repository. Once
    published go to `https://github.com/<username>/<repoName>/settings/installations`
    and add Travis CI as a service and follow the instructions. You can now see automated
    builds when you make commits. Refer to [https://docs.travis-ci.com/user/getting-started/](https://docs.travis-ci.com/user/getting-started/)
    for details.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用Travis而不是Jenkins，你可以通过选择Travis选项，然后将仓库作为公开仓库发布到GitHub来实现。一旦发布，请转到`https://github.com/<username>/<repoName>/settings/installations`，添加Travis
    CI作为服务并按照说明操作。现在，当你提交时，你可以看到自动构建。有关详细信息，请参阅[https://docs.travis-ci.com/user/getting-started/](https://docs.travis-ci.com/user/getting-started/)。
- en: As you can see, we got a `Jenkinsfile` generated at the root and Docker image
    for Jenkins created in the `src/main/docker` directory. We also got an `idea.gdsl`
    file, which is used by IntelliJ Idea for autocompletion.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在根目录中生成了一个`Jenkinsfile`，在`src/main/docker`目录中创建了一个Jenkins的Docker镜像。我们还得到了一个`idea.gdsl`文件，该文件由IntelliJ
    Idea用于自动完成。
- en: The Jenkinsfile and its stages
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkinsfile及其阶段
- en: 'Let''s take a look at the generated `Jenkinsfile`, which has our pipeline definitions
    using the Groovy DSL:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看生成的`Jenkinsfile`，它使用Groovy DSL定义了我们的流水线：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have multiple stages defined running in a sequence, highlighted in bold;
    there are eight to be exact. It starts with a checkout of the branch from version
    control ending with deployment to Heroku (we will see more about this in the following
    chapter).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了多个按顺序运行的阶段，用粗体突出显示；确切地说有八个。它从从版本控制中检出分支开始，以部署到Heroku结束（我们将在下一章中了解更多关于这一点）。
- en: 'The steps are quite straightforward as most of it is just triggering a Gradle
    task. Let''s look at each of them:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤相当直接，因为其中大部分只是触发Gradle任务。让我们看看每一个：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `checkout` stage does a local checkout of the source code revision that
    triggered the build:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkout`阶段对触发构建的源代码修订版本进行本地检出：'
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This `check java` stage just prints the Java version installed on the Jenkins
    environment:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`check java`阶段只是打印出Jenkins环境中安装的Java版本：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `clean` stage first grants execution permission for the Gradle wrapper
    on a Unix-like OS and then executes the Gradle clean task. The `--no-daemon` flag
    disables the Gradle daemon feature, which is not required in a CI environment:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`clean`阶段首先在类Unix操作系统上为Gradle wrapper授予执行权限，然后执行Gradle clean任务。`--no-daemon`标志禁用了Gradle守护进程功能，这在CI环境中不是必需的：'
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `install tools` stage makes sure that NodeJS and all the NPM modules are
    installed by running `yarn` install via Gradle.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`install tools`阶段通过运行Gradle的`yarn install`确保安装了NodeJS和所有NPM模块。'
- en: 'The `-PnodeInstall` flag ensures that NodeJS is installed first if not done
    already:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`-PnodeInstall`标志确保如果尚未安装，首先安装NodeJS：'
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The **backend tests** stage runs all the server-side integration and unit tests
    by triggering the Gradle test task. It will fail the Jenkins pipeline when there
    is an error and register the test reports on the Jenkins web UI using the JUnit
    plugin after the test run is complete:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`backend tests`阶段通过触发Gradle测试任务运行所有服务器端集成和单元测试。如果出现错误，它将使Jenkins管道失败，并在测试运行完成后使用JUnit插件在Jenkins
    web UI上注册测试报告：'
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Similar to previously, the frontend tests stage runs the client-side unit tests
    by triggering the yarn test command via a `Gradle` task. It will also fail the
    pipeline on an error and register the test reports on the Jenkins web UI:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前类似，`frontend tests`阶段通过触发`Gradle`任务中的yarn test命令运行客户端单元测试。它也会在出现错误时使管道失败，并在测试运行完成后使用JUnit插件在Jenkins
    web UI上注册测试报告：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `packaging` stage triggers the `Gradle bootRepackage` task with the `prod`
    profile and archives the created WAR files with a unique fingerprint:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`packaging`阶段通过使用`prod`配置触发`Gradle bootRepackage`任务，并将创建的WAR文件存档，带有唯一的指纹：'
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The final stage is for `deployment` and it also uses a Gradle task for this.
    We will see this in detail in the following chapter. For now, let's comment out
    this stage. We will re-enable it later.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个阶段是用于`deployment`的，它也使用Gradle任务来完成。我们将在下一章中详细说明。现在，让我们注释掉这个阶段。我们稍后会重新启用它。
- en: 'Now let''s commit everything to `git` by running these commands. Make sure
    you are on the master branch, else `commit` and merge the branch with the master:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过运行这些命令将所有内容提交到`git`。确保你处于主分支，否则请将分支与主分支合并：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Setting up the Jenkinsfile in a Jenkins server
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Jenkins服务器上设置Jenkinsfile
- en: 'Now that our `Jenkinsfile` is ready, let''s set up CI/CD for our application.
    First, we need to upload our application to a GIT server, such as GitHub, GitLab,
    or BitBucket. Let''s use GitHub ([https://github.com/](https://github.com/)) for
    this. Make sure you have an account created in GitHub first:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的`Jenkinsfile`已经准备好了，让我们为我们的应用程序设置CI/CD。首先，我们需要将我们的应用程序上传到Git服务器，例如GitHub、GitLab或BitBucket。让我们使用GitHub
    ([https://github.com/](https://github.com/)) 来做这件事。确保你首先在GitHub上创建了一个账户：
- en: 'In GitHub, create a new repository ([https://github.com/new](https://github.com/new));
    let''s call it online-store. *Do not* check the Initialize this repository with
    a README option. Once created, you will see instructions to add code. Let''s go
    with the option of push an existing repository from the command line by running
    the following commands inside our online-store application folder. Do not forget
    to replace `<username>` with your actual GitHub username:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub中创建一个新的仓库 ([https://github.com/new](https://github.com/new))；让我们称它为online-store。*不要*选择“使用README初始化此仓库”选项。一旦创建，你将看到添加代码的说明。让我们选择通过在online-store应用程序文件夹内运行以下命令从命令行推送现有仓库的选项。不要忘记将`<username>`替换为你的实际GitHub用户名：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now go to the Jenkins server web UI by visiting `http://localhost:8989/` and
    create a new job using the **create new jobs** link.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过访问`http://localhost:8989/`进入Jenkins服务器web UI，并使用“创建新作业”链接创建一个新的作业。
- en: 'Enter a name, select Pipeline from the list, and click OK:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个名称，从列表中选择“Pipeline”，然后点击“确定”：
- en: '![](img/2e80a96e-257c-42c0-afe3-5098de2242fa.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2e80a96e-257c-42c0-afe3-5098de2242fa.png)'
- en: 'Then, on the next page, do the following:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在下一页上，执行以下操作：
- en: Scroll down or click on the Build Triggers section.
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动或点击“构建触发器”部分。
- en: Select the Poll SCM checkbox.
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“Poll SCM”复选框。
- en: Enter H/01 * * * * as the cron schedule value so that Jenkins polls our repository
    every minute and builds if there are new commits:![](img/16196b14-9c88-475d-a0b2-ec7e545fd80f.png)
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将cron计划值输入为H/01 ** ** ** **，以便Jenkins每分钟轮询我们的仓库，并在有新提交时构建：![图片](img/16196b14-9c88-475d-a0b2-ec7e545fd80f.png)
- en: 'Next, on the same page:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在同一页面上：
- en: Scroll down or click on the Pipeline section.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动页面或点击“管道”部分。
- en: Select Pipeline script from SCM for the Definition field from the drop-down
    menu.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择“从SCM选择管道脚本”作为定义字段。
- en: Select Git for the SCM field from the drop-down menu.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择“Git”作为SCM字段。
- en: Add the Repository URL for the application.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加应用的仓库URL。
- en: Finally, click Save:![](img/7bd7ba52-fc98-4b40-924f-2a5a1bde738e.png)
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击“保存”：![图片](img/7bd7ba52-fc98-4b40-924f-2a5a1bde738e.png)
- en: Click on Build Now to trigger a new build to test our pipeline:![](img/f4f6e27f-024e-4e2f-92be-a748bb6dc0fe.png)
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“立即构建”以触发新的构建来测试我们的管道：![图片](img/f4f6e27f-024e-4e2f-92be-a748bb6dc0fe.png)
- en: 'We should now see a build has started and its progress on the web UI as in
    the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该能在Web UI上看到构建已经开始，其进度如下截图所示：
- en: '![](img/3df6580a-8ea4-44ed-b74f-1289d8bc3377.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3df6580a-8ea4-44ed-b74f-1289d8bc3377.png)'
- en: Congratulations! We have successfully set up CI/CD for our application. The
    builds will get triggered when you make new commits as well.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们已经成功为我们的应用设置了CI/CD。当您提交新更改时，构建将被触发。
- en: 'You can also the view the pipeline status using the new UI from the Jenkins
    Blue Ocean plugin. Install the plugin from the Plugin Manager (Click on Jenkins
    in the top menu and go to Manage Jenkins | Manage Plugins  | Available and search
    for `Blue Ocean` and install it). The Open Blue Ocean link is available on the
    left-hand side menu. The builds will look as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用Jenkins Blue Ocean插件的新UI查看管道状态。从插件管理器安装插件（点击顶部菜单中的Jenkins，然后转到管理Jenkins
    | 管理插件 | 可用插件，搜索“Blue Ocean”并安装它）。左侧菜单上有“打开Blue Ocean”链接。构建将如下所示：
- en: '![](img/d289958e-4b4b-4fa5-b99d-c75e7030ad27.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d289958e-4b4b-4fa5-b99d-c75e7030ad27.png)'
- en: 'Click on a build to view the pipeline. You can click on each stage on the progress
    indicator to list the steps from that stage, and then expand the list items to
    view the logs from that step:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 点击一个构建来查看管道。您可以在进度指示器上点击每个阶段，列出从该阶段开始的步骤，然后展开列表项以查看该步骤的日志：
- en: '![](img/f2e88d7e-18eb-4f74-b4be-89c222a07b61.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f2e88d7e-18eb-4f74-b4be-89c222a07b61.png)'
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at what CI/CD is, and the tools supported by JHipster.
    We also learned how to set up Jenkins and created our CI/CD pipeline using JHipster
    and Jenkins. We also fixed our automated tests and made them run on the CI server.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了CI/CD是什么，以及JHipster支持的工具。我们还学习了如何设置Jenkins，并使用JHipster和Jenkins创建我们的CI/CD管道。我们还修复了我们的自动化测试，并使它们在CI服务器上运行。
- en: In the next chapter, we will see how to deploy our application to *production*
    using a cloud-hosting provider such as Heroku.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何使用云托管提供商（如Heroku）将我们的应用部署到**生产**环境。
