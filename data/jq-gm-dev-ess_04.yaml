- en: Chapter 4. Looking Sideways
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。横看成岭侧成峰
- en: It's now time to make a more complex game. We will implement a very popular
    genre, that of the 2D platform game. Some early examples of this genre are *Super
    Mario Bros* and *Sonic the Hedgehog*. These games are typically built using small
    repetitive sprites, called tile maps, for the level design. We will add these,
    as well as a more general collision detection, to our framework. For the game
    logic itself we will use object-oriented code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候制作一个更复杂的游戏了。我们将实现一个非常流行的类型，即 2D 平台游戏。这一类型的早期示例包括 *超级马里奥兄弟* 和 *索尼克小子*。这些游戏通常使用小型重复的精灵，称为瓦片地图，进行关卡设计。我们将添加这些内容，以及更通用的碰撞检测，到我们的框架中。对于游戏逻辑本身，我们将使用面向对象的代码。
- en: 'Here is a quick list of the features we will have to add to our framework:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将不得不添加到我们的框架中的功能的快速列表：
- en: Offline divs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离线 div
- en: Groups
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分组
- en: Sprite transformation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精灵变换
- en: Tile maps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 瓦片地图
- en: Collision detections
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: We will first begin by going through all of these, and will then start with
    the game.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将逐个遍历所有这些，然后开始游戏。
- en: Offline divs
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 离线 div
- en: As explained at the end of the previous chapter, avoiding reflow is a good way
    to speed things up. It's not always easy to completely avoid querying the state
    of the DOM during your manipulations. And even if you are very careful, as a framework
    developer, you are never sure what the user of your framework will do. However,
    there is a way to reduce the negative effect of a reflow; detach the piece of
    DOM you are working on, modify it, and then attach it back to the document.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章节末尾所解释的那样，避免重排是加快速度的好方法。在进行操作时完全避免查询 DOM 状态并不总是容易的。即使您非常小心，作为框架开发者，您也永远不确定您的框架的用户会做什么。然而，有一种方法可以减少重排的负面影响；分离您正在操作的
    DOM 片段，修改它，然后将其重新附加到文档中。
- en: 'Let''s say you have a node with the ID `box` and want to manipulate its child
    elements in a complex manner. The following code shows you how to detach it:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个带有 ID `box` 的节点，并且想要以复杂的方式操纵其子元素。以下代码向您展示了如何分离它：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This requires a small modification of our framework's API; until now, we used
    a string to identify sprites. This has the side effect of requiring the sprite
    to be part of the document. For example, if you call `gf.x("sprite")`, jQuery
    will try to find a node with the ID `sprite` in the document. If you detach the
    sprite or one of its parents, the function won't find its ID.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要对我们的框架 API 进行小的修改；到目前为止，我们使用字符串来标识精灵。这会导致需要将精灵作为文档的一部分。例如，如果您调用 `gf.x("sprite")`，jQuery
    将尝试在文档中查找 ID 为 `sprite` 的节点。如果分离精灵或其父级之一，则该函数将找不到其 ID。
- en: The solution is simply to provide the DOM node itself to our framework's functions.
    As we use jQuery, we will wrap this node in jQuery. Let's compare the current
    API and the proposed one for the `gf.x` function.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案很简单，只需将 DOM 节点本身提供给我们框架的函数。由于我们使用 jQuery，因此我们将在 jQuery 中包装此节点。让我们比较当前 API
    和提议的 `gf.x` 函数的 API。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This solution has another advantage; it allows for further optimization. If
    we look at the implementation of this function, we will find another problem:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此解决方案还有另一个优点；它允许进一步优化。如果我们看一下此函数的实现，我们会发现另一个问题：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can see that each time the function is called, jQuery is used to retrieve
    the element. Any access to the DOM (even using the element's ID in the selector)
    to find the element has a performance cost. Ideally, if the concerned element
    is used more than a few times, you may want to cache it to improve performance.
    This is made possible with the proposed API.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用函数时，都可以看到 jQuery 被用于检索元素。任何对 DOM 的访问（即使在选择器中使用元素的 ID 来查找元素）都会产生性能成本。理想情况下，如果相关元素被使用超过几次，您可能希望对其进行缓存以提高性能。这是由所提出的
    API 可能实现的。
- en: 'The implementation is pretty straightforward, so we will only show the `gf.x`
    function:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 实现非常简单，因此我们将只显示 `gf.x` 函数：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Groups
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分组
- en: 'It''s very convenient to organize the elements of your game in a hierarchical
    manner. A typical game could be organized this way:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将游戏元素以分层方式组织起来非常方便。一个典型的游戏可以这样组织：
- en: '![Groups](img/5060OT_04_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![分组](img/5060OT_04_01.jpg)'
- en: To allow this, we need to add a very simple thing called groups to our framework.
    A group is basically a simple div, positioned exactly like a sprite, but has no
    background and no width and height. We will add a `gf.addGroup` function to do
    this for us. Its signature will be the same as that of `gf.addSprite`, but the
    options argument will only hold *x* and *y* coordinates.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许这一点，我们需要向我们的框架添加一个非常简单的东西，称为组。组基本上是一个简单的 div，位置与精灵完全相同，但没有背景和宽度和高度。我们将添加一个
    `gf.addGroup` 函数来为我们执行此操作。它的签名将与 `gf.addSprite` 的签名相同，但选项参数将仅保存 *x* 和 *y* 坐标。
- en: 'The following example shows you how to generate the tree shown in the previous
    figure:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例向您展示了如何生成前面图示中显示的树：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The implementation of this function is very similar to that of `gf.addSprite`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能的实现与 `gf.addSprite` 的实现非常相似：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Having multiple entities on our game screen makes it necessary to have a simple
    way to differentiate between them. We could use a flag in the object literal associated
    with the node through the `$.data` function, but we will instead use CSS classes.
    This has the advantage of making it very easy to retrieve or filter all the elements
    of one type.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏屏幕上有多个实体使得有一个简单的方法来区分它们成为必要。我们可以在通过 `$.data` 函数与节点关联的对象字面量中使用标志，但我们将改用
    CSS 类。这有一个优点，就是可以非常容易地检索或过滤所有相同类型的元素。
- en: To implement this, we just have to change the fragments for sprites and groups.
    The name we will give to the CSS class will be namespaced. Namespacing in CSS
    is simply done with a prefix in the class name. For example, we will give our
    sprites the class `gf_sprite`; this will minimize the chance that another plugin
    uses the same class, in contrast to, say, `sprite`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们只需改变精灵和组的片段。我们将给 CSS 类命名为命名空间。在 CSS 中，命名空间简单地在类名中加上前缀。例如，我们将给我们的精灵添加类
    `gf_sprite`；这将最大程度地减少另一个插件使用相同类的机会，与 `sprite` 相比。
- en: 'The new fragment will look like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 新的片段看起来像这样：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now if you want to find all the children that are sprites, you can write something
    like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您想要查找所有子精灵，您可以这样写：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Sprite transformation
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精灵变换
- en: There are many situations where you will want to transform your sprites in simple
    ways. You may want, for example, to make them bigger or smaller or to rotate or
    flip them. The most convenient method for doing this is by using CSS transforms.
    In the last few years, CSS transforms have become well supported by most browsers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况下，您将希望以简单的方式转换您的精灵。例如，您可能希望使它们变大或变小，或者旋转或翻转它们。实现这一点的最方便的方法是使用 CSS 变换。在过去几年中，大多数浏览器都已很好地支持
    CSS 变换。
- en: If you decide to use this feature, you just have to realize that versions before
    Microsoft Internet Explorer 9 do not support it. There is the possibility to use
    the proprietary `filter` CSS property, but in most cases, it's way too slow.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定使用此功能，您只需意识到 Microsoft Internet Explorer 9 之前的版本不支持它。有可能使用专有的 `filter`
    CSS 属性，但在大多数情况下，这太慢了。
- en: Another possibility is that of using a technique used in some of the old 8-bit
    and 16-bit games. You can simply generate the images for the transformed sprite.
    This has the advantage of being very fast and being compatible with all browsers.
    On the other hand, it will increase the size of your artworks and requires you
    to regenerate all the transformations if you need to change your sprite at some
    point.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能性是使用一些旧的 8 位和 16 位游戏中使用的技术。您只需为变换后的精灵生成图像。这有很快的优势，并且与所有浏览器兼容。另一方面，它会增加您艺术品的大小，并且如果您需要在某个时候更改您的精灵，则需要重新生成所有的变换。
- en: We will here only implement the CSS transform solution because in most situations
    it's acceptable to target modern browsers only.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将仅实现 CSS 变换解决方案，因为在大多数情况下，仅针对现代浏览器是可接受的。
- en: CSS transform
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS 变换
- en: There are many transformations that are possible in CSS, even 3D ones (you can
    take a look at [https://github.com/boblemarin/Sprite3D.js](https://github.com/boblemarin/Sprite3D.js)
    for some very good examples of this), but we will stick to rotation and scaling.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 有许多可能的变换，甚至是 3D 变换（您可以查看 [https://github.com/boblemarin/Sprite3D.js](https://github.com/boblemarin/Sprite3D.js)
    以获取一些非常好的示例），但我们将坚持旋转和缩放。
- en: In most browsers, the CSS property "transform" is vendor prefixed. This means
    that in Safari, for example, it will be called `-webkit-transform`, and in Firefox,
    `-moz-transform`. Working with properties of this kind used to be a real pain,
    but with jQuery 1.8, you can simply forget about it and act as if there was no
    prefix. jQuery will take care of using the correct prefix where it needs it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数浏览器中，CSS属性“transform”都是供应商前缀的。意思是，在Safari中，它将被称为`-webkit-transform`，而在Firefox中，将是`-moz-transform`。以往处理这类属性是一件真正痛苦的事情，但使用jQuery
    1.8，你可以简单地忘记它，就像没有前缀一样。jQuery会在需要时自动使用正确的前缀。
- en: 'As explained before, there are many values that this property can take, and
    we will focus on two here: `rotate` and `scale`. The syntax for `rotate` is as
    follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所解释的，这个属性可以取许多值，我们将在这里专注于`rotate`和`scale`两个：`rotate`的语法如下：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, `angle` is a clockwise angle expressed with its unit, either degrees or
    radians (abbreviated respectively as **deg** and **rad**). The rotation is done
    around the origin of the element, by default, its center. This is what you want
    in a game most of the time, but if you want to change it for some reason, you
    can simply use the `transform-origin` CSS properties to do so.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`angle`是以**deg**或**rad**（分别缩写为度和弧度）表示的顺时针角度。旋转默认是围绕元素的原点进行的，大多数情况下，这是你希望的，但如果出于某种原因你想要改变它，你可以简单地使用`transform-origin`
    CSS属性来实现。
- en: 'For example, if you want to rotate your element 10 degrees counterclockwise
    you would write:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想要逆时针旋转你的元素10度，你会写：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It would look like this if your element were a red square:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的元素是一个红色的正方形，它会像这样：
- en: '![CSS transform](img/5060OT_04_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![CSS transform](img/5060OT_04_02.jpg)'
- en: 'The way `scale` works is very similar, but it has two possible syntaxes:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`scale`的工作方式非常相似，但具有两种可能的语法：'
- en: '`transform: scale(ratio)`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transform: scale(ratio)`'
- en: '`transform: scale(ratio_x, ratio_y)`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transform: scale(ratio_x, ratio_y)`'
- en: If you specify only one value, the result will be an isotropic transformation;
    in other words, of equal magnitude along both axes. On the contrary, if you specify
    two values, the first will scale along the x axis and the second one along the
    y axis (anisotropic transformation). The following figure illustrates the difference
    between those two.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只指定一个值，结果将是各向同性的变换；换句话说，沿着两个轴的大小是相等的。相反，如果你指定两个值，第一个将沿着x轴缩放，第二个将沿着y轴缩放（各向异性变换）。下图说明了这两者之间的区别。
- en: '![CSS transform](img/5060OT_04_03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![CSS transform](img/5060OT_04_03.jpg)'
- en: In our case, we will not include arbitrary anisotropic scaling into our framework,
    but we will still use the two-value syntax because it will allow us to flip our
    sprites; indeed, if we write `scale(-1,1)`, this will in effect mean "flip the
    element along the x axis (horizontally) and leave it unchanged along the y axis".
    Of course, this works with values other than 1; as long as the magnitude of the
    two values is the same, you will only flip the sprite and not change its aspect
    ratio.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将不包括任意的各向异性缩放到我们的框架中，但我们仍将使用双值语法，因为这将允许我们翻转我们的精灵；的确，如果我们写`scale(-1,1)`，这实际上意味着“横向翻转元素并保持纵向不变”。当然，这对于除1之外的值也适用；只要两个值的大小相同，你只会翻转精灵而不改变其长宽比。
- en: 'These two values for the transform property work well together, so if you wanted
    to rotate an element 10 degrees counterclockwise, flip it vertically, and make
    it twice as large, you would write:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于transform属性的这两个值，很好地配合在一起，所以如果你想要将一个元素逆时针旋转10度，垂直翻转它，并使其大小加倍，你会这样写：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Adding transform to the framework
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将transform添加到框架中
- en: 'Now we have to write a function that does this for us. As with most of our
    framework''s functions, we will use an object literal to hold the optional arguments
    and give the node to which the function applies as a first argument. A call to
    this function to generate the example is as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须写一个函数来代替我们完成这个工作。与我们框架的大多数函数一样，我们将使用对象字面量来保存可选参数，并将函数应用于的节点作为第一个参数。调用这个函数来生成示例的示例为：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The angle is in degrees and the `flipH` and `flipV` options are Boolean values.
    The values of the omitted parameters (`flipH`, in this example) won''t default
    to a general value; what we will do instead is to take the current value of this
    parameter for the given element. This will allow you to call the transform function
    twice and change two different parameters without having to know what the other
    call is doing. For example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 角度以度为单位，`flipH`和`flipV`选项是布尔值。省略的参数的值（在本例中是`flipH`）将不会默认为常规值；相反，我们将采用给定元素的该参数的当前值。这将允许您两次调用变换函数并改变两个不同的参数，而无需知道另一个调用正在做什么。例如：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will, however, mean that we won't be able to use the `$.extend` function
    like we used to. Instead, we will have to manually check the stored value of the
    undefined parameters for the given elements.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这意味着我们将无法像过去那样使用`$.extend`函数。相反，我们将不得不手动检查给定元素的未定义参数的存储值。
- en: 'These values will be stored in the object literal associated with the `gf`
    key, which is associated with our element that has the `$.data` function. That
    also means that we will need to define the default value for those properties
    when we create the sprite (or group). For example, the `addSprite` function will
    start with:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值将存储在与`gf`键关联的对象文字中，该键与具有`$.data`函数的元素相关联。这也意味着在创建精灵（或组）时，我们需要为这些属性定义默认值。例如，`addSprite`函数将以以下方式开始：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once you''ve understood the way in which the CSS `transform` property works,
    the implementation of our `gf.transform` function will be pretty straightforward:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了CSS `transform`属性的工作方式，实现我们的`gf.transform`函数将变得非常简单：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once again, this is a simple function that will provide great functionality
    and allow us to create neat effects in our games. Depending on your game, you
    may want to add the anisotropic scaling to it or even 3D transform, but the basic
    structure and API of the function can remain the same.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 再一次，这是一个简单的函数，会提供出色的功能，并允许我们在游戏中创建整洁的效果。根据你的游戏，你可能希望将各向异性缩放加入其中，甚至是3D转换，但函数的基本结构和API可以保持不变。
- en: Tile maps
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 瓦片地图
- en: Tile maps are a very common tool for making lots of games. The idea behind it
    is that most levels are made of similar parts. The ground, for example, is likely
    to repeat itself a lot, with a few variations; there will be a few kinds of different
    trees repeated many times, and a few items such as stones and flowers or grass
    will appear many times, represented by the exact same sprite.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 瓦片地图是制作许多游戏的常用工具。其背后的理念是大多数关卡由类似的部分组成。例如，地面很可能会重复很多次，只是有少许变化；会有几种不同的树反复出现很多次，以及一些物品，如石头、花或草将以完全相同的精灵表示多次出现。
- en: This means that using one big image to describe your level is not the most efficient
    solution size-wise. What you really want is to be able to give a list of all the
    unique elements and then describe how they are combined to generate your level.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着使用一个大图像来描述你的关卡并不是以空间为最有效的解决方案。你真正想要的是能够给出所有唯一元素的列表，然后描述它们如何组合生成你的关卡。
- en: Tile maps are the simplest implementation of this. They add a constraint though;
    all elements must be of the same size and placed on a grid. If you can work with
    those constraints, this solution becomes very efficient; that's the reason why
    so many old games were created with it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 瓦片地图是最简单的实现方式。但是它增加了一个限制；所有元素都必须具有相同的大小并放置在网格上。如果你能够适应这些约束，这种解决方案将变得非常高效；这就是为什么那么多老游戏都是用它创建的原因。
- en: We will start by implementing a very naive version of it and then show, at the
    end of the chapter, how we can make it faster in most situations without too much
    work.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从实现一个非常天真的版本开始，然后在本章末尾展示如何在大多数情况下以不太多的工作快速实现它。
- en: 'To sum up, a tile map is made up of:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 总而言之，瓦片地图由以下组成：
- en: A series of images (what we call animations in our framework)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列图片（我们在框架中称之为动画）
- en: A bi-dimensional array describing what image goes where
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个描述图像放置位置的二维数组
- en: 'The following figure illustrates this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了这一点：
- en: '![Tile maps](img/5060OT_04_04.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![瓦片地图](img/5060OT_04_04.jpg)'
- en: 'In addition to being useful for reducing the size of your game, tile maps offer
    the following advantages:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 除了有助于减小游戏尺寸之外，瓦片地图还提供以下优点：
- en: Detecting collisions with a tile map is very easy.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测与瓦片地图的碰撞非常容易。
- en: The array that describes how the tile map looks also contains semantic information
    about the level. For example, tiles 1 to 3 are ground tiles, while 4 to 6 are
    part of the scenery also. This will allow you to easily "read" the level and react
    to it.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述瓦片地图外观的数组还包含关于级别的语义信息。例如，瓦片1到3是地面瓦片，而4到6是景观的一部分。这将使您能够轻松“阅读”级别并对其做出反应。
- en: It's very simple to generate random variation of levels. Just create the bi-dimensional
    array with a few rules, and your game will be different each time the player starts
    again!
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成不同层次的随机变化非常简单。只需按照几条规则创建二维数组，每次玩家重新开始游戏时，游戏都会有所不同！
- en: Lots of open-source tools exist that help you create them.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在许多开源工具可帮助您创建它们。
- en: 'However, you have to realize that there are some constraints too:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您必须意识到也有一些约束：
- en: As all the elements composing the tile map have the same size, if you want to
    create a bigger element, you will have to decompose it into smaller parts, which
    could be tedious.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于组成瓦片地图的所有元素大小相同，如果要创建更大的元素，则必须将其分解为较小的部分，这可能会很繁琐。
- en: Even if done with a lot of talent, it will give a certain continual look to
    your game. If you want to avoid having some blocks that repeat around your level,
    tile maps are not for you.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使具有很多才华，它也会给您的游戏带来一定的连续外观。如果您不想在级别周围重复一些块，则瓦片地图不适合您。
- en: Naive implementation
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 朴素的实现
- en: We already know how to create a sprite, so basically what we need in order to
    create a tile map is to generate the sprites that compose it. Just like `gf.addSprite`,
    our `gf.addTilemap` function will take the parent div, the ID of the generated
    tile map, and an object literal describing the options.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何创建精灵，所以基本上我们需要为创建瓦片地图生成组成它的精灵。就像`gf.addSprite`一样，我们的`gf.addTilemap`函数将接受父div、生成的瓦片地图的ID以及描述选项的对象字面量。
- en: The options are the position of the tile map, the dimension of each tile, and
    the number of tiles that compose the tile map horizontally and vertically, the
    list of animations, and the bi-dimensional array describing the tile position.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 选项是瓦片地图的位置、每个瓦片的尺寸、以及横向和纵向组成瓦片地图的瓦片数量、动画列表和描述瓦片位置的二维数组。
- en: 'We will iterate through the bi-dimensional array and create the sprite as needed.
    It''s often convenient to have places without sprites in our tile map, so we will
    use the following conventions:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遍历二维数组，并根据需要创建精灵。在我们的瓦片地图中有些地方没有精灵往往是很方便的，因此我们将使用以下约定：
- en: If all the entries have zeroes, it means that no sprites need to be created
    at this place
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果所有条目都是零，则意味着不需要在此位置创建精灵
- en: If all the places have a number greater than zero, it means that a sprite with
    an animation at the index corresponding to this number minus one in the animation
    array should be created
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果所有地方的数字都大于零，则表示应创建一个带有动画的精灵，该动画位于动画数组中对应此数字减一的索引处
- en: This is typically a place where you want to create your complete tile map before
    adding it to the document. We will use a cloned fragment to generate the `div`
    tag holding all the tiles and add to it the cloned fragment we used for sprites
    too. Only once all the tiles are created will we add the tile map to the document.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是您希望在将其添加到文档之前创建完整瓦片地图的地方。我们将使用克隆的片段来生成包含所有瓦片的`div`标签，并将我们用于精灵的克隆片段添加到其中。只有在创建所有瓦片后，我们才会将瓦片地图添加到文档中。
- en: 'There is one more subtlety here. We will add two classes to our tiles, one
    that marks which columns the tile belong to, and another that marks which row
    it belongs to. Other than that, there are no big subtleties in the code for now:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个微妙之处。我们将向我们的瓦片添加两个类，一个标记瓦片所属的列，另一个标记瓦片所属的行。除此之外，目前代码中没有其他重要的细节：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That's it for now. This will generate the whole tile map at initialization time.
    This means that very large tile maps will be slow. We will see at the end of the
    chapter how to generate only the part of the tile map that is visible.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。这将在初始化时生成整个瓦片地图。这意味着非常大的瓦片地图会很慢。在本章末尾，我们将看到如何仅生成可见部分的瓦片地图。
- en: Collision detection
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: This is a very important part of our framework, and we will start by looking
    at how we will do this for the case of a sprite colliding with the tile map. This
    situation has the advantage of being easier than the general case, but still using
    most of the same basic ideas. We will, however, stick with axis-aligned elements.
    This means that collision with rotated elements will not be shown here.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '这是我们框架的一个非常重要的部分，我们将从精灵与瓦片地图碰撞的情况开始看看我们将如何做到这一点。这种情况有一个好处，即比一般情况更容易，但仍然使用了大部分相同的基本思想。然而，我们将坚持轴对齐元素。这意味着不会在此处显示与旋转元素的碰撞。  '
- en: Colliding with tile maps
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与瓦片地图碰撞
- en: 'Finding which tiles of a tile map collide with a sprite can be divided into
    two parts. First find a box representing the intersection of the two. Then, list
    all the sprites in this box. A list of some of the possible intersections is shown
    in red in the following figure:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 找到与精灵碰撞的瓦片地图的瓦片可以分为两部分。首先找到表示两者交集的框。然后，列出此框中的所有精灵。下图中以红色显示了一些可能的交叉点列表：
- en: '![Colliding with tile maps](img/5060OT_04_05.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![与瓦片地图碰撞](img/5060OT_04_05.jpg)'
- en: This may at first seem complicated, but it becomes much easier if you consider
    that it's the exact same problem as finding two one-dimensional intersections
    (one for each axis).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始可能会觉得复杂，但是如果你考虑到这与寻找两个一维交叉点（每个轴一个）完全相同的问题，那就会变得容易得多。
- en: 'You may not have realized it, but we used a simplified version of one-dimensional
    intersections in our *Frogger* clone to detect collisions. The following figure
    shows what a typical one-dimensional intersection, **i**, of two segments, **a**
    and **b**, would look like:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能没有意识到，在我们的*青蛙过河*克隆中，我们使用了一维交叉的简化版本来检测碰撞。下图显示了两个段，**a**和**b**的典型一维交叉**i**的样子：
- en: '![Colliding with tile maps](img/5060OT_04_06.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![与瓦片地图碰撞](img/5060OT_04_06.jpg)'
- en: 'In this situation, the intersection is simply the second element as it''s completely
    contained in the first one. The following figure shows you three other possible
    situations:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，交叉点只是第二个元素，因为它完全包含在第一个元素中。下图显示了另外三种可能的情况：
- en: '![Colliding with tile maps](img/5060OT_04_07.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![与瓦片地图碰撞](img/5060OT_04_07.jpg)'
- en: One way to solve the problem is to express the solution from the point of view
    of the second element. Two points will define the interval; let's call the left-most
    point `i1` and the right-most `i2`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是从第二个元素的角度来表达解决方案。两个点将定义区间；我们将最左边的点称为`i1`，最右边的点称为`i2`。
- en: Let's first consider the situation where such an intersection really exists,
    where the two elements are touching. You will probably see that `i1` is the bigger
    point between `a1` and `b1`. In the same manner, `i2` is the smaller point between
    `a2` and `b2`. However, what if the two intervals don't intersect? We will simply
    return `i1=b1` and `i2=b1` if the interval `a` is at its left, and `i1=b2` and
    `i2=b2` if the interval `a` is at its right. To compute this, we just have to
    constrain the result for `i1` and `i2` between `b1` and `b2`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先考虑这样一个情况，即确实存在这样的交叉点，两个元素相互接触。您可能会发现`i1`是`a1`和`b1`之间的较大点。以同样的方式，`i2`是`a2`和`b2`之间的较小点。但是，如果两个区间不相交怎么办？如果区间`a`在其左侧，我们将简单地返回`i1=b1`和`i2=b1`，如果区间`a`在其右侧，我们将返回`i1=b2`和`i2=b2`。为了计算这个，我们只需要将`i1`和`i2`的结果约束在`b1`和`b2`之间。
- en: 'The resulting function would look as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 结果函数如下所示：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The good part is that we only use two comparisons for each point. Now we can
    apply this to our two-dimensional problem. The following figure shows you how
    to decompose the box intersection into two line intersections:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 好处是我们每个点只使用两次比较。现在我们可以将此应用于我们的二维问题。下图显示了如何将框交叉分解为两个线交叉点：
- en: '![Colliding with tile maps](img/5060OT_04_08.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![与瓦片地图碰撞](img/5060OT_04_08.jpg)'
- en: Finding the colliding tiles
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寻找碰撞瓦片
- en: 'Now we will write a function that takes a sprite and a tile map. It will then
    find the intersections for both axes: x1 to x2 and y1 to y2\. Now the point (x1,
    y1) will be the upper-left corner of the intersection box, and the point (x2,
    y2) will be the lower-right corner.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写一个函数，它接受一个精灵和一个瓦片地图。然后，它将为两个轴找到交叉点：x1到x2和y1到y2。现在点（x1，y1）将是交集框的左上角，点（x2，y2）将是右下角。
- en: 'However, what we really want for tile maps is not the coordinates but the indexes
    in the bi-dimensional array. Therefore, we will first transform the coordinate
    so that the point of origin is the upper-left corner of the tile map. Then, we
    will divide the new coordinates according to the width and the respective height
    of a single tile. After rounding the result of this operation, we will have the
    indexes of the upper-left and lower-right tiles that compose the intersecting
    box:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在砖块地图中真正想要的不是坐标，而是二维数组中的索引。因此，我们将首先转换坐标，使原点是瓦片地图的左上角。然后，我们将根据单个瓦片的宽度和相应的高度来划分新坐标。在执行此操作的结果四舍五入后，我们将得到组成相交框的左上角和右下角瓦片的索引：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We will now use this result in the collision detection function. We simply have
    to list all the tiles between those two points. We will use the bi-dimensional
    array to find all non-zero entries and then use the classes we defined for the
    line and column to find our tiles.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在碰撞检测函数中使用这个结果。我们只需列出这两个点之间的所有瓦片。我们将使用二维数组来查找所有非零条目，然后使用我们为线和列定义的类来找到我们的瓦片。
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will allow us to find all the tiles colliding with a sprite, but we have
    to be careful that the coordinate that we give for the sprite and the tile map
    are correct. If the sprite is in a group that is moved ten pixels to the right,
    we will have to add ten to the value of the x coordinate of the sprite; otherwise,
    the collision detection method will not notice it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们找到与精灵发生碰撞的所有瓦片，但我们必须确保我们为精灵和瓦片地图提供的坐标是正确的。如果精灵在一个向右移动了十个像素的组中，我们将不得不将十添加到精灵的
    x 坐标值；否则，碰撞检测方法将不会注意到它。
- en: We could write a version of this function that looks at the coordinates of all
    of the sprites and tile maps to find what their relative offset is. This makes
    the function slightly slower and a bit more complex, but you should be able to
    do it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个版本的这个函数，它查看所有精灵和瓦片地图的坐标，以找出它们的相对偏移量。这会使函数稍微慢一些，稍微复杂一些，但你应该能够做到。
- en: Sprite versus sprite collision
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 精灵与精灵的碰撞
- en: The function to detect whether two sprites collide or not will use the same
    one-dimensional intersection function we just wrote. To have a collision between
    the two sprites, we must have a collision on both one-dimensional projections.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 用于检测两个精灵是否发生碰撞的函数将使用我们刚刚编写的同一维度交集函数。要使两个精灵发生碰撞，我们必须在两个一维投影上都发生碰撞。
- en: If the interval returned by the `gf.intersect` function has a length of zero
    (both values are equals), it means that the two sprites collide on this axis.
    To have a collision between the two sprites, both projections have to collide.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `gf.intersect` 函数返回的间隔长度为零（两个值相等），则表示这两个精灵在此轴上发生碰撞。要使两个精灵发生碰撞，两个投影都必须发生碰撞。
- en: 'The implementation of our function is very simple as most of the logic is contained
    in the `gf.intersect` function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数实现非常简单，因为大部分逻辑都包含在 `gf.intersect` 函数中：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Coding the game
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写游戏
- en: We now have all the tools we need to start our game. For this game, we will
    use the wonderful artworks by Kenney Vleugels ([http://www.kenney.nl](http://www.kenney.nl)).
    It will be a classical platformer where the player can move around and jump.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了开始游戏所需的所有工具。对于这个游戏，我们将使用 Kenney Vleugels 的精美艺术作品（[http://www.kenney.nl](http://www.kenney.nl)）。这将是一个经典的平台游戏，玩家可以在其中移动和跳跃。
- en: 'There will be two kinds of enemies, a sort of blob and a flying insect. For
    the sake of simplicity, the player is immortal and kills the enemies as soon as
    it touches them. We will describe here each part of the game in the following
    order:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将有两种类型的敌人，一种是一种类似于斑点的物体，另一种是一种飞行昆虫。为了简单起见，玩家是不朽的，并在接触到敌人时将其杀死。我们将按以下顺序描述游戏的每个部分：
- en: Basic setup of the game screen
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏屏幕的基本设置
- en: Object-oriented code for the player
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于玩家的面向对象代码
- en: Player control
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家控制
- en: Parallax scrolling
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视差滚动
- en: Enemies
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敌人
- en: Basic setup of the game screen
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏屏幕的基本设置
- en: 'This is very similar to what we did for the *Frogger* clone. Here is how we
    will organize the game screen:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们为 *Frogger* 克隆所做的非常相似。以下是我们将组织游戏屏幕的方式：
- en: '![Basic setup of the game screen](img/5060OT_04_09.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![游戏屏幕的基本设置](img/5060OT_04_09.jpg)'
- en: We will have a lot of animations in this game; three for the player, three for
    each of the two enemies' seven tiles, and two background animations. To make things
    more readable, we will regroup them. The animations for the player and enemies
    will each be stored in an object literal, and the animations for the tiles will
    be stored in an array.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中我们将有很多动画；玩家有三个，每个敌人有三个，两个背景动画有两个。为了使事情更加可读，我们将对它们进行分组。玩家和敌人的动画将分别存储在对象字面量中，而瓷砖的动画将存储在数组中。
- en: 'Here is an extract of our code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们代码的一部分摘录：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Object-oriented code for the player
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家的面向对象代码
- en: There are many reasons you may want to use object-oriented (OO) code in your
    game. First, it's a very good way to organize your code. Second, it provides some
    useful ways to reuse and extend your code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的游戏中使用面向对象(OO)代码有许多原因。首先，这是组织代码的非常好的方式。其次，它提供了一些有用的方式来重用和扩展您的代码。
- en: If you are not familiar with OO programming, JavaScript is probably not the
    best language to learn. We won't go into the theory of OO; even without it, you
    should be able to see the logic behind the code we will be writing and what it
    brings to the table.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉面向对象编程，JavaScript可能不是学习的最佳语言。我们不会深入讨论OO的理论；即使没有，你也应该能够看到我们将要编写的代码背后的逻辑以及它带来了什么。
- en: As we need only one player, we will create an anonymous class and instantiate
    it right away. This is quite unusual and only makes sense in this particular situation.
    Here is the skeleton of our class with all methods, but without their implementation.
    We will look at each of them later.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只需要一个玩家，我们将创建一个匿名类并立即实例化它。这相当不寻常，只在这种特殊情况下才有意义。这是我们类的框架，具有所有方法，但没有它们的实现。我们稍后将逐个查看它们。
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, we begin by defining a few variables that we will use later,
    and then define the object's methods.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们首先定义了一些稍后将要使用的变量，然后定义了对象的方法。
- en: Updating the player's position
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新玩家的位置
- en: We have implemented a very basic physic simulation for player movement along
    the y axis; if no collision occurs, the avatar will fall with a given acceleration
    and with a limited maximum speed. This is sufficient to generate neat jump trajectories.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为玩家沿y轴的移动实现了一个非常基本的物理模拟；如果没有碰撞发生，头像将以给定的加速度和有限的最大速度下落。这足以生成整洁的跳跃轨迹。
- en: 'Let''s have a look at what the `update` function does. First, it needs to compute
    the avatar''s next position:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`update`函数做了什么。首先，它需要计算头像的下一个位置：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can see in this code that we compute the speed; this is the vertical speed
    of the player. We use the correct physical rule here, where the speed after a
    time interval is equal to *the previous speed plus the acceleration time of the
    interval*. It's then constrained between -100 and 100 to simulate the terminal
    velocity. Here, the acceleration is constant, as is the gravitational pull.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，你可以看到我们计算了速度；这是玩家的垂直速度。我们在这里使用了正确的物理规则，即时间间隔后的速度等于*前一个速度加上时间间隔的加速度*。然后将其限制在-100到100之间，以模拟终端速度。在这里，加速度是恒定的，重力也是如此。
- en: Then we use this speed to compute the next position along the y axis, again
    with the correct physical rule.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用这个速度来计算沿y轴的下一个位置，同样使用正确的物理规则。
- en: The new position along the x axis is much simpler; it's the current position
    modified by the horizontal movement induced by player control (we will see later
    exactly how this value is generated).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 沿x轴的新位置要简单得多；它是由玩家控制引起的水平移动修改后的当前位置（我们稍后将看到这个值是如何生成的）。
- en: Then we need to check for collision to see if the avatar can really go where
    it wants or whether there is something on the way. For this, we will use the `gf.tilemapCollision`
    method we wrote earlier.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要检查碰撞以查看头像是否真的可以去想去的地方，或者是否有障碍物。为此，我们将使用之前编写的`gf.tilemapCollision`方法。
- en: Once we have all the tiles that collide with our sprite, what can we do? We
    will look at any of them and move the sprite out of their way through the shortest
    possible movement. To do this, we will compute the exact intersection between
    the sprite and the tile and find whether its width or height is its larger dimension.
    If the width is more than the height, it means it's a shorter move on the y axis,
    and if the height is more than the width, it's a shorter move on the x axis.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们拥有所有与我们的精灵碰撞的瓷砖，我们可以做什么？我们将查看其中任何一个并通过最短可能的移动将精灵移出它们的路径。为此，我们将计算精灵与瓷砖之间的确切交叉点，并找出其宽度或高度哪个是其较大的尺寸。如果宽度大于高度，则意味着在y轴上移动较短，如果高度大于宽度，则在x轴上移动较短。
- en: 'If we do this for all tiles, we will have moved the avatar to a place where
    it doesn''t collide with any tiles. Here is the full code of what we just described:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对所有瓷砖都这样做，我们将把角色移到一个不与任何瓷砖碰撞的位置。这是我们刚刚描述的全部代码：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You will notice that if we detect that we need to move the player upward along
    the y axis, we change the avatar animation and status if the player is jumping.
    This is simply because this means that the player has landed on the ground.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，如果我们检测到我们需要沿y轴向上移动玩家，我们会改变角色动画和状态，如果玩家正在跳跃，这仅仅是因为这意味着玩家已经着陆。
- en: This code alone is enough to contain all the rules you need to produce a decent
    movement of the player in the level.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码足以包含你在关卡中制作出一个体面的玩家移动所需的所有规则。
- en: Controlling the player's avatar
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制玩家的角色
- en: All methods except `update` directly correspond to particular types of input
    from the player. They will be called during the main loop after the corresponding
    key has been detected as pressed. If no keys are pressed, the idle function will
    be called.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`update`之外的所有方法都直接对应于玩家的特定输入类型。它们将在主循环中在相应的键被检测为按下后被调用。如果没有键被按下，将调用空闲函数。
- en: 'Let''s have a look at the function that moves the player to the left:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下将玩家向左移动的函数：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Its main part is a switch because we will react differently depending on the
    state of the player. If the player is currently standing, we will need to change
    the animation to walking, set the player's new state, and move the player along
    the x axis. If the player is jumping, we just move the player along the x axis
    (but slightly slower). If the player is already walking, we just move it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 其主要部分是一个开关，因为我们将根据玩家的状态有不同的反应。如果玩家当前正在站立，我们将需要改变动画以行走，设置玩家的新状态，并沿x轴移动玩家。如果玩家正在跳跃，我们只是沿x轴移动玩家（但稍微慢一点）。如果玩家已经在行走，我们只需移动它。
- en: The last line flips the sprite horizontally because our image depicts the player
    facing right. The function for the right direction is basically the same.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行水平翻转了精灵，因为我们的图像描述了面向右的玩家。向右的方向函数基本上是相同的。
- en: The `jump` method will check whether the player is currently either standing
    or walking, and if so, it will change the animations, change the status, and set
    a vertical speed to generate the jump during the `update` function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`jump`方法将检查玩家当前是否处于站立或行走状态，如果是，则会更改动画，更改状态，并在`update`函数期间设置垂直速度以生成跳跃。'
- en: The `idle` status will set the status to standing and the `animation` function
    accordingly, but only if the player is walking.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`idle`状态将将状态设置为站立，并相应地设置`animation`函数，但仅当玩家正在行走时。'
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: And that's it for player movement. If you start the game with the logic contained
    in this object alone, you will already have most of what makes a platformer—a
    character moving around jumping from one platform to the other.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 关于玩家移动就是这些。如果你仅仅使用这个对象中包含的逻辑开始游戏，你将已经拥有大部分构成平台游戏的东西——一个角色在各个平台之间移动跳跃。
- en: Player control
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家控制
- en: 'We will still need to connect the player''s object to the main loop. This is
    really trivial as all the logic is contained in the object. There is, however,
    one little detail we omitted. As it is the player will go out of the screen if
    he moves left. We need to follow him! The way we will implement it is thus: if
    the player goes beyond a given point, we will start to move the group containing
    all the sprites and tiles in the opposite direction. This will give the impression
    that the camera is following the player.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要将玩家对象连接到主循环。这真的很简单，因为所有逻辑都包含在对象中。然而，我们忽略了一个小细节。由于玩家向左移动，他将离开屏幕。我们需要跟随他！我们将实现的方式如下：如果玩家超出了一个给定的点，我们将开始移动包含所有精灵和瓷砖的组，朝相反的方向移动。这会给人一种摄像机在跟随玩家的印象。
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is the main loop containing everything we described earlier.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是包含我们之前描述的所有内容的主循环。
- en: Parallax scrolling
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视差滚动
- en: Parallax scrolling is a very neat way of giving a little depth to a 2D game.
    It uses the principle that the farther away objects are, the slower they seem
    to move. It's typically what you see when you look through the side window of
    a moving car.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 视差滚动是给2D游戏增加一点深度的很好的方法。它利用了远离的物体看起来移动得越慢这一原理。这通常是当你从汽车的侧窗往外看到的景象。
- en: '![Parallax scrolling](img/5060OT_04_10.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![视差滚动](img/5060OT_04_10.jpg)'
- en: 'The first layer in the preceding figure will be the group containing all the
    sprites and the tile map. The second and third layers will simply be images. We
    will use the same technique we used in the previous game: we will simply use the
    background position to generate their movement.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中的第一层将是包含所有精灵和平铺地图的组。第二层和第三层将简单地是图像。我们将使用与以前的游戏相同的技术：简单地使用背景位置来生成它们的移动。
- en: 'The final code takes place in the main game loop just after we move the group
    around to keep the player visible on screen:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的代码在主游戏循环中进行，就在我们移动组以保持玩家在屏幕上可见之后：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, the code is simple; the only subtlety is in choosing the right
    values for the speed of each layer. There is sadly no other way to do this than
    by observing the effect with the naked eye.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，代码很简单；唯一微妙的地方在于选择每个图层速度的合适值。遗憾的是除了用赤裸裸的眼睛观察效果外，没有其他方法来做到这一点。
- en: Creating enemies
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建敌人
- en: For the enemies, we will use OO code too. It will allow us to use inheritance
    only to specify what changes between the two sorts of enemies. The first kind
    is slime. Enemies of this type crawl on the ground, and when they die, they flatten
    and stay where they were killed. They patrol back and forth between two points.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于敌人，我们也将使用面向对象的代码。这将允许我们仅仅使用继承来指定两种敌人之间的不同之处。第一种是史莱姆。这种类型的敌人在地面上爬行，当它们死亡时，它们会被压扁并停留在它们被杀死的地方。它们在两点之间来回巡逻。
- en: The second kind are flies. They behave exactly like the slimes, but they fly
    in the sky, and once killed, fall into the abyss.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种是苍蝇。它们的行为与史莱姆完全相同，但它们在天空中飞行，一旦被杀死，就会坠入深渊。
- en: 'We will start by writing the code for the slimes. It will be similar in structure
    to the player''s object, only much simpler:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始编写史莱姆的代码。它的结构与玩家的对象类似，但简单得多：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Enemies have only two states, alive and dead. It's the `update` function that
    generates their behavior, either by making them patrol or by letting them die.
    The only subtlety here is that we use a direction variable to store whether the
    slime is moving to the left or to the right.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人只有两种状态，活着和死亡。这是`update`函数生成它们的行为，要么让它们巡逻，要么让它们死去。这里唯一的微妙之处在于我们使用一个方向变量来存储史莱姆是向左移动还是向右移动。
- en: 'As the behavior of the flies is so similar, we don''t need to write much to
    implement their object:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因为苍蝇的行为如此相似，我们不需要写太多来实现它们的对象：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here you can see the quite strange syntax for object inheritance in JavaScript
    (it''s called prototypal inheritance). If you''re not familiar with it, you should
    read some advanced books about JavaScript because the full implication of what''s
    going on here is beyond the scope of this book. However, the intuitive way to
    understand it is this: you create a simple object and copy all the methods of
    another class into it. Then you modify the classes you want to override.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到JavaScript中对象继承的相当奇怪的语法（它被称为原型继承）。如果你对此不熟悉，你应该阅读一些关于JavaScript的高级书籍，因为这里发生的一切的全部意义超出了本书的范围。然而，直观理解它的方式是这样的：你创建一个简单的对象，并将另一个类的所有方法复制到它里面。然后你修改你想要覆盖的类。
- en: Here we really just need to change the way the fly behaves after its death by
    making it fall.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们真的只需要改变苍蝇死亡后的行为，让它坠落。
- en: 'Now we have to call the update function from the main game loop and check for
    collision with the player. This, again, is done in a very simple way as most of
    the logic is already written or is in the framework:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在主游戏循环中调用更新函数并检查与玩家的碰撞。同样，这样做的方式非常简单，因为大部分逻辑已经编写或者在框架中：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is it for our game. Of course, like for the last one, there are a lot
    of things you can add here: give the player the ability to die, allow him to kill
    enemies only if he jumps on them, or anything you like, really. With this basic
    template, you''ll be able to generate a wide variety of games with vastly different
    gameplays depending on your choice of the basic rules. Here is what the final
    game looks like:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的游戏。当然，就像上一个游戏一样，你可以在这里添加很多东西：让玩家有能力死亡，只有当他跳在敌人上时才允许他杀死敌人，或者任何你喜欢的东西。有了这个基本模板，你将能够根据你对基本规则的选择生成各种各样游戏玩法完全不同的游戏。这就是最终游戏的样子：
- en: '![Creating enemies](img/5060OT_04_11.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![创建敌人](img/5060OT_04_11.jpg)'
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We now know how to draw tile maps and detect collision between them and sprites
    as well as between sprites. We have a working example of object-oriented code
    for our game logic that we will be able to use in lots of other kinds of games.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何绘制瓦片地图以及检测它们和精灵之间以及精灵之间的碰撞。我们对于我们的游戏逻辑有一个可用的面向对象的代码的工作示例，我们将能够在许多其他类型的游戏中使用它。
- en: As for our preceding game, the resulting game here can be improved in lots of
    ways, and I recommend doing so to familiarize yourself even more with the code.
    You can add more enemies, make them die only if the player jumps on them, and
    detect when the player reaches the end of the level.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 至于我们之前的游戏，这里的游戏可以在许多方面进行改进，我建议这样做以更加熟悉代码。你可以增加更多的敌人，只有当玩家跳在它们上面时它们才会死亡，并且检测玩家何时到达关卡的结尾。
- en: In the next chapter, we will use the techniques we learned here to make a top-view
    RPG.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将运用我们在这里学到的技巧来制作一个俯视视角的RPG游戏。
