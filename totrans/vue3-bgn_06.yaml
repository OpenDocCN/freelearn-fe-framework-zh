- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Event and Data Handling in Vue.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Major frameworks have gained their popularity not only from their ability to
    break down big pages into small reusable components but also due to the simplicity
    with which these components can communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to focus on how the data flows between different
    components. This exchange of information between components is handled in two
    different ways: parent to child with properties and child to parent with events.'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to start this chapter by introducing a few changes that have been
    committed in the Companion App since our last chapter. These modifications can
    be used as a good guide to help you develop your skills and consolidate what you
    have already learned. We are going to revisit properties by learning about more
    advanced techniques such as `validator` and `required` by creating our first reusable
    component in the form of a simple button. Then, we will learn how to handle native
    events such as `click` and `change`, and finally, introduce custom events that
    will allow our component to broadcast messages to the rest of the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter includes the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Companion App changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deepening our knowledge of props
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling native events in Vue.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting components with custom events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have learned how to handle communication
    between multiple components. With this new knowledge, you should be able to move
    away from the individual components and start to think at a macro level by considering
    more complex application structures that include multiple components.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to follow this chapter, you should use a branch called `CH06`. To
    pull this branch, run the following command or use your GUI of choice to support
    you in this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This branch is going to include a few changes. These will be explained in the
    first section of this chapter, but you can start and run the app to get familiar
    with its updated look and browse the repository.
  prefs: []
  type: TYPE_NORMAL
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Companion App changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, the Companion App had a very basic look and feel and its changes
    were completely made by the code that we wrote within the chapters, but things
    have changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how the application looks now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Companion app with updated design and components](img/B21130_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Companion app with updated design and components'
  prefs: []
  type: TYPE_NORMAL
- en: As you can observe in the previous screenshot, the Companion App has not only
    received a facelift with some updated styles but it also exhibits new components
    that will be used in the course of this and future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: These changes have been applied to be able to make the most of the book content,
    allowing us to focus on the new learning material without having to spend too
    much time creating the scaffolding and basic structure of components, but you
    should spend some time exploring the changes made and try to understand why and
    how things were implemented.
  prefs: []
  type: TYPE_NORMAL
- en: All the changes and modifications that have been added since last chapter, use
    features that you have already been introduced to, and going through each change
    is a perfect exercise to enforce your learning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two main groups of changes have been made to the app:'
  prefs: []
  type: TYPE_NORMAL
- en: Folder and file changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logic changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at these changes in detail, starting with the changes that affected
    folders and files.
  prefs: []
  type: TYPE_NORMAL
- en: Folders and file changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `CH06` branch, a few changes have taken place within the folders and
    files of the application. The changes were made to start to structure the app
    like a real production app, moving away from the simple “proof of concept” look
    and structure that the app had until now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The changes made in the file structure are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Our first atom component with `TheLogo.vue` was added.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous chapter, the `SVG` element of the logo was hardcoded in the
    header of our Companion App. This has now been moved into its own file and it
    has been imported into `TheHeader.vue`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A sidebar called `SideBar.vue` was added to the UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The layout of our app has been modified and we have added a new sidebar in the
    `organism` folder with the name `SideBar.vue`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The ability to create posts with `CreatePost.vue` was scaffolded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main container of our application now includes a new component aimed at
    creating new posts. This component just includes the HTML structure and some style,
    but it has no logic yet. The component can be found at `CreatePost.vue` in the
    `molecules` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We renamed `TheWelcome.vue` to `SocialPosts.vue`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To better align our components with the newly updated layout, there was a need
    to remove the very generic `TheWelcome.vue` component and align it with the component
    structure. To do so, we have renamed the component `SocialPosts.vue` as it includes
    a list of social posts, and also moved it within the `molecules` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have found out about all the files and folder changes, it is time
    to see any code logic changes that may have been included in this update.
  prefs: []
  type: TYPE_NORMAL
- en: Logic changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like the folder changes, the app has gone through a few modifications.
    These changes will align the app for future changes, and they also give you a
    glimpse of what it is like to work on a real project by adding more files and
    a more complex folder structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to finish this book with a repository that has a handful of components,
    you would not experience what it is like to work on a real application, and you
    will therefore fail to learn how to navigate the code base and, more importantly,
    structure your code base. For this reason, the app has been enhanced to have some
    more structures:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining `homeView.vue`: At this moment in time, the application is a single
    page, but this will change later down the line. To start and align with those
    changes, we have started to define the `src`/`views`/`HomeViews.vue`) to include
    the sidebar, header, and main page body. This will allow us to create other pages
    in the future without the need to duplicate this structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cleaning up the code in the header: The header file has been cleaned up. We
    removed the hardcoded logo and added a new icon next to the “Welcome” message.
    To complete the changes, we also added some styles to our components. Look at
    this file to remind yourself how to load external components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Making `SocialPost` render dynamic content with `v-for`: Up until now, `SocialPost`
    posts were individually and manually loaded in `SocialPosts.vue` (previously known
    as `TheWelcome.vue`). The rendering of multiple posts is now dynamic and it is
    handled by `v-for`. Using `v-for` has not only improved the readability of the
    component but also made it dynamic, allowing us to add `post` to our list without
    the need to manually change the HTML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.2: Git differences between the hardcoded version of SocialPost and
    the one using v-if](img/B21130_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Git differences between the hardcoded version of SocialPost and
    the one using v-if'
  prefs: []
  type: TYPE_NORMAL
- en: We have now finished explaining both the structural and logical changes included
    in this chapter. Before we move forward, there is one small detail that I want
    to mention and it is about the `:``key` property.
  prefs: []
  type: TYPE_NORMAL
- en: If you carefully check the previous screen, you will notice that the new version
    of the code (the right-hand side) has an extra property called `:key`. This property
    is a requirement when using `v-for` with Vue components.
  prefs: []
  type: TYPE_NORMAL
- en: The key value is used by the framework to prevent unnecessary re-rendering of
    the full list. In fact, Vue.js uses this attribute to keep track of which specific
    component instance changed and just update a specific node instead of the full
    list.
  prefs: []
  type: TYPE_NORMAL
- en: So, going forward, every time you use the `v-for` directives, you should remember
    to also set a unique key using `:key`. This is usually raised as a warning by
    linting tools. Providing this value helps Vue.js identify all the different nodes
    that it creates with `v-for`, and speeds up re-rendering if any of it changes.
    You should try to define a key whenever possible, unless the DOM created is very
    simple.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid using an array index
  prefs: []
  type: TYPE_NORMAL
- en: It is very common to see the array index being used as the `:key` value for
    a `v-for` loop. Unfortunately, this is a very bad practice as the index will change
    if an array item is removed, forcing Vue.js to re-render the full list and possibly
    produce bugs that are hard to spot.
  prefs: []
  type: TYPE_NORMAL
- en: We are now up to speed with all the changes we have made. As mentioned previously,
    you should spend a few minutes familiarizing yourself with the changes and understand
    what was done and why.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to start our journey with data flows and look
    closely at properties. This subject was already introduced in the previous chapter
    but it has more to offer, and it is time to learn about it.
  prefs: []
  type: TYPE_NORMAL
- en: Deepening our knowledge of props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B21130_03.xhtml#_idTextAnchor039), we introduced and started
    to use properties as a way to pass information from a component to its children.
    As our understanding of Vue.js is widening, it is time to expand our knowledge
    of this basic feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as a quick recap, so far, we have learned that properties (props) are
    defined using the `defineProps` compiler macro, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Doing so will allow our component to accept a prop called `name` of type `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we are going to learn what other configurations properties
    have to offer. The ability to define a props type is not the only configuration
    available.
  prefs: []
  type: TYPE_NORMAL
- en: Props configurations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most cases, just configuring a prop type, as previously shown, is more than
    enough, but there are times when fine control is needed, and the following configuration
    will help you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax we used to declare properties has a name followed by the expected
    type, `PropsName: Type`, but to be able to use advanced configuration, we need
    to change the props to accept an object. So, the example that we provided before
    of `name: String` in object syntax will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that the properties have an object, we can add extra configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A Vue.js prop can accept multiple types. To do so, we can just define the types
    as an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Setting required properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two types of properties, `required` or `optional`. Out of the box,
    all properties are set to be `optional` by the framework and this is done on purpose
    to align with the way native HTML handles attributes (e.g., `disabled` or `readonly`).
  prefs: []
  type: TYPE_NORMAL
- en: 'When developing components, you should always ask yourself whether the component
    can be rendered without the value of a prop value, and if not, make sure you set
    the prop as `required`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When a prop is required, if a user tries to implement the component without
    it, the component will throw an error and, in some cases, not render the component
    at all, depending on your settings.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a properties fallback with a default value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a prop is set to `optional` and it is not passed, the component will give
    it an `undefined` value. This is okay for most cases, but there are situations
    in which you would like the properties to have a fallback value.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is common for beginner developers to achieve this using `v-if` in the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This solution is very verbose and should be replaced with a default prop value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `welcomeMsg` prop is not passed, the component will render the `Welcome`
    string. Our HTML can now be clean for logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Arrays and object default initialization
  prefs: []
  type: TYPE_NORMAL
- en: 'Objects and arrays have a different syntax for `default` and must be returned
    by a factory function: `default: () => []` or `default: () => {}`.'
  prefs: []
  type: TYPE_NORMAL
- en: Validating your properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last configuration that we are going to introduce is the ability to validate
    the value received. This is extremely helpful when your prop can just accept a
    specific set of values or if they have to be formatted in a specific way. A validator
    is a function that receives an argument equal to the prop value and is expected
    to return `true` to mark the validation or `false` to invalidate the validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for example, if we want to create a prop that can just accept two strings,
    `light` or `dark`, we would set the `validator` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding lines of code, our component props, `theme`, will just accept
    these two values. If the wrong value is passed, the component will not render
    and will throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To put everything that we have learned into practice, we are going to create
    a simple base button. Base components, such as the one offered by component libraries,
    accept multiple properties and are usually the best fit to utilize advanced properties
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our button is going to have the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: It will *require* a value that can be a string or number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If will have an `optional` prop of `width` that defaults to `100px`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will have an `optional` theme that only accepts a `light` or `dark` value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The new button can be found in the `atoms` folder under the name `TheButton.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The file is mostly defined. Its HTML includes a `button` element with placeholders
    for our properties and styles ready to accommodate our prop value. All that is
    left for this component is to define its properties. Before reading the following
    solution, try and use the preceding information to define the props by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'When fully defined, the defined props should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Prop configurations are extremely powerful and so simple to use. Using them
    correctly can help save many lines of code in your template and will help you
    make your component more robust.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned how to use prop configurations and created
    a base button to help us understand its real usage. We learned how to provide
    multiple types, how to set a prop as `required`, how to define a default value,
    and last but not least, how to validate it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we will start to move our attention to another part of
    data handling: events. Events are used by children components to communicate with
    their parent component. We are going to first introduce the native element and
    then move on to define custom elements.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling native events in Vue.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since JavaScript’s inception, events have always played a vital role in the
    success of this programming language. For this reason, all JavaScript frameworks
    have made sure they offer a strong solution to handle native and custom events.
  prefs: []
  type: TYPE_NORMAL
- en: We refer to native events as the ones built in HTML elements and APIs such as
    a `click` event triggered by `<button>`, a `change` event triggered by `<select>`,
    or a `load` event triggered by `<img>`.
  prefs: []
  type: TYPE_NORMAL
- en: Just like with props and directives, Vue.js event handling seamlessly merges
    with the existing native syntax to handle events offered by HTML elements. In
    native HTML, all events handlers are prefixed with the word `on`, so a `click`
    event becomes `onclick` and a `change` event becomes `onchange`. Vue.js follows
    this convention by creating a directive (which, as we know, starts with `v-`)
    called `v-on`. So a `click` event in Vue is handled using `v-on:click` and a `change`
    event is listened to by using `v-on:change`.
  prefs: []
  type: TYPE_NORMAL
- en: You have probably noticed that this is not the syntax that we used in the code
    base so far. In fact, if you open up `SocialPost.vue`, you will notice that we
    used a different syntax where the event is prefixed with the `@` symbol.
  prefs: []
  type: TYPE_NORMAL
- en: This is just a nice shorthand provided by the Vue.js framework. Using the `@`
    sign not only simplifies the actual writing of the events but is also clearly
    marked as different from other directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how these different methods would look when applied to `<button>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Even if the syntax is not completely the same, it is very similar and intuitive
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: There is a small difference to notice. In fact, in the native method to handle
    events, the method that is passed to `onclick` is actually called `onclick="method()"`,
    while in the Vue.js case, the methods are not called and they are just passed
    as a reference to the method name that will later be called by the framework engine,
    `@click="method`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time to make some changes to the code base by opening up `SideBar.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This file is the one responsible for the new sidebar being displayed in our
    layout. This component includes a couple of elements and buttons that will be
    used as learning material in the course of this and future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: For this section, we are going to focus on the current time displayed on the
    screen. More specifically, we are going to create the ability to update this time
    at the click of a button.
  prefs: []
  type: TYPE_NORMAL
- en: Handling events is achieved in two steps. First, we create a method that includes
    all the logic to trigger the event, and then we attach this to the HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the method first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding change, clicking the button labeled **Update Time** will
    update the current time shown on the screen. Let’s break down how we achieved
    this.
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a method for our event logic. This method is going to be prefixed
    with the word `on` followed by an identifier of the actual event – for example,
    `updateTimeClick` – generating a name equal to `onUpdateTimeClick`.
  prefs: []
  type: TYPE_NORMAL
- en: The logic of this particular event is quite simple, but as we learned in the
    previous chapter, methods can be complex and also have side effects, so there
    is no limit to what an event can achieve.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add the `click` directive in the HTML. We can either use `v-on:click`
    or `@click`. This will automatically link our Vue method with the native `click`
    event.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example should not have been too different from the one that we already
    covered in the earlier chapters, but event handling does not stop here. In fact,
    there are two important concepts that we need to learn about: event modifiers,
    which we are going to introduce right now, and event parameters, which will be
    covered later in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Event modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While working with events in JavaScript, it is very common to modify the event
    by either preventing the default behavior (`event.preventDefault()`) or stopping
    the propagation of the event (`event.stopPropagation()`).
  prefs: []
  type: TYPE_NORMAL
- en: This is where the event modifier comes into place. Vue.js offers us a simple
    syntax to trigger these logics directly from the HTML without the need to navigate
    through the event object.
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js offers many modifiers – from event modifiers (such as `.prevent`, `.stop`,
    and `.once`) to keyboard modifiers that allow you to listen to a specific button
    (such as `.enter`, `.tab`, and `.space`) and, finally, to mouse modifiers that
    allow you to trigger events on a specific mouse press with `.left`, `.right`,
    and `.middle`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down the syntax of a Vue directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: Breakdown of syntax for a Vue directive](img/B21130_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Breakdown of syntax for a Vue directive'
  prefs: []
  type: TYPE_NORMAL
- en: 'A directive in Vue.js is made up of four main sections:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the directive – for example, `v-on`, `v-if`, or `@` if using the
    available shorthand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An argument, such as `click` for a `click` event, or the name of a prop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A modifier such as `prevent` or `stop`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual value required by the directives. In the case of an event handler,
    the value would be the function that is run when the event is triggered, while
    in the case of props, the value would be a simple variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event modifiers are appended to the event directive, so, for example, for `preventDefault`,
    you would write `@click.prevent="methodName"`.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about all of these modifiers is out of the scope of this book as some
    of them (such as `capture` and `passive`) have very specific usage that is not
    always required. If you want to learn more, you can get more details in the Vue.js
    official documentation ([https://vuejs.org/guide/essentials/event-handling#event-modifiers](https://vuejs.org/guide/essentials/event-handling#event-modifiers)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on, we are going to try and use one of these modifiers in our
    application: `.once`. This modifier prevents our event handler from being triggered
    more than once. This is very useful when you have actions that can just be performed
    once, for example, saving a new entry or updating a table row.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to apply this to the same `click` event that we recently wrote.
    By doing so, we will just be able to update the current time once, as clicking
    the button multiple times will not perform any action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The usage of the modifier is quite simple, as we have just shown. All we needed
    to do to prevent the event from being triggered more than once was add the word
    `.once` after our event directive.
  prefs: []
  type: TYPE_NORMAL
- en: Modifiers are not just for events but for all directives
  prefs: []
  type: TYPE_NORMAL
- en: The ability to provide a modifier to a directive, as shown previously, is not
    exclusive to events; in fact, modifiers are a feature available to directives
    in general. The only built-in directive to have modifiers is `v-on`, but you can
    create your own custom directive or use an external package that could have its
    own modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: After this brief introduction of native events, it is time to learn about custom
    events and how they can be used to broadcast messages between components.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting components with custom events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Frameworks such as Vue.js allow us to break down our application into very small
    components, sometimes as small as a single HTML element. This would not be possible
    without a strong communication system.
  prefs: []
  type: TYPE_NORMAL
- en: Native HTML elements offer events as a way for them to trigger actions and pass
    information to their parents, and Vue.js components use a very similar pattern
    by offering custom events.
  prefs: []
  type: TYPE_NORMAL
- en: Custom events are not something new, as they have been around JavaScript for
    quite some time, but they are usually very verbose to use in vanilla JavaScript,
    whereas with Vue.js, creating, emitting, and listening to custom events feels
    easy and intuitive. Let’s see how these are defined and used.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn about custom events, we are going to modify the Companion App by adding
    the ability for the user to delete a post:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: Diagram displaying the flow of data between parent and child
    components](img/B21130_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Diagram displaying the flow of data between parent and child components'
  prefs: []
  type: TYPE_NORMAL
- en: As visualized by the preceding diagram, properties such as `Posts` are used
    by the parent to send information to the child. On the other hand, events are
    used for the child to emit information to the parent.
  prefs: []
  type: TYPE_NORMAL
- en: In the example illustrated in *Figure 6**.4*, the `SocialPosts.vue` file sends
    a list of social posts to the child, and the child uses a custom event called
    `delete` to ask the parent to delete a post.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to implement this custom event in the `SocialPost.vue` file.
    The first step requires us to trigger a native `click` event when the *delete*
    icon is clicked. Just as we did in the previous section, we achieve this by adding
    the `@click` directive in the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add the `onDeleteClick` method in the `<``script>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to define the event and trigger it when `onDeleteClick` is triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We define emits using a compiler macro called `defineEmits`. This follows the
    same syntax of `defineProps` as it accepts an array of events that can be emitted
    by the component. In our case, we just defined one event of `delete`.
  prefs: []
  type: TYPE_NORMAL
- en: '`defineEmits` returns a function that can be used to trigger our events. It
    is suggested to name this constant `emit` to align with the native `$emit` method
    available in Vue.js.'
  prefs: []
  type: TYPE_NORMAL
- en: This function accepts two arguments. The first is the event name, and the second
    is just a parameter that will be passed to whoever listens to the event. In our
    case, this was defined with `emit('delete')`, where `delete` was our custom event
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the child custom event is fully set, it is time to ensure that the
    parent is listening to the event. Let’s go over `SocialPosts.vue` and put our
    skills to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Listening to a custom event in Vue.js is no different from listening to a native
    event. In fact, both use the `v-on` (or `@`) directive, as shown by `@delete="onDelete"`.
    This code, just like other event listeners, will wait for the event to be triggered
    before running the provided function.
  prefs: []
  type: TYPE_NORMAL
- en: The method triggered by the event is called `onDelete` and uses plain JavaScript
    to remove the item from the `Posts` object. If we tried the current code, we would
    see that the functionality works as expected and the first post is deleted when
    the *delete* icon is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: This is great but not perfect, as we would like to choose which post to delete
    instead of hardcoding this to be the first post. To fix this bug, we would have
    to add an argument to define which one is the correct post to delete when declaring
    our custom event.
  prefs: []
  type: TYPE_NORMAL
- en: Event arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until this moment, all the events that have been handled in the Companion App
    required access to neither the event object nor the external argument.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are going to learn how you could expand your event handler to accept
    these extra values.
  prefs: []
  type: TYPE_NORMAL
- en: Since the methods attached to an event have access to all reactive data of a
    component, you may think that passing arguments may not be extremely useful, but
    this is not the case.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, arguments are extremely helpful when triggering an event from an element
    that is using `v-for` – just like in our case, in which we need to inform our
    event of the `post` index. Having access to the correct value of the post that
    is triggering the event is vital for the functionality to run correctly.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to delete the correct post, we first need to add the value of the
    `post` index when triggering the event handler and then ensure that this value
    is read and used by the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make the `post` index available by exposing it within `v-for`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the index to the event declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the `postIndex` argument in the event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After these three modifications, we should be able to delete the correct post
    from our Companion App.
  prefs: []
  type: TYPE_NORMAL
- en: Getting access to the events native object with $event
  prefs: []
  type: TYPE_NORMAL
- en: 'Event handlers have access to a special argument called `$event`. This is passed
    automatically to all events that have no argument or can be passed directly from
    the HTML when passing custom parameters: `<button @click="handler($event,` `customParameter)
    />"`.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have revisited previously learned topics by analyzing the
    changes in the Companion App. We then expanded our knowledge of props by introducing
    all their possible options. Next, we moved on to event handling by explaining
    how to use native HTML events within Vue.js components before closing the chapter
    with the definition of a custom event handler and how this can be used to flow
    information between components.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be able to create and use custom events. With this knowledge,
    plus the additional knowledge on props, you should be able to work on larger applications
    that have multiple components. You should also make use of the changes that have
    been made in the Companion App to learn how to navigate the new code base.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to continue to build on the topic of “increase
    scope” by removing the hardcoded values, starting to use external APIs, learning
    how to handle side effects by watching for value changes, and overcoming the limitation
    of computed properties. These changes will increase the complexity of our application
    even further, while at the same time, providing us with a vital skill to increase
    our knowledge of the Vue.js framework.
  prefs: []
  type: TYPE_NORMAL
