["```js\nclass Engine {...} \n\nclass Transmission {...}\n\nclass Car { \n  engine; \n  transmission;\n\n  constructor() { \n    this.engine = new Engine(); \n    this.transmission = new Transmission(); \n  } \n} \n\n```", "```js\nclass Engine {...} \nclass Transmission {...} \n\n@Injectable() \nclass Car { \n  engine; \n  transmission;\n\n  constructor(engine: Engine, transmission: Transmission) { \n    this.engine = engine; \n    this.transmission = transmission; \n  } \n} \n\n```", "```js\nimport 'reflect-metadata';\nimport {\n  ReflectiveInjector,\n  Inject,\n  Injectable,\n  OpaqueToken\n} from '@angular/core';\n\nconst BUFFER_SIZE = new OpaqueToken('buffer-size');\n\nclass Buffer {\n  constructor(@Inject(BUFFER_SIZE) private size: Number) {\n    console.log(this.size);\n  }\n}\n\n@Injectable()\nclass Socket {\n  constructor(private buffer: Buffer) {}\n}\n\nlet injector = ReflectiveInjector.resolveAndCreate([\n  { provide: BUFFER_SIZE, useValue: 42 },\n  Buffer,\n  Socket\n]);\n\ninjector.get(Socket);\n\n```", "```js\n$ cd app\n$ ts-node ch5/ts/injector-basics/injector.ts\n\n```", "```js\nclass Socket {\n  constructor(@Inject(Buffer) private buffer: Buffer) {}\n}\n\n```", "```js\nlet injector = ReflectiveInjector.resolveAndCreate([ \n  { provide: BUFFER_SIZE, useValue: 42 }, \n  Buffer, \n  Socket \n]); \n\n```", "```js\nclass Buffer { \n  constructor(@Inject(BUFFER_SIZE) private size: Number) { \n    console.log(this.size); \n  } \n} \n\n```", "```js\n// ch5/ts/injector-basics/forward-ref.ts \n\n@Injectable() \nclass Socket { \n  constructor(private buffer: Buffer) {...} \n} \n\n// undefined \nconsole.log(Buffer); \n\nclass Buffer { \n  constructor(@Inject(BUFFER_SIZE) private size: Number) {...} \n} \n\n// [Function: Buffer] \nconsole.log(Buffer); \n\n```", "```js\n... \nimport {forwardRef} from '@angular/core'; \n...\n\n@Injectable() \nclass Socket { \n  constructor(@Inject(forwardRef(() => Buffer)) \n    private buffer: Buffer) {} \n}\n\nclass Buffer {...} \n\n```", "```js\nlet injector = ReflectiveInjector.resolveAndCreate([ \n  { provide: BUFFER_SIZE, useValue: 42 }, \n  { provide: Buffer, useClass: Buffer }, \n  { provide: Socket, useClass: Socket } \n]); \n\n```", "```js\nclass Http {...} \n\n@Injectable() \nclass UserService { \n  constructor(private http: Http) {} \n} \n\nlet injector = ReflectiveInjector.resolveAndCreate([ \n  UserService, \n  Http \n]); \n\n```", "```js\nclass DummyHttp {...} \n\n// ... \n\nlet injector = ReflectiveInjector.resolveAndCreate([ \n  UserService, \n  { provide: Http, useClass: DummyHttp } \n]); \n\n```", "```js\n// ch5/ts/configuring-providers/existing.ts \nlet injector = ReflectiveInjector.resolveAndCreate([ \n  DummyService, \n  { provide: Http, useExisting: DummyService }, \n  UserService \n]); \n\n```", "```js\nlet dummyHttp = { \n  get() {}, \n  post() {} \n}; \nlet injector = ReflectiveInjector.resolveAndCreate([ \n  { provide: DummyService, useValue: dummyHttp }, \n  { provide: Http, useExisting: DummyService }, \n  UserService \n]); \nconsole.assert(injector.get(UserService).http === dummyHttp); \n\n```", "```js\nlet injector = ReflectiveInjector.resolveAndCreate([ \n  { \n    provide: TLSConnection, \n    useFactory: (socket: Socket, certificate: Certificate, crypto: Crypto) \n      =>  { \n        let connection = new TLSConnection(); \n        connection.certificate = certificate; \n        connection.socket = socket; \n        connection.crypto = crypto; \n        socket.open(); \n        return connection; \n      }, \n      deps: [Socket, Certificate, Crypto] \n  }, \n  { BUFFER_SIZE, useValue: 42 }, \n  Buffer, \n  Socket, \n  Certificate, \n  Crypto \n]); \n\n```", "```js\nlet injector = ReflectiveInjector.resolveAndCreate([ \n  ... \n  { BUFFER_SIZE, useValue: 42 }, \n  Buffer, \n  Socket, \n  Certificate, \n  Crypto \n]); \n\n```", "```js\n// buffer with size 42 \nconsole.log(injector.get(Buffer)); \n// socket with buffer with size 42 \nconsole.log(injector.get(Socket)); \n\n```", "```js\nlet connection = new TLSConnection();\nconnection.certificate = certificate;\nconnection.socket = socket;\nconnection.crypto = crypto;\nsocket.open();\nreturn connection;\n\n```", "```js\n{\n  provide: TLSConnection,\n  useFactory: (socket: Socket, certificate: Certificate, crypto: Crypto) =>  { \n    // ... \n  }, \n  deps: [Socket, Certificate, Crypto] \n}\n\n```", "```js\n// ch5/ts/parent-child/simple-example.ts\n\nclass Http {} \n\n@Injectable() \nclass UserService { \n  constructor(public http: Http) {} \n} \n\nlet parentInjector = ReflectiveInjector.resolveAndCreate([ \n  Http\n]);\n\nlet childInjector = parentInjector.resolveAndCreateChild([ \n  UserService\n]);\n\n// UserService { http: Http {} }\nconsole.log(childInjector.get(UserService)); \n// true \nconsole.log(childInjector.get(Http) === parentInjector.get(Http)); \n\n```", "```js\nabstract class Channel {}\n\nclass Http extends Channel {}\n\nclass WebSocket extends Channel {} \n\n@Injectable() \nclass UserService { \n  constructor(public channel: Channel) {} \n} \n\nlet parentInjector = ReflectiveInjector.resolveAndCreate([ \n  { provide: Channel, useClass: Http } \n]);\n\nlet childInjector = parentInjector.resolveAndCreateChild([ \n  { provide: Channel, useClass: WebSocket }, \n  UserService \n]); \n\n```", "```js\nchildInjector.get(UserService); \n\n```", "```js\n@Injectable() \nclass UserService { \n  constructor(@Self() public channel: Channel) {} \n} \n\n```", "```js\nlet parentInjector = ReflectiveInjector.resolveAndCreate([ \n  { provide: Channel, useClass: Http } \n]);\n\nlet childInjector = parentInjector.resolveAndCreateChild([ \n  UserService \n]); \n\n```", "```js\nclass Context { \n  constructor(public parentContext: Context) {} \n} \n\n```", "```js\nlet parentInjector = ReflectiveInjector.resolveAndCreate([ \n  { provide: Context, useValue: new Context(null) } \n]);\n\nlet childInjector = parentInjector.resolveAndCreateChild([ \n  Context \n]); \n\n```", "```js\nchildInjector.get(Context); \n\n```", "```js\nclass Context { \n  constructor(@SkipSelf() public parentContext: Context) {} \n} \n\n```", "```js\nabstract class SortingAlgorithm { \n  abstract sort(collection: BaseCollection): BaseCollection; \n} \n\n@Injectable() \nclass Collection extends BaseCollection { \n  private sort: SortingAlgorithm;\n\n  constructor(sort: SortingAlgorithm) { \n    super(); \n    this.sort = sort || this.getDefaultSort(); \n  } \n} \n\nlet injector = ReflectiveInjector.resolveAndCreate([ \n  Collection \n]); \n\n```", "```js\n// ch5/ts/decorators/optional.ts\n\n@Injectable() \nclass Collection extends BaseCollection { \n  private sort: SortingAlgorithm;\n\n  constructor(@Optional() sort: SortingAlgorithm) { \n    super(); \n    this.sort = sort || this.getDefaultSort(); \n  } \n} \n\n```", "```js\n// ch5/ts/configuring-providers/multi-providers.ts \nconst VALIDATOR = new OpaqueToken('validator'); \n\ninterface EmployeeValidator { \n  (person: Employee): string; \n} \n\nclass Employee {...} \n\nlet injector = ReflectiveInjector.resolveAndCreate([ \n  {\n    provide: VALIDATOR, \n    multi: true, \n    useValue: (person: Employee) => { \n      if (!person.name) { \n        return 'The name is required'; \n      } \n    } \n  },\n  {\n    provide: VALIDATOR, \n    multi: true, \n    useValue: (person: Employee) => { \n      if (!person.name || person.name.length < 1) { \n        return 'The name should be more than 1 symbol long'; \n      } \n    } \n  },\n  Employee \n]); \n\n```", "```js\nclass Employee { \n  name: string;\n\n  constructor(@Inject(VALIDATOR) private validators: EmployeeValidator[]) {}\n\n  validate() { \n    return this.validators \n      .map(v => v(this)) \n      .filter(value => !!value); \n  } \n} \n\n```", "```js\n// ch4/ts/tooltip/app.ts\n\n// ... \n@Directive(...) \nexport class Tooltip { \n  @Input() saTooltip: string; \n\n  constructor(private el: ElementRef, private overlay: Overlay) { \n    this.overlay.attach(el.nativeElement); \n  } \n  // ... \n}\n\n@Component({ \n  // ... \n  providers: [Overlay]\n}) \nclass App {} \n\n```", "```js\nclass Markdown {...}\n\n@Component(...)\nclass MarkdownPanel {...}\n\n@Component(...)\nclass App {...}\n\n@NgModule({\n  declarations: [App, MarkdownPanel],\n  providers: [Markdown],\n  imports: [BrowserModule],\n  bootstrap: [App],\n})\nclass AppModule {}\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n```", "```js\n// ch4/ts/directives-ngmodules/app.ts\n// ...\n@NgModule({\n  declarations: [Button],\n  exports: [Button],\n  providers: [Markdown],\n})\nclass ButtonModule {}\n\n//...\n\n@NgModule({\n  declarations: [App, MarkdownPanel],\n  imports: [BrowserModule, ButtonModule],\n  bootstrap: [App],\n})\nclass AppModule {}\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n```", "```js\n@Component({ \n  // ... \n  providers: [Overlay]\n})\nclass App {} \n\n```", "```js\n@Directive({ \n  selector: '[saTooltip]', \n  providers: [{ provide: Overlay, useClass: OverlayMock }] \n}) \nexport class Tooltip { \n @Input() saTooltip: string; \n\n  constructor(private el: ElementRef, private overlay: Overlay) { \n    this.overlay.attach(el.nativeElement); \n  } \n  // ... \n} \n\n// ... \n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n\n```", "```js\n<markdown-panel> \n  <panel-title># Title</pane-title> \n  <panel-content> \n# Content of the panel \n* First point \n* Second point \n  </panel-content> \n</markdown-panel> \n\n```", "```js\nimport * as markdown from 'markdown';\n\nclass Markdown { \n  toHTML(md) { \n    return markdown.toHTML(md); \n  } \n} \n\n```", "```js\n// ch5/ts/directives/app.ts \n@Component({ \n  selector: 'markdown-panel', \n  viewProviders: [Markdown], \n  styles: [...], \n  template: ` \n    <div class=\"panel\"> \n      <div class=\"panel-title\"> \n        <ng-content select=\"panel-title\"></ng-content> \n      </div> \n      <div class=\"panel-content\"> \n        <ng-content select=\"panel-content\"></ng-content> \n      </div> \n    </div>` \n}) \nclass MarkdownPanel { \n  constructor(private el: ElementRef, private md: Markdown) {}\n\n  ngAfterContentInit() { \n    let el = this.el.nativeElement; \n    let title = el.querySelector('panel-title'); \n    let content = el.querySelector('panel-content'); \n    title.innerHTML = this.md.toHTML(title.innerHTML); \n    content.innerHTML = this.md.toHTML(content.innerHTML); \n  } \n} \n\n```", "```js\n<markdown-panel> \n  <panel-title>### Small title</panel-title> \n  <panel-content> \n    Some code \n  </panel-content> \n  <markdown-button>*Click to toggle*</markdown-button> \n</markdown-panel> \n\n```", "```js\n@Component({ \n  selector: 'markdown-panel', \n  viewProviders: [Markdown], \n  styles: [...], \n  template: ` \n    <div class=\"panel\"> \n      <markdown-button>*Click to toggle*</markdown-button> \n      <div class=\"panel-title\"> \n        <ng-content select=\"panel-title\"></ng-content> \n      </div> \n      <div class=\"panel-content\"> \n        <ng-content select=\"panel-content\"></ng-content> \n      </div> \n    </div>` \n}) \n\n```", "```js\n// ch5/es5/simple-example/app.js\n\nvar Markdown = ng.core.Class({ \n  constructor: function () {},\n  toHTML: function (md) {\n    return markdown.toHTML(md); \n  } \n}); \n\n```", "```js\n// ch5/es5/simple-example/app.js \n\nvar MarkdownPanel = ng.core.Component({ \n  selector: 'markdown-panel', \n  viewProviders: [Markdown], \n  styles: [...], \n  template: '...' \n}) \n.Class({ \n  constructor: [Markdown, ng.core.ElementRef, function (md, el) { \n    this.md = md; \n    this.el = el; \n  }], \n  ngAfterContentInit: function () { \n    ... \n  } \n}); \n\n```", "```js\nModule.service('UserMapper', \n  ['User', '$http', function (User, $http) { \n    // ... \n  }]); \n\n```", "```js\n... \n.Class({ \n  constructor: [[ng.core.Optional(), Markdown], \n    ng.core.ElementRef, function (md, el) { \n      this.md = md; \n      this.el = el; \n    }], \n  ngAfterContentInit: function () { \n    ... \n  } \n}); \n... \n\n```"]