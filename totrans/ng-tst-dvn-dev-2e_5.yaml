- en: Chapter 5. Protractor, a Step Ahead
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: End-to-end testing is real fun as long as it interacts directly with the browser,
    but a good developer should know the advanced features of Protractor to perform
    large-scale application testing. Besides that, debugging is kind of a challenge
    in e2e testing as it depends on the DOM element of the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Protractor has some APIs for debugging. This chapter will mostly cover those
    APIs and features, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up and configuring Protractor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some advanced Protractor APIs such as browser, locator, and action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging Protractor with the `browser.pause()` and `browser.debug()` APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced setup and configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw a basic and commonly used setup and configuration
    for Protractor. Here, we will take a look at some advanced configurations that make
    installation simpler and more powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Protractor globally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps to install Protractor globally:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Node.js has been installed and is available in command prompt, type the
    following command to install Protractor globally on the system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding command uses Node's `npm` command to install Protractor globally
    so that we can use Protractor just with the `protractor` command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test whether the Protractor version can be determined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Advanced configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will be configuring Protractor a bit more using the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the protractor `config` file to support multiple browsers in a single
    test suite. The `multiCapabilities` parameter is an array that takes multiple
    `browserName` objects for any test suite, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can set advanced settings for browsers in the `capabilities` parameter;
    for example, for `chrome`, we can pass extra parameters as `chromeOptions`, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Sometimes, we may need to run Protractor directly without Selenium or WebDriver.
    This is possible by passing a parameter in the `config.js` file. The parameter
    is `directConnect: true` in the configuration object, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Great! We have configured Protractor a step ahead.
  prefs: []
  type: TYPE_NORMAL
- en: Protractor APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main activities of an e2e test for any web page are to get the DOM elements
    of that page, interact with them, assign an action to them, and share information
    with them; then, the user can get the current state of the website. To enable
    us to perform all these actions, Protractor provides a wide array of APIs (some
    are from the web driver). In this chapter, we will look at some commonly used
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how Protractor works with an Angular project,
    where we had to interact with UI elements. For that, we used a few Protractor
    APIs, such as `element.all`, `by.css`, `first`, `last`, and `getText`. However,
    we didn't see or understand the workings of these APIs in depth. To understand
    the workings of APIs in Protractor is very simple, but in real life we will mostly
    have to work with bigger, complex projects. Hence, it's important that we understand
    and know more about these APIs in order to interact with the UI and play with
    its events.
  prefs: []
  type: TYPE_NORMAL
- en: Browser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Protractor works with Selenium WebDriver, which is a browser automation framework.
    We can use a method from the Selenium WebDriver API to interact with the browser
    from the test spec. We will take a look at a few of them in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'To navigate the browser to a specific web address and load the mock modules
    for that page before the Angular load, we will use the `.get()` method by passing
    the specific address or relative path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the current page''s web URL, use the `CurrentUrl()` method, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To navigate to another page and browse it using in-page navigation, `setLocation` is
    used, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the title of the current page (basically, the title that is set in the
    HTML page), the `getTitle` method is used, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To reload the current page with the mocks module before the Angular load, the
    `refresh()` method is used, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To pause the test process, the `pause()` method is used. This is useful for debugging
    the test process, and we will use this test debugging section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To debug the test process, the `debugger()` method is used. This method is
    different and can be considered an advanced level of the `pause()` method. This
    is useful for advanced debugging of the test process, along with injecting custom
    helper function into the browser. We will use this test debugging section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To close the current browser, `close()` is used. This is useful for complex
    multimodule testing, when we sometimes need to close the current browser before
    opening a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To support Angular in Protractor, we have to set the `useAllAngularAppRoots`
    params to `true`. The logic behind doing this is that, when we set this parameter
    to `true`, it will search for all Angular apps in the page while the element finder
    traverses through the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Protractor itself exposes some global functions, and `element` is one of them.
    This function takes a locator (a kind of selector--we will discuss it in the next
    step) and returns an `ElementFinder`. This function basically finds a single element
    based on the locator, but it supports multiple element singing along with chaining
    another method as `element.all`, which also takes a locator and returns an `ElementFinderArray`.
    Both of them support chaining methods for the next action.
  prefs: []
  type: TYPE_NORMAL
- en: element.all
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we already know, `element.all` returns an `ElementArrayFinder` that supports
    chaining methods for the next action. We will look at a few of them and how they
    actually work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To select multiple elements as an array with a specific locator, we should
    use `element.all`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After getting a bunch of elements as an array, we may need to select a specific
    element. In that case, we should be chaining `get(position)` by passing the specific
    array index as the position number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After getting a bunch of elements as an array, we might need to select child
    elements again with a preferred locator, and for that we can chain the `.all(locator)`
    method again with the existing elements, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After getting the desired elements, we might want to check whether the number
    of elements selected is as expected. There is a method, `count()`, that is used
    to chain to get the total number of selected elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the `get(position)` method, we can get the first element from the
    array by chaining the `first()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the `first()`method, we can get the last element from the array
    by chaining the `last()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As long as we have a bunch of elements as an array, we may need to traverse
    though the elements to take any action. In that case, we may need to go through
    a loop by chaining the `each()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like the `each()` method, there is another method, `filter()`, to chain
    with the element array to traverse through the items and assign a filter to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `element` class returns `ElementFinder`, which means a single element in
    the element array, and this also supports chaining methods for the next action.
    In the previous examples, we saw how to obtain a single selected element from
    the element array so that all of the chaining methods work on that single element
    as well. There are a lot of chaining methods for working on a single element,
    and we will look at a few that are most commonly used.
  prefs: []
  type: TYPE_NORMAL
- en: 'By passing a specific locator as an argument to the `element` method, we can
    select a single DOM element, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After getting a specific single element, we may need to find the child element
    of the element on which we have to chain the `element.all` method with the rerun
    `elementFinder` object. For this, pass a specific locator to find the child `elementFinderArray`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After selecting a specific element, we might need to check whether that element
    is present while chaining the `isPresent()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Actions mainly change the method that affects or triggers the selected DOM element.
    The goal of selecting a DOM element is to interact with it by triggerring some
    actions so that it can act like a real user. There are some commonly used actions
    for specific interaction. We will look at a few of them here.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the inner text or contained text of any element, we have to chain the
    `getText()`method with the `elementFinder` object after selecting the specific
    element, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the inner HTML of any element, we have to chain the `getInnerHtml()`method
    with the `elementFinder` object after selecting the specific element, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can find any specific attribute value of any element by passing the attribute
    key to the `getAttribute()` method, which will chain with the selected `elementFinder`
    object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In most cases, we need to clear the value of the input field. For that, we
    can chain the `clear()`method with the selected `elementFinder` object, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that it's only the input or texture that may have some value and needs
    you to clear/reset the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we need to trigger a click event on any button, link, or image, after
    selecting a specific `elementFinder` object, we will need to chain the `click()`
    method, and it will act like a real click on that element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, we might need to trigger the `submit()` method for form submission.
    In that case, we have to chain the `submit()` method with the selected element.
    The selected element should be a `form` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Locators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Locators inform Protractor how to find a certain element in the DOM element.
    Protractor exports `locator` as a global factory function, which will be used
    with a global `by` object. We can use them in many ways based on our DOM, but
    let's look at some of the most commonly used ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can select any element by passing any of the CSS selectors to the `by.css`
    method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can select any element by passing its element ID to the `by.id` method,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also select a specific element or elements by tag name by passing it
    to `by.tagName`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To select the DOM element of any specific input field, we can pass the name
    in the `by.name` method, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides a CSS selector or ID, we can select a specific button by passing its
    text label to `by.buttonText`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can find an element by passing the model name defined as an `ng-model` on
    `by.model`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can find a specific DOM element by passing its binding defined
    with `ng-bind` in `by.bindings`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides all the locators explained earlier, there is another way to find a
    specific DOM element: a custom locator. Here, we have to create a custom locator
    using `by.addLocator` by passing the locator name and callback. Then, we have
    to pass that custom locator with `by.customLocatorName(args)`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Protractor tests - postmortem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's kind of difficult to debug e2e tests as they depend on the entire ecosystem
    of an application. Sometimes they depend on prior actions such as login, and sometimes
    they depend on permissions. Another major barrier to debugging e2e is its dependency
    on WebDriver. As it acts differently with different operating systems and browsers,
    this makes it difficult to debug e2e. Besides that, it generates long error messages,
    which makes it difficult to separate browser related issues and test process errors.
  prefs: []
  type: TYPE_NORMAL
- en: Still, we will try to debug all e2e tests and see how that works for our case.
  prefs: []
  type: TYPE_NORMAL
- en: Types of failure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There might be various reasons for the failure of a test suite as long as it
    depends on WebDriver and various parts throughout the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some known failure types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**WebDrive failure**: WebDriver throws an error when a command can''t be completed.
    For example, a browser can''t get the address that''s defined to help it navigate,
    or maybe an element is not found as expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WebDriver unexpected failure**: Sometimes, WebDriver fails and gives an error
    when it fails to update the web driver manager. This is a browser and OS-related
    issue, although it''s not common.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protractor failure for Angular**: Protractor will fail when Angular is not found
    in the library as expected because the Protractor test depends on Angular itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protractor Angular2 failure**: Protractor will fail for an Angular project''s
    test spec when the `useAllAngular2AppRoots` parameter is missing in the configuration
    because, without this, the test process will look at one single root element while
    expecting more elements in the process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protractor failure for timeout**: Sometimes, Protractor fails for the timeout
    when the test spec falls into a loop or a long pool and fails to return data in
    time. However, a timeout is configurable, so it can be increased as needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expectation failure**: This is a common failure in the test spec.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading an existing project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code used in this test comes from [Chapter 4](ch04.html "Chapter 4. End-to-End
    Testing with Protractor"), *End to End Testing with Protractor*. We will copy
    the code to a new directory: `angular-protractor-debug`.'
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, the application was a to-do application that had some items in
    the to-do list, and we added some items to it. It has a single component class,
    `AppComponent`, which has a list of items, and an `add` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current directory should be structured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading an existing project](img/image_05_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After verifying that the folder structure is the same as shown in the preceding
    screenshot, the first job is to get the required dependencies, `node_modules`,
    locally by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install all the required modules. Now, let''s build and run the project
    with the `npm` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything should be fine now: the project should run on `http://localhost:3000`,
    and the output should be as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading an existing project](img/image_05_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With that, we are ready to go on to the next step of implementing a debugger
    in our Angular project.
  prefs: []
  type: TYPE_NORMAL
- en: Including the debugger in the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before adding the debugger to our project, let's run the e2e test in our existing
    project. We hope to pass without any failure in the e2e test specs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, our tests passed. The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Including the debugger in the project](img/image_05_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can add our debugging code in the same place where the passed test specs
    are, but let''s keep the passed test case separate and play with the debugger
    in a different directory. Let''s create a new directory, `debug/`. We will need
    two files in the directory: one for the configuration and the other for the spec.'
  prefs: []
  type: TYPE_NORMAL
- en: For the Protractor configuration file, we can copy the `protractor.conf.js`
    file and rename it to `debugConf.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Everything in the configuration will be the same as the previous configuration.
    However, we need to increase the default timeout for the Jasmine test, or the
    test will timeout during debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s increase the timeout to `3000000` ms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will need a spec file to which to write the test spec and debug tests.
    Save the new spec file as `app.debug.e2e.ts`. Oh yes, we will need to change the
    config file once again to define the spec files for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We can make a simple test spec file for `app.debug.e2e.ts`. Then, we can add
    debug codes and play with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simple test specs are as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Pausing and debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To debug any test spec, we must pause the test process and see what is going
    on step-by-step. Protractor also has built-in methods to pause the process. Here
    are two methods to pause and debug the test process:'
  prefs: []
  type: TYPE_NORMAL
- en: '`browser.pause()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`browser.debugger()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using pause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Debugging Protractor tests becomes easy and simple with the `browser.pause()`
    command. Using the `pause()` method, we can enter the Protractor debugger control
    flow and execute some commands to check out what's happening in the control flow
    of the test. Mostly, developers use debuggers in tests when the test fails with
    an unknown error and there are long error messages.
  prefs: []
  type: TYPE_NORMAL
- en: After using the `browser.pause()` command, we can use a few more commands based
    on our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a brief look:'
  prefs: []
  type: TYPE_NORMAL
- en: '`c`: If we type `c` as a command, it will move one step forward in the test,
    and we will see how the test command works in depth. If we plan to move forward
    with a test, it''s better to do it quickly as there is a timeout issue ( the Jasmine
    default timeout), which we''ve learned about. We will see an example later on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repl`: By typing `repl` as a command, we can enter the interactive mode of
    debugging. It''s known as as the interactive mode as, from there, we can interact
    directly with the browser from the terminal by typing WebDriver commands. A response,
    result, or error from the browser will be displayed on the terminal as well. We
    will see more hands-on examples later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ctrl + C`: Press ***Ctrl*** + C to exit pause mode and continue the test.
    When we will use this, the test will continue from the point where it paused.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quick example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use `browser.pause()` in test specifications, we will have to add the method
    to the test spec at the places we want to pause the test and watch the control
    flow for debugging. Here, we just have one test spec with a wrong/failing test
    case, we know it will fail, and we will find out why it failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have to add the `pause()` method, as shown, to the test `spec it()
    {}` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: It's time to run the test. As we've separated the test spec for the debugger,
    we will run the test via Protractor (not `npm`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the test with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have placed the `browser.pause()` method before the `expect()` method,
    it will pause there. We can see in the control flow that this makes it wait for
    Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A quick example](img/image_05_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will move forward; for that, let''s type `C`. It will run `executeAsyncScript`
    and will wait for Angular to load:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A quick example](img/image_05_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will move another step ahead by typing `C`. It will try to select the element
    based on the locator provided by us, that is, `element(by.id(''my_id'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A quick example](img/image_05_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are close to getting the test result now. For that, we will have to move
    another step forward by typing `C`. Now, it will try to select the element based
    on the locator, and it will fail to select that. This will give a result with
    an error message, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A quick example](img/image_05_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Debugging with interactive mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To enter interactive mode, we have to type `repl`, after which we can run any
    command used in the test spec.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s find the element and its text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The result is the same as we got previously, by moving forward step by step,
    by typing `C`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Result**: `NoSuchElementError: No element found using locator: By (css selector,`
    `*[id="my_id"])`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how interactive mode works for a valid locator, when the `element`will
    be found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '**Result**: `test`'
  prefs: []
  type: TYPE_NORMAL
- en: Using the debugger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Debugging with the `browser.debugger()` command is a bit complex and more advanced
    than using `browser.pause()`. With the `browser.pause()` command, we can pause
    the control flow of the test and inject the custom helper functions into the browser
    so that debugging happens in the same way as we would debug in a browser console.
  prefs: []
  type: TYPE_NORMAL
- en: This debugging should be under node in debug mode, like here in Protractor debugging.
    This debugging is not useful for someone bad at node debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: To use the `browser.debugger()` method in the test spec, we will have to add
    the method to the test spec at the points where we want to set a breakpoint and
    watch the control flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'For us, we have to add the `debugger()` method, as follows, to the `test spec
    it() {}` function, and this will be our breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To run the debugger, we have to add `debug` to the command after `protractor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the command, we have to move forward by typing `C`, but here
    we need to do it just once. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the debugger](img/image_05_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1\. `Selenium WebDriver` is a browser automation framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Q2\. Using `browser.debugger()` is a simple way to debug Protractor.
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Q3\. What are `by.css()`, `by.id()`, and `by.buttonText()` called?
  prefs: []
  type: TYPE_NORMAL
- en: Elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Protractor has various kinds of API. In this chapter, we tried to understand
    some of the most commonly used APIs with some examples. We also covered API types
    (such as browser, elements, locator, and actions), and how they are chained with
    one another, in some detail.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging was introduced in this chapter, and we tried to learn a simple way
    to debug, using `browser.pause()`, in more detail, and then we moved on to a complex
    method (`browser.debugger()`), and understood that complex developers need node
    debugger experience.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will delve into more real-life projects; further, we
    will go through the top-down and bottom-up approaches and learn them both.
  prefs: []
  type: TYPE_NORMAL
