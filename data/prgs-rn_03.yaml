- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Hello React Native
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 欢迎来到React Native
- en: After you learned the basics of React and React Native in [*Chapter 1*](B16694_01.xhtml#_idTextAnchor016),
    *What Is React Native?*, and the fundamentals of JavaScript and TypeScript in
    [*Chapter 2*](B16694_02.xhtml#_idTextAnchor030), *Understanding the Essentials
    of JavaScript and TypeScript*, it is now time to dive deeper into the React Native
    world.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习完React和React Native的基础知识后，包括[*第1章*](B16694_01.xhtml#_idTextAnchor016)“什么是React
    Native？”以及JavaScript和TypeScript的基础知识[*第2章*](B16694_02.xhtml#_idTextAnchor030)“理解JavaScript和TypeScript的基础”之后，现在是时候深入React
    Native的世界了。
- en: One of the best things about React Native is that it is very flexible when it
    comes to how you use it. You can choose **Expo**, which handles all the native
    part for you and allows you to complete your first app in hours. It also makes
    it possible to build iOS apps without having a Mac. But you also can go with a
    bare React Native workflow, which gives you a lot of options in terms of how you
    integrate your React Native app into your whole development landscape.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: React Native最优秀的地方之一是它在使用方式上非常灵活。你可以选择**Expo**，它会为你处理所有原生部分，让你能在几小时内完成你的第一个应用。它还使得在没有Mac的情况下构建iOS应用成为可能。但你也可以选择裸React
    Native工作流程，这为你提供了将React Native应用集成到整个开发环境中的许多选项。
- en: You can also integrate or even write your own (native) libraries. While this
    flexibility is one of the biggest strengths of React Native, it needs you to really
    understand what’s going on in the different scenarios to make the right choice
    for your project and your company.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以集成或甚至编写自己的（原生）库。虽然这种灵活性是React Native最大的优势之一，但它需要你真正理解在不同场景下发生的事情，以便为你的项目和公司做出正确的选择。
- en: This chapter will enable you to do so. You will truly understand the different
    approaches, how to leverage them, and when to use each approach.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助你做到这一点。你将真正理解不同的方法，如何利用它们，以及在何时使用每种方法。
- en: 'You will learn the following things in the sections of this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本章的各个部分学习以下内容：
- en: Understanding how React Native works on an example app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过示例应用了解React Native的工作原理
- en: Passing properties
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递属性
- en: Understanding class components, function components, and Hooks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解类组件、函数组件和Hooks
- en: Connecting different platforms to JavaScript
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将不同平台连接到JavaScript
- en: Introducing the new React Native Architecture
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍新的React Native架构
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be able to run the code in this chapter, you have to set up the following
    things:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够运行本章中的代码，你必须设置以下内容：
- en: A working React Native environment ([https://reactnative.dev/docs/environment-setup](https://reactnative.dev/docs/environment-setup)—**React
    Native command-line interface** (**CLI**) quickstart guide)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的React Native开发环境([https://reactnative.dev/docs/environment-setup](https://reactnative.dev/docs/environment-setup)—**React
    Native命令行界面** (**CLI**) 快速入门指南)
- en: While most of this chapter should also work on Windows, I would recommend working
    on a Mac
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然本章的大部分内容也应该在Windows上工作，但我建议你在Mac上工作
- en: "Understanding how React Native works on an \Lexample app"
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过示例应用了解React Native的工作原理
- en: 'There is no better way to understand a technology than by working with it.
    This section contains a simple example app that will show information about movies
    based on a static **JavaScript Object Notation** (**JSON**) file. The app will
    be further developed in the next chapters. For now, it should contain the following
    views:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实际操作来理解一项技术没有比这更好的方式了。本节包含一个简单的示例应用，该应用将根据静态**JavaScript对象表示法** (**JSON**)文件显示电影信息。应用将在下一章中进一步开发。目前，它应该包含以下视图：
- en: A home view to show a list of movie categories
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个主视图，用于显示电影类别列表
- en: A category detail page with information about the category as well as the most
    popular movies of the category, with title and poster
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含类别信息以及该类别最受欢迎的电影（包括标题和海报）的类别详情页面
- en: A movie detail page with information about the movie, including title, poster,
    rating, release date, and description
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含电影信息（包括标题、海报、评分、上映日期和描述）的电影详情页面
- en: 'While this is a very simple example, we’ll use it to focus a lot on understanding
    what’s going on under the hood. But let’s start with creating the app. We’ll use
    a React Native bare workflow to be complete in control while not having any overhead.
    That means we are using the official React Native CLI to initialize our project.
    This is done with the following command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个非常简单的例子，但我们将用它来重点理解底层发生了什么。但让我们先从创建应用开始。我们将使用React Native裸工作流程来完全控制，同时不增加任何开销。这意味着我们正在使用官方的React
    Native CLI来初始化我们的项目。这可以通过以下命令完成：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We are using a TypeScript template to directly set up our project as a TypeScript
    project. This includes the **TypeScript compiler** (**tsc**) as well as the correct
    file extensions. You will learn more about templates and other options to start
    a React Native project in [*Chapter 9*](B16694_09.xhtml#_idTextAnchor282), *Essential
    Tools for Improving React Native Development*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用TypeScript模板直接将项目设置为TypeScript项目。这包括**TypeScript编译器**（**tsc**）以及正确的文件扩展名。你将在[*第9章*](B16694_09.xhtml#_idTextAnchor282)《提高React
    Native开发的基本工具》中了解更多关于模板和其他启动React Native项目选项的内容。
- en: The preceding command creates a `videoexample` folder that contains the new
    React Native project. If you have set up everything correctly, you can start your
    example app on your iOS simulator with `cd videoexample && npx react-native run-ios`
    (iOS simulators only work on iOS; on Windows, you can use `cd videoexample &&
    npx react-native run-android` to start an Android simulator).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令创建了一个包含新React Native项目的`videoexample`文件夹。如果你已经正确设置了所有内容，你可以使用`cd videoexample
    && npx react-native run-ios`在你的iOS模拟器上启动示例应用（iOS模拟器仅适用于iOS；在Windows上，你可以使用`cd
    videoexample && npx react-native run-android`来启动Android模拟器）。
- en: 'When you have successfully started your simulator, you should see the React
    Native default app running. It should look like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你成功启动你的模拟器后，你应该能看到React Native默认应用正在运行。它应该看起来像这样：
- en: '![Figure 3.1 – React Native default app'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – React Native默认应用'
- en: '](img/B16694_03_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – React Native默认应用'
- en: Figure 3.1 – React Native default app
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – React Native默认应用'
- en: When you open the `videoexample` folder in your **integrated development environment**
    (**IDE**), you will see that the React Native CLI has created a lot of files for
    you. In the following subsection, you’ll learn what they are and what they do.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在你的**集成开发环境**（**IDE**）中打开`videoexample`文件夹时，你会看到React Native CLI为你创建了很多文件。在接下来的小节中，你将了解它们是什么以及它们的作用。
- en: Understanding the React Native example project
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解React Native示例项目
- en: 'The example project has only one screen, but technically it is a complete Android
    and iOS app. This means it contains the following things:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 示例项目只有一个屏幕，但从技术上讲，它是一个完整的Android和iOS应用。这意味着它包含以下内容：
- en: '`android`: This folder contains the native Android project. You can open this
    folder with Android Studio and work with it like a native Android app. It uses
    Gradle as the build system, which also is integrated very nicely into Android
    Studio. The most important files you may have to touch on at some point in time
    are the following ones:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android`：这个文件夹包含原生的Android项目。你可以用Android Studio打开这个文件夹，就像处理原生Android应用一样。它使用Gradle作为构建系统，并且很好地集成到Android
    Studio中。你可能在某个时候需要修改以下文件：'
- en: '`android/app/src/main/AndroidManifest.xml`: The Android manifest contains essential
    information about the app. You may have to edit this file when adding certain
    functionality to your app that needs user permission or starting the app from
    push notifications.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android/app/src/main/AndroidManifest.xml`：Android清单包含关于应用的基本信息。你可能需要在添加需要用户权限的功能或从推送通知启动应用时编辑此文件。'
- en: '`android/app/src/main/java/com/<youridentifier>/MainApplication.java & android/app/src/main/java/com/<youridentifier>/MainApplication.java`:
    These are the main files of your application. Normally you don’t have to touch
    these, but some libraries need some extra configuration here to work correctly.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android/app/src/main/java/com/<youridentifier>/MainApplication.java & android/app/src/main/java/com/<youridentifier>/MainApplication.java`：这些是应用的主要文件。通常你不需要修改这些文件，但某些库需要在这里进行一些额外的配置才能正确工作。'
- en: '`android/app/build.gradle`: This file defines the Android build process for
    your app. In most cases, React Native handles this automatically, even if you
    install third-party libraries with native parts. But in some cases, you can have
    conflicts between these libraries, or you have to do some additional configuration.
    In these cases, this is the file to look at. There is also another build file
    in `android/build.gradle`, where you can add configurations for all sub-projects/modules.'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android/app/build.gradle`: 此文件定义了你的应用的 Android 构建过程。在大多数情况下，即使你安装了具有原生部分的第三方库，React
    Native 也会自动处理此过程。但在某些情况下，你可能在这些库之间遇到冲突，或者你必须进行一些额外的配置。在这些情况下，这是你要查看的文件。在 `android/build.gradle`
    中还有一个构建文件，你可以为所有子项目/模块添加配置。'
- en: '`iOS`: This folder contains the native iOS project. It consists of your app
    project, and something called `<youridentifier>.xcodeproj`: This is your app’s
    project file. It contains only your project. Don’t use this in Xcode because it
    won’t work!'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iOS`: 此文件夹包含原生 iOS 项目。它由你的应用项目和名为 `<youridentifier>.xcodeproj` 的东西组成：这是你的应用的项目文件。它只包含你的项目。不要在
    Xcode 中使用它，因为它不会工作！'
- en: '`<youridentifier>.xcworkspace`: This is the file to work with. It contains
    your project as well as the pods’ projects. This is the file to work with in Xcode.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<youridentifier>.xcworkspace`: 这是你要工作的文件。它包含你的项目以及 pods 的项目。这是在 Xcode 中要工作的文件。'
- en: '`Podfile`: In this file, you can define dependencies for other projects. These
    dependencies are fetched via `cocoapods`. You can think of `cocoapods` like the
    `npm` or `yarn` package for native dependencies. In most cases, all dependencies
    are handled automatically by React Native, but sometimes, you must adapt the dependencies
    (at the time of writing—for example—on an M1 Mac). If you must do so, the Podfile
    is the file to look at.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Podfile`: 在此文件中，你可以定义其他项目的依赖项。这些依赖项通过 `cocoapods` 获取。你可以将 `cocoapods` 视为原生依赖项的
    `npm` 或 `yarn` 包。在大多数情况下，所有依赖项都由 React Native 自动处理，但有时你必须调整依赖项（例如，在撰写本文时——例如——在
    M1 Mac 上）。如果你必须这样做，`Podfile` 就是你要查看的文件。'
- en: Note on cocoapods
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 cocoapods 的说明
- en: '`cocoapods` is a very popular dependency management tool for iOS development.
    Nevertheless, it is not an official tool provided by Apple but an open source
    solution. The `cocoapods` team has no information about upcoming releases of Xcode
    or macOS, so it can sometimes take some time for `cocoapods` to work well with
    the latest releases.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`cocoapods` 是 iOS 开发中一个非常流行的依赖管理工具。尽管如此，它不是苹果官方提供的工具，而是一个开源解决方案。`cocoapods`
    团队没有关于 Xcode 或 macOS 即将发布的任何信息，因此 `cocoapods` 有时需要一些时间才能与最新版本良好地协同工作。'
- en: '`node_modules`: This folder is completely autogenerated during the dependency
    installation process with `npm install` or `yarn`. You don’t have to change anything
    here unless you want to patch third-party libraries.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node_modules`: 此文件夹在 `npm install` 或 `yarn` 的依赖安装过程中完全自动生成。除非你想修补第三方库，否则你不需要在此处做任何更改。'
- en: Hint on patching libraries
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 关于修补库的提示
- en: Sometimes, it can be useful to patch an existing library to fix a bug or add
    certain functionality. In these cases, you can either maintain your own fork of
    this library (which is very time-consuming) or you can use `patch-package`. `patch-package`
    is a small tool that creates patches for certain `npm` dependencies. You can read
    more on this in [*Chapter 10*](B16694_10.xhtml#_idTextAnchor347)*, Structuring
    Large-Scale, Multi-Platform Projects*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，修补现有的库以修复错误或添加某些功能可能很有用。在这些情况下，你可以维护这个库的自己的分支（这非常耗时）或者你可以使用 `patch-package`。`patch-package`
    是一个创建特定 `npm` 依赖项补丁的小工具。你可以在 [*第 10 章*](B16694_10.xhtml#_idTextAnchor347)*，*大规模、多平台项目的结构*
    中了解更多信息。
- en: '`.eslintrc.js`/`.prettierrc.js`: A fresh React Native project comes with built-in
    ESLint and Prettier support. These files contain the configurations for ESLint
    and Prettier. For more information on these tools, please read [*Chapter 9*](B16694_09.xhtml#_idTextAnchor282),
    *Essential Tools for Improving React Native Development*.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.eslintrc.js`/`.prettierrc.js`: 一个新的 React Native 项目自带内置的 ESLint 和 Prettier
    支持。这些文件包含 ESLint 和 Prettier 的配置。有关这些工具的更多信息，请参阅 [*第 9 章*](B16694_09.xhtml#_idTextAnchor282)，*提高
    React Native 开发的必备工具*。'
- en: '`.watchmanconfig`: React Native uses a tool called `watchman` to watch projects’
    files and trigger actions when they change. This is important for hot reloading
    during development. In most cases, this file is just an empty object.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.watchmanconfig`: React Native 使用一个名为 `watchman` 的工具来监视项目文件，并在它们发生变化时触发操作。这对于开发过程中的热重载非常重要。在大多数情况下，此文件只是一个空对象。'
- en: '`app.json`: This file contains information about your app, such as the app
    name.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.json`：这个文件包含有关你的应用的信息，例如应用名称。'
- en: '`babel.config.js`/`tsconfig.json`: These files contain information, standards,
    and rules for the Babel and TypeScript compiler. In most cases, you don’t have
    to edit these.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`babel.config.js`/`tsconfig.json`：这些文件包含有关Babel和TypeScript编译器的信息、标准和规则。在大多数情况下，你不需要编辑这些文件。'
- en: '`metro.config.js`: React Native uses a bundler called Metro to create your
    JavaScript bundle during development. This bundler runs on your Mac or PC, recreates
    your app’s JavaScript bundle after you have made changes, and pushes it to your
    device or simulator. This file contains the configuration of the `metro` bundler.
    In most cases, you don’t have to edit it. If you want to learn more about Metro,
    please visit the official page here: [https://facebook.github.io/metro/](https://facebook.github.io/metro/).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metro.config.js`：React Native在开发期间使用名为Metro的打包器来创建你的JavaScript包。这个打包器运行在你的Mac或PC上，在你做出更改后重新创建你的应用JavaScript包，并将其推送到你的设备或模拟器。这个文件包含`metro`打包器的配置。在大多数情况下，你不需要编辑它。如果你想了解更多关于Metro的信息，请访问官方页面：[https://facebook.github.io/metro/](https://facebook.github.io/metro/)。'
- en: '`Index.js`: This is the entry point of your JavaScript bundle. If you have
    a look at the code, it does nothing but bind it from `./App` to the native app
    via React Native `AppRegistry.registerComponent`.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Index.js`：这是你的JavaScript包的入口点。如果你查看代码，你会发现它只是通过React Native的`AppRegistry.registerComponent`将`./App`绑定到本地应用。'
- en: '`App.tsx`: This is the React Native default app. You can make changes here
    and see them directly in your simulator. This file will be replaced by our example
    application later on.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App.tsx`：这是React Native的默认应用。你可以在这里进行更改，并直接在你的模拟器中看到它们。稍后，这个文件将被我们的示例应用替换。'
- en: By getting to know all these files, you already learned a lot about React Native.
    You saw that it contains real native projects with real native dependencies, uses
    a lot of useful tools, and has a single entry point.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解所有这些文件，你已经学到了很多关于React Native的知识。你看到它包含真实本地的项目，具有真实本地的依赖项，使用了大量有用的工具，并且有一个单一的入口点。
- en: The next step for our example application is to set up a working folder structure.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例应用的下一步是设置一个工作文件夹结构。
- en: Structuring the example application
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构化示例应用
- en: First, I always recommend creating an `src` folder for all of your JavaScript/TypeScript
    code. It is always a good idea to have all the code that belongs together in one
    place.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我总是建议为所有的JavaScript/TypeScript代码创建一个`src`文件夹。将所有属于一起的代码放在一个地方总是一个好主意。
- en: 'For our example app, we create the following three subfolders in the `src`
    folder:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例应用，我们在`src`文件夹中创建了以下三个子文件夹：
- en: '`@types`: In this folder, you place your TypeScript type declarations.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@types`：在这个文件夹中，你放置你的TypeScript类型声明。'
- en: '`components`: This folder contains all reusable components.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`components`：这个文件夹包含所有可重用的组件。'
- en: '`containers`: Here, you have containers that are used to define the `ScrollView`
    containers with custom animations here. These containers are used to hold the
    content of your views.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`containers`：在这里，你可以定义带有自定义动画的`ScrollView`容器。这些容器用于存放视图的内容。'
- en: '`services`: In this folder, we’ll create our services to connect to the movies.
    In this example, it will use the static JSON file as the source; later, we’ll
    connect to an external **application programming interface** (**API**).'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`services`：在这个文件夹中，我们将创建我们的服务以连接到电影。在这个例子中，它将使用静态JSON文件作为源；稍后，我们将连接到外部**应用程序编程接口**（**API**）。'
- en: '`views`: This folder contains whole-page views. In our case, it is the three
    views defined before.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views`：这个文件夹包含整个页面的视图。在我们的例子中，它包含之前定义的三个视图。'
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are other approaches to how to structure a React Native project. Especially
    for large-scale projects, with multiple repositories, there can be ones that work
    better in some cases. You’ll learn about some of them in [*Chapter 10*](B16694_10.xhtml#_idTextAnchor347),
    *Structuring Large-Scale, Multi-Platform Projects*. For our example project, this
    structure is absolutely fine.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他方法来结构化React Native项目。特别是对于大型项目，有多个仓库的项目，在某些情况下可能会有更好的解决方案。你将在[*第10章*](B16694_10.xhtml#_idTextAnchor347)，“结构化大型、多平台项目”中了解到一些。对于我们的示例项目，这种结构绝对是可以的。
- en: To get a deeper understanding of what’s going on, we try to do the first version
    of our example project completely without any third-party libraries. This is only
    for learning purposes and is not recommended in real-world projects.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更深入地了解正在发生的事情，我们尝试在不使用任何第三方库的情况下完成我们示例项目的第一个版本。这只是为了学习目的，并不建议在实际项目中使用。
- en: 'The first thing we must decide on is the general architecture of the app. It
    can be very helpful to visualize the different parts of the application in a diagram,
    like the one you can see here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须决定的第一件事是应用程序的一般架构。在图表中可视化应用程序的不同部分可能非常有帮助，就像你在这里可以看到的那样：
- en: '![Figure 3.2 – Example app architecture'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 – 示例应用程序架构'
- en: '](img/B16694_03_02.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16694_03_02.jpg)'
- en: Figure 3.2 – Example app architecture
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 示例应用程序架构
- en: As you can see in *Figure 3.2*, we will create three views (`Home.tsx`, `Genre.tsx`,
    and `Movie.tsx`). Since we are not using any navigation library, we must use the
    state of `App.tsx` to switch between these views. All three views use the `ScrollContainer`
    container to correctly place the views’ content. They also share some reusable
    components.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图3.2*所示，我们将创建三个视图（`Home.tsx`、`Genre.tsx`和`Movie.tsx`）。由于我们没有使用任何导航库，我们必须使用`App.tsx`的状态在这些视图之间切换。所有三个视图都使用`ScrollContainer`容器来正确放置视图的内容。它们还共享一些可重用组件。
- en: 'The result is a very simple app that lets us navigate our movie content. In
    the following screenshot, you can see what it looks like:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个非常简单的应用程序，它让我们能够导航我们的电影内容。在下面的屏幕截图中，你可以看到它的样子：
- en: '![Figure 3.3 – Example app screenshot'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 – 示例应用程序截图'
- en: '](img/B16694_03_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16694_03_03.jpg)'
- en: Figure 3.3 – Example app screenshot
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 示例应用程序截图
- en: You can see a list of movie genres on the first page, a list of movies of a
    single genre on the second page, and movie details on the third page.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在第一页看到一个电影类型的列表，在第二页看到一个单一类型的电影列表，在第三页是电影详情。
- en: Now you’ve learned about the architecture and seen a high-level overview, it’s
    now time to dive deeper into the code. We’ll focus on the most interesting parts,
    but if you want to see the whole code, please go to the GitHub repository mentioned
    in the *Technical requirements* section. Let’s start with the `App.tsx` file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了架构并看到了高级概述，现在是时候深入代码了。我们将关注最有趣的部分，但如果你想看到整个代码，请参阅*技术要求*部分中提到的GitHub仓库。让我们从`App.tsx`文件开始。
- en: Creating a root view
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建根视图
- en: 'The `App.tsx` file serves as the root component of our project. It decides
    which view should be mounted and holds the global application state. Please have
    a look at the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.tsx`文件作为我们项目的根组件。它决定哪个视图应该被挂载，并持有全局应用程序状态。请查看以下代码：'
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see here, the `App.tsx` file has three state variables. This state
    can be seen as a global state because the `App.tsx` file is the root component
    of the app and can be passed down to the other components. It must contain a page
    that defines which view should be visible, and it can hold a genre and a movie.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`App.tsx`文件有三个状态变量。这个状态可以被视为全局状态，因为`App.tsx`文件是应用程序的根组件，并且可以传递给其他组件。它必须包含一个页面来定义哪个视图应该可见，并且它可以包含一个类型和一个电影。
- en: At the end of the file, you can find a `switch`/`case` statement. Based on the
    page state, this `switch/case` decides which view should be mounted. Also, the
    `App.tsx` file provides some functions to navigate through the application (`chooseGenre`,
    `chooseMovie`, `backToGenres`, `backToHome`) and passes them down to the views.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的末尾，你可以找到一个`switch`/`case`语句。根据页面状态，这个`switch/case`决定哪个视图应该被挂载。此外，`App.tsx`文件提供了一些在应用程序中导航的函数（`chooseGenre`、`chooseMovie`、`backToGenres`、`backToHome`），并将它们传递给视图。
- en: Important hint
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As you can see, the direct setter functions of the state variables (`setPage`,
    `setGenre`, `setMovie`) aren’t passed down to any view. Instead, we created functions
    that call these setter functions. This is best practice because it guarantees
    that our state is mutated in a predictable way. You should never allow your state
    to get mutated directly from outside your component. You will learn more about
    this in [*Chapter 5*](B16694_05.xhtml#_idTextAnchor110), *Managing States and
    Connecting Backends*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，状态变量的直接设置函数（`setPage`、`setGenre`、`setMovie`）并没有传递给任何视图。相反，我们创建了调用这些设置函数的函数。这是最佳实践，因为它保证了我们的状态以可预测的方式被修改。你永远不应该允许你的状态直接从组件外部被修改。你将在[*第五章*](B16694_05.xhtml#_idTextAnchor110)中了解更多关于*管理状态和连接后端*的内容。
- en: Next, let’s have a look at the views. These are pages that display content.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看视图。这些是显示内容的页面。
- en: Displaying content based on a state
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根据状态显示内容
- en: 'The `Home` view is the first page the user sees when opening the app. Please
    have a look at the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Home`视图是用户打开应用时看到的第一个页面。请查看以下代码：'
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, you can see multiple things. At the top of the code block, you can see
    that we defined an `interface` for the `props` component. This is the TypeScript
    declaration of what should be passed down to this component from the parent component
    (in this case, the `App.tsx` file). Next, we have a list of genres as state variables.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到多个东西。在代码块顶部，你可以看到我们为`props`组件定义了一个`interface`。这是TypeScript声明，说明了应该从父组件（在这种情况下，是`App.tsx`文件）传递给此组件的内容。接下来，我们有一个作为状态变量的类型列表。
- en: This is a local state or component state because it is only used inside this
    component. In the next line, we use the `useEffect` hook to call the `getGenres`
    method of our `movieService` to fetch the genres and set them to the local state.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个局部状态或组件状态，因为它只在这个组件内部使用。在下一行，我们使用`useEffect`钩子调用我们的`movieService`的`getGenres`方法来获取类型并将它们设置到局部状态。
- en: You will learn more about the `useState` and `useEffect` hooks in the *Understanding
    class components, function components, and Hooks* section of this chapter, but
    for now, it is only important that `useEffect` with an empty array as the second
    argument is called once when the component gets mounted.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本章的*理解类组件、函数组件和Hooks*部分中了解更多关于`useState`和`useEffect`钩子的内容，但到目前为止，重要的是当组件挂载时，带有空数组作为第二个参数的`useEffect`只会被调用一次。
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When working with React, the terms *mounting* and *unmounting* are used a lot.
    **Mounting** means adding components to the render tree that weren’t there before.
    A newly mounted component can trigger its lifecycle functions (class components)
    or hooks (function components). **Unmounting** means removing components from
    the render tree. This can also trigger lifecycle functions (class components)
    or Hook cleanups (function components).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用React时，经常使用*挂载*和*卸载*这两个术语。**挂载**意味着向渲染树添加之前不存在的组件。一个新挂载的组件可以触发其生命周期函数（类组件）或hooks（函数组件）。**卸载**意味着从渲染树中移除组件。这也可以触发生命周期函数（类组件）或Hook清理（函数组件）。
- en: After the `useEffect` Hook, you can see the `return` statement, which contains
    the `ScrollContainer` container, which contains the `Header` component and a list
    of `Pressable` instances, one for each genre. This list is created with the `.map`
    command.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`useEffect`钩子之后，你可以看到`return`语句，其中包含`ScrollContainer`容器，该容器包含`Header`组件和一系列`Pressable`实例，每个类型一个。这个列表是用`.map`命令创建的。
- en: Important note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This mixing of declarative UI and JavaScript data processing is one of the biggest
    strengths of React and React Native, and you will see it a lot. But whenever you
    do it, keep in mind that this is processed and recalculated every time the component
    is re-rendered. This means no expensive data processing operations should be done
    here.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种声明性UI和JavaScript数据处理混合是React和React Native最大的优势之一，你将经常看到它。但无论何时这样做，都要记住，这将在组件每次重新渲染时进行处理和重新计算。这意味着不应在此处执行昂贵的数据处理操作。
- en: 'After looking at the `Home` view, we should also have a look at the `Genre`
    view. It basically works the same way, but with one big difference. The `Genre`
    view fetches its data based on a property that is passed from the `App.tsx` file.
    Look at the `useEffect` hook of the `Genre.tsx` file here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看`Home`视图之后，我们也应该看看`Genre`视图。它基本上以相同的方式工作，但有一个很大的不同。`Genre`视图根据从`App.tsx`文件传递的属性获取其数据。在这里看看`Genre.tsx`文件的`useEffect`钩子：
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can see that the `getMoviesByGenreId` method of `movieService` needs a genre
    `Genre.tsx` file from the `App.tsx` file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`movieService`的`getMoviesByGenreId`方法需要从`App.tsx`文件中获取`Genre.tsx`文件中的类型。
- en: 'The whole process works as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程如下：
- en: The `App.tsx` file passes down a `chooseGenre` function to the `Home.tsx` file.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`App.tsx`文件将`chooseGenre`函数传递给`Home.tsx`文件。'
- en: The user clicks on a genre and triggers the `chooseGenre` function, which sets
    the genre to the `App.tsx` state and also sets the page to `GENRE` in the `App.tsx`
    file, which unmounts `Home.tsx` and mounts `Genre.tsx`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户点击一个类型并触发`chooseGenre`函数，该函数将类型设置为`App.tsx`状态，并在`App.tsx`文件中将页面设置为`GENRE`，这会导致`Home.tsx`卸载并挂载`Genre.tsx`。
- en: The `App.tsx` file passes down the genre to the `Genre.tsx` file.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`App.tsx`文件将类型传递给`Genre.tsx`文件。'
- en: The `Genre.tsx` file fetches the genre’s movies based on the genre ID.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Genre.tsx`文件根据genre ID获取该类别的电影。'
- en: The same pattern is used to set the movie and navigate to the `Movie.tsx` view.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的模式设置电影并导航到`Movie.tsx`视图。
- en: The `Movie.tsx` page does not fetch any data on its own in this example. It
    gets passed down the movie data it displays from the `App.tsx` file and needs
    no other information.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Movie.tsx`页面本身不获取任何数据。它从`App.tsx`文件中传递下来显示的电影数据，并且不需要其他信息。
- en: After understanding the views, we’ll now have a look at the components.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解视图之后，我们现在将查看组件。
- en: Using reusable components
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用可重用组件
- en: 'It is very important to move UI code that you use in different places to components,
    at least when the project grows—this is crucial to prevent duplicate code and
    an inconsistent UI. But even in a smaller project, using reusable components is
    always a good idea and speeds up development a lot. In this simple example, we
    created a `Header` component:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将在不同地方使用的UI代码移动到组件中非常重要，至少当项目增长时——这是防止代码重复和UI不一致的关键。但即使在较小的项目中，使用可重用组件也是一个好主意，并且可以大大加快开发速度。在这个简单的例子中，我们创建了一个`Header`组件：
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, this is a very simple component. It takes a string and renders
    the string in a predefined way, but even this simple component saves us quite
    some time and prevents duplicated code. Instead of having to style the header
    text in `Home.tsx`, `Genre.tsx`, and `Movie.tsx`, we can just use the `Header`
    component and get our header text styled in a consistent way.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个非常简单的组件。它接受一个字符串，并以预定义的方式渲染该字符串，但即使这个简单的组件也能为我们节省很多时间，并防止代码重复。我们不必在`Home.tsx`、`Genre.tsx`和`Movie.tsx`中分别样式化标题文本，我们只需使用`Header`组件，就可以以一致的方式获取我们的标题文本。
- en: Important note
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Use reusable components wherever you can. They ensure a consistent UI and make
    changes easily adaptable throughout the whole application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下使用可重用组件。它们确保UI的一致性，并使整个应用程序中的更改易于适应。
- en: After looking at the components, we’ll turn our attention to the services next.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看组件之后，我们将注意力转向服务。
- en: Using services to fetch data
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用服务获取数据
- en: You should always abstract the data fetching from the rest of the application.
    This is not only for logical reasons, but also if you have to change anything
    here (because of an API change), you don’t want to touch your views or components.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该始终将数据获取从应用程序的其他部分抽象出来。这不仅出于逻辑原因，而且如果您必须在此处更改任何内容（因为API更改），您不想触及您的视图或组件。
- en: 'In this example, we use two JSON files as the data source. You can find them
    in the repository under `assets/data`. The services use the files to filter or
    list the data and provide it to the views. Please have a look at the following
    code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用两个JSON文件作为数据源。您可以在存储库的`assets/data`下找到它们。服务使用这些文件来过滤或列出数据，并将其提供给视图。请查看以下代码：
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see here, we require the two JSON files in the first two lines. The
    `getGenres` and `getMovies` functions just return the content of the files, without
    any filtering. `getMovieByGenreId` takes a numeric genre ID and filters the movies
    for this ID in the `genre_ids` of the movie. It then returns the filtered `movies`
    array.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们要求在前两行提供两个JSON文件。`getGenres`和`getMovies`函数仅返回文件的内容，没有任何过滤。`getMovieByGenreId`函数接受一个数字类型的genre
    ID，并在电影的`genre_ids`中过滤出此ID的电影。然后它返回过滤后的`movies`数组。
- en: In the last line, we export the functions to be importable in our views.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，我们导出要导入到我们的视图中的函数。
- en: Important note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In larger projects, it is very common to start working with dummy data such
    as our JSON files here. This is because the frontend part is often developed in
    parallel to the API, and with the dummy data, the frontend team exactly knows
    what the data will look like. When the API is ready and the data service is well
    abstracted, it is no problem to replace the dummy data with the real-world API
    data fetching. We’ll also do this in [*Chapter 5*](B16694_05.xhtml#_idTextAnchor110),
    *Managing States and Connecting Backends*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在较大的项目中，使用类似我们这里的JSON文件这样的虚拟数据开始工作是非常常见的。这是因为前端部分通常与API并行开发，并且有了虚拟数据，前端团队可以确切地知道数据将是什么样子。当API准备就绪并且数据服务很好地抽象化后，用真实世界的API数据获取替换虚拟数据就不再成问题。我们也会在[*第5章*](B16694_05.xhtml#_idTextAnchor110)中这样做，*管理状态和连接后端*。
- en: At last, we’ll have a look at the containers.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将查看容器。
- en: Using containers for page styling
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用容器进行页面样式
- en: 'In our example, we only have one container, `ScrollContainer`. It has a very
    similar purpose to the components, but while components are mainly parts that
    are used as parts of a view, containers are used to define the (outer) layout
    of a view. Please have a look at the code of our `ScrollContainer` container here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们只有一个容器，`ScrollContainer`。它具有与组件非常相似的目的，但组件主要是作为视图的一部分使用的部分，而容器用于定义视图的（外部）布局。请查看我们的`ScrollContainer`容器代码：
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see in the interface definition, our `ScrollContainer` container
    takes only one property called `children`, which is defined as `React.ReactNode`.
    This means you can pass components to `ScrollContainer`. Also, the `children`
    property of a React component makes it possible to use this component with opening
    and closing tags while passing all JSX between the tags down to the component
    as a `children` property. This is exactly what we have done in all our views.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在界面定义中看到的，我们的`ScrollContainer`容器只接受一个名为`children`的属性，它被定义为`React.ReactNode`。这意味着你可以将组件传递给`ScrollContainer`。此外，React组件的`children`属性使得在传递所有JSX标签之间的内容时，可以使用开闭标签使用此组件，并将这些内容作为`children`属性传递给组件。这正是我们在所有视图中所做的那样。
- en: Our `ScrollContainer` container also uses a component called `SafeAreaView`.
    This is provided by React Native and handles all the different devices with notches
    (iPhone, Samsung), virtual back buttons (Android), and more.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ScrollContainer`容器也使用了一个名为`SafeAreaView`的组件。这是由React Native提供的，可以处理所有带有刘海（iPhone、三星）的设备、虚拟返回按钮（Android）等不同设备。
- en: Now that you’ve had a look at all the different parts of our first example application,
    it’s time for a short wrap-up. Up to now, you’ve learned how to structure an application,
    why it is important to abstract the different layers, and how to create reusable
    UI.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看过我们第一个示例应用的所有不同部分，是时候进行简短的总结。到目前为止，你已经学会了如何构建一个应用，为什么抽象不同的层很重要，以及如何创建可重用的UI。
- en: 'You’ve also learned that React and React Native components always consist of
    two parts: preparing the data in state/props and displaying the data with JSX.
    Maybe you also have realized that all our components are sorted in such a way
    that the data preparation is at the top of the component while the displaying
    of the data is at the bottom. I prefer this way of structuring a component because
    it makes it much more readable.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你也已经了解到，React和React Native组件始终由两部分组成：在状态/属性中准备数据，以及使用JSX显示数据。也许你也意识到，我们所有的组件都是按照这样的顺序排序的，即数据准备位于组件的顶部，而数据的显示位于底部。我更喜欢这种组件结构方式，因为它使组件的阅读性大大提高。
- en: You also already know a way to pass properties between components. Because this
    is a very important topic, we’ll focus on that in more detail in the next section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你也已经知道了一种在组件之间传递属性的方法。因为这是一个非常重要的主题，我们将在下一节中更详细地讨论。
- en: Passing properties
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递属性
- en: 'As you have already seen in the example application, there are multiple ways
    to pass data around in an application. Some best practices have been established
    that you should definitely stick to; otherwise, your application can get very
    hard to debug and maintain. We list these here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在示例应用中已经看到的，在应用中传递数据有多种方式。已经建立了一些最佳实践，你绝对应该坚持；否则，你的应用可能会变得非常难以调试和维护。我们在这里列出这些：
- en: '**Never modify a component state in an unpredictable way from outside the component**:
    I know—I repeat myself; we had this in the previous section, but this is very
    important. Modifying your state in an unpredictable way from outside the component
    can lead to bad errors, especially when you are working on a large project with
    a team of developers. But let’s have a look in detail.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**永远不要以不可预测的方式从组件外部修改组件的状态**：我知道——我再重复一遍；我们在上一节中提到过，但这非常重要。以不可预测的方式从组件外部修改状态可能会导致错误，尤其是在你与一个开发团队一起在大型项目中工作时。但让我们详细看看。'
- en: '*Unpredictable* in this scenario means that you pass the setter function of
    your state directly to other components.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，“不可预测”意味着你直接将你的状态设置函数传递给其他组件。
- en: Why is this so bad? Because other components and maybe other developers can
    decide what to put in the state of your component. It is very likely that sooner
    or later, one of them decides to put something in there that your component can’t
    handle in some edge cases.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这样很糟糕？因为其他组件和可能的其他开发者可以决定将什么放入你的组件状态。很可能 sooner or later，其中之一决定放入一些你的组件在某些边缘情况下无法处理的东西。
- en: What is the solution? There are multiple scenarios where you have to modify
    a component state from outside the component, but if you have to, do it in a predictable
    way by passing predefined functions. These functions should then verify the data
    and handle the state modification.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是什么？在多个场景中，你可能需要从组件外部修改组件状态，但如果你必须这样做，请通过传递预定义的函数以可预测的方式进行。然后，这些函数应该验证数据并处理状态修改。
- en: '`PropTypes` you can use. For more information, please look at this link: [https://www.npmjs.com/package/prop-types](https://www.npmjs.com/package/prop-types).'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`PropTypes`。更多信息，请参阅此链接：[https://www.npmjs.com/package/prop-types](https://www.npmjs.com/package/prop-types)。
- en: '**Limit the number of props you pass**: The more properties you pass, the harder
    your code will get to read and maintain, so think twice if it is necessary to
    pass a property. Also, it’s better to pass objects rather than multiple primitives.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制传递的props数量**：你传递的属性越多，你的代码就越难阅读和维护，所以如果你认为有必要传递一个属性，请三思。此外，传递对象而不是多个原始数据类型会更好。'
- en: After these best practices for passing properties, we’ll have a deeper look
    at different component types and hooks in the next section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节介绍传递属性的最好实践之后，我们将在下一节更深入地探讨不同的组件类型和hooks。
- en: Understanding class components, function components, and Hooks
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类组件、函数组件和Hooks
- en: 'React and React Native provide two different ways to write components: class
    components and function components. Nowadays, you can use both variants interchangeably.
    Both ways are supported, and there is no sign that one of them won’t be supported
    in the future. So, why do two different ways exist? This is due to historical
    reasons. Before hooks were introduced in 2019 (React 16.8), function components
    couldn’t have a state or use any lifecycle methods, which meant that any component
    that needed to fetch and store data had to be a class component. But because function
    components require less code to write, they were often used for displaying data
    that was passed as props.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: React和React Native提供了两种不同的编写组件的方式：类组件和函数组件。如今，你可以互换使用这两种变体。两种方式都受到支持，目前没有迹象表明其中任何一种在未来不会被支持。那么，为什么存在两种不同的方式呢？这要归因于历史原因。在2019年（React
    16.8）引入hooks之前，函数组件不能拥有状态或使用任何生命周期方法，这意味着任何需要获取和存储数据的组件都必须是类组件。但是，由于函数组件需要编写的代码更少，它们通常用于显示作为props传递的数据。
- en: The limitation of function components changed with the introduction of Hooks.
    **Hooks** are functions provided by React that make it possible to use functionality,
    which was limited to class components, also in function components.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Hooks的引入，函数组件的限制发生了变化。**Hooks**是React提供的函数，使得在函数组件中也能使用原本仅限于类组件的功能。
- en: Today, it depends a lot on your preferences as to whether you work with function
    components and hooks or class components and lifecycle methods. Again, function
    components are less code to write, but developers with experience in **object-oriented
    programming** (**OOP**) languages might prefer to work with class components.
    Both ways are totally fine and don’t differ in terms of performance. Only the
    app size will be a little larger when working with class components.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，是否使用函数组件和hooks或类组件和生命周期方法很大程度上取决于你的个人喜好。再次强调，函数组件需要编写的代码更少，但具有面向对象编程（**OOP**）语言经验的开发者可能更喜欢使用类组件。两种方式都是完全可行的，并且在性能方面没有差异。只是在使用类组件时，应用程序的大小会稍微大一些。
- en: In the next subsections, we’ll have a look at the different syntax and how to
    work with the different component types. We’ll start with class components.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们将探讨不同的语法以及如何处理不同组件类型。我们将从类组件开始。
- en: Working with class components and lifecycle methods
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类组件和生命周期方法
- en: As already mentioned, class components were always able to hold dynamic data
    in a changeable state. This state can be changed due to either user interaction
    or an action triggered in a lifecycle method. Lifecycle methods are methods that
    are provided by React and are called at a specific time of the component execution.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，类组件始终能够以可变状态持有动态数据。这种状态可以通过用户交互或生命周期方法中触发的事件来改变。生命周期方法是React提供的方法，在组件执行的具体时间点被调用。
- en: 'One of the most important lifecycle methods is `componentDidMount`. This method
    is called directly after a component was mounted and is often used for data fetching.
    The following code example shows a very basic example of a class component:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的生命周期方法之一是 `componentDidMount`。这个方法在组件被挂载后直接调用，通常用于数据获取。以下代码示例展示了类组件的一个非常基础的例子：
- en: '[PRE7]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The class component has one `state` property that is initialized in the constructor
    of the class. This `state` variable can hold multiple objects. In this case, it
    only contains a `num` property that gets initialized with a random number between
    `0` and `100`. The component always has to have a `render` function. This function
    contains the JSX of the component. In this example, it’s only a `Text` component
    that displays a random number to the user.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 类组件有一个 `state` 属性，它在类的构造函数中初始化。这个 `state` 变量可以持有多个对象。在这种情况下，它只包含一个 `num` 属性，该属性使用介于
    `0` 和 `100` 之间的随机数进行初始化。组件必须始终有一个 `render` 函数。这个函数包含组件的 JSX。在这个例子中，它只是一个显示随机数给用户的
    `Text` 组件。
- en: 'To bring some life to this example, we can start an interval to regenerate
    the random number every second. This is where lifecycle functions come into play.
    We would use the `componentDidMount` lifecycle function to start the interval
    and `componentWillUnmount` to clean it up. Please have a look at the following
    code snippet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这个例子更有活力，我们可以启动一个间隔，每秒重新生成一个随机数。这就是生命周期函数发挥作用的地方。我们会使用 `componentDidMount`
    生命周期函数来启动间隔，并使用 `componentWillUnmount` 来清理它。请查看以下代码片段：
- en: '[PRE8]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In `componentDidMount`, we create an interval that updates the `num` state every
    second. As you can see, we are not setting the state directly, but we are using
    the `setState` method. Remember—setting the state directly is only allowed for
    initialization in the constructor.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `componentDidMount` 中，我们创建一个间隔，每秒更新 `num` 状态。正如你所看到的，我们并没有直接设置状态，而是使用了 `setState`
    方法。记住——直接设置状态只允许在构造函数的初始化中使用。
- en: We also store the interval’s handle to `this.interval`. In `componentWillUnmount`,
    we clear `this.interval` so that we don’t have code running infinitely when we
    are navigating away from the component.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将间隔的句柄存储在 `this.interval` 中。在 `componentWillUnmount` 中，我们清除 `this.interval`，这样当我们从组件导航离开时，就不会有代码无限运行。
- en: Note
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`componentDidMount` is the right place to fetch data that is used in the component.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentDidMount` 是获取组件中使用的数据的正确位置。'
- en: 'If you want to see a running version of this example, please have a look at
    the following CodeSandbox instance: [https://codesandbox.io/s/class-component-basic-nz9cy?file=/src/index.js](https://codesandbox.io/s/class-component-basic-nz9cy?file=/src/index.js).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看到这个例子的运行版本，请查看以下 CodeSandbox 实例：[https://codesandbox.io/s/class-component-basic-nz9cy?file=/src/index.js](https://codesandbox.io/s/class-component-basic-nz9cy?file=/src/index.js)。
- en: 'After this simple example, it’s time to look at lifecycle methods a little
    closer. You’ll now get to know the most used ones, as listed here:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子之后，是时候更仔细地看看生命周期方法了。你现在将了解这里列出的最常用的方法：
- en: '`componentDidMount()`: This method is called directly after a component is
    mounted. It is called only once during the whole lifecycle of a component. It
    can be used for data fetching, adding handlers, or populating the state in any
    other way.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentDidMount()`: 这个方法在组件被挂载后直接调用。在整个组件的生命周期中，它只会被调用一次。它可以用于数据获取、添加处理程序或以任何其他方式填充状态。'
- en: '`componentWillUnmount()`: This method is called directly before a component
    gets unmounted. It is called only once during the whole lifecycle of a component.
    It should be used for cleaning up handlers, intervals, timeouts, or any other
    executing code.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillUnmount()`: 这个方法在组件即将卸载之前被调用。在整个组件的生命周期中，它只会被调用一次。它应该用于清理处理程序、间隔、超时或任何其他正在执行的代码。'
- en: '`componentDidUpdate(prevProps)`: This method is called every time a component
    gets updated and re-rendered. It can be called multiple times (a lot of times)
    during the whole lifecycle of a component. `componentDidUpdate` gets the previous
    props passed as a parameter so that you can compare them to the current props
    to check what changed. It can be used for refetching data based on changed parameters
    of the component. Please be informed that any `setState` method in the `componentDidUpdate`
    method has to be wrapped in a condition. This is for preventing infinite loops.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentDidUpdate(prevProps)`: 每当组件更新并重新渲染时，都会调用这个方法。在整个组件的生命周期中，它可能被多次调用（很多次）。`componentDidUpdate`
    方法接收作为参数传递的先前props，以便你可以将它们与当前props进行比较，以检查发生了什么变化。它可以用于根据组件参数的变化重新获取数据。请注意，在
    `componentDidUpdate` 方法中的任何 `setState` 方法都必须被条件包裹。这是为了防止无限循环。'
- en: '`shouldComponentUpdate(nextProps, nextState)`: This method is called every
    time before a re-render will take place. It can be called multiple times (a lot
    of times) during the whole lifecycle of a component. It exists only for performance
    reasons, because in some scenarios, you only want to re-render a component when
    specific parts of props or state are changing. This can be especially useful when
    working with large applications or large lists of data.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shouldComponentUpdate(nextProps, nextState)`: 这个方法在组件即将进行重新渲染之前被调用。在整个组件的生命周期中，它可能被多次调用（很多次）。它仅为了性能考虑而存在，因为在某些场景下，你可能只想在特定的props或state部分发生变化时重新渲染组件。这在处理大型应用程序或大量数据列表时特别有用。'
- en: 'There are some more lifecycle methods that aren’t used that often. If you want
    to check them out, please have a look at the official documentation here: [https://reactjs.org/docs/react-component.html](https://reactjs.org/docs/react-component.html).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些生命周期方法使用得不太频繁。如果你想了解更多，请查看官方文档：[https://reactjs.org/docs/react-component.html](https://reactjs.org/docs/react-component.html)。
- en: In this subsection, you learned the syntax of class components and how to work
    with lifecycle methods. To have a direct comparison, we’ll write the same example
    for function components with Hooks in the next subsection.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了类组件的语法以及如何使用生命周期方法。为了进行直接比较，我们将在下一个子节中为带有Hooks的函数组件编写相同的示例。
- en: Working with function components and Hooks
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数组件和Hooks
- en: 'You should already be familiar with the function component syntax since we
    were using it for the example app in the first section of this chapter. Nevertheless,
    we’ll have a look at a code example, as we did in the previous subsection about
    class components, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在本章第一部分的示例应用中使用了函数组件语法，你应该已经熟悉它了。尽管如此，我们仍将查看一个代码示例，就像我们在之前关于类组件的子节中做的那样，如下所示：
- en: '[PRE9]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, even in this small example, the code is much shorter. A function
    component is basically nothing else than a function that runs on every re-render.
    But with Hooks, especially the `useState` hook, function components provide a
    way of storing data between re-renders.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，即使在这么小的示例中，代码也要短得多。函数组件基本上就是一个在每次重新渲染时运行的函数。但是，有了Hooks，特别是 `useState` 钩子，函数组件提供了一种在重新渲染之间存储数据的方法。
- en: We use the `useState` hook to store our `num` variable in the component state.
    Function components have to return what should be rendered. You can think of the
    component as a direct `render` function. We can then use the `num` variable to
    print the random number.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `useState` 钩子将 `num` 变量存储在组件状态中。函数组件必须返回应该渲染的内容。你可以将组件视为一个直接的 `render`
    函数。然后我们可以使用 `num` 变量来打印随机数。
- en: Important hint
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: All code that you put in a function component without using Hooks or similar
    mechanisms runs on every re-render. It is basically the same as putting code in
    the `render` function of a class component. This means you should only put your
    declarative UI and cheap data processing operations there. All other operations
    should be wrapped with Hooks, to prevent performance issues.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数组件中，不使用Hooks或类似机制放入的所有代码都会在每次重新渲染时运行。这基本上和在类组件的 `render` 函数中放入代码一样。这意味着你应该只在那里放置你的声明性UI和便宜的数据处理操作。所有其他操作都应该用Hooks包裹，以防止性能问题。
- en: 'Next, we’ll start an interval to change the random number every second. We
    did the same in the example with the class component. The following code does
    exactly this in a function component:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将启动一个间隔，每秒更改一次随机数。我们在类组件的示例中也做了同样的事情。以下代码在函数组件中实现了这一点：
- en: '[PRE10]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We use the `useEffect` Hook to start the interval. The `useEffect` interval
    takes two arguments. The first one is a function that defines the effect that
    should be run. The second argument is an array, and it defines when the effect
    should be run. It is optional, and if you don’t provide it, your effect will run
    on every re-render.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`useEffect` Hook来启动间隔。`useEffect`间隔接受两个参数。第一个是一个定义应该运行的效果的函数。第二个参数是一个数组，它定义了效果应该运行的时间。它是可选的，如果你不提供它，你的效果将在每次重新渲染时运行。
- en: You can put state variables, other functions, and much more in there. If you
    do so, the effect will run every time one of the variables in this array changes.
    In our case, we want the effect to only run once when the component is mounted.
    To achieve this, we’ll use an empty array as a second argument.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在其中放置状态变量、其他函数等等。如果你这样做，效果将在数组中的任何一个变量更改时运行。在我们的情况下，我们希望效果在组件挂载时只运行一次。为了实现这一点，我们将使用空数组作为第二个参数。
- en: We also return an anonymous function that clears the interval in the effect.
    This is a cleanup function. This cleanup function runs when the component unmounts
    and before running the effect the next time. Since we only run the effect on mount,
    the cleanup function only runs on unmount.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还返回一个清除效果的匿名函数。这是一个清理函数。这个清理函数在组件卸载时运行，并在下次运行效果之前。由于我们只在挂载时运行效果，因此清理函数只在卸载时运行。
- en: 'If you want to run this example, please have a look at the following CodeSandbox
    instance: [https://codesandbox.io/s/function-component-basic-yhsrlo](https://codesandbox.io/s/function-component-basic-yhsrlo).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想运行这个示例，请查看以下CodeSandbox实例：[https://codesandbox.io/s/function-component-basic-yhsrlo](https://codesandbox.io/s/function-component-basic-yhsrlo)。
- en: After this simple example, it’s time to take a deeper look at the most important
    Hooks. We already used two of them, which are by far the most important ones.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的示例之后，是时候深入探讨最重要的Hooks了。我们已经使用了其中两个，它们无疑是其中最重要的。
- en: Working with stateless function components with useState
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用无状态函数组件和useState
- en: 'The `useState` Hook makes it possible to store information between re-renders.
    and create stateful function components. It returns an array with two entries.
    The first one is the state variable, while the second one is the setter function
    for the state variable. In most cases, you will use array destructuring to access
    both entries in one line, as in the following code example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState` Hook使得在重新渲染之间存储信息并创建有状态函数组件成为可能。它返回一个包含两个条目的数组。第一个是状态变量，而第二个是状态变量的设置函数。在大多数情况下，你将使用数组解构在一行中访问这两个条目，如下面的代码示例所示：'
- en: '[PRE11]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `useState` function also takes one argument that you can use to define the
    default value of the state variable. This is the value it gets initialized with.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState`函数还接受一个参数，你可以使用它来定义状态变量的默认值。这是它初始化时得到的值。'
- en: To change the value of the state, you always have to use the setter function.
    Never set the value directly since this won’t trigger any re-renders or other
    React internals.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改状态值，你总是必须使用设置函数。永远不要直接设置值，因为这不会触发任何重新渲染或其他React内部操作。
- en: 'To change the value and trigger a re-render, you can simply call the setter
    function with a fixed value. This is how it looks:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改值并触发重新渲染，你可以简单地使用固定值调用设置函数。这就是它的样子：
- en: '[PRE12]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is what you’ll do most of the time, but you also can pass an update function.
    This can be very useful when you have to do state updates based on the old state,
    like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你大部分时间会做的事情，但你也可以传递一个更新函数。当你需要根据旧状态进行状态更新时，这非常有用，例如：
- en: '[PRE13]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, we’ll pass a function that takes the previous value as a single
    argument. We can now use this value to return the new value, which will then be
    used in the setter. This is especially useful when incrementing or decrementing
    values.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将传递一个函数，该函数接受前一个值作为单个参数。现在我们可以使用这个值来返回新值，然后这个值将被用于设置函数。这在递增或递减值时特别有用。
- en: Now that we are able to store data between re-renders, we’ll want to run some
    functions after certain events.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够在重新渲染之间存储数据，我们将在某些事件之后运行一些函数。
- en: Using effects with useEffect
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用useEffect与效果一起使用
- en: The `useEffect` Hook is used to run code after certain events. These events
    can be the mounting of a component or an update of a component. The first argument
    of the `useEffect` Hook has to be a function that will be run when the effect
    is triggered.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect` 钩子用于在特定事件之后运行代码。这些事件可以是组件的挂载或组件的更新。`useEffect` 钩子的第一个参数必须是一个函数，当效果被触发时将运行此函数。'
- en: The second argument is an array that can be used to limit the events the effect
    should trigger on. It is optional, and when you don’t provide it, the effect runs
    on mount and on every update that triggers a re-render. If you provide it as an
    empty array, the effect runs only on mount. If you provide values in the array,
    the effect is limited to running only if one of the provided values changes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个数组，可以用来限制效果应该触发的事件。这是可选的，当你不提供它时，效果在挂载时运行，并在每次触发重新渲染的更新时运行。如果你提供一个空数组，效果仅在挂载时运行。如果你在数组中提供值，效果仅限于在提供的值之一发生变化时运行。
- en: 'There is one very important thing to mention here. If you use references to
    variables and functions that can change between re-renders inside your `useEffect`
    Hook, you have to include them in the dependencies. This is because otherwise,
    you could have a reference to stale data in your `useEffect` Hook. Please have
    a look at the following diagram for an illustration of this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一件非常重要的事情需要提及。如果你在 `useEffect` 钩子内部使用可以改变重新渲染之间变量的引用和函数，你必须将它们包含在依赖项中。这是因为否则，你可能在
    `useEffect` 钩子中有一个指向陈旧数据的引用。请查看以下图表以了解这一点的说明：
- en: '![Figure 3.4 – References in useEffect'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – useEffect 中的引用'
- en: '](img/B16694_03_04.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16694_03_04.jpg)'
- en: Figure 3.4 – References in useEffect
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – useEffect 中的引用
- en: On the left side, you see what happens when you don’t include a state variable—which
    you access inside your `useEffect` Hook—in the dependencies. In this case, the
    state variable changes and triggers a re-render, but since your `useEffect` Hook
    has no connection to the state variable, it does not know that there was a change.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在图的左侧，你可以看到当你没有在依赖项中包含一个状态变量——你是在你的 `useEffect` 钩子内部访问这个状态变量——会发生什么。在这种情况下，状态变量发生变化并触发了重新渲染，但由于你的
    `useEffect` 钩子没有与状态变量建立连接，它不知道发生了变化。
- en: When the effect runs the next time—for example, triggered by a change in another
    dependency—you’ll access the stale (old) version of your state variable. This
    is very important to know because it can lead to very serious and hard-to-find
    bugs.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当效果下次运行时——例如，由另一个依赖项的变化触发——你会访问你状态变量的陈旧（旧）版本。这一点非常重要，因为它可能导致非常严重且难以发现的错误。
- en: On the right side of the diagram, you see what happens when you include the
    state variable in the dependencies of the `useEffect` Hook. The `useEffect` Hook
    now knows when the state variable changes and updates the reference.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在图的右侧，你可以看到当你将状态变量包含在 `useEffect` 钩子的依赖项中时会发生什么。现在 `useEffect` 钩子知道状态变量何时发生变化，并更新引用。
- en: This is the same for functions that you write in your component. Please always
    keep in mind that every function that you write inside your function component
    that is not wrapped by a Hook will be recreated on every re-render.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于你在组件中编写的函数。请始终记住，你编写在函数组件内部且未被钩子包裹的每个函数都会在每次重新渲染时被重新创建。
- en: That means if you want to access functions inside an `useEffect` Hook, you also
    have to add them to the dependencies. Otherwise, you’ll potentially reference
    stale versions of these functions. But this leads to another problem. Since the
    functions are recreated on every re-render, it would trigger your effect on every
    re-render, and this is something we don’t want most of the time.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你想在 `useEffect` 钩子内部访问函数，你也必须将它们添加到依赖项中。否则，你可能会引用这些函数的陈旧版本。但这也导致另一个问题。由于函数在每次重新渲染时都会被重新创建，它会在每次重新渲染时触发你的效果，而这通常是我们不希望看到的。
- en: This is where two other Hooks come into play. It is possible to memoize values
    and functions between re-renders, which not only solves our `useEffect` triggering
    problem but also improves performance significantly.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是两个其他钩子发挥作用的地方。在重新渲染之间，你可以缓存值和函数，这不仅解决了我们的 `useEffect` 触发问题，而且显著提高了性能。
- en: Improving performance with useCallback and useMemo
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 useCallback 和 useMemo 提高性能
- en: Both `useCallback` and `useMemo` are Hooks to memoize things between re-renders.
    While `useCallback` is provided to memoize a function, `useMemo` is provided to
    memoize a value. The API of both Hooks is very similar. You provide a function
    and an array of dependencies. The `useCallback` Hook memoizes the function without
    executing it, while the `useMemo` Hook executes the function and memoizes the
    return value of the function.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`useCallback` 和 `useMemo` 都是用于在重新渲染之间记忆事物的 Hooks。虽然 `useCallback` 提供了记忆函数的功能，而
    `useMemo` 提供了记忆值的功能。这两个 Hooks 的 API 非常相似。你提供一个函数和一个依赖项数组。`useCallback` Hooks 在不执行函数的情况下记忆函数，而
    `useMemo` Hooks 执行函数并记忆函数的返回值。'
- en: Always keep in mind that these hooks are for performance optimization. Especially
    regarding `useMemo`, the React documentation explicitly state that there is no
    semantic guarantee that memoization works in every case. This means you have to
    write your code in a way that works even without memoization.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 总是要记住，这些 Hooks 是用于性能优化的。特别是关于 `useMemo`，React 文档明确指出，没有语义保证记忆化在所有情况下都有效。这意味着你必须以即使没有记忆化也能正常工作的方式编写你的代码。
- en: 'You now know the most common Hooks. You’ll get to know some more in [*Chapter
    5*](B16694_05.xhtml#_idTextAnchor110), *Managing States and Connecting Backends*.
    If you want to get a deeper understanding, I can recommend the official Hooks
    tutorial in the React documentation: [https://reactjs.org/docs/hooks-reference.html](https://reactjs.org/docs/hooks-reference.html).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经了解了最常见的 Hooks。你将在 [*第五章*](B16694_05.xhtml#_idTextAnchor110) 中了解更多，*管理状态和连接后端*。如果你想获得更深入的理解，我可以推荐
    React 文档中的官方 Hooks 教程：[https://reactjs.org/docs/hooks-reference.html](https://reactjs.org/docs/hooks-reference.html)。
- en: Note
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Besides the Hooks that are provided by React, you can write your own Hooks to
    share logic between function components. You can call all React Hooks inside your
    custom Hook. Please stick to the naming convention and always start your custom
    Hooks with `use`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 React 提供的 Hooks，你还可以编写自己的 Hooks 来在函数组件之间共享逻辑。你可以在自定义 Hook 中调用所有 React Hooks。请遵循命名约定，并始终以
    `use` 开头你的自定义 Hooks。
- en: After this extensive look at components, Hooks, and how the React part of React
    Native works, it’s now time to have a deeper look at the native part. As you learned
    in [*Chapter 1*](B16694_01.xhtml#_idTextAnchor016), *What Is React Native?*, React
    Native has a JavaScript part and a native part.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在对组件、Hooks 以及 React Native 的 React 部分进行了广泛的探讨之后，现在是我们深入探讨原生部分的时候了。正如你在 [*第一章*](B16694_01.xhtml#_idTextAnchor016)
    中学到的，*什么是 React Native？*，React Native 有一个 JavaScript 部分和一个原生部分。
- en: As you learned in the first section of this chapter, React Native ships with
    a complete Android project and a complete iOS project. It’s time to have a look
    at how everything is tied together.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在本章的第一节中学到的，React Native 随带了一个完整的 Android 项目和一个完整的 iOS 项目。现在是时候看看所有这些是如何联系在一起的。
- en: Connecting different platforms to JavaScript
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将不同平台连接到 JavaScript
- en: In the first subsection of this section, we’ll focus on Android and iOS because
    these are the most common platforms. At the end of this section, we’ll also have
    a look at how to deploy to the web, Mac, Windows, and even other platforms.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的第一个小节中，我们将重点关注 Android 和 iOS，因为这些是最常见的平台。在本节的最后，我们还将探讨如何部署到 Web、Mac、Windows
    以及其他平台。
- en: First, it is important to understand that React Native provides a way of communication
    between JavaScript and Native. Most of the time, you don’t need to change anything
    on the native side because the framework itself or some community libraries cover
    most of the native functionalities, but nevertheless, it is important to understand
    how it works.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重要的是要理解 React Native 提供了 JavaScript 和原生之间的通信方式。大多数时候，你不需要在原生端做任何改变，因为框架本身或一些社区库已经覆盖了大部分原生功能，但无论如何，理解它是如何工作的仍然很重要。
- en: Let’s start with the UI. When you write your UI in JavaScript, React Native
    maps your JSX components such as `View` and `Text` to native components such as
    `UIView` and `NSAttributedString` on iOS or `android.view` and `SpannableString`
    on Android. The styling of these native components is done using a layout engine
    called Yoga.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 UI 开始。当你用 JavaScript 编写 UI 时，React Native 会将你的 JSX 组件，如 `View` 和 `Text`，映射到
    iOS 上的 `UIView` 和 `NSAttributedString` 或 Android 上的 `android.view` 和 `SpannableString`
    等原生组件。这些原生组件的样式是通过一个名为 Yoga 的布局引擎来实现的。
- en: While React Native provides a lot of components for Android and iOS, there are
    some scenarios that don’t work out of the box. A good example of this is **Scalable
    Vector Graphics** (**SVG**). React Native itself does not provide SVG support
    but React Native provides the logic it uses to connect JavaScript and native components
    so that everyone can create their own mappings and components.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 React Native 为 Android 和 iOS 提供了许多组件，但有些场景并不直接支持。一个很好的例子是**可缩放矢量图形**（**SVG**）。React
    Native 本身并不提供 SVG 支持，但它提供了连接 JavaScript 和原生组件的逻辑，这样每个人都可以创建自己的映射和组件。
- en: 'And here comes the large React Native community into play. Nearly every feature
    is covered by an open source library that provides these mappings, at least for
    Android and iOS. That’s also the case for SVG support. There is a well-maintained
    library called `react-native-svg`, which you can find here: [https://github.com/react-native-svg/react-native-svg](https://github.com/react-native-svg/react-native-svg).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，大型 React Native 社区开始发挥作用。几乎每个功能都有开源库提供这些映射，至少对于 Android 和 iOS 是如此。SVG 支持也是如此。有一个维护良好的库叫做
    `react-native-svg`，您可以在以下位置找到它：[https://github.com/react-native-svg/react-native-svg](https://github.com/react-native-svg/react-native-svg)。
- en: This library provides a `<SVG />` JavaScript component that under the hood maps
    to the native SVG implementations on Android and iOS.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库提供了一个 `<SVG />` JavaScript 组件，底层映射到 Android 和 iOS 上的原生 SVG 实现。
- en: After understanding how UI mapping works, it’s time to have a look at other
    communication between JavaScript and Native. The second very common use case is
    the transfer of data such as information about user gestures, sensor information,
    or other data that can be created on one side and has to be transferred to the
    other side.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了 UI 映射的工作原理之后，是时候看看 JavaScript 和原生之间的其他通信了。第二个非常常见的用例是数据的传输，例如关于用户手势、传感器信息或其他可以在一方创建并需要传输到另一方的数据。
- en: This is done through connected methods. React Native provides a way to call
    native methods from JavaScript, pass callback functions to Native, and call these
    callbacks from Native. This is how data can be transferred in both directions.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过连接方法完成的。React Native 提供了一种从 JavaScript 调用原生方法、传递回调函数到原生，并从原生调用这些回调的方法。这就是数据如何双向传输的方式。
- en: While Android and iOS support comes out of the box, React Native is not limited
    to these platforms. Microsoft created open source projects called `react-native-windows`
    and `react-native-macos`. There are a lot of features supported by these projects
    to bring your app to Windows and macOS.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Android 和 iOS 的支持是开箱即用的，但 React Native 并不仅限于这些平台。微软创建了名为 `react-native-windows`
    和 `react-native-macos` 的开源项目。这些项目支持许多功能，可以将您的应用程序带到 Windows 和 macOS 平台。
- en: There is also a very useful project called `react-native-web` that adds web
    support to React Native. One important thing to understand is that even if you
    could use the same code base for all platforms, you might want to adapt it to
    best practices for the particular platform.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个非常有用的项目叫做 `react-native-web`，它为 React Native 添加了网络支持。一个需要理解的重要事情是，即使您可以使用相同的代码库为所有平台编写代码，您可能仍然希望将其适应特定平台的最佳实践。
- en: For example, if you are targeting the web, you might want to optimize your project
    for search engines, something that is not necessary for Android and iOS apps.
    There are multiple approaches to handling these platform-specific adjustments.
    The most common ones will be explained in [*Chapter 10*](B16694_10.xhtml#_idTextAnchor347)*,
    Structuring Large-Scale, Multi-Platform Projects*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您针对的是网络，您可能希望优化您的项目以适应搜索引擎，这对于 Android 和 iOS 应用程序来说并不是必要的。处理这些特定平台调整的方法有很多种。最常见的方法将在[*第
    10 章*](B16694_10.xhtml#_idTextAnchor347)*，结构化大规模、多平台项目*中解释。
- en: While you can use Android, iOS, Windows, macOS, and the web quite easily, you
    are not limited to them. Basically, you could use React Native to create apps
    for any platform, and you would only have to write the native part on your own.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以使用 Android、iOS、Windows、macOS 和网络，但您并不局限于它们。基本上，您可以使用 React Native 为任何平台创建应用程序，您只需自己编写原生部分即可。
- en: For a long time, all communication between JavaScript and Native was done asynchronously
    via JSON over the so-called bridge. While this works fine for most cases, it can
    lead to performance issues in some cases.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间以来，JavaScript 和原生之间的所有通信都是通过所谓的桥异步地通过 JSON 完成的。虽然这在大多数情况下都很好用，但在某些情况下可能会导致性能问题。
- en: Therefore, the React Native core team at Facebook decided to completely rewrite
    the React Native Architecture. It took a couple of years, but at the time of writing
    this book, the new architecture is rolled out at the main Facebook app, and it
    also landed in the React Native open source repository to be publicly available.
    You will learn more about the new architecture in the next section.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Facebook 的 React Native 核心团队决定完全重写 React Native 架构。这花费了几年的时间，但在撰写本书时，新的架构已经在主要的
    Facebook 应用中推出，并且它也进入了 React Native 开源仓库，可供公众使用。你将在下一节中了解更多关于新架构的内容。
- en: Introducing the new React Native Architecture
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍新的 React Native 架构
- en: 'In the last section, you learned how the connection between JavaScript and
    Native works in general. While this general idea does not change, the underlying
    implementation changes completely. Please have a look at the following diagram:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，你学习了 JavaScript 和原生之间的连接是如何工作的。虽然这个基本概念没有改变，但底层实现发生了完全的改变。请查看以下图表：
- en: '![Figure 3.5 – The new React Native Architecture'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5 – 新的 React Native 架构'
- en: '](img/B16694_03_05.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片/B16694_03_05.jpg]'
- en: Figure 3.5 – The new React Native Architecture
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 新的 React Native 架构
- en: The core of the new React Native Architecture is something called **JavaScript
    Interface** (**JSI**). It replaces the old way of communication via the bridge.
    While communication over the bridge was done with serialized JSON in an asynchronous
    way, JSI makes it possible for *JavaScript to hold references to C++ host objects
    and invoke methods on them*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 React Native 架构的核心是称为 **JavaScript 接口**（**JSI**）的东西。它取代了通过桥进行通信的旧方式。虽然通过桥的通信是以序列化的
    JSON 的异步方式进行，但 JSI 使得 *JavaScript 能够持有 C++ 主机对象的引用并调用它们的方法*。
- en: This means the JavaScript object and the C++ host object connected via JSI will
    be really aware of each other, which makes synchronous communication possible
    and makes the need for JSON serialization obsolete. This results in a huge performance
    boost for all React Native apps.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着通过 JSI 连接的 JavaScript 对象和 C++ 主机对象将真正地相互了解，这使得同步通信成为可能，并使得 JSON 序列化的需求变得过时。这为所有
    React Native 应用带来了巨大的性能提升。
- en: Another part of the rearchitecture is a new renderer called Fabric, which reduces
    the number of steps done to create a native UI. Also, using JSI, a shadow tree
    that determines what will be rendered is created directly in C++, while JavaScript
    also has a reference to it. This means JavaScript and Native can both interact
    with the shadow tree, which massively improves the responsiveness of the UI.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 重构的一部分是一个名为 Fabric 的新渲染器，它减少了创建原生 UI 所需的步骤数量。此外，使用 JSI，一个决定将要渲染内容的阴影树直接在 C++
    中创建，同时 JavaScript 也有对其的引用。这意味着 JavaScript 和原生代码都可以与阴影树交互，这极大地提高了 UI 的响应速度。
- en: The second part of the rearchitecture that benefits from JSI is called **Turbo
    Modules**. It replaces Native Modules, which was the way to connect native modules
    and JavaScript modules. While the old Native Modules all had to be initialized
    at startup because JavaScript had no information about the state of the native
    module, JSI makes it possible to delay the initialization of the module until
    it is needed.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JSI 中受益的重构的第二部分被称为 **Turbo Modules**。它取代了 Native Modules，这是连接原生模块和 JavaScript
    模块的方式。虽然旧的 Native Modules 都必须在启动时初始化，因为 JavaScript 没有关于原生模块状态的信息，但 JSI 使得在需要时延迟模块初始化成为可能。
- en: Since JavaScript can now hold a direct reference, there is also no need to work
    with serialized JSON. This results in a significant boost in the startup time
    for React Native apps.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 现在可以持有直接的引用，因此也就没有必要与序列化的 JSON 进行交互。这导致 React Native 应用的启动时间显著提升。
- en: There is also a new developer tool called **CodeGen** that gets introduced with
    the new architecture. It uses typed JavaScript to generate corresponding native
    interface files, to ensure compatibility between JavaScript and the native side.
    This is very useful when writing own libraries with native code. You will learn
    more about this in [*Chapter 10*](B16694_10.xhtml#_idTextAnchor347)*, Structuring
    Large-Scale, Multi-Platform Projects*, in the Creating Own Libraries section.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个名为 **CodeGen** 的新开发者工具与新的架构一起推出。它使用类型化 JavaScript 生成相应的原生接口文件，以确保 JavaScript
    和原生侧之间的兼容性。这在编写包含原生代码的库时非常有用。你将在[*第 10 章*](B16694_10.xhtml#_idTextAnchor347)*，在“创建自己的库”部分中的“结构化大规模、多平台项目”中了解更多关于此内容。
- en: All in all, the new architecture will bring a huge performance boost on all
    levels for every React Native app. It will take some time to switch an existing
    app to the new architecture, and it also will take some time until all common
    open source libraries have done the switch. But it will happen sooner or later,
    and it will definitely be worth the work.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，新的架构将为每个React Native应用在所有级别上带来巨大的性能提升。将现有应用切换到新架构需要一些时间，而且直到所有常见的开源库都完成切换也需要一些时间。但这是迟早的事，而且这绝对值得付出努力。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: To end this chapter, let’s have a short summary of what this chapter was about.
    You learned about what the project structure of a simple React Native app looks
    like and what the different files are for. You also know about class components
    and function components, and you understand the most important lifecycle methods
    and Hooks. Based on this, you can use component states and trigger code execution
    in both class components and function components.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束本章，让我们简要总结一下本章的内容。你学习了简单React Native应用的项目结构是什么样的，以及不同的文件分别用于什么。你还了解了类组件和函数组件，以及最重要的生命周期方法和Hooks。基于这些，你可以在类组件和函数组件中使用组件状态并触发代码执行。
- en: You also learned how JavaScript and Native are connected in React Native apps,
    what the problems are with the current (old) React Native Architecture, and what
    the new architecture is.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了JavaScript和原生在React Native应用中的连接方式，当前（旧）React Native架构的问题，以及新的架构是什么。
- en: Now that you have a good overview of how React Native works in general, let’s
    dive deeper into components, styling, storage, and navigation in the next chapter.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对React Native的整体工作原理有了很好的了解，让我们在下一章深入探讨组件、样式、存储和导航。
- en: 'Part 2: Building World-Class Apps with React Native'
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：使用React Native构建世界级应用
- en: In this part, we will focus on not only creating apps but creating first-class
    apps with React Native. You will learn what you must pay attention to when working
    with React Native to create apps with native performance and a world-class user
    experience.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '在这部分，我们将不仅关注创建应用，还要使用React Native创建一流的应用。你将学习在创建具有原生性能和世界级用户体验的应用时，必须注意哪些事项。 '
- en: 'The following chapters are in this section:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节包含在本节中：
- en: '[*Chapter 4*](B16694_04.xhtml#_idTextAnchor079), *Styling, Storage, and Navigation
    in React Native*'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B16694_04.xhtml#_idTextAnchor079)，*React Native中的样式、存储和导航*'
- en: '[*Chapter 5*](B16694_05.xhtml#_idTextAnchor110), *Managing States and Connecting
    Backends*'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B16694_05.xhtml#_idTextAnchor110)，*管理状态和连接后端*'
- en: '[*Chapter 6*](B16694_06.xhtml#_idTextAnchor130), *Working with Animations*'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B16694_06.xhtml#_idTextAnchor130)，*与动画一起工作*'
- en: '[*Chapter 7*](B16694_07.xhtml#_idTextAnchor236), *Handling Gestures in React
    Native*'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B16694_07.xhtml#_idTextAnchor236)，*在React Native中处理手势*'
- en: '[*Chapter 8*](B16694_08.xhtml#_idTextAnchor268), *JavaScript Engines and Hermes*'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B16694_08.xhtml#_idTextAnchor268)，*JavaScript引擎和Hermes*'
- en: '[*Chapter 9*](B16694_09.xhtml#_idTextAnchor282), *Essential Tools for Improving
    React Native Development*'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B16694_09.xhtml#_idTextAnchor282)，*提高React Native开发的基本工具*'
