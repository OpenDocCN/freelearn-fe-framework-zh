- en: '*Chapter 1*: Exploring React Testing Library'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*: 探索 React 测试库'
- en: '**React Testing Library** is a modern tool for testing the UI output of React
    components. It abstracts a lot of boilerplate code, allowing you to write code
    that is easier to read, and allows you to test the code. The library encourages
    you to move away from testing implementation details, to avoid many false negative
    and false positive test cases. Instead, the library''s API of tools makes it easy
    for you to write tests that simulate actual users'' behaviors with your components,
    yielding confidence that the application works as expected for users. Also, because
    the library urges you to focus on the user when writing tests, you don''t need
    to continuously update tests that fail when you refactor the code''s implementation
    details. The React Testing Library allows you to write tests that fail when critical
    functionality unexpectedly changes, thus providing more value.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**React 测试库** 是一个用于测试 React 组件 UI 输出的现代工具。它抽象了很多样板代码，使你能够编写更易于阅读的代码，并允许你测试代码。该库鼓励你远离测试实现细节，以避免许多错误的否定和错误的肯定测试用例。相反，该库的工具
    API 使你能够轻松编写模拟实际用户行为的测试用例，从而对应用程序按预期工作有信心。此外，由于该库敦促你在编写测试时关注用户，因此你不需要在重构代码的实现细节时不断更新失败的测试。React
    测试库允许你编写在关键功能意外更改时失败的测试，从而提供更多价值。'
- en: By the end of this chapter, you will understand what the implementation details
    are and the disadvantages they bring regarding maintenance and value in your test
    cases. For many years, it has been common for teams to test their components by
    focusing on the code's implementation details. Many teams still use this approach
    today. However, there are better ways to test the components that we will cover
    in this chapter. You will learn how to add confidence to your test case planning
    by understanding how to shift your thinking toward testing from the user's perspective.
    We will introduce you to the ideas behind the **Document Object Model** (**DOM**)
    Testing Library to ease the task of testing before transitioning to the primary
    focus, the React version of the library.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解实现细节是什么以及它们在测试用例的维护和价值方面带来的缺点。多年来，团队通过关注代码的实现细节来测试他们的组件已经成为一种常见的做法。许多团队至今仍在使用这种方法。然而，在本章中，我们将介绍更好的测试组件的方法。你将学习如何通过理解如何从用户的角度转变思维来测试，从而增强你的测试用例规划信心。我们将介绍
    **文档对象模型** (**DOM**) 测试库背后的理念，以简化测试任务，在转向主要关注点，即库的 React 版本之前。
- en: Next, you will learn about the Jest testing framework, tasked with executing
    and asserting our tests' output. Finally, you will learn how to install and use
    the `jest-dom` utility to enhance test assertions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习关于 Jest 测试框架，该框架负责执行和断言我们的测试输出。最后，你将学习如何安装和使用 `jest-dom` 工具来增强测试断言。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Learning about the DOM Testing Library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 DOM 测试库
- en: Understanding the role of Jest in testing React applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Jest 在测试 React 应用程序中的作用
- en: Learning about the advantages of using `jest-dom` to test React applications
    with Jest
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解使用 `jest-dom` 测试 Jest 的 React 应用程序的优点
- en: Understanding the disadvantages of implementation detail-focused testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解以实现细节为重点的测试的缺点
- en: The lessons of this chapter will set the foundation for understanding how you
    will use React Testing Library throughout this book to write better tests that
    focus on the user's perspective. The skills gained in this chapter will help whether
    you are new to writing tests for React applications or are an experienced tester
    looking for better ways to verify that your code works as expected.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的教训将为理解你将如何在本书中使用 React 测试库来编写更好的、关注用户视角的测试奠定基础。本章获得的知识将帮助你在编写 React 应用程序的测试时，无论是新手还是经验丰富的测试人员寻找更好的验证代码按预期工作的方式。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For the examples in this chapter, you will need to have Node.js installed on
    your machine. You can find the code examples for this chapter here: [https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter01](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter01).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的示例，你需要在你的机器上安装 Node.js。你可以在这里找到本章的代码示例：[https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter01](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter01)。
- en: Introducing the DOM Testing Library
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍DOM测试库
- en: The **DOM Testing Library** is a collection of tools created by Kent C. Dodds
    and numerous contributors to make our lives easier when our goal is to test our
    applications' UI from real users' perspectives. This section will give you an
    overview of how the library can help make testing efforts focused on users' perspectives
    a lot easier.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**DOM测试库**是由Kent C. Dodds和众多贡献者创建的一系列工具集合，旨在在我们测试应用程序UI时从真实用户的视角出发时使我们的工作更加轻松。本节将为您概述该库如何帮助使关注用户视角的测试工作变得更加容易。'
- en: What is the DOM Testing Library?
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是DOM测试库？
- en: The DOM Testing Library makes it easier to test the UI of applications like
    real users to gain confidence that the application works as expected for users.
    There are no methods to get the component's state value or directly invoke component
    methods.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: DOM测试库使得像真实用户一样测试应用程序的UI变得更加容易，从而增强我们对应用程序按预期为用户工作的信心。没有方法可以获取组件的状态值或直接调用组件方法。
- en: 'The library encourages you to select DOM elements in ways that are available
    to all users. The library''s API includes accessibility-focused query methods
    allowing you to interact with the DOM like users with disabilities who require
    tools such as screen readers or other forms of assistive technology to navigate
    applications. For example, say you want to select the following element in your
    test:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 该库鼓励您以所有用户都可以使用的方式选择DOM元素。库的API包括关注可访问性的查询方法，允许您以需要屏幕阅读器或其他辅助技术来导航应用程序的残疾用户一样与DOM交互。例如，假设您想在测试中选择以下元素：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, we have an input element of type `"text"`. You could
    select the input on the screen by its placeholder value of `"First Name..."` with
    the DOM Testing Library like so:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码中，我们有一个类型为 `"text"` 的输入元素。您可以使用DOM测试库通过其占位符值 `"First Name..."` 来在屏幕上选择该输入元素：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `getByPlaceholderText` method is used from the screen object to select the
    DOM element by its placeholder value in the preceding code. The screen object
    allows you to select elements attached to the body element of the DOM. Notice
    the regular expression used in the query. It is doubtful that a user would care
    if the text were in upper or lowercase, so the DOM Testing Library allows you
    to search for elements by text values regardless of the case.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`getByPlaceholderText` 方法用于从屏幕对象中选择DOM元素，通过前述代码中的占位符值来选择。屏幕对象允许您选择附加到DOM的body元素上的元素。注意查询中使用的正则表达式。用户可能不会在意文本是大写还是小写，因此DOM测试库允许您通过文本值来搜索元素，而不考虑大小写。'
- en: 'Having the ability to select elements by text value regardless of their case
    increases the test''s ability to maintain a passing result despite changes to
    implementation details of the element. The use of the `getByPlaceholderText` method
    is a great way to select elements, but we can be even more specific by refactoring
    the source code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 能够根据元素文本值选择元素，而不考虑其大小写，这增加了测试在元素实现细节发生变化时仍能保持通过结果的能力。使用 `getByPlaceholderText`
    方法是选择元素的好方法，但我们可以通过重构源代码来更加具体：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code, we added a `label` element and an accessible `name`
    attribute to the input. Now all users, including those using screen readers, can
    access the element. We can select the input element in our test like so:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码中，我们添加了一个 `label` 元素和一个可访问的 `name` 属性到输入元素。现在所有用户，包括使用屏幕阅读器的用户，都可以访问该元素。我们可以在测试中这样选择输入元素：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we use the `getByRole` method to select the element by
    its role of a textbox with the name `first name`. Selecting an element by its
    role is the preferred way to select elements with the DOM Testing Library when
    available.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码中，我们使用 `getByRole` 方法通过具有 `first name` 名称的文本框角色来选择元素。当可用时，通过角色选择元素是DOM测试库中首选的选择元素方式。
- en: The library is very flexible in that you can use it with any JavaScript test
    runner, such as Mocha or Jest, that provides APIs to access the DOM. We will run
    our tests with Jest in this book and learn more about it in the next section.
    There are many specific versions of the DOM Testing Library for popular UI frameworks
    and libraries.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 该库非常灵活，您可以使用它与任何提供访问DOM的API的JavaScript测试运行器一起使用，例如Mocha或Jest。本书中我们将使用Jest运行我们的测试，并在下一节中了解更多关于它的信息。DOM测试库有许多针对流行UI框架和库的特定版本。
- en: 'The particular versions add extra features to the DOM Testing Library''s API
    for more comfortable use. For example, to place a React component under test into
    the DOM, we can use the `render` method of `ReactDOM` to place the component into
    an element attached to the DOM:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 特定版本为 DOM Testing Library 的 API 添加了额外功能，以便更方便地使用。例如，要将待测试的 React 组件放入 DOM 中，我们可以使用
    `ReactDOM` 的 `render` 方法将组件放入一个附加到 DOM 的元素中：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code, first, we create a `div` element. Next, we attach `SomeComponent`
    to the `div` element. Then, we attach `div` to the `body` element of the DOM.
    Finally, we use the `getByText` method of the DOM Testing Library''s `screen`
    object to find an element with the text value of `Login`. If we use React Testing
    Library, we can replace the first three lines from the preceding code with the
    `render` method:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们创建一个 `div` 元素。接下来，我们将 `SomeComponent` 组件附加到 `div` 元素上。然后，我们将 `div`
    元素附加到 DOM 的 `body` 元素上。最后，我们使用 DOM Testing Library 的 `screen` 对象的 `getByText`
    方法来查找具有文本值 `Login` 的元素。如果我们使用 React Testing Library，我们可以将前面代码中的前三行替换为 `render`
    方法：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, we use React Testing Library's `render` method to automatically
    render the component under test into the DOM for us. We will show you how to use
    the React version of the library throughout this book. There is even support for
    many popular end-to-end testing frameworks, such as Cypress ([https://www.cypress.io/](https://www.cypress.io/)),
    which we will cover in [*Chapter 7*](B16887_07_Final_PG_ePub.xhtml#_idTextAnchor109),
    *End-to-End UI Testing with Cypress*. The library provides a utility to enhance
    test assertions with Jest, which we will cover later in this chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 React Testing Library 的 `render` 方法自动将待测试的组件渲染到 DOM 中。我们将在本书中展示如何使用库的
    React 版本。甚至支持许多流行的端到端测试框架，例如 Cypress ([https://www.cypress.io/](https://www.cypress.io/))，我们将在
    [*第 7 章*](B16887_07_Final_PG_ePub.xhtml#_idTextAnchor109)，*使用 Cypress 进行端到端 UI
    测试* 中介绍。该库提供了一个用于增强 Jest 测试断言的实用工具，我们将在本章后面介绍。
- en: Next, we will cover the guiding principles behind the DOM Testing Library.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍 DOM Testing Library 背后的指导原则。
- en: Guiding principles
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指导原则
- en: 'The DOM Testing Library is driven by providing easy-to-use APIs to test your
    rendered applications in the DOM. The tools help give you confidence that your
    tests represent actions that actual users are likely to take. For example, you
    might build an email form allowing customers to subscribe to your newsletter such
    as the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: DOM Testing Library 通过提供易于使用的 API 来驱动，以测试你在 DOM 中渲染的应用程序。这些工具有助于让你有信心，你的测试代表了实际用户可能采取的操作。例如，你可能构建一个允许客户订阅你的时事通讯的电子邮件表单，如下所示：
- en: '![Figure 1.1 – Subscription form component](img/Figure_1.1_B16887.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 订阅表单组件](img/Figure_1.1_B16887.jpg)'
- en: Figure 1.1 – Subscription form component
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 订阅表单组件
- en: Because you want to be sure that the form works, you'll think about the steps
    a potential subscriber would take while interacting with the form. You think to
    yourself, *If I were a user, first, I might look for a label named Email Address
    or a placeholder that has the text "enter an email."* The DOM Testing Library
    has a method called `getByLabelText` to quickly find the email input by the label
    displayed on the screen. The DOM Testing Library has another method called `getByPlaceholderText`
    that allows you to locate an input via its placeholder value.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你想确保表单能正常工作，所以你会考虑潜在订阅者在与表单交互时可能采取的步骤。你心想，*如果我是用户，首先，我可能会寻找一个名为“电子邮件地址”的标签或一个上面写着“输入电子邮件”的占位符*。DOM
    Testing Library 有一个名为 `getByLabelText` 的方法，可以快速通过屏幕上显示的标签找到电子邮件输入框。DOM Testing
    Library 还有一个名为 `getByPlaceholderText` 的方法，允许你通过其占位符值定位输入框。
- en: After entering the email, you think to yourself, *Next, I would look for a button
    with the text "Subscribe" and click it*. The DOM Testing Library provides a method
    called `getByText` that allows you to find a button by its text value. Also, the
    library provides a method called `getByRole` that enables you to query the DOM
    specifically for an element with the role of `button` with the `subscribe` text
    value.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入电子邮件后，你心想，*接下来，我会寻找一个上面写着“订阅”的按钮并点击它*。DOM Testing Library 提供了一个名为 `getByText`
    的方法，允许你通过文本值来查找按钮。此外，该库还提供了一个名为 `getByRole` 的方法，允许你通过 `subscribe` 文本值来查询具有 `button`
    角色的 DOM 元素。
- en: Now that you understand the DOM Testing Library's general concepts, we will
    discuss the framework we will use to execute our test cases in the next section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 DOM Testing Library 的一般概念，我们将在下一节讨论我们将用于执行测试用例的框架。
- en: Executing test cases with Jest
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jest 执行测试用例
- en: '**Jest** is a JavaScript testing framework created by the team at Facebook.
    In this section, we will cover a brief overview of Jest and how we can use it
    to verify the output of test cases for React components.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jest** 是由 Facebook 团队创建的 JavaScript 测试框架。在本节中，我们将简要介绍 Jest 以及如何使用它来验证 React
    组件测试用例的输出。'
- en: Running tests with Jest
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Jest 运行测试
- en: Most React projects are tested with Jest, so it makes sense to introduce this
    tool alongside learning React Testing Library. When we write our tests using React
    Testing Library, we need a test runner to execute the test.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 React 项目都使用 Jest 进行测试，因此在学习 React 测试库的同时介绍这个工具是有意义的。当我们使用 React 测试库编写测试时，我们需要一个测试运行器来执行测试。
- en: 'Use the following command to install Jest in your project:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令在您的项目中安装 Jest：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We will run our React tests using Jest. At a high level, Jest provides the `describe`,
    `it`, `test`, and `expect` functions to organize and execute tests. You can think
    of the `describe` function as a test suite. Use the `describe` function to group
    related tests for specific components. The `it` and `test` functions are for specific
    tests. The `it` and `test` functions are interchangeable functions used to house
    and run the code for individual test cases. Use the `expect` function to assert
    the expected output. Jest also provides mock functions to handle code outside
    the realm of tests and coverage reporting. A test written with Jest can be as
    simple as testing the output of a pure function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Jest 运行我们的 React 测试。从高层次来看，Jest 提供了 `describe`、`it`、`test` 和 `expect`
    函数来组织和执行测试。你可以把 `describe` 函数看作是一个测试套件。使用 `describe` 函数来组织特定组件的相关测试。`it` 和 `test`
    函数是针对特定测试的。`it` 和 `test` 函数是可以互换的函数，用于存放和运行单个测试用例的代码。使用 `expect` 函数来断言预期的输出。Jest
    还提供了模拟函数来处理测试范围之外的代码和覆盖率报告。使用 Jest 编写的测试可以像测试纯函数的输出一样简单。
- en: 'In the following example, we use the `test` and `expect` functions to assert
    the total number of characters in a provided name:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用 `test` 和 `expect` 函数来断言提供的名称中的字符总数：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s look at an example test that will assert the details of a `Profile`
    component created with a class-style React component. The `Profile` component
    accepts employee information and displays it as a card-style element in the DOM.
    A user can click a button to hide or show the employee''s details on the screen.
    Here is a screenshot of the component''s DOM output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例测试，该测试将断言使用类式 React 组件创建的 `Profile` 组件的详细信息。`Profile` 组件接受员工信息，并在 DOM
    中将其显示为卡片式元素。用户可以点击按钮来在屏幕上隐藏或显示员工的详细信息。以下是组件 DOM 输出的截图：
- en: '![Figure 1.2 – Profile component'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.2 – 配置组件'
- en: '](img/Figure_1.2_B16887.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.2_B16887.jpg)'
- en: Figure 1.2 – Profile component
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 配置组件
- en: 'Let''s take a look at the code for the `Profile` component. We create a `state`
    object with the `showDetails` property initially set to `true`. Next, we create
    a `setDetails` method that will update the `state` value of `showDetails`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Profile` 组件的代码。我们创建一个带有 `showDetails` 属性的 `state` 对象，初始值设置为 `true`。接下来，我们创建一个
    `setDetails` 方法，该方法将更新 `showDetails` 的 `state` 值：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Inside the `render` method, we display the `name` and `title` properties passed
    into the component:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `render` 方法内部，我们显示传递给组件的 `name` 和 `title` 属性：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the `src` image just has a placeholder image, but ideally would accept
    a passed-in value such as the `name` and `title` property values.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`src` 图像只是一个占位符图像，但理想情况下应该接受传递的值，例如 `name` 和 `title` 属性值。
- en: 'Lastly, we have a button that invokes the `setDetails` method when clicked.
    The button''s text is set to either `Hide Details` or `Display Details` based
    on the value of `state.showDetails`. Also, the employee details are displayed
    based on the value of `state.showDetails`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个按钮，当点击时将调用 `setDetails` 方法。按钮的文本设置为 `Hide Details` 或 `Display Details`，这取决于
    `state.showDetails` 的值。此外，根据 `state.showDetails` 的值显示员工详细信息：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s look at the code for a `Profile` component test that verifies the
    button with the text `"display details"` is shown when the button with the text
    `"hide details"` is clicked:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个 `Profile` 组件测试的代码，该测试验证当点击带有文本 `"hide details"` 的按钮时，显示带有文本 `"display
    details"` 的按钮：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code, we create a `div` element to later use with the component
    under test. Next, we use the `render` method of `ReactDOM` to render the `Profile`
    component with passed-in properties into `div`. Finally, we add `div` with the
    component to the `body` element of the DOM. Next, we perform actions on the resulting
    DOM output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个 `div` 元素，稍后将与测试组件一起使用。然后，我们使用 `ReactDOM` 的 `render` 方法将带有传入属性的
    `Profile` 组件渲染到 `div` 中。最后，我们将包含组件的 `div` 添加到 DOM 的 `body` 元素中。接下来，我们对生成的 DOM
    输出执行操作：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code, first we grab the button with the name `hide details`.
    Next, we fire a click event on the `hide details` button. Then, we grab the button
    with the name `display details`. Next, we will make assertions:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先我们获取名为 `hide details` 的按钮。然后，我们在 `hide details` 按钮上触发一个点击事件。接下来，我们获取名为
    `display details` 的按钮。然后，我们将进行断言：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, first, we expect the `display details` button to be *truthy*,
    meaning the element is found in the DOM. Then, we do some test cleanup by removing
    `div` from the DOM's `body` element, allowing successive tests to start from a
    clean slate.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们期望 `display details` 按钮为 *truthy*，这意味着元素在 DOM 中被找到。然后，我们通过从 DOM
    的 `body` 元素中移除 `div` 来进行一些测试清理，以便后续测试可以从一个干净的状态开始。
- en: Let's look at the previous test again by focusing on the Jest parts of the code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次查看之前的测试，重点关注代码中的 Jest 部分。
- en: 'All the code for a specific test lives inside an `it` or `test` method:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 特定测试的所有代码都位于 `it` 或 `test` 方法内部：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This method and others in the test file will execute when Jest is run with
    the `npm`) test. Jest will find your test file, execute tests within it, and show
    the test results in the console:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `npm test` 运行 Jest 时，此方法和测试文件中的其他方法将执行。Jest 将找到您的测试文件，执行其中的测试，并在控制台显示测试结果：
- en: '![Figure 1.3 – Profile test passed console output'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.3 – 配置测试通过控制台输出]'
- en: '](img/Figure_1.3_B16887.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.3 – B16887.jpg]'
- en: Figure 1.3 – Profile test passed console output
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.3 – 配置测试通过控制台输出]'
- en: 'If we had multiple tests for a component, we could organize them together in
    the `describe` method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对一个组件有多个测试，我们可以在 `describe` 方法中将它们组织在一起：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The most important part of a test is the assertion. In Jest, you can assert
    the output of the test using the `expect` method:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 测试最重要的部分是断言。在 Jest 中，您可以使用 `expect` 方法断言测试的输出：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `toBeTruthy` method chained off the `expect` method is one of many matcher
    methods that Jest provides to verify the expected result of the code passed into
    `expect`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `expect` 方法链式调用的 `toBeTruthy` 方法是 Jest 提供的许多匹配器方法之一，用于验证传递给 `expect` 的代码的预期结果。
- en: Now you understand the role Jest plays in testing React applications. You can
    install the framework and use its API to organize, write, and execute test cases.
    Next, you will learn about a utility provided by the Testing Library to add enhanced
    Jest assertion matchers to help with testing React components.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经理解了 Jest 在测试 React 应用程序中的作用。您可以为框架安装它，并使用其 API 来组织、编写和执行测试用例。接下来，您将了解
    Testing Library 提供的一个实用工具，用于添加增强的 Jest 断言匹配器，以帮助测试 React 组件。
- en: Enhancing Jest assertions with jest-dom
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 jest-dom 增强Jest断言
- en: '`jest-dom` is a utility tool from the DOM Testing Library that provides extra
    Jest assertions to use in tests. In this section, you will learn how to install
    `jest-dom` and understand the advantages of using `jest-dom` with Jest.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`jest-dom` 是 DOM 测试库的一个实用工具，它为测试提供了额外的 Jest 断言。在本节中，您将学习如何安装 `jest-dom` 并了解使用
    `jest-dom` 与 Jest 一起使用的优势。'
- en: Adding jest-dom to a project
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 jest-dom 添加到项目中
- en: 'Add `jest-dom` to a project that includes Jest using the following steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤将 `jest-dom` 添加到包含 Jest 的项目中：
- en: 'Install the package using `npm`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npm` 安装此包：
- en: '[PRE17]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add the following snippet to the top of your test file:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下片段添加到您的测试文件顶部：
- en: '[PRE18]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After installing and importing `jest-dom` into your test file, you can start
    using the extra assertions as they are now chained off the `expect` method. You
    will see detailed illustrated use cases in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 `jest-dom` 安装并导入到您的测试文件后，您就可以开始使用额外的断言了，因为它们现在都是通过 `expect` 方法链式调用的。您将在下一节中看到详细的示例用法。
- en: Advantages of using jest-dom with Jest
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 jest-dom 与 Jest 一起使用的优势
- en: You can enhance user-focused testing goals by including `jest-dom` in React
    projects that use Jest. `jest-dom` provides two significant enhancements for Jest
    assertions. First, `jest-dom` provides over 20 custom DOM matchers that create
    more descriptive test code. Second, `jest-dom` also provides better context-specific
    error messages. We will show you examples of both advantages in the following
    subsections.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在使用 Jest 的 React 项目中包含 `jest-dom` 来增强以用户为中心的测试目标。`jest-dom` 为 Jest 断言提供了两个重要的增强。首先，`jest-dom`
    提供了超过 20 个自定义 DOM 匹配器，可以创建更具描述性的测试代码。其次，`jest-dom` 还提供了更好的上下文特定错误消息。我们将在以下小节中展示这两个优势的示例。
- en: jest-dom descriptive test code examples
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: jest-dom 描述性测试代码示例]
- en: 'To illustrate the benefits of using `jest-dom`, first, we will revisit our
    `Profile` component test file from the previous section, *Introducing the DOM
    Testing Library*. Note that we will only focus on the assertion code in the test.
    We asserted the text value of an element:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明使用 `jest-dom` 的好处，首先，我们将回顾上一节中提到的 `Profile` 组件测试文件，即 *介绍 DOM 测试库*。请注意，我们只会关注测试中的断言代码。我们断言了一个元素的文本值：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The syntax of the previous code may not be as clear to some developers who are
    unfamiliar with the code base. It may not be evident that we are verifying the
    element is found in the DOM. `jest-dom` has a `toBeInTheDocument()` method to
    provide a more straightforward syntax.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的语法可能对一些不熟悉代码库的开发者来说并不清晰。可能不明显的是，我们正在验证元素是否在 DOM 中找到。`jest-dom` 有一个 `toBeInTheDocument()`
    方法可以提供更简洁的语法。
- en: 'Next, we will refactor our code using use the `jest-dom` `toBeInTheDocument()`
    method to make the code more descriptive:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `jest-dom` 的 `toBeInTheDocument()` 方法重构我们的代码，使代码更具描述性：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, from the syntax it is more apparent that we are expecting the element
    to be in the DOM. We could also assert that the `hide details` button is removed
    from the DOM when clicked:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从语法上更明显地看出，我们期望元素在 DOM 中。我们还可以断言当点击时，`hide details` 按钮将从 DOM 中移除：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Jest's `toBeFalsy()` method was used to return a `null` value, which evaluates
    to `false` in JavaScript. For the test, this means the element was not found in
    the DOM. However, the syntax is not clear that using `toBeFalsy()` indicates the
    element wasn't found in the DOM as expected and may confuse some developers looking
    at the code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 的 `toBeFalsy()` 方法被用来返回一个 `null` 值，这在 JavaScript 中评估为 `false`。对于测试来说，这意味着元素没有在
    DOM 中找到。然而，语法并不明确表明使用 `toBeFalsy()` 表示元素没有按预期在 DOM 中找到，可能会让一些查看代码的开发者感到困惑。
- en: 'We can use the `toBeInTheDocument()` method again to provide a more straightforward
    syntax:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次使用 `toBeInTheDocument()` 方法来提供更简洁的语法：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, from the syntax in the previous code it is more apparent that we expect
    the element to not be in the DOM. Notice that Jest's `not` property is used before
    the `jest-dom` method. The `not` property is used to return the opposite value.
    If we did not use the `not` property, we would be asserting the element is in
    the DOM.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从前面代码的语法中可以看出，我们期望元素不在 DOM 中。请注意，在 `jest-dom` 方法之前使用了 Jest 的 `not` 属性。`not`
    属性用于返回相反的值。如果我们没有使用 `not` 属性，我们就会断言元素在 DOM 中。
- en: 'For another example, let''s say we have the following login form we want to
    test:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，假设我们有一个以下登录表单想要测试：
- en: '![Figure 1.4 – Login component'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4 – 登录组件'
- en: '](img/Figure_1.4_B16887.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4 – 登录组件](img/Figure_1.4_B16887.jpg)'
- en: Figure 1.4 – Login component
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 登录组件
- en: 'In the previous screenshot, we have a login form feature that allows a user
    to enter a username and password and check a `disabled` state until the user enters
    values for the `username` and `password` fields. The login form in this example
    is currently still in development, so at the moment, nothing happens when a user
    clicks the **Login** button. However, we can write a test to verify the functionality
    of the **Login** button being enabled when a user enters credentials:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们有一个登录表单功能，允许用户输入用户名和密码，并检查 `disabled` 状态，直到用户为 `username` 和 `password`
    字段输入值。在这个例子中，登录表单目前仍在开发中，所以目前当用户点击 **登录** 按钮时没有任何操作。然而，我们可以编写一个测试来验证当用户输入凭据时，**登录**
    按钮被启用：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, we set up our test by rendering the `Login` component
    into the `div` tag and attaching it to the `body` element in the DOM. Next, we
    grab all the form elements, which include the `username`, `password`, `rememberMe`,
    and `login` buttons, and place them in variables.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过将 `Login` 组件渲染到 `div` 标签中并将其附加到 DOM 中的 `body` 元素来设置我们的测试。接下来，我们获取所有表单元素，包括
    `username`、`password`、`rememberMe` 和 `login` 按钮，并将它们放入变量中。
- en: 'Next, we will perform user actions on the DOM:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对DOM执行用户操作：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding code, we create a `fakeData` object with values to use in
    the test. Next, we use `fireEvent` to add values to the `username` and `password`
    fields and finally, to click the `rememberMe` checkbox. Next, we will make assertions:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个`fakeData`对象，并赋予其值以用于测试。接下来，我们使用`fireEvent`向`username`和`password`字段添加值，并最终点击`rememberMe`复选框。然后，我们将进行断言：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding code, we assert that `loginBtn` has a `disabled` attribute
    set to `false`. However, we can use a `jest-dom` assertion method for a cleaner
    syntax:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们断言`loginBtn`有一个设置为`false`的`disabled`属性。然而，我们可以使用`jest-dom`断言方法来获得更简洁的语法：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding code, we use the `toBeDisabled()` method to verify the `jest-dom`
    methods to verify the expected state of the form after entering values:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`toBeDisabled()`方法来验证`jest-dom`方法以验证输入值后表单的预期状态：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, we use the `toHaveFormValues()` method to verify the
    form inputs have the entered `fakeData` values using an easy-to-read syntax. The
    great thing about our previous test is that as long as the functionality stays
    the same, we can continue building out the login form or refactor the internal
    code without concerns that our current tests will break.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`toHaveFormValues()`方法来验证表单输入具有输入的`fakeData`值，使用易于阅读的语法。我们之前的测试的伟大之处在于，只要功能保持不变，我们就可以继续构建登录表单或重构内部代码，而不用担心当前的测试会中断。
- en: Now you understand how `jest-dom` methods allow you to write more descriptive
    test code. Next, we will use the same examples to illustrate how `jest-dom` methods
    provide better context-specific error messages.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了`jest-dom`方法如何让你编写更具描述性的测试代码。接下来，我们将使用相同的示例来说明`jest-dom`方法如何提供更好的上下文特定错误信息。
- en: jest-dom error message example
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: jest-dom错误信息示例
- en: 'In the previous section, we asserted that the `username` and `password` credentials
    for the `Login` component. We could have also asserted that the `jest-dom assertion`
    method, we could have mistakenly typed `disable` instead of `disabled` in the
    `hasAttribute` method:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们断言了`Login`组件的`username`和`password`凭证。我们还可以断言`jest-dom assertion`方法，我们可能在`hasAttribute`方法中错误地输入了`disable`而不是`disabled`：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The typo in the previous code would lead to the following test result output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中的错别字会导致以下测试结果输出：
- en: '![Figure 1.5 – Login component false negative test'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.5 – 登录组件假阴性测试'
- en: '](img/Figure_1.5_B16887.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.5_B16887.jpg)'
- en: Figure 1.5 – Login component false negative test
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – 登录组件假阴性测试
- en: In the previous screenshot, the results indicate the test failed from receiving
    a false value at the point where we expect the `true`. The result is a false negative
    because the source code was correct, but our test code was incorrect.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，结果显示测试在期望为`true`的点接收到了一个假值。结果是假阴性，因为源代码是正确的，但我们的测试代码是错误的。
- en: 'The error message does not make it obvious that the assertion code had a typo
    causing our test not to receive the expected result. We could make a similar test
    code error by mistakenly using the `not` property with the `jest-dom` `toBeDisabled`
    method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息并没有明确指出断言代码中存在错别字，导致我们的测试没有收到预期的结果。我们可能会通过错误地使用`not`属性与`jest-dom`的`toBeDisabled`方法进行类似的测试代码错误：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the previous code, we mistakenly assert the **Login** button is not disabled
    at the point in the test when it should be disabled. The test code mistake in
    the previous code would lead to the following test result output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们错误地断言在测试中应该被禁用的**登录**按钮没有被禁用。前面代码中的测试代码错误会导致以下测试结果输出：
- en: '![Figure 1.6 – Second login component false negative test](img/Figure_1.6_B16887.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6 – 第二个登录组件假阴性测试](img/Figure_1.6_B16887.jpg)'
- en: Figure 1.6 – Second login component false negative test
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 第二个登录组件假阴性测试
- en: In the previous screenshot, the results indicate the test fails, but we also
    receive helpful feedback for pinpointing the error while debugging. The test output
    informs us that the received element is disabled and logs the element to the console
    to view all the attributes. The `disabled` attribute is shown in the `element`
    output, which helps us understand that we need to debug our test code to know
    why we didn't receive the expected result.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，结果显示测试失败，但我们还收到了有助于定位错误并在调试时提供反馈的有用信息。测试输出告诉我们接收到的元素已被禁用，并将元素记录到控制台以查看所有属性。`disabled`属性在`element`输出中显示，这有助于我们理解我们需要调试测试代码以了解为什么我们没有收到预期的结果。
- en: Now you know how `jest-dom`'s methods provide better context-specific error
    messages to resolve issues faster. In the next section, we will learn about the
    disadvantages of including implementation details in our tests.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了`jest-dom`的方法如何提供更好的上下文特定错误消息以更快地解决问题。在下一节中，我们将了解在测试中包含实现细节的缺点。
- en: Testing implementation details
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试实现细节
- en: '**Implementation details** include the component state''s current value or
    explicitly invoking a method attached to a button in the DOM. Implementation details
    are the *under-the-hood* parts of components abstracted away from the user when
    they use the component. As an analogy, we can think of the experience of driving
    a car. To move, you must use the key to start the car, put the car into drive,
    and press the gas pedal. You don''t need to know how everything is wired together
    in the engine under the vehicle''s hood. You probably do not even care. All you
    care about is that you can drive the car when you perform the behaviors mentioned.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现细节**包括组件状态当前值或显式调用DOM中按钮附加的方法。实现细节是当用户使用组件时从用户抽象出来的组件的内部部分。作为一个类比，我们可以想到驾驶汽车的经历。为了移动，你必须使用钥匙启动汽车，将汽车置于驱动状态，并踩下油门。你不需要知道车辆引擎盖下的一切是如何连接的。你可能甚至不关心。你唯一关心的是，当你执行上述行为时，你可以驾驶汽车。'
- en: In this section, you will explore the disadvantages of focusing on implementation
    details in your tests. We will show you examples of tests with implementation
    details. Finally, you will learn how to shift your focus away from thinking about
    implementation details when testing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将探索在测试中关注实现细节的缺点。我们将向你展示包含实现细节的测试示例。最后，你将了解如何在测试时将注意力从考虑实现细节中转移开。
- en: Problems with implementation detail-focused tests
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注实现细节的测试的问题
- en: When you write tests that focus on your code's internal details, you create
    a scenario that increases the chance you have of refactoring your tests whenever
    you change those details. For example, if you have a state object property named
    `value` and you write a test to assert that `state.value === 3`, that test will
    fail if you change the name of the state property to `currentValue`. Having your
    test code rely on the state object property's name is a problem because it adds
    a lot of unnecessary extra maintenance and slows down your workflow.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写关注代码内部细节的测试时，你会创建一个场景，增加你每次更改这些细节时重构测试的机会。例如，如果你有一个状态对象属性名为`value`，并且编写一个测试来断言`state.value
    === 3`，那么当将状态属性名称更改为`currentValue`时，该测试将失败。让你的测试代码依赖于状态对象属性名称是一个问题，因为它增加了大量的不必要的额外维护并减慢了你的工作流程。
- en: Another problem is that executing this test case yields a false negative because
    its functionality did not change; only the state name changed. Your tests should
    give you confidence that the most valuable pieces of your application related
    to user behavior function as expected and quickly let you know why this is not
    the case.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题在于执行这个测试用例会产生一个错误的阴性结果，因为其功能并没有改变；只是状态名称发生了变化。你的测试应该让你对与应用程序中与用户行为相关的最有价值部分按预期工作充满信心，并迅速让你知道为什么这不是这种情况。
- en: Testing implementation details does not verify application code from the most
    valuable testers' perspective, that of actual users. For example, if you build
    an account creation form component and ship it to production, an end user interacting
    with the form via the UI will care about filling out the form and clicking `onChange`
    method or updates to the state object property named `usernameVal` when the user
    enters new text.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从最有价值的测试者角度——即实际用户的角度——测试实现细节并不能验证应用程序代码。例如，如果你构建了一个账户创建表单组件并将其部署到生产环境中，与表单通过UI交互的最终用户将关注填写表单并点击`onChange`方法或当用户输入新文本时对状态对象属性`usernameVal`的更新。
- en: However, you can reduce risk for users if you test that when a user fills out
    the form, and they click the **Submit** button, the expected results happen. A
    user will not directly interact with methods or state objects; therefore, our
    tests can be more valuable by focusing on how users will interact with the form
    in the UI.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你测试当用户填写表单并点击**提交**按钮时，预期的结果会发生，那么你可以降低用户的风险。用户不会直接与方法和状态对象交互；因此，我们的测试可以通过关注用户如何在UI中与表单交互而更有价值。
- en: In another example, using the same component, a software engineer is a user
    who will add the account creation form to the application code along with the
    required dependencies. The engineer user cares that the component renders as expected
    when they attempt to use it. Again, you could test the same implementation details
    mentioned in the first example.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个示例中，使用相同的组件，一个软件工程师是一个用户，他将在应用程序代码中添加账户创建表单以及所需的依赖项。工程师用户关心当他们尝试使用组件时，组件是否按预期渲染。同样，你可以测试第一个示例中提到的相同实现细节。
- en: However, you can gain more confidence that the component will work as expected
    for users if you test that when an engineer renders the form with the required
    data, the data is present. Keep in mind that this does not mean you should never
    test the implementation details of your code. In most scenarios, tests that focus
    on the user provide more confidence than tests that focus on implementation details.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你测试当工程师使用所需数据渲染表单时数据是存在的，那么你可以更有信心地认为组件将按预期为用户工作。记住，这并不意味着你应该永远不测试代码的实现细节。在大多数情况下，关注用户的测试比关注实现细节的测试更有信心。
- en: Next, we will show you an example of testing implementation details to illustrate
    this further.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将展示一个测试实现细节的示例，以进一步说明这一点。
- en: Implementation detail-focused test example
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集中于实现细节的测试示例
- en: 'Let''s look at an example test to illustrate further problems with testing
    the implementation details of components. The test will assert the details of
    a `Profile` component created with a class-style React component. The `Profile`
    component accepts employee information and displays it as a card-style element
    in the DOM. A user can click a button to hide or show the employee''s details
    on the screen. Here is a screenshot of the component''s DOM output:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例测试来进一步说明测试组件实现细节的问题。这个测试将断言使用类式React组件创建的`Profile`组件的细节。`Profile`组件接受员工信息，并在DOM中以卡片式元素的形式显示。用户可以点击按钮来在屏幕上隐藏或显示员工的详细信息。以下是组件DOM输出的截图：
- en: '![Figure 1.7 – Profile component'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.7 – Profile组件'
- en: '](img/Figure_1.7_B16887.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.7_B16887.jpg)'
- en: Figure 1.7 – Profile component
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – Profile组件
- en: 'Let''s take a look at the code for the `Profile` component. We create a state
    object with the `showDetails` property initially set to `true`. Next, we create
    a `setDetails` method that will update the state value of `showDetails`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`Profile`组件的代码。我们创建了一个带有`showDetails`属性的state对象，初始值设置为`true`。接下来，我们创建了一个`setDetails`方法，它将更新`showDetails`的状态值：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Inside the `render` method, we display the `name` and `title` properties passed
    into the component:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在`render`方法内部，我们显示传递给组件的`name`和`title`属性：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that the `src` image just has a placeholder image, but ideally would accept
    a passed-in value such as the `name` and `title` property values.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`src`图像只是一个占位符图像，但理想情况下应该接受传递的值，例如`name`和`title`属性值。
- en: 'Lastly, we have a button that invokes the `setDetails` method when clicked.
    The button''s text is set to either `Hide Details` or `Display Details` based
    on the value of `state.showDetails`. Also, employee details are displayed based
    on the value of `state.showDetails`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个按钮，当点击时会调用`setDetails`方法。按钮的文本根据`state.showDetails`的值设置为`Hide Details`或`Display
    Details`。此外，根据`state.showDetails`的值显示员工详细信息：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, let's look at the test code for the `Profile` component. The test is created
    using Enzyme, which is a React testing utility that makes it difficult to avoid
    testing implementation details and Jest. In the test file, we have one test with
    four assertions for the `Profile` component.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`Profile`组件的测试代码。这个测试是用Enzyme创建的，Enzyme是一个React测试工具，它使得避免测试实现细节变得困难，并且使用了Jest。在测试文件中，我们对`Profile`组件有一个包含四个断言的测试。
- en: 'We mount the `Profile` component into the DOM with values set for the required
    dependencies. We set the `name` property to `"John Doe"`, the `title` property
    to `"Team Lead"`, and the `details` property to `"This is my 5th year and I love
    helping others"`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Profile`组件挂载到DOM中，并设置了所需的依赖项的值。我们将`name`属性设置为`"John Doe"`，`title`属性设置为`"Team
    Lead"`，`details`属性设置为`"这是我第5年，我喜欢帮助他人"`：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we make assertions on the resulting DOM output of the `Profile` component.
    We assert the value of the `showDetails` state property. We search the DOM for
    an element with the`.card-text.details` class and assert the value of its text.
    Then, we invoke the component''s `setDetails` method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们对`Profile`组件的结果DOM输出进行断言。我们断言`showDetails`状态属性的值。我们在DOM中搜索具有`.card-text.details`类的元素，并断言其文本的值。然后，我们调用组件的`setDetails`方法：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, we assert that the `showDetails` state property has changed and that
    the element with the`.card-text.details` class is no longer in the DOM:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们断言`showDetails`状态属性已更改，并且具有`.card-text.details`类的元素不再在DOM中：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To summarize, the test makes assertions on the following implementation details:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，测试对以下实现细节进行断言：
- en: The state object
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态对象
- en: The `setDetails` method
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setDetails`方法'
- en: The element with the class `.card-text.details`
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有类`.card-text.details`的元素
- en: If one of the state object's properties changes, our test will break. If the
    `setDetails` method's name is changed or replaced with some other code without
    affecting the functionality, our test will fail. Lastly, if the class name the
    test uses to select the element changes, our test will break.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态对象的某个属性发生变化，我们的测试将失败。如果`setDetails`方法的名字被更改或替换为其他代码（不影响功能），我们的测试将失败。最后，如果测试使用的类名更改以选择元素，我们的测试将失败。
- en: As you can see, the test's assertions can yield false negative results if the
    implementation details change as compared to functionality changes. This increases
    the likelihood of a need to update the test often, and not test based on actual
    users' behavior.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果实现细节与功能变化相比发生变化，测试的断言可能会产生假阴性结果。这增加了需要经常更新测试而不是基于实际用户行为的测试的可能性。
- en: Now that you understand the disadvantages of testing implementation details,
    let's look at better ways to test.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了测试实现细节的缺点，让我们看看更好的测试方法。
- en: How to move away from implementation detail testing
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何摆脱实现细节测试
- en: 'Now that you understand the disadvantages of implementation detail-focused
    testing, how do you write tests to ensure that they will work as expected for
    users? Simply create your tests as if the software under test was a black box.
    Your thought process should be, *What are the expectations a software engineer
    or end user may have while using this piece of software?* Let''s look at the following
    `Counter` component with **Add** and **Subtract** buttons, which display the current
    value. The value is increased or decreased by 1 based on the clicked button:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了以实现细节为重点的测试的缺点，您如何编写测试以确保它们将按预期为用户工作？简单地说，就像正在测试的软件是一个黑盒一样创建您的测试。您的思考过程应该是，*在使用这个软件时，软件工程师或最终用户可能会有哪些期望？*让我们看看以下具有**添加**和**减去**按钮的`Counter`组件，这些按钮显示当前值。根据点击的按钮，值会增加或减少1：
- en: '![Figure 1.8 – Counter component'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.8 – 计数器组件'
- en: '](img/Figure_1.8_B16887.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.8_B16887.jpg)'
- en: Figure 1.8 – Counter component
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – 计数器组件
- en: Try to think of as many black-box scenarios a software engineer or end user
    may perform while using the form.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试想出尽可能多的软件工程师或最终用户在使用表单时可能执行的黑盒场景。
- en: 'Here are a few sample scenarios:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例场景：
- en: When the `Counter` component is rendered, the counter is displayed in the DOM.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`Counter`组件被渲染时，计数器在DOM中显示。
- en: When a user clicks the **Add** button, the current value is increased by 1.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户点击**添加**按钮时，当前值增加1。
- en: When a user clicks the **Subtract** button, the current value is decreased by
    1.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户点击**减去**按钮时，当前值减少1。
- en: These scenarios provide assurance that our application works as expected for
    users compared to focusing on things such as state changes or method calls.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些场景确保与关注状态变化或方法调用等事物相比，我们的应用程序按预期为用户工作。
- en: Now you know how to move away from implementation detail-focused test cases
    and instead focus on actual users. We have seen numerous examples applying the
    user-focused test approach from previous sections in this chapter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何摆脱以实现细节为重点的测试用例，而是专注于实际用户。我们已经在本章的前几节中看到了许多应用用户关注测试方法的例子。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the DOM Testing Library and how it is designed
    to help you write user-focused tests. You now understand how the design of the
    DOM Testing Library can help you gain confidence that your software works as intended
    for users. You learned how to install Jest and understand that it is a test runner
    and the tool we will use to test React code. You learned about `jest-dom`. You
    know how it can add better error messages and descriptive DOM matchers for your
    test assertions. You can now install and use `jest-dom` in a project that uses
    Jest. Finally, you have gained an understanding of the disadvantages of implementation
    detail-focused testing.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了 DOM Testing Library 以及它是如何设计来帮助你编写以用户为中心的测试的。你现在理解了 DOM Testing Library
    的设计如何帮助你获得信心，确保你的软件按预期为用户工作。你学习了如何安装 Jest，并理解它是一个测试运行器，我们将使用它来测试 React 代码。你了解了
    `jest-dom`。你知道它可以为你的测试断言添加更好的错误消息和描述性的 DOM 匹配器。你现在可以在使用 Jest 的项目中安装和使用 `jest-dom`。最后，你对实现细节为中心的测试的缺点有了理解。
- en: In the next chapter, we will learn how to install and start writing tests for
    React components using React Testing Library.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 React Testing Library 安装和开始编写 React 组件的测试。
- en: Questions
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Install all the tools mentioned in this chapter and write a simple test.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装本章中提到的所有工具，并编写一个简单的测试。
- en: Search for examples of tests online that focus on implementation details. Identify
    all implementation details and create a refactored version of the tests using
    the DOM Testing Library.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在线搜索关注实现细节的测试示例。识别所有实现细节，并使用 DOM Testing Library 创建测试的重构版本。
- en: Search MDN Web Docs for articles about ARIA roles. Next, practice writing tests
    using the `getByRole` query to select various elements.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 MDN Web Docs 中搜索关于 ARIA 角色的文章。接下来，练习使用 `getByRole` 查询来选择各种元素编写测试。
