- en: Continuous Integration and API Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成和 API 设计
- en: Before we start building more complicated features for our LOB app, LemonMart,
    we need to ensure that every code push we create has passing tests, adheres to
    the coding standards, and is an executable artifact that team members can run
    tests against, as we continue to further develop our application. Simultaneously,
    we need to start thinking about how our application will communicate with a backend
    server. Whether you, your team or another team will be creating the new APIs,
    it will be important that the API design accommodates the needs of both the frontend
    and backend architectures. To ensure a smooth development process, a robust mechanism
    is needed to create an accessible, living piece of documentation for the API.
    **Continuous Integration** (**CI**) can solve the first problem and Swagger is
    perfect to address API design, documentation, and testing needs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始为我们的 LOB 应用 LemonMart 构建更复杂的功能之前，我们需要确保我们每次代码推送都有通过的测试，并遵守编码标准，并且是团队成员可以运行测试的可执行构件，因为我们将继续进一步开发我们的应用。同时，我们还需要开始思考我们的应用将如何与后端服务器通信。无论是你、你的团队还是另一个团队将要创建新的
    API，都很重要的是，API 设计要满足前端和后端架构的需求。为了确保一个顺畅的开发过程，需要一个强大的机制来创建一个可访问的、实时的 API 文档。**持续集成**（**CI**）可以解决第一个问题，而
    Swagger 完美地解决了 API 设计、文档和测试的需求。
- en: Continuous Integration is critical to ensuring a quality deliverable by building
    and executing tests on every code push. Setting up a CI environment can be time
    consuming and requires specialized knowledge of the tool being used. CircleCI
    is an established, cloud-based CI service with a free tier and helpful articles
    to get you started with as little configuration as possible. We will go over a
    Docker-based approach that can be run on most CI services, keeping your specific
    configuration knowledge relevant and CI service knowledge down to a minimum.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成（Continuous Integration）对确保每次代码推送都能交付高质量的成果至关重要，它通过在每次代码推送时构建和执行测试来实现。建立一个
    CI 环境可能会耗费很多时间，并需要对所使用的工具有专门的了解。CircleCI 是一个成熟的云端持续集成服务，提供免费的服务套餐和相关文章，帮助你以尽可能少的配置开始使用。我们将介绍一种基于
    Docker 的方法，它可以在大多数 CI 服务上运行，让你的特定配置知识保持有效，并将 CI 服务知识降到最低限度。
- en: Another aspect of full-stack development is that you will likely be developing
    the frontend and backend of your application around the same time. Whether you
    work by yourself, as a team, or with multiple teams, it is critical to establish
    a data contract to ensure that you won't run into eleventh-hour integration challenges.
    We will use Swagger to define a data contract for a REST API and then create a
    mock server that your Angular application can make HTTP calls to. For backend
    development, Swagger can act as a great starting point to generate boilerplate
    code and can go forward as living documentation and testing UI for your API.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 全栈开发的另一个方面是你可能会同时开发应用的前端和后端。无论你是自己工作，还是和一个团队或多个团队一起工作，建立一个数据契约很关键，以确保你不会在最后关头遇到集成问题。我们将使用
    Swagger 来定义 REST API 的数据契约，然后创建一个模拟服务器，你的 Angular 应用可以向它发起 HTTP 请求。对于后端开发来说，Swagger
    可以作为生成样板代码的绝佳起点，并且可以继续作为 API 的实时文档和测试 UI。
- en: 'In this chapter, you will learn how to do the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: CI with CircleCI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 CircleCI 一起使用持续集成
- en: API design with Swagger
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Swagger 进行 API 设计
- en: 'This chapter requires the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要以下内容：
- en: A free CircleCI account
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 免费的 CircleCI 账户
- en: Docker
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Continuous Integration
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: The aim of Continuous Integration is to enable a consistent and repeatable environment
    to build, test, and generate deployable artifacts of your application with every
    code push. Before a pushing code, a developer should have a reasonable expectation
    that their build will pass; therefore creating a reliable CI environment that
    automates commands that developers can also run in their local machines is paramount.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成的目的是为了能够在每次代码推送时创建一个一致且可重复的环境，以构建、测试并生成可部署的应用构件。在推送代码之前，开发者应该合理地期望他们的构建会通过；因此，创建一个可靠的
    CI 环境，自动化开发者也可以在本地机器上运行的命令，是至关重要的。
- en: Containerizing build environment
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器化构建环境
- en: In order to ensure a consistent build environment across various OS platforms,
    developer machines, and Continuous Integration environments, you may containerize
    your build environment. Note that there are at least half-a-dozen common CI tools
    currently in use. Learning the ins and outs of each tool is almost an impossible
    task to achieve. Containerization of your build environment is an advanced concept
    that goes above and beyond of what is currently expected of CI tools. However,
    containerization is a great way to standardize over 90% of your build infrastructure,
    and can be executed in almost any CI environment. With this approach, the skills
    you learn and the build configuration you create becomes far more valuable, because
    both your knowledge and the tools you create become transferable and reusable.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保在各种 OS 平台、开发者机器和持续集成环境中保持一致的构建环境，你可以对你的构建环境进行容器化。请注意，目前至少有六种常用的 CI 工具。学习每个工具的细节几乎是不可能完成的任务。你的构建环境的容器化是一个超出当前
    CI 工具预期的先进概念。然而，容器化是标准化你的 90% 以上的构建基础设施的绝佳方式，几乎可以在任何 CI 环境中执行。通过这种方法，你学到的技能和你创建的构建配置变得更有价值，因为你的知识和你创建的工具都变得可传递和可重用。
- en: There are many strategies to containerize your build environment with different
    levels of granularity and performance expectations. For the purpose of this book,
    we will focus on reusability and ease of use. Instead of creating a complicated,
    interdependent set of Docker images that may allow for more efficient fail-first
    and recovery paths, we will focus on a single and straightforward workflow. Newer
    versions of Docker have a great feature called multi-stage builds, which allow
    you to define a multi image process in an easy-to-read manner and maintain a singular `Dockerfile`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多策略可以使你的构建环境容器化，具有不同的粒度和性能预期。为了本书的目的，我们将专注于可重用性和易用性。与其创建一组复杂的相互依赖的 Docker
    镜像，可能会允许更有效的失败优先和恢复路径，我们将专注于单一和简单的工作流程。较新版本的 Docker 具有一个很棒的功能，称为多阶段构建，它允许你以易于阅读的方式定义一个多镜像过程，并维护一个单一的`Dockerfile`。
- en: At the end of the process, you can extract an optimized container image as our
    deliverable artifact, shedding the complexity of images used previously in the
    process.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程结束时，你可以提取一个优化的容器镜像作为我们的交付产品，摆脱了先前过程中使用的镜像的复杂性。
- en: 'As a reminder your single `Dockerfile` would look like the sample below:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，你的单一`Dockerfile`看起来像下面的样例：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Multi-stage works by using multiple `FROM` statements in a single `Dockerfile`,
    where each stage can perform a task and make any resources within its instance
    available to other stages. In a build environment, we can implement various build-related
    tasks as their own stages, and then copy the end result, such as the `dist` folder
    of an Angular build to the final image, which contains a web server. In this case,
    we will implement three stages of images:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段构建通过在单个`Dockerfile`中使用多个`FROM`语句来实现，每个阶段可以执行任务并使其实例内的任何资源可用于其他阶段。在构建环境中，我们可以将各种与构建相关的任务实现为它们自己的阶段，然后将最终结果，如
    Angular 构建的`dist`文件夹，复制到包含 Web 服务器的最终镜像中。在这种情况下，我们将实现三个镜像阶段：
- en: '**Builder**: Used to build a production version of your Angular app'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建器**：用于构建你的 Angular 应用的生产版本。'
- en: '**Tester**: Used to run unit and e2e tests against a headless Chrome instances'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试程序**：用于对一个无界面 Chrome 实例执行单元测试和 e2e 测试'
- en: '**Web Server**: The final result only containing the optimized production bits'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web 服务器**：最终结果只包含了优化过的生产要素'
- en: Multi-stage builds require Docker version 17.05 or higher. To read more about
    multi-stage builds, read the documentation at [https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段构建需要 Docker 版本 17.05 或更高版本。要了解更多关于多阶段构建的信息，请阅读文档：[https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/)。
- en: Start by creating a new file to implement the multi-stage configuration, named
    `Dockerfile.integration`, at the root of your project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的文件来实现多阶段配置，命名为`Dockerfile.integration`，放在项目的根目录。
- en: Builder
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建器
- en: 'The first stage is `builder`. We need a lightweight build environment that
    can ensure consistent builds across the board. For this purpose, I''ve created
    a sample Alpine-based Node build environment complete with npm, bash, and git
    tools. For more information on why we''re using Alpine and Node, refer to [Chapter
    10](4628e6f3-23d6-4aa7-a842-d1df666718de.xhtml),* Prepare Angular App for Production
    Release*, in the *Containerizing the App using Docker* section:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个阶段是`builder`。我们需要一个轻量级的构建环境，可以确保统一的构建结果。为此，我创建了一个示例的Alpine-based Node构建环境，完整包含了npm、bash和git工具。关于为何我们使用
    Alpine 和 Node 的更多信息，请参考[第10章](4628e6f3-23d6-4aa7-a842-d1df666718de.xhtml)，*准备
    Angular 应用程序进行生产发布*，*使用 Docker 容器化应用程序*部分：
- en: 'Implement a new npm script to build your Angular app:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个新的 npm 脚本来构建你的 Angular 应用程序：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Inherit from a Node.js based build environment like `node:10.1`  or `duluca/minimal-node-build-env:8.11.2`
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继承自基于 Node.js 的构建环境，比如`node:10.1`或`duluca/minimal-node-build-env:8.11.2`。
- en: 'Implement your environment specific build script, as shown here:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现你特定环境的构建脚本，如下所示：
- en: Note that at the time of publishing a bug in low-level npm tooling is preventing `node` based
    images  from successfully installing Angular dependencies. This means that the
    sample `Dockerfile` below is based on an older version of Node and npm with `duluca/minimal-node-build-env:8.9.4`.
    In the future, when the bugs are sorted out an updated build environment will
    be able to leverage `npm ci` to install dependencies, which brings significant
    speed gains over the `npm install` command.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在出版时，低级 npm 工具中的一个 bug 阻止了基于`node`镜像成功安装 Angular 依赖项。这意味着下面的示例`Dockerfile`基于较旧版本的
    Node 和 npm，使用了`duluca/minimal-node-build-env:8.9.4`。在将来，当 bug 得到解决后，更新的构建环境将能够利用`npm
    ci`来安装依赖项，相比`npm install`命令将带来显著的速度提升。
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, the source code is being pulled from GitHub by the
    container. I have chosen to do that for the sake of keeping the sample simple,
    because it works the same way in both local and remote continuous integration
    environments. However, your CI server will already have a copy of the source code,
    which you'll want to copy from your CI environment and then into the container.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，容器正在从 GitHub 拉取源代码。我选择这样做是为了保持示例的简单性，因为它在本地和远程持续集成环境中都起作用。然而，你的 CI 服务器已经有了源代码的副本，你需要从你的
    CI 环境中复制然后在容器中使用。
- en: Instead of the `RUN git clone $GIT_REPO .` command, you can copy source code
    with the `COPY $SRC_CODE_LOCATION .` command from your CI server or your local
    machine. If you do this, you will have to implement a `.dockerignore` file that
    somewhat resembles your `.gitignore` file to ensure that secrets aren't leaked,
    `node_modules` is not copied and the configuration is repeatable in other environments.
    In a CI environment, you will want to override the environment variable `$SRC_CODE_LOCATION` so
    that the source directory of the `COPY` command is correct. Feel free to create
    multiple versions of the `Dockerfile` that may fit your various needs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 用`COPY $SRC_CODE_LOCATION .`命令替换`RUN git clone $GIT_REPO .`命令，从你的 CI 服务器或本地机器复制源代码。如果这么做，你需要实现一个`.dockerignore`文件，与你的`.gitignore`文件相似，以确保不泄露秘密，不复制`node_modules`，并且配置在其他环境中是可重复的。在
    CI 环境中，你需要重写环境变量 `$SRC_CODE_LOCATION`，使得`COPY`命令的源目录是正确的。随意创建适合各种需求的多个版本的`Dockerfile`。
- en: In addition, I have built a minimal Node build environment `duluca/minimal-node-build-env` based
    on `node-alpine`, which you can observe on Docker Hub at [https://hub.docker.com/r/duluca/minimal-node-build-env](https://hub.docker.com/r/duluca/minimal-node-build-env).
    This image is about ten times smaller than `node`. The size of Docker images have
    a real impact on build times, since the CI server or your team members will spend
    extra time pulling a larger image. Choose the environment that best fits your
    needs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我建立了一个基于`node-alpine`的最小 Node 构建环境`duluca/minimal-node-build-env`，你可以在 Docker
    Hub 上查看 [https://hub.docker.com/r/duluca/minimal-node-build-env](https://hub.docker.com/r/duluca/minimal-node-build-env)。这个镜像比`node`小约十倍。Docker
    镜像的大小对构建时间有实质影响，因为 CI 服务器或团队成员需要额外时间拉取较大的镜像。选择最适合你需求的环境。
- en: Debugging build environment
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试构建环境
- en: Depending on your particular needs, your initial setup of the builder portion
    of the `Dockerfile` may be frustrating. To test out new commands or debug errors,
    you may need to directly interact with the build environment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的特定需求，构建`Dockerfile`的初始设置可能会让人沮丧。为了测试新命令或调试错误，你可能需要直接与构建环境交互。
- en: 'To interactively experiment and/or debug within the build environment, execute
    the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要在构建环境中进行交互实验和/或调试，执行以下操作：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can test or debug commands within this temporary environment before baking
    them into your `Dockerfile`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这个临时环境中测试或调试命令，然后将它们加入到您的`Dockerfile`中。
- en: Tester
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试员
- en: The second stage is `tester`. By default, the Angular CLI generates a testing
    requirement that is geared toward a development environment. This will not work
    in a continuous integration environment; we must configure Angular to work against
    a headless browser that can execute without the assistance of a GPU and further,
    a containerized environment to execute the tests against.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段是`tester`。默认情况下，Angular CLI生成的测试要求是针对开发环境的。这在持续集成环境中不起作用；我们必须配置Angular以针对一个无需GPU辅助执行的无头浏览器以及进一步的容器化环境来执行测试。
- en: Configuring a headless browser for Angular
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Angular配置一个无头浏览器
- en: 'The protractor testing tool officially supports running against Chrome in headless
    mode. In order to execute Angular tests in a continuous integration environment,
    you will need to configure your test runner, Karma, to run with a headless Chrome
    instance:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: protractor测试工具正式支持在无头模式下运行Chrome。为了在持续集成环境中执行Angular测试，您需要配置您的测试运行器Karma使用一个无头Chrome实例来运行：
- en: 'Update `karma.conf.js` to include a new headless browser option:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`karma.conf.js`以包含新的无头浏览器选项：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `ChromiumNoSandbox` custom launcher encapsulates all the configuration elements
    needed for a good default setup.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChromiumNoSandbox`自定义启动器封装了所有需要的配置元素，以获得一个良好的默认设置。'
- en: 'Update `protractor` configuration to run in headless mode:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`protractor`配置以在无头模式下运行：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In order to test your application for responsive scenarios, you can use the
    `--window-size` option, as shown earlier, to change the browser settings.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试应用程序的响应场景，您可以使用`--window-size`选项，如前所示，来更改浏览器设置。
- en: 'Update the `package.json` scripts to select the new browser option in production
    build scenarios:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`package.json`脚本以在生产构建场景中选择新的浏览器选项：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that `test:prod` doesn't include `npm run e2e`. e2e tests are integration
    tests that take longer to execute, so  think twice about including them as part
    of your critical build pipeline. e2e tests will not run on the lightweight testing
    environment mentioned in the next section, so they will require more resources
    and time to execute.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`test:prod`不包括`npm run e2e`。e2e测试是需要更长时间来执行的集成测试，所以在包含它们作为关键构建流水线的一部分时三思而后行。e2e测试不会在下一节提到的轻量级测试环境中运行，因此它们需要更多的资源和时间来执行。
- en: Configuring testing environment
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置测试环境
- en: 'For a lightweight testing environment, we will be leveraging an Alpine-based
    installation of the Chromium browser:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于轻量级的测试环境，我们将利用基于Alpine的Chromium浏览器安装：
- en: Inherit from `slapers/alpine-node-chromium`
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继承自`slapers/alpine-node-chromium`
- en: 'Append the following configuration to `Docker.integration`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Docker.integration`后追加以下配置：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding script will copy the production build from the `builder` stage
    and execute your test scripts in a predictable manner.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本将从`builder`阶段复制生产构建，并以可预测的方式执行您的测试脚本。
- en: Web server
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web服务器
- en: 'The third and final stage generates the container that will be your web server.
    Once this stage is complete, the prior stages will be discarded and the end result
    will be an optimized sub-10 MB container:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第三和最后阶段生成将成为您web服务器的容器。一旦此阶段完成，之前的阶段将被丢弃，最终结果将是一个优化的小于10MB的容器：
- en: Containerize your application with Docker
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Docker将您的应用程序容器化
- en: Append the `FROM` statement at the end of the file
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件末尾附加`FROM`语句
- en: '`COPY` the production ready code from `builder` as shown here:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`builder`中复制生产就绪的代码，如下所示：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Build and test your multi-stage `Dockerfile`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并测试您的多阶段`Dockerfile`：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you are pulling code from GitHub, ensure that your code is committed and
    pushed before building the container, since it will pull your source code directly
    from the repository. Use the `--no-cache` option to ensure that new source code
    is pulled. If you are copying code from your local or CI environment, then do
    *not* use `--no-cache` as you won't the speed gains from being able to reuse previously
    built container layers.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从GitHub拉取代码，请确保在构建容器之前提交并推送代码，因为容器将直接从存储库中拉取源代码。使用`--no-cache`选项确保拉取新的源代码。如果您从本地或CI环境复制代码，则*不要*使用`--no-cache`，因为您不能从能够重复使用先前构建的容器层中获得速度提升。
- en: 'Save your script as a new npm script named `build:ci` as shown:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将您的脚本另存为名为`build:ci`的新npm脚本,如下所示:'
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: CircleCI
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CircleCI
- en: CircleCI makes it easy to get started with a free tier and great documentation
    for beginners and pros alike. If you have unique enterprise needs, CircleCI can
    be brought on premise, behind corporate firewalls, or as a private deployment
    in the cloud.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: CircleCI易于上手,free tier很棒,对初学者和专业人士都有很好的文档。如果您有独特的企业需求,CircleCI可以就地部署在企业防火墙后或云端的私有部署中。
- en: 'CircleCI has pre-baked build environments for virtual configuration of free
    setups, but it can also run builds using Docker containers, making it a solution
    that scales to user skills and needs, as mentioned in the *Containerizing Build
    Environment* section:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 'CircleCI为免费设置提供了预制的构建环境,但它也可以使用Docker容器运行构建,使其成为一个可以根据用户技能和需求进行扩展的解决方案,如"容器化构建环境"部分所述:'
- en: Create a CircleCI account at [https://circleci.com/](https://circleci.com/)
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 [https://circleci.com/](https://circleci.com/) 创建一个CircleCI账户
- en: 'Sign up with GitHub:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用GitHub注册:'
- en: '![](img/4f65be58-723e-4ff6-b5c4-78c8f84b8b55.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f65be58-723e-4ff6-b5c4-78c8f84b8b55.png)'
- en: CircleCI Sign up page
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: CircleCI注册页面
- en: 'Add a new project:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '添加一个新项目:'
- en: '![](img/a6a16149-7840-4de0-9131-712aeb53638b.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6a16149-7840-4de0-9131-712aeb53638b.png)'
- en: CircleCI Projects Page
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: CircleCI项目页面
- en: On the next screen, you have an option to select Linux or macOS build environments.
    The macOS build environments are very useful for building iOS or macOS apps. However,
    there is no free-tier for those environments; only Linux instances with 1x parallelism
    are free.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个屏幕上,你有选择Linux或macOS构建环境的选项。macOS构建环境非常适合构建iOS或macOS应用程序。但是,这些环境没有免费层;只有1x并行的Linux实例是免费的。
- en: Search for lemon-mart and click on Setup project
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索lemon-mart并单击"设置项目"。
- en: Select Linux
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Linux
- en: Select Platform 2.0
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择平台2.0
- en: Select Language as Other, since we'll use a custom containerized build environment
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将使用自定义容器化构建环境,因此将语言选为"其他"
- en: 'In your source code, create a folder named `.circleci` and add a file named `config.yml`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在您的源代码中,创建一个名为`.circleci`的文件夹,并添加一个名为`config.yml`的文件:'
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding file, a `build` job is defined, which is based on CircleCI's
    pre-built `docker:17.12.0-ce-git` image, containing the Docker and git CLI tools
    within itself. We then define build `steps`, which checks out the source code
    from GitHub with `checkout`, informs CircleCI to set up a Docker-within-Docker
    environment with the `setup_remote_docker` command and then executes the `docker
    build -f Dockerfile.integration .` command to initiate our custom build process.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的文件中,定义了一个基于CircleCI预构建的`docker:17.12.0-ce-git`镜像的`build`作业,该镜像包含Docker和git
    CLI工具。然后我们定义构建`步骤`,它使用`checkout`从GitHub检出源代码,使用`setup_remote_docker`命令通知CircleCI设置一个Docker-within-Docker环境,然后执行`docker
    build -f Dockerfile.integration .`命令启动我们的自定义构建过程。
- en: In order to optimize builds, you should experiment with layer caching and copying
    source code from the already checked out source code in CircleCI.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化构建,您应该尝试使用层缓存并从CircleCI中已经检出的源代码复制源代码。
- en: Sync your changes to Github
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将更改同步到GitHub
- en: On CircleCI, click to Create your project
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在CircleCI上,单击创建您的项目
- en: 'If everything goes well, you will have passing, *green*, build. As shown in
    the following screenshot, build #4 was successful:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '如果一切顺利,您将会有一个通过*绿色*构建。如下图所示,构建#4成功了:'
- en: '![](img/dafc6e0c-df81-4ae3-abf7-edd373a0c589.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dafc6e0c-df81-4ae3-abf7-edd373a0c589.png)'
- en: Green build on CircleCI
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: CircleCI上的绿色构建
- en: At the moment, the CI server is running, building the app in stage 1, then running
    the tests in stage 2, and then building the web server in stage 3\. Note that
    we are not doing anything with this web server container image, such as deploying
    it to a server.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 目前,CI服务器正在运行,在第1阶段构建应用程序,然后在第2阶段运行测试,最后在第3阶段构建Web服务器。请注意,我们并没有对这个Web服务器容器镜像做任何事情,比如将其部署到服务器。
- en: 'In order to deploy your image, you will need to implement a deploy step. In
    this step, you can deploy to a multitude of targets such as Docker Hub, Zeit Now,
    Heroku, or AWS ECS. The integration to these targets will involve multiple steps.
    At a highlevel, these steps are as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '为了部署您的镜像,您需要实现一个部署步骤。在这一步中,您可以将其部署到多个目标,如Docker Hub、Zeit Now、Heroku或AWS ECS。与这些目标的集成将涉及多个步骤。从整体上看,这些步骤如下:'
- en: Install target-specific CLI tool with a separate run step
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用单独的运行步骤安装面向目标的CLI工具
- en: Configure Docker with login credentials specific to the target environment,
    storing said credentials as CircleCI environment variables
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用针对目标环境的登录凭据配置Docker,并将这些凭据存储为CircleCI环境变量
- en: Use `docker push` to submit the resulting web server image to the target's Docker
    registry
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker push`将生成的Web服务器镜像提交到目标的Docker注册表
- en: Execute a platform-specific `deploy` command to instruct the target to run the
    Docker image that was just pushed.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行平台特定的`deploy`命令，指示目标运行刚刚推送的Docker镜像。
- en: An example of how to configure such a deployment on AWS ECS from your local
    development environment is covered in [Chapter 16](7ccc1261-21e7-44b9-aaf8-0079360288e7.xhtml),
    *Highly-Available Cloud Infrastructure on AWS*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如何从本地开发环境在AWS ECS上配置此类部署的示例在[第16章](7ccc1261-21e7-44b9-aaf8-0079360288e7.xhtml)中有涵盖，*AWS上高可用的云基础设施*。
- en: Code coverage report
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码覆盖率报告
- en: 'A good way to understand the amount and the trends of unit tests coverage for
    your Angular project is through a code coverage report. In order to generate the
    report for your app, execute the following command from your project folder:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 了解你的Angular项目的单元测试覆盖量和趋势的一个好方法是通过代码覆盖率报告。为了为你的应用程序生成报告，从项目文件夹执行以下命令：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The resulting report will be created as HTML under a folder name coverage;
    execute the following command to view it in your browser:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 结果报告将以HTML形式创建在名为覆盖率的文件夹下；执行以下命令在浏览器中查看：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here''s the folder-level sample coverage report generated by `istanbul.js` for
    LemonMart:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`istanbul.js`为LemonMart生成的文件夹级样本覆盖报告：
- en: '![](img/3f1960d4-072a-4579-ac6b-1e6254264a97.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f1960d4-072a-4579-ac6b-1e6254264a97.jpg)'
- en: Istanbul code coverage report for LemonMart
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: LemonMart 的伊斯坦布尔代码覆盖率报告
- en: 'You can drill down on a particular folder, like `src/app/auth`, and get a file-level
    report, as shown here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以进一步深入了解特定文件夹，比如`src/app/auth`，并获得一个文件级报告，就像这样：
- en: '![](img/c13d8f4f-f833-4c65-b82f-287045b70272.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c13d8f4f-f833-4c65-b82f-287045b70272.png)'
- en: Istanbul code coverage report for src/app/auth
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: LemonMart的src/app/auth的伊斯坦布尔代码覆盖率报告
- en: 'You can further drill down to get line-level coverage for a given file, like
    `cache.service.ts`, as shown here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以进一步深入了解给定文件，比如`cache.service.ts`的行级覆盖率，就像这样：
- en: '![](img/dc3e1e82-8e8b-4ced-9009-ed54ba11e845.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc3e1e82-8e8b-4ced-9009-ed54ba11e845.png)'
- en: Istanbul Code Coverage Report for cache.service.ts
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Istanbul 缓存服务代码覆盖率报告
- en: In the preceding image you can see that lines 5, 12, 17-18 and 21-22 are not
    covered by any test. The Iicon denotes that the if path was not taken. We can
    increase our code coverage by implementing unit tests that exercise the functions
    that are contained within `CacheService`. As an exercise, the reader should attempt
    to atleast cover one of these functions with a new unit test and observe the code
    coverage report change.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的图像中，您可以看到第5,12,17-18和21-22行没有被任何测试覆盖。图标表示if路径未被采用。我们可以通过实现练习中包含在`CacheService`中的函数的单元测试来增加我们的代码覆盖率。作为练习，读者应尝试至少用一个新的单元测试覆盖这些功能之一，并观察代码覆盖率报告的变化。
- en: Ideally, your CI server configuration should generate and host the code coverage
    report with every test run in a readily accessible manner. Implement these commands
    as script in `package.json` and execute them in your CI pipeline. This configuration
    is left as an exercise for the reader.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，您的CI服务器配置应该在每次测试运行时以一种容易访问的方式生成和托管代码覆盖率报告。在`package.json`中将这些命令作为脚本实现，并在CI流程中执行。这个配置留作读者的练习。
- en: Install `http-server` as a development dependency to your project.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将`http-server`作为项目的开发依赖项安装到您的项目中。
- en: API design
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API设计
- en: 'In full-stack development, nailing down the API design early on is important.
    The API design itself is closely correlated with how your data contract will look.
    You may create RESTful endpoints or use the next-gen GraphQL technology. In designing
    your API, frontend and backend developers should closely collaborate to achieve
    shared design goals. Some high-level goals are listed as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在全栈开发中，早期确定API设计是很重要的。API设计本身与数据契约的外观密切相关。您可以创建RESTful端点或使用下一代GraphQL技术。在设计API时，前端和后端开发人员应密切合作，以实现共享的设计目标。一些高层目标如下：
- en: Minimize data transmitted between client and server
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化客户端与服务器之间传输的数据
- en: Stick to well-established design patterns (that is, pagination)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坚持成熟的设计模式（即分页）
- en: Design to reduce business logic present in the client
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计以减少客户端中存在的业务逻辑
- en: Flatten data structures
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展平数据结构
- en: Do not expose database keys or relationships
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要暴露数据库键或关系
- en: Version endpoints from the get go
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一开始就提供版本端点
- en: Design around major data components
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 围绕主要数据组件进行设计
- en: It is important not to reinvent the wheel and take a disciplined, if not strict,
    approach to designing your API. The downstream effect of missteps in API design
    can be profound and impossible to correct once your application goes live.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 很重要的是不要重复造轮子，并且要严格、甚至严格地设计你的API。API设计的错误后果在应用程序上线后可能会产生深远的影响，并且不可能再进行修正。
- en: I will go into details of designing around major data components and implement
    a sample Swagger endpoint.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我将详细介绍如何围绕主要数据组件进行设计，并实现一个示例的Swagger端点。
- en: Designing around major data components
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 围绕主要数据组件进行设计
- en: It helps to organize your APIs around major data components. This will roughly
    match how you consume data in various components in your Angular application.
    We will start off by defining our major data components by creating a rough data
    entity diagram and then implementing a sample API for the user data entity with
    swagger.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 它有助于围绕主要数据组件组织你的API。这将粗略地匹配你在 Angular 应用程序中不同组件中消耗数据的方式。我们将首先通过创建一个粗略的数据实体图来定义我们的主要数据组件，然后使用
    Swagger 实现用户数据实体的示例API。
- en: Defining entities
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义实体
- en: Let's start by taking a stab at what kind of entities you would like to store
    and how these entities might relate to one another.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先试着确定你想要储存的实体是什么，并思考这些实体如何相互关联。
- en: 'Here''s a sample design for LemonMart, created using [draw.io](http://draw.io):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用[draw.io](http://draw.io)创建的 LemonMart 的示例设计：
- en: '![](img/132edb42-b0ab-435e-9d27-8c61b2fae794.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/132edb42-b0ab-435e-9d27-8c61b2fae794.jpg)'
- en: Data entity diagram for LemonMart
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: LemonMart的数据实体图
- en: At this moment, whether your entities are stored in a SQL or NoSQL database
    is inconsequential. My suggestion is to stick to what you know, but if you're
    starting from scratch, a NoSQL database like MongoDB will offer the most amount
    of flexibility as your implementation and requirements evolve.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你的实体是存储在SQL还是NoSQL数据库中无关紧要。我的建议是坚持你所知道的，但如果你从头开始，像 MongoDB 这样的 NoSQL 数据库将在你的实现和需求演变时提供最大灵活性。
- en: Roughly speaking, you will need CRUD APIs for each entity. You can use Swagger
    to design your APIs.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 大致来说，你需要为每个实体进行 CRUD API。你可以使用Swagger来设计你的API。
- en: Swagger
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swagger
- en: Swagger will allow you to design your web API. For teams, it can act as an interface
    between frontend and backend teams. Additionally, with API mocking, you can develop
    and complete API features before the implementation of the APIs even begins.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 将允许你设计你的web API。对于团队来说，它可以充当前端和后端团队之间的接口。此外，通过API mocking，你可以在实现API之前开发和完成API功能。
- en: We will implement a sample Users API as we move on, to demonstrate how Swagger
    works.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的进行，我们将实现一个示例用户API，以演示Swagger的工作方式。
- en: The sample project comes with recommended extensions for VS Code. Swagger Viewer
    allows us to preview the YAML file without running any additional tools.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例项目带有用于VS Code的推荐扩展程序。Swagger Viewer允许我们在不运行任何额外工具的情况下预览YAML文件。
- en: Defining a Swagger YAML file
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个Swagger YAML文件
- en: 'The most widely used and supported version of the Swagger spec is `swagger:
    ''2.0''`. The following example is given using the newer, standards-based, `openapi:
    3.0.0`. The sample code repository contains both examples. However, at the time
    of publishing, most tooling in the Swagger ecosystem relies on version 2.0.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 'Swagger 规范的最广泛使用和支持版本是`swagger: ''2.0''`。以下示例使用了新的、基于标准的`openapi: 3.0.0`。示例代码仓库包含了这两个示例。然而，在发布时，Swagger
    生态系统中的大多数工具依赖于版本 2.0。'
- en: The sample code repository can be found at [github.com/duluca/lemon-mart-swagger-server](http://github.com/duluca/lemon-mart-swagger-server).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码仓库可以在[github.com/duluca/lemon-mart-swagger-server](http://github.com/duluca/lemon-mart-swagger-server)找到。
- en: For your mock API server, you should create a separate git repository, so that
    this contract between your frontend and backend can be maintained separately.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的模拟API服务器，你应该创建一个单独的git仓库，这样前端和后端之间的这个约定可以被分开维护。
- en: Create a new GitHub repository, called `lemon-mart-swagger-server`
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`lemon-mart-swagger-server`的新GitHub仓库。
- en: 'Start defining a YAML file with general information and target servers:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始定义一个带有通用信息和目标服务器的YAML文件：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Under `components`, define shared data `schemas`:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`components`下，定义共享的数据`schemas`：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Under `components`, add shared `parameters`, making it easy to reuse common
    patterns like paginated endpoints:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`components`下，添加共享的`parameters`，使得重用常见模式像分页端点变得容易：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Under `paths`, define a `get` endpoint for the `/users` path:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`paths`下，为`/users`路径定义一个`get`端点：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Under `paths`, add `get` user by ID and `update` user by ID endpoints:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`paths`下，添加通过ID`get`用户和通过ID`update`用户的端点：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To validate your Swagger file, you can use the online editor at [editor.swagger.io](https://editor.swagger.io).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证您的 Swagger 文件，您可以使用[editor.swagger.io](https://editor.swagger.io)上的在线编辑器。
- en: 'Note the use of `style: form` and `explode: false`, which are the simplest
    way to configure an endpoint that expects basic form data. For more parameter
    serialization options or to simulate authentication endpoints and a slew of other
    possible configurations, refer to the documentation at [swagger.io/docs/specification/](https://swagger.io/docs/specification/).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '注意使用了 `style: form` 和 `explode: false`，这是配置预期接收基本表单数据的端点的最简单方式。要获取更多参数序列化选项或模拟认证端点和一系列其他可能的配置，请参考[swagger.io/docs/specification/](https://swagger.io/docs/specification/)上的文档。'
- en: Creating a Swagger server
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Swagger 服务器
- en: Using your YAML file, you can generate a mock Node.js server using the Swagger
    Code Gen tool.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您的 YAML 文件，您可以使用 Swagger Code Gen 工具生成一个模拟的 Node.js 服务器。
- en: OpenAPI 3.0 with unofficial tooling
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用非官方工具的 OpenAPI 3.0
- en: 'As mentioned in the earlier section, this section will use version 2 of the
    YAML file, which can generate a server using the official tooling. There are,
    however, other tools out there that can generate some code, but not complete enough
    to be easy to use:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一部分所述，此部分将使用 YAML 文件的版本 2，该版本可以使用官方工具生成服务器。然而，还有其他工具可以生成一些代码，但不够完整以便易于使用：
- en: 'If using OpenAPI 3.0 on the project folder, execute the following command:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在项目文件夹上使用 OpenAPI 3.0，请执行以下命令：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Under a new folder, called `server`, you should now have a Node Express server
    generated.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个名为 `server` 的新文件夹下，现在应该有一个生成的 Node Express 服务器。
- en: 'Install dependencies for the server:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为服务器安装依赖项：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You must then manually implement the missing stubs to complete the implementation
    of the server.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后必须手动实现缺失的存根以完成服务器的实现。
- en: Swagger 2.0 with official tooling
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用官方工具的 Swagger 2.0
- en: 'Using official tooling and version 2.0, you can automate API creation and response
    generation. Once official tooling fully supports them, OpenAPI 3.0, the same instructions
    should apply:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用官方工具和版本 2.0，您可以自动创建 API 并生成响应。一旦官方工具完全支持它们，OpenAPI 3.0，相同的说明应该适用：
- en: 'Publish your YAML file on a URI that will be accessible by your machine:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个可以被您的机器访问到的 URI上发布您的 YAML 文件：
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In your project folder, execute the following command, replacing `<uri>` with
    the one pointing at your YAML file:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件夹中，执行以下命令，将 `<uri>` 替换为指向您的 YAML 文件的 uri：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Similar to the preceding section, this will create a Node Express server under
    the server directory. In order to execute this server, carry on with the following
    steps.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一节类似，这将在 server 目录下创建一个 Node Express 服务器。要执行此服务器，请按照以下步骤操作。
- en: Install the server's dependencies with `npm install`
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npm install` 安装服务器的依赖项
- en: Run `npm start`. Your mock server should now be up and running.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `npm start`。您的模拟服务器现在应该运行起来了。
- en: Navigate to `http://localhost:3000/docs`
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 `http://localhost:3000/docs`
- en: 'Try out the API for `get /users`; you''ll note that the items property is empty:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试 `get /users` 的 API；您将注意到 items 属性为空：
- en: '![](img/5232c3e1-da5f-4aef-b66a-e15a886d30bf.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5232c3e1-da5f-4aef-b66a-e15a886d30bf.png)'
- en: Swagger UI - Users endpoint
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI - 用户端点
- en: However, you should be receiving dummy data. We will correct this behavior.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您应该收到虚拟数据。我们将修正这种行为。
- en: 'Try out `get /user/{id}`; you''ll see that you''re receiving some dummy data
    back:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试 `get /user/{id}`；您将看到收到一些虚拟数据：
- en: '![](img/6e2ad6a5-bff4-42cd-b195-0e0d03d31ae4.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e2ad6a5-bff4-42cd-b195-0e0d03d31ae4.png)'
- en: Swagger UI - User by ID endpoint
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI - 按ID查找用户端点
- en: The difference in behavior is because, by default, the Node Express server uses
    controllers generated under `server/controllers/Default.js` to read random data
    generated during server creation from `server/service/DefaultService.js`. However,
    you can disable the default controllers and force Swagger into a better default
    stubbing mode.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 行为上的差异是因为，默认情况下，Node Express 服务器使用在 `server/controllers/Default.js` 下生成的控制器从
    `server/service/DefaultService.js` 读取在服务器创建期间生成的随机数据。然而，您可以禁用默认控制器并强制 Swagger
    切换到更好的默认存根模式。
- en: 'Update `index.js` to force the use of stubs and comment out controllers:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `index.js` 以强制使用存根并注释掉控制器：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Try out the `/users` endpoint again
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次尝试 `/users` 端点
- en: 'As you can see here, the response is higher quality by default:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这里看到的，响应默认情况下质量更高：
- en: '![](img/f75896ae-de7d-4ffc-8e71-1938fdc51bc7.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f75896ae-de7d-4ffc-8e71-1938fdc51bc7.png)'
- en: Swagger UI - Users endpoint with dummy data
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI - 附带虚拟数据的用户端点
- en: In the preceding, `total` is a whole number, `role` is defined correctly, and
    `items` is a valid array structure.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的内容中，`total`是一个整数，`role`已正确定义，`items`是一个有效的数组结构。
- en: To enable better and more customized data mocking, you can edit `DefaultService.js`.
    In this case, you would want to update the `usersGET` function to return an array
    of customized users.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现更好和更定制的数据模拟，你可以编辑`DefaultService.js`。在这种情况下，你需要更新`usersGET`函数，以返回一组定制的用户。
- en: Enable Cross-Origin Resource Sharing (CORS)
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用跨源资源共享（CORS）
- en: 'Before you''re able to use your server from your application, you will need
    to configure it to allow for **Cross-Origin Resource Sharing** (**CORS**) so that
    your Angular application hosted on `http://localhost:5000` can communicate with
    your mock server hosted on `http://localhost:3000`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够从应用程序中使用你的服务器之前，你需要对其进行配置，以允许**跨源资源共享**（**CORS**），以便你在`http://localhost:5000`上托管的Angular应用程序可以与在`http://localhost:3000`上托管的模拟服务器进行通信：
- en: 'Install the `cors` package:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`cors`包：
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Update `index.js` to use `cors`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`index.js`来使用`cors`：
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Ensure that `app.use(cors())` is called right before `initializeMiddleware`;
    otherwise, other Express middleware may interfere with the functionality of `cors()`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在`initializeMiddleware`之前调用`app.use(cors())`；否则，其他Express中间件可能会干扰`cors()`的功能。
- en: Verifying and publishing Swagger server
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证和发布Swagger服务器
- en: You can verify your Swagger server setup through the SwaggerUI, which will be
    located at `http://localhost:3000/docs`, or you can achieve a more integrated
    environment with the Preview Swagger extension in VS Code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过SwaggerUI验证你的Swagger服务器设置，它位于`http://localhost:3000/docs`，或者你可以在VS Code中通过Preview
    Swagger扩展实现更加集成的环境。
- en: 'I will demonstrate how you can use this extension to test your API from within
    VS Code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我将演示如何使用该扩展从VS Code内部测试你的API：
- en: Select the YAML file in Explorer
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在资源管理器中选择YAML文件
- en: Press *Shift* + *Alt* + *P *and execute the Preview Swagger command
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Shift* + *Alt* + *P*并执行Preview Swagger命令
- en: 'You will see an interactive window to test your configuration, as illustrated:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到一个交互式窗口来测试你的配置，如下图所示：
- en: '![](img/0ed1b78b-5dfb-45ec-8e63-5c8d276900d8.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ed1b78b-5dfb-45ec-8e63-5c8d276900d8.png)'
- en: Preview Swagger Extension in Visual Studio Code
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中预览Swagger扩展
- en: Click on the Get button for /users
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击/users下的Get按钮
- en: Click on Try it out to see the results
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Try it out查看结果
- en: In OpenAPI 3.0.0, instead of schemes, you will see a list of servers, including
    local and remote resources. This is a very convenient tool to explore various
    data sources as you code your frontend application.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenAPI 3.0.0中，你会看到一系列服务器，包括本地和远程资源，而不是方案。这是一个非常方便的工具，可以在编写前端应用程序时探索各种数据源。
- en: Now that you have verified your Swagger server, you can publish your server
    to make it accessible to team members or **Automated Acceptance Test** (**AAT**)
    environments that require a predictable dataset to execute successfully.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经验证了你的Swagger服务器，你可以发布你的服务器，以使团队成员或者需要可预测数据集以成功执行的**自动验收测试**（**AAT**）环境可以访问。
- en: Perform the following steps*:*
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：*
- en: Add npm Scripts for Docker to the root level `package.json` file
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Docker的npm脚本添加到根级`package.json`文件中
- en: 'Add a `Dockerfile`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`Dockerfile`：
- en: '[PRE26]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once you build the container, you are ready to deploy it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你构建了容器，你就可以部署它了。
- en: I have published a sample server on Docker Hub at [https://hub.docker.com/r/duluca/lemon-mart-swagger-server](https://hub.docker.com/r/duluca/lemon-mart-swagger-server).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我在Docker Hub上发布了一个样例服务器，网址是[https://hub.docker.com/r/duluca/lemon-mart-swagger-server](https://hub.docker.com/r/duluca/lemon-mart-swagger-server)。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to create a container-based Continuous Integration
    environment. We leveraged CircleCI as a cloud-based CI service and highlighted
    the fact that you can deploy the outcome of your builds to all major cloud hosting
    providers. If you enable such automated deployment, you will achieve **Continuous Deployment**
    (**CD**). With a CI/CD pipeline, you can share every iteration of your app with
    clients and team members and quickly deliver bug fixes or new features to your
    end users.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何创建基于容器的持续集成环境。我们利用了CircleCI作为基于云的CI服务，并强调了你可以将构建结果部署到所有主要的云托管提供商。如果你启用这样的自动化部署，你将实现**持续部署**（**CD**）。通过CI/CD管道，你可以与客户和团队成员分享应用程序的每一次迭代，并快速向最终用户交付错误修复或新功能。
- en: We also discussed the importance of good API design and established Swagger
    as a tool that is beneficial to frontend and backend developers alike to define
    and develop against a live data-contract. If you create a Swagger mock server,
    you can enable team members to pull the mock server image and use it to develop
    their frontend applications before backend implementation is completed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了良好 API 设计的重要性，并确定 Swagger 是一个有益于前端和后端开发人员的工具，用于定义和根据实时数据合同进行开发。如果你创建一个
    Swagger 模拟服务器，你可以让团队成员拉取模拟服务器镜像，并在后端实现完成之前用它来开发他们的前端应用。
- en: Both CircleCI and Swagger are highly sophisticated tools in their own ways.
    The techniques mentioned in this chapter are straightforward on purpose, but they
    are meant to enable sophisticated workflows, giving you a taste of the true power
    of such tools. You can improve upon the efficiency and the capability of this
    technique vastly, but the techniques will depend on your specific needs.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: CircleCI 和 Swagger 在各自的方式上都是非常复杂的工具。本章提到的技术故意简单，但旨在实现复杂的工作流程，让你感受到这些工具真正的力量。你可以大大提高这种技术的效率和能力，但这些技术将取决于你的具体需求。
- en: Armed with CI and mocked APIs that we can send real HTTP requests to, we are
    ready to iterate rapidly while ensuring a high-quality deliverable. In the next
    chapter, we will dive deep into designing an authorization and authentication
    experience for your line-of-business app using token-based authentication and
    conditional navigation techniques to enable a smooth user experience, continuing
    the Router-first approach.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 凭借我们可以发送真实 HTTP 请求的 CI 和模拟 API，我们已经准备好迅速迭代，同时确保高质量的交付成果。在下一章中，我们将深入探讨使用基于令牌的身份验证和条件导航技术为你的业务线应用设计授权和认证体验，以实现平滑的用户体验，延续首先路由的方法。
