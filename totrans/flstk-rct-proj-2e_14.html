<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Integrating Data Visualization with an Expense Tracking Application</h1>
                </header>
            
            <article>
                
<p>These days, it is easy to collect and add data to applications on the internet. As more and more data becomes available, it becomes necessary to process the data and present insights extracted from this data in meaningful and appealing visualizations to end users. <span>In this chapter, we will learn how to use MERN stack technologies along with Victory—a charting library for React—to easily integrate data visualization features in a full-stack application. We will extend the MERN skeleton application to build an expense tracking application, which will incorporate data processing and visualization features for expense data recorded by a user over time.</span></p>
<p><span class="cdp-chapters-widget-post-title">After going through the implementation of these features, you should have a grasp of how to utilize the MongoDB aggregation framework and the <span>Victory </span>charting library to add data visualization features of your choice to</span> any full-stack MERN web application. </p>
<p><span>In this chapter, we will build an expense tracking application integrated with data visualization features by covering the following topics:</span></p>
<ul>
<li>Introducing MERN Expense Tracker </li>
<li>Adding expense records</li>
<li>Visualizing expense data over time</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing MERN Expense Tracker</h1>
                </header>
            
            <article>
                
<p>The MERN Expense Tracker application will allow users to keep track of their day-to-day expenses. Users who are signed in to their accounts will be able to add their expense records with details such as expense description, category, amount, and when the given expense was incurred or paid. The application will store these expense records and extract meaningful data patterns to give the user a visual representation of how their expense habits fare as time progresses. The following screenshot shows the home page view for a signed-in user on the MERN Expense Tracker application, and it gives the user an overview of their expenses for the current month:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-877 image-border" src="assets/8092ee10-448d-4cea-a31a-05dc85c6f382.png" style="width:25.17em;height:27.83em;"/></p>
<div class="packt_tip"><span>The code for the complete MERN Expense Tracker application is available on GitHub at:</span> <a href="https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter10/mern-expense-tracker" target="_blank">https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter10/mern-expense-tracker</a><span>.</span><span> You can</span><span> clone this code and run the application as you go through the code explanations for the rest of this chapter. </span></div>
<p>In this chapter, <span>we will extend the MERN skeleton to build the expense tracking application with data visualization features. The views required for these expense tracking and visualization features will be developed by extending and modifying the existing React components in the MERN skeleton application. The component tree in the following screenshot shows all the custom React components that make up the MERN Expense Tracker frontend developed in this chapter:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-878 image-border" src="assets/035a54ab-1da5-46e3-9db1-032248a6af3e.png" style="width:41.67em;height:18.42em;"/></p>
<p><span>We will add new React components to implement views for creating expense records, listing and modifying already recorded expenses, and displaying reports giving insights into expenses incurred by a user over time. We will also modify existing components such as the <span class="packt_screen">Home</span> component to render an overview of current expenses by a user. Before we can implement visualizations for the user's expense data, we need to start by adding the capability to record day-to-day expenses on the application. In the next section, we will discuss how to implement this feature allowing signed-in users to create and modify their expense records on the application.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding expense records</h1>
                </header>
            
            <article>
                
<p>In the MERN Expense Tracker application, a user who is signed in will be able to create and manage their expense records. To enable these features of adding and managing expense records, <span>we will need to define how to store expense details, and implement the full-stack slices that will let users </span>create new expenses, view these expenses, and update or delete existing expenses on the application.</p>
<p>In the following sections, first, we will define the Expense model with a Mongoose Schema to store the details of each expense record. Then, we will discuss implementations for the backend APIs and frontend views that are needed to allow a user to create new expenses, view a list of their expenses, and modify existing expenses by either editing details of or deleting an expense from the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining an Expense model </h1>
                </header>
            
            <article>
                
<p>We will implement a Mongoose model to define an Expense model for storing the details of each expense record. This model will be defined in<span> </span><kbd>server/models/expense.model.js</kbd>, and the implementation will be similar to<span> other Mongoose Model implementations covered in previous chapters, such as the Course model defined in <a href="c58ac055-5a1e-4bf4-b8a6-c9b311cf267a.xhtml" target="_blank">Chapter 6</a>, <em>Building a Web-Based Classroom Application</em></span><span>. The Expense schema in this model </span>will have simple fields to store details about each expense, such as a title, the amount, category, and date when it was incurred, along with a reference to the user who created the record. <span>The code defining the expense fields are given in the following list with explanations:</span></p>
<ul>
<li><strong>Expense title</strong>: <span>The <kbd>title</kbd> field will describe the expense. It is declared to be a <kbd>String</kbd> type and will be a required field:</span></li>
</ul>
<pre style="padding-left: 60px">title: { <br/>    type: String, <br/>    trim: true, <br/>    required: 'Title is required' <br/>},</pre>
<ul>
<li><strong>Expense amount</strong>: <span>The <kbd>amount</kbd> field will store the monetary cost of the expense as a value of the <kbd>Number</kbd> type, and it will be a required field with a minimum allowed value of 0:</span></li>
</ul>
<pre style="padding-left: 60px">amount: { <br/>    type: Number, <br/>    min: 0,<br/>    required: 'Amount is required' <br/>},</pre>
<ul>
<li><strong>Expense category</strong>: <span>The <kbd>category</kbd> field will define the expense type, so expenses can be grouped by this value. It is declared to be a <kbd>String</kbd> type and will be a required field:</span></li>
</ul>
<pre style="padding-left: 60px">category: {<br/>    type: String,<br/>    trim: true,<br/>    required: 'Category is required'<br/>},</pre>
<ul>
<li><strong>Incurred on</strong>: <span>The <kbd>incurred_on</kbd> field will store the date-time when the expense was incurred or paid. It is declared to be a <kbd>Date</kbd> type and will default to the current date-time if no value is provided:</span></li>
</ul>
<pre style="padding-left: 60px">incurred_on: {<br/>    type: Date,<br/>    default: Date.now<br/>},</pre>
<ul>
<li><strong>Notes</strong>: <span>The <kbd>notes</kbd> field, defined as a <kbd>String</kbd> type, will allow the recording of additional details or notes for a given expense record:</span></li>
</ul>
<pre style="padding-left: 60px">notes: {<br/>    type: String,<br/>    trim: true<br/>},</pre>
<ul>
<li><strong>Expense recorded by</strong>: <span>The <kbd>recorded_by</kbd> field will reference the user who is creating the expense record:</span></li>
</ul>
<pre style="padding-left: 60px">recorded_by: {<br/>    type: mongoose.Schema.ObjectId, <br/>    ref: 'User'<br/>}</pre>
<ul>
<li><strong>Created and updated at times</strong>: <span>The</span><span> </span><kbd>created</kbd><span> </span><span>and</span><span> </span><kbd>updated</kbd><span> </span><span>fields will be <kbd>Date</kbd> types, with</span><span> </span><kbd>created</kbd><span> </span><span>generated when a new expense is added, and</span><span> </span><kbd>updated</kbd><span> </span><span>changed when any expense details are modified:</span></li>
</ul>
<pre style="padding-left: 60px">updated: Date,<br/>created: { <br/>    type: Date, <br/>    default: Date.now <br/>},</pre>
<p>The fields added to this schema definition will enable us to implement all the expense-related features in MERN Expense Tracker. In the next section, we will start developing these features by implementing the full-stack slice that will allow users to create new expense records.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a new expense record</h1>
                </header>
            
            <article>
                
<p><span>In order to create a new expense record on the application, we will need to integrate a full-stack slice that allows the user to fill out a form view in the frontend, and then save the entered details to a new expense document in the database in the backend. </span><span>To implement this feature, in the following sections, we will add a create expense API in the backend, along with a way to fetch this API in the frontend, and a create new expense form view that takes user input for expense details.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The create expense API</h1>
                </header>
            
            <article>
                
<p>For <span>the implementation of the create expense API that will allow creating new expenses in the database</span>, we will first add a <kbd>POST</kbd> route, as shown in the following code. </p>
<p><kbd>mern-expense-tracker/server/routes/expense.routes.js</kbd>:</p>
<pre>router.route('/api/expenses')<br/>  .post(authCtrl.requireSignin, expenseCtrl.create)</pre>
<p><span>A <kbd>POST</kbd> request to this route at </span><kbd>/api/expenses</kbd><span> will first ensure that the requesting user is signed in with the <kbd>requireSignin</kbd></span> method from the <kbd>auth</kbd> controllers, before invoking the <kbd>create</kbd> method to add a new expense record in the database. This <kbd>create</kbd> method is defined in the following code.</p>
<p><kbd>mern-expense-tracker/server/controllers/expense.controller.js</kbd><span>:</span></p>
<pre>const create = async (req, res) =  {<br/>  try {<br/>    req.body.recorded_by = req.auth._id<br/>    const expense = new Expense(req.body)<br/>    await expense.save()<br/>    return res.status(200).json({<br/>      message: "Expense recorded!"<br/>    })<br/>  } catch (err) {<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p><span>In this </span><kbd>create</kbd><span> method, we set the </span><kbd>recorded_by</kbd><span> field to the user currently signed in, before using the expense data provided in the request body to save the new expense in the Expense collection in the database.</span></p>
<p>The<span> </span><kbd>expense.routes.js</kbd><span> </span>file containing the expense routes will be very similar to the<span> </span><kbd>user.routes</kbd><span> </span>file. To load these new expense routes in the Express app, we need to mount the expense routes in<span> </span><kbd>express.js</kbd>, as shown in the following code, in the same way that we did for the auth and user routes. </p>
<p><kbd>mern-expense-tracker/server/express.js</kbd>:</p>
<pre>app.use('/', expenseRoutes)</pre>
<p>This create expense API endpoint is now ready in the backend and can be used in the frontend to make a <kbd>POST</kbd> request. <span>To fetch this API in the frontend, we will add a corresponding </span><kbd>create</kbd><span> method in </span><kbd>api-expense.js</kbd><span>, similar to the other API implementations that we discussed in previous chapters, such as the <em>Creating a new auction</em> section from <a href="48801a75-cf6a-4eb8-b294-65314e749e9d.xhtml" target="_blank">Chapter 9</a>, <em>Adding Real-Time Bidding Capabilities to the Marketplace</em>.</span></p>
<p><span>This fetch method will be used in the frontend </span><span>component that will display a form where the user can enter details of the new expense and save it on the application. In the next section, we will implement the React component that will render the form for recording a new expense.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The NewExpense component</h1>
                </header>
            
            <article>
                
<p>Signed-in users on this expense tracking application will interact with a form view in order to enter details of a new expense record. This form view will be rendered in the <kbd>NewExpense</kbd> component, which will allow users to create a new expense by entering the expense title, the amount spent, the category of the expense, the date-time of when the expense was incurred, and any additional notes.</p>
<p>This form will render as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-879 image-border" src="assets/214b657c-665b-4b1d-a4a3-40b417767811.png" style="width:24.50em;height:32.33em;"/></p>
<p><span>The implementation for this </span><kbd>NewExpense</kbd><span> component is similar to other form implementations that we have discussed previously, such as the </span><kbd>Signup</kbd><span> component implementation from <a href="6f2ca10a-8079-4e3a-9d42-a3db8e85b9d9.xhtml" target="_blank">Chapter 4</a>,<em> <span class="cdp-organizer-chapter-title"><span class="cdp-organize-title-label">Adding a React Frontend to Complete MERN</span></span></em></span><span class="cdp-chapters-widget-post-title">. The only different field in this form component is the date-time input for the <span class="packt_screen">Incurred on</span> timing. Clicking on this field will render a date-time picker widget, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-880 image-border" src="assets/4e19ff40-3364-4d0d-a006-57c91a3a525b.png" style="width:18.25em;height:28.17em;"/></p>
<p>To implement this date-time picker for the form, we will use Material-UI Pickers along with a date management library. Before we can integrate these libraries, we first need to install the following Material-UI Pickers and <kbd>date-fns</kbd> modules by running the following <kbd>yarn</kbd> command from the command line:</p>
<pre><strong>yarn add </strong><span><strong>@material-ui/pickers @date-io/date-fns@1.x date-fns</strong><br/></span></pre>
<p>Once these modules are installed, we can import the required components and modules in the <kbd>NewExpense</kbd> component and add the date-time picker widget to the form, as shown in the following code. </p>
<p><kbd>mern-expense-tracker/client/expense/NewExpense.js</kbd><span>:</span></p>
<pre>import DateFnsUtils from '@date-io/date-fns'<br/>import { DateTimePicker, MuiPickersUtilsProvider} from "@material-ui/pickers"<br/>...<br/> &lt;MuiPickersUtilsProvider utils={DateFnsUtils}&gt;<br/>        &lt;DateTimePicker<br/>           label="Incurred on"<br/>           views={["year", "month", "date"]}<br/>           value={values.incurred_on}<br/>           onChange={handleDateChange}<br/>           showTodayButton<br/>       /&gt; <br/> &lt;/MuiPickersUtilsProvider&gt; </pre>
<p>This widget will render options to pick a year, month, date, and time along with a <span class="packt_screen">TODAY</span> button to set the current time as the selected value. When the user is done picking a date-time, we will capture the value with the <kbd>handleDateChange</kbd> method and set it to state with the other expense-related values collected from the form. The <kbd>handleDateChange</kbd> method is defined as follows.</p>
<p><kbd>mern-expense-tracker/client/expense/NewExpense.js</kbd><span>:</span></p>
<pre>  const handleDateChange = date =  {<br/>    setValues({...values, incurred_on: date })<br/>  }</pre>
<p>Using this, we will have a <kbd>date</kbd> value set for the <kbd>incurred_on</kbd> field in the new expense record.</p>
<p>This<span> </span><kbd>NewExpense</kbd><span> </span>component can only be viewed by signed-in users. So, we will add a<span> </span><kbd>PrivateRoute</kbd><span> </span>in the<span> </span><kbd>MainRouter</kbd><span> </span>component, which will render this form only for authenticated users at<span> </span><kbd>/expenses/new</kbd>.</p>
<p><kbd>mern-expense-tracker/client/MainRouter.js</kbd>:</p>
<pre> PrivateRoute path="/expenses/new" component={NewExpense}/ </pre>
<p>This link can be added to any view, such as the Menu component, to be rendered conditionally when users are signed in. Now that it is possible to add new expense records in this expense tracking application, in the next section, we will discuss the implementation to fetch and list these expenses from the database in the backend to the views in the frontend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing expenses</h1>
                </header>
            
            <article>
                
<p>In MERN Expense Tracker, users will be able to view the list of expenses that they already recorded on the application and incurred within a provided date range. In the following sections, we will add this ability by implementing a backend API to retrieve the list of expenses recorded by the currently signed-in user, and add a frontend view that will use this API to render the returned list of expenses to the end user.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The expenses by user API</h1>
                </header>
            
            <article>
                
<p>We will implement an API to get the expenses recorded by a specific user and incurred between a provided date range. The request for this API will be received at <kbd>'/api/expenses'</kbd>, with the route defined in <kbd>expense.routes.js</kbd> as follows.</p>
<p><kbd>mern-expense-tracker/server/routes/expense.routes.js</kbd><span>:</span></p>
<pre>router.route('/api/expenses')<br/>  .get(authCtrl.requireSignin, expenseCtrl.listByUser)</pre>
<p>A <kbd>GET</kbd> request to this route will first ensure that the requesting user is signed in, before invoking the controller method to fetch the expenses from the database. In this application, users will only be able to view their own expenses. After the user authentication is confirmed, in the <kbd>listByUser</kbd> controller method we query the Expense collection in the database using date range specified in the request and the ID of the user who is signed in. The <span><kbd>listByUser</kbd> method is defined in the following code.</span></p>
<p><kbd>mern-expense-tracker/server/controllers/expense.controller.js</kbd><span>:</span></p>
<pre>const listByUser = async (req, res) =  {<br/>  let firstDay = req.query.firstDay<br/>  let lastDay = req.query.lastDay<br/>  try {<br/>    let expenses = await Expense.find({'$and':[ {'incurred_on': <br/>       { '$gte': firstDay, '$lte':lastDay }}, <br/>           {'recorded_by': req.auth._id } }).sort('incurred_on')<br/>             .populate('recorded_by', '_id name')<br/>    res.json(expenses)<br/>  } catch (err){<br/>    console.log(err)<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>In this method, we start by gathering the first day and the last day of the date range specified in the request query. From the database, we then retrieve the expenses incurred by the signed-in user within these dates. The signed-in user is matched against the user referenced in the <kbd>recorded _by</kbd> field. The <kbd>find</kbd> query against the Expense collection using these values will return matching expenses sorted by the <kbd>incurred_on</kbd> field, with the recently incurred expenses listed first. </p>
<p>The API to retrieve expenses recorded by a specific user can be used in the frontend to retrieve and display the expenses to the end user. <span>To fetch this API in the frontend, we will add a corresponding </span><kbd>listByUser</kbd><span> method in </span><kbd>api-expense.js</kbd><span>, as shown in the following code. </span></p>
<p><kbd>mern-expense-tracker/client/expense/api-expense.js</kbd><span>:</span></p>
<pre>  const listByUser = async (params, credentials, signal) =  {<br/>    const query = queryString.stringify(params)<br/>    try {<br/>      let response = await fetch('/api/expenses?'+query, {<br/>        method: 'GET',<br/>        signal: signal,<br/>        headers: {<br/>          'Accept': 'application/json',<br/>          'Authorization': 'Bearer ' + credentials.t<br/>        }<br/>      })<br/>      return await response.json()<br/>    }catch(err){<br/>      console.log(err)<br/>    }<br/>  }</pre>
<p><span>In this method, before making the request to the list expenses API, we form the query string containing the date range with the <kbd>queryString</kbd> library. Then, this query string is attached to the request URL.</span></p>
<p><span>This fetch method will be used in the <kbd>Expenses</kbd> component to retrieve and show the expenses to the user. We will take a look at the implementation of the <kbd>Expenses</kbd> component in the next section.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Expenses component</h1>
                </header>
            
            <article>
                
<p>The list of expenses retrieved from the database will be rendered using a React component called <kbd>Expenses</kbd>. This component, on the initial load, will render the expenses incurred by the signed-in user in the current month. In this view, the user will also have the option to pick a date range to retrieve expenses incurred within specific dates, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-881 image-border" src="assets/fee16c3c-cc06-4cb4-9b14-aea6d4f3ab59.png" style="width:28.67em;height:18.67em;"/></p>
<p>While defining the <kbd>Expenses</kbd> component, we first use a <kbd>useEffect</kbd> hook to make a fetch call to the list expenses API in order to retrieve the initial list of expenses. We also initialize the values that are necessary for making this request and for rendering the response to be received from the server, as shown in the following code.</p>
<p><kbd>mern-expense-tracker/client/expense/Expenses.js</kbd><span>:</span></p>
<pre>export default function Expenses() {<br/>    const date = new Date(), y = date.getFullYear(), m = date.getMonth()<br/>    const [firstDay, setFirstDay] = useState(new Date(y, m, 1))<br/>    const [lastDay, setLastDay] = useState(new Date(y, m + 1, 0))<br/>    <br/>    const jwt = auth.isAuthenticated()<br/>    const [redirectToSignin, setRedirectToSignin] = useState(false)<br/>    const [expenses, setExpenses] = useState([])<br/><br/>    useEffect(() =  {<br/>        const abortController = new AbortController()<br/>        const signal = abortController.signal<br/>        listByUser({firstDay: firstDay, lastDay: lastDay}, <br/>                   {t: jwt.token}, signal)<br/>        .then((data) =  {<br/>           if (data.error) {<br/>                setRedirectToSignin(true)<br/>              } else {<br/>                setExpenses(data)<br/>              }<br/>           })<br/>        return function cleanup(){<br/>          abortController.abort()<br/>        }<br/>    }, [])<br/>...<br/>}</pre>
<p>We first determine the dates of the first day and the last day of the current month. These dates are set in the state to be rendered in the search form fields and provided as the date range query parameters in the request to the server. Because we will only fetch the expenses associated with the current user, we retrieve the signed-in user's <span><kbd>auth</kbd> credentials to be sent with the request. If the request to the server results in an error, we will redirect the user to the login page. Otherwise, we will set the received expenses in the state to be rendered in the view.</span></p>
<p>In the view part of the <kbd>Expenses</kbd> component, we will add a <span>form to </span>search by date range, before iterating through the resulting expenses array to render individual expense details. In the following sections, we will look at the implementation of the search form and expenses list in the component view.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Searching by date range</h1>
                </header>
            
            <article>
                
<p>In the <kbd>Expenses</kbd> view, users will have the option to view a list of expenses incurred within a specific date range. To implement a search form that allows users to pick a start and end date for the range, we will use <kbd>DatePicker</kbd> components from Material-UI Pickers.</p>
<p>In the view, we will add two <kbd>DatePicker</kbd> components to collect the first day and the last day of the query range, and also add a button to initiate the search, as shown in the following code.</p>
<p><kbd>mern-expense-tracker/client/expense/Expenses.js</kbd><span>:</span></p>
<pre> div className={classes.search} <br/>    &lt;MuiPickersUtilsProvider utils={DateFnsUtils} <br/>        &lt;DatePicker<br/>          disableFuture<br/>          format="dd/MM/yyyy"<br/>          label="SHOWING RECORDS FROM"<br/>          views={["year", "month", "date"]}<br/>          value={firstDay}<br/>          onChange={handleSearchFieldChange('firstDay')}<br/>       /&gt;<br/>        &lt;DatePicker<br/>          format="dd/MM/yyyy"<br/>          label="TO"<br/>          views={["year", "month", "date"]}<br/>          value={lastDay}<br/>          onChange={handleSearchFieldChange('lastDay')}<br/>       /&gt; <br/>    &lt;/MuiPickersUtilsProvider&gt; <br/>    Button variant="contained" color="secondary" <br/>       onClick= {searchClicked} GO &lt;/Button&gt;<br/> &lt;/div&gt;</pre>
<p>When a user interacts with the <kbd>DatePicker</kbd> components to select a date, we will invoke the <kbd>handleSearchFieldChange</kbd> method to get the selected <kbd>date</kbd> value. This method gets the <kbd>date</kbd> value and sets it to either the <kbd>firstDay</kbd> or <kbd>lastDay</kbd> value in the state accordingly. T<span>he </span><kbd>handleSearchFieldChange</kbd><span> method is defined in the following code.</span></p>
<p><kbd>mern-expense-tracker/client/expense/Expenses.js</kbd><span>:</span></p>
<pre>const handleSearchFieldChange = name =  date =  {<br/>    if(name=='firstDay'){<br/>        setFirstDay(date)<br/>    }else{<br/>        setLastDay(date)<br/>    }<br/>}</pre>
<p>After the two dates are selected and set in state, when the user clicks on the <span class="packt_screen">Search</span> button, we will invoke the <kbd>searchClicked</kbd> method. In this method, we make another call to the list expenses API with the new dates sent in the query parameters. The <kbd>searchClicked</kbd><span> method is defined as follows.</span></p>
<p><kbd>mern-expense-tracker/client/expense/Expenses.js</kbd><span>:</span></p>
<pre>const searchClicked = () =  {<br/>    listByUser({firstDay: firstDay, lastDay: lastDay},{t: jwt.token}).then((data) =  {<br/>        if (data.error) {<br/>          setRedirectToSignin(true)<br/>        } else {<br/>          setExpenses(data)<br/>        }<br/>    })<br/>}</pre>
<p>Once the expenses resulting from this new query are received from the server, we set it to the state to be rendered in the view. In the next section, we will look at the implementation for displaying this retrieved list of expenses.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rendering expenses</h1>
                </header>
            
            <article>
                
<p>In the <kbd>Expenses</kbd> component view, we iterate through the list of expenses retrieved from the database and display each expense record to the end user in a Material-UI <kbd>ExpansionPanel</kbd> component. In the <kbd>ExpansionPanel</kbd> component, we show details of the individual expense record in the <em>Summary</em> section. Then, on the expansion of the panel, we will give the user the option to edit details of the expense or delete the expense, as discussed in the next section.</p>
<p>In the following code added to the view code after the search form elements, we use <kbd>map</kbd> to iterate through the <kbd>expenses</kbd> array and render each <kbd>expense</kbd> in an <kbd>ExpansionPanel</kbd> component.</p>
<p><kbd>mern-expense-tracker/client/expense/Expenses.js</kbd><span>:</span></p>
<pre>{expenses.map((expense, index) = {<br/>  return  span key={index} <br/>     &lt;ExpansionPanel className={classes.panel}&gt;<br/>        &lt;ExpansionPanelSummary <br/>           expandIcon={ Edit / } &gt;<br/>          &lt;div className={classes.info} <br/>            Typography className={classes.amount} $ {expense.amount} &lt;/Typography&gt;<br/>            &lt;Divider style={{marginTop: 4, marginBottom: 4}}/&gt;<br/>            &lt;Typography  {expense.category}  &lt;/Typography&gt;<br/>            &lt;Typography className={classes.date} <br/>                {new Date(expense.incurred_on).toLocaleDateString()}<br/>            &lt;/Typography&gt;  <br/>          &lt;/div&gt; <br/>          &lt;div&gt; <br/>            &lt;Typography className={classes.heading} {expense.title} &lt;/Typography&gt; <br/>            &lt;Typography className={classes.notes}  {expense.notes}  &lt;/Typography&gt;<br/>          &lt;/div&gt; <br/>        &lt;/ExpansionPanelSummary&gt;<br/>        &lt;Divider/&gt;<br/>        &lt;ExpansionPanelDetails style={{display: 'block'}} <br/>           ...<br/>        &lt;/ExpansionPanelDetails&gt;<br/>     &lt;/ExpansionPanel&gt; <br/>    &lt;/span&gt; <br/> })<br/>}</pre>
<p>The expense details are rendered in the <kbd>ExpansionPanelSummary</kbd> component, giving the user an overview of the expense that they recorded on the application. The <kbd>ExpansionPanelDetails</kbd> component will contain the options to modify the given expense and complete the feature allowing users to manage the expenses they have recorded on the application. In the next section, we will discuss the implementation of these options to modify the recorded expense. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modifying an expense record</h1>
                </header>
            
            <article>
                
<p>Users on <span>MERN Expense Tracker will be able to modify the expenses they have already recorded on the application by either updating the details of an expense or deleting the expense record altogether.</span></p>
<p><span>In the frontend of the application, they will receive these modification options in the expenses list after expanding to see details of an individual expense in the list, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-970 image-border" src="assets/7800c168-2271-4a4f-8c2e-3f75507ee3ec.png" style="width:27.83em;height:20.25em;"/></p>
<p>To implement these expense modification features, we will have to update the view to render this form and the delete option. Additionally, we will add edit and delete expense API endpoints on the server. In the following sections, we will discuss how to render these edit and delete elements in the frontend, and then implement the edit and delete APIs in the backend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rendering the edit form and delete option</h1>
                </header>
            
            <article>
                
<p>We will render the edit expense form and delete option in the <kbd>Expenses</kbd> component view. For each expense record rendered in a Material-UI <kbd>ExpansionPanel</kbd> component in this view, we will add form fields in the <kbd>ExpansionPanelDetails</kbd> section, with each field pre-populated with the corresponding expense detail value. Users will be able to interact with these form fields to change the values and then click on the <span class="packt_screen">Update</span> button to save the changes to the database. We will add these form fields in the view along with the <span class="packt_screen">Update</span> button and delete option, as shown in the following code.</p>
<p><kbd>mern-expense-tracker/client/expense/Expenses.js</kbd><span>:</span></p>
<pre> &lt;ExpansionPanelDetails style={{display: 'block'}}&gt;<br/>   &lt;div&gt; <br/>     &lt;TextField label="Title" value={expense.title} <br/>               onChange={handleChange('title', index)}/&gt; <br/>     &lt;TextField label="Amount ($)" value={expense.amount} <br/>               onChange={handleChange('amount', index)} type="number"/&gt;<br/>   &lt;/div&gt; <br/>   &lt;div&gt;<br/>     &lt;MuiPickersUtilsProvider utils={DateFnsUtils}&gt; <br/>       &lt;DateTimePicker<br/>          label="Incurred on"<br/>          views={["year", "month", "date"]}<br/>          value={expense.incurred_on}<br/>          onChange={handleDateChange(index)}<br/>          showTodayButton<br/>      /&gt;<br/>     &lt;/MuiPickersUtilsProvider <br/>     &lt;TextField label="Category" value={expense.category} <br/>        onChange={handleChange('category', index)}/&gt;<br/>   &lt;/div&gt; <br/>   &lt;TextField label="Notes" multiline rows="2"<br/>      value={expense.notes}<br/>      onChange={handleChange('notes', index)}<br/>  /&gt;<br/>   &lt;div className={classes.buttons} <br/>    { error &amp;&amp; ( Typography component="p" color="error" <br/>        &lt;Icon color="error" className={classes.error} error &lt;/Icon&gt; <br/>                    {error}<br/>                 &lt;/Typography&gt; )<br/>    }<br/>    { saved &amp;&amp; Typography component="span" color="secondary" Saved &lt;/Typography&gt;  }<br/>     &lt;Button color="primary" variant="contained" <br/>            onClick={()=  clickUpdate(index)} Update &lt;/Button&gt; <br/>     DeleteExpense expense={expense} onRemove={removeExpense}/ <br/>   &lt;/div&gt;  <br/> &lt;/ExpansionPanelDetails&gt; </pre>
<p>The form fields added here are similar to the fields added in the <kbd>NewExpense</kbd> component to create new expense records. When the user interacts with these fields to update the values, we invoke the <kbd>handleChange</kbd> method with the corresponding index of the given expense in the <kbd>expenses</kbd> array, the name of the field, and the changed value. The <kbd>handleChange</kbd> method is defined in the following code. </p>
<p><kbd>mern-expense-tracker/client/expense/Expenses.js</kbd><span>:</span></p>
<pre>const handleChange = (name, index) =  event =  {<br/>    const updatedExpenses = [...expenses]<br/>    updatedExpenses[index][name] = event.target.value<br/>    setExpenses(updatedExpenses)<br/>}</pre>
<p>The expense object at the given index in the <kbd>expenses</kbd> array is updated with the changed value of the specified field and set to state. This will render the view with the latest values as the user is updating the edit form. When the user is done making changes and clicks on the <kbd>Update</kbd> button, we will invoke the <kbd>clickUpdate</kbd> method, which is defined as follows.</p>
<p><kbd>mern-expense-tracker/client/expense/Expenses.js</kbd><span>:</span></p>
<pre>const clickUpdate = (index) =  {<br/>    let expense = expenses[index]<br/>    update({<br/>            expenseId: expense._id<br/>        }, {<br/>            t: jwt.token<br/>        }, expense)<br/>    .then((data) =  {<br/>        if (data.error) {<br/>           setError(data.error)<br/>        } else {<br/>           setSaved(true)<br/>           setTimeout(()= {setSaved(false)}, 3000)<br/>    }<br/>}</pre>
<p>In this <kbd>clickUpdate</kbd> method, we send the updated expense to the backend in a fetch call to an edit expense API. The implementation of this edit expense API is discussed in the next section.</p>
<p>The <kbd>DeleteExpense</kbd> component added to the edit form renders a <span class="packt_screen">Delete</span> button and uses the <kbd>expense</kbd> object passed as a prop to delete the associated expense from the database by calling the delete expense API. The implementation for this <kbd>DeleteExpense</kbd> is similar to the<span> </span><kbd>DeleteShop</kbd><span> component discussed in </span><a href="03fd3b4a-b7fd-4b42-ad7e-5bc34b5612b0.xhtml" target="_blank">Chapter 7</a><span>, </span><em><span class="cdp-chapters-widget-post-title">Exercising MERN Skills with an Online Marketplace</span></em><span class="cdp-chapters-widget-post-title">.<span> In the next section, we will discuss the implementation of the edit and delete expense APIs used by the edit form and delete the option to relay the expense-related updates made by the user to the Expense collection in the database.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Editing and deleting an expense in the backend</h1>
                </header>
            
            <article>
                
<p>In order to complete the edit and delete expense operations initiated by signed-in users from the frontend, we need to have the corresponding APIs in the backend. The route for these API endpoints that will accept the update and delete requests can be declared in the following code.</p>
<p><kbd>mern-expense-tracker/server/routes/expense.routes.js</kbd><span>:</span></p>
<pre>router.route('/api/expenses/:expenseId')<br/>  .put(authCtrl.requireSignin, expenseCtrl.hasAuthorization, expenseCtrl.update)<br/>  .delete(authCtrl.requireSignin, expenseCtrl.hasAuthorization, expenseCtrl.remove)<br/>router.param('expenseId', expenseCtrl.expenseByID)</pre>
<p><span>A <kbd>PUT</kbd> or <kbd>DELETE</kbd> request to this route will first ensure that the current user is signed in with the <kbd>requireSignin</kbd> <kbd>auth</kbd> controller method, before checking authorization and performing any operations in the database.</span></p>
<p><span>The </span><kbd>:expenseId</kbd><span> </span><span>parameter in the route URL, </span><kbd>/api/expenses/:expenseId</kbd><span>, will invoke the</span><span> </span><kbd>expenseByID</kbd><span> </span><span>controller method, which is similar to the</span><span> </span><kbd>userByID</kbd><span> </span><span>controller method. It retrieves the expense from the database and attaches it to the request object to be used in the</span><span> </span><kbd>next</kbd><span> </span><span>method. The</span><span> </span><kbd>expenseByID</kbd><span> </span><span>method is defined in the following code.</span></p>
<p><kbd>mern-expense-tracker/server/controllers/expense.controller.js</kbd><span>:</span></p>
<pre>const expenseByID = async (req, res, next, id) =  {<br/>    try {<br/>      let expense = await Expense.findById(id).populate<br/>           ('recorded_by', '_id name').exec()<br/>      if (!expense)<br/>        return res.status('400').json({<br/>          error: "Expense record not found"<br/>        })<br/>      req.expense = expense<br/>      next()<br/>    } catch (err){<br/>      return res.status(400).json({<br/>        error: errorHandler.getErrorMessage(err)<br/>      })<br/>    }<br/>}</pre>
<p><span>The expense object retrieved that is from the database will also contain the name and ID details of the user who recorded the expense, as we specified in the</span><span> </span><kbd><span>populate()</span></kbd><span> </span><span>method. For these API endpoints, next, we verify that this expense object was actually recorded by the signed-in user with the <kbd>hasAuthorization</kbd> method, which is defined in the expense controller as follows.</span></p>
<p><kbd>mern-expense-tracker/server/controllers/expense.controller.js</kbd><span>:</span></p>
<pre>const hasAuthorization = (req, res, next) =  {<br/>  const authorized = req.expense &amp;&amp; req.auth &amp;&amp; <br/>      req.expense.recorded_by._id == req.auth._id<br/>  if (!(authorized)) {<br/>    return res.status('403').json({<br/>      error: "User is not authorized"<br/>    })<br/>  }<br/>  next()<br/>}</pre>
<p>Once it has been confirmed that the user trying to update the expense is the one who recorded it and if it is a <kbd>PUT</kbd> request, then the <kbd>update</kbd> method is invoked next to update the expense document with the new changes in the Expense collection. The <kbd>update</kbd> controller method is defined in the following code.</p>
<p><kbd>mern-expense-tracker/server/controllers/expense.controller.js</kbd><span>:</span></p>
<pre>const update = async (req, res) =  {<br/>    try {<br/>      let expense = req.expense<br/>      expense = extend(expense, req.body)<br/>      expense.updated = Date.now()<br/>      await expense.save()<br/>      res.json(expense)<br/>    } catch (err) {<br/>      return res.status(400).json({<br/>        error: errorHandler.getErrorMessage(err)<br/>      })<br/>    }<br/>}</pre>
<p><span>The method retrieves the expense details from <kbd>req.expense</kbd>, then uses the <kbd>lodash</kbd> module to extend and merge the changes that came in the request body to update the expense data. Before saving this updated expense to the database, the <kbd>updated</kbd> field is populated with the current date to reflect the last updated timestamp. On the successful save of this update, the updated expense object is sent back in the response.</span></p>
<p><span>If it is a <kbd>DELETE</kbd> request instead of a <kbd>PUT</kbd> request, the </span><kbd>remove</kbd><span> method is invoked instead in order to delete the specified expense document from the collection in the database. The <kbd>remove</kbd> controller method is defined in the following code.</span></p>
<p><kbd>mern-expense-tracker/server/controllers/expense.controller.js</kbd><span>:</span></p>
<pre>const remove = async (req, res) =  {<br/>    try {<br/>      let expense = req.expense<br/>      let deletedExpense = await expense.remove()<br/>      res.json(deletedExpense)<br/>    } catch (err) {<br/>      return res.status(400).json({<br/>        error: errorHandler.getErrorMessage(err)<br/>      })<br/>    }<br/>}</pre>
<p>The <kbd>remove</kbd> operation in this method will permanently delete the expense from the application.</p>
<p class="mce-root"><span>We have all the features in place for users on the application to start recording and managing their day-to-day expenses. We defined an Expense model for storing expense data, and backend APIs and frontend views for creating new expenses, displaying a list of expenses for a given user, and modifying an existing expense. We are now ready to implement data visualization features based on the expense data that will be recorded by users on the application over time. We will discuss these implementations in the next section.<br/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visualizing expense data over time</h1>
                </header>
            
            <article>
                
<p>Aside from allowing users to keep logs of their expenses, the MERN Expense Tracker application will process the collected expense data to give users insights into their spending habits over time. We will implement simple data aggregation and visualization features to demonstrate how the MERN stack can accommodate such requirements in any full-stack application. To enable these features, we will utilize MongoDB's aggregation framework and also the React-based charting and data visualization library<span>—</span>Victory<span>—</span>by Formidable. </p>
<p>In the following sections, we will first add features to summarize a user's expenses in the current month and also show how they are doing compared to previous months. Then, we will add different Victory charts to give them a visual representation of their spending patterns over a month, and a year, and per expense category.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summarizing recent expenses</h1>
                </header>
            
            <article>
                
<p>When a user signs in to their account on the application, they will see a preview of the expenses they incurred so far in the current month. They will also see a comparison of how much more or less they are spending in each category in comparison to the averages from previous months. To implement these features, we will have to add backend APIs that will run aggregation operations on the relevant expense data in the database and return the computed results to be rendered in the frontend. In the following sections, we will implement the full-stack slices<span>—</span>first to show a preview of all the expenses incurred so far in the current month, and then a comparison of the average expenses per category with respect to expenditures in the current month.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Previewing expenses in the current month</h1>
                </header>
            
            <article>
                
<p>After a user signs in to the application, we will show a preview of their current expenses, including their total expenditure for the current month and how much they spent on the current date and the day before. This preview will be displayed to the end user, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-883 image-border" src="assets/60c1cf6a-5c2f-4a1f-9c37-ed181fd420b3.png" style="width:19.50em;height:12.33em;"/></p>
<p>In order to implement this feature, we need to add a backend API that will process the existing expense data to return these three values, so it can be rendered in a React component. In the following sections, we will take a look at the implementation and integration of this API with a frontend view to complete this preview feature. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The current month preview API</h1>
                </header>
            
            <article>
                
<p>We will add an API to the backend that will return the preview of expenses incurred so far in the current month. To implement this API, we will first declare a <kbd>GET</kbd> route, as shown in the following code.</p>
<p><kbd>mern-expense-tracker/server/routes/expense.routes.js</kbd><span>:</span></p>
<pre>router.route('/api/expenses/current/preview')<br/>  .get(authCtrl.requireSignin, expenseCtrl.currentMonthPreview)</pre>
<p>A <kbd>GET</kbd> request to this route at <kbd>'/api/expenses/current/preview'</kbd> will first ensure the requesting client is a signed-in user, and then it will invoke the <kbd>currentMonthPreview</kbd> controller method. In this method, we will use MongoDB's aggregation framework to perform three sets of aggregations on the Expense collection and retrieve the <span>total expenses for the </span>current month, the current date, and the day before.</p>
<p>T<span>he </span><kbd>currentMonthPreview</kbd><span> controller method will be defined with the following structure, where we first determine the dates needed to find matching expenses, and then we perform the aggregations before returning the results in the response.</span></p>
<p><kbd>mern-expense-tracker/server/controllers/expense.controller.js</kbd><span>:</span></p>
<pre>const currentMonthPreview = async (req, res) =  {<br/>  const date = new Date(), y = date.getFullYear(), m = date.getMonth()<br/>  const firstDay = new Date(y, m, 1)<br/>  const lastDay = new Date(y, m + 1, 0)<br/><br/>  const today = new Date()<br/>  today.setUTCHours(0,0,0,0)<br/>  <br/>  const tomorrow = new Date()<br/>  tomorrow.setUTCHours(0,0,0,0)<br/>  tomorrow.setDate(tomorrow.getDate()+1)<br/>  <br/>  const yesterday = new Date()<br/>  yesterday.setUTCHours(0,0,0,0)<br/>  yesterday.setDate(yesterday.getDate()-1)<br/><br/>  try {<br/>      /* ... Perform aggregation operations on the Expense collection <br/>             to compute current month's numbers ... */<br/>      /* ... Send computed result in response ... */<br/>  } catch (err){<br/>    console.log(err)<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/><br/>}</pre>
<p>We first determine the dates for the current month's first day and last day, then the dates for today, tomorrow, and yesterday with the minutes and seconds set to zero. We will need these dates to specify the ranges for finding the matching expenses that were incurred in the current month, today, and yesterday. Then, with these values and the signed-in user's ID reference, we construct the aggregation pipelines necessary to retrieve the total expenses for the current month, today, and yesterday. We group these three different aggregation pipelines using the <kbd>$facet</kbd> stage in MongoDB's aggregation framework, as shown in the following code.</p>
<p><kbd>mern-expense-tracker/server/controllers/expense.controller.js</kbd><span>:</span></p>
<pre>let currentPreview = await Expense.aggregate([<br/>  { $facet: { month: [<br/>    { $match: { incurred_on: { $gte: firstDay, $lt: lastDay }, <br/>      recorded_by: mongoose.Types.ObjectId(req.auth._id)}},<br/>    { $group: { _id: "currentMonth" , totalSpent: {$sum: "$amount"} }},<br/>       ],<br/>    today: [<br/>      { $match: { incurred_on: { $gte: today, $lt: tomorrow }, <br/>        recorded_by: mongoose.Types.ObjectId(req.auth._id) }},<br/>      { $group: { _id: "today" , totalSpent: {$sum: "$amount"} } },<br/>        ],<br/>   <br/>    yesterday: [<br/>      { $match: { incurred_on: { $gte: yesterday, $lt: today }, <br/>        recorded_by: mongoose.Types.ObjectId(req.auth._id) }},<br/>      { $group: { _id: "yesterday" , totalSpent: {$sum: "$amount"} } <br/>        },<br/>       ]<br/>    }<br/>  }])<br/>let expensePreview = {month: currentPreview[0].month[0], today: currentPreview[0].today[0], yesterday: currentPreview[0].yesterday[0] }<br/>res.json(expensePreview)</pre>
<p>For each aggregation pipeline, we first match the expenses using the date range values for the <kbd>incurred_on</kbd> field, and also the <kbd>recorded_by</kbd> field with the current user's reference, so the aggregation is only performed on the expenses recorded by the current user. Then, the matching expenses in each pipeline are grouped to calculate the total amount spent. </p>
<div class="packt_infobox">In the <span>faceted aggregation operation </span>result, e<span>ach pipeline has its own field in the output document where the results are stored as an array of documents.</span></div>
<p><span>After the aggregation operations are completed, we access the computed results and compose the response to be sent back in the response to the requesting client. This API can be used in the frontend with a fetch request. You can define a corresponding fetch method to make the request, similar to other API implementations. Then, the fetch method can be used in a React component to retrieve </span><span>and render </span><span>these aggregated values </span><span>to the user. In the next section, we will discuss the implementation of this view to render the preview of current expenses for a user.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rendering the preview of current expenses</h1>
                </header>
            
            <article>
                
<p>We can give the user a glimpse of their current expenses in any React component, which is accessible to a signed-in user and added to the frontend of the application. To retrieve the expense totals and render these in the view, we can call the current month preview API either in a <kbd>useEffect</kbd> hook or when a button is clicked on.</p>
<p>In the MERN Expense Tracker application, we render these details in a React component that is added to the home page. We use a <kbd>useEffect</kbd> hook, as shown in the following code, to retrieve the current expense preview data.</p>
<p><kbd>mern-expense-tracker/client/expense/ExpenseOverview.js</kbd><span>:</span></p>
<pre>  useEffect(() =  {<br/>      const abortController = new AbortController()<br/>      const signal = abortController.signal<br/>      currentMonthPreview({t: jwt.token}, signal).then((data) =  {<br/>        if (data.error) {<br/>          setRedirectToSignin(true)<br/>        } else {<br/>          setExpensePreview(data)<br/>        }<br/>      })<br/>      return function cleanup(){<br/>        abortController.abort()<br/>      }<br/>  }, [])</pre>
<p>Once the data is received from the backend, we set it to state in a variable called <kbd>expensePreview</kbd>, so the information can be displayed in the view. In the view of the component, we use this state variable to compose an interface with these details as desired. In the following code, we render the total expenses for the current month, for the current date, and for the day before.</p>
<p><kbd>mern-expense-tracker/client/expense/ExpenseOverview.js</kbd><span>:</span></p>
<pre> &lt;Typography variant="h4" color="textPrimary" You've spent &lt;/Typography&gt; <br/> &lt;div&gt;  <br/>&lt;Typography component="span" <br/>        ${expensePreview.month ? expensePreview.month.totalSpent : '0'} <br/>          span so far this month  &lt;/span&gt; <br/>     &lt;/Typography&gt;<br/>     &lt;div&gt; <br/>       &lt;Typography variant="h5" color="primary" <br/>         ${expensePreview.today ? expensePreview.today.totalSpent :'0'} <br/>             span today &lt;/span&gt; <br/>         &lt;/Typography&gt;<br/>         &lt;Typography variant="h5" color="primary" <br/>            ${expensePreview.yesterday <br/>               ? expensePreview.yesterday.totalSpent: '0'}     <br/>             &lt;span className={classes.day} yesterday  &lt;/span&gt; <br/>         &lt;/Typography&gt; <br/>         &lt;Link to="/expenses/all"  Typography variant="h6"&gt; See more            &lt;/Typography&gt;  &lt;/Link&gt; <br/>     &lt;/div&gt; <br/> &lt;/div&gt; </pre>
<p>These values are only rendered if the corresponding value is returned in the aggregation results from the backend; otherwise, we render a "<kbd>0</kbd>."</p>
<p>With this current expenses preview feature implemented, we are able to process the expense data recorded by the user to give them an idea of how much they are spending currently. In the next section, we will follow similar implementation steps to inform the user about their spending status for each expense category.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tracking current expenses by category</h1>
                </header>
            
            <article>
                
<p>In this application, we will give the user an overview of how much they are currently spending in each expense category in comparison to previous averages. For each category, we will display the monthly average based on previous expense data, show the total spent so far in the current month, and show the difference to indicate whether they are spending extra or are saving money in the current month. The following screenshot shows what this feature will look like to the end user for their expense data: </p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-884 image-border" src="assets/d2f06c77-b483-4b80-9079-4ad1551ce9c8.png" style="width:26.50em;height:21.33em;"/></p>
<p><span>To implement this feature, we need to add a backend API that will process the existing expense data to return the monthly average along with the total spent in the current month for each category, so it can be rendered in a React component. In the following sections, we will look at the implementation and integration of this API and frontend view to complete this feature to track expenses by category. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The current expenses by category API</h1>
                </header>
            
            <article>
                
<p><span>We will add an API to the backend that will return the average monthly expenses and the total spent in the current month for each expense category. To implement this API, we will first declare a <kbd>GET</kbd> route, as shown in the following code.</span></p>
<p><kbd>mern-expense-tracker/server/routes/expense.routes.js</kbd><span>:</span></p>
<pre>router.route('/api/expenses/by/category')<br/>  .get(authCtrl.requireSignin, expenseCtrl.expenseByCategory)</pre>
<p><span>A <kbd>GET</kbd> request to this route at </span><kbd>'/api/expenses/by/category'</kbd><span> will first ensure that the requesting client is a signed-in user, and then it will invoke the </span><kbd>expenseByCategory</kbd><span> controller method. </span>In this method, we will use different features of MongoDB's aggregation framework to separately calculate the monthly expense averages for each category and the total spent in the current month per category, before combining the two results to return these two values associated with each category to the requesting client.</p>
<p>T<span>he <kbd>expenseByCategory</kbd></span><span> controller method will be defined with the following structure, where we first determine the dates required to find matching expenses, and then we perform the aggregations before returning the results in the response.</span></p>
<p><kbd>mern-expense-tracker/server/controllers/expense.controller.js</kbd><span>:</span></p>
<pre>const expenseByCategory = async (req, res) =  {<br/>  const date = new Date(), y = date.getFullYear(), m = date.getMonth()<br/>  const firstDay = new Date(y, m, 1)<br/>  const lastDay = new Date(y, m + 1, 0)<br/><br/>  try {<br/>    let categoryMonthlyAvg = await Expense.aggregate([/*... aggregation ... */]).exec()<br/>    res.json(categoryMonthlyAvg)<br/>  } catch (err) {<br/>    console.log(err)<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>In this method, we will use an aggregation pipeline containing a <kbd>$facet</kbd> with two sub-pipelines for calculating the monthly average per category and the total spent per category in the current month. Then, we take these two resulting arrays from the sub-pipelines to merge the results. The code for this aggregation pipeline is defined in the following code. </p>
<p><kbd>mern-expense-tracker/server/controllers/expense.controller.js</kbd><span>:</span></p>
<pre>[<br/>  { $facet: {<br/>     average: [<br/>      { $match: { recorded_by: mongoose.Types.ObjectId(req.auth._id) }},<br/>      { $group: { _id: {category: "$category", month: {$month: "$incurred_on"}}, <br/>                  totalSpent: {$sum: "$amount"} } },<br/>      { $group: { _id: "$_id.category", avgSpent: { $avg: "$totalSpent"}}},<br/>      { $project: {<br/>         _id: "$_id", value: {average: "$avgSpent"},<br/>        }<br/>      }<br/>     ],<br/>     total: [<br/>      { $match: { incurred_on: { $gte: firstDay, $lte: lastDay }, <br/>                  recorded_by: mongoose.Types.ObjectId(req.auth._id) }},<br/>      { $group: { _id: "$category", totalSpent: {$sum: "$amount"} } },<br/>      { $project: {<br/>         _id: "$_id", value: {total: "$totalSpent"},<br/>        }<br/>      }<br/>     ]<br/>    }<br/>  },<br/>  { $project: {<br/>     overview: { $setUnion:['$average','$total'] },<br/>   }<br/>  },<br/>  { $unwind: '$overview' },<br/>  { $replaceRoot: { newRoot: "$overview" } },<br/>  { $group: { _id: "$_id", mergedValues: { $mergeObjects: "$value" } } }<br/>]</pre>
<p>While projecting the output of the sub-pipelines in the <kbd>$facet</kbd> stage, we make sure that the keys of the result objects are <kbd>_id</kbd> and <kbd>value</kbd> in both output arrays, so they can be merged uniformly. Once the faceted aggregation operations are done, we use a <kbd>$setUnion</kbd> on the results to combine the arrays. Then, we make the resulting combined array the new root document in order to run a <kbd>$group</kbd> aggregation on it to merge the values for the averages and totals per category.</p>
<p>The final output from this aggregation pipeline will contain an array with an object for each expense category. Each object in this array will have the category name as the <kbd>_id</kbd> value and a <kbd>mergedValues</kbd> object containing the average and total values for the category. <span>Then, this final output array generated from the aggregation is sent back in the response to the requesting client.</span></p>
<p><span>We can use this API in the frontend with a fetch request. You can define a corresponding fetch method to make the request, similar to other API implementations. Then, the fetch method can be used in a React component to retrieve </span><span>and render </span><span>these aggregated values </span><span>to the user. In the next section, we will discuss the implementation of this view to render the comparison of expenses in each category by a user in the current month versus previous months.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rendering an overview of expenses per category </h1>
                </header>
            
            <article>
                
<p><span>Besides informing the user of how much they are spending currently, we can give them an idea of how they are doing in comparison to previous expenditures. We can tell them whether they are spending more or saving money in the current month for each category. We can implement a React component, that calls the current expenses by category API to render the average and total values sent by the backend and also displays the computed difference between these two values.</span></p>
<p><span>The API can be fetched either in a </span><kbd>useEffect</kbd><span> hook or when a button is clicked on. In the MERN Expense Tracker application, we render these details in a React component that is added to the home page. We use a </span><kbd>useEffect</kbd><span> hook, as shown in the following code, to retrieve the expenses per category data.</span></p>
<p><kbd>mern-expense-tracker/client/expense/ExpenseOverview.js</kbd><span>:</span></p>
<pre>  useEffect(() =  {<br/>    const abortController = new AbortController()<br/>    const signal = abortController.signal<br/>    expenseByCategory({t: jwt.token}, signal).then((data) =  {<br/>      if (data.error) {<br/>        setRedirectToSignin(true)<br/>      } else {<br/>        setExpenseCategories(data)<br/>      }<br/>    })<br/>    return function cleanup(){<br/>      abortController.abort()<br/>    }<br/>  }, [])</pre>
<p>We will set the values <span>received </span>from the backend to the state in an <kbd>expenseCategories</kbd> variable, and render its details in the view. This variable will contain an array, which we will iterate through in the view code to display three values for each category<span>—</span>the monthly average, the current month's total expenditure, and the difference between the two with an indication of whether money was saved or not.</p>
<p>In the following code, we use a <kbd>map</kbd> to iterate over the received data array and, for each item in the array, generate the view to display the average and total values received with the item. Besides this, we also show a computed value using these two values.</p>
<p><kbd>mern-expense-tracker/client/expense/ExpenseOverview.js</kbd><span>:</span></p>
<pre>{<strong>expenseCategories.map</strong>((expense, index) =  {<br/>    return( div key={index}  <br/>        &lt;Typography variant="h5" {<strong>expense._id</strong>} &lt;/Typography&gt;<br/>        &lt;Divider style={{ backgroundColor: <br/>            <strong>indicateExpense</strong>(expense.mergedValues)}}/&gt;<br/>        &lt;div&gt; <br/>          &lt;Typography component="span" past average &lt;/Typography&gt;<br/>          &lt;Typography component="span" this month &lt;/Typography&gt; <br/>          &lt;Typography component="span"  {<strong>expense.mergedValues.total </strong><br/><strong>             &amp;&amp; expense.mergedValues.total-<br/>              expense.mergedValues.average &gt; 0 ?<br/>                 </strong><strong>"spent extra" : "saved"</strong> } <br/>          &lt;/Typography&gt; <br/>        &lt;/div&gt; <br/>        &lt;div&gt; <br/>          &lt;Typography component="span" ${<strong>expense.mergedValues.average</strong>}         &lt;/Typography&gt; <br/>          &lt;Typography component="span" ${<strong>expense.mergedValues.total ? </strong><br/><strong>             expense.mergedValues.total : 0</strong>}<br/>          &lt;/Typography&gt; <br/>          &lt;Typography component="span" ${<strong>expense.mergedValues.total ? </strong><br/><strong>           Math.abs(expense.mergedValues.total-<br/>             expense.mergedValues.average) : </strong><strong> <br/>                expense.mergedValues.average</strong>}<br/>          &lt;/Typography&gt;<br/>        &lt;/div&gt; <br/>        &lt;Divider/&gt; <br/>     &lt;/div&gt; ) <br/>  })<br/>}</pre>
<p>For each item in the array, we first render the category name, then the headings of the three values we will display. The third heading is rendered conditionally depending on whether the current total is more or less than the monthly average. Then, under each heading, we render the corresponding values for the monthly average, the current total<span>—</span>which will be zero if no value was returned<span>—</span>and then the difference between this average and the total. For the third value, we render the absolute value of the computed difference between the average and total values using <kbd>Math.abs()</kbd>.</p>
<p>Based on this difference, we also render the divider under the category name with different colors to indicate whether money was saved, extra money was spent, or the same amount of money was spent. To determine the color, we define a method called <kbd>indicateExpense</kbd>, as shown in the following code:</p>
<pre>const indicateExpense = (values) =  {<br/>    let color = '#4f83cc'<br/>    if(values.total){<br/>      const diff = values.total - values.average<br/>      if( diff   0){<br/>        color = '#e9858b'<br/>      }<br/>      if( diff   0 ){<br/>        color = '#2bbd7e'<br/>      } <br/>    }<br/>    return color<br/>}</pre>
<p>A different color is returned if the current total is more than, less than, or equal to the monthly average. This gives <span>the user </span>a quick visual indicator of how they are faring in terms of incurring expenses per category for the current month.</p>
<p>We have added simple data visualization features to the expense tracking application by utilizing existing capabilities of MERN stack technologies such as the aggregation framework in MongoDB. In the next section, we will demonstrate how to add even more complex data visualization features into this application by integrating an external charting library.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Displaying expense data charts</h1>
                </header>
            
            <article>
                
<p>Graphs and charts are time-tested mechanisms for visualizing complex data patterns. In the MERN Expense Tracker application, we will add simple charts using Victory to report expense patterns over time in graphical representations to the user.</p>
<div class="packt_infobox">Victory is an open source charting and data visualization library for React and React Native developed by Formidable. Different types of charts are available as modular components that can be customized and added to any React application. To learn more about Victory, visit <a href="https://formidable.com/open-source/victory" target="_blank">https://formidable.com/open-source/victory</a>.</div>
<p>Before we get started with integrating Victory charts in the code, we will need to install the module by running the following command from the command line:</p>
<pre><strong>yarn add victory</strong></pre>
<p>In the expense tracking application, we will add three different charts as a part of the interactive expense reports presented to the user. The three charts will include a scatter plot showing the expenses incurred in a given month, a bar chart showing the total expenses incurred per month in a given year, and a pie chart showing the average expenditure per category within a provided date range.</p>
<p>For each chart, we will add a corresponding backend API to retrieve the relevant expense data and a React component to the frontend that will use the retrieved data to render the associated Victory chart. In the following sections, we will implement the full-stack slices necessary to add a scatter plot chart for a month's expenses, a bar chart showing a year's monthly expenses, and a pie chart displaying the average expenses per category over a given period of time. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A month's expenses in a scatter plot</h1>
                </header>
            
            <article>
                
<p>We will show the expenses incurred by a user over a given month in a scatter plot. This will provide them with a visual overview of how their expenses pan out over a month. The following screenshot shows how the scatter plot will render with user expense data: </p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9dd8ba80-3981-4919-a0e7-cdda0e660b71.png" style="width:29.92em;height:25.42em;"/></p>
<p>We plot the expense amounts versus the day of the month when it was incurred on the <em>y</em> axis and <em>x</em> axis, respectively. Hovering over a plotted bubble displays how much was spent on which date for that specific expense record. In the following sections, we will implement this feature by first adding a backend API that will return the expenses for the given month in the format needed to render it in a Victory Scatter chart. Then, we will add a React component that will retrieve this data from the backend and render it in the Victory Scatter chart.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The scatter plot data API</h1>
                </header>
            
            <article>
                
<p><span>We will add an API to the backend that will return the expenses incurred over a given month in the data format needed to render the scatter chart in the frontend. To implement this API, we will first declare a <kbd>GET</kbd> route, as shown in the following code.</span></p>
<p><kbd>mern-expense-tracker/server/routes/expense.routes.js</kbd><span>:</span></p>
<pre>router.route('/api/expenses/plot')<br/>  .get(authCtrl.requireSignin, expenseCtrl.plotExpenses)</pre>
<p><span>A <kbd>GET</kbd> request to this route at </span><kbd>'/api/expenses/plot'</kbd><span> will first ensure that the requesting client is a signed-in user, and then it will invoke the </span><kbd>plotExpenses</kbd><span> controller method. The request will also </span>take the value of the given month in a URL query parameter, which will be used in the <kbd>plotExpenses</kbd> method to determine the dates of the first day and the last day of the provided month. <span>We will need these dates to specify the range for finding the matching expenses that were incurred in the specified month and recorded by the authenticated user while aggregating the expenses into the data format needed for the chart. The <kbd>plotExpenses</kbd> method is defined in the following code.</span></p>
<p><kbd>mern-expense-tracker/server/controllers/expense.controller.js</kbd><span>:</span></p>
<pre>const plotExpenses = async (req, res) =  {<br/><br/>    const date = new Date(req.query.month), y = date.getFullYear(), m =    date.getMonth()<br/>    const firstDay = new Date(y, m, 1)<br/>    const lastDay = new Date(y, m + 1, 0)<br/><br/>    try {<br/><br/>        let totalMonthly = await Expense.aggregate( [<br/>        { $match: { incurred_on: { $gte : firstDay, $lt: lastDay }, <br/>                    recorded_by: mongoose.Types.ObjectId(req.auth._id) }},<br/>        { $project: {x: {$dayOfMonth: '$incurred_on'}, y: '$amount'}}<br/>        ]).exec()<br/><br/>        res.json(totalMonthly)<br/><br/>    } catch (err){<br/>        console.log(err)<br/>        return res.status(400).json({<br/>        error: errorHandler.getErrorMessage(err)<br/>        })<br/>    }<br/>}</pre>
<p>We run a simple aggregation operation that finds the matching expenses and returns an output containing the values in the format needed for the <em>y</em> axis and <em>x</em> axis values of the scatter chart. The final result of the aggregation contains an array of objects, with each object containing an <kbd>x</kbd> attribute and a <kbd>y</kbd> attribute. The <kbd>x</kbd> attribute contains the day of the month value from the <kbd>incurred_on</kbd> date. The <kbd>y</kbd> attribute contains the corresponding expense amount. T<span>his final output array generated from the aggregation is sent back in the response to the requesting client.</span></p>
<p><span>We can use this API in the frontend with a fetch request. You can define a corresponding fetch method to make the request, similar to other API implementations. Then, the fetch method can be used in a React component to retrieve </span><span>and render this array of <kbd>x</kbd> and <kbd>y</kbd> values in a scatter plot chart</span><span>. In the next section, we will discuss the implementation of this view to render a scatter chart showing the expenses incurred over a given month.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The MonthlyScatter component</h1>
                </header>
            
            <article>
                
<p><span>We will implement a React component that calls the scatter plot data API to render the received array of expenses incurred over a given month in a Victory Scatter chart. </span></p>
<p><span>The API can be fetched either in a </span><kbd>useEffect</kbd><span> hook or when a button is clicked on. In the MERN Expense Tracker application, we render this scatter chart in a React component called <kbd>MonthlyScatter</kbd>. When this component loads, we render a scatter chart for expenses in the current month. We also add a <kbd>DatePicker</kbd> component to allow users to select the desired month and retrieve data for that month with a button click. In the following code, we retrieve the initial scatter plot data with a </span><kbd>useEffect</kbd><span> hook when the component loads.</span></p>
<p><kbd>mern-expense-tracker/client/report/MonthlyScatter.js</kbd><span>:</span></p>
<pre>const [plot, setPlot] = useState([])<br/>const [month, setMonth] = useState(new Date())<br/>const [error, setError] = useState('')<br/>const jwt = auth.isAuthenticated()<br/>useEffect(() =  {<br/>        const abortController = new AbortController()<br/>        const signal = abortController.signal<br/><br/>        plotExpenses({month: month},{t: jwt.token}, signal).then((data) =  {<br/>          if (data.error) {<br/>            setError(data.error)<br/>          } else {<br/>            setPlot(data)<br/>          }<br/>        })<br/>        return function cleanup(){<br/>          abortController.abort()<br/>        }<br/>    }, [])</pre>
<p>When the plotted data is received from the backend and set in the state, we can render it in a Victory Scatter chart. Additionally, we can add the following code in the component view to render a customized scatter chart with labels.</p>
<p><kbd>mern-expense-tracker/client/report/MonthlyScatter.js</kbd><span>:</span></p>
<pre> &lt;VictoryChart<br/>    theme={VictoryTheme.material}<br/>    height={400}<br/>    width={550}<br/>    domainPadding={40}<br/>     <br/>     &lt;VictoryScatter<br/>        style={{<br/>            data: { fill: "#01579b", stroke: "#69f0ae", strokeWidth: 2 },<br/>            labels: { fill: "#01579b", fontSize: 10, padding:8}<br/>        }}<br/>        bubbleProperty="y"<br/>        maxBubbleSize={15}<br/>        minBubbleSize={5}<br/>        labels={({ datum }) =  `$${datum.y} on ${datum.x}th`}<br/>        labelComponent={ VictoryTooltip/ }<br/>        data={plot}<br/>        domain={{x: [0, 31]}}<br/>    /&gt;<br/>     &lt;VictoryLabel<br/>        textAnchor="middle"<br/>        style={{ fontSize: 14, fill: '#8b8b8b' }}<br/>        x={270} y={390}<br/>        text={`day of month`}<br/>    /&gt; <br/>     &lt;VictoryLabel<br/>        textAnchor="middle"<br/>        style={{ fontSize: 14, fill: '#8b8b8b' }}<br/>        x={6} y={190}<br/>        angle = {270} <br/>        text={`Amount ($)`}<br/>    /&gt;<br/> &lt;/VictoryChart&gt;</pre>
<p>We place a <kbd>VictoryScatter</kbd> component in a <kbd>VictoryChart</kbd> component, giving us the flexibility to customize the scatter chart wrapper and place axis label texts outside <span>the scatter chart. We pass the data to <kbd>VictoryScatter</kbd>, indicate which value the bubble property is based on, customize the styles, and specify the size range and labels for each bubble.</span></p>
<p><span>This code plots and renders the scatter chart against the data provided with the amount spent versus the day of the month on the <em>y</em> axis and <em>x</em> axis, respectively. In the next section, we will follow similar steps to add a bar chart to graphically display the monthly expenses in a given year.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Total expenses per month in a year</h1>
                </header>
            
            <article>
                
<p>We will show the user a bar chart representing their total monthly expenses over a given year. This will give them an overview of how their expenses are spread out annually. <span>The following screenshot shows how the bar chart will render with user expense data: </span></p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-885 image-border" src="assets/cd85f5ff-22b3-4a73-b64b-895a21ff103d.png" style="width:23.67em;height:18.17em;"/></p>
<p class="mce-root">Here, we populate the bar chart with the total expense value corresponding to each month in a given year. We add the monthly total value as labels to each bar. On the x-axis, we show the short name of each month. In the following sections, we will implement this feature by first adding a backend API that will return the total expenses incurred per month over a given year and in the format needed to render it in a Victory Bar chart. Then, we will add a React component that will retrieve this data from the backend and render it in the Victory Bar chart.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The yearly expenses API</h1>
                </header>
            
            <article>
                
<p><span>We will add an API to the backend that will return the total monthly expenses incurred over a given year in the data format needed to render the bar chart in the frontend.</span></p>
<p><span>To implement this API, we will first declare a <kbd>GET</kbd> route, as shown in the following code.</span></p>
<p><kbd>mern-expense-tracker/server/routes/expense.routes.js</kbd><span>:</span></p>
<pre>router.route('/api/expenses/yearly')<br/>  .get(authCtrl.requireSignin, expenseCtrl.yearlyExpenses)</pre>
<p><span>A <kbd>GET</kbd> request to this route at </span><kbd>'/api/expenses/yearly'</kbd><span> will first ensure that the requesting client is a signed-in user, and then it will invoke the </span><kbd>yearlyExpenses</kbd><span> controller method. The request will also </span><span>take the value of the given year in a URL query parameter, which will be used in the </span><kbd>yearlyExpenses</kbd><span> method to determine the dates of the first day and the last day of the provided year. </span><span>We will need these dates to specify the range for finding the matching expenses that were incurred in the specified year and recorded by the authenticated user while aggregating the total monthly expenses into the data format needed for the chart. The <kbd>yearlyExpenses</kbd> method is defined in the following code.</span></p>
<p><kbd>mern-expense-tracker/server/controllers/expense.controller.js</kbd><span>:</span></p>
<pre>  const yearlyExpenses = async (req, res) =  {<br/>  const y = req.query.year<br/>  const firstDay = new Date(y, 0, 1)<br/>  const lastDay = new Date(y, 12, 0)<br/>  try {<br/>    let totalMonthly = await Expense.aggregate( [<br/>      { $match: { incurred_on: { $gte : firstDay, $lt: lastDay } }},<br/>      { $group: { _id: {$month: "$incurred_on"}, totalSpent: {$sum: "$amount"} } },<br/>      { $project: {x: '$_id', y: '$totalSpent'}}<br/>    ]).exec()<br/>    res.json({monthTot:totalMonthly})<br/>  } catch (err){<br/>    console.log(err)<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>We run an aggregation operation that finds the matching expenses, groups the expenses by month to calculate the total, and returns an output containing the values in the format needed for the <em>y</em> axis and <em>x</em> axis values of the bar chart. The final result of the aggregation contains an array of objects, with each object containing an<span> </span><kbd>x</kbd><span> attribute </span>and<span> a </span><kbd>y</kbd><span> </span>attribute.</p>
<p>The<span> </span><kbd>x</kbd><span> </span>attribute contains the month value from the<span> </span><kbd>incurred_on</kbd><span> </span>date. The<span> </span><kbd>y</kbd><span> </span>attribute contains the corresponding total expense amount for that month. T<span>his final output array generated from the aggregation is sent back in the response to the requesting client.</span></p>
<p><span>We can use this API in the frontend with a fetch request. You can define a corresponding fetch method to make the request, similar to other API implementations. Then, the fetch method can be used in a React component to retrieve </span><span>and render this array of <kbd>x</kbd> and <kbd>y</kbd> values in a bar chart</span><span>. In the next section, we will discuss the implementation of this view to render a bar chart showing the total monthly expenses incurred over a given year.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The YearlyBar component</h1>
                </header>
            
            <article>
                
<p><span>We will implement a React component that calls the yearly expenses data API to render the received array of expenses incurred monthly over a given year in a Victory Bar chart. </span></p>
<p><span>The API can be fetched either in a </span><kbd>useEffect</kbd><span> hook or when a button is clicked on. In the MERN Expense Tracker application, we render this bar chart in a React component called <kbd>YearlyBar</kbd>. When this component loads, we render a bar chart for expenses in the current year. We also add a <kbd>DatePicker</kbd> component to allow users to select the desired year and retrieve data for that year with a button click. In the following code, we retrieve the initial yearly expense data with a </span><kbd>useEffect</kbd><span> hook when the component loads.</span></p>
<p><kbd>mern-expense-tracker/client/report/YearlyBar.js</kbd><span>:</span></p>
<pre>const [year, setYear] = useState(new Date())<br/>const [yearlyExpense, setYearlyExpense] = useState([])<br/>const [error, setError] = useState('') <br/>const jwt = auth.isAuthenticated()<br/>useEffect(() =  {<br/>    const abortController = new AbortController()<br/>    const signal = abortController.signal<br/>    yearlyExpenses({year: year.getFullYear()},{t: jwt.token}, signal).then((data) =  {<br/>        if (data.error) {<br/>        setError(data.error)<br/>        }<br/>        setYearlyExpense(data)<br/>    })<br/>    return function cleanup(){<br/>        abortController.abort()<br/>    }<br/>}, [])</pre>
<p><span>With the data received from the backend and set in the state, we can render it in a Victory Bar chart. We can add the following code in the component view to render a customized bar chart with labels and only the <em>x</em> axis displayed.</span></p>
<p><kbd>mern-expense-tracker/client/report/YearlyBar.js</kbd><span>:</span></p>
<pre>const monthStrings = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']<br/> &lt;VictoryChart<br/>    theme={VictoryTheme.material}<br/>    domainPadding={10}<br/>    height={300}<br/>    width={450} <br/>     &lt;VictoryAxis/&gt; <br/>     &lt;VictoryBar<br/>        categories={{<br/>            x: monthStrings<br/>        }}<br/>        style={{ data: { fill: "#69f0ae", width: 20 }, labels: {fill: "#01579b"} }}<br/>        data={yearlyExpense.monthTot}<br/>        x={monthStrings['x']}<br/>        domain={{x: [0, 13]}}<br/>        labels={({ datum }) =  `$${datum.y}`}<br/>    /&gt; <br/> &lt;/VictoryChart&gt;</pre>
<p>The month values returned from the database are zero-based indices, so we define our own array of month name strings to map to these indices. To render the bar chart, we place a<span> </span><kbd>VictoryBar</kbd><span> </span>component in a<span> </span><kbd>VictoryChart</kbd><span> </span>component, giving us the flexibility to customize the bar chart wrapper, and also the <em>y</em> axis with a <kbd>VictoryAxis</kbd> component, which is added without any props so that a <em>y</em> axis is not displayed at all<span>.</span></p>
<p><span>We pass the data to <kbd>VictoryBar</kbd> and also define the categories for the <em>x</em> axis values using the month strings so that all months of the year are displayed on the chart, even if a corresponding total value does not exist yet. We render individual labels for each bar to show the total expense value for each month. To map the <em>x</em> axis value with the correct month string, we specify it in the <kbd>x</kbd> prop for the <kbd>VictoryBar</kbd> component.</span></p>
<p><span>This code plots and renders the bar chart against the data provided, with the monthly expense totals mapped for each month. In the next section, we will follow similar steps to add a pie chart to graphically display the average expenses per category in a given date range.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Average expenses per category in a pie chart</h1>
                </header>
            
            <article>
                
<p>We can render a pie chart showing how much users spend on average per expense category over a given period of time. This will help users visualize which categories consume more or less of their wealth over time. <span>The following screenshot shows how the pie chart will render with</span> <span>user expense data:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-886 image-border" src="assets/7d31b4ff-2eb5-45d6-85d8-105670706600.png" style="width:28.17em;height:19.50em;"/></p>
<p><span>We populate the pie chart with each category and its average expenditure value, showing the corresponding name and amount as labels. In the following sections, we will implement this feature by first adding a backend API that will return the average expenses per category over the given date range and in the format needed to render it in a Victory Pie chart. Then, we will add a React component that will retrieve this data from the backend and render it in the Victory Pie chart.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The average expenses by category API</h1>
                </header>
            
            <article>
                
<p><span>We will add an API to the backend that will return the average expenses incurred in each category over a given time period and in the data format needed to render the pie chart in the frontend. To implement this API, we will first declare a <kbd>GET</kbd> route, as shown in the following code.</span></p>
<p><kbd>mern-expense-tracker/server/routes/expense.routes.js</kbd><span>:</span></p>
<pre>router.route('/api/expenses/category/averages')<br/>  .get(authCtrl.requireSignin, expenseCtrl.averageCategories)</pre>
<p><span>A <kbd>GET</kbd> request to this route at </span><kbd>'/api/expenses/category/averages'</kbd><span> will first ensure that the requesting client is a signed-in user, and then it will invoke the </span><kbd>averageCategories</kbd><span> controller method. The request will also </span><span>take the values of the given date range in URL query parameters, which will be used in the <kbd>averageCategories</kbd></span><span> method to determine the dates of the first day and the last day of the provided range. </span><span>We will need these dates to specify the range for finding the matching expenses that were incurred in the specified date range and recorded by the authenticated user while aggregating the expense averages per category into the data format needed for the chart. The <kbd>averageCategories</kbd> method is defined in the following code.</span></p>
<p><kbd>mern-expense-tracker/server/controllers/expense.controller.js</kbd><span>:</span></p>
<pre>const averageCategories = async (req, res) =  {<br/>  const firstDay = new Date(req.query.firstDay)<br/>  const lastDay = new Date(req.query.lastDay)<br/><br/>  try {<br/>    let categoryMonthlyAvg = await Expense.aggregate([<br/>      { $match : { incurred_on : { $gte : firstDay, $lte: lastDay }, <br/>         recorded_by: mongoose.Types.ObjectId(req.auth._id)}},<br/>      { $group : { _id : {category: "$category"}, <br/>         totalSpent: {$sum: "$amount"} } },<br/>      { $group: { _id: "$_id.category", avgSpent: <br/>         { $avg: "$totalSpent"}}},<br/>      { $project: {x: '$_id', y: '$avgSpent'}}<br/>    ]).exec()<br/>    res.json({monthAVG:categoryMonthlyAvg})<br/>  } catch (err){<br/>    console.log(err)<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>We run an aggregation operation that finds the matching expenses, groups the expenses by category to first calculate the total and then the average, and returns an output containing the values in the format needed for the <em>y</em> and <em>x</em> values of the pie chart. The final result of the aggregation contains an array of objects, with each object containing an<span> </span><kbd>x</kbd><span> attribute </span>and<span> a </span><kbd>y</kbd><span> </span>attribute. The<span> </span><kbd>x</kbd><span> </span>attribute contains the category name as the value. The<span> </span><kbd>y</kbd><span> </span>attribute contains the corresponding average expense amount for that category. T<span>his final output array generated from the aggregation is sent back in the response to the requesting client.</span></p>
<p><span>We can use this API in the frontend with a fetch request. You can define a corresponding fetch method to make the request, similar to other API implementations. Then, the fetch method can be used in a React component to retrieve </span><span>and render this array of <kbd>x</kbd> and <kbd>y</kbd> values in a pie chart</span><span>. In the next section, we will discuss the implementation of this view to render a pie chart showing the average expenses incurred per category over a given date range.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The CategoryPie component</h1>
                </header>
            
            <article>
                
<p><span>We will implement a React component that calls the average expenses by category API to render the received array of average expenses incurred per category in a Victory Pie chart. </span></p>
<p><span>The API can be fetched either in a </span><kbd>useEffect</kbd><span> hook or when a button is clicked on. In the MERN Expense Tracker application, we render this pie chart in a React component called <kbd>CategoryPie</kbd>. When this component loads, we render a pie chart for the average expenses incurred per category in the given month. We also add two <kbd>DatePicker</kbd> components to allow users to select the desired date range and retrieve data for that range with a button click. In the following code, we retrieve the initial average expense data with a </span><kbd>useEffect</kbd><span> hook when the component loads.</span></p>
<p><kbd>mern-expense-tracker/client/report/CategoryPie.js</kbd><span>:</span></p>
<pre>const [error, setError] = useState('')<br/>const [expenses, setExpenses] = useState([])<br/>const jwt = auth.isAuthenticated()<br/>const date = new Date(), y = date.getFullYear(), m = date.getMonth()<br/>const [firstDay, setFirstDay] = useState(new Date(y, m, 1))<br/>const [lastDay, setLastDay] = useState(new Date(y, m + 1, 0))<br/>useEffect(() =  {<br/>        const abortController = new AbortController()<br/>        const signal = abortController.signal<br/>        averageCategories({firstDay: firstDay, lastDay: lastDay}, <br/>        {t: jwt.token}, signal).then((data) =  {<br/>          if (data.error) {<br/>            setError(data.error)<br/>          } else {<br/>            setExpenses(data)<br/>          }<br/>        })<br/>        return function cleanup(){<br/>          abortController.abort()<br/>        }<br/>    }, [])</pre>
<p><span>With the data received from the backend and set in state, we can render it in a Victory Pie chart. We can add the following code in the component view to render a customized pie chart with individual text labels for each slice and a center label for the chart.</span></p>
<p><kbd>mern-expense-tracker/client/report/CategoryPie.js</kbd><span>:</span></p>
<pre> &lt;div style={{width: 550, margin: 'auto'}}&gt;<br/>     &lt;svg viewBox="0 0 320 320"&gt;<br/>         &lt;VictoryPie standalone={false} data=<br/>            {expenses.monthAVG}    innerRadius={50} <br/>              theme={VictoryTheme.material} <br/>                labelRadius={({ innerRadius }) =  innerRadius + 14 }<br/>                labelComponent={ VictoryLabel angle={0} style={[{<br/>                    fontSize: '11px',<br/>                    fill: '#0f0f0f'<br/>                },<br/>                {<br/>                    fontSize: '10px',<br/>                    fill: '#013157'<br/>                }]} text={( {datum} ) =  `${datum.x}\n $${datum.y}`}/ }<br/>        /&gt;<br/>         &lt;VictoryLabel<br/>              textAnchor="middle"<br/>              style={{ fontSize: 14, fill: '#8b8b8b' }}<br/>              x={175} y={170}<br/>              text={`Spent \nper category`}<br/>         /&gt; <br/>     &lt;/svg&gt; <br/> &lt;/div&gt; </pre>
<p>To render the pie chart with a separate center label, we place a<span> </span><kbd>VictoryPie</kbd><span> </span>component in an<span> </span><kbd>svg</kbd><span> element</span>, giving us the flexibility to customize the pie chart wrapping and a separate circular label using a <kbd>VictoryLabel</kbd> outside the pie chart code.</p>
<p><span>We pass the data to <kbd>VictoryPie</kbd>, define customized labels for each slice, and make the pie chart standalone so that the center label can be placed over the chart. </span><span>This code plots and renders the pie chart against the data provided with the average expense displayed for each category. </span></p>
<p>We have added three different Victory charts to the application based on the user-recorded expense data, which was processed as needed and retrieved from the database in the backend. The MERN Expense Tracker application is complete with abilities that allow users to record their day-to-day expenses, and then visualize data patterns and expenditure habits extracted from the expense data recorded over time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we <span>extended the MERN skeleton application to </span>develop an expense tracking application with data visualization features. We designed an Expense model for recording expense details and implemented the full-stack <strong>CRUD</strong> (<strong>Create</strong>, <strong>Read</strong>, <strong>Update</strong>, <strong>Delete</strong>) functionalities that allowed signed-in users to record their day-to-day expenses, see a list of their expenses, and modify existing expense records.</p>
<p>We added data processing and visualization features that gave users an overview of their current expenses and also an idea of how much more or less they are spending per expense category. We also incorporated different types of charts to show users their expenditure patterns over various time ranges.</p>
<p>While implementing these features, we learned about some of the data processing options with the aggregation framework in MongoDB and also incorporated some of the customizable chart components from Victory. You can explore the aggregation framework and the Victory library further to incorporate more complex data visualization features in your own full-stack applications.</p>
<p>In the next chapter, we will explore even more advanced possibilities with MERN stack technologies as we build a media streaming application by extending the MERN skeleton.</p>


            </article>

            
        </section>
    </body></html>