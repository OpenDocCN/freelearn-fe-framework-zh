# 第八章：答案

在这里，你可以找到每章末尾提供的问题的答案：

# 第一章

所有问题都是开放式回答。

# 第二章

1.  **render**方法。

1.  **screen**对象。

1.  表示性组件。

1.  **debug**方法。

1.  这是一个开放式回答问题。

# 第三章

1.  **user-event**模块与用户在 DOM 上执行操作时发生的事件非常相似，例如**keydown**和**keyup**事件。

1.  MSW 允许你测试向 API 发起 HTTP 请求的组件。这是通过在请求到达互联网之前拦截请求，并返回可控制的模拟数据以进行测试来实现的。

1.  模拟函数是一个测试替身，用于进行断言。例如，我们可以使用模拟函数来验证当用户点击按钮时，方法是否被调用。

1.  风险在于，用模拟版本替换实际依赖项来测试组件不允许你测试与真实生产依赖项集成时的结果行为。

1.  这是一个开放式回答问题。

1.  当你期望元素存在于 DOM 的当前状态时，请使用`getBy*`查询。当元素的存在取决于使元素在 DOM 中出现的延迟的异步操作时，请使用`findBy*`查询。当你想验证元素不在 DOM 中时，请使用`queryBy*`查询。

# 第四章

1.  测试集成组件允许你在组件相互交互时通过验证生产行为来降低风险。使用隔离方法，我们会用假数据和响应替换真实依赖项，因此不能降低太多风险。此外，在许多情况下，使用集成测试方法，你可以用更少的测试覆盖更多的代码。

1.  你应该只在其他首选查询方法，如`getBy*`和`findBy*`无法用于选择元素时，才使用`data-testid`属性作为最后的手段。

1.  `act`方法确保你的测试行为更接近 React 更新浏览器 DOM 的方式。在需要手动进行组件更新的情况下使用`act`，例如解决 React 在测试中否则不会意识到的 Promise。React Testing Library 自动将组件包裹在`act`中，在大多数情况下，如点击事件，无需手动包裹所有更新组件的代码。

# 第五章

1.  与 Enzyme 或 ReactTestUtils 不同，React Testing Library 允许你编写避免实现细节并从最终用户视角模拟 DOM 交互的测试。

1.  在 Jest 的监视模式下运行测试允许你在快速添加新代码时了解回归何时发生。在监视模式下运行测试在使用 TDD 方法构建组件时也非常有益。

1.  当你需要用不同的值多次执行相同的测试时，请使用`each`方法。

# 第六章

所有问题都是开放式回答。

# 第七章

所有问题都是开放式回答。
