- en: Flex-Layout - Angular's Responsive Layout Engine
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flex-Layout - Angular的响应式布局引擎
- en: Flex-Layout is a TypeScript-based layout engine for Angular. It is an alternative
    to using Bootstrap's grid for laying out your components in your Angular projects.
    Flex-Layout evolved from AngularJS Material, a UI Component Framework, which was
    created by a team at Google led by Thomas Burleson—a well-known speaker at Angular
    conferences. I've not yet had the chance to attend an Angular conference, such
    as ng-conf or AngularMix, but I will. Maybe I'll see you there! There are many
    conferences on Angular spanning the globe—so you know that you're spending your
    time wisely studying a technology that is in high demand and is here to stay.
    I don't think I've said this to you yet, so I will now. Congratulations! Congratulations
    on selecting such a great technology to use in your projects, or maybe even as
    the cornerstone technology on which to build your career.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Flex-Layout是一个基于TypeScript的Angular布局引擎。它是在Angular项目中布置组件的替代方法，而不是使用Bootstrap的网格。Flex-Layout起源于AngularJS
    Material，这是一个由谷歌团队创建的UI组件框架，由Thomas Burleson领导，他是Angular大会上的知名演讲者。我还没有机会参加Angular大会，比如ng-conf或AngularMix，但我会的。也许我会在那里见到你！全球范围内有许多关于Angular的会议，所以你知道你在明智地学习一项需求量很高且将会持续存在的技术。我想我还没有对你说过这个，所以我现在会说。恭喜！恭喜你选择了这样一个伟大的技术来在你的项目中使用，甚至可能作为构建你职业生涯的基石技术。
- en: I can't help but get excited when I discover technologies that transform the
    way I create software for my clients and for myself, and now I get to share my
    excitement with you! So, pardon the slight tangent from the material at hand.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我发现可以改变我为客户和自己创建软件的方式的技术时，我忍不住感到兴奋，现在我可以和你分享我的兴奋！所以，请原谅我稍微偏离了手头的材料。
- en: OK, let's now take a look at what we'll be covering in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们来看看这一章我们将要涵盖的内容。
- en: Why this chapter was included in the book
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么这一章被包括在书中
- en: The four available techniques for the layout of our components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们组件布局的四种可用技术
- en: Why FlexBox CSS is probably the best option
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么FlexBox CSS可能是最佳选择
- en: What is Flex-Layout and why should you consider using it?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flex-Layout是什么，为什么你应该考虑使用它？
- en: Integrating Flex-Layout
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整合Flex-Layout
- en: The Flex-Layout API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flex-Layout API
- en: Design strategies when using Flex-Layout
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用Flex-Layout时的设计策略
- en: Associating our wireframes and components with the chapters and topics in this
    book
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的线框和组件与本书的章节和主题相关联
- en: Implementing our selected wireframes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现我们选择的线框
- en: Why this chapter was included in the book
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么这一章被包括在书中
- en: This is a very short chapter. In fact, it's probably the shortest in the book.
    However, I wanted to include it to give you options, particularly in terms of
    having an alternative technology to Bootstrap. Within reason, the more options
    you have, the better off you are. Additionally, some developers enjoy using Bootstrap,
    while others don't. I suspect that the reason for this is that Bootstrap's layout
    system is a grid. I don't know many developers who like being sandboxed into something
    like that. Don't get me wrong, I'm not knocking Bootstrap (Bootstrap is a great
    technology, and the name is even in the title of this book!), but Flex-Layout
    definitely feels like it is less rigid. Another reason that some developers would
    prefer working with something like Flex-Layout is that it feels more developer-friendly.
    For instance, instead of using `DIV` elements with special attributes, you use
    dedicated elements. This is sometimes referred to as taking a declarative approach, which
    sometimes simply feels more natural to developers. This may or may not make sense
    to you at the moment, but it will by the end of the chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简短的章节。事实上，这可能是本书中最短的章节。然而，我想包括它是为了给你提供选择，特别是在拥有替代技术来替代Bootstrap方面。在合理范围内，你拥有的选择越多，你就越好。此外，一些开发者喜欢使用Bootstrap，而另一些则不喜欢。我怀疑这是因为Bootstrap的布局系统是一个网格。我不知道有多少开发者喜欢被限制在这样的东西里。不要误会，我并不是在抨击Bootstrap（Bootstrap是一项很棒的技术，甚至在本书的标题中都有它的名字！），但Flex-Layout确实感觉更加灵活。一些开发者更愿意使用类似Flex-Layout这样的东西的另一个原因是它更加友好。例如，你使用专门的元素，而不是使用带有特殊属性的DIV元素。有时这被称为采用声明性方法，有时对开发者来说更自然。这可能现在对你来说有些难以理解，但在本章结束时你会明白的。
- en: The four available techniques for the layout of our components
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们组件布局的四种可用技术
- en: As web developers, and unless you're privileged to have a web designer on your
    team, we necessarily find ourselves needing to spend time with the layout of the
    components on our pages.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 作为网页开发者，除非你有幸在团队中有一个网页设计师，否则我们必须花时间来布局页面上的组件。
- en: As a quick aside, let's put some terminology in place for our discussions moving
    forward. I've used the terms *component* and *pages* interchangeably in the first
    few chapters, but it is now time to get more precise. As you know, Angular applications
    are SPAs by default and thus only have one page. I've mentioned a few times in
    the book that an Angular application is like a tree of components, and it all
    starts with the root component. Components are composable, which is to say that
    a component can be made of other components. What's the result of this? Well,
    we need a web page in order to have our root component rendered—and from that
    moment forth, our root component brings in other components, which, in turn, bring
    in yet other components. The end result is that our components recursively render
    themselves to give the illusion that we have multiple pages. Of course, we don't
    have multiple pages. We have a single web page, and the way in which we're architecting
    our application is that we have a main encompassing component for each *page* in
    our application. All that means is that when you see me mention *page*, instead
    of *component*, I'm really referring to the main component on that *page*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，让我们为我们未来的讨论确定一些术语。在前几章中，我已经交替使用了*组件*和*页面*这两个术语，但现在是时候更加精确了。你知道，Angular应用默认是单页应用，因此只有一个页面。我在书中已经多次提到，Angular应用就像一个组件树，一切都始于根组件。组件是可组合的，也就是说一个组件可以由其他组件组成。这会导致什么结果呢？嗯，我们需要一个网页来渲染我们的根组件，从那一刻起，我们的根组件引入其他组件，这些组件又引入其他组件。最终的结果是，我们的组件递归地渲染自己，以产生我们有多个页面的错觉。当然，我们并没有多个页面。我们只有一个网页，我们的应用程序的架构方式是每个*页面*都有一个主要的包含组件。这意味着当你看到我提到*页面*时，实际上是指该*页面*上的主要组件，而不是*组件*。
- en: Take a look back at the code we wrote for [Chapter 4](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml),
    *Routing*, and it should all start to be making sense to you. Specifically, a
    given URL maps to a component. With more traditional web applications that are
    not SPAs, the URLs are mapped to views, or "pages". OK, let's return our focus
    to considerations and available options as to layout strategies.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下我们在[第4章](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml) *路由*中编写的代码，现在应该开始对你有意义了。具体来说，给定的URL映射到一个组件。对于不是单页应用的传统Web应用程序，URL映射到视图或“页面”。好的，让我们把注意力转回到布局策略的考虑和可用选项。
- en: 'Laying out the components in our application includes the following four necessities:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中布置组件包括以下四个必要条件：
- en: Laying out our components within their containers (that is, parent component
    and child component(s))
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中布置我们的组件（即父组件和子组件）
- en: Sizing our components
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整我们的组件大小
- en: Positioning our components relative to each other
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的组件相对放置在一起
- en: Styling the components
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的样式
- en: 'I don''t profess to be an expert in styling or CSS. I can barely color coordinate
    the clothes I wear. While we have seen some CSS in [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml),
    *Bootstrap – Grid Layout and Components*, in our SASS crash course (and we''ll
    certainly see more CSS in the chapters ahead), this is not a book about design
    and styling. Packt Publishing offers a few excellent books on CSS. In this chapter,
    we''ll only concern ourselves with laying out our components within their containers.
    To that end, we have four techniques that we can choose from: tables, float and
    clear, FlexBox CSS, and CSS Grid.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不自诩是样式或CSS方面的专家。我几乎无法搭配我穿的衣服。虽然我们在[第3章](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml)中看到了一些CSS，*Bootstrap
    - 网格布局和组件*，在我们的SASS速成课程中（在接下来的章节中我们肯定会看到更多的CSS），但这不是一本关于设计和样式的书。Packt Publishing出版了一些关于CSS的优秀书籍。在本章中，我们只关注在容器中布局我们的组件。为此，我们有四种可以选择的技术：表格、浮动和清除、FlexBox
    CSS和CSS Grid。
- en: Yes, of course, Flex-Layout is also an option for us because we've chosen Angular
    (big smile). However, the four layout techniques I've listed apply to web development
    in general—regardless of a frontend framework, library, or just plain old HTML
    and CSS. As we have seen in [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml),
    *Bootstrap – Grid Layout and Components*, Bootstrap is a CSS framework built on
    top of FlexBox CSS, and so also applies to web development in general.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，当然，Flex-Layout也是我们的选择，因为我们选择了Angular（微笑）。然而，我列出的四种布局技术适用于网页开发一般情况——无论是前端框架、库，还是普通的HTML和CSS。正如我们在[第3章](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml)中所看到的，*Bootstrap
    - 网格布局和组件*，Bootstrap是一个建立在FlexBox CSS之上的CSS框架，因此也适用于网页开发一般情况。
- en: Getting back to our discussion of layout techniques, let's contrast the four
    that are generally available to web developers, and see whether there is a clear
    winner. From there, we'll move on to the nitty-gritty of this chapter and take
    a look at what Flex-Layout is and why we should use it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们对布局技术的讨论，让我们对比一下通常可用于网页开发的四种技术，看看是否有一个明显的赢家。从那里，我们将继续本章的细节，看看Flex-Layout是什么，以及为什么我们应该使用它。
- en: Table
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表格
- en: Every web developer (born before the year 2000) has heard of and has likely
    used the `TABLE` tag. Where did this come from? Well, a long time ago, in a galaxy
    far, far away, a team of alien programmers invented HTML table tags. These aliens
    soon grew weary of using this layout technique, so they banned its use and banished
    all the web development books that taught table tags their planet. Meanwhile,
    somewhere on Earth, circa 1994, a web developer who was frustrated with layout
    issues was hit on the head with what seemed like a technical book. Its markings
    appeared to be some form of hieroglyphics—all indecipherable to the young techie,
    except the distinctly familiar markup language. The first chapter's heading was
    simply, `<TABLE>`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个网页开发者（2000年之前出生）都听说过并可能使用过`TABLE`标签。这是从哪里来的？嗯，很久以前，在一个遥远的星球上，一群外星程序员发明了HTML表格标签。这些外星人很快厌倦了使用这种布局技术，所以他们禁止了它的使用，并放逐了所有教授表格标签的网页开发书籍。与此同时，在地球上的某个地方，大约在1994年，一位对布局问题感到沮丧的网页开发者被一本看起来像技术书籍的东西砸到了头上。它的标记似乎是某种形式的象形文字，对年轻的技术人员来说都是无法理解的，除了那个熟悉的标记语言。第一章的标题只是`<TABLE>`。
- en: 'Kidding aside, while tables were tremendously helpful in the early days of
    web development, they are now an ancient layout technique that is often frowned
    upon. Here are some reasons why tables are no longer the default method for laying
    out page elements:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 开玩笑的是，虽然表格在网页开发的早期阶段非常有帮助，但现在它们是一种古老的布局技术，经常受到指责。以下是一些表格不再是布局页面元素的默认方法的原因：
- en: They tend to clutter up the markup in our web pages and components
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们往往会在我们的网页和组件中混乱标记
- en: They are a maintenance nightmare, since moving things around is extremely tedious
    using tables
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是维护的噩梦，因为使用表格移动东西非常乏味
- en: They are rigid—more so than a grid, to the extent that we sometimes had to resort
    to having nested tables, which, of course, exacerbate the first two bullet points
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是刚性的——比网格更加刚性，以至于我们有时不得不诉诸于嵌套表格，这当然加剧了前两个要点
- en: However, despite these negatives, using tables is still a valid option and is
    why I've listed it here as one of the main four.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管存在这些负面因素，使用表格仍然是一个有效的选择，这就是为什么我在这里将其列为主要的四个选项之一。
- en: Positioning using float, and clear
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用浮动和清除进行定位
- en: CSS has some pretty cool features. Among my favorites were a couple of its declarations
    that deal with positioning. Specifically, the two CSS declarations I'm referring
    to are float and clear. These declarations can be applied to block elements, such
    as `<div>`, as well as inline elements, such as `<img>`. Block-level elements
    are elements that occupy 100% of the parent element's space, whereas inline elements
    are happy to share the horizontal space they reside within their parent element.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: CSS有一些非常酷的功能。我最喜欢的是其中一些处理定位的声明。具体来说，我指的是两个CSS声明，即浮动和清除。这些声明可以应用于块级元素，如`<div>`，以及内联元素，如`<img>`。块级元素是占据父元素空间的元素，而内联元素乐意分享它们所在父元素的水平空间。
- en: The notion of *floating* an element (such as a `<div>`) is that it relinquishes
    its demand to take up the entire horizontal line. In short, it collapses its space
    to only consume what it needs—instead of being greedy with the horizontal real
    estate available—and other elements can now reside beside it, instead of being
    pushed below it. This is true for when the element being floated does not take
    up the entire space. Elements that are floated beside it, when there is not enough
    room horizontally, will wrap down to the next line. With that being said, you
    can start to see how you can achieve some degree of responsive design by using
    the CSS float declaration to float elements.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*浮动*元素（如`<div>`）的概念是，它放弃了占据整个水平线的需求。简而言之，它将其空间折叠为仅消耗所需的空间，而不是贪婪地利用水平空间，其他元素现在可以驻留在其旁边，而不是被推到下面。当被浮动的元素不占据整个空间时，旁边浮动的元素在水平空间不足时会换行到下一行。话虽如此，您可以开始看到如何通过使用CSS浮动声明来浮动元素来实现一定程度的响应式设计。'
- en: The purpose of *clearing* is to control how the float takes effect. When you
    use the CSS declaration of clear on an element, you are basically instructing
    that element to not float up to the higher horizontal space—even if there is space
    to float up in. Remember, floating elements means that the element will take the
    highest vertical space it can take, provided that there is room, and that its
    adjoining elements have also been floated (especially for block-level elements
    that want to consume the entire horizontal space on their own). When there isn't
    sufficient space, it'll wrap down to the next highest available spot, and if there
    is enough space, it'll float up to be beside the other element. The exception
    to this is if you apply the clear declaration to it in its style or class, in
    which it will always behave as it wraps down—even when there's room higher up.
    Are we good on this? Cool.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*清除*的目的是控制浮动的效果。当您在元素上使用CSS声明清除时，基本上是在指示该元素不要浮动到更高的水平空间上，即使有空间可以浮动。请记住，浮动元素意味着元素将占据它可以占据的最高垂直空间，前提是有空间，并且它的相邻元素也已经被浮动（特别是对于希望独占整个水平空间的块级元素）。当没有足够的空间时，它会换行到下一个可用的位置，如果有足够的空间，它会浮动到其他元素的旁边。唯一的例外是，如果您在其样式或类中应用了清除声明，它将始终表现为换行，即使上方有空间。我们对此了解吗？很好。'
- en: Positioning elements via *float* and *clear* definitely works, and you can create
    some fairly sophisticated layouts by using them. But their effects may not always
    be what you want to see happen, as the viewport size gets smaller. In the world
    of responsive layout, having as much control as possible over your layout is paramount,
    and being limited to just floating and clearing can often make it a bit of a challenge
    to have your layout rearrange itself, given a wide array of viewport sizes—at
    least with as much precision as the next two options give you. Another thing that
    you need to get used to with floating elements is that you need to reorder the
    listing of elements on your page, depending on whether you're floating the elements
    to the left or to the right.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过*浮动*和*清除*定位元素确实有效，您可以使用它们创建一些相当复杂的布局。但随着视口尺寸变小，它们的效果可能并不总是您想要看到的。在响应式布局的世界中，尽可能多地控制布局至关重要，而仅限于浮动和清除通常会使布局重新排列成为一项挑战，尤其是在各种视口尺寸下，至少与下面两个选项给予您的精度一样多。另一件需要习惯的事情是，浮动元素需要根据您是将元素向左还是向右浮动来重新排列页面上的元素列表。
- en: The reason I took a little more time here on *float* and *clear* is that it's
    an area where too many developers don't take the time to let it sink in. The takeaway
    point here is that you can get very far with just this layout technique, and,
    depending on the nature of the project and its requirements, it may be what the
    doctor ordered. Of course, there's more to say about *float* and *clear* in terms
    of design strategies, but that is a whole other book. As always, I recommend playing
    around with this layout technique/strategy.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我在*浮动*和*清除*上花了更多时间的原因是，有太多开发人员没有花时间让它深入人心。这里的要点是，您可以仅使用这种布局技术走得很远，根据项目的性质和要求，这可能是医生开的处方。当然，关于*浮动*和*清除*的设计策略还有更多要说，但那是另一本书。像往常一样，我建议尝试使用这种布局技术/策略。
- en: FlexBox CSS
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FlexBox CSS
- en: FlexBox CSS is a layout technique that came into being with CSS3\. It's a very
    powerful thing, and this is why other frameworks, such as Bootstrap and Flex-Layout,
    are built on top of it. But the best thing about FlexBox CSS is that it's understood
    by nearly all of the browsers in general use today. With FlexBox we get the best
    of both worlds — tremendous browser outreach and admirable layout flexibility
    for your application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: FlexBox CSS是一个随着CSS3而出现的布局技术。这是一个非常强大的东西，这也是为什么其他框架，比如Bootstrap和Flex-Layout，都是建立在它之上的。但FlexBox
    CSS最好的地方在于，它几乎被所有通用的浏览器所理解。使用FlexBox，我们既可以获得巨大的浏览器覆盖范围，又可以为应用程序提供令人钦佩的布局灵活性。
- en: 'I won''t say much more than this for FlexBox CSS because chances are that you
    will not use it—at least not directly. There are three reasons why I can probably
    safely make that assumption:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会再多说FlexBox CSS，因为很可能你不会直接使用它。我可以假设这样做的原因有三个：
- en: Bootstrap is built on top of FlexBox CSS, and you're probably more likely to
    use the Bootstrap grid as opposed to using FlexBox CSS directly
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bootstrap是建立在FlexBox CSS之上的，你可能更有可能使用Bootstrap网格而不是直接使用FlexBox CSS
- en: The same thing holds true with Flex-Layout, since it basically wraps FlexBox
    CSS in a nice API, making it easier to use
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Flex-Layout也是一样的，因为它基本上是在FlexBox CSS的基础上包装了一个很好的API，使其更容易使用
- en: CSS Grid
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS Grid
- en: CSS Grid FlexBox CSS is a layout technique that comes into being with CSS4\.
    It's also a very powerful thing, and it makes some things easier to do than with
    FlexBox CSS, but, at the same time, some things are harder to implement than doing
    it with FlexBox CSS. Being a relatively new addition to the world of CSS, it is
    not as widely integrated into browsers that are generally in use.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: CSS Grid FlexBox CSS是一个随着CSS4而出现的布局技术。它也是一个非常强大的东西，它使一些事情比使用FlexBox CSS更容易，但与此同时，有些事情比使用FlexBox
    CSS更难实现。作为CSS世界相对较新的补充，它并没有被广泛整合到通常使用的浏览器中。
- en: Why FlexBox CSS is probably the best option
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么FlexBox CSS可能是最佳选择
- en: 'After reading the few preceding paragraphs in the previous section, who the
    winner is should come as no surprise to you. It''s definitely FlexBox CSS. Let''s
    summarize this with a list of factors that should be considered when selecting
    a layout option:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读了前面几段的内容后，谁是赢家对你来说应该不会有什么意外。显然是FlexBox CSS。让我们用一个因素列表来总结选择布局选项时应该考虑的因素：
- en: '**Browser reach:** As developers, we care deeply about the reach of our web
    applications.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器覆盖范围：作为开发者，我们非常关心我们的Web应用的覆盖范围。
- en: '**Ease of use**: This one is a bit of a stretch, I know—both Bootstrap''s grid
    and Flex-Layout are built on top of it, making it easier to use. But once you
    get your head around FlexBox CSS, most layout requirements can be handled fairly
    easily.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易用性：我知道这有点牵强，因为Bootstrap的网格和Flex-Layout都是建立在它之上的，使其更容易使用。但一旦你掌握了FlexBox CSS，大多数布局要求都可以比较容易地处理。
- en: '**Ease of maintenance**: This one follows from the previous bullet point. But
    something that most developers are surprised by is the fact that, during the lifespan
    of a typical application, 20% of the time that developers are involved with it
    is in building it, whereas 80% of developer time with the application is in maintaining
    it—and so this last bullet point cannot be overemphasized.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于维护：这个因素是从前一个要点中得出的。但大多数开发者感到惊讶的是，在典型应用的生命周期中，开发者参与其中的时间有20%是在构建它，而80%的时间是在维护它，所以最后一个要点不能过分强调。
- en: Again, we're not considering Bootstrap and Flex-Layout to be layout techniques
    because they are tools/frameworks superimposed on top of the underlying layout
    techniques.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们不认为Bootstrap和Flex-Layout是布局技术，因为它们是在基础布局技术之上的工具/框架。
- en: What is Flex-Layout and why should you use it?
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Flex-Layout，为什么应该使用它？
- en: We covered why the best option for us from the four for laying out our components
    is FlexBox CSS, but this is a chapter on Flex-Layout, and so I now need to introduce
    it to you. So let's do that now, and then I'll list a few reasons why you should
    consider using it instead of using FlexBox CSS directly (again since Flex-Layout
    is built on top of FlexBox CSS).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了为什么对于我们来说，布局组件的最佳选项是FlexBox CSS，但这是关于Flex-Layout的一章，所以我现在需要向你介绍它。所以让我们现在做到这一点，然后我将列出一些原因，为什么你应该考虑使用它，而不是直接使用FlexBox
    CSS（再次强调，因为Flex-Layout是建立在FlexBox CSS之上的）。
- en: 'Flex-Layout''s home can be found here: [https://www.github.com/angular/flex-layout](https://www.github.com/angular/flex-layout).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Flex-Layout的主页可以在这里找到：[https://www.github.com/angular/flex-layout](https://www.github.com/angular/flex-layout)。
- en: 'Here are a few bullet points detailing what Flex-Layout is:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于Flex-Layout的要点：
- en: It's a standalone library.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个独立的库。
- en: It's Angular-native (and is a TypeScript implementation).
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是Angular原生的（并且是TypeScript实现）。
- en: It's integrated with the CLI.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与CLI集成。
- en: 'It has static APIs, which are for the containers, and other static APIs, which
    are for the container children. These APIs have the following characteristics:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有静态API，用于容器，以及其他静态API，用于容器子元素。这些API具有以下特点：
- en: They are declarative
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是声明性的
- en: They support data binding and change detection
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们支持数据绑定和变化检测
- en: They are directives used in HTML
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是在HTML中使用的指令
- en: There's no CSS for us to write since it's dynamically injected for us
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于我们来说，没有CSS需要编写，因为它会动态地为我们注入
- en: 'Some advantages of using it instead of FlexBox CSS, and following from the
    preceding bullet points, are as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与FlexBox CSS相比，使用它的一些优势，以及从前面的要点中可以得出以下结论：
- en: You don't have to be a CSS expert (in fact, as you'll soon see, we won't even
    be using a CSS style sheet)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不必是CSS专家（事实上，正如你很快会看到的，我们甚至不会使用CSS样式表）
- en: It fits Angular perfectly (in fact, it's Angular-native)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它完美适配Angular（事实上，它是Angular原生的）
- en: There are APIs which helps developers in faster application development
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有API可以帮助开发人员更快地开发应用程序
- en: Another nice thing to know is that since Flex-Layout is a standalone (that is,
    self-contained) library, it can be used with or without Angular Material. We'll
    be taking a look at Angular Material in [Chapter 9](1a222c0e-7130-4ac2-959d-ae9d6cc1ca7d.xhtml),
    *Working with Angular Material*, where we'll be utilizing a couple of its components.
    Again, these components can be used as replacements for, or in conjunction with,
    ng-Bootstrap. We'll be taking a look at ng-Bootstrap in [Chapter 8](784689d5-c12c-4a1d-b2a4-dfcdbe7e6d38.xhtml), *Working
    with NG Bootstrap.*
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要知道的好处是，由于Flex-Layout是一个独立的（即自包含的）库，它可以与或无需Angular Material一起使用。我们将在[第9章](1a222c0e-7130-4ac2-959d-ae9d6cc1ca7d.xhtml)中查看Angular
    Material，那里我们将使用它的一些组件。同样，这些组件可以用作ng-Bootstrap的替代品，或与ng-Bootstrap一起使用。我们将在[第8章](784689d5-c12c-4a1d-b2a4-dfcdbe7e6d38.xhtml)中查看ng-Bootstrap，*使用NG
    Bootstrap*。
- en: I've mentioned in the preceding bullet list that Flex-Layout has static APIs.
    What I have not mentioned is that it also has responsive APIs. We'll be covering
    Flex-Layout's static APIs in an upcoming section, The *Flex-Layout API*, but I
    leave the reading of its responsive API to you (I have included links to the Flex-Layout
    documentation at the end of that section).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我在前面的要点列表中提到了Flex-Layout具有静态API。我没有提到的是它还有响应式API。我们将在接下来的章节中介绍Flex-Layout的静态API，但我把它的响应式API留给你阅读（我在该章节的末尾包含了Flex-Layout文档的链接）。
- en: However, I would like to say a quick word on responsive APIs. Responsive APIs
    are there so that you can create an adaptive UX (that is, an adaptive user experience
    to have a slightly different layout for various viewport sizes). In order to do
    that, you need to also leverage MediaQueries—not only FlexBox CSS. Now, yes, this
    is a chapter on Flex-Layout, so why am I mentioning that you need to leverage
    MediaQueries in conjunction with FlexBox CSS? I mention this to point out the
    fact that the Flex-Layout team has us covered in this space (that is, responsive
    UX, not just layout) as well. And they have done this by providing extensions
    to the static APIs to abstract the MediaQueries away from us. This means that
    we don't have to handcraft tedious rule sets—and since they created extensions
    on the static APIs, we can leverage what we learn there and apply the extensions
    to create the adaptive UX right in our HTML. It's really quite brilliant!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我想简要谈一下响应式API。响应式API是为了让您创建自适应的UX（即，为不同的视口大小创建略有不同的布局）。为了做到这一点，您还需要利用MediaQueries，而不仅仅是FlexBox
    CSS。是的，这是一章关于Flex-Layout，那么为什么我要提到您需要结合FlexBox CSS利用MediaQueries呢？我提到这一点是为了指出Flex-Layout团队在这个领域（即，响应式UX，而不仅仅是布局）已经为我们做好了准备。他们通过为静态API提供扩展来将MediaQueries抽象化，这意味着我们不必手工编写繁琐的规则集——因为他们在静态API上创建了扩展，我们可以利用在那里学到的知识并将扩展应用于在我们的HTML中创建自适应的UX。这真的非常聪明！
- en: Integrating Flex-Layout
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成Flex-Layout
- en: The Flex-Layout library comes as one self-contained module, and so we only need
    to import it in one place. It is more straightforward to integrate than routing
    was in the previous chapter.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Flex-Layout库作为一个自包含的模块，所以我们只需要在一个地方导入它。与上一章的路由集成更加直接。
- en: 'Now let''s add Flex-Layout to our project. The first thing we need to do is
    to install the library. In your Terminal, navigate to the root folder of the `realtycarousel`
    application that we started creating in [Chapter 4](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml),
    *Routing*, and type the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将Flex-Layout添加到我们的项目中。我们需要做的第一件事是安装该库。在您的终端中，导航到我们在[第4章](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml)中开始创建的`realtycarousel`应用程序的根文件夹，并输入以下内容：
- en: '[PRE0]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will install the library, so we can later import it into any of our Angular
    applications.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装该库，这样我们就可以在任何一个Angular应用程序中导入它。
- en: 'Note: If your CLI outputs a warning, such as something along the lines of `"``@angular/flex-layout@5.0.0-beta.14`
    requires a peer of `@angular/cdk@^5.0.0` but none is installed. You must install
    peer dependencies yourself" (which is what happened to me), just install it the
    same way as anything else, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您的CLI输出警告，比如类似于`"``@angular/flex-layout@5.0.0-beta.14`需要`@angular/cdk@^5.0.0`的对等依赖，但没有安装。您必须自己安装对等依赖"（这就是发生在我身上的事情），只需像其他任何东西一样安装即可，如下所示：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we need to import it into our `RealtyCarousel` application. To do this,
    we need to add a couple of things to our application''s main module. Open your
    `RealtyCarousel` project in your IDE, and then open the `app.module.ts` file from
    within the `src/app` directory. At the top of the file within our other import
    statements, add the following import statement:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将其导入到我们的`RealtyCarousel`应用程序中。为此，我们需要向应用程序的主模块添加一些内容。在IDE中打开您的`RealtyCarousel`项目，然后从`src/app`目录中打开`app.module.ts`文件。在文件顶部的其他导入语句中，添加以下导入语句：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: (Just underneath the `import` statement , that we added for the `RouterModule`
    will be just fine.)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: （在我们为`RouterModule`添加的`import`语句的下面就可以了。）
- en: 'We also need to include the `FlexLayoutModule` in the imports array within
    the `@NgModule` section, like this: (just underneath the statement `RouterModule.forRoot(appRoutes)`, we
    had added for the `RouterModule` would be just fine.)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`@NgModule`部分的导入数组中包含`FlexLayoutModule`，就像这样：（就在`RouterModule.forRoot(appRoutes)`语句下面，我们为`RouterModule`添加的那样。）
- en: With that, we're done. We now have the power of Flex-Layout at our disposal.
    Virtually anything else we'll do with Flex-Layout gets done in our HTML.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止。我们现在可以利用Flex-Layout的功能。几乎我们在Flex-Layout中做的任何其他事情都是在我们的HTML中完成的。
- en: Let's take a look at the Flex-Layout API next—which is how we'll be leveraging
    Flex-Layout in our pages (that is, component templates).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来看一下Flex-Layout API，这是我们将在页面中利用Flex-Layout的方式（即组件模板）。
- en: The Flex-Layout API
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flex-Layout API
- en: What makes Flex-Layout easier to work with than FlexBox CSS is the fact that
    it has APIs that abstract the CSS away for us. We still need CSS (remember, browsers
    only understand HTML, JavaScript, and CSS), but what I mean by the face that CSS
    will be abstracted away for us is that when our application is transpiled, Angular
    Flex-Layout will inject the CSS for us. As I've mentioned, Flex-Layout doesn't
    even have a CSS style sheet, and we don't have to write any CSS.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与FlexBox CSS相比，Flex-Layout更容易使用的原因是它具有抽象出CSS的API。我们仍然需要CSS（记住，浏览器只能理解HTML、JavaScript和CSS），但我所说的CSS将被抽象化是指当我们的应用程序被转译时，Angular
    Flex-Layout会为我们注入CSS。正如我所提到的，Flex-Layout甚至没有CSS样式表，我们也不需要编写任何CSS。
- en: 'The following is a table of the Flex-Layout APIs, detailing what they are used
    for, together with a quick syntactical example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Flex-Layout API的表格，详细说明了它们的用途，以及一个快速的语法示例：
- en: '| **Type** | **API** | **Used for** | **Example** |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **API** | **用于** | **示例** |'
- en: '| Static (for container) | `fxLayout` | Defines the direction of the flow (that
    is, flex-direction). | `<div fxLayout="row" fxLayout.xs="column">` `</div>` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 静态（对于容器） | `fxLayout` | 定义流的方向（即flex-direction）。 | `<div fxLayout="row" fxLayout.xs="column">`
    `</div>` |'
- en: '| Static (for container) | `fxLayoutAlign` | Defines the alignment of the elements.
    | `<div fxLayoutAlign="start stretch">` `</div>` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 静态（对于容器） | `fxLayoutAlign` | 定义元素的对齐方式。 | `<div fxLayoutAlign="start stretch">`
    `</div>` |'
- en: '| Static (for container) | `fxLayoutWrap` | Defines whether the elements should
    wrap. | `<div fxLayoutWrap>` `</div>` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 静态（对于容器） | `fxLayoutWrap` | 定义元素是否应该换行。 | `<div fxLayoutWrap>` `</div>` |'
- en: '| Static (for container) | `fxLayoutGap` | Sets the spacing between elements.
    | `<div fxLayoutGap="15px">` `</div>` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 静态（对于容器） | `fxLayoutGap` | 设置元素之间的间距。 | `<div fxLayoutGap="15px">` `</div>`
    |'
- en: '| Static (for children) | `fxFlex` | Specifies resizing of the host element
    within its container flow layout. | `<div fxFlex="1 2 calc(15em + 20px)">` `</div>`
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 静态（对于子元素） | `fxFlex` | 指定在其容器流布局中调整宿主元素的大小。 | `<div fxFlex="1 2 calc(15em
    + 20px)">` `</div>` |'
- en: '| Static (for children) | `fxFlexOrder` | Defines the order of a FlexBox item.
    | `<div fxFlexOrder="2">` `</div>` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 静态（对于子元素） | `fxFlexOrder` | 定义FlexBox项目的顺序。 | `<div fxFlexOrder="2">` `</div>`
    |'
- en: '| Static (for children) | `fxFlexOffset` | Offsets a FlexBox item within its
    container flow layout. | `<div fxFlexOffset="20px">` `</div>` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 静态（对于子元素） | `fxFlexOffset` | 在其容器流布局中偏移FlexBox项目。 | `<div fxFlexOffset="20px">`
    `</div>` |'
- en: '| Static (for children) | `fxFlexAlign` | Similar to `fxLayoutAlign`, but for
    a specific FlexBox item (not all). | `<div fxFlexAlign="center">` `</div>` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 静态（对于子元素） | `fxFlexAlign` | 类似于`fxLayoutAlign`，但适用于特定的FlexBox项目（而不是全部）。 |
    `<div fxFlexAlign="center">` `</div>` |'
- en: '| Static (for children) | `fxFlexFill` | Maximizes dimensions of the element
    to that of its parent container. | `<div fxFlexFill>` `</div>` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 静态（对于子元素） | `fxFlexFill` | 将元素的尺寸最大化到其父容器的尺寸。 | `<div fxFlexFill>` `</div>`
    |'
- en: These APIs have options, and defaults. For instance, the `fxLayout` API defaults
    to row, but also has column, as well as row-reverse, and column-reverse.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些API有选项和默认值。例如，`fxLayout` API默认为行，但也有列，以及行反转和列反转。
- en: Also, the `.xs` in the example for the `fxLayout` API has a similar notion as
    the Bootstrap grid in that it provides a way to allow for different viewport sizes.
    So, in the first example in the preceding table, the layout for regular viewports
    will be that elements flow from left to right within the row, and, for small viewports,
    the elements will be stacked in a single column.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，在`fxLayout` API的示例中，`.xs`与Bootstrap网格有类似的概念，它提供了一种允许不同视口尺寸的方式。因此，在前面表格中的第一个示例中，常规视口的布局将使元素在行内从左到右流动，而对于小视口，元素将堆叠在单列中。
- en: Another interesting thing to point out in the examples in the preceding table
    is where there is a calculation made in the `fxFlex` API. This is a little like
    what we looked at in the SASS crash course in [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml), *Bootstrap –
    Grid Layout and Components*, although SASS was compiled by Ruby, whereas Flex-Layout
    is compiled by TypeScript.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面表格中的示例中，还有一个有趣的地方是在`fxFlex` API中进行了计算。这有点像我们在[第3章](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml)的SASS快速入门中所看到的，*Bootstrap
    - 网格布局和组件*，尽管SASS是由Ruby编译的，而Flex-Layout是由TypeScript编译的。
- en: I won't enumerate all the options here because you didn't purchase this book
    to read documentation, any more than I wrote this book to just copy documentation.
    Of course, I will point you to the place to look up the documentation for Flex-Layout.
    You can find it at their official website: [https://github.com/angular/flex-layout/wiki/API-Documentation](https://github.com/angular/flex-layout/wiki/API-Documentation).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里列举所有的选项，因为你购买这本书不是为了阅读文档，就像我写这本书不只是为了复制文档一样。当然，我会指引你去查找Flex-Layout的文档。你可以在他们的官方网站找到：[https://github.com/angular/flex-layout/wiki/API-Documentation](https://github.com/angular/flex-layout/wiki/API-Documentation)。
- en: Fortunately, the Flex-Layout team has done a fantastic job with the documentation.
    Their wiki also includes several live layout demos that you can take a look at.
    Here is the direct link: [https://tburleson-layouts-demos.firebaseapp.com/#/docs](https://tburleson-layouts-demos.firebaseapp.com/#/docs).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Flex-Layout团队在文档方面做得非常出色。他们的维基还包括了几个实时布局演示，你可以看一看。这是直接链接：[https://tburleson-layouts-demos.firebaseapp.com/#/docs](https://tburleson-layouts-demos.firebaseapp.com/#/docs)。
- en: Design strategies when using FlexBox
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FlexBox时的设计策略
- en: Since Flex-Layout is more of a flowing kind of thing, as opposed to being a
    grid, it's often easier to think of vertical sections of your application and
    assign them their own container. This is because the sections within your containers
    will automatically wrap downward as the viewport size gets smaller. Elements within
    the container should be thought of as belonging together. Contrasting this with
    a grid system, such as Bootstrap, the thinking is different; the cells in the
    grid mark the physical boundaries of the elements. The elements within the cells
    don't automatically wrap because when you are thinking of the design/layout, you
    insert elements in specific cells. Another way to conceptualize the differences
    between a grid and FlexBox is to think of a grid as being two-dimensional (that
    is, rows and columns—much like a spreadsheet), and FlexBox as being one-dimensional
    (in that it either flows horizontally, or it flows vertically).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Flex-Layout更多地是一种流动的方式，而不是网格，因此通常更容易考虑应用程序的垂直部分并为它们分配自己的容器。这是因为容器内的部分会随着视口尺寸变小而自动向下包裹。容器内的元素应该被视为属于一起。与Bootstrap等网格系统相比，思维方式是不同的；网格中的单元格标记了元素的物理边界。单元格内的元素不会自动换行，因为在设计/布局时，您会将元素插入特定的单元格中。另一种概念化网格和FlexBox之间的差异的方法是将网格视为二维的（即行和列
    - 就像电子表格一样），将FlexBox视为一维的（即它要么水平流动，要么垂直流动）。
- en: Once you have your vertical containers in mind, you can then think about sub-containers
    flowing from left to right, and the sub-container then wrapping downward as the
    viewport size gets smaller—and when it does wrap downward, all the elements with
    that sub-container go along for the ride. Bear in mind, when I mention sub-containers,
    that I'm referring to the fact that FlexBox containers can be nested—which is
    what gives much of the layout control to the developer. When laying out your page,
    think of the flows as *outside-in*. This is to say that you should break up your
    page into large vertical sections—such as a header, main body, and footer—and
    then dive into each of the sections to add your sub-containers, which will flow
    from left to right.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了垂直容器的想法，您就可以考虑从左到右流动的子容器，然后随着视口尺寸变小，子容器向下包裹 - 当它向下包裹时，所有具有该子容器的元素都会一起移动。请记住，当我提到子容器时，我指的是FlexBox容器可以嵌套
    - 这就是为什么开发人员可以控制布局的大部分原因。在布局页面时，将流程视为“从外到内”。这意味着您应该将页面分成大的垂直部分 - 例如标题、主体和页脚 -
    然后深入到每个部分中添加子容器，这些子容器将从左到右流动。
- en: It's difficult to describe *flow* in words, and so the best thing to do, as
    always, is to experiment with your containers and elements and study the behavior
    of their flow as you adjust your viewport size. This chapter includes code listings
    for three of our component templates (that is, *pages*) as well as their wireframes.
    You'll see exactly how I've designed the layouts for these component templates.
    Along the way, I'll also tell you why I've made some of the decisions I've made.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 很难用言语描述“流动”，因此像往常一样，最好的方法是尝试使用您的容器和元素，并研究随着视口尺寸调整它们的流动行为。本章包括三个组件模板（即*页面）的代码清单，以及它们的线框图。您将看到我如何为这些组件模板设计布局。在此过程中，我还会告诉您我为什么做出了一些决定。
- en: Associating our components with the chapters and topics in this book
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的组件与本书的章节和主题相关联
- en: Up until now, we haven't discussed where and when we'll be implementing our
    components. Part of the reason was that we didn't even start writing any Angular
    code until [Chapter 4](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml), *Routing*—with
    the sole exception being our to-do list mini-application in [Chapter 1](f1243d74-a120-408f-8181-cb379b457dd1.xhtml),
    *Quick Start*. However, now that we have started writing Angular code, it's time
    to do that now.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有讨论我们将在何时何地实施我们的组件。部分原因是直到[第4章](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml)
    *路由*，我们甚至都没有开始编写任何Angular代码，唯一的例外是我们在[第1章](f1243d74-a120-408f-8181-cb379b457dd1.xhtml)
    *快速入门*中的待办事项列表迷你应用。然而，现在我们已经开始编写Angular代码，现在是时候做了。
- en: A good place to start the discussion is to select which component templates
    we'll be laying out with Flex-Layout. Since this book focuses more on Bootstrap
    than it does with Flex-Layout, we'll be using Bootstrap's grid for the rest of
    our component templates, which is the majority of them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 开始讨论的一个好地方是选择我们将使用Flex-Layout布局的组件模板。由于这本书更多地关注Bootstrap而不是Flex-Layout，我们将使用Bootstrap的网格来布局我们应用程序中其余的组件模板，这占了大部分。
- en: The first thing we'll do is to list our wireframes, as a reference,which represent
    our application's *pages* (that is, component templates), and we'll select three
    of them, which we will implement in the following section, *Implementing our selected
    wireframes*. And then, we'll look at the table that follows, which will show you
    which component templates we will implement and which chapters and, specifically,
    which topics we're pairing them up with.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是列出我们的线框图，作为参考，它们代表我们应用的*页面*（即组件模板），我们将选择其中三个，在接下来的部分*实现我们选择的线框图*中实现它们。然后，我们将看一下接下来的表格，它将向您展示我们将实现哪些组件模板，以及哪些章节，具体来说，我们将把它们与哪些主题配对。
- en: 'The following is a list of our 13 wireframes from [Chapter 1](f1243d74-a120-408f-8181-cb379b457dd1.xhtml),
    *Quick Start*:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们从[第1章](f1243d74-a120-408f-8181-cb379b457dd1.xhtml) *快速入门*中的13个线框图的列表：
- en: Home
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首页
- en: Sign Up
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册
- en: Log In
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录
- en: Edit Profile (excluded from coverage in the book)
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑个人资料（不在书中涵盖范围内）
- en: Property Listing (excluded from coverage in the book)
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 房产列表（不在书中涵盖范围内）
- en: Create Listing
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建列表
- en: Edit Listing
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑列表
- en: Preview Listing
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预览列表
- en: Property Details (excluded from coverage in the book)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 房产详情（不在书中涵盖范围内）
- en: Photo Listing
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 照片列表
- en: Upload Photo / Create Card
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传照片/创建卡片
- en: Edit Photo (excluded from coverage in the book)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑照片（不在书中涵盖范围内）
- en: Preview Photo
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预览照片
- en: 'The following is a table of the wireframes that we will implement together
    in this book, along with a list of their associated chapters and topics. You can
    use this as a kind of roadmap in conceptually piecing together our application
    in your mind—meaning, at a high level, you''ll know in which chapter we''ll be
    implementing various parts of the component templates in our application:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在本书中一起实现的线框图的表格，以及它们关联的章节和主题的列表。您可以将其用作在概念上将我们的应用程序组合在一起的路线图，也就是说，从高层次上，您将知道我们将在哪一章中实现应用程序中组件模板的各个部分：
- en: '| **Wireframe /component template** | **Associated chapters** | **Associated topics**
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **线框图/组件模板** | **关联章节** | **关联主题** |'
- en: '| Home | 3 | Bootstrap grid |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 首页 | 3 | Bootstrap网格 |'
- en: '| Sign Up | 3, 8, 10 | Modal dialog, ng-Bootstrap (input boxes), Forms |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 注册 | 3, 8, 10 | 模态对话框，ng-Bootstrap（输入框），表单 |'
- en: '| Log In | 14 | Authentication |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 登录 | 14 | 认证 |'
- en: '| Create Listing | 5, 14 | Flex-Layout, Custom validation |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 创建列表 | 5, 14 | Flex-Layout, 自定义验证 |'
- en: '| Edit Listing | 5, 10 | Flex-Layout, Forms |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 编辑列表 | 5, 10 | Flex-Layout, 表单 |'
- en: '| Preview Listing | 5, 6, 9 | Flex-Layout, Components, Angular Material (chips)
    |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 预览列表 | 5, 6, 9 | Flex-Layout, 组件，Angular Material（芯片） |'
- en: '| Photo Listing | 6, 7 | Components, Templates |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 照片列表 | 6, 7 | 组件，模板 |'
- en: '| Upload Photo / Create Photo Card | 10 | Forms |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 上传照片/创建照片卡 | 10 | 表单|'
- en: '| Preview Photo | 6, 9 | Components, Angular Material (card) |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 预览照片 | 6, 9 | 组件，Angular Material（卡片）|'
- en: The preceding table shows us topics from which chapters we will be implementing
    in our wireframes (that is, component templates). For example, by taking a look
    at the fourth row from the top, we can see that when we implement our Create Listing
    wireframe (that is, our `CreateListingComponent`), we'll be using Flex-Layout
    from this chapter, and Custom Validation from [Chapter 14](485921eb-86e2-4068-b314-5c62a1545c22.xhtml), *Advanced
    Angular Topics*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上表显示了我们将在我们的线框（即组件模板）中实施的主题。例如，通过查看从顶部开始的第四行，我们可以看到当我们实施我们的创建列表线框（即我们的`CreateListingComponent`）时，我们将使用本章的
    Flex-Layout，以及来自[第14章](485921eb-86e2-4068-b314-5c62a1545c22.xhtml) *高级 Angular
    主题*的自定义验证。
- en: Keep in mind that every wireframe will require components—despite not listing
    [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml), *Building Angular Components*,
    in the associated chapters column, and components in the associated topics column.
    The reason I did this for some of the wireframes, such as Photo Listing and Preview
    Photo, is that we're going to discuss components a little more than we will, say,
    for the Sign-Up or Edit Listing wireframes. Also, certain wireframes will have
    us focusing much more on other topics. For instance, you can see for the Upload
    Photo wireframe that we'll be focusing on forms, from [Chapter 10](5f27121b-6fb2-4429-aa6e-394aec2152ac.xhtml),
    *Working with Forms*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，每个线框都需要组件——尽管在相关章节列中没有列出[第6章](acd5e47c-07a7-4954-993d-360134221325.xhtml)
    *构建 Angular 组件*，以及相关主题列中的组件。我之所以对一些线框这样做，比如照片列表和预览照片，是因为我们将会更多地讨论组件，而不是比如注册或编辑列表线框。此外，某些线框将使我们更加关注其他主题。例如，您可以看到对于上传照片线框，我们将更多地关注表单，来自[第10章](5f27121b-6fb2-4429-aa6e-394aec2152ac.xhtml)
    *使用表单*。
- en: Since we won't be jumping from chapter to chapter, this means that we'll be
    revisiting the majority of our pages (that is, component templates) two, three,
    or even four times, as we progress through the book.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不会跳来跳去，这意味着在我们阅读本书时，我们将会多次回顾我们的大部分页面（即组件模板），两次、三次，甚至四次。
- en: Implementing our selected wireframes
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施我们选择的线框
- en: 'The three wireframes (that is, component templates) that I''ve selected to
    implement with you in this chapter are the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章中选择要与您实施的三个线框（即组件模板）如下：
- en: Create Listing (included because there are many sections and elements within
    the view)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建列表（包括因为视图中有许多部分和元素）
- en: Edit Listing (included for the same reason as Create Listing)
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑列表（出于与创建列表相同的原因而包括）
- en: Preview Listing (included because there are very few elements within the view)
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预览列表（包括因为视图中有非常少的元素）
- en: 'In the listing of the aforementioned wireframes , you may have noticed that
    there are three wireframes that have been marked as *excluded from coverage in
    the book*. Here is the wireframe exclusion list, along with the reason for its
    exclusion:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述线框的列表中，您可能已经注意到有三个线框被标记为*不在书中涵盖范围内*。以下是线框排除列表，以及排除原因：
- en: '**Edit Profile**: This has been excluded because it is just another edit form
    (much like the Edit Listing screen)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑个人资料**：这被排除在外，因为它只是另一个编辑表单（与编辑列表屏幕非常相似）'
- en: '**Property Listing**: This has been excluded because it is just another listing
    screen (much like the Photo Listing screen)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**房产列表**：这被排除在外，因为它只是另一个列表屏幕（很像照片列表屏幕）'
- en: '**Property Details**: This has been excluded because it is a static screen
    that is uninteresting to us, from an Angular perspective'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**房产详情**：这被排除在外，因为从 Angular 的角度来看，这是一个无趣的静态屏幕'
- en: '**Edit Photo**: This has been excluded because it''s yet again just another
    edit form'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑照片**：这个被排除了，因为这只是另一个编辑表单'
- en: However, don't fret. All the code for the application that we'll be building
    together throughout the remaining pages, including the code for the four wireframes
    that we won't be implemented in the book, as well as the non-UI-based code (such
    as the Python-based APIs in [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml),
    *Integrating Backend Data Services*, and more), are being made available to you
    as a download. I have you covered.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要担心。我们将在剩下的页面中一起构建的应用程序的所有代码，包括书中不会实现的四个线框的代码，以及非基于 UI 的代码（例如 [第 12 章](9610f27b-03db-4258-8a68-24eb3901117b.xhtml)
    中的基于 Python 的 API，*集成后端数据服务*，等等），都可以通过下载获得。我已经为你准备好了。
- en: One last noteworthy point, and then we'll get on with some Flex-Layout coding.
    You can tell that our application will require some wireframes to be revisited
    more than once so that we can complete it—that is, we'll be building our application
    in pieces and in what seems like a chaotic back and forth fashion. This is not
    because the author is off his rocker—as some of his friends would love to tell
    you stories that make a strong case for just the opposite—but rather, it is by
    design. Remember, the philosophy of this book is to maximize your effectiveness
    of the absorption of the material, so you embark on the journey to becoming an
    Angular guru as quickly as possible. To the extent possible, we will immediately
    implement what material we cover so that it makes immediate sense, and sticks.
    That's the goal—and is also why I wanted to include the preceding table (that
    is, associating the wireframes with the chapters and topics).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个值得注意的点，然后我们将继续进行一些 Flex-Layout 编码。你可以看出我们的应用程序将需要一些线框被多次重新访问，以便我们可以完成它——也就是说，我们将分阶段构建我们的应用程序，看起来像是一种混乱的来回方式。这不是因为作者疯了——正如他的一些朋友喜欢给你讲述一些强有力的案例，证明恰恰相反——而是出于设计。记住，本书的理念是最大限度地提高你对材料的吸收效果，这样你就可以尽快成为
    Angular 大师。在尽可能的范围内，我们将立即实施我们所涵盖的材料，以便它立即有意义，并且牢固。这就是目标，也是为什么我想包括前面的表格（即，将线框与章节和主题相关联）。
- en: There's typically a method to my madness (wink). Let's now turn our attention
    to the implementation of the three wireframes for this chapter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我的疯狂通常都是有条不紊的方法（眨眼）。现在让我们把注意力转向本章的三个线框的实现。
- en: The Create Listing wireframe
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建列表线框
- en: 'In this section, we will bring all our knowledge and understanding together
    and learn to create our application pages for the Create Listing page. Take a
    look at the following wireframe, which we will convert into code using Flex-Layout:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将汇集所有的知识和理解，学习为创建列表页面创建我们的应用程序页面。看一下下面的线框，我们将使用 Flex-Layout 将其转换为代码：
- en: '![](assets/952c07b6-0b5c-467b-a454-d51e1219ad9e.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/952c07b6-0b5c-467b-a454-d51e1219ad9e.png)'
- en: The other wireframe shows that we will need a header section and a two-column
    layout to hold the form and input elements.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个线框显示，我们将需要一个标题部分和一个两列布局来容纳表单和输入元素。
- en: 'We will first create a new component in our application and call it `Create
    Listing`. In the component template file, let''s add the following sample code
    to the template:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在我们的应用程序中创建一个新组件，并将其命名为“创建列表”。在组件模板文件中，让我们向模板添加以下示例代码：
- en: '[PRE3]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, we are creating a row using the `fxLayout` to create
    a placeholder for our logo. Next, we are creating the menu links and, using `fxFlexOrder`,
    we are sorting the menu links. Now, we will need to create a two-column layout,
    so we are now creating child elements inside the `fxLayout` row with two divisions,
    each `fxFlex` for 60 and 40, respectively. Inside the two columns, we will place
    our form input elements to create the form, as shown in the wireframe. Run the
    app and we should see the output, as shown in the following screenshot:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们使用`fxLayout`创建了一行，为我们的标志创建了一个占位符。接下来，我们创建了菜单链接，并使用`fxFlexOrder`对菜单链接进行排序。现在，我们需要创建一个两列布局，所以我们现在在`fxLayout`行内创建了两个子元素，每个`fxFlex`分别为60和40。在这两列中，我们将放置我们的表单输入元素，以创建表单，如线框所示。运行应用程序，我们应该看到输出，如下面的截图所示：
- en: '![](assets/5ee464c0-2a23-4602-b2aa-8855b27e4577.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: 现在，是时候进行一些代码操作了。我们将在我们的Angular项目中创建一个名为edit-listing的新组件，并在组件模板文件中重用相同的代码，以快速准备好**编辑列表**页面：
- en: We have got our layout ready for the **Create Listing** page. If you look closely,
    our labels are not exactly next to the input fields. What needs to be updated?
    That's right; we need to create a child column inside the main column. Try it
    out by way of your homework. Now, on similar lines, we can easily implement our
    Edit Listing page.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了**创建列表**页面的布局。如果你仔细看，我们的标签并不完全在输入字段旁边。需要更新什么？没错，我们需要在主列内创建一个子列。通过作业来尝试一下。现在，同样的，我们可以轻松实现我们的编辑列表页面。
- en: The Edit Listing wireframe
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑列表线框
- en: In the previous section, we have created our **Create Listing** page. In this
    section, we will learn to implement the page layout for our Edit Listing page.
    Take a look at the example we will implement. Does it not look exactly the same
    as the **Create Listing** page? That's correct.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了我们的**创建列表**页面。在本节中，我们将学习为我们的编辑列表页面实现页面布局。看一下我们将要实现的示例。它不是看起来和**创建列表**页面完全一样吗？没错。
- en: 'The layout of the **Create** and **Edit Listing** pages will mostly be the
    same, except for the fact that there is data loaded when we launch the **Edit**
    page, whereas in the **Create** screen, there will be no data loaded initially:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建**和**编辑列表**页面的布局大部分都是相同的，除了在启动**编辑**页面时加载数据，而在**创建**屏幕上，最初不会加载任何数据：'
- en: '![](assets/0e242f70-fe76-4216-b713-a02a8102963b.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0e242f70-fe76-4216-b713-a02a8102963b.png)'
- en: 'Now, it''s time for some code action. We will create a new component in our
    Angular project named edit-listing and, in the component template file, we will
    reuse the same code to create the layout from the **Create Listing** page to quickly
    get the **Edit Listing** page ready:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/5ee464c0-2a23-4602-b2aa-8855b27e4577.png)'
- en: '[PRE4]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we are creating two rows,  one for the header section
    and the other for the content row. Inside the content row, we are creating two
    child columns using `fxRow`, which will be populated with the form input field
    elements. The output will be exactly the same as that of the Create Listing page.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们创建了两行，一行用于标题部分，另一行用于内容行。在内容行内，我们使用`fxRow`创建了两个子列，它们将用表单输入字段元素填充。输出将与创建列表页面完全相同。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter provided a quick tour of exciting technology. Of course, a small
    book can be written that is exclusively dedicated to FlexBox CSS and Flex-Layout,
    so covering it in just a few pages does not do it the justice it deserves. If
    there is an industry that changes rapidly, it is ours, and so alternative technologies
    should be mentioned—and, if the technology was exciting enough, maybe even get
    its own chapter—regardless of which tech book and which technologies. This was
    precisely the case for Flex-Layout and this book. I wanted to introduce Flex-Layout
    to you, in some depth.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了对令人兴奋的技术的快速介绍。当然，可以专门撰写一本专门介绍FlexBox CSS和Flex-Layout的小书，所以仅仅在几页中介绍并不能充分展现它应有的价值。如果有一个行业变化迅速，那就是我们的行业，因此应该提到替代技术
    - 如果技术足够令人兴奋，甚至可能获得自己的章节 - 无论是哪本技术书籍和哪些技术。这正是Flex-Layout和这本书的情况。我希望向你深入介绍Flex-Layout。
- en: We started the chapter with a quick review of the four options for the layout
    techniques, explaining why FlexBox CSS is the best choice of the four. I then
    introduced Flex-Layout to you and presented a few compelling reasons for why you
    should consider using it instead of using FlexBox. Next, we saw how to integrate
    Flex-Layout into our Angular project, and took a look at a few of its APIs. Lastly,
    we circled back to our wireframes (that is, components) and associated each of
    them with the chapters in this book, and then implemented the components that
    were associated with this chapter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从快速回顾四种布局技术的选项开始，解释了为什么FlexBox CSS是其中最佳选择。然后我向你介绍了Flex-Layout，并提出了一些令人信服的理由，说明为什么你应该考虑使用它而不是FlexBox。接下来，我们看到了如何将Flex-Layout集成到我们的Angular项目中，并查看了一些其API。最后，我们回到了我们的线框图（即组件），并将它们与本书中的章节相关联，然后实现了与本章相关的组件。
- en: I hope you enjoyed this chapter and will make it a point to experiment with
    Flex-Layout in at least one of your web development projects. My prediction is
    that many Angular developers will choose Flex-Layout as their tool of choice for
    laying out their components. I was already leaning toward using Flex-Layout instead
    of Bootstrap's grid for my next project, for all component templates.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你喜欢这一章，并且会尽量在你的网页开发项目中尝试使用Flex-Layout。我预测许多Angular开发者将选择Flex-Layout作为布局组件的首选工具。对于我的下一个项目，我已经倾向于使用Flex-Layout而不是Bootstrap的网格来设计所有组件模板。
- en: In the next chapter, we are going to learn all about the building blocks of
    any Angular applications - components. We will deep-dive to learn and create some
    cool stuff with Angular components. Happy Reading.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习任何Angular应用程序的构建块 - 组件。我们将深入学习并使用Angular组件创建一些很酷的东西。祝阅读愉快。
