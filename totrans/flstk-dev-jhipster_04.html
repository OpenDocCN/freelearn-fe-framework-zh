<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Entity Modeling with JHipster Domain Language</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we saw how we can use JHipster to generate a production-grade web application with a lot of awesome features, such as i18n, administration modules, account management, and so on. In this chapter, we will see how we can enrich that application with business entities and a model.</p>
<p>We will learn about the following in this chapter:</p>
<ul>
<li><strong>JHipster Domain Language </strong>(<strong>JDL</strong>)</li>
<li>JDL studio</li>
<li>Entity and relationship modeling with JDL</li>
<li>Entity generation</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to JDL</h1>
                </header>
            
            <article>
                
<p>JDL (<a href="http://www.jhipster.tech/jdl/">http://www.jhipster.tech/jdl/</a>) is used to create the domain model for a JHipster application. It provides a simple and user-friendly DSL to describe the entities and their relationships (for SQL databases only).</p>
<p>JDL is the recommended way to create entities for an application and can replace the entity generator provided by JHipster, which can be difficult to use when creating a lot of entities. The JDL is normally written in one or more files with a <kbd>.jh</kbd> extension.</p>
<p>Visit <a href="http://www.jhipster.tech/jdl/">http://www.jhipster.tech/jdl/</a> for complete documentation on JDL.</p>
<div class="packt_tip">If you prefer to work with UML and UML modeling tools, then check out JHipster-UML (<a href="http://www.jhipster.tech/jhipster-uml/">http://www.jhipster.tech/jhipster-uml/</a>), a tool that can create entities from popular UML tools.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DSL grammar for JDL</h1>
                </header>
            
            <article>
                
<p>Now, let's see the JDL grammar. At the time of writing, JDL supports generating complete entity models with relationships and options <span>such as </span>DTO, service layer, and so on. The grammar can be broken down into the following:</p>
<ul>
<li>Entity declaration</li>
<li>Relationship declaration</li>
<li>Options declaration</li>
</ul>
<p>In the following syntax, <kbd>[]</kbd> denotes optional and <kbd>*</kbd> denotes more than one can be specified.</p>
<p>Javadocs can be added to entity declarations and <kbd>/** */</kbd> Java comments can be added to fields and relationship declarations. JDL only comments can be added using <kbd>//</kbd> syntax.</p>
<p>It is also possible to define numerical constants in JDL, for example, <kbd>DEFAULT_MIN_LENGTH = 1</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Entity modeling with JDL</h1>
                </header>
            
            <article>
                
<p>The entity declaration is done using the following syntax:</p>
<pre>entity &lt;entity name&gt; ([&lt;table name&gt;]) {<br/>  &lt;field name&gt; &lt;type&gt; [&lt;validation&gt;*]<br/>}</pre>
<p><kbd>&lt;entity name&gt;</kbd> is the name of the entity and will be used for class names and table names. Table names can be overridden using the optional <kbd>&lt;table name&gt;</kbd> parameter.</p>
<p><kbd>&lt;field name&gt;</kbd> is the name of the fields (attributes) you want for the entity and <kbd>&lt;type&gt;</kbd> is the field type, as in String, Integer, and so on. Refer to <a href="http://www.jhipster.tech/jdl/#available-types-and-constraints">http://www.jhipster.tech/jdl/#available-types-and-constraints</a> for all supported field types. The ID field will be automatically created and hence need not be specified in JDL.</p>
<p><span><kbd>&lt;validation&gt;</kbd> is optional and </span>one or more <kbd>&lt;validation&gt;</kbd> for the fields can be specified depending on the validation supported by the field type. For validations <span>such as </span>max length and pattern, values can be specified in braces.</p>
<p>An example entity declaration would look like the following:</p>
<pre>/**<br/> * This is customer entity javadoc comment<br/> * @author Foo<br/> */<br/>entity Customer {<br/>  /** Name field */<br/>  name String required,<br/>  age Integer,<br/>  address String maxlength(100) pattern(/[a-Z0-9]+/)<br/>}</pre>
<p>Enumerations can also be declared using the following syntax:</p>
<pre>enum &lt;enum name&gt; {<br/>  &lt;VALUE&gt;*<br/>}</pre>
<p>Here is an example:</p>
<pre>enum Language {<br/>  ENGLISH, DUTCH, FRENCH<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Relationship management</h1>
                </header>
            
            <article>
                
<p>The relationship between entities can be declared using this syntax:</p>
<pre>relationship &lt;type&gt; {<br/>  &lt;from entity&gt;[{&lt;relationship name&gt;[(&lt;display field&gt;)] &lt;validation&gt;*}] <br/>  to <br/>  &lt;to entity&gt;[{&lt;relationship name&gt;[(&lt;display field&gt;)] &lt;validation&gt;*}]<br/>}</pre>
<p>The <kbd>&lt;type&gt;</kbd> is one from <kbd>OneToMany</kbd>, <kbd>ManyToOne</kbd>, <kbd>OneToOne</kbd>, or <kbd>ManyToMany</kbd> and as the name suggests, declares the relationship type between <kbd>&lt;from entity&gt;</kbd> and <kbd>&lt;to entity&gt;</kbd>.</p>
<p><kbd>&lt;from entity&gt;</kbd> is the name of the owner entity of the relationship or the source. <kbd>&lt;to entity&gt;</kbd> is the destination of the relationship.</p>
<p><kbd>&lt;relationship name&gt;</kbd> is optional and can be used to specify the field names to create for the relationship in the domain object. <kbd>&lt;display field&gt;</kbd> can be specified in braces to control the field of the entity to be shown in the drop-down menu on the generated web page, by default the ID field will be used. <kbd>&lt;validation&gt;</kbd> can be specified on the <kbd>&lt;from entity&gt;</kbd> or <kbd>&lt;to entity&gt;</kbd> and is optional. Currently, only required is supported.</p>
<p><kbd>OneToMany</kbd> and <kbd>ManyToMany</kbd> relationships are always bidirectional in JHipster. In case of <kbd>ManyToOne</kbd> and <kbd>OneToOne</kbd> relationships, it is possible to create both bidirectional and unidirectional relationships. For unidirectional relationships, just skip the <span><kbd>&lt;relationship name&gt;</kbd> on the destination/to entity.</span></p>
<p>Multiple relationships of the same type can be declared within the same block, separated by a comma.</p>
<p><span>An example relationship declaration would look like the following:</span></p>
<pre>entity Book<br/>entity Author<br/>entity Tag<br/><br/>relationship OneToMany {<br/>  Author{book} to Book{writer(name) required},<br/>  Book{tag} to Tag<br/>}</pre>
<p>The user is an existing entity in JHipster and it is possible to have certain relationships with the user. Many-to-many and one-to-one relations can be declared, but the other entity must be the source or owner. Many-to-one relations are also possible with a user entity.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DTO, service, and pagination options</h1>
                </header>
            
            <article>
                
<p>JDL also allows us to declare entity related options easily. Options currently supported are:</p>
<ul>
<li><kbd>service</kbd>: By default, JHipster generates REST Resource classes that call the entity repositories directly. This is the simplest option, but in real-world scenarios, we might need a service layer to handle business logic. This option lets us create a service layer with a simple Spring service bean class or with a traditional interface and implementation for the service bean. Possible values are <kbd>serviceClass</kbd> and<strong> </strong><kbd>serviceImpl</kbd>. Choosing the latter will create an interface and implementation, which is preferred by some people.</li>
<li><kbd>dto</kbd>:  By default, domain objects are directly used in the REST endpoints created, which may not be desirable in some situations and you might want to use an intermediatory <strong>Data Transfer Object</strong> (<strong>DTO</strong>) to have more control. JHipster lets us generate the DTO layer using Mapstruct (<a href="http://mapstruct.org/">http://mapstruct.org/</a>), an annotation preprocessor library that automatically generates the DTO classes. It is advisable to use a service layer when using DTO. A possible value is <kbd>mapstruct</kbd>. For more info visit: <a href="http://www.jhipster.tech/using-dtos/">http://www.jhipster.tech/using-dtos/</a>.</li>
<li><kbd>filter</kbd>: This option lets us enable JPA based filtering capabilities for the entity. This works only when a service layer is used. For more details, visit: <a href="http://www.jhipster.tech/entities-filtering/">http://www.jhipster.tech/entities-filtering/</a>.</li>
<li><kbd>paginate</kbd>: This option lets us enable pagination for an entity. This enables pagination on the Resource layer and also implements a paging option on the client side. Possible values are pager, pagination, and infinite-scroll.</li>
<li><kbd>noFluentMethod</kbd>: This lets us disable Fluent API style setters for the generated entity domain objects.</li>
<li><kbd>skipClient</kbd>/<kbd>skipServer</kbd>: These options let us either skip the client-side code or server-side code during generation.</li>
<li><kbd>angularSuffix</kbd><span>: This option lets us specify a suffix for the folder and class names in the frontend code.</span></li>
</ul>
<p>The general syntax for option declaration is <kbd>&lt;OPTION&gt; &lt;ENTITIES | * | all&gt; <span>[with &lt;VALUE&gt;] </span>[except &lt;ENTITIES&gt;]</kbd>.</p>
<p>The following are some possible options and different syntax in which they can be declared:</p>
<pre>entity A<br/>entity B<br/>...<br/>entity Z<br/><br/>dto * with mapstruct<br/>service A with serviceImpl<br/>service B with serviceClass<br/>paginate * with pagination except B, C<br/>paginate B, C with infinite-scroll<br/>filter A, B</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JDL Studio</h1>
                </header>
            
            <article>
                
<p>We will be using JDL Studio (<a href="https://start.jhipster.tech/jdl-studio/">https://start.jhipster.tech/jdl-studio/</a>)<span> to create our JDL file. It </span>is an online web application built by the JHipster team for creating JDL files in a visual editor. The tool shows a visual representation of the created entity model and also lets you import/export JDL and capture image snapshots:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2759a4bc-38aa-48fc-a2ac-043b42be3fe1.png"/></div>
<p>The tool also provides features <span>such as </span>syntax highlighting, auto-completion, error reporting, and Sublime Text-style keyboard shortcuts.</p>
<p>Navigate your favorite browser to <a href="https://start.jhipster.tech/jdl-studio/">https://start.jhipster.tech/jdl-studio/</a> to open the application.</p>
<div class="packt_infobox">Please note that by default this application stores the JDL in your browser's local storage. You can create an account with JHipster online if you want to save your JDL files to the cloud.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Use case entity model with explanation</h1>
                </header>
            
            <article>
                
<p>Now, let's look at our use case and the entity model. Before that, clear the default JDL in the JDL Studio editor.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Entities</h1>
                </header>
            
            <article>
                
<p>Let's start by defining our entities:</p>
<ol>
<li>Copy the following snippet for <kbd>Product</kbd> and <kbd>ProductCategory</kbd> into the JDL Studio editor:</li>
</ol>
<pre style="padding-left: 60px">/** Product sold by the Online store */<br/>entity Product {<br/>    name String required<br/>    description String<br/>    price BigDecimal required min(0)<br/>    size Size required<br/>    image ImageBlob<br/>}<br/><br/>enum Size {<br/>    S, M, L, XL, XXL<br/>}<br/><br/>entity ProductCategory {<br/>    name String required<br/>    description String<br/>}</pre>
<p style="padding-left: 60px">The <kbd>Product</kbd> entity is the core of the domain model; it holds product information <span>such as </span><kbd>name</kbd>, <kbd>description</kbd><span>, </span><kbd>price</kbd>, <kbd>size</kbd>, and <kbd>image</kbd> which is a Blob. <kbd>name</kbd>, <kbd>price</kbd>, and <kbd>size</kbd> are required fields. <kbd>price</kbd> also has a min value validation. The <kbd>size</kbd> field is an enum with defined values.</p>
<p style="padding-left: 60px">The <kbd>ProductCategory</kbd> entity is used to group products together. It has <kbd>name</kbd> and <kbd>description</kbd> where <kbd>name</kbd> is a required field.</p>
<ol start="2">
<li><span>Add the following snippet for</span> <kbd>Customer</kbd> <span>into the JDL Studio editor:</span></li>
</ol>
<pre style="padding-left: 60px">entity Customer {<br/>    firstName String required<br/>    lastName String required<br/>    gender Gender required<br/>    email String required pattern(/^[^@\s]+@[^@\s]+\.[^@\s]+$/)<br/>    phone String required<br/>    addressLine1 String required<br/>    addressLine2 String<br/>    city String required<br/>    country String required<br/>}<br/><br/>enum Gender {<br/>    MALE, FEMALE, OTHER<br/>}</pre>
<p style="padding-left: 60px">The <kbd>Customer</kbd> entity holds details of the customers using the online shopping portal. Most of the fields are marked as required, the <kbd>email</kbd> field has regex pattern validation. The <kbd>gender</kbd> field is an <kbd>enum</kbd>. This entity is related to the system user which we will see in detail soon.</p>
<ol start="3">
<li>Add the following snippet for <kbd>ProductOrder</kbd> and <kbd>OrderItem</kbd> into the JDL Studio editor:</li>
</ol>
<pre style="padding-left: 60px">entity ProductOrder {<br/>    placedDate Instant required<br/>    status OrderStatus required<br/>    code String required<br/>}<br/><br/>enum OrderStatus {<br/>    COMPLETED, PENDING, CANCELLED<br/>}<br/><br/>entity OrderItem {<br/>    quantity Integer required min(0)<br/>    totalPrice BigDecimal required min(0)<br/>    status OrderItemStatus required<br/>}<br/><br/>enum OrderItemStatus {<br/>    AVAILABLE, OUT_OF_STOCK, BACK_ORDER<br/>}</pre>
<p style="padding-left: 60px">The <kbd>ProductOrder</kbd> and <kbd>OrderItem</kbd> entities are used to track product orders made by customers. <kbd>ProductOrder</kbd> holds the <kbd>placedDate</kbd> and <kbd>status</kbd>, and <kbd>code</kbd> of the order, which are all required fields, while <kbd>OrderItem</kbd> holds information about the <kbd>quantity</kbd>, <kbd>totalPrice</kbd>, and <kbd>status</kbd> of individual items. All fields are required and the <kbd>quantity</kbd> and <kbd>totalPrice</kbd> fields have min value validation. <kbd>OrderStatus</kbd> and <kbd>OrderItemStatus</kbd> are <kbd>enum</kbd> fields.</p>
<ol start="4">
<li>Add the following snippet for <kbd>Invoice</kbd> and <kbd>Shipment</kbd> into the JDL Studio editor:</li>
</ol>
<pre style="padding-left: 60px">entity Invoice {<br/>    date Instant required<br/>    details String<br/>    status InvoiceStatus required<br/>    paymentMethod PaymentMethod required<br/>    paymentDate Instant required<br/>    paymentAmount BigDecimal required<br/>}<br/><br/>enum InvoiceStatus {<br/>    PAID, ISSUED, CANCELLED<br/>}<br/><br/>enum PaymentMethod {<br/>    CREDIT_CARD, CASH_ON_DELIVERY, PAYPAL<br/>}<br/><br/>entity Shipment {<br/>    trackingCode String<br/>    date Instant required<br/>    details String<br/>}</pre>
<p style="padding-left: 60px">The <kbd>Invoice</kbd> and <kbd>Shipment</kbd> entities are used to track the invoice and shipping for the product orders, respectively. Most of the fields in <kbd>Invoice</kbd> are required and the <kbd>status</kbd> and <kbd>paymentMethod</kbd> fields are enums.</p>
<p style="padding-left: 60px">The enumerations are being used to contain the scope of certain fields, which gives more granular control over those fields.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Relationships</h1>
                </header>
            
            <article>
                
<p>Now that we have defined our entities, let's add relationships between them:</p>
<ol>
<li><span>Add the following snippet for relationships into the JDL Studio editor:</span></li>
</ol>
<pre style="padding-left: 60px">relationship OneToOne {<br/>    Customer{user} to User<br/>}</pre>
<p style="padding-left: 60px">The first relationship declared is a unidirectional <kbd>OneToOne</kbd> between a <kbd>Customer</kbd> entity and the inbuilt <kbd>User</kbd> entity: </p>
<pre style="padding-left: 60px">Customer (1) -----&gt; (1) User</pre>
<p style="padding-left: 60px"><span>It means the <kbd>Customer</kbd> entity knows about the <kbd>User</kbd> and is the owner of the relationship but the <kbd>User</kbd> doesn't know about the <kbd>Customer</kbd> and hence we will not be able to obtain customers from a <kbd>User</kbd>. This lets us map customers to the <kbd>User</kbd> entity and use that for authorization purposes later ensuring one customer can be mapped only to one system user.</span></p>
<ol start="2">
<li>Add this snippet for relationships into the JDL Studio editor:</li>
</ol>
<pre style="padding-left: 60px">relationship ManyToOne {<br/>    OrderItem{product} to Product<br/>}</pre>
<p style="padding-left: 60px">This one declares a unidirectional <kbd>ManyToOne</kbd> relationship from <kbd>OrderItem</kbd> to <kbd>Product</kbd>: </p>
<pre style="padding-left: 60px">OrderItem (*) -----&gt; (1) Product</pre>
<p style="padding-left: 60px">It means the <kbd>OrderItem</kbd> knows their <kbd>Product</kbd> but <kbd>Product</kbd> does not know about <kbd>OrderItem</kbd>. This keeps the design clean as we don't want to know about orders from products for this use case. In the future, if we want to know the orders made for a product we could make this bi-directional. </p>
<ol start="3">
<li>Add the following snippet for relationship into the JDL Studio editor:</li>
</ol>
<pre style="padding-left: 60px">relationship OneToMany {<br/>   Customer{order} to ProductOrder{customer},<br/>   ProductOrder{orderItem} to OrderItem{order},<br/>   ProductOrder{invoice} to Invoice{order},<br/>   Invoice{shipment} to Shipment{invoice},<br/>   ProductCategory{product} to Product{productCategory}<br/>}</pre>
<p style="padding-left: 60px">This declaration is interesting, as we have multiple <kbd>OneToMany</kbd> declarations:</p>
<pre>Customer (1) &lt;-----&gt; (*) ProductOrder<br/>ProductOrder (1) &lt;-----&gt; (*) OrderItem<br/>ProductOrder (1) &lt;-----&gt; (*) Invoice<br/>Invoice (1) &lt;-----&gt; (*) Shipment<br/>ProductCategory (1) &lt;-----&gt; (*) Product</pre>
<p><span>They are all bidirectional, meaning both</span> the source <span>entity and destination entity know about each other.</span></p>
<p>We declare that a <kbd>Customer</kbd> can have multiple ProductOrders, <kbd>ProductOrder</kbd> can have multiple OrderItems and Invoices, <kbd>Invoice</kbd> can have many <kbd>Shipment</kbd>, and <kbd>ProductCategory</kbd> can have many Products. From the destination entity, the source entities are mapped as <kbd>ManyToOne</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Options for entities</h1>
                </header>
            
            <article>
                
<p><span>Add the following snippet for options into the JDL Studio editor:</span></p>
<pre>service * with serviceClass<br/>paginate Product, Customer, ProductOrder, Invoice, Shipment, OrderItem with pagination</pre>
<p>In the options, we keep it simple and declare that we want a service class for all entities. We also enabled pagination for some of the entities that may get a lot of entries over time.</p>
<p>The diagram shows the complete model, with all the entities and their relationships as shown in JDL Studio:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/383158ed-4758-42c6-8d8c-142ef607bdc3.jpg"/></div>
<p>Now, let's download this JDL file to our file system:</p>
<ol>
<li>Click on the download button in the upper-right-hand corner of the JDL Studio application.</li>
<li>Save the file with the name <kbd>online-store.jh</kbd> inside the <kbd>online-store</kbd> directory where we created our application in the previous chapter.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Entity generation with JHipster</h1>
                </header>
            
            <article>
                
<p>Now, it's time to generate the domain model with our JDL. We will use the <kbd>import-jdl</kbd> command from JHipster for this.</p>
<p>Open your favorite Terminal application and navigate to the <kbd>online-store</kbd> folder where we created the application earlier. Then, execute the <kbd><span>import-jdl</span></kbd> command:</p>
<pre class="mce-root"><strong>&gt; cd online-store<br/>&gt; jhipster import-jdl online-store.jh</strong></pre>
<p>This will trigger the entity creation process and you will be asked to confirm the overwriting of existing files with changes. Take a look at the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/73967f25-9074-43e2-9b36-4b9423d5728b.png"/></div>
<p>Enter <em>a</em> to confirm the overwrite of all files with changes. Once the files are generated, JHipster will trigger a <kbd>yarn webpack:build</kbd> step to rebuild the client side code. Once done you will see a success message like the following:</p>
<div class="CDPAlignCenter CDPAlign"><img height="116" src="assets/4aafe021-078c-491f-b99b-7957d9e4a44a.png" width="395"/></div>
<p><span>Running </span><kbd>git status</kbd><span> on the Terminal shows us that five files were modified and a lot of new files added. Let's commit the changes to Git. Execute the commands shown here:</span></p>
<div>
<pre><strong>&gt; git add --all</strong><br/><strong>&gt; git commit -am "generated online store entity model"</strong></pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generated code walkthrough</h1>
                </header>
            
            <article>
                
<p>Now let's take a look at what has been generated. Let's open the application code in our favorite IDE/editor. Let's take a look at what has been generated for the <kbd>Product</kbd> entity.</p>
<p>You might have noticed that there is a <kbd>.jhipster</kbd> folder at the root of the project and if you look into it you will see a bunch of JSON files. Let's look at <kbd>Product.json</kbd>. It holds metadata about the generated entity and is used by JHipster to regenerate and edit an entity when needed:</p>
<pre>{ <br/>    "fluentMethods": true, <br/>    "relationships": [ <br/>        { <br/>            "relationshipType": "many-to-one", <br/>            "relationshipName": "productCategory", <br/>            "otherEntityName": "productCategory", <br/>            "otherEntityField": "id" <br/>        } <br/>    ], <br/>    "fields": [ <br/>        { <br/>            "fieldName": "name", <br/>            "fieldType": "String", <br/>            "fieldValidateRules": [ <br/>                "required" <br/>            ] <br/>        }, <br/>        { <br/>            "fieldName": "description", <br/>            "fieldType": "String" <br/>        }, <br/>        { <br/>            "fieldName": "price", <br/>            "fieldType": "BigDecimal", <br/>            "fieldValidateRules": [ <br/>                "required", <br/>                "min" <br/>            ], <br/>            "fieldValidateRulesMin": 0 <br/>        }, <br/>        { <br/>            "fieldName": "size", <br/>            "fieldType": "Size", <br/>            "fieldValues": "S,M,L,XL,XXL", <br/>            "fieldValidateRules": [ <br/>                "required" <br/>            ] <br/>        }, <br/>        { <br/>            "fieldName": "image", <br/>            "fieldType": "byte[]", <br/>            "fieldTypeBlobContent": "image" <br/>        } <br/>    ], <br/>    "changelogDate": "20180114123458", <br/>    "javadoc": "Product sold by the Online store", <br/>    "entityTableName": "product", <br/>    "dto": "no", <br/>    "pagination": "pagination", <br/>    "service": "serviceClass", <br/>    "jpaMetamodelFiltering": false <br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Server-side source code</h1>
                </header>
            
            <article>
                
<p><span>Now let's look at the server-side code generated.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Domain class for the entity</h1>
                </header>
            
            <article>
                
<p>In the <kbd>src/main/java/com/mycompany/store/domain</kbd> folder, you will find the entity domain object. Open <kbd>Product.java</kbd>:</p>
<pre>@ApiModel(description = "Product sold by the Online store")<br/>@Entity<br/>@Table(name = "product")<br/>@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)<br/>public class Product implements Serializable {<br/><br/>    private static final long serialVersionUID = 1L;<br/><br/>    @Id<br/>    @GeneratedValue(strategy = GenerationType.IDENTITY)<br/>    private Long id;<br/><br/>    @NotNull<br/>    @Column(name = "name", nullable = false)<br/>    private String name;<br/><br/>    @Column(name = "description")<br/>    private String description;<br/><br/>    @Lob<br/>    @Column(name = "image")<br/>    private byte[] image;<br/><br/>    @Column(name = "image_content_type")<br/>    private String imageContentType;<br/><br/>    @NotNull<br/>    @DecimalMin(value = "0")<br/>    @Column(name = "price", precision=10, scale=2, nullable = false)<br/>    private BigDecimal price;<br/><br/>    @NotNull<br/>    @Enumerated(EnumType.STRING)<br/>    @Column(name = "jhi_size", nullable = false)<br/>    private Size size;<br/><br/>    @ManyToOne<br/>    private ProductCategory productCategory;<br/><br/>    // jhipster-needle-entity-add-field - JHipster will add fields <br/>     here, do not remove<br/><br/>    ... // getters<br/><br/>    public Product name(String name) {<br/>        this.name = name;<br/>        return this;<br/>    }<br/><br/>    ... // setters<br/><br/>    // jhipster-needle-entity-add-getters-setters - JHipster will add getters and setters here, do not remove<br/><br/>    ... // equals, hashcode and toString methods<br/>}</pre>
<p>The entity class defines the fields and relationships.</p>
<pre>@ApiModel(description = "Product sold by the Online store")</pre>
<p>This annotation is used by Swagger to show useful documentation when the entity is used in an endpoint:</p>
<pre>@Entity<br/>@Table(name = "product")</pre>
<p>These are JPA annotations declaring the POJO as an entity and mapping it to an SQL table:</p>
<pre>@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)</pre>
<p>This is a Hibernate annotation, which lets us enable level 2 cache for this entity. In our case using Hazelcast:</p>
<pre>@Id<br/>@GeneratedValue(strategy = GenerationType.IDENTITY)<br/>private Long id;</pre>
<p>The <kbd>id</kbd> field is special and is mapped as a generated value field. Depending on the DB, this field will use a native generation technique or a sequence provided by Hibernate. Since we are using MySQL, it will use the native DB primary key generation technique:</p>
<pre>@Column(name = "name", nullable = false)</pre>
<p>This JPA annotation is used to map columns to fields and it can also be used to declare properties <span>such as </span>nullable, precision, scale, unique, and so on for the field:</p>
<pre>@NotNull<br/>@DecimalMin(value = "0")</pre>
<p>These are Bean validation annotations enabling validation for the fields:</p>
<pre>@Lob<br/>@Column(name = "image")<br/>private byte[] image;<br/><br/>@Column(name = "image_content_type")<br/>private String imageContentType;</pre>
<p>The image field is a Blob and it is marked by the Lob type since we are using MySQL. It also has an additional field to hold the content type information:</p>
<pre>@Enumerated(EnumType.STRING)</pre>
<p>The Enumerated annotation is used to map Enum fields. These are stored as simple <span>varchar fields in the DB:</span></p>
<pre>@ManyToOne<br/>private ProductCategory productCategory;</pre>
<p>The relationships are mapped using annotations <span>such as </span><kbd>@ManyToOne</kbd>, <kbd>@OneToMany</kbd>, <kbd>@OneToOne</kbd>, and <kbd>@ManyToMany</kbd>.</p>
<p>Here, <kbd>ProductCategory</kbd> is mapped as <kbd>ManyToOne</kbd>; on the other side of the relationship Product is mapped as <kbd>OneToMany</kbd> as shown here:</p>
<pre>@OneToMany(mappedBy = "productCategory")<br/>@JsonIgnore<br/>@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)<br/>private Set&lt;Product&gt; products = new HashSet&lt;&gt;();</pre>
<p>As you can see, the relationship also specifies a cache for it. It tells Jackson to ignore the field while converting to JSON to avoid a circular reference since <span><kbd>ProductCategory</kbd> is already mapped in <kbd>Product</kbd> entity:</span></p>
<pre>public Product name(String name) {<br/>    this.name = name;<br/>    return this;<br/>}</pre>
<p>This is a fluent setter generated by default along with the standard setter. This can be turned off by specifying the <kbd>noFluentMethod</kbd> for the entity in JDL. Fluent methods are handy as they let us chain setters as follows for more concise code:</p>
<pre>new Product().name("myProduct").price(10);</pre>
<p>The corresponding table definitions and constraints are created using Liquibase and can be found in <kbd>src/main/resources/config/liquibase/changelog</kbd> with the file names <kbd>&lt;timestamp&gt;_added_entity_Product</kbd> and <kbd>&lt;timestamp&gt;_added_entity_constraints_Product.xml</kbd>, which automatically get applied to the database when we reload or start the application again.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Repository interface for the entity</h1>
                </header>
            
            <article>
                
<p><span>In the </span><kbd>src/main/java/com/mycompany/store/repository</kbd><span> folder, you will find the entity repository service. Open</span> <kbd>ProductRepository.java</kbd>:</p>
<pre>@Repository<br/>public interface ProductRepository extends JpaRepository&lt;Product, Long&gt; {<br/><br/>}</pre>
<p>The repository service is just an empty interface that extends the <kbd>JpaRepository</kbd> class. Since it is a Spring Data repository, the implementation is automatically created, allowing us to do all CRUD actions using this simple interface declaration. Additional repository methods can be added here easily. We will see about that in the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Service class for the entity</h1>
                </header>
            
            <article>
                
<p>Since we opted to generate service classes for our entities, let's look at one. <span>In the </span><kbd>src/main/java/com/mycompany/store/service</kbd><span> folder, you will find the entity repository service. Open </span><kbd>ProductService.java</kbd>:</p>
<pre>@Service<br/>@Transactional<br/>public class ProductService {<br/><br/>    private final Logger log = LoggerFactory.getLogger(ProductService.class);<br/><br/>    private final ProductRepository productRepository;<br/><br/>    public ProductService(ProductRepository productRepository) {<br/>        this.productRepository = productRepository;<br/>    }<br/><br/>    ...<br/>}</pre>
<p>The service uses constructor injection to get its dependencies, which are automatically injected by Spring during bean instantiation. The service is also marked as <kbd>@Transactional</kbd> to enable transaction management for data access. The service defines CRUD action methods. For example, the <kbd>findAll</kbd> method calls the equivalent repository method while adding a read-only transaction rule to it. You can see that the method already supports pagination and returns the results as <kbd>Page</kbd>. The <kbd>Page</kbd> and <kbd>Pageable</kbd> objects are provided by Spring and let us easily control pagination:</p>
<pre>    @Transactional(readOnly = true)<br/>    public Page&lt;Product&gt; findAll(Pageable pageable) {<br/>        log.debug("Request to get all Products");<br/>        return productRepository.findAll(pageable);<br/>    }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resource class for the entity</h1>
                </header>
            
            <article>
                
<p><span> </span><span>In the </span><kbd>src/main/java/com/mycompany/store/web/rest</kbd><span> folder you will find the entity resource service. Open </span><kbd>ProductResource.java</kbd>:</p>
<pre>@RestController<br/>@RequestMapping("/api")<br/>public class ProductResource {<br/>   ...<br/>}</pre>
<p>The resource acts as the controller layer and in our case, it serves the REST endpoints to be used by our client-side code. The endpoint has a base mapping to <kbd>"/api"</kbd>:</p>
<pre>    @GetMapping("/products")<br/>    @Timed<br/>    public ResponseEntity&lt;List&lt;Product&gt;&gt; getAllProducts(Pageable <br/>    pageable) {<br/>        log.debug("REST request to get a page of Products");<br/>        Page&lt;Product&gt; page = productService.findAll(pageable);<br/>        HttpHeaders headers = <br/>        PaginationUtil.generatePaginationHttpHeaders(page, <br/>        "/api/products");<br/>        return new ResponseEntity&lt;&gt;(page.getContent(), headers, <br/>        HttpStatus.OK);<br/>    }</pre>
<p>All the CRUD actions have equivalent mapping methods here, for example, the <kbd>getAllProducts</kbd> maps to the <kbd>findAll</kbd> from our service. The resource also handles pagination by adding appropriate headers for pagination.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Client side</h1>
                </header>
            
            <article>
                
<p>The client-side resources for the entity are created in the <kbd>src/main/webapp/app/entities</kbd> folder. Let's take a look at the code created for the <kbd>Product</kbd> entity in the <kbd>product</kbd> folder.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TypeScript model class for the entity</h1>
                </header>
            
            <article>
                
<p>Let's look at the TypeScript model generated in <kbd>product.model.ts</kbd>. This maps directly to the domain object:</p>
<pre>export class Product implements IProduct {<br/>    constructor(<br/>        public id?: number,<br/>        public name?: string,<br/>        public description?: string,<br/>        public imageContentType?: string,<br/>        public image?: any,<br/>        public price?: number,<br/>        public size?: Size,<br/>        public productCategory?: IProductCategory<br/>    ) {<br/>    }<br/>}</pre>
<p>The fields are all optional making it possible to create an object instance without any values. You will also see that the enums are also generated alongside the model in the file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Angular services for the entity</h1>
                </header>
            
            <article>
                
<p>The <kbd>ProductService</kbd> is an Angular service that interacts with our REST endpoints and created in <kbd>product.service.ts</kbd>:</p>
<pre>@Injectable()<br/>export class ProductService {<br/><br/>    private resourceUrl = SERVER_API_URL + 'api/products';<br/><br/>    constructor(private http: HttpClient) { }<br/><br/>    ...<br/><br/>    query(req?: any): Observable&lt;HttpResponse&lt;Product[]&gt;&gt; {<br/>        const options = createRequestOption(req);<br/>        return this.http.get&lt;Product[]&gt;(<br/>            this.resourceUrl, <br/>            { params: options, observe: 'response' }<br/>        )<br/>        .map((res: HttpResponse&lt;Product[]&gt;) =&gt; this.convertArrayResponse(res));<br/>    }<br/><br/>    ...<br/>}</pre>
<p>As you can see, the service has a constructor with dependencies injected following a similar pattern as our server-side code. There are methods mapping all the CRUD actions to the backend REST Resource. The HTTP calls make use of RxJS Observables to provide an asynchronous streaming API, which is much better than a Promise based API. </p>
<p>There is also <kbd>ProductPopupService</kbd> defined in <kbd>product-popup.service.ts</kbd>, a utility service to open popup dialogs for entity editing and deletion.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Angular components of the entity</h1>
                </header>
            
            <article>
                
<p>For an entity, there are six component classes generated in four files and four HTML files that are used in the components. </p>
<p><kbd>ProductComponent</kbd>, <span>defined in</span> <kbd>product.component.ts</kbd> <span>handles the main listing screen. It uses</span> <kbd>product.component.html</kbd>, <span>as the template. The component manages the view and their actions. It also calls multiple services to fetch data and to do other actions such as alerts and event broadcasts:</span></p>
<pre>@Component({<br/>    selector: 'jhi-product',<br/>    templateUrl: './product.component.html'<br/>})<br/>export class ProductComponent implements OnInit, OnDestroy {<br/>    ...<br/>}</pre>
<p><kbd>product-dialog.component.ts</kbd> defines <kbd>ProductDialogComponent</kbd> and <kbd>ProductPopupComponent</kbd>, which handle the create/edit dialog page using <kbd>template product-dialog.component.html</kbd>:</p>
<pre>@Component({<br/>    selector: 'jhi-product-dialog',<br/>    templateUrl: './product-dialog.component.html'<br/>})<br/>export class ProductDialogComponent implements OnInit {<br/>    ...<br/>}<br/><br/>@Component({<br/>    selector: 'jhi-product-popup',<br/>    template: ''<br/>})<br/>export class ProductPopupComponent implements OnInit, OnDestroy {<br/>    ...<br/>}</pre>
<div>
<p><kbd>ProductDetailComponent</kbd> <span>handles the detail view screen using </span><kbd>product-detail.component.html</kbd> <span>as the template and is defined in </span><kbd>product-detail.component.ts</kbd>.</p>
</div>
<p><kbd>ProductDeleteDialogComponent</kbd> <span><span>and </span></span><kbd>ProductDeletePopupComponent</kbd> <span>defined in </span><kbd>product-delete-dialog.component.ts</kbd> <span>manages the delete popup dialog using </span><kbd>product-delete-dialog.component.html</kbd> <span>as the template.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Angular route for the entity</h1>
                </header>
            
            <article>
                
<p>We need a route declaration so that we can access the entity pages. This is declared in <kbd>product.route.ts</kbd><span class="packt_screen">.</span></p>
<p>For example, this declares the detail view of the entity:</p>
<pre>    {<br/>        path: 'product/:id',<br/>        component: ProductDetailComponent,<br/>        data: {<br/>            authorities: ['ROLE_USER'],<br/>            pageTitle: 'storeApp.product.home.title'<br/>        },<br/>        canActivate: [UserRouteAccessService]<br/>    }</pre>
<p>The data attribute is used to pass metadata <span>such as </span>allowed roles and page titles to the component. The <kbd>UserRouteAccessService</kbd> defined in the <kbd>canActivate</kbd> attribute decides whether a user has the authorization to view the page and uses the authorities metadata and authentication details to verify. Routes having a popup, declares the <kbd>outlet: 'popup'</kbd> attribute.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Angular module for the entity</h1>
                </header>
            
            <article>
                
<p>Finally, we have a module for the entity. Angular modules can be used to consolidate all components, directives, pipes, and services of an entity so that they can be imported into other modules easily. The<span> </span><kbd>StoreProductModule</kbd><span> </span>module is defined in <kbd>product.module.ts</kbd>:</p>
<pre>@NgModule({<br/>    imports: [<br/>        StoreSharedModule,<br/>        RouterModule.forChild(ENTITY_STATES)<br/>    ],<br/>    declarations: [<br/>        ProductComponent,<br/>        ProductDetailComponent,<br/>        ProductDialogComponent,<br/>        ProductDeleteDialogComponent,<br/>        ProductPopupComponent,<br/>        ProductDeletePopupComponent,<br/>    ],<br/>    entryComponents: [<br/>        ProductComponent,<br/>        ProductDialogComponent,<br/>        ProductPopupComponent,<br/>        ProductDeleteDialogComponent,<br/>        ProductDeletePopupComponent,<br/>    ],<br/>    providers: [<br/>        ProductService,<br/>        ProductPopupService,<br/>        ProductResolvePagingParams,<br/>    ],<br/>    schemas: [CUSTOM_ELEMENTS_SCHEMA]<br/>})<br/>export class StoreProductModule {}</pre>
<p>The module declares the components and registers services provided by it. The module also imports shared modules so that it can access shared services and components. The module is imported by the <kbd>StoreEntityModule</kbd> defined in <kbd>entity.module.ts</kbd> under <kbd>src/main/webapp/app/entities</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generated pages</h1>
                </header>
            
            <article>
                
<p>Let's start the application to view the generated pages. In the Terminal, execute the Gradle command the follows:</p>
<pre><strong>&gt; ./gradlew</strong></pre>
<p>This will start the server in development mode locally. Since the <kbd>import-jdl</kbd> step already compiled the frontend code, we don't have to run <kbd>yarn start</kbd> just to see the new pages, but please note that for further development it is better to use <kbd>yarn start</kbd> along with the preceding command. If you had the server already running while generating the entities, then no need to run this command, instead just compile the source again using the <kbd>./gradlew compileJava</kbd> command. Using your IDE and Spring devtools will hot reload the application for you. If you had <kbd>yarn start</kbd> running then a hot reload will take place on the client side as well, otherwise, it will just refresh the page. We will see more about hot reloading in the next chapter.</p>
<p>Once you see the following message, the server is ready and we can navigate to the URL <kbd>http://localhost:8080</kbd> in our favorite browser:</p>
<pre><strong>----------------------------------------------------------</strong><br/><strong>        Application 'store' is running! Access URLs:</strong><br/><strong>        Local: http://localhost:8080</strong><br/><strong>        External: http://192.168.2.7:8080</strong><br/><strong>        Profile(s): [swagger, dev]</strong><br/><strong>----------------------------------------------------------</strong></pre>
<p>If you are not already logged in, sign in using the default admin user with the password <kbd><span>admin</span></kbd><span> </span>by clicking on the <span class="packt_screen">Sign in</span> link on the home page. Once logged in, click on the <span class="packt_screen">Entities</span> link in the menu and you will see all our entities listed there:</p>
<div class="CDPAlignCenter CDPAlign"><img height="211" src="assets/8bfb4e57-74ce-4d6d-816b-4ba5702bb321.png" width="266"/></div>
<p>Click on the <span class="packt_screen">Product</span> and you will see the <span><span class="packt_screen">Products</span></span> listing screen. It doesn't have any items yet as we haven't created any:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/202a2acd-6872-49dd-94b6-1f84b625a5b0.png"/></div>
<p>Let's create an entity, click on the <span class="packt_screen">Create a new Product</span> button on the screen and you will see the <span class="packt_screen">Create or edit a Product</span> popup dialog:</p>
<div class="CDPAlignCenter CDPAlign"><img height="515" src="assets/43c697e8-5b03-455d-9f97-80897e761feb.png" width="506"/></div>
<p>Enter <kbd>Name</kbd>, <kbd>Description</kbd>, <kbd>Price</kbd>, and <kbd>Size</kbd>. Choose an image by clicking on the <span class="packt_screen">Choose file</span> button. Don't worry about <span class="packt_screen">Product Category</span> as we haven't created any yet. Now click on <span class="packt_screen">Save</span> and the popup will disappear and the listing screen will be refreshed with the success message:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/117792dc-54ac-46cb-9a11-656c4191fec6.png"/></div>
<p>The <span class="packt_screen">Products</span> screen now shows our new entity with buttons for <span class="packt_screen">View</span>, <span class="packt_screen">Edit</span>, and <span class="packt_screen">Delete</span>. There are also pagination links on the bottom. Explore the<span> </span><span class="packt_screen">View</span><span>, </span><span class="packt_screen">Edit</span>,<span> and </span><span class="packt_screen">Delete</span> buttons by clicking on each of them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running generated tests</h1>
                </header>
            
            <article>
                
<p>Let's run all the tests to make sure the generated test code works fine.</p>
<p>Let's run the server-side unit/integration tests, client-side Karma unit tests, and Protractor e2e tests using the command-line. In a new Terminal, navigate to the application source folder and execute these commands. They should finish with a success message. Make sure you have the application running, as e2e tests will need it. If the application is not running first start it by running <kbd>./gradlew</kbd> in a Terminal:</p>
<pre><strong>&gt; ./gradlew test &amp;&amp; yarn test &amp;&amp; yarn e2e</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p><span>In this chapter, we saw how to model and create entities using JDL. We also walked through important aspects of the created source code. We also browsed through the created entity modules and saw them in action. In the next chapter, we will see how we can utilize JHipster to further develop the application and include specific business logic and tweaks. We will also learn about some of the technologies used in more depth.</span></p>


            </article>

            
        </section>
    </body></html>