- en: '*Chapter 5*: Building a Personal Shopping List Application Using Context and
    Hooks'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: State management is a very important part of modern web and mobile applications
    and is something that React is very good at. Handling state management in React
    applications can be quite confusing, as there are multiple ways you can handle
    the current state of your application. The projects you created in the first four
    chapters of this book didn't focus on state management too much, something that
    will be investigated much more in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will show how you can handle state management in React by creating
    an application state that is accessible from every component. Before React v16.3,
    you needed third-party packages to handle state in React, but with the renewed
    version of the context API, this is no longer mandatory. Also, with the release
    of React Hooks, more ways to mutate this Context were introduced. Using an example
    application, the methods for handling state management for your application are
    demonstrated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the context API for state management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutating Context with Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code splitting with React Suspense
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will build a personal shopping list by adding state management
    using Context and Hooks. We will advance upon a boilerplate application that has
    been created with Create React App and has declarative routing using `react-router`.
    Also, code splitting of the bundle is added with React Suspense.
  prefs: []
  type: TYPE_NORMAL
- en: The build time is 2.5 hours.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The project that we''ll create in this chapter builds upon an initial version
    that you can find on GitHub: [https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter05-initial](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter05-initial).
    The complete source code can also be found on GitHub: [https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: After downloading the initial application, make sure that you run `npm install`
    from the project's root directory. This project is created using Create React
    App and installs the `react`, `react-dom`, `react-scripts`, `styled-components`,
    and `react-router-dom` packages, which you've already seen in previous chapters.
    After finishing the installation process, you can run `npm start` from the same
    tab in Terminal and view the project in your browser (`http://localhost:3000`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial application for this section is created with Create React App and
    has routing and data fetching already implemented. When you open the application,
    a screen displaying a header, a navigation bar, and two lists are being rendered.
    If, for example, you click on the first list that is displayed here, a new page
    will open that displays the items of this list. On this page, you can click on
    the **Add Item** button in the top-right corner to open a new page, which has
    a form to add a new list and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The initial application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.1_B17390.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – The initial application
  prefs: []
  type: TYPE_NORMAL
- en: This form is rendered by the `ListForm` component and has no functionality yet,
    as you'll add this later on. When you click on the left button, it redirects you
    to the previously visited page, using the navigate method from `react-router-dom`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When you try to submit the form to either add a new list or add a new item to
    a list, nothing happens yet. The functionality of these forms will be added in
    this section later on, for which you'll use the Context API and React Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: The project is structured in the same manner as the applications you've created
    before. A distinction is made, however, between reusable function components in
    the `components` directory and components that represent a route in the `pages`
    directory. The page components are using the `useDataFetching` Hook, which we
    saw earlier in [*Chapter 3*](B17390_03_Final_NM_ePub.xhtml#_idTextAnchor039),
    *Building a Dynamic Project Management Board*, which adds data fetching.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an overview of the complete structure of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The entry point of this application is the `src/index.js` file that renders
    the `App` component, which sets up routing using a `Router` component from `react-router-dom`.
    The `App` component contains a `Header` component and a `Switch` router component
    that defines four routes. These routes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/`: Renders `Lists`, with an overview of all of the lists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/list/:listId`: Renders `ListDetail`, with an overview of all items from a
    specific list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/list/:listId/new`: Renders `ListForm`, with a form to add new items to a
    specific list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The data is fetched from a mock server that was created using the free service,
    My JSON Server, which creates a server from the `db.json` file in the root directory
    of your project in GitHub. This file consists of a JSON object that has two fields,
    `items` and `lists`, which creates multiple endpoints on a mock server. The ones
    you''ll be using in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/items](https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/items)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/lists](https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/lists)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `db.json` file must be present in the master branch (or default branch)
    of your GitHub repository for My JSON Server to work. Otherwise, you'll receive
    a **404 Not Found** message when trying to request the API endpoints.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Personal shopping list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll build a personal shopping list application that has
    state management using Context and Hooks. With this application, you can create
    shopping lists that you can add items to, along with their quantities and prices.
    The starting point of this section is an initial application that has routing
    and local state management already enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Context API for state management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: State management is very important, as the current state of the application
    holds data that is valuable to the user. In previous chapters, you've already
    used local state management by using `useState` and `useEffect` Hooks. This pattern
    is very useful when the data in the state is only of importance to the components
    you're setting the state in. As passing down the state as props through several
    components can become confusing, you'd need a way to access props throughout your
    application even when you're not specifically passing them as props. For this,
    you can use the Context API from React, which is also used by packages you've
    already used in previous chapters such as `styled-components` and `react-router-dom`.
  prefs: []
  type: TYPE_NORMAL
- en: To share state across multiple components, a React feature called Context will
    be explored, starting in the first part of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you want to add Context to your React application, you can do this by creating
    a new Context with the `createContext` method from React. This creates a Context
    object that consists of two React components, called Provider and Consumer. The
    Provider is where the initial (and subsequently current) value of the Context
    is placed, which can be accessed by components that are present within the Consumer.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done in the `App` component in `src/App.js`, as you want the Context
    for the lists to be available in every component that is rendered by `Route`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a Context for the lists and making it exportable so
    that the list data can be used everywhere. For this, you can create a new file
    called `ListsContext.js` inside a new directory, `src/context`. In this file,
    you can add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The previous code creates a Provider based on a `Context` object that is passed
    as a prop and sets a value based on the return from the `useDataFetching` Hook
    that is fetching all of the lists. Using the `children` prop, all of the components
    that will be wrapped inside the `ListsContextProvider` component can retrieve
    the data for the value from a Consumer.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `ListsContextProvider` component can be imported inside your `App` component
    to wrap the Router component that is wrapping all the routes for our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This way, you''re now able to consume the value from the Provider for `ListsContext`,
    from all the components wrapped within `ListsContextProvider`. In the `Lists`
    component, this data can be retrieved using the `useContext` Hook from React by
    passing the `ListsContext` object to it. This data can then be used to render
    the lists, and the `useDataFetching` Hook can be removed from `src/pages/Lists.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that you've removed the `useDataFetching` Hook from `Lists`, no requests
    to the API are sent directly from this component anymore. The data for the lists
    is instead fetched from `ListsContextProvider` and is passed by `ListsContext`,
    which is used by the `useContext` Hook in `Lists`. If you open the application
    in the browser by going to `http://localhost:3000/`, you can see the lists are
    being rendered just as before.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you'll also add a Context object for the items, so the
    items are also available to all of the components within the Routes component
    from `react-router`.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting Context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as for the list data, the item data could also be stored in Context and
    passed to the components that need this data. That way, data is no longer fetched
    from any of the rendered components but from the Context only:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, start by creating a new file where both a Context and Provider are created.
    This time, it''s called `ItemsContext.js`, which can also be added to the `src/context`
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, import this new Context and Provider in `src/App.js`, where you can nest
    this below the `ListsContextProvider` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `ListDetail` component can now get the item from `ItemsContext`, meaning
    we no longer have to use the `useDataFetching` Hook in this component. To accomplish
    this, you need to make the following changes to `src/pages/ListDetail.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All of the data fetching is now no longer by the `List` and `Lists` components.
    By nesting these Context Providers, the return values can be consumed by multiple
    components. But this still isn't ideal, as you're now loading all of the lists
    and all of the items when starting your application.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of this approach is that once we open a detail page for a list,
    it will retrieve all items, even if they are not for this list. In the next section,
    you'll see how to get only the data you need by combining Context with custom
    Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Mutating Context with Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple ways in which you can get data conditionally from the Context;
    one of these is placing the data from the Context in the local state. That could
    be a solution for a smaller application, but can be inefficient for larger applications,
    as you'd still need to pass this state down your component tree. Another solution
    is to use React Hooks to create a function that is added to the value of your
    Context and can be invoked from any of the components that are nested in this
    Context. Also, this method of getting the data lets you efficiently load only
    the data that you'd need.
  prefs: []
  type: TYPE_NORMAL
- en: How this can be used together with React life cycles and state management using
    Hooks is demonstrated in the first part of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Using life cycles in functional components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Previously, we used the `useDataFetching` Hook to do the data fetching for
    us, but this doesn''t let us control when the data will be fetched exactly. From
    the components that are consuming our Context data, we want to be able to initiate
    the data fetching. Therefore we need to add life cycles to them, which invoke
    a function to do the data fetching inside our Context components. Follow these
    steps to implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in achieving this is by adding logic to do data fetching in
    the `src/context/ItemsContext.js` file. This logic will replace the usage of the
    `useDataFetching` Hook, starting with adding local state variables for the data
    fetching state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After this, we can add a function called `fetchItems` that we pass to `ItemsContextProvider`,
    meaning it will be added to the Context. This function is wrapped in a `useCallback`
    Hook to prevent unneeded (re)renders of your component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this function in place, the next step would be to invoke it with a value
    for `listId` from the `ListDetail` component. This would mean that we no longer
    retrieve all the items once we load this component, but use the params from the
    URL to determine what data should be fetched and added to the Context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding `useEffect` Hooks call the `fetchItems` function when there's
    a `listId` present in the URL of the page, and when the value for `items` is an
    empty array. This prevents us from fetching the items again if they already exist
    in `ItemsContext`.
  prefs: []
  type: TYPE_NORMAL
- en: By creating a function to do data fetching in our Context, we can now control
    when the data should be fetched, so there will no longer be unnecessary requests
    to the API. But other Hooks can also directly pass data to the Provider without
    having to duplicate `useState` Hooks. This will be demonstrated in the next part
    of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Using advanced state with useReducer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to use actions for adding data to the Provider is by using a pattern
    similar to Flux, which was introduced by Facebook. The Flux pattern describes
    a data flow where actions are being dispatched that retrieve data from a store
    and return it to the view. This would mean that actions need to be described somewhere;
    there should be a central place where data is stored and this data can be read
    by the view. To accomplish this pattern with the Context API, you can use another
    Hook, called `useReducer`. This Hook can be used to return data not from a local
    state, but from any data variable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with the `useState` Hook, the `useReducer` Hook needs to be added to
    the component that is using it. `useReducer` will take an initial state and a
    function that determines which data should be returned. This initial value needs
    to be added to the `src/context/ListsContext.js` file before adding the Hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next to an initial value, the `useReducer` Hook also takes a function that''s
    called `reducer`. This `reducer` function should also be created and is a function
    that updates `initialState`, which was passed and returns the current value, based
    on the action that was sent to it. If the action that was dispatched doesn''t
    match any of those defined in `reducer`, the reducer will just return the current
    value without any changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The two parameters for the `useReducer` Hook are now added to the file, so
    you need to add the actual Hook and pass `initialState` and `reducer` to it. The
    `useDataFetching` Hook can be removed, as this will be replaced with a new function
    that has data fetching logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, `reducer` changes the value it returns when the `GET_LISTS_SUCCESS`
    or `GET_LISTS_ERROR` action is sent to it. Before it was mentioned, you can call
    this `reducer` by using the `dispatch` function that was returned by the `useReducer`
    Hook. However, as you also have to deal with the asynchronous fetching of the
    data, you can''t invoke this function directly. Instead, you need to create an
    `async/await` function that calls the `fetchData` function and dispatches the
    correct action afterward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding `fetchLists` function calls the API and if there is a result,
    the `GET_LISTS_SUCCESS` action will be dispatched to the reducer using the `dispatch`
    function from the `useReducer` Hook. If not, the `GET_LISTS_ERROR` action will
    be dispatched, which returns an error message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The values from the state and the `fetchLists` function must be added to the
    Provider so that we can access them from other components through the Context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This `getLists` function can now be invoked from the `useEffect` Hook in the
    component where the lists are displayed, the `Lists` component, on the first render.
    The lists should only be retrieved when there aren''t any lists available yet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you now visit the project in the browser again, you can see the data from
    the lists is loaded just as before. The big difference is that the data is fetched
    using a Flux pattern, meaning this can be extended to fetch the data in other
    instances as well. The same can be done for `ItemsContext` as well, in the `src/context/ItemsContext.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the `useReducer` Hook, and add the initial value for the items
    and the `reducer` function that we use with this Hook later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After this, you can add the initial state and reducer to the `useReducer` Hook.
    The `fetchItems` function that already exists in this file must be changed so
    that it will use the `dispatch` function from `useReducer` instead of the `update`
    functions from the `useState` Hooks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, add the state and the `fetchItems` function to `ListsContextProvider`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you were to open a specific list on the `/lists/:listId` route, for example,
    `http://localhost:3000/list/1`, you would see that nothing has changed and that
    the items for the list are still displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might notice that the title of the list isn''t displayed here. The information
    for the lists is only fetched when the `Lists` component is first rendered, so
    you''d need to create a new function to always fetch the information for the list
    that you''re currently displaying in the `List` component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `src/context/ListsContextProvider.js` file, you need to extend `initialState`
    to also have a field called `list`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `reducer`, you also now have to check for two new actions that either add
    the data about a list to the context or add an error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These actions will be dispatched from a new `fetchList` function that takes
    the specific ID of a list to call the API. If successful, the `GET_LIST_SUCCESS`
    action will be dispatched; otherwise, the `GET_LIST_ERROR` action is dispatched.
    Also, pass the function to the Provider so that it can be used from other components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And, in the `ListDetail` component, we can get the list data from `ListsContext`
    by calling the `fetchList` function in a `useEffect` Hook. Also, pass it as a
    prop to the `NavBar` component so that it will be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the previous code block, we're calling the `fetchList` function from a different
    `useEffect` Hook than the `fetchItems` function. This is a good way to separate
    concerns to keep our code clean and concise.
  prefs: []
  type: TYPE_NORMAL
- en: All of the data in your application is now being loaded using the Providers,
    which means it's now detached from the views. Also, the `useDataFetching` Hook
    is completely removed, making your application structure more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Not only can you use the context API with this pattern to make data available
    to many components, but you can also mutate the data. How to mutate this data
    will be shown in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Mutating data in the Provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Not only can you retrieve data using this Flux pattern, but you can also use
    it to update data. The pattern remains the same: you dispatch an action that would
    trigger the request to the server and, based on the outcome, the reducer will
    mutate the data with this result. Depending on whether or not it was successful,
    you could display a success message or an error message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code already has a form for adding a new item to a list—something that
    is not working yet. Let''s create the mechanism to add items by updating the Provider
    for `items`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to add new actions to the reducer in `ItemsContext`, which
    will be dispatched once we try to add a new item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to add a new function that can handle `POST` requests, as this
    function should also set the method and a body when handling the `fetch` request.
    You can create this function in the preceding file as well, and pass it to the
    Provider:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As the function to add a new item to a list is now available from the Provider,
    the `ListForm` component in `src/pages/ListForm.js` is now able to use the `addItem`
    function, which will dispatch the action that will call the API and add the item
    to the state. However, the values of the input fields in the form need to be determined
    first. Therefore, the input fields need to be controlled components, meaning their
    value is controlled by the local state that encapsulates the value. Therefore
    we need to import the `useState` Hook and also a `useContext` Hook, which we''ll
    use later to get values from the Context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For this, we used the `useState` Hook for every `state` value that we created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The local state values and the function that triggers an update of the local
    state values must be set as a prop on the `FormItem` components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last thing you need to do now is to add a function that will be dispatched
    when the form is submitted by clicking the submit button. This function takes
    `value` for the local state, adds information about the item, and uses this to
    call the `addItem` function. After this function is called, the navigate function
    from `useNavigate` is called to go back to the overview for this list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you now submit the form, a `POST` request to the mock server will be sent.
    You'll be sent back to the previous page where you can see the result. If successful,
    the `GET_LIST_SUCCESS` action was dispatched and the item you inserted was added
    to the list.
  prefs: []
  type: TYPE_NORMAL
- en: So far, the information from the Context has been used only separately by using
    the Providers, but this can also be combined into one application Context, as
    shown in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you look at the current structure of the routes in your `App` component,
    you can imagine that this will get messy if you add more Providers and Consumers
    to your application. State management packages such as Redux tend to have an application
    state where all of the data for the application is stored. When using Context,
    it''s possible to create an application Context that can be accessed using the
    `useContext` Hook. This Hook acts as a Consumer and can retrieve values from the
    Provider of the Context that was passed to it. Let''s refactor the current application
    to have an application Context:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a file called `AppContext.js` in the `src/context` directory.
    This file will import both `ListsContextProvider` and `ItemsContextProvider`,
    nest them, and have them wrap any component that will be passed to it as a `children`
    prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `src/App.js` file, we can now import this `AppContext` file in favor
    of the Providers for the lists and items and replace `ListsContextProvider` and
    `ItemsContextProvider` with `AppContext`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `AppContext` component can be extended with all of the Context objects that
    you might want to add in the future. Our application now has a much cleaner structure,
    while the data is still being retrieved by the Providers.
  prefs: []
  type: TYPE_NORMAL
- en: Code splitting with React Suspense
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've focused mostly on adding new features, such as routing or state
    management, to our application. But not much focus has been devoted to making
    our application more performant, something that we can do with code splitting.
    A React feature called Suspense can be used for code splitting, which means you
    split the compiled code (your bundle) into smaller chunks. This will prevent the
    browser from downloading the entire bundle with your compiled code at once, and
    instead load your bundle in chunks depending on the components that are rendered
    by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we used Next.js instead of Create React App to create
    our React application, which has code splitting enabled by default.
  prefs: []
  type: TYPE_NORMAL
- en: Suspense lets your components wait until the component you're importing is ready
    to be displayed. Before React 18 it could only be used for code splitting, but
    since the latest version of React it serves more purposes. When you fetch data
    from a component that is imported with Suspense, React will also wait until the
    data for that component is completely fetched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suspense must be used together with the lazy method, which involves using JavaScript
    dynamic imports to load the component only when requested. Both methods can be
    imported from React in `src/App.js`, where the lazy method is used to import the
    components for our pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `return` statement for the `App` component, Suspense must be used with
    a fallback that will be displayed when the dynamically imported components are
    being loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When you look at the application in the browser, you don't see any changes,
    unless you have a slow internet connection. In that case, the fallback for Suspense
    will be displayed while the component is being loaded. However, when you open
    the `bundle.js` and `main.chunk.js`. However, after applying code splitting, chunked
    components are also being loaded, for example, `src_pages_ListDetail_js.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – The network requests for our application after code splitting'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.2_B17390.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – The network requests for our application after code splitting
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the main route, which is `/`, we can see that a chunk named `3.chunk.js`
    is loaded. This isn''t a very helpful filename, something we can change with `webpackChunkName`
    in an inline comment. With this addition, we can instruct webpack to name the
    file something more user friendly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This latest addition makes recognizing which chunks (or components) are loaded
    in our application much easier, as you can see by reloading the application in
    the browser and checking the Network tab again.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you've created a shopping list application that uses the Context
    API and Hooks to pass and retrieve data. Context is used to store data and Hooks
    are used to retrieve and mutate data. With the Context API, you can create more
    advanced scenarios for state management using the `useReducer` Hook. Context is
    also used to create a situation where all of the data is stored application-wide
    and can be accessed from any component by creating a shared Context. Finally,
    we've used React Suspense to apply code splitting to our bundle for improved performance.
  prefs: []
  type: TYPE_NORMAL
- en: The Context API will be used in the next chapter as well, which will show you
    how to build a hotel review application with automated testing using libraries
    such as Jest and Enzyme. It will introduce you to the multiple ways in which you
    can test your UI components created with React, and also show you how to test
    state management in your application using the Context API.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consuming multiple Context objects: [https://reactjs.org/docs/context.html#consuming-multiple-contexts](https://reactjs.org/docs/context.html#consuming-multiple-contexts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'React Suspense: [https://reactjs.org/docs/react-api.html#reactsuspense](https://reactjs.org/docs/react-api.html#reactsuspense)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
