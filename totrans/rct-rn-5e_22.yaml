- en: '20'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '20'
- en: Rendering Item Lists
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染项目列表
- en: In this chapter, you’ll learn how to work with item lists. Lists are a common
    web application component. While it’s relatively straightforward to build lists
    using the `<ul>` and `<li>` elements, doing something similar on native mobile
    platforms is much more involved.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何处理项目列表。列表是常见的Web应用程序组件。虽然使用`<ul>`和`<li>`元素构建列表相对简单，但在本地移动平台上做类似的事情要复杂得多。
- en: Thankfully, React Native provides an **item list** interface that hides all
    of the complexity. First, you’ll get a feel for how item lists work by walking
    through an example. Then, you’ll learn how to build controls that change the data
    displayed in lists. Lastly, you’ll see a couple of examples that fetch items from
    the network.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，React Native提供了一个**项目列表**接口，隐藏了所有的复杂性。首先，你将通过浏览一个示例来了解项目列表的工作方式。然后，你将学习如何构建更改列表中显示的数据的控件。最后，你将看到几个从网络获取项目的示例。
- en: 'We’ll cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Rendering data collections
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染数据集合
- en: Sorting and filtering lists
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序和过滤列表
- en: Fetching list data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取列表数据
- en: Lazy list loading
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒加载列表
- en: Implementing pull to refresh
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现下拉刷新
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter20](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter20).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的代码文件，地址为[https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter20](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter20)。
- en: Rendering data collections
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染数据集合
- en: '**Lists** are the most common way to display a lot of information: for example,
    you can display your friend list, messages, and news. Many apps contain lists
    with data collections, and React Native provides the tools to create these components.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表**是显示大量信息最常见的方式：例如，你可以显示你的朋友列表、消息和新闻。许多应用程序包含具有数据集合的列表，React Native提供了创建这些组件的工具。'
- en: Let’s start with an example. The React Native component you’ll use to render
    lists is `FlatList`, which works the same way on iOS and Android. List views accept
    a `data` property, which is an array of objects. These objects can have any properties
    you like, but they do require a `key` property. If you don’t have a `key` property,
    you can pass the `keyExtractor` prop to the `Flatlist` component and instruct
    what to use instead of `key`. The `key` property is similar to the requirement
    for rendering the `<li>` elements inside of a `<ul>` element. This helps the list
    to efficiently render when changes are made to list data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从示例开始。你将使用React Native组件`FlatList`来渲染列表，它在iOS和Android上工作方式相同。列表视图接受一个`data`属性，它是一个对象数组。这些对象可以具有你喜欢的任何属性，但它们确实需要一个`key`属性。如果你没有`key`属性，你可以将`keyExtractor`属性传递给`Flatlist`组件，并指示使用什么代替`key`。`key`属性类似于在`<ul>`元素内部渲染`<li>`元素的要求。这有助于列表在列表数据更改时高效渲染。
- en: 'Let’s implement a basic list now. Here’s the code to render a basic 100-item
    list:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来实现一个基本的列表。以下是渲染一个包含100项的基本列表的代码：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s walk through what’s going on here, starting with the `data` constant.
    This has an array of 100 items in it. It is created by filling in a new array
    with 100 `null` values and then mapping this to a new array with the objects that
    you want to pass to `<FlatList>`. Each object has a `key` property because this
    is a requirement; anything else is optional. In this case, you’ve decided to add
    a `value` property that will be used later when the list is rendered.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解这里发生的事情，从`data`常量开始。它包含一个100项的数组。这是通过填充一个包含100个`null`值的新数组，然后将其映射到一个新数组，该数组包含要传递给`<FlatList>`的对象来创建的。每个对象都有一个`key`属性，因为这是一个要求；其他任何内容都是可选的。在这种情况下，你决定添加一个`value`属性，该属性将在列表渲染时使用。
- en: Next, you render the `<FlatList>` component. It’s within a `<View>` container
    because list views need height in order to make scrolling work correctly. The
    `data` and `renderItem` properties are passed to `<FlatList>`, which ultimately
    determines the rendered content.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将渲染`<FlatList>`组件。它位于`<View>`容器中，因为列表视图需要高度才能正确工作。`data`和`renderItem`属性被传递给`<FlatList>`，这最终决定了渲染的内容。
- en: 'At first glance, it seems like the `FlatList` component doesn’t do too much.
    Do you have to figure out how the items look? Well, yes, the `FlatList` component
    is supposed to be generic. It’s supposed to excel at handling updates and embeds
    scrolling capabilities into lists for us. Here are the styles that were used to
    render the list:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，`FlatList`组件似乎并没有做太多。您是否需要弄清楚项的外观？嗯，是的，`FlatList`组件应该是通用的。它应该擅长处理更新，并将滚动功能嵌入到列表中。以下是用于渲染列表的样式：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, you’re styling each item on your list. Otherwise, each item would be text-only,
    and it would be difficult to differentiate between other list items. The `container`
    style gives the list height by setting `flex` to `1`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您正在为列表中的每个项设置样式。否则，每个项都将是纯文本，这将很难区分其他列表项。`container`样式通过将`flex`设置为`1`来设置列表的高度。
- en: 'Let’s see what the list looks like now:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看现在列表看起来像什么：
- en: '![Picture 1](img/B19636_20_01.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片 1](img/B19636_20_01.png)'
- en: 'Figure 20.1: Rendering the data collection'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.1：渲染数据集合
- en: If you’re running this example in a simulator, you can click and hold down the
    mouse button anywhere on the screen, like a finger, and then scroll up and down
    through the items.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在模拟器中运行此示例，您可以在屏幕上的任何地方单击并按住鼠标按钮，就像用手指一样，然后上下滚动通过项。
- en: In the following section, you’ll learn how to add controls for sorting and filtering
    lists.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何添加排序和过滤列表的控件。
- en: Sorting and filtering lists
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序和过滤列表
- en: 'Now that you have learned the basics of the `FlatList` components, including
    how to pass data, let’s add some controls to the list that you just implemented
    in the *Rendering data collections* section. The **FlatList** component can be
    rendered together with other components: for example, list controls. It helps
    you to manipulate the data source, which ultimately drives what’s rendered on
    the screen.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学习了`FlatList`组件的基础知识，包括如何传递数据，让我们向在*渲染数据集合*部分实现的列表添加一些控件。`FlatList`组件可以与其他组件一起渲染：例如，列表控件。它帮助您操作数据源，这最终决定了屏幕上渲染的内容。
- en: 'Before implementing list control components, it might be helpful to review
    the high-level structure of these components so that the code has more context.
    Here’s an illustration of the component structure that you’re going to implement:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现列表控制组件之前，回顾这些组件的高级结构可能会有所帮助，这样代码就有更多的上下文。以下是您将要实现的组件结构的示意图：
- en: '![Picture 2](img/B19636_20_02.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2](img/B19636_20_02.png)'
- en: 'Figure 20.2: The component structure'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.2：组件结构
- en: 'Here’s what each of these components is responsible for:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些组件负责的内容如下：
- en: '`ListContainer`: The overall container for the list; it follows the familiar
    React container pattern'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListContainer`：列表的整体容器；它遵循熟悉的React容器模式'
- en: '`List`: A stateless component that passes the relevant pieces of state into
    `ListControls` and the React Native `ListView` component'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List`：一个无状态组件，将相关的状态片段传递给`ListControls`和React Native的`ListView`组件'
- en: '`ListControls`: A component that holds the various controls that change the
    state of the list'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListControls`：一个组件，它包含各种控件，这些控件可以更改列表的状态'
- en: '`ListFilter`: A control for filtering the item list'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListFilter`：用于过滤项目列表的控件'
- en: '`ListSort`: A control for changing the sort order of the list'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListSort`：用于更改列表排序顺序的控件'
- en: '`FlatList`: The actual React Native component that renders items'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FlatList`：实际渲染项的React Native组件'
- en: In some cases, splitting apart the implementation of a list like this is overhead.
    However, I think that if your list needs controls in the first place, you’re probably
    implementing something that will stand to benefit from having a well-thought-out
    component architecture.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，将列表的实现拆分开来可能会增加开销。然而，我认为如果您的列表需要控件，那么您可能正在实现一些将从良好的组件架构中受益的东西。
- en: 'Now, let’s drill down into the implementation of this list, starting with the
    **ListContainer** component:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探讨这个列表的实现，从**ListContainer**组件开始：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we define a few utility functions and the initial array that we will use.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一些实用函数和我们将使用的初始数组。
- en: 'Then, we will define `asc` and `filter` for managing sorting and filtering
    the list, respectively, with the `data` variable implemented using the `useMemo`
    hook:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将定义`asc`和`filter`来管理排序和过滤列表，分别使用`useMemo`钩子实现的`data`变量：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It gives us an opportunity to avoid updating it manually because it will be
    recalculated automatically when the `filter` and `asc` dependencies are updated.
    It also helps us to avoid unnecessary recalculation when `filter` and `asc` are
    not changed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 它给我们一个避免手动更新的机会，因为当`filter`和`asc`依赖项更新时，它将自动重新计算。它还有助于我们在`filter`和`asc`未更改时避免不必要的重新计算。
- en: 'This is how we apply this logic to the `List` component:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将此逻辑应用于`List`组件的方式：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If this seems like a bit much, it’s because it is. This container component
    has a lot of state to handle. It also has some non-trivial behavior that it needs
    to make available to its children. If you look at it from the perspective of an
    encapsulating state, it will be more approachable. Its job is to populate the
    list with state data and provide functions that operate in this state.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来有点多，那是因为确实如此。此容器组件有很多状态要处理。它还有一些需要对其子组件提供的不平凡的行为。如果您从封装状态的角度来看，它将更容易接近。它的任务是使用状态数据填充列表，并提供在此状态下操作的功能。
- en: 'In an ideal world, the child components of this container should be nice and
    simple, since they don’t have to directly interface with the state. Let’s take
    a look at the `List` component next:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界里，此容器的子组件应该是简单而优雅的，因为它们不需要直接与状态交互。让我们看看下一个`List`组件：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This component takes the state from the `ListContainer` component as a property
    and renders a `FlatList` component. The main difference here from the previous
    example is the `ListHeaderComponent` property. This renders the controls for your
    `List` component. What’s especially useful about this property is that it renders
    the controls outside the scrollable list content, ensuring that the controls are
    always visible. Let’s take a look at the `ListControls` component next:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件将来自`ListContainer`组件的状态作为属性，并渲染一个`FlatList`组件。与上一个示例相比，这里的主要区别是`ListHeaderComponent`属性。它渲染了`List`组件的控件。这个属性特别有用，因为它在可滚动列表内容之外渲染控件，确保控件始终可见。让我们看看下一个`ListControls`组件：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This component brings together the `ListFilter` and `ListSort` controls. So,
    if you were to add another list control, you would add it here.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件将`ListFilter`和`ListSort`控件结合在一起。因此，如果您要添加另一个列表控件，您应该在这里添加。
- en: 'Let’s take a look at the `ListFilter` implementation now:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`ListFilter`的实现：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The filter control is a simple text input that filters the list of items by
    user type. The `onFilter` function that handles this comes from the `ListContainer`
    component.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 筛选控件是一个简单的文本输入，通过用户类型筛选项目列表。处理此操作的`onFilter`函数来自`ListContainer`组件。
- en: 'Let’s look at the `ListSort` component next:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一个`ListSort`组件：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here’s a look at the resulting list:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是结果的列表：
- en: '![Picture 3](img/B19636_20_03.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片3](img/B19636_20_03.png)'
- en: 'Figure 20.3: The sorting and filtering list'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.3：排序和筛选列表
- en: 'By default, the entire list is rendered in ascending order. You can see the
    placeholder **Search** text when the user hasn’t provided anything yet. Let’s
    see how this looks when you enter a filter and change the sort order:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，整个列表按升序渲染。当用户尚未提供任何内容时，您可以看到占位符**搜索**文本。让我们看看当您输入筛选器和更改排序顺序时，它看起来会是什么样子：
- en: '![Picture 4](img/B19636_20_04.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片4](img/B19636_20_04.png)'
- en: 'Figure 20.4: The list with a changed sort order and search value'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.4：排序顺序和搜索值已更改的列表
- en: This search includes items containing `1` and sorts the results in descending
    order. Note that you can either change the order first or enter the filter first.
    Both the filter and the sort order are part of the `ListContainer` state.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此搜索包括包含`1`的项，并按降序排序结果。请注意，您可以先更改顺序，然后输入筛选器。筛选器和排序顺序都是`ListContainer`状态的一部分。
- en: In the next section, you’ll learn how to fetch list data from an API endpoint.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何从API端点获取列表数据。
- en: Fetching list data
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取列表数据
- en: Commonly, you’ll fetch your list data from some API endpoint. In this section,
    you’ll learn about making API requests from React Native components. The good
    news is that the `fetch()` API is polyfilled by React Native, so the networking
    code in your mobile applications should look and feel a lot like it does in your
    web applications.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您将从某个API端点获取列表数据。在本节中，您将了解如何在React Native组件中发起API请求。好消息是，React Native已经填充了`fetch()`
    API，因此您在移动应用程序中的网络代码应该看起来和感觉就像在您的Web应用程序中一样。
- en: 'To start things off, let’s build a **mock API** for our list items using functions
    that return promises just like `fetch()` does:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为我们的列表项构建一个**mock API**，使用返回promise的函数，就像`fetch()`一样：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the mock API function in place, let’s make some changes to the `ListContainer`
    component. Instead of using local data sources, you can now use the `fetchItems()`
    function to load data from the mock API. Let’s take a look and define the `ListContainer`
    component:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在mock API函数就位后，让我们对`ListContainer`组件做一些修改。现在，你不再使用本地数据源，而是可以使用`fetchItems()`函数从mock
    API加载数据。让我们看看并定义`ListContainer`组件：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We’ve defined state variables using the `useState` and `useEffect` hooks to
    fetch initial list data.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`useState`和`useEffect`钩子定义了状态变量来获取初始列表数据。
- en: 'Now, let’s take a look at the usage of our new handlers in the `List` component:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看我们在`List`组件中新的处理器的用法：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Any action that modifies the state of the list needs to call `fetchItems()`
    and set the appropriate state once the promise resolves.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 任何修改列表状态的行动都需要在promise解析后调用`fetchItems()`并设置适当的状态。
- en: In the following section, you’ll learn how list data can be loaded lazily.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，你将学习如何懒加载列表数据。
- en: Lazy list loading
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒加载列表
- en: 'In this section, you’ll implement a different kind of list: one that scrolls
    infinitely. Sometimes, users don’t actually know what they’re looking for, so
    filtering or sorting isn’t going to help. Think about the Facebook news feed you
    see when you log in to your account; it’s the main feature of the application,
    and rarely are you looking for something specific. You need to see what’s going
    on by scrolling through the list.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将实现一种不同类型的列表：一个可以无限滚动的列表。有时，用户实际上并不知道他们在寻找什么，所以过滤或排序并不能帮助。想想当你登录账户时看到的Facebook新闻源；它是应用程序的主要功能，你很少会寻找特定的事物。你需要通过滚动列表来查看发生了什么。
- en: 'To do this using a `FlatList` component, you need to be able to fetch more
    API data when the user scrolls to the end of the list. To get an idea of how this
    works, you need a lot of API data to work with, and generators are great at this.
    So, let’s modify the mock that you created in the *Fetching list data* section’s
    example so that it just keeps responding with new data:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`FlatList`组件实现这一点，你需要能够在用户滚动到列表末尾时获取更多的API数据。为了理解这是如何工作的，你需要大量的API数据来操作，生成器在这方面非常出色。所以，让我们修改你在*获取列表数据*部分的示例中创建的mock，让它持续响应新数据：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With `fetchItems`, you can now make an API request for new data every time
    the end of the list is reached. Eventually, this will fail when you run out of
    memory, but I’m just trying to show you in general terms the approach you can
    take to implement infinite scrolling in React Native. Now, let’s take a look at
    what the `ListContainer` component looks like with `fetchItems`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fetchItems`，你现在可以在每次到达列表末尾时发起一个新的API请求以获取新数据。最终，当内存耗尽时，这将会失败，但我只是想从一般的角度展示你可以在React
    Native中实现无限滚动的方案。现在，让我们看看带有`fetchItems`的`ListContainer`组件的样子：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Each time `fetchItems()` is called, the response is concatenated with the `data`
    array. This becomes the new list data source, instead of replacing it as you did
    in earlier examples.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`fetchItems()`时，响应都会与`data`数组连接。这成为新的列表数据源，而不是像早期示例中那样替换它。
- en: 'Now, let’s take a look at the `List` component to see how to respond to the
    end of the list being reached:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看`List`组件，看看如何响应到达列表的末尾：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`FlatList` accepts the `onEndReached` handler prop, which will be invoked every
    time you reach the end of the list during scrolling.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlatList`接受`onEndReached`处理程序属性，它将在你滚动到列表末尾时被调用。'
- en: If you run this example, you’ll see that, as you approach the bottom of the
    screen while scrolling, the list just keeps growing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个示例，你会看到，当你滚动到屏幕底部时，列表会不断增长。
- en: Implementing pull to refresh
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现下拉刷新
- en: The **pull-to-refresh** gesture is a common action on mobile devices. It allows
    users to refresh the content of a view without having to lift a finger from the
    screen or manually reopen the app, just by pulling it down to trigger a page refresh.
    Loren Brichter, the creator of Tweetie (later Twitter for iPhone) and Letterpress,
    introduced this gesture in 2009\. This gesture has become so popular that Apple
    integrated it into its SDKs as `UIRefreshControl`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**下拉刷新**手势是移动设备上的一种常见操作。它允许用户在不离开屏幕或手动重新打开应用的情况下，只需下拉即可刷新视图内容，从而触发页面刷新。Tweetie（后来成为iPhone上的Twitter）和Letterpress的创造者Loren
    Brichter在2009年引入了这一手势。这一手势变得如此流行，以至于苹果将其集成到其SDK中，作为`UIRefreshControl`。'
- en: 'To use pull to refresh in the `FlatList` app, we just need to pass a few props
    and handlers. Let’s take a look at our `List` component:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`FlatList`应用中使用下拉刷新，我们只需传递一些属性和处理器。让我们看看我们的`List`组件：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we have provided the `onRefresh` and `refreshing` props, our `FlatList` component
    automatically enables the pull-to-refresh gesture. The `onRefresh` handler will
    be called when you pull the list, and the refreshing property will enable the
    loading spinner to reflect the loading state.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们提供了`onRefresh`和`refreshing`属性，我们的`FlatList`组件自动启用了下拉刷新手势。当你下拉列表时，将调用`onRefresh`处理器，而`refreshing`属性将启用加载指示器以反映加载状态。
- en: 'To apply defined props in the `List` component, let’s implement the `refreshItems`
    function with the `isRefreshing` state in the `ListContainer` component:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`List`组件中应用定义的属性，让我们在`ListContainer`组件中实现带有`isRefreshing`状态的`refreshItems`函数：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In `refreshItems`, as well as in the `fetchItems` method, we get list items
    but save them as a new list. Also, note that before calling the API, we update
    the `isRefreshing` state to set it as a `true` value, and in the final block,
    we set it to `false` to provide information to `FlatList` that loading has ended.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在`refreshItems`以及`fetchItems`方法中，我们获取列表项，但将它们保存为一个新的列表。此外，请注意，在调用API之前，我们更新`isRefreshing`状态将其设置为`true`值，并在最后的代码块中将其设置为`false`，以向`FlatList`提供信息，表明加载已完成。
- en: Summary
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the `FlatList` component in React Native.
    This component is general-purpose, as it doesn’t impose any specific look on the
    items that get rendered. Instead, the appearance of the list is up to you, leaving
    the `FlatList` component to help with efficiently rendering a data source. The
    `FlatList` component also provides a scrollable region for the items it renders.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了React Native中的`FlatList`组件。这个组件是通用的，因为它不对渲染的项目外观施加任何特定的要求。相反，列表的外观由你决定，让`FlatList`组件帮助高效地渲染数据源。`FlatList`组件还为其渲染的项目提供了一个可滚动的区域。
- en: You implemented an example that took advantage of section headers in list views.
    This is a good place to render static content such as list controls. You then
    learned about making network calls in React Native; it’s just like using `fetch()`
    in any other web application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你实现了一个利用列表视图中的部分标题的示例。这是一个渲染静态内容（如列表控件）的好地方。然后你学习了如何在React Native中进行网络调用；它就像在其他任何Web应用中使用`fetch()`一样。
- en: Finally, you implemented lazy lists that scroll infinitely by only loading new
    items after you’ve scrolled to the bottom of what’s already been rendered. Also,
    we added a feature to refresh that list by means of a pull gesture.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你实现了通过仅在滚动到已渲染内容的底部后加载新项目来实现无限滚动的懒列表。此外，我们还添加了一个通过下拉手势刷新该列表的功能。
- en: In the next chapter, you’ll learn how to show the progress of network calls,
    among other things.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何显示网络调用的进度，以及其他内容。
