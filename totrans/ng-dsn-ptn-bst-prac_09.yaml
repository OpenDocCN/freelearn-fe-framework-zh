- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Exploring Reactivity with RxJS
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RxJS 探索反应性
- en: In a web application, one of the most challenging tasks is dealing with the
    asynchronous nature of the web. An application cannot predict when events such
    as requests to the backend, changing routes, and simple user interactions will
    happen. Imperative programming in these cases is more complex and susceptible
    to errors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个网络应用程序中，最具挑战性的任务之一是处理网络的异步性。应用程序无法预测诸如对后端请求、更改路由和简单的用户交互等事件何时会发生。在这些情况下，命令式编程更复杂且容易出错。
- en: The RxJS library that makes up the Angular ecosystem aims to make controlling
    asynchronous flows simpler using declarative and reactive programming.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 构成 Angular 生态系统的 RxJS 库旨在通过声明性和响应式编程使控制异步流程变得更加简单。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Observables and operators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察对象和操作符
- en: Handling data – transformation operators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理数据 – 转换操作符
- en: Another way to subscribe – the async pipe
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种订阅方式 – 异步管道
- en: Connecting information flows – high-order operators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接信息流 – 高阶操作符
- en: Optimizing data consumption – filter operators
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化数据消费 – 过滤操作符
- en: How to choose the correct operator
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何选择正确的操作符
- en: By the end of the chapter, you will be able to create better experiences for
    your users by integrating their actions with backend requests.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将通过将它们与后端请求集成来为你的用户提供更好的体验。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the instructions in this chapter, you’ll need the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的说明，你需要以下内容：
- en: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
- en: Node.js 18 or higher ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 18 或更高版本 ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
- en: The code files for this chapter are available at .
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可在以下位置找到。
- en: During this chapter, remember to run the backend of the application found in
    the `gym-diary-backend` folder with the `npm` `start` command.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，请记住使用 `npm start` 命令运行位于 `gym-diary-backend` 文件夹中的应用程序的后端。
- en: Observables and operators
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察对象和操作符
- en: Up until this point, we’ve used observables as a way to capture the data that
    came from the backend API using the `subscribe` method, but let’s take a step
    back and ask what an observable is and why we don’t just use JavaScript promises.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用可观察对象作为通过 `subscribe` 方法捕获来自后端 API 的数据的方式，但让我们退一步，问一下什么是可观察对象，以及为什么我们不直接使用
    JavaScript 承诺。
- en: 'Let’s use a table to organize our explanation:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用表格来组织我们的解释：
- en: '|  | **Single** | **Multiple** |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|  | **单** | **多** |'
- en: '| Synchronous | Function | Iterator |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 同步 | 函数 | Iterator |'
- en: '| Asynchronous | Promise | Observable |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 异步 | Promise | Observable |'
- en: Table 9.1 – Types of objects by requirement
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.1 – 根据需求的对象类型
- en: When we need to perform synchronous processing and expect a return value, we
    use a function. If we need a collection of synchronous values, we use an object
    of the `Iterator` type. We use promises when we need the return value of a function,
    but its processing is asynchronous.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要执行同步处理并期望返回值时，我们使用函数。如果我们需要一个同步值的集合，我们使用 `Iterator` 类型的对象。当我们需要函数的返回值但其处理是异步的时候，我们使用承诺。
- en: But what can we use for asynchronous processing that does not return a value
    but a collection of values that can be distributed over time as events? The answer
    to that need is **an observable**! With this data structure, we can capture a
    series of events in time and declaratively make our application react to these
    events.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于异步处理，我们能够使用什么来不返回一个值，而是一个可以随时间作为事件分发的值集合呢？对这个需求的答案是 **可观察对象**！使用这种数据结构，我们可以捕获一系列事件并在声明性上使我们的应用程序对这些事件做出反应。
- en: Regarding the use of promises for HTTP requests, we can use them, but tasks
    that are verbose and complex to perform when using promises can be done using
    observables and RxJS instead. We can say that everything a promise can do, an
    observable is also capable of doing, but vice versa, this becomes complex.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用承诺进行 HTTP 请求的使用，我们可以使用它们，但使用承诺执行冗长且复杂的任务可以改用可观察对象和 RxJS 来完成。我们可以这样说，承诺能做的，可观察对象也能做，反之亦然，这会变得复杂。
- en: In Angular, most asynchronous events are mapped and controlled by observables.
    In addition to HTTP requests, user typing, the exchange of routes by the application,
    and even the life cycle of components are controlled by observables as they are
    events that occur over time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，大多数异步事件都是通过可观察对象映射和控制的。除了HTTP请求、用户输入、应用程序之间的路由交换，甚至组件的生命周期都是通过可观察对象控制的，因为它们是随时间发生的事件。
- en: We can think of these events as flows of information, and RxJS and the concept
    of observables can manipulate these flows and make our application react to them.
    The main resources for manipulating this flow are the RxJS operators, which are
    functions that receive and return data to this flow.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些事件视为信息流，RxJS和可观察的概念可以操纵这些流，并使我们的应用程序能够对其做出反应。操纵此流的主要资源是RxJS操作符，这些是接收并返回数据到该流的函数。
- en: In the next section, we’ll start with the operator that will transform the stream
    data.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将从将转换流数据的操作符开始。
- en: Handling data – transformation operators
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数据 – 转换操作符
- en: In our `DiaryComponent` application component, which renders a list of diary
    entries, we can notice that our component needs to know the details of the return
    value taken from the API, in which case the detail is returned in an attribute
    called `item`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`DiaryComponent`应用程序组件中，它渲染日记条目的列表，我们可以注意到我们的组件需要知道从API返回的值的详细信息，在这种情况下，详细信息是在一个名为`item`的属性中返回的。
- en: Let’s refactor the service to return just what the component needs already formatted,
    abstracting the structure of the API.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构服务，使其仅返回组件需要的已格式化的内容，抽象API的结构。
- en: 'In the `ExerciseSetsService` service, we will refactor the following methods:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ExerciseSetsService`服务中，我们将重构以下方法：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the `getInitialList` and `refreshList` methods of the service, we are calling
    the `pipe` method of the `Observable` object. This method is fundamental to understanding
    RxJS since, through it, we can define which operators will act in the flow of
    information that the observable is enveloping.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务的`getInitialList`和`refreshList`方法中，我们调用`Observable`对象的`pipe`方法。这是理解RxJS的基本方法，因为通过它，我们可以定义哪些操作符将在可观察对象封装的信息流中起作用。
- en: The `pipe` method also returns an observable, and when the component calls the
    `subscribe` method, its result will go through all the operators and deliver the
    result. For our needs, we are using the `map` operator, which receives the data
    that the observable is processing and returns the other data that will be used
    by the `next` operator or, at the end, by the component that made the subscription.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`pipe`方法也返回一个可观察对象，当组件调用`subscribe`方法时，其结果将通过所有操作符并传递结果。针对我们的需求，我们使用`map`操作符，它接收可观察对象正在处理的数据，并返回将被`next`操作符或最终由订阅该组件使用的其他数据。'
- en: 'In this case, the operator receives an object of the `ExerciseSetListAPI` type
    and we will return the item element that is contained in it to the component,
    which is of the `ExerciseSetList` type. With this change, VS Code, together with
    Angular’s Language Server (for more details on how to configure this, read [*Chapter
    1*](B19562_01.xhtml#_idTextAnchor017), *Starting Projects the Right Way*), will
    point out errors in the `diary.resolver.ts` file. We will correct it as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，操作符接收一个`ExerciseSetListAPI`类型的对象，我们将返回其中包含的项元素到组件，该组件是`ExerciseSetList`类型。通过这个更改，VS
    Code以及Angular的Language Server（有关如何配置的更多详细信息，请参阅[*第1章*](B19562_01.xhtml#_idTextAnchor017)，*正确开始项目*）将在`diary.resolver.ts`文件中指出错误。我们将按以下方式更正它：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As the service now returns journal entries and no longer the entire structure
    of the API return, we change the type that the function returns. Note that RxJS
    uses TypeScript to improve the developer’s experience.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务现在返回的是期刊条目而不是整个API返回的结构，我们更改了函数返回的类型。请注意，RxJS使用TypeScript来提高开发者的体验。
- en: 'In the `DiaryRoutingModule` module, let’s refactor the use of the resolver
    that we fixed:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DiaryRoutingModule`模块中，让我们重构我们修复的解析器的使用：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It is important to name your project variables as clearly as possible; in this
    case, we have changed the `route` attribute to `exerciseList`. What we need to
    do to finish this task is to refactor the `DiaryComponent` component:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是尽可能清晰地命名项目变量；在这种情况下，我们将`route`属性更改为`exerciseList`。为了完成这个任务，我们需要重构`DiaryComponent`组件：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With the use of the `map` operator in the service, now, in the component, we
    only pass the list of exercises, so the component does not need to know the implementation
    and the details of the API.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务中的 `map` 操作符，现在，在组件中，我们只传递练习列表，因此组件不需要知道实现和 API 的细节。
- en: In the next section, we will see another way to subscribe.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到另一种订阅方式。
- en: Another way to subscribe – the async pipe
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另一种订阅方式 – 异步管道
- en: To demonstrate the versatility of RxJS in an Angular application, we will perform
    the task of adding a search for exercises in our backend to the diary entry inclusion
    form.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 RxJS 在 Angular 应用中的多功能性，我们将执行在后台添加搜索练习的任务到日记条目包含表单中。
- en: 'Following the good practices of an Angular application, we will create an interface
    that will represent the exercises. From the command line of the operating system,
    we will use the Angular CLI:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 按照Angular应用的良好实践，我们将创建一个表示练习的接口。从操作系统的命令行，我们将使用 Angular CLI：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the file generated by the Angular CLI, we define the structure of the API
    return:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在由 Angular CLI 生成的文件中，我们定义了 API 返回的结构：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We are using interfaces to define the return of the API and a type to define
    a list of exercises. The next step is to create the service that will fetch this
    information, again using the Angular CLI:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用接口来定义 API 的返回值，并使用类型来定义练习列表。下一步是创建一个将获取这些信息的服务，再次使用 Angular CLI：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With the structure of the service created by the Angular CLI, we will complete
    the logic of the service:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用由 Angular CLI 创建的服务结构，我们将完成服务的逻辑：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the service, we are using the `HttpClient` Angular service because we are
    going to query an API, and we are adding the `X-LOADING` header with `false` to
    the request because, here, we don’t want the loading screen to search for exercises.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务中，我们使用 `HttpClient` Angular 服务，因为我们将要查询一个 API，并且我们在请求中添加了 `X-LOADING` 头部，值为
    `false`，因为我们在这里不希望加载屏幕搜索练习。
- en: If the component passes a filter, we will add the `get` URL. Finally, we are
    using the `map` operator that we saw in the previous section because we don’t
    want the component to worry about knowing the structure of the API.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件传递了一个过滤器，我们将添加 `get` URL。最后，我们使用之前章节中看到的 `map` 操作符，因为我们不希望组件担心了解 API 的结构。
- en: 'With the service created, we can change the `NewEntryFormReactiveComponent`
    form:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 服务创建后，我们可以更改 `NewEntryFormReactiveComponent` 表单：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we are first injecting the service we created and creating an attribute
    to control when to show the exercises list or not.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先注入我们创建的服务，并创建一个属性来控制是否显示练习列表。
- en: The `exercises$` attribute will contain the observable that the service will
    return. One detail that you may have noticed is the `$` symbol here. Using this
    postfix for variables and attributes that are observables is a community convention.
    It is not an obligation, but you will often see this symbol in code bases that
    use RxJS.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercises$` 属性将包含服务将返回的可观察对象。你可能已经注意到这里的 `$` 符号。在变量和属性中使用这个后缀是社区惯例。这不是强制性的，但你经常会在使用
    RxJS 的代码库中看到这个符号。'
- en: 'We also created two methods that will be triggered when the user selects an
    exercise from the list. Let’s change the form template:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了两个方法，当用户从列表中选择一个练习时将被触发。让我们更改表单模板：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the `exercise` field, we are adding a list with the `ul` HTML element, and
    this list will be presented by the `showSuggestions` attribute. The focus event
    of the field will trigger this variable and clicking on the element will call
    the `selectExercise` method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `exercise` 字段中，我们添加了一个由 `ul` HTML 元素组成的列表，并且这个列表将通过 `showSuggestions` 属性来展示。字段的焦点事件将触发这个变量，点击元素将调用
    `selectExercise` 方法。
- en: 'The attention in this code will be on the following directive:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的注意力将集中在以下指令上：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With the `*ngFor` directive, we want to iterate over a list, but here, we don’t
    have a list but an observable. How is that possible?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `*ngFor` 指令，我们想要遍历一个列表，但在这里，我们没有列表，而是一个可观察对象。这是怎么做到的？
- en: This is the responsibility of the async pipe! What this pipe does in the template
    is perform a subscription in the observable, take the result of it, which is a
    list of exercises, and offer the `*ngFor` directive to the iteration.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是异步管道的责任！这个管道在模板中执行的操作是在可观察对象上执行订阅，获取其结果，即练习列表，并将 `*ngFor` 指令提供给迭代。
- en: Notice that we only got such concise code because, in the service, we are using
    the `map` operator to prepare the return of the observable for exactly what the
    component needs. Another advantage that the async pipe provides is that the framework
    controls the life cycle of the observable; that is, when the component is destroyed,
    Angular automatically triggers the `unsubscribe` method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们之所以得到了这样简洁的代码，是因为在服务中，我们使用`map`操作符来准备返回的观察者，使其正好满足组件的需求。异步管道提供的另一个优点是框架控制了观察者的生命周期；也就是说，当组件被销毁时，Angular会自动触发`unsubscribe`方法。
- en: We haven’t done this treatment so far in the book because the observable generated
    by an HTTP request is not open after the request is completed, but here we will
    use observables for other cases that may leave the flow with the observable still
    open.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中尚未进行这种处理，因为HTTP请求生成的观察者在请求完成后不会打开，但在这里我们将使用观察者来处理其他可能使观察者流仍然打开的情况。
- en: It is very important to control the life cycle of the observables that we use;
    otherwise, we can generate bugs and performance degradation caused by memory leaks.
    Using the async pipe, this subscription management is done by Angular itself!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 控制我们使用的观察者的生命周期非常重要；否则，我们可能会生成由内存泄漏引起的错误和性能下降。使用异步管道，这种订阅管理是由Angular本身完成的！
- en: In the next section, we will connect different streams using RxJS and the async
    pipe.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用RxJS和异步管道连接不同的流。
- en: Connecting information flows – high-order operators
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接信息流 - 高阶操作符
- en: As we saw at the beginning of the chapter, there are many uses of observables
    besides an HTTP request. In our task, we will exemplify this use. In a reactive
    form, a user typing into a field is treated as an observable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头所看到的，除了HTTP请求之外，还有许多用途可以使用观察者。在我们的任务中，我们将举例说明这种用途。在响应式表单中，用户在字段中输入被视为一个观察者。
- en: 'In our example, let’s change the `NewEntryFormReactiveComponent` component:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，让我们改变`NewEntryFormReactiveComponent`组件：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Running our application, we can see in the browser’s console that typing into
    any form field triggers an event captured by the `subscribe` method.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的应用程序，我们可以在浏览器控制台中看到，在任意表单字段中输入会触发由`subscribe`方法捕获的事件。
- en: Knowing that we can react to user typing events, how do we connect this event
    to the search for exercise information in the API? We use an operator!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 知道我们可以对用户输入事件做出反应，我们如何将此事件连接到API中的练习信息搜索？我们使用一个操作符！
- en: 'Back in our component, we will refactor the code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的组件中，我们将重构代码：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We remove the subscription of the `ngOnInit` method from the component and put
    in the assignment of the `exercises$` observable. However, if we do this, TypeScript
    and Angular type validation show an error because the template is waiting for
    a list to perform the iteration.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从组件中移除`ngOnInit`方法的订阅，并将`exercises$`观察者的赋值放入其中。然而，如果我们这样做，TypeScript和Angular类型验证会显示一个错误，因为模板正在等待一个列表来执行迭代。
- en: Enter the `switchMap` operator. We exchange the first flow of events for typing
    the form with the exercise request flow, passing the `exercise` field of the form
    model as a filter for the `exerciseService` service.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 进入`switchMap`操作符。我们用表单中输入的练习请求流替换第一个事件流，将表单模型的`exercise`字段作为`exerciseService`服务的过滤器。
- en: The result of this is that the `exercises$` observable continues to receive
    a list of exercises. Executing our project, we notice that we have a list with
    a typeahead search making the request as we fill in the field, as shown in the
    following figure.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，`exercises$`观察者继续接收一系列练习。执行我们的项目，我们会注意到我们有一个列表，当我们在字段中填写时，会进行搜索请求，如图所示。
- en: '![Figure 9.1 – Selection of exercises](img/B19562_09_1.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 练习选择](img/B19562_09_1.jpg)'
- en: Figure 9.1 – Selection of exercises
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 练习选择
- en: The `switchMap` operator is a higher-order observable because it takes an observable
    as input and returns an observable as output. This is in contrast to the `map`
    operator, which takes an observable as input and returns a value as output.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`switchMap`操作符是一个高阶观察者，因为它接受一个观察者作为输入并返回一个观察者作为输出。这与`map`操作符形成对比，后者接受一个观察者作为输入并返回一个值作为输出。'
- en: With a command, we have our `search` field, but if we look at our browser’s
    **Network** tab, we can see that a request is triggered for every letter we type.
    We can improve our application’s data consumption without harming our user experience,
    which we will do in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令，我们有了`search`字段，但如果查看浏览器中的**网络**标签页，我们可以看到每次我们键入一个字母都会触发一个请求。我们可以在不影响用户体验的情况下改进应用程序的数据消耗，我们将在下一节中这样做。
- en: Optimizing data consumption – filter operators
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化数据消耗 – 过滤操作符
- en: Our task of creating a typeahead type `search` field is complete, but we can
    make this functionality more efficient from the point of view of consuming HTTP
    requests. Here, in our case, if the user types just one letter, we have already
    started the search for information, but just one letter still results in a very
    open list.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建类型提示类型`search`字段的任务已经完成，但我们可以从消耗HTTP请求的角度使这个功能更高效。在这里，在我们的情况下，如果用户只键入一个字母，我们已经开始搜索信息，但一个字母仍然会导致一个非常开放的列表。
- en: 'It would be more interesting for our application to start looking for exercises
    from the third letter that the user types onward, and we can make the following
    modification for this behavior:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序来说，从用户键入的第三个字母开始查找练习会更有趣，我们可以为此行为进行以下修改：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we start using one of the most versatile features of RxJS, which is chaining
    operators for a certain action. We always need to keep in mind that the order
    of operators is very important, and the output of an operator is the input of
    the next one:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们开始使用RxJS最灵活的特性之一，即链式操作符以执行特定操作。我们始终需要记住操作符的顺序非常重要，一个操作符的输出是下一个操作符的输入：
- en: We use the `map` operator that we already know to extract only the `exercise`
    field from the `form` model and treat the data as if the field value is undefined.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用已知的`map`操作符来从`form`模型中提取仅`exercise`字段，并将数据视为字段值未定义。
- en: The `filter` operator works similarly to the method of the same name for the
    `Array` object in JavaScript. It receives the `exercise` string and we validate
    that its length must be greater than or equal to three to go to the next operator.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`filter`操作符与JavaScript中`Array`对象的同名方法类似。它接收`exercise`字符串，并验证其长度必须大于或等于三个才能进入下一个操作符。'
- en: Finally, we run the `switchMap` high-order operator to switch the form typing
    observable to the service’s HTTP request observable.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们运行`switchMap`高阶操作符，将表单键入的可观察值切换到服务的HTTP请求可观察值。
- en: 'We can also, with another operator, add a waiting time for starting the flow
    of the observable, as in the following example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用另一个操作符，为可观察值的流开始添加一个等待时间，如下例所示：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We added the `debounceTime` operator to create a delay time for the beginning
    of the flow, defining the time in milliseconds and with the good practice of using
    a constant to make the code clearer.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`debounceTime`操作符来创建流开始的延迟时间，以毫秒为单位，并使用常量来使代码更清晰，这是良好的实践。
- en: 'Let’s add one last optimization to our code with a new operator:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个新的操作符添加最后一个优化：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `distinctUntilChanged` operator checks whether the stream’s data, here `exercise`,
    has changed from one iteration to another and triggers the next operator only
    if the value is different, saving even more unnecessary calls to the backend.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`distinctUntilChanged`操作符检查流的数据，这里指`exercise`，是否从一个迭代到另一个迭代发生了变化，并且只有当值不同时才会触发下一个操作符，从而节省更多不必要的后端调用。'
- en: We’ve learned about a few operators, but the library has over 80\. In the next
    section, we’ll learn how to navigate the library’s documentation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了一些操作符，但库中超过80个。在下一节中，我们将学习如何浏览库的文档。
- en: How to choose the correct operator
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何选择正确的操作符
- en: The RxJS library has an extensive number of operators that can help simplify
    your code and handle corner cases of asynchrony and even performance.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS库有大量的操作符可以帮助简化你的代码并处理异步和性能的边缘情况。
- en: You don’t need to memorize all the operators and the ones we’ve seen so far
    will help you with the most common cases.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要记住所有的操作符，我们之前看到的那些将帮助你处理最常见的情况。
- en: The library documentation has a **Decision Tree** page, and we’ll learn how
    to navigate that.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图书馆文档有一个**决策树**页面，我们将学习如何导航该页面。
- en: Enter the site ([https://rxjs.dev/operator-decision-tree](https://rxjs.dev/operator-decision-tree))
    and, here, we will navigate to an operator that we have already studied to exemplify
    the use of this tool.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 进入网站([https://rxjs.dev/operator-decision-tree](https://rxjs.dev/operator-decision-tree))，在这里，我们将导航到一个我们已经研究过的操作符，以展示这个工具的使用。
- en: '![Figure 9.2 – Operator Decision Tree](img/B19562_09_2.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 操作符决策树](img/B19562_09_2.jpg)'
- en: Figure 9.2 – Operator Decision Tree
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 操作符决策树
- en: Let’s go back to our form example. We need to fetch the exercise information
    from what the user’s typing – let’s assume that we don’t know which operator to
    choose.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的表单示例。我们需要从用户的输入中获取练习信息——让我们假设我们不知道选择哪个操作符。
- en: We already have an observable, which is the `valueChanges` event in the Angular
    form, so on the first screen, we will choose the `I have one existing` `Observable,`
    `and` option.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个可观察对象，它是Angular表单中的`valueChanges`事件，所以第一个屏幕上，我们将选择`我有一个现有的` `可观察对象` `和`选项。
- en: The request to our API is represented by an observable, so on the next screen,
    we will choose the **I want to start a new Observable for each** **value** option.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对API的请求由一个可观察对象表示，所以在下个屏幕上，我们将选择**我想为每个** **值** **启动一个新的可观察对象**选项。
- en: As we want to make a new request for each letter the user types, we want to
    change one stream for another, so on the next screen, we’ll choose **and cancel
    the previous nested Observable when a new** **value arrives**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望为用户输入的每个字母都发出新的请求，我们希望将一个流更改为另一个流，所以下一个屏幕上，我们将选择**当新** **值到达时** **取消之前的嵌套可观察对象**。
- en: The exercise search depends on the value that is in the Angular form, so on
    the final page, we will choose **where the nested Observable is calculated for**
    **each value**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 练习搜索取决于Angular表单中的值，所以最终页面上，我们将选择**嵌套可观察对象为每个** **值** **计算**。
- en: Confirming the selection, the decision tree indicates that the correct operator
    for this situation is the `switchMap` operator that we are using!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 确认选择后，决策树指示这种情况的正确操作符是我们正在使用的`switchMap`操作符！
- en: 'Another thing we need to understand in the RxJS documentation is the marble
    graph. For this, let’s take as an example another operator that we studied in
    the chapter, the `map` operator here: https://rxjs.dev/api/index/function/map.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxJS文档中，我们还需要理解的是宝石图。为此，让我们以我们在本章中研究的另一个操作符为例，即这里的`map`操作符：https://rxjs.dev/api/index/function/map。
- en: 'In addition to the textual explanation, we have the following figure:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 除了文本说明外，我们还有以下图示：
- en: '![Figure 9.3 – Map operator marble graph (source: https://rxjs.dev/api/index/function/map,
    MIT license)](img/B19562_09_3.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – Map操作符的宝石图（来源：https://rxjs.dev/api/index/function/map，MIT许可）](img/B19562_09_3.jpg)'
- en: 'Figure 9.3 – Map operator marble graph (source: https://rxjs.dev/api/index/function/map,
    MIT license)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – Map操作符的宝石图（来源：https://rxjs.dev/api/index/function/map，MIT许可）
- en: As we learned at the beginning of this chapter, RxJS works on information flows,
    where operators have the function of handling information.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头所学的，RxJS在信息流上工作，其中操作符具有处理信息的功能。
- en: The graph that illustrates this flow uses arrows to represent the passage of
    time and marbles to represent values.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 说明这个流程的图使用箭头表示时间的流逝，用宝石表示值。
- en: In the documentation here, then, we see that the `map` operator takes each value
    emitted and, based on a function, results in a flow with the values transformed
    by it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这份文档中，我们看到`map`操作符接受每个发出的值，并根据一个函数，产生一个由其转换的值流。
- en: These values are exchanged one by one as soon as they are issued so, in the
    graph, we can see that the positions of the marbles are same.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值一旦发出就依次交换，因此，在图中，我们可以看到宝石的位置相同。
- en: This understanding is fundamental to understanding other more complex operators
    in the library.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种理解对于理解库中其他更复杂的操作符是基本的。
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the RxJS library and its basic elements, observables.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了RxJS库及其基本元素，可观察对象。
- en: We learned what an observable is and how it differs from a promise or a function.
    With that knowledge, we refactored our project to handle data with the `map` operator,
    abstracting the implementation details of the component that will consume the
    service. We also learned about Angular’s async pipe and how it simplifies the
    management of subscription to an observable, leaving this task to the framework
    itself to manage.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了什么是可观察对象以及它与承诺或函数的区别。有了这些知识，我们重构了我们的项目，使用`map`操作符处理数据，抽象出将消费服务的组件的实现细节。我们还了解了Angular的异步管道以及它是如何简化对可观察对象的订阅管理的，将这项任务留给了框架本身来管理。
- en: Finally, we created a typeahead search field using RxJS to search for exercises
    based on the user’s typing event, using operators in order to optimize HTTP calls
    from our frontend. In the next chapter, we will explore the possibilities of the
    automated tests that we can do in our Angular application.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用RxJS创建了一个typeahead搜索字段，根据用户的输入事件搜索练习，使用操作符来优化前端发出的HTTP调用。在下一章中，我们将探讨我们可以在Angular应用程序中进行的自动化测试的可能性。
- en: 'Part 3: Architecture and Deployment'
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：架构和部署
- en: In this part, you will learn how to build the architecture of your Angular project
    to meet the challenges and demands of your users. We will explore the best practices
    for automated testing using the libraries that the framework uses and we will
    install Cypress for end-to-end testing. We will understand the micro frontend
    architecture and how to implement it with Angular. We will use the Azure cloud
    service to perform the build and deploy our example application and finally understand
    how to update an Angular application and use features from version 17 onwards
    such as Angular Signals
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，你将学习如何构建你的Angular项目的架构以满足用户面临的挑战和需求。我们将探讨使用框架使用的库进行自动化测试的最佳实践，并安装Cypress进行端到端测试。我们将了解微前端架构以及如何使用Angular实现它。我们将使用Azure云服务执行构建和部署我们的示例应用程序，并最终了解如何更新Angular应用程序以及从版本17开始使用Angular
    Signals等特性。
- en: 'This part has the following chapters:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 10*](B19562_10.xhtml#_idTextAnchor264)*, Design for Tests: Best Practices*'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B19562_10.xhtml#_idTextAnchor264)*，为测试而设计：最佳实践*'
- en: '[*Chapter 11*](B19562_11.xhtml#_idTextAnchor285)*, Micro Frontend with Angular
    Elements*'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B19562_11.xhtml#_idTextAnchor285)*，使用Angular Elements的微前端*'
- en: '[*Chapter 12*](B19562_12.xhtml#_idTextAnchor311)*, Packaging Everything: Best
    Practices for Deployment*'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B19562_12.xhtml#_idTextAnchor311)*，打包一切：部署的最佳实践*'
- en: '[*Chapter 13*](B19562_13.xhtml#_idTextAnchor328)*, The Angular Renaissance*'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B19562_13.xhtml#_idTextAnchor328)*，Angular的文艺复兴*'
