- en: RxJS Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Reactive Extensions for JavaScript** (**RxJS**) is a set of libraries created
    by Matt Podwysocky. Version 4 of the library is maintained and developed by Microsoft.
    Version 4 can be found at the following link: [https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version 5 is a complete rewrite of version 4 and can be found at the following
    address: [https://github.com/ReactiveX/rxjs](https://github.com/ReactiveX/rxjs).
    Its largest contributor is *Ben Lesh*, with other notable contributors including
    *Andre Staltz*. Version 5 is also Angular''s choice of library for handling HTTP,
    among other things.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: Which patterns make up RxJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The core concepts of RxJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to manually create your own Observables and subscribe to them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The many ways you can create an Observable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of managing cleanup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding what lies beneath by learning to implement the core part of the
    RxJS library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Observer pattern is a Gang of Four pattern. It is a pattern made famous
    by being included in the book *Design Patterns: Elements of Reusable Object-Oriented
    Software* by *Erich Gamma*, *Richard Helm*, *Ralph Johnson*, and *John Vlissides*.
    The pattern has two key players involved: a **Subject** and an **Observer**. A
    Subject is observed by an Observer. Typically, a Subject holds an internal list
    of Observers that should be notified when a change happens on the Subject. It
    is quite common that the Subject is a model and the Observers are some kind of
    UI component. In short, Subjects should be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Hold a list of Observers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an Observer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove an Observer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notify all Observers when a change happens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Observer, on the other hand, should only hold one property, and that is
    an `update()` method that can be called by a Subject when an update has occurred.
    The idea behind this pattern is to create a loose coupling between different layers.
    Neither Subjects nor Observers should know about each other directly by name,
    but rather by abstractions. A class diagram for a Subject might therefore look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d14da8c5-3a06-4875-86c3-4543b4b26a98.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we are including all the required methods: `attach()`, `detach()` and
    `notify()`, and we clearly specify that we are dealing with the abstraction Observer
    and not a concrete type. As for the Observer, this is usually an interface with
    just one method, `update()`, and can be represented by the following class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a38a9906-ccf4-4743-81e0-7363ecf07869.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Given these class diagrams, let''s write down some code to demonstrate what
    an implementation might look like, and let''s start with the Subject. For this
    example, we will be using TypeScript, as TypeScript knows what an interface is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the basic implementation is very short but it is a powerful
    construct. As for the `Observer`, it is even shorter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can try this out by creating a file, `app.ts`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: By running the preceding code, we see that the `Subject` instance allows us
    to attach `Observer` instances to it by calling the `attach()` method. We then
    call `notify()` on the `Subject` instance to ensure that all subscribing `Observer`
    instances gets notified.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, so now we have some core implementation in place, what does an actual use
    case look like? Imagine that we have a `ProductModel` class playing the role of
    a `Subject` and a `ProductUI` class playing the role of an `Observer`. A simple
    implementation of the `ProductModel` class might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we have two properties, `title` and `make`, and when
    both of them change, we call the `notify()` method that we inherit from the base
    class, `Subject`. Let''s have a look at what a `ProductUI` class can look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we see that we receive a `ProductModel` instance in the
    constructor and that we also call `attach()` on said instance so that it is registered
    as an `Observer`. We also define an `update()` method, in which we decide that
    we will rerender the UI, should it be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: This is a typical example of using the Observer pattern and using it for model-to-UI
    communication is just one of many usage possibilities. The general principle is
    to communicate between `Subject` and `Observer` instances in a loosely coupled
    way. The true benefit is to be able to have multiple `Observer` instances on one
    `Subject` so that if the `Subject` changes, all its `Observer` instances can change
    with it. This is also called Publish/Subscribe, which is usually shortened to
    Pub/Sub.
  prefs: []
  type: TYPE_NORMAL
- en: RxJS core concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'RxJS consists of some core concepts that are important for you to understand
    early on. Those are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Observable**: This is a class representing a stream of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observer**: This is a class able to emit data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Producer**: This is what internally produces data, which the Observer ultimately
    emits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operator**: This is a method on an Observable, which allows us to manipulate
    the stream itself or the data it emits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stream**: This is synonymous with an instance of an Observable. The reason
    for it being called a stream is that you should think of the data as continuous
    and not really having an end, unless you explicitly define an end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observable and Observer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having defined all the concepts we need to know initially, it is now time to
    put it all in context to further our understanding. Let''s start off by defining
    an `Observable` and work ourselves into each previously mentioned concept. An
    `Observable` can be created with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the least amount of code needed to create an `Observable`. At this
    point nothing is written to the screen because we need to subscribe to the stream.
    Let''s add a Subscriber to our `Observable`. We do that by calling the method
    `subscribe()` on our stream instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at this code, we see that the `Observable` calls the method `create()`,
    which in turn creates an instance of an `Observable`. What is interesting is how
    the `create()` method takes a function as a parameter; a function that itself
    takes an Observer instance. So, we have an API that looks like this: `Observer.create(fn(observerInstance))`.
    What happens inside said function is that we call `observer.next(1)`. At a higher
    level, we have an `Observable` that is created by us using a `factory` function
    `create()`. The `create` function takes a function as a parameter which defines
    the behavior of the `Observable`. Our `Observable` behavior in this case is very
    simple, which is to emit the value 1\. When we call `observer.next(1)`, we emit
    data. To get hold of what is emitted, we need to call the `subscribe()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Producer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we try to compare this to the Observer pattern, we will see that some concepts
    reoccur, such as Observer. In this pattern, the Observer was notified when something
    happened and the Subject took the initiative to change. Looking at the previous
    code, it looks like the Observer is the one that takes the initiative to change.
    This isn''t strictly true though; it is more of a mediator, which brings us to
    our next concept in RxJS, the `Producer`. The `Producer` is responsible for generating
    the values we need. By involving a `Producer` in our code, we see that the Observer
    is more of a mediator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we can see here, the producer is the one responsible for generating the data,
    while the Observer is responsible for passing on that data to a subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: Observable error and completion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is more to a stream than just generating data; a stream can generate
    errors as well as reaching its completion. If an error or a completion happens,
    the stream will not generate any more values. To signal that we have an error,
    we call the `error()` method on the Observer, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To capture the emitted error, we need to introduce a second callback in our
    call to `subscribe()`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have learned how to emit data but also how to signal an error. The
    last thing we can do is to close the stream, or complete it, as closing is also
    known. We do that by calling `complete()` on the Observer. This will ensure that
    no more values are emitted. To capture a completion signal, we need to add another
    callback in our `subscribe()` call. You use it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our last concept to cover is the operator. An operator is simply a method that
    acts on an Observable and changes the stream in some way. Operators are by nature
    immutable. This immutability makes the code easier to test and reason about. RxJS
    comes with over 60 operators to help in most situations where you define your
    streams and their behavior.
  prefs: []
  type: TYPE_NORMAL
- en: There might be a case where you need to create your own operator, but most likely
    there is an operator out there that already does what you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you define your stream and its behavior, you will use one or more operators.
    It might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that we are using the `.map()` operator and `.filter()` to
    change our stream's data. `.map()` operates on each value in the stream by incrementing
    each value by one. `.filter()` operates on the changed stream; a change brought
    about by calling `.map()`. It also operates on each value in the stream but conditionally
    decides what should be emitted. The end result is only one value being emitted,
    `3`. There are a ton more operators, but this should give you an idea of what
    operators are and how they can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the time, when creating Observables, you won''t use the `create()`
    method to do so. You will use other methods instead. Why is that? Well, an Observable
    instance usually originates from some asynchronous concept. In the context of
    using RxJS for creating Angular applications, an Observable instance will be created
    by doing one of the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating or fetching data over HTTP with AJAX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listening to input changes with reactive forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listening to routing changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listening to UI events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping an asynchronous concept
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In RxJS, there are different creation operators that will help you solve these
    tasks, but the Angular framework might actually create Observables internally.
    Let''s look at some creation operators other than the `create()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: Creation operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Observable is, as we stated before, a representation of data being emitted
    over time. Sometimes, the data arrives straight away and sometimes it takes time.
    Regardless of which, it is really powerful to be able to model that data in the
    same way.
  prefs: []
  type: TYPE_NORMAL
- en: of()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a very simple creation operator, `of()`. This takes a variable
    number of arguments, which will be emitted as values, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The values are fired off immediately. This is very useful when you just want
    to test things out.
  prefs: []
  type: TYPE_NORMAL
- en: interval()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another interesting operator is the `interval()` operator, which takes a number
    of milliseconds as a parameter. This defines the number of milliseconds delay
    there should be between every piece of emitted data. This will start from the
    number 0\. One thing to keep in mind is that it will generate values forever unless,
    for example, a `take()` operator is applied to it. A `take()` operator will limit
    the number of emitted values and close the stream. A typical usage of the operator
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: from()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `from()` operator allows us to create an `Observable` from some other asynchronous/synchronous
    concept. It''s really powerful when almost anything can be made into an `Observable`,
    as this allows for rich composition. Here is what a typical snippet can look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: fromEvent()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have mentioned rich composition a few times already and the power of making
    everything into an Observable. We have turned promises and into Observables, which
    have made everything into streams of data, making the whole situation more easy
    to reason about. What we mean by that is, when every async concept is being turned
    into an Observable, we are suddenly able to think about them in the same way.
    Operators that can be applied to mouse-clicks can also be applied to AJAX requests
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add to this, we can even make UI events into Observables. By using the `.fromEvent()`
    operator, we are able to take an element and its corresponding event and make
    that an Observable. This is true power at our fingertips, which allows us to turn
    scenarios such as autocomplete into a matter of 3-4 lines of code. A typical usage
    of this operator looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: bindCallback()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have listed a lot of ways, synchronous as well as asynchronous,
    in which a construct could be turned into an Observable. Callbacks is the first
    pattern to try to resolve the whole asynchronous matter and it should be said
    that a callback is probably the worst way to solve asynchronous code because of
    its poor readability. Luckily, there is an operator that takes a callback and
    turns it into an Observable called `bindCallback()`. It can be used in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that we start off by defining a function called `fnWithCallback()`.
    We pass this as an argument to the `bindCallback()` method. This produces a `fnWithCallbbackBinded()`
    function. Invoking said function will produce an `Observable` that we can subscribe
    to. So, every time `cb(''data'')` in the `fnWithCallback()` function is invoked
    because of the `setTimeout()`, this will lead to the data callback for our `source$`
    being invoked. How does this work in practice? It''s really quite simple. Let''s
    try to implement our own `Observable` for this. We have learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A `bindCallback()` method takes a function as a parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking `bindCallback()` should produce a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking the result of calling `bindCallback()` should produce an `Observable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `subscribe()` should mean that our data callback should be the `cb`
    parameter in `fnWithCallback()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The resulting implementation should therefore look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Cleanup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have now covered core concepts such as Observable, Observer, Producer, and
    operators. We have also looked into how we can manually create an Observable,
    but realized that there are different creation operators that will help you create
    Observables from other constructs, and sometimes the Angular framework itself
    will create the Observable for you. We have failed to mention one important thing
    though, cleanup. There will be situations where an Observable will allocate resources
    or simply go on forever, as with the `interval()` operator. There is one clear
    remedy to that—define and run a cleanup function when we are done with the Observable.
    Defining such a function forces us to return to the `create` operator and amend
    some code in its behavior function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Subscriptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding code describes a situation where there is a need for a cleanup
    to happen. We have defined a `setInterval()` construct that seemingly emits values
    forever. `cleanUpFn()` has the ability to cancel that behavior, providing it is
    being invoked. We return `cleanUpFn()` at the end of our behavior function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The question is, how do we get hold of it? The answer is that we need to talk
    about a new concept: subscription. A subscription is something that we get back
    when calling `subscribe()` on a stream. Let''s amend the preceding code with just
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have created the variable `subscription` by calling
    `subscribe()`, but the really interesting part happens in the last line: we define
    a timeout that calls `unsubscribe()` on our `subscription`. This will call our
    `cleanUpFn()` so that the interval is cancelled.'
  prefs: []
  type: TYPE_NORMAL
- en: Not many streams that you deal with will need to be unsubscribed from, but the
    ones that allocate resources or start off some construct that goes on forever,
    without us intercepting, will need to have a cleanup behavior which we need to
    invoke once we are done with our stream.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a core implementation of RxJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different phases to understanding something. Understanding a library
    is about learning its concepts and utilizing its methods in the correct way. Then
    comes deeper understanding, such as knowing what methods to use, based on some
    best practice guide you found in a blog. Finally, you come to a really deep stage
    of understanding where you want to understand what is going for relay and starts
    mucking about in the source code itself and maybe try to enhance it by submitting
    Pull Request to a project, most likely based on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: This section aims to give you part of that deeper knowledge straight away. We
    are aware that your head might be spinning a little at this point, with all the
    new concepts you have learned, together with some nifty operators. Let's start
    from scratch with the concepts first introduced and attempt to reverse engineer
    what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing create()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the beginning of this chapter, we were taught how to create an Observable.
    The code looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Just by looking at the code, we can make educated guesses as to what's going
    on underneath. It's clear we need an `Observable` class.
  prefs: []
  type: TYPE_NORMAL
- en: The class needs a `create()` method that takes a function as a parameter. The
    `create()` method should return an `Observable`. Furthermore, our `Observable`
    class needs a `subscribe()` method that takes a function as a parameter. Let's
    start off there and see where we land.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s define our `Observable` class with the aforementioned methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, so we have a class with three methods in it; let''s attempt to implement
    the methods. Let''s take what we know about the `create()` method and start from
    there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We highlighted the required changes in bold and introduced a field on the class
    called `behaviourFn()`. Furthermore, our `create()` method instantiated an `Observable`
    by passing in `behaviourFn` from the `create()` method parameter. This means the
    constructor needs to take a function as a parameter and save that for later use.
    What do we know about the `behaviourFn()` that was passed into the create method?
    We know it takes an Observer instance as a parameter and it also lays out what
    values the Observer instance should emit. For anything to be able to capture those
    emitted values, we need to implement our last method, `subscribe()`. We know that
    `subscribe()` takes `dataFn()` as a parameter and needs to somehow invoke our
    `behaviourFn` when the `subscribe()` method is being invoked to trigger the behavior.
    Let''s therefore amend that in our existing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we realize that we need an `Observer` class so that we actually
    have something to pass to our `behaviourFn()`. Another thing we need to figure
    out is how to invoke `dataFn()` and when. After a thinking for a minute, we realize
    the Observer must be the one responsible for invoking `dataFn()` so it seems only
    reasonable that `dataFn()` is passed into the constructor of our `Observer` class
    for later use, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'By implementing this `Observer` class, we have done three things: one is to
    pass the `dataFn()` through the constructor and make it into a field on the `Observer`
    class; another is to create a `next()` method on the `Observer`, which had to
    be done as we learned that an Observer instance should call `next()` to generate
    values; the third and final thing we did was to ensure that we invoked `dataFn()`
    inside of the `next()` method to be sure that the subscriber is being told every
    time we generate a value by calling the `next()` method. Putting all of this code
    together, we have created a very bare implementation of RxJS, which actually works!
    To better understand what we have so far, let''s display all the code used so
    far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Handling subscriptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We learned how to implement a very basic core in the last section. Earlier
    in the chapter, however, it was mentioned that sometimes your Observable will
    allocate resources or will display a behavior where it clearly won''t be able
    to stop generating values. It is our responsibility to handle such situations
    in a graceful manner. RxJS has clearly laid out a path here, which is to define
    a cleanup function and ensure it is invoked upon calling `unsubscribe()`. Let''s
    show such a scenario, where we clearly need to care about cleaning up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the code, we see that when we define the behavior function (at the
    bottom of the code snippet), we set up a `setInterval()` construct that calls
    `observer.next(`) periodically. We ensure we save the reference in a variable
    ID. This need to be sure that we can cancel the `setInterval()` behavior when
    we choose to. We do that by defining a `cleanUpFn()` in the last row of the `behaviourFn`
    function. This brings us to the top half of our snippet. Here, we see that we
    amend the `subscribe()` method by ensuring we save the result of calling `this.behaviourFn()`
    into a variable called `cleanUpFn`. This is indeed the `cleanUpFn()` we defined
    in `behaviourFn()`. Lastly, we expose the `cleanUpFn()` property by returning
    it as part of an object and assigning it to the `unsubscribe()` property. The
    last thing we need to do is to call the `unsubscribe()` method to ensure our allocated
    resources are released or, as in this specific example, that the `setInterval()`
    construct is cancelled. Calling unsubscribe will call `cleanUpFn()` which in turn
    calls `clearInterval()`, which will cancel the interval.
  prefs: []
  type: TYPE_NORMAL
- en: Adding operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have come a long way in defining our own core implementation of RxJS, but
    we are missing an important piece of the puzzle—operators. Operators are the real
    power of RxJS and can be seen as a utility method that allows us to manipulate
    our stream with ease. Let''s select `filter()` as the target of our example. A
    filter operator is a method that you can call on the stream. The idea is to provide
    it with a function that is able to determine, value for value, whether the specific
    value in question should be emitted. A typical use case looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that the function we provide as a parameter
    to the filter function effectively sorts out any values not meeting the condition.
    In this case, all values above `1` will be emitted, thereby sorting the value
    `1`. Let''s add the `filter()` method to our previously defined `MyObservable`
    class, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see from the preceding snippet that the `filter()` method is added to
    the `MyObservable` and we see that it itself returns an Observable, while also
    taking a `filterFn()` as a parameter. The question you need to ask yourself is
    whether our existing `MyObservable` constructor will do. Our existing constructor
    takes a `behaviourFn()` and we most likely need to store the incoming `filterFn`
    parameter, so we need to extend the constructor or opt for a new implementation
    of an `MyObservable`. We ponder this for a second and realize its probably better
    to go for a new, more dedicated `MyObservable` as we want to avoid a lot of branching
    logic. Therefore, the implementation of said method should be amended to look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, so now we have a new class to implement, `FilterableObservable`. This class
    should share most of the behavior of the `MyObservable`, but instead show how
    we emit data. So, we are talking about inheriting from `MyObservable` but with
    our own special twist. Let''s attempt an implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We can see in the preceding code snippet that we override the `subscribe()`
    implementation, or more specifically, we override the `next()` method on the `Observer`
    instance. We use `filterFn()` for what it was made for, to assess whether something
    should be generated or not. We have now successfully implemented the `filter()`
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the basics, adding errors, and complete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After having taken on the heroic feat of implementing the basics of RxJS, we
    hopefully feel pretty good about understanding its inner workings. So far, we
    have only implemented `dataFn` in `subscribe()`; there are two more callbacks
    in the `subscribe()` method that we need to implement. Let''s look at a code snippet
    and highlight what is missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We have highlighted the two last callbacks as the missing functionality. We
    know from before that to trigger the error callback, we need to call `observer.error(''some
    message'')`. We also know that no values should be emitted after an error is raised.
    Let''s provide an example of such a case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we realize that our `Observer` class is the one that needs amending
    to support the `error()` method call. We also need to be wary of the condition
    we just described, as no more values should be emitted after an error has occurred.
    Let''s jump into an implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We can see in the preceding snippet that we pass another parameter into the
    `errorFn` constructor. The `next()` method needed updating, so we needed to envelope
    it with a conditional that says whether to generate a value or not. Lastly, we
    needed to define the `error()` method as calling the passed-in `errorFn` and setting
    the `hasError` field to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to do one more thing and that is to update our `subscribe()` method
    in the `Observable` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: A little heads up is that when we define the `filter()` operator to override
    the `next()` method, we need to ensure this one takes `hasError` into consideration
    when determining whether to generate a value. We'll leave this to you, dear reader,
    to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last order of business is to support completion. Completion has many similarities
    with raising an error, in the sense that no more values should be emitted. The
    difference is that we should hit the last callback instead. As with the `error()`
    method implementation, we start with the `Observer` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Given the preceding code, we see that our changes entail adding an `isCompleted`
    field. We also pass a `completeFn()` in the constructor. Logic needs to be added
    in the `next()` value, as completion is now another state we need to look for
    besides error. Lastly, we added the `complete()` method, which just invokes the
    passed-in function and sets the `isComplete` field to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, we need to update the `Observable` class to pass the complete function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick reality check here: we have actually implemented the core functionality
    of RxJS—Observer, Observable, and one operator. We are much closer to understanding
    what is going on. We realize that implementing the other 59 operators is quite
    a feat, and it is probably not a good idea when there is a team maintaining the
    existing RxJS repository. Our newfound knowledge is not for nothing; understanding
    what is going on can never be wrong. Who knows? Maybe one of you readers will
    become a contributor; you have certainly been given the tools.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started off by talking about the patterns that make up RxJS. We continued
    by describing its core concepts. This was followed by describing how and when
    it was necessary to create your own Observable, opt for one of RxJS many creation
    operators, or rely on the Angular framework to do this job for you. We briefly
    discussed the importance of cleaning up after your Observable and when it was
    a good idea to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we took on the task of implementing part of the RxJS core to gain a
    deeper understanding of its core concepts and how it all came together. This has
    hopefully given you a pretty solid foundation and in-depth understanding of RxJS
    as we venture into the next chapter, which will cover more operators, and some
    more advanced concepts.
  prefs: []
  type: TYPE_NORMAL
