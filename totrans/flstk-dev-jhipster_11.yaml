- en: Deploying with Docker Compose
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker Compose进行部署
- en: We have generated the application and it is ready for production. In this chapter,
    we will focus on how to deploy the application using Docker Compose. We will also
    see the various options that JHipster provides for deployment, followed by how
    to deploy our registry and console alongside the application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经生成了应用程序，并且它已准备好投入生产。在本章中，我们将重点介绍如何使用Docker Compose部署应用程序。我们还将了解JHipster提供的各种部署选项，以及如何将我们的注册表和控制台与应用程序一起部署。
- en: 'In this chapter, we will look into:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨：
- en: A short introduction to Docker Compose
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose的简要介绍
- en: Kickstarting Kubernetes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动Kubernetes
- en: Introducing OpenShift
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍OpenShift
- en: Explaining Rancher
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释Rancher
- en: Then we will discuss locally with JHipster Registry and JHipster Console
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将讨论使用JHipster Registry和JHipster Console进行本地讨论
- en: Introducing microservice deployment options
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍微服务部署选项
- en: The success of an application not only depends on how well we design it. It
    depends on how well we implement (deploy and maintain) it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的成功不仅取决于我们设计得有多好。它还取决于我们实施（部署和维护）得有多好。
- en: 'A well-designed microservice application in a low-availability environment
    is useless. So it is equally important to decide on a deployment strategy that
    increases its chances to succeed. When it comes to deployment, there is a plethora
    of tools available. Each one of them has its pros and cons, and we have to choose
    one that is suitable for our needs. JHipster currently provides sub-generators
    to create configuration files to containerize, deploy, and manage the microservices
    via the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在低可用性环境中设计良好的微服务应用是无用的。因此，决定一个能增加其成功机会的部署策略同样重要。在部署方面，有大量的工具可供选择。每个工具都有其优缺点，我们必须选择一个适合我们需求的。JHipster目前提供子生成器来创建配置文件，以便通过以下方式容器化、部署和管理微服务：
- en: Docker
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Kubernetes (also helps to orchestrate your deployment)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes（也有助于编排您的部署）
- en: OpenShift (also provides private cloud deployment)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenShift（也提供私有云部署）
- en: Rancher (also provides complete container management)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rancher（也提供完整的容器管理）
- en: We will see them in detail in the following sections.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下章节中详细说明。
- en: A short introduction to Docker Compose
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Compose的简要介绍
- en: Shipping code to the server is always difficult, especially when you want to
    scale it. This is mainly because we have to manually create the same environment
    and make sure the application has all the necessary connectivity (to other services)
    that is needed. This was a major pain point for teams when shipping and scaling
    their code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码发送到服务器总是困难的，尤其是当你想要扩展它时。这主要是因为我们必须手动创建相同的环境，并确保应用程序具有所有必要的连接性（到其他服务），这是必需的。这在团队发送和扩展代码时是一个主要痛点。
- en: Shipping code to the server is difficult.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码发送到服务器是困难的。
- en: Containers were the game-changer in this field. They helped to bundle the entire
    application along with dependencies in a shippable container, and all we need
    is to provide an environment in which these containers can run. This simplified
    the process of shipping code to the server and also among the development teams.
    This also reduced the amount of time a team spent making sure that the application
    ran seamlessly across the environment.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是这个领域的游戏改变者。它们帮助将整个应用程序及其依赖项捆绑在一个可发送的容器中，而我们所需做的就是提供一个环境，让这些容器可以运行。这简化了将代码发送到服务器以及开发团队之间的过程。这也减少了团队确保应用程序在环境中无缝运行所需的时间。
- en: Containers solve the application deployment problem, but how do we scale them?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 容器解决了应用程序部署问题，但我们如何扩展它们？
- en: The Docker Compose tool comes to the rescue here. First, let's see what Docker
    Compose is, and then see what problems it solves.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose工具在这里提供了帮助。首先，让我们看看Docker Compose是什么，然后看看它解决了什么问题。
- en: Docker Compose is a tool that helps to define and run multi-container Docker
    applications with a single file. That is, we use a `.yaml` file to define the
    requirements and/or dependencies of the application. Then, with `docker-compose`,
    we can create newer deployments and start our applications as defined in the `docker-compose`
    file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose是一个工具，它可以帮助使用单个文件定义和运行多容器Docker应用程序。也就是说，我们使用`.yaml`文件来定义应用程序的要求和/或依赖关系。然后，使用`docker-compose`，我们可以创建新的部署并启动在`docker-compose`文件中定义的应用程序。
- en: So, what is required in a `docker-compose` file?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`docker-compose`文件中需要什么？
- en: 'The following code segment is a sample `docker-compose` file that will start
    a Redis database on port `5000`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例 `docker-compose` 文件，它将在端口 `5000` 上启动 Redis 数据库：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line of the `docker-compose` file should be the version of the `docker-compose`
    tool.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose` 文件的第 一行应该是 `docker-compose` 工具的版本。'
- en: Then we need to specify all the necessary services that we need for our application
    to run. They should be defined in the `services:` section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要指定应用程序运行所需的所有必要服务。它们应该在 `services:` 部分中定义。
- en: We can also define multiple services inside here, giving a name to each (`web`
    and `redis`).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在这里定义多个服务，并为每个服务命名（例如 `web` 和 `redis`）。
- en: This is followed by how to build the `service` (either via a command to build
    or referring a Dockerfile).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这随后是构建 `service` 的方法（通过命令构建或引用 Dockerfile）。
- en: 'If the application needs any port access, we can configure it using `5000:5000`
    (that is internal port: external port).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序需要任何端口访问，我们可以使用 `5000:5000`（即内部端口：外部端口）进行配置。
- en: Then, we have to specify the volume information. This basically tells `docker-compose`
    to serve the files from the location specified.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须指定卷信息。这基本上告诉 `docker-compose` 从指定的位置提供文件。
- en: Once we have specified the services required for our application, then we can
    start the application via `docker-compose`. This will start your entire application
    along with the services, and expose the `services` on the port specified.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们指定了应用程序所需的各项服务，就可以通过 `docker-compose` 启动应用程序。这将启动整个应用程序以及服务，并将 `services`
    暴露在指定的端口上。
- en: 'With `docker-compose`, we can perform the following operations:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker-compose`，我们可以执行以下操作：
- en: '**Start**: `docker-compose -f <docker_file> up`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动**：`docker-compose -f <docker_file> up`'
- en: '**Stop**: `docker-compose -f <docker_file> down`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止**：`docker-compose -f <docker_file> down`'
- en: 'We can also perform the following operations:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以执行以下操作：
- en: '**List the running services and their status**: `docker ps`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列出正在运行的服务及其状态**：`docker ps`'
- en: '**Logs**: `docker log <container_id>`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志**：`docker log <container_id>`'
- en: 'In the compose file, we can add the project name, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `compose` 文件中，我们可以添加项目名称，如下所示：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This can be used for identifying multiple environments. With the help of this,
    we can isolate multiple environments. This helps us to handle multiple instances
    across various `dev`, `QA`, and `prod` environments.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用于识别多个环境。借助这个工具，我们可以隔离多个环境。这有助于我们处理跨各种 `dev`、`QA` 和 `prod` 环境的多个实例。
- en: '`Docker-compose` is itself a great tool for deploying your application along
    with all the services it needs. It provides infrastructure as a code. It is an
    excellent choice for development, QA, and other environments except for production.
    But why?'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Docker-compose` 本身就是一个部署应用程序及其所需所有服务的优秀工具。它提供基础设施即代码。它是开发、QA 和其他环境的绝佳选择，除了生产环境。但为什么？'
- en: '`Docker-compose` is really good for creating and starting your application.
    However, when you want to update an existing container there will be a definite
    downtime, since `docker-compose` will recreate the entire container (there are
    few workarounds to make this happen but still, `docker-compose` needs some improvement
    in this space.)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Docker-compose` 确实是一个创建和启动应用程序的好工具。然而，当你想要更新现有的容器时，将会有一个确定性的停机时间，因为 `docker-compose`
    将重新创建整个容器（虽然有一些方法可以使这成为可能，但 `docker-compose` 在这个领域仍需要一些改进。）'
- en: Kickstarting Kubernetes
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动 Kubernetes
- en: 'According to the Kubernetes website:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Kubernetes网站：
- en: '*Kubernetes is an open-source system for automating deployment, scaling, and
    management of containerized applications.*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*Kubernetes 是一个用于自动化部署、扩展和管理容器化应用程序的开源系统。*'
- en: It is a simple and powerful tool for automatic deployment, scaling, and managing
    containerized applications. It provides zero downtime when you roll out a newer
    application or update an existing application. You can automate it to scale in
    and out based on certain factors. It also provides self-healing, such that Kubernetes
    automatically detects the failing application and spins up a new instance. We
    can also define secrets and configuration that can be used across instances.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个简单而强大的工具，用于自动部署、扩展和管理容器化应用程序。当你推出新应用程序或更新现有应用程序时，它提供零停机时间。你可以根据某些因素自动扩展和缩小。它还提供自我修复功能，即
    Kubernetes 会自动检测失败的应用程序并启动一个新的实例。我们还可以定义可以在实例间使用的密钥和配置。
- en: Kubernetes primarily focuses on zero downtime production applications upgrades,
    and also scales them as required.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 主要关注零停机时间生产应用程序的升级，并根据需要对其进行扩展。
- en: A single deployable component is called a **pod** in Kubernetes. This can be
    as simple as a running process in the container. A group of pods can be combined
    together to form a **deployment**.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中单个可部署的组件被称为 **pod**。这可以简单到容器中运行的一个进程。一组 pod 可以组合在一起形成一个 **deployment**。
- en: Similar to `docker-compose`, we can define the applications and their required
    services in a single YAML file or multiple files (as per our convenience).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `docker-compose`，我们可以在单个 YAML 文件或多个文件（根据我们的方便）中定义应用程序及其所需的服务。
- en: Here also, we start with an `apiVersion` in a Kubernetes deployment file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们同样从一个 Kubernetes 部署文件中的 `apiVersion` 开始。
- en: 'The following code is a sample Kubernetes file that will start a Nginx server:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个示例 Kubernetes 文件，它将启动一个 Nginx 服务器：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Followed by the type, which takes either a pod, deployment, namespace, ingress
    (load balancing the pods), role, and many more.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接着是类型，它可以是 pod、deployment、namespace、ingress（负载均衡 pod）、role 以及更多。
- en: Ingress forms a layer between the services and the internet so that all the
    inbound connections are controlled or configured with the ingress controller before
    sending them to Kubernetes services on the cluster. On the other hand, the egress
    controller controls or configures services going out of the Kubernetes cluster.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Ingress 在服务和互联网之间形成一层，这样在将连接发送到集群上的 Kubernetes 服务之前，所有传入的连接都由 ingress 控制器进行控制或配置。另一方面，egress
    控制器控制或配置离开 Kubernetes 集群的服务。
- en: This is followed by the metadata information, such as the type of environments,
    the application name (nginxsvc), and labels (Kubernetes uses this information
    to identify and segregate the pods). Kubernetes uses this metadata information
    to identify the particular pods or a group of pods, and we can manage the instances
    with this metadata. This is one of the key differences with `docker-compose`,
    where `docker-compose` doesn't have the flexibility of defining the metadata about
    the containers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是元数据信息，例如环境类型、应用程序名称（nginxsvc）和标签（Kubernetes 使用这些信息来识别和隔离 pod）。Kubernetes
    使用这些元数据信息来识别特定的 pod 或 pod 组，我们可以使用这些元数据来管理实例。这是与 `docker-compose` 的一大区别，因为 `docker-compose`
    没有定义容器元数据的灵活性。
- en: This is followed by the spec, where we define the specification of the images
    or our application. We can also define the pull strategy for our images as well
    as define the environment variables along with the exposed ports. We can define
    the resource limitations on the machine (or VM) for a particular service. They
    provide health checks, that is, each service is monitored for the health and when
    some services fail, they are immediately replaced by newer ones. They also provide
    service discovery out of the box, by assigning each pod an IP, which makes it
    easier for the services to identify and interact with them. They also provide
    a better dashboard, to visualize your architecture and the status of the application.
    You can do most of the management via this dashboard, such as checking the status,
    logs, scale up, or down the services, and so on.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 spec，在这里我们定义镜像或应用程序的规范。我们还可以定义镜像的拉取策略，以及定义暴露的端口和环境变量。我们可以在机器（或 VM）上为特定服务定义资源限制。它们提供健康检查，即每个服务都会被监控其健康状态，当某些服务失败时，它们会立即被新的服务替换。它们还提供开箱即用的服务发现，通过为每个
    pod 分配一个 IP 地址，这使得服务更容易识别和与之交互。它们还提供了一个更好的仪表板，用于可视化您的架构和应用程序的状态。您可以通过这个仪表板进行大部分管理，例如检查状态、日志、扩展或缩减服务，等等。
- en: Since Kubernetes provide a complete orchestration of our services with configurable
    options, it makes it really hard to set up initially, and this means it is not
    ideal for a development environment. We also need the **kubectl** CLI tool for
    management. Despite the fact that we use Docker images inside, the Docker CLI
    can't be used.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Kubernetes 提供了完整的配置选项来编排我们的服务，这使得它最初设置起来非常困难，这意味着它不适合开发环境。我们还需要 **kubectl**
    CLI 工具进行管理。尽管我们在内部使用 Docker 镜像，但 Docker CLI 不能使用。
- en: There is also **Minikube** (minified Kubernetes), which is used for developing
    and testing applications locally.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此外还有 **Minikube**（精简版 Kubernetes），它用于本地开发和测试应用程序。
- en: Kubernetes not only takes care of containerizing your application, it also helps
    to scale, manage, and deploy your application. It orchestrates your entire application
    deployment. Additionally, it also provides service discovery and automated health
    checks.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 不仅负责将您的应用程序容器化，它还帮助扩展、管理和部署您的应用程序。它编排了您的整个应用程序部署。此外，它还提供服务发现和自动健康检查。
- en: We will focus more on the Kubernetes sub-generator in the following chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中更多地关注 Kubernetes 子生成器。
- en: Introducing OpenShift
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 OpenShift
- en: OpenShift is a multi-cloud, open source container application platform. It is
    based on Kubernetes and used for developing, deploying, and managing applications.
    It is a common platform for developers and operations. It helps them to build,
    deploy, and manage applications consistently across hybrid cloud and multi-cloud
    infrastructures.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 是一个多云、开源的容器应用程序平台。它基于 Kubernetes，用于开发、部署和管理应用程序。它是开发者和运维人员的通用平台。它帮助他们一致地在混合云和多云基础设施上构建、部署和管理应用程序。
- en: For developers, it provides a self-service platform in which they can provision,
    build, and deploy applications and their components. With automated workflows
    for converting your source to the image, it helps developers go from source to
    ready-to-run, dockerized images.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发者，它提供了一个自助平台，他们可以在其中配置、构建和部署应用程序及其组件。通过自动工作流程将源代码转换为镜像，它帮助开发者从源代码到可运行的、docker化的镜像。
- en: For operations, it provides a secure, enterprise-grade Kubernetes for policy-based
    controls and automation for application management, such as cluster services,
    scheduling, and orchestration with load balancing and auto-scaling capabilities.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于运维人员，它提供了一个安全的、企业级的 Kubernetes，用于基于策略的控制和自动化应用程序管理，例如集群服务、调度和编排，具有负载均衡和自动扩展功能。
- en: JHipster also provides OpenShift deployment files as a separate sub-generator.
    We can generate them by running `jhipster openshift` and answering the questions
    as needed. This will generate OpenShift related deployment files.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 还提供了一个独立的子生成器来提供 OpenShift 部署文件。我们可以通过运行 `jhipster openshift` 并根据需要回答问题来生成它们。这将生成与
    OpenShift 相关的部署文件。
- en: Explaining Rancher
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释 Rancher
- en: Rancher is a container management platform. It is also open source. It helps
    to deploy and maintain containers for any organization. Rancher is merely a deployment
    server that is installed on any Linux machine or cluster. So to use Rancher, we
    should first start the Rancher container, and this requires Docker to be available.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Rancher 是一个容器管理平台。它也是开源的。它帮助任何组织部署和维护容器。Rancher 只是一个部署服务器，它安装在任意的 Linux 机器或集群上。因此，要使用
    Rancher，我们首先应该启动 Rancher 容器，这需要 Docker 可用。
- en: Once started, we can log in to Rancher and start deploying our applications.
    It also has role management. Rancher provides an option to choose between Swarm,
    Kubernetes, or Cattle (and other cluster deployment options). It also provides
    details about the infrastructure and applications that are deployed. It shows
    detailed information about the containers, registries, data pools, and other information
    (related to the container and infrastructure).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动，我们就可以登录到 Rancher 并开始部署我们的应用程序。它还具有角色管理功能。Rancher 提供了在 Swarm、Kubernetes
    或 Cattle（以及其他集群部署选项）之间进行选择的选项。它还提供了有关已部署的基础设施和应用程序的详细信息。它显示了有关容器、注册表、数据池和其他信息（与容器和基础设施相关的信息）的详细信息。
- en: It also provides options to tweak the Kubernetes or Swarm settings as needed,
    so it makes it much easier to scale up and down. It also provides options to launch
    the entire application stack via its UI or using `docker-compose.yml` and `rancher-compose.yml`.
    It also has the capability to load the external services and use them (such as
    a load balancer).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了根据需要调整 Kubernetes 或 Swarm 设置的选项，这使得扩展和缩减规模变得更加容易。它还提供了通过其 UI 或使用 `docker-compose.yml`
    和 `rancher-compose.yml` 启动整个应用程序堆栈的选项。它还具有加载外部服务并使用它们的 capability（例如负载均衡器）。
- en: JHipster also provides Rancher deployment files as a separate sub-generator.
    We can generate them by running `jhipster rancher` and answering the questions
    as needed. This will generate the Rancher configuration files.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 还提供了一个独立的子生成器来提供 Rancher 部署文件。我们可以通过运行 `jhipster rancher` 并根据需要回答问题来生成它们。这将生成
    Rancher 配置文件。
- en: Generated Docker Compose files
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成的 Docker Compose 文件
- en: 'By default, JHipster will generate Docker Compose files that enable us to run
    the application completely in the containerized environment, irrespective of the
    options chosen. For example, in the gateway application that we have generated,
    the following files are generated by default under `src/main/docker`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，JHipster会生成Docker Compose文件，使我们能够在容器化环境中完全运行应用，无论选择了哪些选项。例如，在我们生成的网关应用中，以下文件默认在`src/main/docker`下生成：
- en: '`sonar.yml`: This file creates and starts a SonarQube server'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sonar.yml`：此文件创建并启动一个SonarQube服务器'
- en: '`mysql.yml`: This file creates and starts a MySQL database server and creates
    a user and schema'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mysql.yml`：此文件创建并启动一个MySQL数据库服务器，并创建一个用户和模式'
- en: '`jhipster-registry.yml`: This file creates and starts a JHipster Registry service'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jhipster-registry.yml`：此文件创建并启动一个JHipster注册表服务'
- en: '`app.yml`: This is the main file that creates and starts the application along
    with services such as JHipster registry and the database'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.yml`：这是创建并启动应用以及如JHipster注册表和数据库等服务的主要文件'
- en: In addition to this, JHipster also creates a Dockerfile, which helps you to
    containerize the application alone.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JHipster还创建了一个Dockerfile，这有助于您将应用容器化。
- en: Then we can see a folder called `central-server-config`. This will be used as
    a central configuration server for the JHipster Registry.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以看到一个名为`central-server-config`的文件夹。这将被用作JHipster注册表的中央配置服务器。
- en: When the registry and the application are running in Docker, it uses `application.yml`
    from the `docker-config` folder as the central configuration server.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当注册表和应用在Docker中运行时，它使用`docker-config`文件夹中的`application.yml`作为中央配置服务器。
- en: On the other hand, when running only the registry in Docker mode, the application,
    not in Docker, will use `application.yml` from the `localhost-config` folder.
    The key difference is that the URL defining the Eureka client varies.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当仅以Docker模式运行注册表时，非Docker的应用将使用`localhost-config`文件夹中的`application.yml`。关键区别在于定义Eureka客户端的URL不同。
- en: Let's see the Docker files that have been generated.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看生成的Docker文件。
- en: Walking through the generated files
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看生成的文件
- en: Let's start with the `app.yml` file under `src/main/docker` inside your gateway
    application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从位于您的网关应用`src/main/docker`目录下的`app.yml`文件开始。
- en: 'As we saw at the beginning of the chapter, the file starts with the Docker
    version that it supports:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头所看到的，文件以它支持的Docker版本开始：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is followed by the services section where we define the various services,
    applications, or components that we will kick start with this Docker file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这之后是服务部分，我们在这里定义了各种服务、应用或组件，我们将使用此Docker文件启动它们。
- en: Under services section, we will define a name for the service, in our case we
    have used `gateway-app`, followed by the image that we want to use as a container.
    This image is generated with the help of the Docker file that we have in that
    folder.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务部分，我们将为服务定义一个名称，在我们的例子中我们使用了`gateway-app`，然后是我们要用作容器的图像。这个图像是通过我们那个文件夹中的Docker文件生成的。
- en: 'This is followed by the series of environment variables that our application
    will depend on, they include:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这之后是我们应用将依赖的一系列环境变量，它们包括：
- en: '`SPRING_PROFILES_ACTIVE`: Tells the application to run in production mode and
    expose Swagger endpoints.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SPRING_PROFILES_ACTIVE`：告诉应用以生产模式运行并暴露Swagger端点。'
- en: '`EUREKA_CLIENT_SERVICE_URL_DEFAULTZONE`: Tells the application where to check
    for the JHipster Registry (which is the Eureka client that we are using. If we
    have chosen Consul here, then the application will point to the Consul URL)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EUREKA_CLIENT_SERVICE_URL_DEFAULTZONE`：告诉应用在哪里检查JHipster注册表（这是我们使用的Eureka客户端。如果我们在这里选择了Consul，那么应用将指向Consul
    URL）'
- en: '`SPRING_CLOUD_CONFIG_URI`: Tells the application where to look for the `config`
    service for the application.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SPRING_CLOUD_CONFIG_URI`：告诉应用在哪里查找应用的`config`服务。'
- en: '`SPRING_DATASOURCE_URL`: Tells the application where to look for the data source.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SPRING_DATASOURCE_URL`：告诉应用在哪里查找数据源。'
- en: '`JHIPSTER_SLEEP`: This is a custom property that we have used to make sure
    that the JHipster Registry starts before the application starts up.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JHIPSTER_SLEEP`：这是一个自定义属性，我们用它来确保JHipster注册表在应用启动之前启动。'
- en: 'Finally, we specify on which port the application should run and be exposed:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们指定应用应在哪个端口上运行并暴露：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have just defined the service with the `docker-compose` file; now we have
    to specify two other services that are needed for our application to run. They
    are the database and JHipster Registry.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用 `docker-compose` 文件定义了服务；现在我们必须指定两个其他服务，这些服务对于我们的应用程序运行是必需的。它们是数据库和 JHipster
    注册中心。
- en: 'So, we register another service called `gateway-mysql`, which creates and starts
    the MySQL server. We can define MySQL as a separate Docker Compose file and link
    them in here. So, we put an `extends` keyword followed by the `docker-compose`
    file and the service that we have to start from the specified `docker-compose`
    file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们注册了另一个名为 `gateway-mysql` 的服务，该服务创建并启动 MySQL 服务器。我们可以将 MySQL 定义为单独的 Docker
    Compose 文件，并将其链接在这里。因此，我们放置一个 `extends` 关键字，后面跟着 `docker-compose` 文件和从指定的 `docker-compose`
    文件中启动的服务：
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then we input the following code for the `mysql.yml` file, shown as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们输入以下代码到 `mysql.yml` 文件中，如下所示：
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have again started with the version that it supports followed by the `services`
    keyword and then specify the `service` name, `gateway-mysql` that is used in the
    `app.yml` file. If you want to specify a volume for the persistent data storage
    you can uncomment the commented volumes segment. This basically maps the local
    file location to Docker's internal location so that the data is persistent even
    if the Docker image itself is replaced or updated.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次从它支持的版本开始，接着是 `services` 关键字，然后指定 `service` 名称，`gateway-mysql`，这是在 `app.yml`
    文件中使用的。如果您想指定用于持久数据存储的卷，可以取消注释已注释的卷段。这基本上是将本地文件位置映射到 Docker 的内部位置，以便即使 Docker
    镜像本身被替换或更新，数据也能保持持久。
- en: This is followed by a set of environment variables, such as the username and
    the password (we have set it to empty here, but for a real production application
    it is recommended to set it to a more complex password), and then the database
    schema name.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这之后是一系列环境变量，例如用户名和密码（我们在这里将其设置为空，但对于真正的生产应用程序，建议设置一个更复杂的密码），然后是数据库模式名称。
- en: We have also specified the command that we need to run to start the MySQL server.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还指定了启动 MySQL 服务器所需的命令。
- en: 'Then we go back to the `app.yml` file and we then define the JHipster Registry
    service. This will again extend the `jhipster-registry.yml` and `docker-compose`
    file. One more thing to note here is, even though we extend the services from
    another Docker file, we can override the environment variables that we have specified
    in the original `docker-compose` file. This comes in handy in certain cases where
    we have to kickstart our application with different or customized values. In our
    case, we have overridden the location of the Spring Cloud Config server file location
    from that of the original:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们回到 `app.yml` 文件，并定义 JHipster 注册服务。这将再次扩展 `jhipster-registry.yml` 和 `docker-compose`
    文件。在此需要注意的是，尽管我们从另一个 Docker 文件扩展了服务，但我们仍然可以覆盖在原始 `docker-compose` 文件中指定的环境变量。在某些情况下，当我们需要使用不同的或定制的值启动应用程序时，这非常有用。在我们的例子中，我们已经覆盖了
    Spring Cloud Config 服务器文件位置，从原始位置更改过来：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `Jhipster-registry.yml` file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Jhipster-registry.yml` 文件：'
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We have defined the central-config for JHipster Registry as follows. We have
    configured the secret for the JWT and the Eureka client''s URL. The JWT token
    specified is used for services to authorize and communicate between them and the
    registry:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了 JHipster 注册中心的中央配置如下。我们已配置 JWT 的密钥和 Eureka 客户端的 URL。指定的 JWT 令牌用于服务进行授权以及在它们之间以及与注册中心之间的通信：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Added to these, we also generate a `sonar.yml`, (this file is not important
    for deploying your application):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，我们还生成了一个 `sonar.yml` 文件（此文件对于部署您的应用程序不是很重要）：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Similarly, in the microservices, that is, in our invoice and the notification
    applications, we will have similar files generated. They are the same except for
    the change in the service name.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在微服务中，即在我们的发票和通知应用程序中，我们将生成类似的文件。它们除了服务名称的变化外，都是相同的。
- en: Unlike MySQL, MongoDB is also capable of running as a cluster with different
    nodes and configuration. We need to specify them differently here. So we will
    create have two docker-compose files. `mongodb.yml` is for starting the MongoDB
    with a single node, and the `mongodb-cluster.yml` to start the MongoDB as the
    cluster.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与 MySQL 不同，MongoDB 也能够在具有不同节点和配置的集群中运行。我们需要在这里不同地指定它们。因此，我们将创建两个 docker-compose
    文件。`mongodb.yml` 用于启动具有单个节点的 MongoDB，而 `mongodb-cluster.yml` 用于启动作为集群的 MongoDB。
- en: Please check the database port number between the gateway and the microservice
    application. If they use the same database, there may be a clash in the port number
    since JHipster generates the same port number for both. Change it to any other
    unused port, or Docker Compose will show an error. In our case, I have changed
    it to `3307`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请检查网关和微服务应用程序之间的数据库端口号。如果它们使用相同的数据库，由于JHipster为两者生成相同的端口号，因此可能会在端口号上发生冲突。将其更改为任何其他未使用的端口号，否则Docker
    Compose将显示错误。在我们的例子中，我已经将其更改为`3307`。
- en: Building and deploying everything to Docker locally
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地构建和部署一切到Docker
- en: There are multiple ways in which we can use the `docker-compose` files based
    on our needs.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据需要使用多种方式使用`docker-compose`文件。
- en: In general, when we are developing the application, we can run the application
    with the general Maven or Gradle command so that we can debug the application
    and also reload the changes faster, and start the database and JHipster registry
    with Docker.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们开发应用程序时，我们可以使用通用的Maven或Gradle命令来运行应用程序，这样我们就可以调试应用程序并更快地重新加载更改，同时使用Docker启动数据库和JHipster注册表。
- en: 'Otherwise, you can start the entire application from the `app.yml` file, which
    will kickstart the database, JHipster Registry, and then the application itself.
    To do that, open your terminal or Command Prompt, go to the application folder,
    and then run the following command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，您可以从`app.yml`文件启动整个应用程序，这将启动数据库、JHipster注册表，然后是应用程序本身。为此，打开您的终端或命令提示符，转到应用程序文件夹，然后运行以下命令：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then we have to first Dockerize the application by taking a production build
    of our application with the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须首先通过以下命令对我们的应用程序进行生产构建以Docker化应用程序：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once done, we can start the app via the `docker-compose` command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以通过`docker-compose`命令启动应用程序：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`-f` specifies the file with which `docker-compose` should start the server.
    The `-d` flag tells `docker-compose` to run everything in detached mode. This
    will start the application in Docker and expose the application on port `8080`,
    the registry server on port `8761`, and the database on port `3306`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f`指定`docker-compose`应该启动服务器的文件。`-d`标志告诉`docker-compose`以分离模式运行一切。这将启动Docker中的应用程序，并在端口`8080`上公开应用程序，在端口`8761`上公开注册服务器，在端口`3306`上公开数据库。'
- en: 'Then we can go to the respective microservices folder and do the same, create a
    docker image with the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以进入各自的微服务文件夹并执行相同的操作，使用以下命令创建Docker镜像：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then we can start the application via `docker-compose` with the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过以下命令使用`docker-compose`启动应用程序：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can check the running Docker containers with the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令检查正在运行的Docker容器：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It should list all seven containers:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该列出所有七个容器：
- en: '![](img/823303fc-e453-42ca-b415-eb29d6ec4793.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/823303fc-e453-42ca-b415-eb29d6ec4793.png)'
- en: As you can see, there are three app containers (gateway/notification, and invoice),
    and then a JHipster-Registry, followed by three database containers (two MySQL
    and one MongoDB. The order may vary).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有三个应用程序容器（网关/通知和发票），然后是一个JHipster-Registry，接着是三个数据库容器（两个MySQL和一个MongoDB。顺序可能有所不同）。
- en: If you are using JHipster Version 5 or above use `bootWar` instead of the `bootRepackage`
    command in Gradle.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用JHipster版本5或更高版本，请使用`bootWar`而不是Gradle中的`bootRepackage`命令。
- en: Generating docker-compose files for microservices
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为微服务生成docker-compose文件
- en: There are many `docker-compose` files and maintaining them is hard. Thankfully,
    JHipster has a `docker-compose` sub generator bundled with it. The `Docker-compose` sub
    generator helps you to organize all your application's Dockerfiles together. It
    creates a single Dockerfile that refers to the application's Dockerfiles.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多`docker-compose`文件，维护它们很困难。幸运的是，JHipster附带了一个`docker-compose`子生成器。`Docker-compose`子生成器帮助您将所有应用程序的Dockerfile组织在一起。它创建一个单独的Dockerfile，该文件引用应用程序的Dockerfile。
- en: 'Let''s go to the base folder and create a folder and name it `docker-compose`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到基本文件夹并创建一个文件夹，并将其命名为`docker-compose`：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once inside the `docker-compose` folder, we can run the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入`docker-compose`文件夹，我们可以运行以下命令：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will generate the Dockerfiles.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成Dockerfile。
- en: 'As usual, it will ask us a series of questions, before generating the files:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，在生成文件之前，它将询问我们一系列问题：
- en: '![](img/6fc3ae79-37a7-4a6c-a6a1-458d5c2f7a51.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fc3ae79-37a7-4a6c-a6a1-458d5c2f7a51.png)'
- en: At first, it asks which type of application we would like to deploy. We will
    select the microservice application as an option.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它会询问我们想部署哪种类型的应用程序。我们将选择微服务应用程序作为选项。
- en: This is followed by choosing the type of gateway that we would like to use;
    there are two options available, a JHipster-gateway with Zuul proxy, and the more
    exciting, Traefik gateway with Consul
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这之后，它将询问我们希望使用哪种类型的网关；有两个选项可供选择，一个是带有Zuul代理的JHipster-gateway，另一个是更令人兴奋的、带有Consul的Traefik网关
- en: 'Let us choose JHipster-gateway with Zuul proxy:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择带有Zuul代理的JHipster-gateway：
- en: '![](img/2d028b76-22d8-4930-8ee0-f5f9f8b45bfe.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2d028b76-22d8-4930-8ee0-f5f9f8b45bfe.png)'
- en: Then, we have to select the location of the microservices gateway and applications.
    This is the main reason why we have generated the applications inside a single
    parent folder. This will help plugins and sub-generators to easily find the docker
    configuration files created. We will select the default option (../)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须选择微服务网关和应用程序的位置。这是我们为什么在单个父文件夹内生成应用程序的主要原因。这将帮助插件和子生成器轻松找到创建的docker配置文件。我们将选择默认选项（../）
- en: '![](img/a480c434-a824-4568-bcc5-cca434bbe6d5.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a480c434-a824-4568-bcc5-cca434bbe6d5.png)'
- en: After selecting the location, JHipster will search inside the given folder for
    any JHipster generated the application and list them in the next question.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 选择位置后，JHipster将在给定的文件夹内搜索任何由JHipster生成的应用程序，并在下一个问题中列出它们。
- en: 'In our case, it lists notification, invoice, and gateway. We can choose all
    of them and hit *Enter*:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，它列出了通知、发票和网关。我们可以选择所有这些并按*Enter*键：
- en: '![](img/9af279b6-42ad-4a37-9413-0b1590627a08.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9af279b6-42ad-4a37-9413-0b1590627a08.png)'
- en: 'It automatically detects that we have used MongoDB and asks us the next question;
    whether we would like to have MongoDB as a cluster. We will not choose anything
    here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 它会自动检测我们已经使用了MongoDB，并询问我们下一个问题；是否希望将MongoDB作为集群使用。我们在这里不会选择任何内容：
- en: '![](img/36154e7c-2dee-4177-93c5-7e844dd8ee14.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/36154e7c-2dee-4177-93c5-7e844dd8ee14.png)'
- en: 'Then it asks about the console; whether we need to set up any consoles for
    the application. We will choose logs and metrics with the JHipster Console (based
    on ELK and Zipkin):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它会询问关于控制台的问题；是否需要为应用程序设置任何控制台。我们将选择带有JHipster控制台（基于ELK和Zipkin）的日志和指标：
- en: '![](img/604d8af5-db29-4b8e-923f-da698e6691c7.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/604d8af5-db29-4b8e-923f-da698e6691c7.png)'
- en: We can either opt out from the monitoring option or choose Prometheus. That
    connects with Prometheus and shows metrics only.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择退出监控选项或选择Prometheus。这将连接到Prometheus并仅显示指标。
- en: 'Then JHipster asks whether you need Curator or Zipkin:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，JHipster会询问您是否需要Curator或Zipkin：
- en: Curator will help you to curate and manage the indices created by Elasticsearch
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引管理员将帮助您管理和维护由Elasticsearch创建的索引。
- en: Zipkin (as discussed in the previous chapter)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zipkin（如前一章所述）
- en: '![](img/cf0fdc3c-a344-4a4f-9b3f-5e89b59f50df.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cf0fdc3c-a344-4a4f-9b3f-5e89b59f50df.png)'
- en: Since the JHipster console is chosen, it will ask for additional pieces of information
    supported by the console. They include Zipkin and Curator. We have already seen
    Zipkin. Curator, on the other hand, will help us to manage and curate the indices
    in Elasticsearch.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于选择了JHipster控制台，它将询问控制台支持的其他信息。它们包括Zipkin和Curator。我们已经看到了Zipkin。另一方面，Curator将帮助我们管理和维护Elasticsearch中的索引。
- en: We will choose only Zipkin here.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将只选择Zipkin。
- en: '![](img/59d1b8c4-99c8-468a-b7c5-d49e46f271d9.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/59d1b8c4-99c8-468a-b7c5-d49e46f271d9.png)'
- en: We can also choose nothing here and go with the default option.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在这里选择不选择任何内容，并使用默认选项。
- en: 'Finally, it asks for the password for the JHipster Registry; we will go with
    the default here:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它要求输入JHipster Registry的密码；我们将在这里使用默认设置：
- en: '![](img/0b3bd232-743e-416d-9c10-d6c2451fbfb5.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0b3bd232-743e-416d-9c10-d6c2451fbfb5.png)'
- en: That is it; we have just created a higher-level Dockerfile that has information
    about all the services that we need to run the application successfully.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；我们刚刚创建了一个更高层次的Dockerfile，其中包含所有我们需要成功运行应用程序所需的信息。
- en: 'Now we can just run the entire suite with the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令运行整个套件：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will start the gateway, notification, invoice, and the registry, along
    with the console and all other required services.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动网关、通知、发票和注册表，以及控制台和所有其他所需服务。
- en: Features of the deployed application
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署应用程序的功能
- en: 'Thus, the deployed applications are ready to be launched. We can launch the
    JHipster Registry at `http://localhost:8761`; it will list all the registered
    applications:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，部署的应用程序已准备好启动。我们可以在`http://localhost:8761`启动JHipster Registry；它将列出所有已注册的应用程序：
- en: '![](img/3eb7cfcc-036a-43f0-9766-e232a6c9196f.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3eb7cfcc-036a-43f0-9766-e232a6c9196f.png)'
- en: 'Added to that, the registry also tells us the number of instances that are
    registered. Navigate to Eureka | Instances to check that. Currently, we have one
    of each instance registered:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，注册表还告诉我们已注册的实例数量。导航到 Eureka | 实例以检查。目前，每种实例都注册了一个：
- en: '![](img/639db113-5f5f-4644-90e3-673bb49742ba.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/639db113-5f5f-4644-90e3-673bb49742ba.png)'
- en: Similarly, the Gateway application will list down the microservices that are
    connected to it. Go to `http://localhost:8080`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，网关应用将列出连接到它的微服务。访问 `http://localhost:8080`。
- en: 'Navigate to Administration | Gateway to see the microservices applications
    that are connected to this Gateway application:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到管理 | 网关，查看连接到此网关应用的微服务应用：
- en: '![](img/51b49e7e-d335-4760-9356-7aa15d0f1646.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/51b49e7e-d335-4760-9356-7aa15d0f1646.png)'
- en: JHipster console demo
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JHipster 控制台演示
- en: JHipster also provides a console application based on the ELK stack, which can
    be used for logs and metrics monitoring of the application. JHipster Console is
    another open source application. It is really useful and provides some nice dashboards
    to visualize the application. As with other JHipster products, it is much easier
    to get started with the JHipster Console.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 还提供了一个基于 ELK 堆栈的控制台应用程序，可用于应用程序的日志和指标监控。JHipster 控制台是另一个开源应用程序。它非常有用，并提供了一些很好的仪表板来可视化应用程序。与其他
    JHipster 产品一样，使用 JHipster 控制台更容易上手。
- en: 'Let''s go back to our book folder, and then clone the JHipster console project
    from GitHub ([https://github.com/jhipster/jhipster-console](https://github.com/jhipster/jhipster-console)):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的书籍文件夹，然后从 GitHub 克隆 JHipster 控制台项目（[https://github.com/jhipster/jhipster-console](https://github.com/jhipster/jhipster-console)）：
- en: '[PRE20]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Before we start our console, we need to make our applications log the metrics
    and log into the console. To make that happen, we need to change a few settings
    in our applications and then restart them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始控制台之前，我们需要让我们的应用程序记录指标并登录到控制台。为此，我们需要更改应用程序中的几个设置，然后重新启动它们。
- en: 'Let''s go to our `application-prod.yml` file in all the applications (gateway
    and microservices application) and enable the logstash and logs:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到所有应用程序（网关和微服务应用）中的 `application-prod.yml` 文件，并启用 logstash 和日志：
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Set enabled to true in `metrics.logs.enabled` and also `logging.logstash.enabled`.
    This will push the logs to the console application. JHipster Console will collect
    this information and show it in nice-looking dashboards with the help of Kibana.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `metrics.logs.enabled` 和 `logging.logstash.enabled` 中将启用设置为 true。这将把日志推送到控制台应用程序。JHipster
    控制台将收集这些信息，并借助 Kibana 在漂亮的仪表板中显示它们。
- en: 'Once cloned, we can go into this folder and then start the `jhipster-console`
    with the help of `docker-compose`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦克隆完成，我们可以进入这个文件夹，然后使用`docker-compose`启动`jhipster-console`：
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That is it. Your console is running on `http://localhost:5601`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。您的控制台正在 `http://localhost:5601` 上运行。
- en: 'Kibana provides the following (customizable) dashboards:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Kibana 提供以下（可自定义）仪表板：
- en: '![](img/490f238b-6224-40c9-90a9-45035675d289.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/490f238b-6224-40c9-90a9-45035675d289.png)'
- en: 'Kibana also provides application-level metrics, such as JVM threads metrics
    and other details:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Kibana 还提供应用程序级别的指标，例如 JVM 线程指标和其他详细信息：
- en: '![](img/53dc92f3-6f24-41cf-86b2-623c87c342ff.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/53dc92f3-6f24-41cf-86b2-623c87c342ff.png)'
- en: 'Added to this, the console also has an interface where we can see the application
    logs. It shows the log of all the applications deployed. We can filter and search
    the logs with respect to the application:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，控制台还有一个界面，我们可以看到应用程序日志。它显示了所有部署的应用程序的日志。我们可以根据应用程序过滤和搜索日志：
- en: '![](img/a12046f7-0bda-4168-a082-5bc6b2b2918a.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a12046f7-0bda-4168-a082-5bc6b2b2918a.png)'
- en: Kibana also provides a machine-learning tab where we can create a job to track
    the data and then choose any metric available to track it as a sum, count, high
    count, and so on.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Kibana 还提供了一个机器学习标签，我们可以创建一个作业来跟踪数据，然后选择任何可用的指标来跟踪它，如总和、计数、高计数等。
- en: Scaling up with Docker Swarm
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker Swarm 进行扩展
- en: Docker Swarm is Docker's orchestrating layer to manage the containers. It is
    a cluster management tool that focuses on creating replicas of your services,
    networks, as well as storage resources available to it and managing them.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm 是 Docker 的编排层，用于管理容器。它是一个集群管理工具，专注于创建服务的副本、网络以及它可用的存储资源，并管理它们。
- en: The Docker Swarm is nothing more than a cluster of Docker nodes. They act as
    a manager or worker. One interesting feature to note is that a Docker container
    inside the Swarm can either be a manager or worker or both. This helps the swarm
    to allocate a new manager when the manager nodes go down.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm不过是一组Docker节点。它们充当管理节点或工作节点。一个值得注意的有趣特性是，Swarm内部的Docker容器可以是管理节点、工作节点或两者都是。这有助于Swarm在管理节点故障时分配新的管理节点。
- en: At a high level, the manager nodes are responsible for cluster management tasks
    and execute containers. The workers are responsible for executing the containers
    only.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，管理节点负责集群管理任务并执行容器。工作节点只负责执行容器。
- en: 'JHipster applications give us the flexibility to scale our entire application
    with a single command, with JHipster''s `docker-compose sub-generator`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster应用程序为我们提供了使用单个命令扩展整个应用程序的灵活性，通过JHipster的`docker-compose sub-generator`：
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we can scale the instances, using the following command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下命令来扩展实例：
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding command will spin another invoice instance and we can see it
    on the dashboard, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将启动另一个发票实例，我们可以在以下仪表板上看到它：
- en: '![](img/8c9ea7db-888c-4ceb-87a6-dfc146928e9c.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c9ea7db-888c-4ceb-87a6-dfc146928e9c.png)'
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So far, we have seen how to generate, set up, and start JHipster Registry and
    console, and, we have looked at their features. This was followed by how to scale
    the application with `docker-swarm`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何生成、设置和启动JHipster Registry和console，以及我们查看它们的特性。这之后是关于如何使用`docker-swarm`扩展应用程序。
- en: In the next chapter, we will see how to deploy the application to the Google
    Cloud using Kubernetes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何使用Kubernetes将应用程序部署到Google Cloud。
