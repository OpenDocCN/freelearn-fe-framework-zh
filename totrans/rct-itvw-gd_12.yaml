- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building an App Based on the Next.js Toolkit, Authentication, SWR, GraphQL,
    and Deployment
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout our journey in this book, we have learned new skills, methodologies,
    and better ways of thinking. This chapter is the culmination of our efforts, so
    let’s move forward, as it is now time for us to put everything we have learned
    together as we seek to develop an exciting application that features an up-to-date
    modern tech stack. This chapter will allow us to progress from concept to the
    deployment of a Next.js application that has implementations for authentication,
    **stale-while-revalidate** (**SWR**), GraphQL, and deployment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: We will start with a quick introduction to REST APIs, which will be a fantastic
    refresher if you are already familiar with them, or a great introduction if it’s
    your first time learning about this essential methodology. Then, we shall move
    on to figuring out how best to plan the architecture for an application, where
    we will go into how authentication works. This will be followed up by how effective
    SWR is and why it’s worth using, as it’s a very useful aspect that can enhance
    the performance of our applications. Next, we will learn about GraphQL and how
    it compares with traditional REST APIs. Then, we will end with deployment, which
    is where we finally publish our local development build online so that the whole
    world can use it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In the sections that follow, we will talk about the ideas behind business logic
    and how the code we write has significant importance not just for the way our
    application runs but also for how it can reflect positively or negatively on our
    team and company depending on how well it is written. Moving on, we will go through
    creating the presentation layer, which is essential to the user interface and
    user experience. Testing is going to be the next major feature that we touch on,
    as it’s highly recommended that production-ready applications have a robust testing
    suite set up to guarantee that it is stable and in a state that is ready to be
    published as a **minimum viable** **product** (**MVP**).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: With those features completed, we will finish off by learning how to deploy
    our application so that the public can access it. In the last sections, we will
    create a Git repository with a README file.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of topics, the following will be the themes that we will be focusing
    on in the upcoming sections:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Quick introduction to REST APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning the application architecture including authentication, SWR, GraphQL,
    and deployment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the business logic
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the presentation layer
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing testing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Git repository with README documentation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the application for public access
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On your machine, confirm that [https://nodejs.org/en](https://nodejs.org/en)
    is up to date and that the JavaScript Node package for Next.js is set up and operational.
    You can use whatever package manager you want, be it `npm`, `yarn`, or `pnpm`.
    Just make sure that you use the appropriate commands when doing the installation.
    For simplicity’s sake, we will be using `npm`. Work on your project with your
    preferred **integrated development environment** (**IDE**) and **command-line
    interface** (**CLI**) tool. You will also need to have an account on [https://vercel.com/](https://vercel.com/)
    for the deployment section when we build our app. For the authentication section,
    we will use GitHub and Google, so in the unlikely event that you don’t have accounts
    for both of these services already, create one now. GitHub is also required for
    the version control section, so it’s essential for you to have an account.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的机器上，请确认 [https://nodejs.org/en](https://nodejs.org/en) 已更新，并且 Next.js 的 JavaScript
    节点包已设置并运行。您可以使用您想要的任何包管理器，无论是 `npm`、`yarn` 还是 `pnpm`。只需确保在安装时使用适当的命令。为了简化起见，我们将使用
    `npm`。使用您首选的 **集成开发环境**（**IDE**）和 **命令行界面**（**CLI**）工具来处理您的项目。您还需要在 [https://vercel.com/](https://vercel.com/)
    上有一个账户，以便在构建我们的应用程序时进行部署部分。对于认证部分，我们将使用 GitHub 和 Google，所以如果您还没有这两个服务的账户，现在就创建一个。GitHub
    也需要用于版本控制部分，因此拥有一个账户是必不可少的。
- en: The package for Next.js can be found at [https://nextjs.org/](https://nextjs.org/).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 的包可以在 [https://nextjs.org/](https://nextjs.org/) 找到。
- en: The project and code base can be found online at [https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter12/coffee-restaurant](https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter12/coffee-restaurant).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 项目和代码库可以在 [https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter12/coffee-restaurant](https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter12/coffee-restaurant)
    上找到。
- en: To begin, let’s first talk about REST APIs to understand their core concepts.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们先谈谈 REST API，以便了解其核心概念。
- en: Quick introduction to REST APIs
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速了解 REST API
- en: A **Representational State Transfer Application Programming Interface** (**REST
    API**) is a particular technology that has established itself as the cornerstone
    of contemporary web development. By using REST APIs within JavaScript and React
    applications, developers can develop robust and dynamic web apps that can communicate
    with other platforms and information sources. Developers can transfer data between
    the server and client using the REST API without worrying about the architecture
    of the underlying apps. In simple terms, the REST API standardizes communication
    protocols, which simplifies development. With the correct tools and skills, REST
    APIs can totally alter the way web developers work.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**表示状态转移应用程序编程接口**（**REST API**）是一种特定的技术，它已经确立了自己作为当代网络开发基石的地位。通过在 JavaScript
    和 React 应用程序中使用 REST API，开发者可以开发出健壮且动态的网络应用程序，这些应用程序可以与其他平台和信息源进行通信。开发者可以使用 REST
    API 在服务器和客户端之间传输数据，而无需担心底层应用程序的架构。简单来说，REST API 标准化了通信协议，从而简化了开发。有了正确的工具和技能，REST
    API 可以完全改变网络开发者工作的方式。'
- en: We can easily understand the core methodology and concept of a REST API by using
    a restaurant as an example. This is considered to be a popular way to describe
    how the process works. For example, let’s say that a user has a restaurant application.
    Basically, the user requests some data for their menu page, which is equivalent
    to a user in a restaurant asking a waiter for some food. In this case, the waiter
    who is taking the food request is the same as the API taking the request to display
    the menu. The waiter then goes to the kitchen to get the food, which is equivalent
    to the API getting the application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用餐厅作为例子来轻松理解 REST API 的核心方法和概念。这被认为是一种描述工作流程的流行方式。例如，假设一个用户有一个餐厅应用程序。基本上，用户会请求菜单页面的某些数据，这相当于餐厅里的顾客向服务员点菜。在这种情况下，接受食物请求的服务员与接收显示菜单请求的
    API 相同。服务员随后去厨房取食物，这相当于 API 获取应用程序。
- en: So, let’s imagine that the application has a list of food on the menu. A customer
    takes a look at the menu and then gives their order to a waiter. The waiter goes
    to the kitchen with the customer’s order and waits for the meal to be completed.
    When the food is ready, the kitchen staff give the food to the waiter, who then
    responds by returning to the customer with the food they requested. In a real-world
    situation, the customer now has a meal to eat. If we imagine this as a website,
    then a page has now loaded with a table that shows food from the menu inside it.
    This information was fetched via the API to the backend server application, which
    returned it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: This example is perfectly illustrated in *Figure 12**.1*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: Describing a REST API](img/Figure_12.01_B18603.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Describing a REST API'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now learn how we can manage our APIs using various tools. This is another
    important skill for developers to have.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: What tools can we use for testing our APIs?
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When doing API development, it is normal for a developer to use an API tool
    for managing, testing, and interacting with the API. Some of the most popular
    API development tools for JavaScript development can be seen in *Table 12.1*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '| **API tool** | **Website address** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
- en: '| Postman | [https://www.postman.com/](https://www.postman.com/) |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
- en: '| Insomnia | [https://insomnia.rest/](https://insomnia.rest/) |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: '| Swagger | [https://swagger.io/](https://swagger.io/) |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| Thunder Client | [https://www.thunderclient.com/](https://www.thunderclient.com/)
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: 'Table 12.1: Popular JavaScript REST API tools'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: With these tools, we can thoroughly test our REST APIs and it is even possible
    to use this as a basis for creating the documentation. There is something that
    we need to be aware of though when building APIs, and that is **cross-origin resource
    sharing** (**CORS**). CORS is basically an application integration method. CORS
    specifies a method for client web applications loaded in a single domain to communicate
    with assets located in another domain. So, essentially, if we do not specify or
    allow CORS access in our APIs, then we will be blocked from accessing them unless
    they are on the same server.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could have an API hosted online on a website, and let’s say
    that we have a React application that is online on a different server somewhere.
    If our API is not set up for CORS, then our React application can’t connect to
    it to retrieve any data, and we will just get a CORS error in our browser console,
    as shown in the following figure:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: A CORS error web browser console message](img/Figure_12.02_B18603.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: A CORS error web browser console message'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to move on to learning about REST APIs in more detail now that we
    have a better understanding of how they are set up. So, let’s see what features
    are on offer.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Which features are available in a REST API?
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A REST API is a strong tool that gives developers access to a wide range of
    functions. The REST API’s excellent security system is one of its most important
    characteristics. It guarantees that any malicious attacks won’t be made on the
    data given over the API. Additionally, the REST API’s capacity to scale is another
    crucial aspect, which implies that it is a great option for apps with heavy traffic
    because it can manage a lot of queries. Another remarkable quality of REST APIs
    is their flexibility, which lets developers use any architecture or technology
    of their choosing. REST APIs are an excellent tool for developers who wish to
    create dependable and durable apps thanks to all these features taken together.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 是一个强大的工具，它为开发者提供了访问广泛功能的能力。REST API 的出色安全系统是其最重要的特性之一。它保证了通过 API 提供的数据不会受到恶意攻击。此外，REST
    API 的可扩展性是另一个关键方面，这意味着它对于流量大的应用程序是一个很好的选择，因为它可以处理大量的查询。REST API 的另一个显著特点是它们的灵活性，这使得开发者可以使用他们选择的任何架构或技术。由于所有这些特性的结合，REST
    API 是开发者创建可靠和耐用的应用程序的绝佳工具。
- en: A REST API is capable of requesting and responding to requests, but what does
    that mean? Let’s find out.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 能够请求和响应请求，但这究竟意味着什么？让我们来探究一下。
- en: What is the difference between requests and responses when making requests to
    a REST API?
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在向 REST API 发送请求时，请求和响应之间的区别是什么？
- en: Understanding how HTTP requests and responses operate is essential if you want
    to create a web application that connects to a REST API. Data is sent from a client
    to a server using HTTP requests, and it is sent back from the server to the client
    using HTTP responses. REST APIs interact between clients and servers using **GET**,
    **POST**, **PUT**, and **DELETE** standard HTTP protocols. We can build web apps
    that easily interface with REST APIs by designing them with greater effectiveness
    and efficiency by knowing how these requests and responses operate. There are
    other HTTP protocols available, but the standard ones are the most common. Now,
    let’s understand the difference between these HTTP protocols.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建一个连接到 REST API 的网络应用程序，理解 HTTP 请求和响应的工作方式是至关重要的。数据通过 HTTP 请求从客户端发送到服务器，并通过
    HTTP 响应从服务器发送回客户端。REST API 通过 **GET**、**POST**、**PUT** 和 **DELETE** 标准HTTP协议在客户端和服务器之间进行交互。通过了解这些请求和响应的工作方式，我们可以设计出更有效率和效率的
    Web 应用程序，以便它们能够轻松地与 REST API 接口。虽然还有其他 HTTP 协议可用，但标准协议是最常见的。现在，让我们了解这些 HTTP 协议之间的区别。
- en: What is a GET request?
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是 GET 请求？
- en: A `GET` request is a method that is used to obtain data from the server. It
    is a read-only procedure so there is no negative impact on the server. `GET` requests
    do not cause the data or the server to change its state.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET` 请求是一种用于从服务器获取数据的方法。它是一个只读过程，因此不会对服务器产生负面影响。`GET` 请求不会导致数据或服务器改变其状态。'
- en: What is a POST request?
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是 POST 请求？
- en: A `POST` request is used to transmit information to the server in order to establish
    new data. It is not immutable, which means that submitting the same `POST` request
    many times might get different results. `POST` requests generally return the URL
    or an instance of the newly created resource.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `POST` 请求将信息传输到服务器以建立新的数据。它不是不可变的，这意味着多次提交相同的 `POST` 请求可能会得到不同的结果。`POST`
    请求通常返回 URL 或新创建的资源实例。
- en: What is a PUT request?
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是 PUT 请求？
- en: A `PUT` request can be utilized to add new information to preexisting server
    data. It is capable of change, so you can send the same `PUT` request to get different
    results. Based on the way it’s done, if the data does not exist, the server could
    create it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT` 请求可以用来向现有的服务器数据添加新信息。它是可变的，因此你可以发送相同的 `PUT` 请求以获得不同的结果。根据其执行方式，如果数据不存在，服务器可能会创建它。'
- en: What is a DELETE request?
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是 DELETE 请求？
- en: The `DELETE` request is used to remove data from the server. It is also immutable,
    which means that sending the same `DELETE` request multiple times has the same
    outcome. Following the deletion of data, the server normally provides a status
    indicating whether the action was successful or unsuccessful.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE` 请求用于从服务器删除数据。它也是不可变的，这意味着多次发送相同的 `DELETE` 请求会产生相同的结果。在删除数据后，服务器通常会提供一个状态，表明操作是成功还是失败。'
- en: 'We can see an example REST API application in this code example here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们可以看到一个示例 REST API 应用程序：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example, we have a `static` route, which is used for serving files
    such as images, CSS, and JavaScript, for example, so long as they are in a public
    folder in our app. We have a `GET` route for the API, which just returns a JSON
    object. Lastly, we have a `POST` route, which logs to the console and returns
    a JSON object of whatever text a user sends as a `POST` request, as in this example:
    `http://localhost:8080/post/helloworld`.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个`静态`路由，用于提供文件，例如图片、CSS和JavaScript，只要它们位于我们应用中的公共文件夹内。我们有一个用于API的`GET`路由，它只返回一个JSON对象。最后，我们有一个`POST`路由，它将日志记录到控制台，并返回用户作为`POST`请求发送的任何文本的JSON对象，例如这个例子：`http://localhost:8080/post/helloworld`。
- en: HTTP protocols are just one aspect of a REST API. It is also important to have
    good authentication set up. Continue reading to see why this is the case.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议只是REST API的一个方面。同时，设置良好的认证也很重要。继续阅读以了解为什么这是这种情况。
- en: Why is authentication important when using a REST API?
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用REST API时，认证为什么很重要？
- en: 'Using a REST API requires authentication to ensure that private data is kept
    secure. Authentication requires confirming the user’s identity before giving access
    to API capabilities. This helps to avoid unauthorized data access or usage, which
    might endanger users. When communicating with an API, you’ll probably utilize
    a variety of authentication mechanisms, including token-based authentication and
    OAuth. These methods guarantee that only authorized users have access to the API
    and are allowed to send requests or get data. Understanding authentication while
    interacting with a REST API can potentially assist us in building a more secure
    and efficient solution. It is possible to understand authentication flow if we
    see it in a diagram such as this one:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用REST API需要认证以确保私有数据的安全。认证需要在提供API功能访问之前确认用户的身份。这有助于避免未经授权的数据访问或使用，这可能会危及用户。在与API通信时，你可能会利用各种认证机制，包括基于令牌的认证和OAuth。这些方法确保只有授权用户才能访问API并允许发送请求或获取数据。在与REST
    API交互时理解认证可以帮助我们构建更安全、更高效的解决方案。如果我们通过如图所示的图表来观察认证流程，就有可能理解认证流程。
- en: '![Figure 12.3: The REST API authentication flow](img/Figure_12.03_B18603.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3：REST API认证流程](img/Figure_12.03_B18603.jpg)'
- en: 'Figure 12.3: The REST API authentication flow'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：REST API认证流程
- en: Another aspect worth discussing is error handling because it’s crucial that
    we check for mistakes, which is very important when authentication and user details
    are involved. Let’s discover how having effective error handling can make our
    application more trustworthy.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 值得讨论的另一个方面是错误处理，因为检查错误非常重要，尤其是在涉及认证和用户详情时。让我们发现有效的错误处理如何使我们的应用程序更加值得信赖。
- en: How can we use error handling when integrating with a REST API?
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们如何在集成REST API时使用错误处理？
- en: Connecting with a REST API is occasionally difficult, especially when confronted
    with errors. However, having a robust error-handling plan in place could spare
    us time and hassle in the long term. One useful strategy is to specify error codes
    and messages that our application can recognize and respond to. Furthermore, installing
    automatic retries and monitoring systems can assist in identifying and addressing
    issues more rapidly. Another important topic is dealing with data validation mistakes,
    as API inputs must be thoroughly scrutinized before being utilized in our application.
    We can ensure easy integration with a REST API and deliver an improved user experience
    for our clients by being proactive and comprehensive in our approach to error
    management.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与REST API连接有时很困难，尤其是在遇到错误时。然而，有一个强大的错误处理计划可以长期节省我们时间和麻烦。一个有用的策略是指定我们的应用程序可以识别并响应的错误代码和消息。此外，安装自动重试和监控系统可以帮助更快地识别和解决问题。另一个重要的话题是处理数据验证错误，因为API输入在使用我们应用程序之前必须彻底审查。通过在错误管理方面采取积极主动和全面的方法，我们可以确保轻松集成REST
    API并为我们的客户提供更好的用户体验。
- en: The last topic we’ll cover in this section is GraphQL. So, let’s now see how
    GraphQL compares with a traditional REST API.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中我们将讨论的最后一个主题是GraphQL。那么，现在让我们看看GraphQL是如何与传统REST API进行比较的。
- en: What is the difference between a REST API and GraphQL?
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST API和GraphQL之间的区别是什么？
- en: REST and GraphQL are two techniques for the creation and operation of web service
    APIs; however, they differ in numerous ways. GraphQL tends to be more flexible
    because you can request only the data you need and not all at once as with REST
    APIs. This is great because it means fewer data transfer requests on the network.
    Another area GraphQL excels in is versioning history because it is not reliant
    on versions, which is the case with REST APIs, requiring more manual hands-on
    work. Despite this, they both have pros and cons over each other and, when comparing
    the two, we can see how they offer us different advantages and disadvantages.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: REST和GraphQL是创建和操作网络服务API的两种技术；然而，它们在许多方面有所不同。GraphQL通常更灵活，因为您可以请求所需的数据，而不是像REST
    API那样一次性请求所有数据。这很好，因为它意味着网络上数据传输请求更少。GraphQL在版本历史记录方面也表现出色，因为它不依赖于版本，这与REST API的情况不同，需要更多手动操作。尽管如此，它们在彼此之间都有优点和缺点，在比较两者时，我们可以看到它们为我们提供了不同的优势和劣势。
- en: Fetching data
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取数据
- en: The end user often uses a REST API to access resources through preset endpoints,
    where each endpoint is associated with a single resource or a group of related
    resources. The client makes HTTP requests to these endpoints in order to get or
    modify data. When using GraphQL, a client sends queries or mutations to a single
    endpoint, indicating the data it requires or the modifications it wants to make.
    In comparison to REST API, this allows the client to only retrieve the data they
    actually need, eliminating the need for requesting more data than required or
    too little data.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最终用户通常通过预设的端点使用REST API来访问资源，每个端点都与单个资源或一组相关资源相关联。客户端向这些端点发送HTTP请求以获取或修改数据。当使用GraphQL时，客户端向单个端点发送查询或突变，指示所需的数据或想要进行的修改。与REST
    API相比，这允许客户端仅检索实际需要的数据，消除了请求比所需更多或太少数据的需求。
- en: Caching data
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存数据
- en: To improve efficiency and lessen server load, REST APIs can make use of ETags
    and cache-control headers, two common HTTP caching methods. In contrast, because
    of GraphQL’s flexible query form, caching is more difficult. The usage of unique
    caching techniques offered by GraphQL client-side libraries such as Apollo Client
    or application-level caching is frequently required by clients.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高效率和减轻服务器负载，REST API可以使用ETags和缓存控制头，这两种是常见的HTTP缓存方法。相比之下，由于GraphQL的灵活查询形式，缓存更困难。客户端通常需要使用如Apollo
    Client或应用程序级缓存等GraphQL客户端库提供的独特缓存技术。
- en: Documentation
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档
- en: Within REST APIs, documentation is frequently given separately, and it is the
    responsibility of the programmers to keep it up to date. If not kept up with,
    this can result in contradictions and inaccurate data. On the other hand, since
    GraphQL includes built-in introspection, users can dynamically learn about the
    different kinds and features of the API. Engineers can explore and comprehend
    the API more easily, frequently using tools such as GraphiQL.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在REST API中，文档通常单独提供，程序员有责任保持其更新。如果不及时更新，可能会导致矛盾和不准确的数据。另一方面，由于GraphQL包含内置的反射功能，用户可以动态地了解API的不同类型和功能。工程师可以更轻松地探索和理解API，通常使用GraphiQL等工具。
- en: To end this section, we are going to take a look at some code examples of fetching
    some data using REST and GraphQL so it becomes clear how the two methods differ
    from each other.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这一部分，我们将查看一些使用REST和GraphQL获取数据的代码示例，以便清楚地了解这两种方法之间的差异。
- en: How do we fetch data using REST APIs and GraphQL?
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们如何使用REST API和GraphQL获取数据？
- en: We will take a look at code examples for fetching data using REST and GraphQL,
    starting with REST APIs. In these examples, we will use authors and posts.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看使用REST和GraphQL获取数据的代码示例，从REST API开始。在这些示例中，我们将使用作者和帖子。
- en: How do we fetch data using REST APIs?
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们如何使用REST API获取数据？
- en: 'The first step is to get a post that has an ID of `1`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是获取一个ID为`1`的帖子：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is what a potential sample response might look like:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个潜在的示例响应的样子：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When using a REST API for data retrieval, requests return all of the information
    in the data object. It is not possible to request, let’s say, only the `id` and
    `title` information. We would have to write business logic in JavaScript to filter
    the object so that we only get the data we want to use in our application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用REST API进行数据检索时，请求返回数据对象中的所有信息。无法请求，比如说，只获取`id`和`title`信息。我们不得不在JavaScript中编写业务逻辑来过滤对象，以便我们只获取在应用程序中想要使用的数据。
- en: 'So, if we wanted to get details for the author, then we would have to send
    a second `GET` request:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想获取作者详情，那么我们就必须发送第二个 `GET` 请求：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we’ll have the author’s info:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将获得作者的信息：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, now that we have understood the basic concept of fetching data using REST
    APIs, let’s see how we can do the same but this time using GraphQL.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经了解了使用REST API获取数据的基本概念，让我们看看我们如何使用GraphQL来完成同样的操作，但这次是使用GraphQL。
- en: How do we fetch data using GraphQL?
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们如何使用GraphQL获取数据？
- en: 'When we use GraphQL, we first need to create a schema for our API, as shown
    in the following example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用GraphQL时，我们首先需要为我们的API创建一个模式，如下面的示例所示：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we need to write a GraphQL query to get the author and a post:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要编写一个GraphQL查询来获取作者和帖子：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The response will look something like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 响应将看起来像这样：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: GraphQL allows us to retrieve the necessary data with a single request by defining
    the fields we desire.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 允许我们通过定义我们想要的字段，用一个请求检索必要的数据。
- en: Ultimately, deciding between a REST API and GraphQL boils down to our specific
    use cases and requirements. Both have distinct characteristics and abilities that
    can help us optimize the development process while creating web or mobile apps.
    However, as with many technological issues, it is critical for us to consider
    all of our alternatives before settling on the best method. We can safely use
    a REST API or GraphQL within our React applications to obtain the desired outcome
    if we can grasp their common qualities and special benefits. Whatever technology
    we employ, the objective should always be to provide safe, scalable, and effective
    solutions for those who use the app.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，决定使用REST API还是GraphQL归结于我们的具体用例和需求。两者都有独特的特性和能力，可以帮助我们在创建Web或移动应用时优化开发过程。然而，正如许多技术问题一样，在我们确定最佳方法之前，考虑所有替代方案至关重要。如果我们能够掌握它们的共同特性和特殊优势，我们可以在React应用程序中安全地使用REST
    API或GraphQL来获得期望的结果。无论我们采用什么技术，目标始终应该是为使用该应用的人提供安全、可扩展和有效的解决方案。
- en: Now that we have completed this introductory refresher section, let’s take the
    next step and create the foundation for building our app as we learn about the
    planning required for the architecture.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这个入门级复习部分，让我们迈出下一步，在了解架构规划所需内容的同时，为构建我们的应用程序打下基础。
- en: Planning the application architecture including authentication, SWR, GraphQL,
    and deployment
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划应用程序架构，包括认证、SWR、GraphQL和部署
- en: In today’s fiercely competitive marketplace, it is imperative to possess the
    know-how of designing, developing, and deploying an application architecture that
    is efficient, secure, and meets user needs. However, with the advent of evolving
    technologies such as Next.js, authentication methods transitioning from traditional
    OAuth 2.0 to SWR, and GraphQL gaining popularity, planning our application architecture
    might seem like a daunting task.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天这个竞争激烈的市场中，掌握设计、开发和部署高效、安全且满足用户需求的应用程序架构的技能至关重要。然而，随着Next.js等新兴技术的出现，认证方法从传统的OAuth
    2.0过渡到SWR，以及GraphQL的流行，规划我们的应用程序架构可能看起来是一项艰巨的任务。
- en: In this section, we will get valuable insights to assist us in organizing our
    application for success, from selecting the appropriate technologies to incorporating
    user experience design elements. By the end of this section, we will have a roadmap
    to guide us through building our next project, with clear steps to follow through
    to completion.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将获得宝贵的见解，帮助我们组织应用程序以取得成功，从选择适当的技术到融入用户体验设计元素。到本节结束时，我们将有一个路线图来指导我们完成下一个项目的构建，包括明确的步骤以完成整个过程。
- en: Our next topic focuses on serverless frameworks. So, let’s read on and see why
    they are a brilliant choice for building modern apps.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个主题将关注无服务器框架。那么，让我们继续阅读，看看为什么它们是构建现代应用的绝佳选择。
- en: Why are serverless frameworks such as Next.js a brilliant choice for building
    modern applications?
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么无服务器框架如Next.js是构建现代应用的绝佳选择？
- en: New frameworks and architectures are developed as digital technology advances
    to better the effectiveness of building web applications. Next.js is one of these
    architectures because of its speed and flexibility. Next.js apps have a distinct
    design that separates server-side code from client-side logic, resulting in faster
    processing times and better performance. This architecture employs **server-side
    rendering** (**SSR**) to generate HTML pages on the server, significantly reducing
    client-side load. Next.js apps also use a hybrid approach that utilizes dynamic
    and static rendering for increased efficiency and faster load times. Because of
    these features, Next.js is an excellent choice for programmers looking to create
    modern, powerful web applications.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数字技术的进步，新的框架和架构被开发出来，以更好地构建Web应用程序的有效性。Next.js就是这些架构之一，因为它速度快、灵活。Next.js应用程序有一个独特的设计，将服务器端代码与客户端逻辑分开，从而实现更快的处理时间和更好的性能。这种架构采用**服务器端渲染**（**SSR**）在服务器上生成HTML页面，显著减少了客户端的负载。Next.js应用程序还使用一种混合方法，结合动态和静态渲染，以提高效率和更快的加载时间。由于这些特性，Next.js是程序员创建现代、强大Web应用程序的绝佳选择。
- en: The next topic that we will cover is authentication. So, let’s take a look at
    how certain security measures can enhance our defenses.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要讨论的主题是身份验证。那么，让我们看看某些安全措施如何增强我们的防御。
- en: What authentication is available in Next.js applications?
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Next.js应用程序中提供了哪些身份验证方式？
- en: 'The security of online apps is a high priority as they become more essential
    to our daily lives. A key component of protecting these applications is authentication,
    which is the method of confirming a user’s identity. Providing authentication
    in a Next.js application can be done using a variety of techniques, including
    the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 随着在线应用在我们的日常生活中变得越来越重要，网络安全成为了一个高度优先的事项。保护这些应用程序的关键组成部分是身份验证，这是确认用户身份的方法。在Next.js应用程序中提供身份验证可以使用各种技术，包括以下内容：
- en: Auth.js
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Auth.js
- en: '**JSON Web** **Tokens** (**JWTs**)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON Web** **Tokens** (**JWTs**)'
- en: Auth0
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Auth0
- en: OAuth2
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth2
- en: Login and password authentication
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录和密码身份验证
- en: By utilizing these technologies, engineers can defend their applications against
    online threats such as hackers’ attempts to steal user data. This high degree
    of verification guarantees users a safe and reliable environment while also safeguarding
    their private data. A Next.js application must use proper authentication procedures
    given the growing significance of online privacy.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用这些技术，工程师可以保护他们的应用程序免受在线威胁，例如黑客试图窃取用户数据的尝试。这种高程度的验证确保用户在一个安全可靠的环境中，同时也保护了他们的私人数据。鉴于在线隐私日益重要，Next.js应用程序必须使用适当的身份验证程序。
- en: Speed is a high-priority requirement when building our app infrastructure, but
    how does SWR make it better? We will find out now in the next section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的应用程序基础设施时，速度是一个高度优先的要求，但SWR是如何使其变得更好的呢？我们将在下一节中找到答案。
- en: How does SWR allow fast data retrieval?
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SWR是如何实现快速数据检索的？
- en: It is not surprising that quick and effective data fetching has elevated to
    the top of developers’ priorities as the world becomes increasingly data-driven.
    And that’s where **stale-while-revalidate**, or **SWR**, comes into play. SWR
    is a remote data fetching React Hooks library that prioritizes speed, caching,
    and revalidation. Fetching data is made simple with SWR, since it does away with
    annoying loading boxes and makes sure the data is continuously current. Additionally,
    it has a user-friendly API that makes it simple for programmers of any experience
    level to utilize.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 随着世界变得越来越以数据驱动，快速有效的数据获取被提升到开发者优先事项的首位，这并不令人惊讶。这就是**stale-while-revalidate**（或**SWR**）发挥作用的地方。SWR是一个优先考虑速度、缓存和重新验证的远程数据获取React
    Hooks库。使用SWR可以简化数据获取，因为它消除了令人烦恼的加载框，并确保数据持续更新。此外，它有一个用户友好的API，使得任何经验水平的程序员都能轻松使用。
- en: Now, we will take another look at GraphQL to see why it has become the best
    choice for modern application architecture.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将再次审视GraphQL，看看为什么它已经成为现代应用程序架构的最佳选择。
- en: How can GraphQL integration optimize our data fetching?
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何通过GraphQL集成优化我们的数据获取？
- en: The need to optimize productivity and simplify operations grows as technology
    develops. In response, GraphQL integration has become more common. GraphQL significantly
    boosts the speed and accuracy of data retrieval by enabling optimized data fetching.
    With GraphQL, queries can be customized to meet particular needs rather than having
    to get several datasets and sort through them to find the necessary information.
    The outcome of this is that data can be retrieved more quickly and accurately,
    which can aid companies in staying current. Because of these advantages, many
    businesses have adopted GraphQL integration, given its capacity to improve data
    fetching procedures.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Deployment is where our application goes live online for the public to use and
    we get to show off our creation to the world. So, let’s now learn about this crucial
    step in the next section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: How do we deploy our Next.js applications online?
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deploying apps on cloud platforms is the conclusion of all of our hard work,
    and this process can be both challenging and rewarding. The best feature (which
    makes Next.js a favorite among developers) is that it allows SSR. Our Next.js
    application will now be accessible at all times and from any location when we
    deploy it on a cloud infrastructure. Numerous cloud providers are readily accessible
    on the market, each with distinctive characteristics.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: One of the most popular online cloud host providers is **Vercel**, the creators
    of Next.js, meaning that their platform is the perfect place for deploying our
    Next.js apps. Other popular serverless host providers include Netlify, AWS, Azure,
    Render, Firebase, and Supabase. There are countless others out there to choose
    from. The important thing is to find a platform that is cost-effective and offers
    many good features and services. The majority of the ones mentioned here offer
    free services.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will end this section by checking out ways to scale and maintain
    our application once it has been deployed to manage its growth.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: What strategies can we use for scaling and maintaining our application architecture
    as it grows?
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s critical to have a plan developed for expanding as well as sustaining our
    architecture as the popularity and usage of our application grows. Without proper
    planning, our application might not be able to cope with the surge in traffic,
    which could turn off prospective customers. Forecasting and taking into account
    potential future growth, along with the tools and technology that might assist
    us in getting there, are necessary for a scalable design. The continuous effectiveness
    of an app is also greatly dependent on the upkeep of our architecture as it develops.
    Adding user feedback to enhance the user experience, testing our software for
    faults and problems, and routinely reviewing and revising the code base are all
    part of this. Our apps can thrive for a very long time if we put the correct plans
    in place.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Having an in-depth knowledge of authentication, SWR data fetching strategies,
    GraphQL integration, and deployment strategies will greatly benefit us as we start
    to develop the architecture of our Next.js application. With these plans in place,
    we can start thinking about scaling and managing our application as it grows,
    which is a vital component of any effective application architecture. The strength
    of Next.js, combined with these strategies, will result in an excellent user experience
    and contribute to the efficiency of the development process.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Working on our coffee restaurant project
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the theory out of the way, let’s start building our website. The first
    thing we need to do is set up our project, so let’s do that now.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Our technical stack is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '**Next.js**: React framework'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**styled-components**: CSS styling'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**apollographql**: Data API'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**authjs**: Authentication'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**React Testing Library** and **Jest**: Testing'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub**: Version control'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vercel**: Serverless online web host'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to create a restaurant application for this project. There will
    be five main pages, and two of them will require you to be authenticated to access
    them. The authentication will be taken care of with Google or GitHub, so you can
    use either account to sign in.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the final project will look like for our app:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4: Next.js final project home page](img/Figure_12.04_B18603.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: Next.js final project home page'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The project and code base can be found online at [https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter12/coffee-restaurant](https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter12/coffee-restaurant)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: and there is a link on GitHub to a working website, so you can see all of the
    pages.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Building the business logic
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, with the theory completed, we are ready to do some practical work as we
    build our application. It’s going to be a fairly simple application; the main
    aim here is to understand how we connect all of these technologies. The application
    will be a restaurant website that has some restricted pages that require an authenticated
    user to access them. These authenticated pages will only show the data from our
    GraphQL API if the user is logged in; otherwise, they will be presented with a
    sign-in page.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: With that introduction out of the way, let’s begin building the business logic.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder on your computer, such as on the desktop, and then run the
    following Next.js command to create a Next.js project:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can use the following settings:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '`Would you like to use TypeScript with this project? …` `No/Yes`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Would you like to use ESLint with this project? …` `No/Yes`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Would you like to use Tailwind CSS with this project? …` `No/Yes`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '``Would you like to use `src/` directory with this project? …`` `No/Yes`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Use App Router (recommended)? …` `No/Yes`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Would you like to customize the default import alias? …` `No/Yes`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we have to install all of the dependencies and packages for our project.
    So `cd` into the `my-app-restaurant` directory and run the following commands
    to install the packages.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following script to install the regular dependencies:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the following script to install the development dependencies:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'If you encounter any errors when trying to install these packages you could
    try adding the --force command or using sudo if you are on a Mac like this: sudo
    npm i --save-dev @testing-library/jest-dom @testing-library/react jest jest-environment-jsdom
    --force'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following test run script to the `scripts` section in the `package.json`
    file in the `root` folder:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, run this command inside the root of the `my-app-restaurant` folder. This
    will create all of the files and folders we will need for this project:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Before we start to work on the main app files, let’s sort out the configuration
    files first.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Configuration files setup
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Put this code in the `api/auth/[…nextauth]/route.js` file. We will use this
    code for setting up our authentication layer, in which GitHub and Google will
    be used for signing in to the protected routes:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, put this code in the `lib/registry.js` file. This code is used for configuring
    `styled-components` to work with Next.js:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, add the following code to the `jest.config.mjs` file in the `root` directory.
    This file can be used for setting up the Jest test runner:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, update the `next.config.js` file in the `root` folder with this code,
    which will enable `styled-components` to work as well as the app directory setup:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We just have one more step to complete, which is the GitHub and Google authentication
    setup section. We must create IDs and secrets for our `.env.local` file. The authentication
    setup can be found at [https://authjs.dev/getting-started/oauth-tutorial](https://authjs.dev/getting-started/oauth-tutorial).
    The tutorial shows you how to do the authentication setup with GitHub. However,
    the setup is fairly similar for other authentication providers, and you can find
    the one for Google at [https://developers.google.com/identity/protocols/oauth2](https://developers.google.com/identity/protocols/oauth2).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Just remember that when we run our app locally, the callback URL will look
    something like this if we use GitHub as an example: `http://localhost:3000/api/auth/callback/github`.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'When we deploy it online, it might look something like this: `https://your-app-url.vercel.app/api/auth/callback/github`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'This is important because our authenticated routes won’t work unless we use
    the right URL. Finally, we just need to add the IDs and secrets to our `.env.local`
    file. This file also needs a secret to be created for our `NEXTAUTH_SECRET` key-value
    pair, which is required for NextAuth.js:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can create your own secret key, and it can be anything you want; I would
    suggest making it secure by generating a random string of characters as you would
    if you were creating a strong password. There are many free tools that can do
    this for you, or you could just randomly make one yourself, such as this example:
    `Y@q7LH@6YoBa$Dkz`. It uses both uppercase and lowercase alphanumeric characters
    and it also has special characters. We all know how to create secure passwords;
    just use the same thinking when creating your secret key.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Building the app
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s go for it! There are quite a lot of files because the build phase has
    many files. But after this section, we will be close to completion! We have a
    data layer that will act as our database. Basically, there is an array of objects
    that we will fetch using GraphQL and then display on our frontend.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code inside the `data` folder we created. This code will
    be for the data we show on the `data/menu.js` file:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, the following code is for `data/profile.js`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Moving on, the next batch of code is for the authenticated pages for the menu
    and profile.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The following code is for `account/menu/page.js`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'This code is quite long so let’s break it down into smaller code blocks. This
    first code block has our imports and color theme setup:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next code block has our CSS and `styled-components`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And lastly, we have the rendered data for our application:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, the following code is for `account/profile/page.js`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Like last time, let’s break it down into smaller code blocks.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have the imports for our page:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we have the color theme and `styled-components` code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Lastly, we have the rendered content for the page:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let’s work on some component files. The first code is for `components/MainMenu.js`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, the following code is for the `components/Provider.js` file, which is
    required for authentication and session state:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Our next file has our GraphQL schema, resolvers, and our Apollo server. The
    following code goes in `graphql/route.js`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, use the following code to build `nutrition/page.js`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'GraphQL queries are next, so the following code is for the `queries/clientQueries.js`
    file:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, the important `utils/cors.js` file is needed so that we don’t get CORS
    errors when our app is deployed online. This will allow us to access our GraphQL
    API on the authenticated routes:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let’s keep going. We have some more code here and it’s for another GraphQL
    setup page; this time, it has the endpoints for GraphQL, which is how we will
    access our queries later. This file is in `utils/withApollo.js`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Almost done! We are now on the `layout.js` page file:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The 404 error `not-found.js` page has the following code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And lastly, the `page.js` file is in the `root` folder, which is our home page.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is split in two for readability. First, we have the imports and CSS
    section:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And now for the function where we render our components in JSX with HTML:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: That’s it! We are done with the bulk of the code base, and our app is almost
    complete! All that is left is a `GlobalStyles.js` file and the images for the
    frontend. We will do this in the upcoming section.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Building the presentation layer
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our project uses `styled-components`, which means the component and page files
    already have localized CSS. We do have one global CSS file though, which is a
    styled component with global style. Here is the code for `components/GlobalStyles.js`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We have waited long enough; it’s time to finally see our application running!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you are in the `root` folder for `my-app-restaurant` and run
    the application with the `npm run` `dev` command.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Our application should be running on `http://localhost:3000` and our GraphQL
    API should be on `http://localhost:3000/graphql`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'The GraphQL API has built-in documentation for testing our queries. Here is
    an example query that should return the `menu` data:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Before we put our app on GitHub and deploy it online, we will finish off with
    some unit tests for some of the files so that we get used to test-driven development.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Implementing testing
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have two test suites. First, we have the code for `nutrition/page.test.js`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And lastly, the following code is for the `page.test.js` file in the `root`
    folder:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Run the `npm test` command, and all tests should be passing. You can press the
    *A* button to rerun all of the tests.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Our app is more or less complete. Let’s now put it on GitHub so that we can
    version control it. It is also preparation for getting our app to work online
    when we deploy it to Vercel, our serverless host.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Git repository with README documentation
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go to GitHub and create a new repo for our project. If you are new to or still
    unfamiliar with GitHub, then you can follow the *Get started* guide here: [https://docs.github.com/en/get-started](https://docs.github.com/en/get-started).
    Then, simply follow the commands to push your project to GitHub. These are the
    commands I used. Replace them with your own repo:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Our project is now on GitHub! We only have one thing left to do – to deploy
    our app on Vercel – and then we are done!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the application for public access
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sign in to your Vercel account and then, on the dashboard, there should be a
    button to add a new project. Add a new project and import the Git repository you
    just created for the project.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Before you hit the `.env.local` file in the `root` folder of your project. This
    file was not uploaded to your GitHub repo because it has your GitHub and Google
    IDs and secret keys, which you don’t want people to see! When you’re done, hit
    **Deploy** and wait for the build to complete.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Our app should be live online now. However, the `utils/withApollo.js` file,
    the URL is set to `http://localhost:3000/graphql`; our app is online now and is
    not running on our machine, so the address needs to change. Update it to the address
    of your app on Vercel, as in the following example: `https://your-app-url.vercel.app/graphql`.
    Push the latest changes to your GitHub repository, and Vercel will automatically
    update and deploy with the new URI.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commit message should be fine:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And remember from earlier, when we run our app locally, the callback URL will
    look something like this, if we use GitHub as an example: `http://localhost:3000/api/auth/callback/github`.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'When deployed online, it will have the following type of URL structure: `https://your-app-url.vercel.app/api/auth/callback/github`.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: So update the authentication for your app on GitHub and Google to get the **Menu**
    and **Profile** pages working online.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: It should be all done. Now, our application should be available online for the
    whole world to see. Well done!
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have made it to the end of this chapter and leveled up our programming skills
    considerably. Right at the beginning of this chapter, we learned about REST APIs
    and how they help us to fetch data on the internet, which we can then use in our
    applications. Afterward, we had an introduction to planning application architecture,
    where we talked about authentication followed by SWR, an HTTP cache invalidation
    strategy. The next topic was GraphQL, the popular alternative to using REST APIs,
    which requires fewer API requests as it’s possible to fetch only the data we require.
    We then touched upon deployment because it’s important to remember this setup
    from the get-go.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we dived into business logic and learned why our code
    needs to be well refined. This section was followed up by the presentation layer
    as we created a design that used styled-components. Testing was factored in, and
    we learned how to test the code that we wrote for our project. With our application
    completed, the final step was its deployment, and this is where we learned about
    creating a Git repository that has a README file with our documentation. In this
    step, we also put our application online so that it was publicly available for
    everyone to use.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: With everything that we have absorbed, it’s safe to say that we have taken a
    huge leap forward in terms of learning and have become much more talented programmers
    in the process. We are now better prepared to tackle interviews as job seekers.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
