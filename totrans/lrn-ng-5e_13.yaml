- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Unit Testing Angular Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试Angular应用
- en: In the previous chapters, we went through many aspects of how to build an Angular
    enterprise application from scratch. But how can we ensure that an application
    can be maintained in the future without much hassle? A comprehensive automated
    testing layer can become our lifeline once our application begins to scale up
    and we have to mitigate the impact of bugs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了从零开始构建Angular企业应用的许多方面。但我们是怎样确保应用在未来可以轻松维护的呢？一旦我们的应用开始扩展，我们必须减轻bug的影响，一个全面的自动化测试层就可以成为我们的生命线。
- en: Testing, specifically unit testing, is meant to be carried out by the developer
    as the project is being developed. Now that our knowledge of the framework is
    mature, we will briefly cover all the intricacies of unit testing an Angular application
    in this chapter including the use of testing tools..
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 测试，特别是单元测试，旨在在项目开发过程中由开发者执行。现在我们的框架知识已经成熟，我们将简要介绍本章中Angular应用单元测试的所有复杂性，包括测试工具的使用。
- en: For simplicity, the examples in this chapter are not related to the e-shop application
    that we have built throughout the book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，本章中的示例与我们在整本书中构建的电子商务应用无关。
- en: 'In more detail, we will learn about the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地说，我们将学习以下内容：
- en: Why do we need unit tests?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们需要单元测试？
- en: The anatomy of a unit test
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试的结构
- en: Introducing unit tests in Angular
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular中引入单元测试
- en: Testing components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试组件
- en: Testing services
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试服务
- en: Testing pipes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试管道
- en: Testing directives
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试指令
- en: Testing forms
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试表单
- en: Testing the router
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试路由器
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The chapter contains various code samples to walk you through the concept of
    unit testing in Angular. You can find the related source code in the `ch13` folder
    of the following GitHub repository:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例，以向您介绍Angular中单元测试的概念。您可以在以下GitHub仓库的`ch13`文件夹中找到相关源代码：
- en: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition)
    .'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition)
    .'
- en: Why do we need unit tests?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么我们需要单元测试？
- en: In this section, we will learn what unit tests are and why they are useful in
    web development.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习单元测试是什么以及为什么它们在Web开发中很有用。
- en: You can skip to the next section if you’re familiar with unit testing and test-driven
    development.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉单元测试和测试驱动开发，你可以跳到下一节。
- en: Unit tests are part of an engineering philosophy for efficient and agile development
    processes. They add a layer of automated testing to the application code before
    it is developed. The core concept is that a piece of code is accompanied by its
    test, both of which are built by the developer who works on that code. First,
    we design the test against the feature we want to deliver, checking the accuracy
    of its output and behavior. Since the feature is still not implemented, the test
    will fail, so the developer’s job is to build the feature to pass the test.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是高效和敏捷开发流程的工程哲学的一部分。它们在代码开发之前为应用程序代码添加了一层自动化测试。核心概念是，一段代码及其测试都是由负责该代码的开发者构建的。首先，我们针对我们想要交付的功能设计测试，检查其输出和行为是否准确。由于该功能尚未实现，测试将失败，因此开发者的工作是构建功能以通过测试。
- en: Unit testing is quite controversial. While test-driven development is beneficial
    for ensuring code quality and maintenance over time, not everybody undertakes
    unit testing in their daily development workflow.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试相当有争议。虽然测试驱动开发有助于确保代码质量并随着时间的推移进行维护，但并非每个人都在他们的日常开发工作流程中执行单元测试。
- en: 'Building tests as we develop our code can sometimes feel like a burden, especially
    when the test results become larger than the functionality it aims to test. However,
    the arguments in favor of testing outnumber the arguments against it:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开发代码的同时构建测试有时会感觉像是一种负担，尤其是在测试结果变得比要测试的功能更大的情况下。然而，支持测试的论据超过了反对它的论据：
- en: Building tests contributes to better code design. Our code must conform to the
    test requirements and not vice versa. If we try to test an existing piece of code
    and find ourselves blocked at some point, the chances are that the code is not
    well designed and requires some rethinking. On the other hand, building testable
    features can help with the early detection of side effects.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring tested code is a lifeline against introducing bugs in later stages.
    Development is meant to evolve with time, and the risk of introducing a bug with
    every refactor is high. Unit tests are an excellent way to ensure we catch bugs
    early, either when introducing new features or updating existing ones.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building tests is an excellent way to document our code. It becomes a priceless
    resource when someone unfamiliar with the code base takes over the development
    endeavor.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are only a few arguments, but you can find countless resources on the
    web about the benefits of testing your code. If you do not feel convinced yet,
    give it a try; otherwise, let’s continue with our journey and look at the overall
    form of a unit test.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The anatomy of a unit test
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many different ways to test a piece of code. In this chapter, we will
    look at the anatomy of a unit test—the separate parts it’s made of.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'To test any code, we need a framework for writing the test and a runner to
    run it on. In this section, we will focus on the test framework. The test framework
    should provide utility functions for building test suites containing one or several
    test specs. As a result, unit testing involves the following concepts:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '**Test suite** : A suite that creates a logical grouping for many tests. A
    suite, for example, can contain all the tests for a specific feature.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test spec** : The actual unit test.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will use **Jasmine** in this chapter, a popular test framework that is also
    used by default in Angular CLI projects. This is what a unit test looks like in
    Jasmine:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `describe` method defines the test suite and accepts a name and an arrow
    function as parameters. The arrow function is the body of the test suite and contains
    several unit tests. The `it` method defines a single unit test. It accepts a name
    and an arrow function as parameters.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Each test spec validates a specific functionality of the feature described in
    the suite name and declares one or several expectations in its body. Each expectation
    takes a value, called the **expected** value, which is compared against an **actual**
    value using a **matcher** function. The function checks whether the expected and
    actual values match accordingly, which is called an **assertion** . The test framework
    passes or fails the spec depending on the result of such assertions. In the previous
    example, `1+1` will return the actual value that is supposed to match the expected
    value, `2` , declared in the `toBe` matcher function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The Jasmine framework contains various matcher functions according to user-specific
    needs, as we will see later in the chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 框架根据用户特定的需求包含各种匹配器函数，正如我们在本章后面将要看到的。
- en: 'Suppose the previous code contains another mathematical operation that must
    be tested. It would make sense to group both operations under the `Calculator`
    suite, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设前面的代码包含另一个必须测试的数学运算。将这两个操作组合在 `Calculator` 测试套件下进行测试是有意义的，如下所示：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So far, we have learned about test suites and how to use them to group tests
    according to their functionality. Furthermore, we have learned about invoking
    the code we want to test and affirming that it does what it should do. However,
    more concepts are involved in unit tests that are worth knowing about, namely,
    the **setup** and **teardown** functionalities.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了测试套件以及如何使用它们根据其功能分组测试。此外，我们还学习了如何调用我们想要测试的代码并确认它做了它应该做的事情。然而，单元测试中涉及的概念更多，值得了解，即**设置**和**拆卸**功能。
- en: 'A setup functionality prepares your code before you start running the tests.
    It’s a way to keep your code clean by focusing on invoking the code and checking
    the assertions. A teardown functionality is the opposite. It is responsible for
    tearing down what we initially set up, involving activities such as cleaning up
    resources. Let’s see what this looks like in practice with a code example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 设置功能是在你开始运行测试之前准备你的代码。这是一种通过调用代码并检查断言来保持代码清洁的方法。拆卸功能是相反的。它负责拆卸我们最初设置的内容，涉及诸如清理资源等活动。让我们通过一个代码示例来看看这在实际中是什么样子：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `beforeEach` method is used for the setup functionality and runs before
    every unit test. In this example, we set the value of the `total` variable to
    `1` before each test. The `afterEach` method is used to run teardown logic. After
    each test, we reset the value of the `total` variable to `0` .
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforeEach` 方法用于设置功能，并在每个单元测试之前运行。在这个例子中，我们在每个测试之前将 `total` 变量的值设置为 `1`。`afterEach`
    方法用于运行拆卸逻辑。在每个测试之后，我们将 `total` 变量的值重置为 `0`。'
- en: It is evident that the test only has to care about invoking application code
    and asserting the outcome, which makes tests cleaner; however, tests tend to have
    much more setup in a real-world application. Most importantly, the `beforeEach`
    method tends to make it easier to add new tests, which is great. We want well-tested
    code; the easier it is to write and maintain such code, the better for our software.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，测试只需要关注调用应用程序代码并断言结果，这使得测试更简洁；然而，在实际应用中，测试往往需要更多的设置。最重要的是，`beforeEach` 方法通常使添加新测试变得更容易，这是非常好的。我们希望代码经过良好的测试；编写和维护这样的代码越容易，对我们软件的好处就越大。
- en: Now that we have covered the basics of a unit test, let’s see how we can implement
    them in the context of the Angular framework.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了单元测试的基础，让我们看看我们如何在 Angular 框架的上下文中实现它们。
- en: Introducing unit tests in Angular
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Angular 中引入单元测试
- en: 'In the previous section, we familiarized ourselves with unit testing and its
    general concepts, such as test suites, test specs, and assertions. It is time
    to venture into unit testing with Angular, armed with that knowledge. Before we
    start writing tests for Angular, though, let’s have a look at the tooling that
    the Angular framework and the Angular CLI provide us with:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们熟悉了单元测试及其一般概念，如测试套件、测试规范和断言。现在是时候带着这些知识去探索 Angular 的单元测试了。然而，在我们开始为
    Angular 编写测试之前，让我们看看 Angular 框架和 Angular CLI 为我们提供的工具：
- en: '**Jasmine** : We have already learned that this is the testing framework.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jasmine**：我们已经了解到，这是一个测试框架。'
- en: '**Karma** : The test runner for running our unit tests.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Karma**：运行我们的单元测试的测试运行器。'
- en: '**Angular testing utilities** : A set of helper methods that assist us in setting
    up our unit tests and writing our assertions in the context of the Angular framework.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular 测试工具**：一组辅助方法，帮助我们设置单元测试并在 Angular 框架的上下文中编写断言。'
- en: When we use the Angular CLI, we do not have to do anything to configure Jasmine
    and Karma in an Angular application. Unit testing works out of the box when we
    create a new Angular CLI project. Most of the time, we will interact with the
    Angular testing utilities.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Angular CLI 时，我们不需要对 Angular 应用程序中的 Jasmine 和 Karma 进行任何配置。当我们创建一个新的 Angular
    CLI 项目时，单元测试默认情况下就可以工作。大多数时候，我们将与 Angular 测试工具交互。
- en: 'Angular testing utilities help us to create a testing environment that makes
    writing tests for our Angular artifacts easy. It consists of the `TestBed` class
    and various helper methods in the `@angular/core/testing` namespace. As this chapter
    progresses, we will learn what these are and how they can help us test various
    artifacts. For now, let’s have a look at the most commonly used concepts so that
    you are familiar with them when we look at them in more detail later on:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 测试实用工具帮助我们创建一个测试环境，使得为我们的 Angular 艺术品编写测试变得容易。它由 `TestBed` 类和 `@angular/core/testing`
    命名空间中的各种辅助方法组成。随着本章的深入，我们将了解这些是什么以及它们如何帮助我们测试各种艺术品。现在，让我们先看看最常用的概念，以便在稍后更详细地探讨时，您能熟悉它们：
- en: '`TestBed` : A class that creates a testing module. We attach an Angular artifact
    to this testing module when we test it. The `TestBed` class contains the `configureTestingModule`
    method we use to set up the test module as needed.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestBed`：一个创建测试模块的类。当我们测试它时，我们将 Angular 艺术品附加到这个测试模块上。`TestBed` 类包含我们用来设置测试模块所需的
    `configureTestingModule` 方法。'
- en: '`ComponentFixture` : A wrapper class around an Angular component instance.
    It allows us to interact with the component and its corresponding HTML element.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ComponentFixture`：一个围绕 Angular 组件实例的包装类。它允许我们与组件及其相应的 HTML 元素进行交互。'
- en: '`DebugElement` : A wrapper around the DOM element of the component. It is an
    abstraction that operates cross-platform so that our tests are platform-independent.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DebugElement`：组件 DOM 元素的包装。它是一个跨平台操作抽象，使得我们的测试是平台无关的。'
- en: Now that we know our testing environment and the frameworks and libraries used,
    we can start writing our first unit tests in Angular.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了我们的测试环境和使用的框架和库，我们可以开始编写我们的第一个 Angular 单元测试。
- en: All the examples described in this chapter have been created in a new Angular
    CLI project.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中描述的所有示例都是在新的 Angular CLI 项目中创建的。
- en: We will embark on this great journey from the most fundamental building block
    in Angular, the component.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 Angular 最基本的构建块——组件开始，开始这段伟大的旅程。
- en: Testing components
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试组件
- en: You may have noticed that whenever we used the Angular CLI to scaffold a new
    Angular application or generate an Angular artifact, it created some test files
    for us.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，每次我们使用 Angular CLI 构建新的 Angular 应用程序或生成 Angular 艺术品时，它都会为我们创建一些测试文件。
- en: Test files in the Angular CLI contain the word `spec` in their filename. The
    filename of a test is the same as the Angular artifact it is testing, followed
    by the suffix `.spec.ts` . For example, the test file for the main component of
    an Angular application is `app.component.spec.ts` and it resides in the same path
    as the component file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI 中的测试文件文件名中包含单词 `spec`。测试文件的文件名与其所测试的 Angular 艺术品相同，后跟后缀 `.spec.ts`。例如，Angular
    应用程序主组件的测试文件是 `app.component.spec.ts`，它位于组件文件相同的路径中。
- en: We should consider an Angular artifact and its corresponding test one thing.
    When we change the logic of the artifact, we may need to modify the unit test
    as well. Placing unit test files with their Angular artifacts makes it easier
    for us to remember and edit them. It also helps us when we need to refactor our
    code, such as moving artifacts (not forgetting to move the unit test).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该将 Angular 艺术品及其相应的测试视为一件事。当我们更改艺术品的逻辑时，我们可能需要修改单元测试。将单元测试文件与其 Angular 艺术品放在一起，使我们更容易记住和编辑它们。这也有助于我们在需要重构代码时，例如移动艺术品（不要忘记移动单元测试）。
- en: 'When we scaffold a new Angular application, the Angular CLI automatically creates
    a test for the main component, `AppComponent` . At the beginning of the file,
    there is a `beforeEach` statement that is used for setup purposes:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建一个新的 Angular 应用程序时，Angular CLI 会自动为主组件 `AppComponent` 创建一个测试。在文件的开头，有一个用于设置的
    `beforeEach` 语句：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It uses the `configureTestingModule` method of the `TestBed` class and passes
    an object as a parameter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用 `TestBed` 类的 `configureTestingModule` 方法，并将一个对象作为参数传递。
- en: We can specify an `imports` array that contains the component we want to test.
    Additionally, we can define teardown options using the `teardown` property.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定一个包含我们想要测试的组件的 `imports` 数组。此外，我们可以使用 `teardown` 属性定义拆解选项。
- en: 'The `teardown` property contains an object of the `ModuleTeardownOptions` type
    that can set the following properties:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`teardown` 属性包含一个 `ModuleTeardownOptions` 类型的对象，可以设置以下属性：'
- en: '`destroyAfterEach` : It creates a new instance of the module at each test to
    eliminate bugs caused by the incomplete cleanup of HTML elements.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destroyAfterEach`：它在每个测试中创建模块的新实例，以消除由于 HTML 元素清理不完整而引起的错误。'
- en: '`rethrowErrors` : It throws any errors that occur when the module is destroyed.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rethrowErrors`：它在模块销毁时抛出任何发生的错误。'
- en: Finally, we call the `compileComponents` method to compile the TypeScript class
    and the HTML template of our component.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 `compileComponents` 方法来编译我们的组件的 TypeScript 类和 HTML 模板。
- en: 'The first unit test verifies whether we can create a new instance of `AppComponent`
    using the `createComponent` method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个单元测试验证我们是否可以使用 `createComponent` 方法创建 `AppComponent` 的新实例：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The result of the `createComponent` method is a `ComponentFixture` instance
    of the `AppComponent` type that can give us the component instance using the `componentInstance`
    property. We also use the `toBeTruthy` matcher function to check whether the resulting
    instance is valid.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`createComponent` 方法的结果是 `AppComponent` 类型的 `ComponentFixture` 实例，我们可以使用 `componentInstance`
    属性获取组件实例。我们还使用 `toBeTruthy` 匹配器函数来检查生成的实例是否有效。'
- en: 'As soon as we have access to the component instance, we can query any of its
    public properties and methods:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们能够访问组件实例，我们就可以查询其任何公共属性和方法：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the previous test, we check whether the `title` component property is set
    to `my-app` using another matcher function, `toEqual` .
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们使用另一个匹配器函数 `toEqual` 检查 `title` 组件属性是否设置为 `my-app`。
- en: The value of the `title` component property in a new Angular application will
    be the name you passed in the `ng new` command while creating the application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的 Angular 应用程序中，`title` 组件属性的值将是你在创建应用程序时通过 `ng new` 命令传递的名称。
- en: 'As we have learned, a component consists of a TypeScript class and a template
    file. So, testing it only from the class perspective, as in the previous test,
    is not sufficient. We should also test whether the class interacts correctly with
    the DOM:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，组件由 TypeScript 类和模板文件组成。因此，仅从类角度测试，如前面的测试，是不够的。我们还应该测试类是否正确与 DOM 交互：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Many developers favor class testing over DOM testing and rely on **end-to-end**
    ( **E2E** ) testing, which is slower and performs poorly. E2E tests often validate
    the integration of an application with a backend API and are easy to break. Thus,
    performing DOM unit testing in your Angular applications is recommended.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者更喜欢类测试而不是 DOM 测试，并依赖于 **端到端**（**E2E**）测试，这种测试较慢且性能较差。端到端测试通常验证应用程序与后端 API
    的集成，并且容易出错。因此，在 Angular 应用程序中执行 DOM 单元测试是推荐的。
- en: In the preceding test, we create a component and call the `detectChanges` method
    of the `ComponentFixture` . The `detectChanges` method triggers the Angular change
    detection mechanism, forcing the data bindings to be updated. It executes the
    `ngOnInit` life cycle event of the component the first time it is called and the
    `ngOnChanges` in subsequent calls so that we can query the DOM element of the
    component using the `nativeElement` property. In this example, we check the `textContent`
    of the HTML element corresponding to the `title` property.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们创建了一个组件并调用了 `ComponentFixture` 的 `detectChanges` 方法。`detectChanges`
    方法触发了 Angular 的变更检测机制，强制数据绑定更新。它在第一次调用时执行组件的 `ngOnInit` 生命周期事件，在后续调用中执行 `ngOnChanges`，这样我们就可以使用
    `nativeElement` 属性查询组件的 DOM 元素。在这个例子中，我们检查与 `title` 属性对应的 HTML 元素的 `textContent`。
- en: 'To run tests, we use the `ng test` command of the Angular CLI. It will start
    the Karma test runner, fetch all unit test files, execute them, and open a browser
    to display the results of each test. The Angular CLI uses the Google Chrome browser
    by default. The output will look like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试时，我们使用 Angular CLI 的 `ng test` 命令。它将启动 Karma 测试运行器，获取所有单元测试文件，执行它们，并打开浏览器以显示每个测试的结果。Angular
    CLI 默认使用 Google Chrome 浏览器。输出将类似于以下内容：
- en: '![Εικόνα που περιέχει κείμενο, γραμματοσειρά, στιγμιότυπο οθόνης, λευκό  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_13_01.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、字体、屏幕截图、白色 描述由系统自动生成](img/B21418_13_01.png)'
- en: 'Figure 13.1: Test execution output'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1：测试执行输出
- en: In the previous figure, we can see the result of each test at the top of the
    page. We can also see how Karma visually groups each test by suite. In our case,
    the only test suite is **AppComponent** .
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以在页面顶部看到每个测试的结果。我们还可以看到 Karma 如何通过套件视觉分组每个测试。在我们的例子中，唯一的测试套件是 **AppComponent**。
- en: 'Now, let’s make one of our tests fail. Open the `app.component.ts` file, change
    the value of the `title` property to `my-new-app` , and save the file. Karma will
    re-execute our tests and display the results on the page:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们让我们的一个测试失败。打开`app.component.ts`文件，将`title`属性的值更改为`my-new-app`，然后保存文件。Karma将重新执行我们的测试，并在页面上显示结果：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, αριθμός  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_13_02.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、屏幕截图、字体、编号的图片，自动生成的描述](img/B21418_13_02.png)'
- en: 'Figure 13.2: Test failure'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：测试失败
- en: Karma runs in **watch mode** , so we do not need to execute the Angular CLI
    test command every time we make a change.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Karma以**监视模式**运行，因此我们不需要每次更改时都执行Angular CLI测试命令。
- en: 'Sometimes, reading the output of tests in the browser is not very convenient.
    Alternatively, we can inspect the console window that we used to run the `ng test`
    command, which contains a trimmed version of the test results:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在浏览器中阅读测试输出并不太方便。作为替代，我们可以检查我们用来运行`ng test`命令的控制台窗口，其中包含测试结果的裁剪版本：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We’ve gained quite a lot of insight just by looking at the test of `AppComponent`
    that the Angular CLI automatically created for us. In the following section, we
    will look at a more advanced scenario for testing a component with dependencies.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看Angular CLI为我们自动创建的`AppComponent`测试，我们已经获得了相当多的见解。在下一节中，我们将查看一个更高级的场景，用于测试具有依赖项的组件。
- en: Testing with dependencies
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带依赖项的测试
- en: In a real-world scenario, components are not usually as simple as the main component.
    They will almost certainly be dependent on one or more services. They will also
    possibly contain other child components in their template.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的场景中，组件通常不像主组件那样简单。它们几乎肯定依赖于一个或多个服务。它们也可能在其模板中包含其他子组件。
- en: 'We have different ways of dealing with testing in such situations. One thing
    is clear: if we are testing the component, we should not test the service or its
    child components. So, when we set up such a test, the dependency should not be
    the real class. There are different ways of dealing with that when it comes to
    unit testing; no solution is strictly better than another:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有不同方式处理这种情况下的测试。有一点很清楚：如果我们正在测试组件，我们不应该测试服务或其子组件。因此，当我们设置此类测试时，依赖项不应是真实类。在单元测试中，处理这个问题有不同方式；没有解决方案是绝对优于其他解决方案的：
- en: '**Stubbing** : A method that instructs the dependency injector to inject a
    stub of the dependency that we provide instead of the real class.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存根**：一种指示依赖项注入器注入我们提供的存根而不是真实类的指令。'
- en: '**Spying** : A method that injects the actual dependency but attaches a spy
    to the method that we call in our component. We can then either return mock data
    or let the method call through.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**间谍**：一种注入实际依赖项但附加一个间谍到我们在组件中调用的方法的方法。然后我们可以返回模拟数据或让方法调用通过。'
- en: Using stubbing over spying is preferable when a dependency is complicated. Some
    services inject other services, so using the real dependency in a test requires
    you to compensate for other dependencies. It is also the preferred method when
    the component we want to test contains child components in its template.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当依赖项复杂时，使用存根而不是间谍更可取。一些服务会注入其他服务，因此在测试中使用真实依赖项需要您补偿其他依赖项。当我们要测试的组件在其模板中包含子组件时，这也是首选方法。
- en: Regardless of the approach, we ensure that the test does not perform unintended
    actions, such as accessing the filesystem or attempting to communicate via HTTP;
    we are testing the component in complete isolation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 无论采用何种方法，我们都确保测试不会执行意外的操作，例如访问文件系统或尝试通过HTTP进行通信；我们正在完全隔离的情况下测试组件。
- en: Replacing the dependency with a stub
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用存根替换依赖项
- en: Replacing a dependency with a stub means that we completely replace the dependency
    with a fake one.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 用存根替换依赖项意味着我们完全用假的依赖项替换了真实的依赖项。
- en: 'We can create a fake dependency in the following ways:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式创建一个假的依赖项：
- en: Create a constant variable or class that contains properties and methods of
    the real dependency.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含真实依赖项属性和方法的常量变量或类。
- en: Create a mock definition of the actual class of the dependency.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为依赖项的实际类创建一个模拟定义。
- en: The approaches are not so different. In this section, we will look at the first
    one as it is most common in Angular development. Feel free to explore the second
    one at your own pace.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法并没有太大的区别。在本节中，我们将查看第一个方法，因为它在Angular开发中最为常见。您可以按照自己的节奏探索第二个方法。
- en: 'Consider the following `stub.component.ts` component file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下`stub.component.ts`组件文件：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It injects `StubService` , which contains two public properties. Providing
    a stub for this service in tests is pretty straightforward, as shown in the following
    example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它注入了`StubService`，该服务包含两个公共属性。在测试中为该服务提供占位符相当直接，如下面的示例所示：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We have declared the service as `Partial` because we want only to set the `name`
    property initially. We can now use the object literal syntax to inject the stub
    service in our testing module:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将服务声明为`Partial`，因为我们只想最初设置`name`属性。现在我们可以使用对象字面量语法将占位符服务注入到我们的测试模块中：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `msg` component property relies on the value of the `isBusy` service property.
    Therefore, we need to get a reference to the service in the test suite and provide
    alternate values for this property in each test. We can get the injected instance
    of `StubService` using the `inject` method of the `TestBed` class:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`msg`组件属性依赖于`isBusy`服务属性的值。因此，我们需要在测试套件中获取对服务的引用，并在每个测试中为该属性提供不同的值。我们可以使用`TestBed`类的`inject`方法获取注入的`StubService`实例：'
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We pass the real `StubService` as a parameter to the `inject` method, not the
    stubbed version we created. Modifying the value of the stub will not affect the
    injected service since our component uses an instance of the real service. The
    `inject` method asks the root injector of the application for the requested service.
    If the service was provided from the component injector, we would need to get
    it from the component injector using `fixture.debugElement.injector.get(StubService)`
    .
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将真实的`StubService`作为参数传递给`inject`方法，而不是我们创建的占位符版本。修改占位符的值不会影响注入的服务，因为我们的组件使用的是真实服务的实例。`inject`方法请求应用程序的根注入器提供所需的服务。如果服务是从组件注入器提供的，我们就需要使用`fixture.debugElement.injector.get(StubService)`从组件注入器获取它。
- en: 'We can now write our tests to check whether the `msg` component property behaves
    correctly during data binding:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写测试来检查`msg`组件属性在数据绑定期间是否表现正确：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have removed the `fixture.detectChanges` line from the `beforeEach` statement
    because we want to trigger change detection in our tests separately.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从`beforeEach`语句中移除了`fixture.detectChanges`行，因为我们希望在测试中单独触发变更检测。
- en: 'Stubbing a dependency is not always viable, especially when the root injector
    does not provide it. A service can be provided at the component injector level.
    Providing a stub using the process we looked at earlier doesn’t have any effect.
    To tackle such a scenario, we can use the `overrideComponent` method of the `TestBed`
    class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 占位依赖项并不总是可行的，尤其是在根注入器不提供它的情况下。服务可以在组件注入器级别提供。使用我们之前查看的过程提供占位符没有任何效果。为了应对这种情况，我们可以使用`TestBed`类的`overrideComponent`方法：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `overrideComponent` method accepts two parameters: the type of component
    that provides the service and an override metadata object. The metadata object
    contains the `set` property, which provides services to the component.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`overrideComponent`方法接受两个参数：提供服务的组件类型和一个覆盖元数据对象。元数据对象包含`set`属性，它为组件提供服务。'
- en: 'Suppose that the component we want to test contains a child component in its
    template, such as:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要测试的组件在其模板中包含一个子组件，例如：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding case, when we tested the `StubComponent` , we also needed
    to import the TypeScript class of the `<app-child>` component when configuring
    the testing module:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，当我们测试`StubComponent`时，我们还需要在配置测试模块时导入`<app-child>`组件的TypeScript类：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `ChildComponent` class may have other dependencies as well. Providing stubs
    for those dependencies is not viable because it is not the responsibility of the
    component under test. Instead, we can create a stub TypeScript class for the component
    and import it when configuring the testing module:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChildComponent`类可能还有其他依赖。为这些依赖提供占位符不可行，因为这不是被测试组件的责任。相反，我们可以为组件创建一个占位符TypeScript类，并在配置测试模块时导入它：'
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding snippet, we passed an empty array in the `template` property
    of the component because we are not interested in the internal implementation
    of the child component.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在组件的`template`属性中传递了一个空数组，因为我们对子组件的内部实现不感兴趣。
- en: If the child component contains properties and methods that are used while testing
    the parent component, we need to define them as well in the `ChildStubComponent`
    .
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子组件包含在测试父组件时使用的属性和方法，我们还需要在`ChildStubComponent`中定义它们。
- en: 'Alternatively, to provide a stub of the component, we can pass the `NO_ERRORS_SCHEMA`
    from the `@angular/core` npm package while configuring the testing module:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding snippet instructs Angular to ignore any components that have not
    been imported into the testing module.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Stubbing a dependency is very simple, but it is not always possible, as we will
    see in the following section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Spying on the dependency method
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using a stub is not the only way to isolate logic in a unit test. We don’t have
    to replace the entire dependency—only the parts our component uses. Replacing
    certain parts means we point out specific methods on the dependency and assign
    a spy to them. A spy can answer what you want, but you can also see how many times
    it was called and with what arguments. So, a spy gives you much more information
    about what is happening.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to set up a spy in a dependency:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Inject the actual dependency and spy on its methods.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Jasmine `createSpyObj` method to create a fake dependency instance.
    We can then spy on the methods of this dependency as we would with the real one.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first case is most common in Angular development. Let’s see how to set
    it up. Consider the following `spy.component.ts` file, which uses the `Title`
    service of the Angular framework:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Title` service interacts with the title of the main HTML document in an
    Angular application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not have any control over the `Title` service since it is built into
    the framework. It may have dependencies that we do not know about. Spying on its
    methods is the easiest and safest way to use it in our tests. We inject it in
    the testing module using the `providers` array and then use it in our test, such
    as:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We use the Jasmine `spyOn` method, which accepts two parameters: the object
    and its specific method to spy. We used it before calling the `ngOnInit` component
    method to attach the spy before triggering the change detection mechanism. The
    `expect` statement validates that the `setTitle` method was called with the correct
    arguments.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Our component also uses the `getTitle` method to get the document title. We
    can spy directly on that method and return mock data:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to define the `Title` service as a spy object and initialize
    it by passing two parameters—the name of the service and an array of the method
    names that the component currently uses:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then we attach a spy to the `getTitle` method and return a custom title using
    the Jasmine `returnValue` method:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we add the `titleSpy` variable in the `providers` array of the testing
    module:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The resulting test should look like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Very few services are well behaved and straightforward, such as the `Title`
    service, in the sense that they are synchronous. Most of the time, they are asynchronous
    and can return observables or promises. In the following section, we will learn
    how to test asynchronous dependencies.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Testing asynchronous services
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Angular testing utilities provide two artifacts to tackle asynchronous testing
    scenarios:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '`waitForAsync` : An asynchronous approach to unit test services. It is combined
    with the `whenStable` method of the `ComponentFixture` class.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fakeAsync` : A synchronous approach to unit test services. It is used in combination
    with the `tick` function.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both approaches provide roughly the same functionality; they only differ in
    how we use them. Let’s see how we can use each by looking at an example.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following `async.component.ts` file:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It injects the `AsyncService` from the `async.service.ts` file and calls its
    `getItems` method inside the `ngOnInit` method. As we can see, the `getItems`
    method returns an observable of strings. It also introduces a slight delay so
    that the scenario looks asynchronous:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The unit test queries the native element of the component and checks whether
    the value of the `items$` observable is displayed correctly:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We wrap the test body inside the `waitForAsync` method and call the `detectChanges`
    method to trigger change detection. Furthermore, we call the `whenStable` method,
    which returns a promise that is resolved immediately when the `items$` observable
    is complete. When the promise is resolved, we call the `detectChanges` method
    again to trigger data binding and query the DOM accordingly.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The `whenStable` method is also used when we want to test a component that contains
    a template-driven form. The asynchronous nature of this method makes it preferable
    to use reactive forms in our Angular applications.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative synchronous approach would be to use the `fakeAsync` method
    and write the same unit test as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the previous snippet, we wrapped the test body in a `fakeAsync` method and
    replaced the `whenStable` method with the `tick` function. The `tick` function
    advances the time by `500` ms, which is the virtual delay we introduced in the
    `getItems` method of the `AsyncService` .
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Testing components with asynchronous services can sometimes become a nightmare.
    Still, each of the described approaches can significantly help us in this task.
    However, components are not only about services but also input and output bindings.
    In the following section, we will learn how to test the public API of a component.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Testing with inputs and outputs
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have learned how to test components with simple properties and tackle
    synchronous and asynchronous dependencies. But there is more to a component than
    that. As we learned in *Chapter 3* , *Structuring User Interfaces with Components*
    , a component has a public API consisting of inputs and outputs that should also
    be tested.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we want to test the public API of a component, it makes sense to test
    how it interacts when hosted from another component. Testing such a component
    can be done in two ways:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: We can verify that our input binding is correctly set.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can verify that our output binding triggers correctly and that what it emits
    is received.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose that we have the following `bindings.component.ts` file with an input
    and output binding:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Before we start writing our tests, we should create a test host component inside
    the `bindings.component.spec.ts` file that is going to use the component under
    test:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the setup phase, notice that the `ComponentFixture` is of the `TestHostComponent`
    type:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Our unit tests will validate the behavior of `BindingsComponent` when interacting
    with `TestHostComponent` .
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'The first test checks whether the input binding to the `title` property has
    been applied correctly:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The second test validates whether the `isFavorite` property is wired up correctly
    with the `liked` output event:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the previous test, we query the DOM for the `<button>` element using the
    `nativeElement` property of the `ComponentFixture` class. Then, we click on it
    for the output event to emit. Alternatively, we could have used the `debugElement`
    property to find the button and use its `triggerEventHandler` method to click
    on it:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding test, we use the `query` method, which accepts a **predicate**
    function as a parameter. The predicate uses the CSS method of the `By` class to
    locate an element by its CSS selector.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: As we learned in the *Introducing unit tests in Angular* section, the `debugElement`
    is framework agnostic. If you are sure that your tests will only run in a browser,
    you should go with the `nativeElement` property.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The `triggerEventHandler` method accepts the event name we want to trigger as
    a parameter; in this case, it is the `click` event.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: We could have avoided a lot of code if we had only tested the `BindingsComponent`
    , which would still have been valid. But we would have missed the opportunity
    to test it as a real-world scenario. The public API of a component is intended
    to be used by other components, so we should test it in this way.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the button we use in the template of the `BindingsComponent` is a
    native HTML `<button>` element. If the button was an Angular Material button component,
    we could use an alternate approach for interacting with it, which is the topic
    of the following section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Testing with a component harness
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Angular CDK library, the core of Angular Material, contains a set of utilities
    that allow a test to interact with a component over a public testing API. Angular
    CDK testing utilities enable us to access Angular Material components without
    relying on their internal implementation using a **component harness** .
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of testing an Angular component using a harness consists of the
    following parts:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '`@angular/cdk/testing` : The npm package that contains infrastructure for interacting
    with a component harness.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing environment** : The environment in which the component harness test
    will be loaded. The Angular CDK contains a built-in testing environment for unit
    testing with Karma. It also provides a rich set of tools that allow developers
    to create custom testing environments.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Component harness** : A class that gives the developer access to the instance
    of a component in the browser DOM.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To learn how to use component harnesses, we will convert the `<button>` element
    of the `BindingsComponent` into an Angular Material button:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding snippet assumes that you have added the Angular Material library
    to the project that you are working on.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using a component harness from the Angular CDK, we need to import
    the following artifacts from the `@angular/cdk/testing` namespace:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding snippet, we have added the following classes:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '`TestbedHarnessEnvironment` : Represents the testing environment for running
    unit tests with Karma.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MatButtonHarness` : The component harness for the Angular Material button
    component. Almost all components of the Angular Material library have a corresponding
    component harness that we can use.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are a component library author, the Angular CDK provides all the necessary
    tools for creating harnesses for your UI components.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After we have finished importing all the necessary artifacts, we can write
    our test:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding test, the `loader` method of the testing environment accepts
    the `ComponentFixture` instance of the current component as a parameter and returns
    a `HarnessLoader` object. The abstraction that an Angular CDK harness provides
    is based on the concept that it operates on the component fixture, which is an
    abstraction layer on top of the actual DOM element.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: We surround the body of the test inside an `async` function because component
    harnesses are promise-based. We use the `getHarness` method of the harness loader
    to load the specific harness for the button component. Finally, we call the `click`
    method of the button component harness to trigger the button click event.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: We do not need to call the `detectChanges` method because the Angular CDK component
    harness triggers change detection automatically.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The component harness is a powerful Angular CDK tool that ensures we interact
    with components abstractly and safely during testing.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed many ways to test a component with a dependency. Now, it is
    time to learn how to test the dependency itself.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Testing services
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we learned in *Chapter 5* , *Managing Complex Tasks with Services* , a service
    can inject other services. Testing a standalone service is pretty straightforward:
    we get an instance from the injector and then start to query its public properties
    and methods.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: We are only interested in testing the public API of a service, which is the
    interface that components and other artifacts use. Private properties and methods
    do not have any value when tested because they represent the internal implementation
    of the service.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different types of testing that we can perform in a service:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Testing synchronous and asynchronous operations, such as a method that returns
    a simple array or one that returns an observable
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing services with dependencies, such as a method that makes HTTP requests
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will go through each in more detail.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Testing synchronous/asynchronous methods
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we create an Angular service using the Angular CLI, it also creates a
    corresponding test file. Consider the following `async.service.spec.ts` file,
    which is the test file for the `AsyncService` we used earlier:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `AsyncService` is not dependent on anything. It is also provided with the
    root injector of the Angular application, so it passes an empty object to the
    `configureTestingModule` method. We can get an instance of the service we test
    using the `inject` method of the `TestBed` class.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'The first test that we can write is pretty straightforward as it calls the
    `setItems` method and inspects its result:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Writing a test for synchronous methods, as in the previous case, is usually
    relatively easy; however, things are different when we want to test an asynchronous
    method such as the following.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'This second test is a bit tricky because it involves an observable. We need
    to subscribe to the `getItems` method and inspect the value as soon as the observable
    is complete:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The Karma test runner does not know when an observable will complete, so we
    provide the `done` method to signal that the observable has been completed, and
    we can now assert the `expect` statement.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Testing services with dependencies
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing services with dependencies is similar to testing components with dependencies.
    Every method we saw in the *Testing components* section can be applied similarly;
    however, we follow a different approach when testing a service that injects the
    `HttpClient` service.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following `deps.service.ts` file that uses the HTTP client:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Angular testing utilities provide two artifacts for mocking HTTP requests in
    unit tests: the `provideHttpClientTesting` function, which provides an HTTP client
    for testing, and the `HttpTestingController` , which mocks the `HttpClient` service.
    We can import both from the `@angular/common/http/testing` namespace:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Our tests should not make a real HTTP request. They only need to validate that
    it will be made with the correct options. The following is the first test that
    validates the `getItems` method:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding test, we create a fake request using the `expectOne` method
    of the `HttpTestingController` that takes a URL as an argument. The `expectOne`
    method creates a mock request object and asserts that only one request is made
    to the specific URL. After we have created our request, we can validate that its
    method is `GET` .
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'We follow a similar approach when testing the `addItem` method, except that
    we need to make sure that the body of the request contains the correct data:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After each test, we make sure that no unmatched requests are pending using
    the `verify` method inside an `afterEach` block:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the following section, we continue our journey through the testing world
    by learning how to test a pipe.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Testing pipes
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned in *Chapter 4* , *Enriching Applications Using Pipes and Directives*
    , a pipe is a TypeScript class that implements the `PipeTransform` interface.
    It exposes a `transform` method, which is usually synchronous, which means it
    is straightforward to test.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the `list.pipe.ts` file containing a pipe that converts a comma-separated
    string into a list:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Writing a test is simple. The only thing that we need to do is to instantiate
    an instance of the `ListPipe` class and verify the outcome of the `transform`
    method with some mock data:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Angular testing utilities are not involved when testing a pipe. We create an
    instance of the pipe class, and we can start calling the `transform` method.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Angular directives are artifacts that we may not create very often since the
    built-in collection that the framework provides is more than enough; however,
    if we create custom directives, we should also test them. In the following section,
    we will learn how to accomplish this.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Testing directives
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Directives are usually quite straightforward in their overall shape, being components
    with no view attached. The fact that directives usually work with components gives
    us a good idea of how to proceed when testing them.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the `copyright.directive.ts` file that we created in *Chapter 5* ,
    *Enriching Applications Using Pipes and Directives* :'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'A directive is usually used with a component, so it makes sense to unit test
    it while using it on a component. Let’s create a test host component and add it
    to the `imports` array of the testing module:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can now write our tests that check whether the `<span>` element contains
    the `copyright` class and displays the current year in its `textContent` property:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is how simple it can be to test a directive. The key takeaways are that
    you need a component to place the directive on and that you implicitly test the
    directive using the component.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will learn how to test reactive forms.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Testing forms
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in *Chapter 10* , *Collecting User Data with Forms* , forms are integral
    to an Angular application. It is rare for an Angular application not to have at
    least one simple form, such as a search form. In this chapter, we will focus on
    reactive forms because they are easier to test than template-driven forms.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following `search.component.ts` file:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the preceding component, we can write our unit tests to verify that:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The value of the `searchText` form control can be set correctly
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Search` button is disabled when the form is invalid
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `console.log` method is called when the form is valid, and the user clicks
    the **Search** button
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To test a reactive form, we first need to import `ReactiveFormsModule` into
    the testing module:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'For the first test, we need to assert whether the value propagates to the `searchText`
    form control when we type something into the input control:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the preceding test, we use the `querySelector` method of the `nativeElement`
    property to find the `<input>` HTML element and set its value. But this alone
    will not be sufficient for the value to propagate to the form control. The Angular
    framework will not know whether the value of the `<input>` HTML element has changed
    until we trigger the `input` DOM event to that element. We are using the `dispatchEvent`
    method to trigger the event, which accepts a single method as a parameter that
    points to an instance of the `CustomEvent` class.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are sure that the `searchText` form control is wired up correctly,
    we can use it to write the remaining tests:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that in the second test, we set the value of the `searchText` form control,
    and then we call the `detectChanges` method for the button to be enabled. Clicking
    on the button triggers the `submit` event of the form, and we can finally assert
    the expectation of our test.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'In cases where a form has many controls, it is not convenient to query them
    inside our tests. Alternatively, we can create a `Page` object that takes care
    of querying HTML elements and spying on services:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We can then create an instance of the `Page` object in the `beforeEach` statement
    and access its properties and methods in our tests.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, reactive forms are very easy to test since the form model is
    the single source of truth. In the following section, we will learn how to test
    parts of an Angular application that use the router.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Testing the router
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testing code interacting with the Angular router could easily be a separate
    chapter. In this section, we will focus on the following router concepts:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Routed and routing components
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guards
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolvers
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see first how to test routed and routing components.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Routed and routing components
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A routed component is a component that is activated when we navigate to a specific
    application route. Consider the following `app.routes.ts` file:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `RoutedComponent` class is defined in the following `routed.component.ts`
    file:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The preceding component binds the value of the `title` component property to
    a `<span>` HTML element. The test we will write will assert if the binding works
    correctly.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular router testing is based on the component harness approach we learned
    about in the *Testing components* section. It exposes the `RouterTestingHarness`
    class, which contains various utility methods for working with routed components
    in tests:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Before we can start testing a routed component, we must register the application
    routing configuration in the testing module:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the preceding setup process, we provide the application routing configuration
    as in the `app.config.ts` file.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already learned that we can query the DOM of the native HTML element
    from the `ComponentFixture` class. When a component is loaded using the router,
    we use the `routeNativeElement` property instead from the `RouterTestingHarness`
    class:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The preceding test is separated into the following steps:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: We use the `create` method of the `RouterTestingHarness` to create a new routing
    harness for our component.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We navigate to the registered route path using the `navigateByUrl` method. According
    to the application routing configuration, the `/routed` URL will activate the
    component under test.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use standard query methods of the `routeNativeElement` property to verify
    that the `<span>` HTML element displays the correct text.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `RouterTestingHarness` class also contains the `routeDebugElement` property,
    which works cross-platform similarly to the `debugElement` property of the `ComponentFixture`
    class.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'A routing component is a component that is used to navigate to another component
    in an Angular application. It usually involves calling the `navigate` method of
    the `Router` service as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'According to the preceding snippet, our test should verify that the router
    will navigate to the root path when we call the `goBack` method:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In the preceding test, we use the `inject` method of the `TestBed` class to
    get a reference to the `Router` service. We then access the `url` property to
    verify that the navigation process was completed correctly.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will learn how to test router guards.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Guards
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We learned in *Chapter 9* , *Navigating through Applications with Routing* ,
    that router guards are plain functions.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following guard that checks the authentication status of a user:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the preceding guard, we check the `isLoggedIn` property of the following
    `AuthService` class:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We decided to keep the `AuthService` class simple and focus on the logic of
    the authentication guard.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: If the `isLoggedIn` property is `true` , the guard also returns `true` . Otherwise,
    it executes the `parseUrl` method of the `Router` service to redirect users to
    the root path.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular CLI has created the following unit test for the guard:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the preceding snippet, the `executeGuard` variable encapsulates the creation
    of the `authGuard` function. It uses the `runInInjectionContext` method of the
    `TestBed` class to allow the injection of required services using the `inject`
    method.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'To create unit tests that validate the usage of the authentication guard, we
    must execute the following steps:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `import` statement of the `@angular/router` npm package as follows:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Add the following `import` statement:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Create the following variables that correspond to the injected services:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Initialize the preceding variables in the `beforeEach` statement of the test
    suite:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In the preceding snippet, we use the `createSpyObj` method to create a spy object
    for the `Router` service and provide it to the testing module. Additionally, we
    get the instance of the actual `AuthService` class using the `inject` method of
    the `TestBed` class because it is a simple service with no dependencies.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'The first unit test should assert that the guard execution returns `true` when
    the user is authenticated:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We pass an empty object for the `ActivatedRouteSnapshot` and `RouterStateSnapshot`
    parameters because they are unnecessary in the guard.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'The second unit test should verify that the guard execution causes a redirection
    to the root path:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In the following section, we will learn how to test guard resolvers.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Resolvers
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Router resolvers are plain functions of a specific type similar to guards. The
    most common scenario when testing resolvers is to verify that the returned data
    is correct.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following resolver, which returns a list of items:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The resolver uses the `AsyncService` we saw earlier, which returns an observable
    of items using the `getItems` method.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular CLI will initially create the following unit test file when scaffolding
    the resolver:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In the preceding snippet, the `executeResolver` variable encapsulates the creation
    of the `itemsResolver` function, similar to how it does with guards. It also uses
    the `runInInjectionContext` method of the `TestBed` class to allow the injection
    of required services.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic of our resolver is very simple, so we must write a single unit test:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `import` statement of the `@angular/router` npm package as follows:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Add the following `import` statement:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Change the type of the `executeResolver` variable to `ResolveFn<string[]>`
    so that it matches the signature of the `itemsResolver` function:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Write the following unit test:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: To verify that the resolver returns correct data, we must subscribe to the `executeResolver`
    function.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to unit test some important features of the
    Angular router.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are at the end of our testing journey, and it’s been a long but exciting
    one. In this chapter, we saw the importance of introducing unit testing in our
    Angular applications, the basic shape of a unit test, and the process of setting
    up Jasmine for our tests.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to write robust tests for our components, directives, pipes,
    and services. We also discussed how to test Angular reactive forms and the router.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: This unit testing chapter has almost completed the puzzle of building a complete
    Angular application. Only the last piece remains, which is important because web
    applications are ultimately destined for the web. Therefore, in the next chapter,
    we will learn how to produce a production build for an Angular application and
    deploy it to share with the rest of the world!
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
