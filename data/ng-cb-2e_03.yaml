- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: The Magic of Dependency Injection in Angular
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 中依赖注入的魔法
- en: This chapter is all about the magic of **Dependency Injection** (**DI**) in
    Angular. Here, you’ll learn some detailed information about the concept of DI
    in Angular. DI is the process that Angular uses to inject different dependencies
    into components, directives, and services. You’ll work with several examples,
    using services and providers to get some hands-on experience that you can utilize
    in your later Angular projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于 Angular 中 **依赖注入**（**DI**）的魔法。在这里，你将了解 Angular 中 DI 概念的详细信息。DI 是 Angular
    用于将不同依赖项注入到组件、指令和服务的进程。你将通过几个示例进行操作，使用服务和提供者来获得一些实际经验，这些经验可以在你以后的 Angular 项目中利用。
- en: 'In this chapter, we’re going to cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Using Angular DI tokens
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular DI 令牌
- en: Optional dependencies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选依赖项
- en: Creating a singleton service using `providedIn`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `providedIn` 创建单例服务
- en: Creating a singleton service using `forRoot()`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `forRoot()` 创建单例服务
- en: Providing alternate classes against the same DI token
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对同一 DI 令牌提供替代类
- en: Dynamic configurations using value providers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用值提供者进行动态配置
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For the recipes in this chapter, ensure your setup is complete as per the ''Technical
    Requirements'' in the ''Angular-Cookbook-2E'' GitHub repository. For setup details,
    visit: [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md).
    The starter code for this chapter is located at [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter03](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter03).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的食谱，请确保你的设置已按照 'Angular-Cookbook-2E' GitHub 仓库中的 '技术要求' 完成。有关设置详细信息，请访问：[https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md)。本章的起始代码位于
    [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter03](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter03)。
- en: Using Angular DI tokens
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Angular DI 令牌
- en: In this recipe, you’ll learn how to create a basic DI token. We will create
    it for a regular TypeScript class, to be used as an Angular service using DI.
    We have a class named `Jokes` in our application, which is used in the `AppComponent`
    by manually creating a new instance of the class. This makes our code tightly
    coupled and hard to test, since the `AppComponent` class directly uses the `Jokes`
    class.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，你将学习如何创建基本的 DI 令牌。我们将为常规 TypeScript 类创建它，以便使用 DI 作为 Angular 服务。在我们的应用程序中有一个名为
    `Jokes` 的类，它通过手动创建该类的新实例在 `AppComponent` 中使用。这使得我们的代码紧密耦合且难以测试，因为 `AppComponent`
    类直接使用 `Jokes` 类。
- en: In other words, when running the tests for the `App` component, we now rely
    on the `Jokes` class, and if something changes in that class, our test will break.
    Since Angular is all about **DI** and **services**, we’ll use a DI token to use
    the `Jokes` class as an Angular service. We’ll use the `InjectionToken` method
    to create a DI token, and then the `@Inject` decorator to enable us to use the
    class in our service.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当运行 `App` 组件的测试时，我们现在依赖于 `Jokes` 类，如果该类中发生任何变化，我们的测试将失败。由于 Angular 专注于
    **DI** 和 **服务**，我们将使用 DI 令牌来使用 `Jokes` 类作为 Angular 服务。我们将使用 `InjectionToken` 方法创建
    DI 令牌，然后使用 `@Inject` 装饰器来使我们能够在服务中使用该类。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter03/ng-di-token`
    inside the cloned repository:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的 `start/apps/chapter03/ng-di-token`：
- en: Open the code repository in your code editor.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会在新浏览器标签页中打开应用，你应该会看到以下内容：
- en: '![](img/B18469_03_01.png)'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_03_01.png)'
- en: 'Figure 3.1: The ng-di-token app running on http://localhost:4200'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.1：在 http://localhost:4200 上运行的 ng-di-token 应用
- en: Now that we have the app running, we can move on to the steps for the recipe.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了应用，我们可以继续进行食谱的步骤。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The app we have right now shows a greeting message to a random user that has
    been retrieved from a TypeScript class, named `Jokes`. We create an instance of
    the `Jokes` class in the `AppComponent` class by using the statement `jokes =
    new Jokes();`. However, Angular has a built-in way of using classes as services
    using DI. So instead of using it as a class, we will use it as an Angular service
    using DI. We will start by creating an `InjectionToken` for our `Jokes` class,
    and then we will inject it into our `AppComponent` class. Perform these steps
    to follow along:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前拥有的应用程序向一个从 TypeScript 类 `Jokes` 中检索到的随机用户显示问候消息。我们通过在 `AppComponent` 类中使用语句
    `jokes = new Jokes();` 创建 `Jokes` 类的实例。然而，Angular 有一种内置的方式使用类作为服务通过依赖注入（DI）。所以，我们不会将其作为类使用，而是将其作为
    Angular 服务使用 DI。我们将首先为我们的 `Jokes` 类创建一个 `InjectionToken`，然后将其注入到 `AppComponent`
    类中。按照以下步骤进行操作：
- en: 'We’ll create an `InjectionToken` in the `jokes.class.ts` file. We will name
    the token `''Jokes''`, using a new `InjectionToken` instance. Finally, we will
    export this token from the file:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在 `jokes.class.ts` 文件中创建一个 `InjectionToken`。我们将命名令牌为 `'Jokes'`，使用一个新的 `InjectionToken`
    实例。最后，我们将从这个文件中导出这个令牌：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we’ll use the `inject` method from the `@angular/core` package and the
    `JOKES` token from the `jokes.class.ts` file in order to use the class, as follows:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用 `@angular/core` 包中的 `inject` 方法和 `jokes.class.ts` 文件中的 `JOKES` 令牌来使用该类，如下所示：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: And that is it. You should see the app works the same as before. The only difference
    is that instead of instantiating the instance of the `Jokes` class manually ourselves,
    we are relying on the injection token to instantiate it. This not only comes with
    the ease of not having to create instances, but if the `Jokes` class uses other
    classes as dependencies via Angular DI and any of those are missing, we will get
    the appropriate errors to fix the issues. As a result, we have a more robust architecture
    of our services and components, which ensures the dependencies are met before
    our application is run/built. Now that we know the recipe, let us take a closer
    look at how it works.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。你应该看到应用程序与之前一样工作。唯一的区别是，我们不是手动实例化 `Jokes` 类的实例，而是依赖于注入令牌来实例化它。这不仅带来了无需创建实例的便利，而且如果
    `Jokes` 类通过 Angular DI 使用其他类作为依赖项，并且其中任何一个缺失，我们将会得到适当的错误来修复问题。因此，我们有一个更健壮的服务和组件架构，这确保在应用程序运行/构建之前满足依赖项。现在我们知道了配方，让我们更详细地看看它是如何工作的。
- en: How it works…
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Angular does not recognize regular TypeScript classes as injectables. However,
    we can create our own injection tokens and use the `inject` method from the `@angular/core`
    package to inject the relevant classes and values wherever necessary. Angular
    recognizes these tokens behind the scenes and finds their corresponding definition,
    which is usually in the form of a `factory` function. Notice that we are using
    `providedIn: ''root''` within the token definition. This means there will be only
    one instance of the class in the entire application.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 'Angular 不识别常规 TypeScript 类作为可注入项。然而，我们可以创建自己的注入令牌，并使用 `@angular/core` 包中的 `inject`
    方法在需要的地方注入相关的类和值。Angular 在幕后识别这些令牌并找到它们的对应定义，这通常是以 `factory` 函数的形式。请注意，我们在令牌定义中使用
    `providedIn: ''root''`。这意味着在整个应用程序中只有一个类的实例。'
- en: See also
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: DI in Angular ([https://angular.io/guide/dependency-injection](https://angular.io/guide/dependency-injection))
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 中的 DI ([https://angular.io/guide/dependency-injection](https://angular.io/guide/dependency-injection))
- en: '`InjectionToken` documentation ([https://angular.io/api/core/InjectionToken](https://angular.io/api/core/InjectionToken))'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InjectionToken` 文档 ([https://angular.io/api/core/InjectionToken](https://angular.io/api/core/InjectionToken))'
- en: Optional dependencies
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选依赖
- en: Optional dependencies in Angular are powerful when you use or configure a dependency
    that may or may not exist or has not been provided within an Angular application.
    In this recipe, we will learn how to use the `@Optional` decorator to configure
    optional dependencies in our components and services. We will work with `LoggerService`
    and ensure our components do not break if they have not already been provided
    with the `LoggerService`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Angular 应用程序中使用或配置一个可能存在或不存在或尚未提供的依赖项时，Angular 中的可选依赖项非常强大。在这个配方中，我们将学习如何使用
    `@Optional` 装饰器在组件和服务中配置可选依赖项。我们将与 `LoggerService` 一起工作，确保如果组件尚未提供 `LoggerService`，它们不会崩溃。
- en: Getting ready
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter03/ng-optional-dependencies`
    inside the cloned repository:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用程序位于克隆的仓库中的`start/apps/chapter03/ng-optional-dependencies`目录下：
- en: Open the code repository in your code editor.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令来启动项目：
- en: '[PRE3]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用程序，你应该会看到以下内容：
- en: '![](img/B18469_03_02.png)'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_03_02.png)'
- en: 'Figure 3.2: The ng-optional-dependencies app running on http://localhost:4200'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.2：ng-optional-dependencies应用程序在http://localhost:4200上运行
- en: Now that we have the app running, we can move on to the steps for the recipe.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了应用程序，我们可以继续进行下一步骤。
- en: How to do it…
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We’ll have an app containing a `LoggerService`, which is provided using `providedIn:
    ''root''` as its injectable configuration. We’ll see what happens when we don’t
    provide this service anywhere. Then, we’ll identify and fix the issues using the
    `@Optional` decorator. Follow these steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将有一个包含`LoggerService`的应用程序，该服务通过`providedIn: ''root''`作为其可注入配置提供。我们将看到当我们没有在任何地方提供此服务时会发生什么。然后，我们将使用`@Optional`装饰器识别和修复问题。按照以下步骤操作：'
- en: First, let’s run the app, enter a new version number, `0.0.1`, and hit the **Submit**
    button.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们运行应用程序，输入一个新的版本号，`0.0.1`，然后点击**提交**按钮。
- en: 'This will result in the logs being saved in `localStorage` via `LoggerService`.
    Open **Chrome Dev Tools**, navigate to **Application**, select **Local Storage**,
    and then click on `http://localhost:4200`. You will see the key `vc_logs_ng_od`
    with log values, as follows:'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将导致日志通过`LoggerService`保存到`localStorage`中。打开**Chrome开发者工具**，导航到**应用程序**，选择**本地存储**，然后点击`http://localhost:4200`。你会看到带有日志值的键`vc_logs_ng_od`，如下所示：
- en: '![](img/B18469_03_03.png)'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_03_03.png)'
- en: 'Figure 3.3: The logs are saved in localStorage for http://localhost:4200'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.3：日志被保存在http://localhost:4200的localStorage中
- en: 'Let’s try to remove the configuration provided in the `@Injectable` decorator
    for `LoggerService`, in the `logger.service.ts` file. The change should be as
    follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`logger.service.ts`文件中尝试移除为`LoggerService`提供的`@Injectable`装饰器中的配置。更改应如下所示：
- en: '[PRE4]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will result in Angular not being able to recognize it and throwing an
    error in the console, as follows:'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将导致Angular无法识别它，并在控制台抛出错误，如下所示：
- en: '![](img/B18469_03_04.png)'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_03_04.png)'
- en: 'Figure 3.4: An error reflecting that Angular doesn’t recognize the LoggerService'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.4：一个反映Angular无法识别LoggerService错误的错误
- en: 'We can now use the `@Optional` decorator to mark the dependency as optional.
    Let’s import it from the `@angular/core` package and use the decorator in the
    constructor of `VcLogsComponent`, in the `vc-logs.component.ts` file, as follows:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用`@Optional`装饰器将依赖项标记为可选。让我们从`@angular/core`包中导入它，并在`vc-logs.component.ts`文件的`VcLogsComponent`构造函数中使用装饰器，如下所示：
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Great! Now, if you refresh the app and view the console, there should be a different
    error. Yay, progress!
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 太好了！现在，如果你刷新应用程序并查看控制台，应该会有不同的错误。太棒了，有进展！
- en: '*Figure 3.5* shows that we have a new error because we’re trying to call the
    `this.logger.log()` statement inside the `ngOnChanges` method.'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图3.5* 显示，我们有一个新的错误，因为我们正在尝试在`ngOnChanges`方法内部调用`this.logger.log()`语句。'
- en: '![](img/B18469_03_05.png)'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_03_05.png)'
- en: 'Figure 3.5: An error detailing that this.logger is essentially null now'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.5：一个详细说明`this.logger`现在是基本为空的错误
- en: 'To fix this issue, we can either decide not to log anything at all, or we can
    fall back to the `console.*` methods if `LoggerService` is not provided. The code
    falls back to the `console.*` method is as follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以选择完全不记录任何日志，或者如果未提供`LoggerService`，则回退到`console.*`方法。回退到`console.*`方法的代码如下：
- en: '[PRE6]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s also update the ngOnChanges block to use this log (getter) function:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也更新`ngOnChanges`块以使用此日志（获取器）函数：
- en: '[PRE7]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, if you update the version and hit **Submit**, you should see the logs on
    the console, as follows:![](img/B18469_03_06.png)
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你更新版本并点击**提交**，你应该会在控制台上看到日志，如下所示：![](img/B18469_03_06.png)
- en: 'Figure 3.6: The logs being printed on the console as a fallback to LoggerService
    not being provided'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.6：当未提供LoggerService时，日志作为回退在控制台上的打印
- en: Great! We’ve finished the recipe, and everything looks great. Please refer to
    the next section to understand how it works.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们已经完成了食谱，一切看起来都很棒。请参考下一节了解它是如何工作的。
- en: How it works
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The `@Optional` decorator is a special one from the `@angular/core` package,
    which allows you to mark a dependency as optional. Behind the scenes, when used
    in the constructor method of a class with a dependency, Angular will provide the
    value as `null` when the dependency doesn’t exist or is not provided to the app.
    Since we remove the configuration object from the `@Injectable()` decorator from
    the `LoggerService` class, it isn’t provided in Angular for DI. As a result, our
    `@Optional()` decorator makes it `null` when injected and doesn’t cause Angular
    to throw the `NullInjectorError` shown in *Figure 3.4*. In *step 4*, we create
    a `log` getter function in our component’s class `VcLogsComponent`, so we can
    use the `LoggerService`''s method named `log` when the service is provided; and
    `console.log` otherwise. Then, in the following steps, we just use the `log` method
    we created. If you go back to the `logger.service.ts` file and provide the service
    as `providedIn: ''root''` again, you won’t see any console logs now and will see
    that now the app uses the service, i.e., the `LoggerService` that uses the `localStorage`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Optional`装饰器是`@angular/core`包中的一个特殊装饰器，它允许你将一个依赖项标记为可选。在幕后，当在具有依赖项的类的构造函数方法中使用时，如果依赖项不存在或未提供给应用程序，Angular将提供值为`null`。由于我们从`LoggerService`类的`@Injectable()`装饰器中移除了配置对象，它不会在Angular中提供用于DI。因此，我们的`@Optional()`装饰器在注入时将其设置为`null`，不会导致Angular抛出*图3.4*中显示的`NullInjectorError`。在*步骤4*中，我们在组件的类`VcLogsComponent`中创建了一个`log`获取器函数，这样我们就可以在服务提供时使用`LoggerService`的`log`方法；否则使用`console.log`。然后，在接下来的步骤中，我们只需使用我们创建的`log`方法。如果你回到`logger.service.ts`文件并将服务作为`providedIn:
    ''root''`再次提供，你现在将看不到任何控制台日志，并且会看到现在应用程序正在使用服务，即使用`localStorage`的`LoggerService`。'
- en: See also
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: Optional dependencies in Angular ([https://angular.io/guide/dependency-injection#optional-dependencies](https://angular.io/guide/dependency-injection#optional-dependencies))
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular中的可选依赖项（[https://angular.io/guide/dependency-injection#optional-dependencies](https://angular.io/guide/dependency-injection#optional-dependencies)）
- en: Hierarchical injectors in Angular ([https://angular.io/guide/hierarchical-dependency-injection](https://angular.io/guide/hierarchical-dependency-injection))
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular中的分层注入器（[https://angular.io/guide/hierarchical-dependency-injection](https://angular.io/guide/hierarchical-dependency-injection)）
- en: Creating a singleton service using providedIn
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`providedIn`创建单例服务
- en: 'In this recipe, you’ll learn several tips on how to ensure your Angular service
    is being used as a singleton. This means that there will only be one instance
    of your service in the entire application. We’ll use a couple of techniques, including
    the `providedIn: ''root''` statement, making sure we only provide the service
    once in the entire app by using the `@Optional()` and `@SkipSelf()` decorators.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '在本食谱中，你将学习如何确保你的Angular服务作为单例使用的几个技巧。这意味着在整个应用程序中，你的服务将只有一个实例。我们将使用一些技术，包括`providedIn:
    ''root''`语句，通过使用`@Optional()`和`@SkipSelf()`装饰器确保在整个应用程序中只提供一次服务。'
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter03/ng-singleton-service`
    inside the cloned repository:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用程序位于克隆的仓库中的`start/apps/chapter03/ng-singleton-service`内：
- en: Open the code repository in your code editor.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE8]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用程序，你应该看到以下内容：
- en: '![](img/B18469_03_07.png)'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_03_07.png)'
- en: 'Figure 3.7: The ng-singleton-service app running on http://localhost:4200'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.7：运行在http://localhost:4200上的ng-singleton-service应用程序
- en: Now that we have the app running, we can move on to the steps for the recipe.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动了应用程序，我们可以继续进行下一步的步骤。
- en: How to do it
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'The problem with the app is that if you add or remove any notifications, the
    count on the bell icon in the header does not change. That’s due to us having
    multiple instances of `NotificationsService` provided in the `AppModule` and `HomeModule`
    classes. Please refer to the following steps to ensure we only have a single instance
    of the service in the app:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序的问题在于，如果你添加或删除任何通知，页眉中铃铛图标上的计数不会改变。这是因为我们在`AppModule`和`HomeModule`类中提供了多个`NotificationsService`实例。请参考以下步骤以确保应用程序中只有一个服务实例：
- en: 'We will use `providedIn: ''root''` for the `NotificationService` to tell Angular
    that it is only provided in the root module, and it should only have one instance
    in the entire app. So, let’s go to `notifications.service.ts` and pass `providedIn:
    ''root''` in the `@Injectable` decorator parameters, as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们将使用`providedIn: ''root''`为`NotificationService`来告诉Angular它只应在根模块中提供，并且在整个应用中只有一个实例。所以，让我们去`notifications.service.ts`文件，并在`@Injectable`装饰器参数中传递`providedIn:
    ''root''`，如下所示：'
- en: '[PRE9]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Great! Now, even if you refresh and try adding or removing notifications, you’ll
    still see that the count in the header doesn’t change. *“But why is this, Ahsan?”*
    Well, I’m glad you asked. It’s because we’re still providing the service in `AppModule`
    as well as in `HomeModule` classes.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 太好了！现在，即使你刷新并尝试添加或删除通知，你仍然会看到标题中的计数没有变化。*“但是为什么这样，Ahsan？”* 好吧，我很高兴你问了。这是因为我们仍然在`AppModule`和`HomeModule`类中提供了这个服务。
- en: 'First, let’s remove `NotificationsService` from the `providers` array in `app.module.ts`,
    as highlighted in the following code block:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们从`app.module.ts`中的`providers`数组中移除`NotificationsService`，如下面的代码块中突出显示：
- en: '[PRE10]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we’ll remove `NotificationsService` from `home.module.ts`, as highlighted
    in the following code block:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将从`home.module.ts`中移除`NotificationsService`，如下面的代码块中突出显示：
- en: '[PRE11]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Awesome! Now, you should be able to see the count in the header change according
    to whether you add/remove notifications. However, what happens if someone still
    provides it in another lazily loaded module by mistake?
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 太棒了！现在，你应该能够看到标题中的计数根据你是否添加/删除通知而改变。然而，如果有人不小心在另一个懒加载的模块中错误地提供了它，会发生什么呢？
- en: 'Let’s put `NotificationsService` back in the `home.module.ts` file:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们把`NotificationsService`放回`home.module.ts`文件中：
- en: '[PRE12]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Boom! We don’t have any errors on the console or during compile time. However,
    we do have the issue of the count not updating in the header. So, how do we alert
    the developers if they make such a mistake?
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 哗啦！我们在控制台或编译时间都没有任何错误。然而，我们有一个问题，那就是标题中的计数没有更新。那么，我们如何提醒开发者他们犯了这样的错误呢？
- en: 'In order to alert the developer about potential duplicate providers, we will
    use the `@SkipSelf` decorator from the `@angular/core` package in our `NotificationsService`,
    and throw an error to notify and modify `NotificationsService`, as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了提醒开发者关于潜在的重复提供者，我们将在我们的`NotificationsService`中使用来自`@angular/core`包的`@SkipSelf`装饰器，并抛出一个错误来通知并修改`NotificationsService`，如下所示：
- en: '[PRE13]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the previous step now complete, you’ll notice that we have a problem,
    which is that we have failed to provide `NotificationsService` to our app. You
    should see this in the console:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在完成前一步后，你会注意到我们有一个问题，那就是我们未能向我们的应用提供`NotificationsService`。你应该在控制台中看到以下内容：
- en: '![](img/B18469_03_08.png)'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_03_08.png)'
- en: 'Figure 3.8: An error detailing that NotificationsService can’t be injected
    into NotificationsService'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.8：一个详细说明NotificationsService无法注入到NotificationsService的错误
- en: The reason for this is that `NotificationsService` is now a dependency of `NotificationsService`
    itself. This can’t work as it has not already been resolved by Angular. To fix
    this, we’ll also use the `@Optional()` decorator in the next step.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 原因是`NotificationsService`现在成为了它自己的依赖。这行不通，因为它还没有被Angular解析。为了解决这个问题，我们将在下一步中使用`@Optional()`装饰器。
- en: 'All right – now, we’ll use the `@Optional()` decorator in `notifications.service.ts,`
    which is in the constructor for the dependency alongside the `@SkipSelf` decorator.
    The code should appear as follows:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好吧——现在，我们将在`notifications.service.ts`中使用`@Optional()`装饰器，它位于构造函数中的依赖项旁边，与`@SkipSelf`装饰器一起。代码应该如下所示：
- en: '[PRE14]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have now fixed the `NotificationsService` -> `NotificationsService` dependency
    issue. You should see the proper error for the `NotificationsService` being provided
    multiple times in the console, as follows:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在已经解决了`NotificationsService` -> `NotificationsService`依赖问题。你应该在控制台中看到`NotificationsService`被多次提供的正确错误，如下所示：
- en: '![](img/B18469_03_09.png)'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_03_09.png)'
- en: 'Figure 3.9: An error detailing that NotificationsService is already provided
    in the app'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.9：一个详细说明NotificationsService已经在应用中提供的错误
- en: Now, we’ll safely remove the provided `NotificationsService` from the `providers`
    array in the `home.module.ts` file, as shown in *step 3*, and check whether the
    app is working correctly
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将安全地从`home.module.ts`文件中的`providers`数组中移除提供的`NotificationsService`，正如*步骤
    3*中所示，并检查应用是否正常工作。
- en: Bam! We now have a singleton service using the `providedIn` strategy. In the
    next section, let’s discuss how it works.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 哗！我们现在使用`providedIn`策略有一个单例服务。在下一节中，让我们讨论它是如何工作的。
- en: How it works
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'Whenever we try to inject a service somewhere, by default, it tries to find
    a service inside the associated module of where you’re injecting the service.
    When we use `providedIn: ''root''` to declare a service, whenever the service
    is injected anywhere in the app, Angular knows that it simply must find the service
    definition in the root scope, instead of trying to find it in the feature modules
    or anywhere else.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '每当我们尝试在某个地方注入一个服务时，默认情况下，它会尝试在注入服务的相关模块中寻找服务。当我们使用 `providedIn: ''root''` 来声明一个服务时，无论服务在哪里注入，Angular
    都知道它必须在根作用域中找到服务定义，而不是尝试在功能模块或其他地方寻找。'
- en: 'However, you must make sure that the service is only provided once in the entire
    application. If you provide it in multiple modules, then even with `providedIn:
    ''root''`, you’ll have multiple instances of the service. To avoid providing a
    service in multiple modules or multiple places in the app, we can use the `@SkipSelf()`
    decorator with the `@Optional()` decorator in the services’ constructor to check
    whether the service has already been provided in the app.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，你必须确保整个应用中只提供一次服务。如果你在多个模块中提供它，即使使用 `providedIn: ''root''`，你也会有多个服务实例。为了避免在多个模块或应用中的多个位置提供服务，我们可以在服务的构造函数中使用
    `@SkipSelf()` 装饰器和 `@Optional()` 装饰器来检查服务是否已经在应用中提供。'
- en: See also
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Hierarchical DI in Angular ([https://angular.io/guide/hierarchical-dependency-injection](https://angular.io/guide/hierarchical-dependency-injection))
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 中的分层依赖注入 ([https://angular.io/guide/hierarchical-dependency-injection](https://angular.io/guide/hierarchical-dependency-injection))
- en: Creating a singleton service using forRoot()
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `forRoot()` 创建单例服务
- en: In this recipe, you’ll learn how to use `ModuleWithProviders` and the `forRoot()`
    statement to ensure your Angular service is used as a singleton in the entire
    app. We’ll start with an app that has multiple instances of `NotificationsService`,
    and we’ll implement the necessary code to make sure we end up with a single instance
    of the service in our application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何使用 `ModuleWithProviders` 和 `forRoot()` 语句来确保你的 Angular 服务在整个应用中以单例的形式使用。我们将从一个具有多个
    `NotificationsService` 实例的应用开始，并实现必要的代码以确保我们最终在我们的应用中获得单个服务实例。
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter03/ng-singleton-service-forroot`,
    inside the cloned repository:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于 `start/apps/chapter03/ng-singleton-service-forroot`，在克隆的仓库内：
- en: Open the code repository in your code editor.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the Terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令来运行项目：
- en: '[PRE15]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用，你应该看到以下内容：
- en: '![](img/B18469_03_10.png)'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_03_10.png)'
- en: 'Figure 3.10: The ng-singleton-service-forroot app running on http://localhost:4200'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.10：运行在 http://localhost:4200 的 ng-singleton-service-forroot 应用
- en: Now that we have the app running, in the next section, we can move on to the
    steps for the recipe.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了应用，在下一节中，我们可以继续进行菜谱的步骤。
- en: How to do it
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'In order to make sure you only have a singleton service in the app with the
    `forRoot` method, you need to understand how `ModuleWithProviders` and the `static
    forRoot()` method are created and implemented. Perform the following steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你只使用 `forRoot` 方法在应用中有一个单例服务，你需要理解 `ModuleWithProviders` 和 `static forRoot()`
    方法是如何创建和实现的。执行以下步骤：
- en: 'First, we’ll make sure that the service has its own module. In many Angular
    applications, you’ll probably see `CoreModule` where the services are provided
    (given we’re not using the `providedIn: ''root''` syntax for some reason). To
    begin, we’ll create a module, named `ServicesModule`, using the following command
    from the project root:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '首先，我们要确保服务有自己的模块。在许多 Angular 应用中，你可能会看到 `CoreModule`，其中提供了服务（假设我们没有使用 `providedIn:
    ''root''` 语法的原因）。为了开始，我们将使用以下命令从项目根目录创建一个名为 `ServicesModule` 的模块：'
- en: '[PRE16]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s create a static method `forRoot()` inside the `ServicesModule` class
    in the `services.module.ts` file. We’ll name the method `forRoot` and return a
    `ModuleWithProviders` object that contains the `NotificationsService`, provided
    in the `providers` array, as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `services.module.ts` 文件中的 `ServicesModule` 类内创建一个静态方法 `forRoot()`。我们将命名该方法为
    `forRoot`，并返回一个包含 `NotificationsService`（在 `providers` 数组中提供）的 `ModuleWithProviders`
    对象，如下所示：
- en: '[PRE17]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we’ll remove the `NotificationsService` from the `app.module.ts` file’s
    `providers` array and include `ServicesModule` in the `app.module.ts` file. In
    particular, we’ll add `ServicesModule` in the `imports` array using the `forRoot()`
    method, as highlighted in the following code block.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将从`app.module.ts`文件的`providers`数组中移除`NotificationsService`，并在`app.module.ts`文件中包含`ServicesModule`。特别是，我们将使用`forRoot()`方法在`imports`数组中添加`ServicesModule`，如下面的代码块所示。
- en: 'This is because it injects `ServicesModule` with the providers in `AppModule`,
    for instance, with the `NotificationsService` being provided, as follows:'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是因为它将`ServicesModule`及其提供者注入到`AppModule`中，例如，提供`NotificationsService`，如下所示：
- en: '[PRE18]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You’ll notice that when adding/removing notifications, the count in the header
    still doesn’t change. This is because we’re still providing the `NotificationsService`
    in the `home.module.ts` file.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到，在添加/删除通知时，标题中的计数仍然没有改变。这是因为我们仍在`home.module.ts`文件中提供`NotificationsService`。
- en: 'We’ll remove the `NotificationsService` from the `providers` array in the `home.module.ts`
    file, as follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从`home.module.ts`文件的`providers`数组中移除`NotificationsService`，如下所示：
- en: '[PRE19]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Great job. Now that we have finished the recipe, in the next section, let’s
    discuss how it works.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好。现在我们已经完成了这个食谱，在下一节中，让我们讨论它是如何工作的。
- en: How it works
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: '`ModuleWithProviders` acts as a wrapper for an `NgModule`, bundling it with
    a `providers` array. It’s used to configure an `NgModule` along with its providers,
    ensuring that when the module is imported elsewhere, it brings along its providers,
    too. In our `ServicesModule`, we’ve created a `forRoot` method that returns a
    `ModuleWithProviders`. It includes our `NotificationsService`, which allows us
    to have a single instance of this service throughout the app, avoiding multiple
    instances that would normally occur if `NotificationsService` was provided in
    the `providers` array of `ServicesModule` and imported into various modules. Therefore,
    to ensure a single instance, `ServicesModule` should be imported using the `ModuleWithProviders`
    approach, not in the standard way. That is why when using the `ModuleWithProviders`
    approach, we don’t import the `ServicesModule` in the regular way, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModuleWithProviders`充当`NgModule`的包装器，将其与`providers`数组捆绑在一起。它用于配置`NgModule`及其提供者，确保当模块在其他地方导入时，它也带来了其提供者。在我们的`ServicesModule`中，我们创建了一个返回`ModuleWithProviders`的`forRoot`方法。它包括我们的`NotificationsService`，这使得我们可以在整个应用中拥有这个服务的单个实例，避免了在`ServicesModule`的`providers`数组中提供`NotificationsService`并将其导入到各个模块时通常出现的多个实例。因此，为了确保单个实例，`ServicesModule`应该使用`ModuleWithProviders`方法导入，而不是标准方式。这就是为什么在使用`ModuleWithProviders`方法时，我们不按常规方式导入`ServicesModule`，如下所示：'
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Instead, we import it using the `forRoot` method which ensures the `NotificationService`
    is only provided once in the entire app as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们使用`forRoot`方法导入它，这确保了`NotificationService`在整个应用中只被提供一次，如下所示：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that you understand how the recipe works, see the next section for some
    useful links.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了这个食谱的工作原理，请查看下一节以获取一些有用的链接。
- en: See also
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The `ModuleWithProviders` Angular documentation ([https://angular.io/api/core/ModuleWithProviders](https://angular.io/api/core/ModuleWithProviders))
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ModuleWithProviders` Angular文档([https://angular.io/api/core/ModuleWithProviders](https://angular.io/api/core/ModuleWithProviders))'
- en: The `ModuleWithProviders` migration documentation ([https://angular.io/guide/migration-module-with-providers%20](https://angular.io/guide/migration-module-with-providers%20))
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ModuleWithProviders`迁移文档([https://angular.io/guide/migration-module-with-providers%20](https://angular.io/guide/migration-module-with-providers%20))'
- en: Providing alternate classes against the same DI Token
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 针对相同的DI令牌提供备用类
- en: In this recipe, you’ll learn how to provide two different services to the app
    using **Aliased class providers**. This is extremely helpful in complex applications
    where you need to narrow down the implementation of the service/class for some
    components/modules, that is, providing different classes against the same DI token
    to have a polymorphic behavior. Additionally, aliasing is used in component/service
    unit tests to mock the dependent service’s actual implementation so that we don’t
    rely on it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，你将学习如何使用**别名类提供者**向应用提供两个不同的服务。这在复杂的应用程序中非常有用，其中你需要为某些组件/模块缩小服务的/类的实现，即针对相同的DI令牌提供不同的类以实现多态行为。此外，别名在组件/服务单元测试中使用，以模拟依赖服务的实际实现，这样我们就不依赖于它了。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter03/ng-aliased-class-providers`,
    inside the cloned repository:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于 `start/apps/chapter03/ng-aliased-class-providers`，在克隆的仓库内：
- en: Open the code repository in your code editor.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码编辑器中打开代码仓库。
- en: 'Open the Terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE22]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This should open the app in a new browser tab, and you should see the app as
    shown in *Figure 3.11*.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用，您应该看到如图 3.11 所示的应用。
- en: Click on the **Login as Admin** button. You should see something similar to
    the following screenshot:![](img/B18469_03_11.png)
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **登录为管理员** 按钮。您应该看到以下截图类似的内容：![](img/B18469_03_11.png)
- en: 'Figure 3.11: The ng-aliased-class-providers app running on http://localhost:4200'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.11：运行在 http://localhost:4200 的 ng-aliased-class-providers 应用
- en: Now that we have the app running, let’s move to the next section to follow the
    steps for the recipe.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了应用，让我们进入下一节，按照菜谱的步骤进行操作。
- en: How to do it
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'We have a standalone component named `BucketComponent`, which is being used
    in both the admin and employee components. `BucketComponent` uses `BucketService`
    behind the scenes to add/remove items from and to a bucket. For the employee,
    we’ll restrict the ability to remove an item by providing an `aliased` class provider
    and a replacement of `BucketService` named `EmployeeBucketService`. This is so
    that we can override the remove item functionality. Perform the following steps
    to get started:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为 `BucketComponent` 的独立组件，它被用于管理员和员工组件中。`BucketComponent` 在幕后使用 `BucketService`
    来添加/删除桶中的项目。对于员工，我们将通过提供一个 `aliased` 类提供者和名为 `EmployeeBucketService` 的 `BucketService`
    替换来限制删除项目的权限。这样我们就可以覆盖删除项目功能。按照以下步骤开始：
- en: 'We’ll start by creating `EmployeeBucketService` within the `employee` folder.
    Run the following command from the workspace root:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在 `employee` 文件夹内创建 `EmployeeBucketService`。从工作区根目录运行以下命令：
- en: '[PRE23]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we’ll extend `EmployeeBucketService` from `BucketService` so that we
    get all the goodness of the `BucketService` class. Let’s modify the code as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将从 `BucketService` 扩展 `EmployeeBucketService`，以便我们能够获得 `BucketService`
    类的所有优点。让我们按照以下方式修改代码：
- en: '[PRE24]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will now override the `removeItem` method to display a simple `alert`, mentioning
    that the employees can’t remove items from the bucket. Your code should appear
    as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将重写 `removeItem` 方法以显示一个简单的 `alert`，说明员工不能从桶中删除项目。您的代码应如下所示：
- en: '[PRE25]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As a final step, we need to provide the `aliased` class provider to the `employee.component.ts`
    file, as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，我们需要将 `aliased` 类提供者提供给 `employee.component.ts` 文件，如下所示：
- en: '[PRE26]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you now log in as an employee in the app and try to remove an item, you’ll
    see an alert pop up, which says `Employees cannot delete items`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在以员工身份登录应用并尝试删除项目，您将看到一个弹出窗口，上面写着“员工不能删除项目”。
- en: How it works
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'When we inject a service into a component, Angular tries to find that component
    inside the component/module we’ve provided the dependency for and then by moving
    up the hierarchy of components and modules. Our `BucketService` is provided in
    `''root''`, using the `providedIn: ''root''` syntax. Therefore, it resides at
    the top of the hierarchy. However, since, in this recipe, we use an `aliased`
    class provider in the `EmployeeComponent` class against the DI token `BucketService`,
    when Angular searches for `BucketService` for the `EmployeeComponent`, it quickly
    finds the `EmployeeBucketService` against the token in the `EmployeeComponent`
    and stops there – i.e., it doesn’t reach the “root” to get the actual `BucketService`.
    This is what we intended.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们将服务注入到组件中时，Angular 会尝试在我们提供的依赖项的组件/模块中找到该组件，然后通过移动组件和模块的层次结构来查找。我们的 `BucketService`
    在 `''root''` 中提供，使用 `providedIn: ''root''` 语法。因此，它位于层次结构的顶部。然而，由于在这个菜谱中，我们在 `EmployeeComponent`
    类中对 DI 令牌 `BucketService` 使用了一个 `aliased` 类提供者，当 Angular 为 `EmployeeComponent`
    查找 `BucketService` 时，它会快速找到 `EmployeeComponent` 中的 `EmployeeBucketService` 对应的令牌并停止搜索——即，它不会到达“root”以获取实际的
    `BucketService`。这正是我们想要的。'
- en: See also
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: DI in Angular ([https://angular.io/guide/dependency-injection](https://angular.io/guide/dependency-injection))
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 中的依赖注入 ([https://angular.io/guide/dependency-injection](https://angular.io/guide/dependency-injection))
- en: Hierarchical injectors in Angular ([https://angular.io/guide/hierarchical-dependency-injection](https://angular.io/guide/hierarchical-dependency-injection))
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 中的分层注入器 ([https://angular.io/guide/hierarchical-dependency-injection](https://angular.io/guide/hierarchical-dependency-injection))
- en: Dynamic configurations using value providers
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用值提供者的动态配置
- en: In this recipe, you’ll learn how to use value providers in Angular to provide
    constants and config values to your app. We’ll start with the same example from
    the previous recipe, which involves `EmployeeComponent` and `AdminComponent` using
    the `BucketComponent` to manage a bucket of fruits. We will restrict the `EmployeeComponent`
    from deleting items from the bucket by using the configuration with a value provider.
    As a result, the employees won’t even see the **Delete** button.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何在Angular中使用值提供者来为你的应用提供常量和配置值。我们将从上一个菜谱中的相同示例开始，该示例涉及`EmployeeComponent`和`AdminComponent`使用`BucketComponent`来管理一个水果桶。我们将通过使用值提供者的配置来限制`EmployeeComponent`删除桶中项目的权限。因此，员工甚至看不到**删除**按钮。
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter03/ng-value-providers`
    inside the cloned repository:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的`start/apps/chapter03/ng-value-providers`目录下：
- en: Open the code repository in your code editor.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令来运行项目：
- en: '[PRE27]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This should open the app in a new browser tab, and you should see the app as
    shown in *Figure 3.12*.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会在新浏览器标签页中打开应用，你应该会看到如图3.12所示的界面。
- en: Click on the **Login as Admin** button. You should see something like the following
    screenshot:![](img/B18469_03_12.png)
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**登录为管理员**按钮。你应该会看到如下截图：![](img/B18469_03_12.png)
- en: 'Figure 3.12: The ng-value-providers app running on http://localhost:4200'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.12：运行在http://localhost:4200的ng-value-providers应用
- en: Now that you see the app running, let’s look at the next section to follow the
    recipe.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你看到应用正在运行，让我们看看下一步要遵循的菜谱。
- en: How to do it
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'We have a standalone component named `BucketComponent`, which is being used
    in both the admin and employee components. `BucketComponent` uses `BucketService`
    behind the scenes to add/remove items from and to a bucket. For the employee,
    we’ll restrict the ability to remove an item by providing a value provider. This
    is so that we can override the remove item functionality. Let’s begin with the
    following steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`BucketComponent`的独立组件，它被用于管理员和员工组件中。`BucketComponent`在幕后使用`BucketService`来添加/删除桶中的项目。对于员工，我们将通过提供值提供者来限制删除项目的权限。这样我们就可以覆盖删除项目的功能。让我们从以下步骤开始：
- en: 'First, we’ll start by creating the value provider with `InjectionToken` within
    a new file, named `app-config.ts`, in the root of the project. The code should
    appear as follows:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将在项目根目录下创建一个新的文件，命名为`app-config.ts`，并在其中使用`InjectionToken`创建值提供者。代码应如下所示：
- en: '[PRE28]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Before we can actually use this `AppConfig` constant in our `BucketComponent`,
    we need to register it to the `AppModule` so that when we inject this in the `BucketComponent`,
    the value of the provider is resolved.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们实际上可以在`BucketComponent`中使用这个`AppConfig`常量之前，我们需要将其注册到`AppModule`中，这样当我们向`BucketComponent`注入这个值时，提供者的值才能被解析。
- en: 'Let’s add the provider to the `app.module.ts` file, as follows:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`app.module.ts`文件中添加提供者，如下所示：
- en: '[PRE29]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, the app knows about the `AppConfig` constants. The next step is to use
    this constant in `BucketComponent`.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，应用已经知道了`AppConfig`常量。下一步是在`BucketComponent`中使用这个常量。
- en: 'We’ll use the `inject` method to inject it inside the `BucketComponent` class,
    in the `bucket/bucket.component.ts` file, as follows:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`inject`方法将其注入到`BucketComponent`类中，在`bucket/bucket.component.ts`文件中，如下所示：
- en: '[PRE30]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Great! The constant has been injected. Now, if you refresh the app, you shouldn’t
    get any errors. The next step is to use the `canDeleteItems` property from `config`
    in `BucketComponent` to show/hide the `delete` button.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 太好了！常量已经注入。现在，如果你刷新应用，你不应该收到任何错误。下一步是使用`BucketComponent`中的`config`的`canDeleteItems`属性来显示/隐藏`delete`按钮。
- en: 'Now, we’ll add an `*ngIf` directive in the `bucket/ bucket.component.html`
    file to only show the `delete` button if the value of `appConfig.canDeleteItems`
    is `true`. Update the element with the `fruites__item__delete-icon` class, as
    follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在`bucket/bucket.component.html`文件中添加一个`*ngIf`指令，仅在`appConfig.canDeleteItems`的值为`true`时显示`delete`按钮。更新具有`fruites__item__delete-icon`类的元素，如下所示：
- en: '[PRE31]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can test whether everything works by setting the `AppConfig` constant’s
    `canDeleteItems` property to `false`. Note that the **Delete** button is now hidden
    for both the admin and employee. Once tested, set the value of `canDeleteItems`
    back to `true` again.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以通过将`AppConfig`常量的`canDeleteItems`属性设置为`false`来测试是否一切正常。请注意，**删除**按钮现在对管理员和员工都不可见。测试完成后，请将`canDeleteItems`的值再次设置为`true`。
- en: Now, we have everything set up. Let’s add a new constant so that we can hide
    the **Delete** button for the employee only.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们已经设置好了一切。让我们添加一个新的常量，以便我们只为员工隐藏**删除**按钮。
- en: 'Let’s create an employee configuration object now. We’ll create an `employee.config.ts`
    file inside the `employee` folder, and we will add the following code to it:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个员工配置对象。我们将在`employee`文件夹内创建一个`employee.config.ts`文件，并将以下代码添加到其中：
- en: '[PRE32]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we’ll provide this `EmployeeConfig` constant to the `EmployeeComponent`
    for the same `APP_CONFIG` injection token. The code in the `employee.component.ts`
    file should look as follows:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将这个`EmployeeConfig`常量提供给`EmployeeComponent`，用于相同的`APP_CONFIG`注入令牌。`employee.component.ts`文件中的代码应如下所示：
- en: '[PRE33]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: And we’re done! The recipe is now complete. You can see that the **Delete**
    button is visible to the admin but hidden for the employee. It’s all thanks to
    the magic of value providers.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！配方现在完整了。您可以看到，**删除**按钮对管理员可见，但对员工隐藏。这一切都归功于值提供者的魔力。
- en: How it works
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: When we inject a token into a component, Angular tries to find the resolved
    value of the token in the injected place and then by moving up the hierarchy of
    components and modules. We provided the `EmployeeConfig` object against the `APP_CONFIG`
    token in the `EmployeeComponent` class. When Angular tries to resolve the token’s
    value for `BucketComponent`, it finds it early as `EmployeeConfig`, within the
    `EmployeeComponent` instead of the value provided in the `AppModule` as `AppConfig`.
    Therefore, Angular stops right there and doesn’t reach `AppModule`. This is amazing,
    as we can now have a global configuration and override the configuration within
    nested modules/components.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将令牌注入到组件中时，Angular会尝试在注入位置找到令牌的解析值，然后通过移动组件和模块的层次结构向上查找。我们在`EmployeeComponent`类中针对`APP_CONFIG`令牌提供了`EmployeeConfig`对象。当Angular尝试解析`BucketComponent`的令牌值时，它会在`EmployeeComponent`内部找到`EmployeeConfig`，而不是在`AppModule`中作为`AppConfig`提供的值。因此，Angular会立即停止，不会到达`AppModule`。这真是太神奇了，因为我们现在可以拥有全局配置，并覆盖嵌套模块/组件内的配置。
- en: See also
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: DI in Angular ([https://angular.io/guide/dependency-injection](https://angular.io/guide/dependency-injection))
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular中的依赖注入([https://angular.io/guide/dependency-injection](https://angular.io/guide/dependency-injection))
- en: Hierarchical injectors in Angular ([https://angular.io/guide/hierarchical-dependency-injection](https://angular.io/guide/hierarchical-dependency-injection))
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular中的分层注入器([https://angular.io/guide/hierarchical-dependency-injection](https://angular.io/guide/hierarchical-dependency-injection))
- en: Learn more on Discord
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的Discord社区——在那里您可以分享反馈、向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/AngularCookbook2e](Chapter_3.xhtml)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/AngularCookbook2e](Chapter_3.xhtml)'
- en: '![](img/QR_Code1388317275422265.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1388317275422265.png)'
