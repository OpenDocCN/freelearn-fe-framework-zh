- en: Explaining Pipes and Communicating with RESTful Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释管道和与RESTful服务通信
- en: 'In the previous chapter, we covered some very powerful features of the framework.
    However, we can go even deeper into the functionality of Angular''s forms module
    and router. In this chapter, we''ll explain how we can perform the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们介绍了框架的一些非常强大的功能。然而，我们可以进一步深入到Angular表单模块和路由的功能。在本章中，我们将解释我们如何执行以下操作：
- en: Developing model-driven forms
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发模型驱动表单
- en: Defining parameterized routes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义参数化路由
- en: Defining child routes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义子路由
- en: Using the HTTP module for communication with RESTful APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP模块与RESTful API通信
- en: Transforming data with custom pipes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义管道转换数据
- en: We will explore all these concepts in the process of extending the functionality
    of the "Coders repository" application. At the beginning of the preceding chapter,
    we mentioned that we will allow the import of developers from GitHub. However,
    before we implement this feature, let's extend the functionality of the form.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在扩展“Coders repository”应用程序功能的过程中探讨所有这些概念。在前一章的开始，我们提到我们将允许从GitHub导入开发者。然而，在我们实现这个功能之前，让我们扩展表单的功能。
- en: Developing model-driven forms in Angular
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Angular中开发模型驱动表单
- en: These will be the last steps for finishing "Coders repository". You can build
    on top of the code available at `ch7/step-1/` (or `ch7/step-2`, depending on your
    previous work), in order to extend the functionality of the application with the
    new concepts we will cover. The complete example is located at `ch8/multi-page-model-driven`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将是完成“Coders repository”的最后几步。您可以在`ch7/step-1/`（或`ch7/step-2`，取决于您之前的工作）提供的代码基础上构建，以扩展应用程序的功能，我们将介绍新的概念。完整的示例位于`ch8/multi-page-model-driven`。
- en: 'This is the result that we will achieve by the end of this section:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将在本节结束时实现的结果：
- en: '![](img/5bbecb65-7340-4363-a5df-54c6c66615c7.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5bbecb65-7340-4363-a5df-54c6c66615c7.png)'
- en: Figure 1
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图1
- en: 'In the preceding screenshot, there are two forms:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，有两个表单：
- en: 'A form that has the following controls:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该表单包含以下控件：
- en: The text input for the GitHub handle
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于GitHub处理的文本输入
- en: A checkbox that points out whether we want to import the developer from GitHub
    or enter them manually
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个复选框，指出我们是否想从GitHub导入开发者或手动输入他们
- en: A form for entering new users manually
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于手动输入新用户的表单
- en: 'The second form looks exactly the way we left it in the previous chapter. However,
    this time, its definition looks a little bit different:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个表单看起来与我们之前章节中留下的完全一样。然而，这次，其定义看起来略有不同：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that this time, we don't have the `submit` handler or the `#f="ngForm"`
    attribute. Instead, we bind the `[formGroup]` input to the `addDevForm` property,
    which is defined inside the component's controller. Using this input, we can bind
    to something called `FormGroup`. As its name states, the `FormGroup` class consists
    of a list of controls grouped together with the sets of validation rules associated
    with them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这次我们没有`submit`处理程序或`#f="ngForm"`属性。相反，我们将`[formGroup]`输入绑定到组件控制器内部的`addDevForm`属性。使用这个输入，我们可以绑定到称为`FormGroup`的东西。正如其名称所示，`FormGroup`类由一组与它们关联的验证规则组合在一起的控件列表组成。
- en: 'We need to use a similar declaration in the form used for importing a developer.
    However, this time, we will provide a different value of the `[formGroup]` property,
    as we will define a different form group in the component''s controller. Place
    the following snippet above the form we introduced earlier:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在用于导入开发者的表单中使用类似的声明。然而，这次，我们将提供不同的`[formGroup]`属性值，因为我们将在组件控制器中定义不同的表单组。将以下片段放置在我们之前引入的表单之上：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s declare the `importDevForm` and `addDevForm` properties in the
    component''s controller:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在组件控制器中声明`importDevForm`和`addDevForm`属性：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Initially, we import the `FormGroup` class from the `@angular/forms` module,
    and later, declare the required properties in the controller. Notice that we have
    one additional parameter of `constructor` of `AddDeveloper` called `fb` of the
    `FormBuilder` type.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们从`@angular/forms`模块导入`FormGroup`类，稍后，在控制器中声明所需的属性。注意，我们在`AddDeveloper`的`constructor`中有一个额外的参数，名为`fb`，其类型为`FormBuilder`。
- en: 'The `FormBuilder` type provides a programmable API for the definition of `FormGroup`
    where we can attach validation behavior to each control in the group. Let''s use
    the `FormBuilder` instance for the initialization of the `importDevForm` and `addDevForm`
    properties:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormBuilder` 类型提供了一个可编程 API，用于定义 `FormGroup`，我们可以将验证行为附加到组中的每个控件。让我们使用 `FormBuilder`
    实例初始化 `importDevForm` 和 `addDevForm` 属性：'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `FormBuilder` instance has a method called `group` that allows us to define
    controls and set their properties, such as their default values and validators.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormBuilder` 实例有一个名为 `group` 的方法，它允许我们定义控件并设置它们的属性，例如它们的默认值和验证器。'
- en: 'According to the previous snippet, `importDevForm` has two fields: `githubHandle`
    and `fetchFromGitHub`. We declare that the default value of the `githubHandle`
    control is the empty string and its value is required, and set the default value
    of the `fetchFromGitHub` control to `false`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的代码片段，`importDevForm` 有两个字段：`githubHandle` 和 `fetchFromGitHub`。我们声明 `githubHandle`
    控件的默认值为空字符串，其值是必需的，并将 `fetchFromGitHub` 控件的默认值设置为 `false`。
- en: 'In the second form, `addDevForm`, we declare four controls. For the `realName`
    control, as the default value, we set the empty string, and use `Validators.requred`
    in order to introduce validation behavior (which is exactly what we did for the
    `githubHandle` control). As a validator for the email input, we will use the `validateEmail`
    function and set the control''s initial value to the empty string. The `validateEmail`
    function is the one we defined in the previous chapter:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个表单 `addDevForm` 中，我们声明了四个控件。对于 `realName` 控件，我们将默认值设置为空字符串，并使用 `Validators.requred`
    来引入验证行为（这正是我们对 `githubHandle` 控件所做的那样）。作为电子邮件输入的验证器，我们将使用 `validateEmail` 函数，并将控件初始值设置为空字符串。`validateEmail`
    函数是我们之前章节中定义的：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The last two controls we define here are the `technology` control, which has
    a required value validator and has an empty string as its initial value, and the
    `popular` control, with its initial value set to `false`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里定义的最后两个控制是 `technology` 控制器，它有一个必需的值验证器，其初始值为空字符串，以及 `popular` 控制器，其初始值设置为
    `false`。
- en: Using composition of control validators
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用控制验证器的组合
- en: 'We took a look at how we can apply a single validator to form controls. Using
    the model-driven approach, we applied the `Validators.required` validator in a
    way equivalent to what we did in the previous chapter, where we used template-driven
    forms and added the `required` attribute. However, in some applications, the domain
    may require a more complex validation logic. For example, if we want to apply
    both the required and the `validateEmail` validators to the email control, we
    should do the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看了一下如何将单个验证器应用于表单控件。使用模型驱动方法，我们以与上一章中使用的模板驱动表单和添加 `required` 属性相同的方式应用了 `Validators.required`
    验证器。然而，在某些应用程序中，领域可能需要更复杂的验证逻辑。例如，如果我们想将 `required` 和 `validateEmail` 验证器都应用于电子邮件控件，我们应该做以下操作：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `compose` method of the `Validators` object accepts an array of validators
    as an argument and returns a new validator. The new validator's behavior will
    be a composition of the logic defined in the individual validators passed as an
    argument, and they will be applied in the same order as they were introduced in
    the array.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Validators` 对象的 `compose` 方法接受一个验证器数组作为参数，并返回一个新的验证器。新验证器的行为将是作为参数传递的各个验证器中定义的逻辑的组合，并且它们将按照在数组中引入的顺序应用。'
- en: 'The property names in the object literal passed to the `group` method, of `FormBuilder`,
    should match with the values that we set to the `formControlName` attributes of
    the inputs in the template. This is the complete template of `importDevForm`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `FormBuilder` 的 `group` 方法的对象字面量中的属性名应该与我们在模板中为输入的 `formControlName` 属性设置的值相匹配。这是
    `importDevForm` 的完整模板：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding template, we can see that, once the `submitted` flag has the
    `true` value, the form will be hidden from the user. Next to the first input element,
    we will set the value of the `formControlName` attribute to `githubHandle`. The
    `formControlName` attribute associates an existing form input in the template
    with one declared in the `FormGroup` class, corresponding to the form element
    where HTML input resides. This means that the key associated with the controls
    definition inside the object literal, which we pass to the `group` method of `FormBuilder`,
    must match with the name of the corresponding control in the template, set with
    `formControlName`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模板中，我们可以看到，一旦 `submitted` 标志具有 `true` 值，表单将隐藏给用户。在第一个输入元素旁边，我们将 `formControlName`
    属性的值设置为 `githubHandle`。`formControlName` 属性将模板中现有的表单输入与在 `FormGroup` 类中声明的输入关联起来，对应于
    HTML 输入所在的表单元素。这意味着我们传递给 `FormBuilder` 的 `group` 方法的对象字面量内部的控件定义所关联的键必须与模板中设置
    `formControlName` 的相应控件名称匹配。
- en: 'Now we want to implement the following behavior:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要实现以下行为：
- en: When the Fetch from GitHub checkbox is checked, `disable` the form for entering
    a new developer and enable the form for importing a developer from GitHub
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当“从 GitHub 获取”复选框被勾选时，禁用输入新开发者的表单，并启用从 GitHub 导入开发者的表单
- en: When the current active (or enabled) form is invalid, `disable` the `submit`
    button
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当当前活动（或启用）的表单无效时，禁用 `submit` 按钮
- en: We'll explore how we can achieve this functionality using Angular's reactive
    forms (also known as model-driven forms) API.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何使用 Angular 的响应式表单 API（也称为模型驱动表单）来实现此功能。
- en: 'Inside the `AddDeveloper` class, add the following methods definitions:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AddDeveloper` 类中，添加以下方法定义：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that in `ngOnInit`, we invoke the `toggleControls` method with the current
    value of the `fetchFromGitHub` checkbox. We can get reference to `AbstractControl`,
    which represents the checkbox, by getting the `fetchFromGitHub` property of `controls`
    within `importDevForm`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 `ngOnInit` 中，我们使用当前 `fetchFromGitHub` 复选框的值调用 `toggleControls` 方法。我们可以通过获取
    `importDevForm` 中 `controls` 的 `fetchFromGitHub` 属性来获取表示复选框的 `AbstractControl`
    的引用。
- en: After that, we subscribe to the `valueChange` event of the checkbox by passing
    a callback to its `subscribe` method. Each time the value of the checkbox is changed,
    the callback we've passed to `subscribe` will be invoked.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们通过传递一个回调给其 `subscribe` 方法来订阅复选框的 `valueChange` 事件。每次复选框的值发生变化时，我们传递给 `subscribe`
    的回调将被调用。
- en: Later, in `ngOnDestroy`, we unsubscribe from the `valueChange` subscription
    in order to prevent our code from memory leaks.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在 `ngOnDestroy` 中，我们取消订阅 `valueChange` 订阅，以防止我们的代码出现内存泄漏。
- en: Finally, the most interesting thing happens in `toggleControls`. To this method,
    we pass a flag that indicates whether we want `importDevForm` to be enabled or
    not. If we want the form to be enabled, all we need to do is to invoke the `enable`
    method of the `githubHandle` control and `disable` all the `controls` in `addDevForm`.
    We can `disable` all the `controls` in `addDevForm` by iterating over the control
    names (that is, the keys of the `controls` property of `addDevForm`), getting
    the corresponding control instance for each individual name, and invoking its
    `disable` method. In case the `importEnabled` flag has the `false` value, we do
    the exact opposite, by invoking the `enable` method of the `controls` from `addDevForm`
    and the `disable` method of the control from `importDevForm`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最有趣的事情发生在 `toggleControls` 方法中。我们将一个标志传递给此方法，该标志指示我们是否希望 `importDevForm`
    被启用。如果我们希望表单被启用，我们只需要调用 `githubHandle` 控件的 `enable` 方法，并禁用 `addDevForm` 中的所有 `controls`。我们可以通过遍历控制名称（即
    `addDevForm` 的 `controls` 属性的键）来禁用 `addDevForm` 中的所有 `controls`，获取每个单独名称的相应控件实例，并调用其
    `disable` 方法。如果 `importEnabled` 标志的值为 `false`，我们将执行完全相反的操作，通过调用 `addDevForm` 中的
    `controls` 的 `enable` 方法和 `importDevForm` 中控件的 `disable` 方法。
- en: Exploring the HTTP module of Angular
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Angular 的 HTTP 模块
- en: Now, after we have developed both forms—for importing existing developers and
    adding new developers, it is time to implement the logic behind them in the controller
    of the component.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们开发了两个表单——导入现有开发者和添加新开发者之后，是时候在组件的控制器中实现它们背后的逻辑了。
- en: 'For this purpose, we will need to communicate with the GitHub API. Although
    we can do this directly from the component''s controller, by approaching the problem
    this way, we would couple the view with the RESTful API of GitHub. In order to
    enforce better separation of concerns, we can extract the logic for communication
    with GitHub into a separate service called `GitHubGateway`. Open the file called
    `github_gateway.ts`, and enter the following content:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们需要与GitHub API进行通信。虽然我们可以直接从组件的控制器中这样做，但通过这种方式解决问题，我们会将视图与GitHub的RESTful
    API耦合起来。为了强制更好的关注点分离，我们可以将用于与GitHub通信的逻辑提取到一个单独的服务中，称为`GitHubGateway`。打开名为`github_gateway.ts`的文件，并输入以下内容：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Initially, we import the `HttpClient` class from the `@angular/common/http`
    module. All the HTTP-related functionalities are externalized outside the Angular's
    core.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们从`@angular/common/http`模块导入`HttpClient`类。所有与HTTP相关的功能都被外部化到Angular的核心之外。
- en: Right after that we declare the `GitHubUser` interface. We use it in order to
    describe the expected type of the response returned from GitHub. In this case,
    we create the interface declaration manually; however, usually, such interfaces
    are generated using an API schema (such as OpenAPI, for instance), which is shared
    between the frontend and the backend.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们声明`GitHubUser`接口。我们使用它来描述GitHub返回的预期响应类型。在这种情况下，我们手动创建接口声明；然而，通常这样的接口是通过API模式（例如OpenAPI）生成的，这些模式在前端和后端之间共享。
- en: After a dependency acceptance of `GitHubGateway`, needs to be injected through
    the DI mechanism of the framework, we will decorate the class with the `@Injectable`
    decorator.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在接受`GitHubGateway`依赖后，需要通过框架的DI机制注入，我们将使用`@Injectable`装饰器装饰类。
- en: The only functionality from the GitHub's API we use is the one for fetching
    users, so we define a single method called `getUser`. As an argument, it accepts
    the GitHub handle of the developer.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的GitHub API的唯一功能是用于获取用户的功能，因此我们定义了一个名为`getUser`的单个方法。它接受开发者的GitHub处理程序作为参数。
- en: 'Note that if you make more than 60 requests per day to the GitHub''s API, you
    might get this error: GitHub API Rate limit exceeded. This is due to the rate
    limits for requests without a GitHub API token. For further information, visit
    [https://github.com/blog/1509-personal-api-tokens](https://github.com/blog/1509-personal-api-tokens).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你每天向GitHub的API发送超过60个请求，你可能会遇到这个错误：GitHub API速率限制超出。这是由于没有GitHub API令牌的请求速率限制。有关更多信息，请访问[https://github.com/blog/1509-personal-api-tokens](https://github.com/blog/1509-personal-api-tokens)。
- en: 'Inside the `getUser` method, we use the instance of the `HttpClient` service
    that we received in `constructor`. Notice that the `get` method of the client
    has a type parameter and returns `Observable`. The purpose of the type parameter
    is to indicate what will be the type of the response, which is wrapped inside
    of `Observable`. As the expected type, we set the `GitHubUser` interface. There
    are a few benefits of using observables instead of promises for `HttpClient`;
    for instance, consider the following benefits:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getUser`方法内部，我们使用在`constructor`中接收到的`HttpClient`服务实例。请注意，客户端的`get`方法有一个类型参数，并返回`Observable`。类型参数的目的是指示响应的类型，该响应被包裹在`Observable`中。作为预期类型，我们设置了`GitHubUser`接口。使用可观察对象而不是承诺来为`HttpClient`提供一些好处；例如，考虑以下好处：
- en: Observables are cancellable by design
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察对象按设计是可取消的
- en: Observables can be easily retried
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察对象可以轻松重试
- en: We can map and filter the responses received from a given request
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以映射和过滤从给定请求接收到的响应
- en: The complete API of the `HttpClient` service can be found at [https://angular.io/api/common/http/HttpClient](https://angular.io/api/common/http/HttpClient).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient`服务的完整API可以在[https://angular.io/api/common/http/HttpClient](https://angular.io/api/common/http/HttpClient)找到。'
- en: Using Angular's HTTP module
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular的HTTP模块
- en: 'Now, let''s implement the logic for importing the existing developers from
    GitHub. First, we will need to import `HttpClientModule` in our `AppModule` class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现从GitHub导入现有开发者的逻辑。首先，我们需要在我们的`AppModule`类中导入`HttpClientModule`：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After that, open the `ch7/step-2/add_developer.ts` file and enter the following
    imports:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开`ch7/step-2/add_developer.ts`文件，并输入以下导入：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add `GitHubGateway` to the list of providers of the `AddDeveloper` component:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将`GitHubGateway`添加到`AddDeveloper`组件提供者的列表中：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As the next step, we have to include the following parameters in `constructor`
    of the class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，我们必须在类的`constructor`中包含以下参数：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This way, the `AddDeveloper` class instances will have a private property called
    `githubAPI`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`AddDeveloper`类实例将有一个名为`githubAPI`的私有属性。
- en: The only thing left is to implement the `addDeveloper` method and allow the
    user to import the existing developers using the `GitHubGateway` instance.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作就是实现`addDeveloper`方法，并允许用户使用`GitHubGateway`实例导入现有的开发者。
- en: 'Once the user clicks on the Add button, we will need to check whether we need
    to import an existing GitHub user or add a new developer. For this purpose, we
    can use the value of the `fetchFromGitHub` control:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户点击添加按钮，我们需要检查是否需要导入现有的GitHub用户或添加新的开发者。为此，我们可以使用`fetchFromGitHub`控制器的值：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If it has a truthy value, then we can invoke the `getUser` method of the `githubAPI`
    property and pass the value of the `githubHandle` control as an argument:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它有一个真值，那么我们可以调用`githubAPI`属性的`getUser`方法，并将`githubHandle`控制器的值作为参数传递：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `getUser` method of the `GitHubGateway` instance, we delegate the call
    to the `get` method of the `HttpClient` service, which returns `Observable`. In
    order to get the result that `Observable` will push, we will need to pass a callback
    to its `subscribe` method:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GitHubGateway`实例的`getUser`方法中，我们将调用委托给`HttpClient`服务的`get`方法，该方法返回`Observable`。为了获取`Observable`将要推送的结果，我们需要将其`subscribe`方法传递一个回调函数：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding snippet, we first perform an HTTP `GET` request. After this,
    we get the corresponding `Observable` instances that, in general cases, will emit
    a series of values; in this case, only a single one—the body of the response,
    parsed to JSON. If the request fails, then we will get an error.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们首先执行一个HTTP `GET`请求。之后，我们得到相应的`Observable`实例，在一般情况下，将发出一系列值；在这种情况下，只有一个——响应的主体，解析为JSON。如果请求失败，那么我们将得到一个错误。
- en: 'Note that in order to reduce the bundle size of Angular, the team at Google
    has included only the core of RxJS in the framework. In order to use the `map`
    and `catch` methods, you will need to add the following imports at `add_developer.ts`:
    `import ''rxjs/add/operator/map'';` and `import ''rxjs/add/operator/catch'';`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了减少Angular的包大小，谷歌团队只在框架中包含了RxJS的核心。为了使用`map`和`catch`方法，你需要在`add_developer.ts`中添加以下导入：`import
    'rxjs/add/operator/map';` 和 `import 'rxjs/add/operator/catch';`。
- en: 'Keep in mind that RxJS version 5.5 introduced the so called *lettable operators*,
    which allows us to import operators with named imports, compared to the preceding
    example, which uses imports with side effects. This is a big step forward type
    safety. More about lettable operators can be found here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，RxJS版本5.5引入了所谓的*可订阅操作符*，这允许我们使用命名导入导入操作符，与前面的示例相比，它使用具有副作用导入。这是一个向前的重大步骤，提高了类型安全性。更多关于可订阅操作符的信息可以在这里找到：
- en: '[https://github.com/ReactiveX/rxjs/blob/master/doc/lettable-operators.md](https://github.com/ReactiveX/rxjs/blob/master/doc/lettable-operators.md)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/ReactiveX/rxjs/blob/master/doc/lettable-operators.md](https://github.com/ReactiveX/rxjs/blob/master/doc/lettable-operators.md)'
- en: 'Now, let''s implement the body of the callback we pass to `subscribe`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现传递给`subscribe`的回调函数的主体：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding example, we set the properties of a new `Developer` instance.
    Here, we establish the mapping between the object returned from GitHub's API and
    the developer's representation in our application. We consider a developer as
    popular if they have more than `1000` followers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们设置了一个新的`Developer`实例的属性。在这里，我们建立了GitHub API返回的对象与我们在应用程序中代表开发者的映射。我们认为如果一个开发者拥有超过`1000`个关注者，那么他就是受欢迎的。
- en: The entire implementation of the `addDeveloper` method can be found at `ch8/multi-page-model-driven/add_developer.ts`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`addDeveloper`方法的整个实现可以在`ch8/multi-page-model-driven/add_developer.ts`中找到。'
- en: 'In order to handle failed requests, we can use the catch method of the Observable
    instances: `this.githubAPI.getUser(model.githubHandle)`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理失败的请求，我们可以使用Observable实例的`catch`方法：`this.githubAPI.getUser(model.githubHandle)`
- en: '`.catch((error, source, caught) => {`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`.catch((error, source, caught) => {`'
- en: '`console.log(error);`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log(error);`'
- en: '`return error;`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`return error;`'
- en: '`});`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`});`'
- en: Defining parameterized views
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义参数化视图
- en: 'As the next step, once the user clicks on the name of any of the developers
    on the home page of the application, they should be redirected to a view with
    a detailed profile of the selected developer. The end result will look as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，一旦用户点击了应用程序主页上任何开发者的名字，他们应该被重定向到一个包含所选开发者详细资料的视图。最终结果将如下所示：
- en: '![](img/b1564a7f-12c4-4447-abaa-74ba5697e9e0.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b1564a7f-12c4-4447-abaa-74ba5697e9e0.png)'
- en: Figure 2
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图2
- en: 'In order to do this, we will need to pass an identifier of the developer to
    the component that shows the developer''s detailed profile. Open `app.ts`, and
    add the following import:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要将开发者的标识符传递给显示开发者详细资料的组件。打开`app.ts`，并添加以下导入：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We haven''t developed the `DeveloperDetails` component yet, so, if you run
    the application, you will get an error. We will define the component in the next
    paragraph, but before this, let''s alter the routes definition of `app.ts`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未开发`DeveloperDetails`组件，因此，如果您运行应用程序，您将得到一个错误。我们将在下一段定义该组件，但在那之前，让我们修改`app.ts`的路线定义：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we add a single route with the `dev-details/:id` path and associate the
    `DeveloperDetails` component with it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加一个具有`dev-details/:id`路径的单个路由，并将其与`DeveloperDetails`组件关联。
- en: Note that in the `path` property, we declare that the route has a single parameter
    called `id` and also set the `children` property to `devDetailsRoutes`. The `devDetailsRoutes`
    children contains the nested routes, which should be rendered within `router-outlet`
    located in the `DeveloperDetails` component.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`path`属性中，我们声明该路由有一个名为`id`的单个参数，并将`children`属性设置为`devDetailsRoutes`。`devDetailsRoutes`子路由应位于`DeveloperDetails`组件中的`router-outlet`内。
- en: 'Now, let''s pass `id` of the current developer as a parameter to the `routerLink`
    directive. Open `home.html` in your working directory and replace the table cell,
    where we display the developer''s `realName` property with the following content:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将当前开发者的`id`作为参数传递给`routerLink`指令。打开您的工作目录中的`home.html`，并将显示开发者`realName`属性的表格单元格替换为以下内容：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The value of the `routerLink` directive is an array with the following three
    elements:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`routerLink`指令的值是一个包含以下三个元素的数组：'
- en: '`''/dev-details''`: A string that shows the root route'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''/dev-details''`：显示根路由的字符串'
- en: '`dev.id`: The ID of the developer whose details we want to see'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev.id`：我们想要查看详细信息的开发者的ID'
- en: '`''dev-basic-info''`: The path of a route that shows which component within
    the nested route should be rendered'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''dev-basic-info''`：显示嵌套路由中应渲染哪个组件的路由路径'
- en: Defining nested routes
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义嵌套路由
- en: 'Now, let''s jump to the `DeveloperDetails` definition. In your working directory,
    create a file called `developer_details.ts` and enter the following content:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到`DeveloperDetails`的定义。在您的工作目录中，创建一个名为`developer_details.ts`的文件，并输入以下内容：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For the sake of simplicity, in order to not introduce a complex directory/file
    structure in the examples for this book, we have a few components and route declarations
    in a single file. Keep in mind that according to best practices, the individual
    declarations should be placed into separate files. For further information, visit
    [https://angular.io/styleguide](https://angular.io/styleguide).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，为了避免在本书的示例中引入复杂的目录/文件结构，我们在单个文件中包含了一些组件和路线声明。请记住，根据最佳实践，单个声明应放置在单独的文件中。有关更多信息，请访问[https://angular.io/styleguide](https://angular.io/styleguide)。
- en: In the previous snippet, we define a component with controller called `DeveloperDetails`.
    Note that within the controller's `constructor` function, through the DI mechanism
    of Angular, we inject a parameter associated with the `ActivatedRoute` token.
    The injected parameter provides us with access to the parameters visible by the
    current route. In `ngOnInit`, we apply an imperative approach, where we subscribe
    changes in the value of the route's `params` property, get the first set of parameters,
    and assign the `dev` property to the result of the invocation of `this.developers.getUserById`
    with the selected developer's identifier as an argument.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们定义了一个名为`DeveloperDetails`的组件，并在控制器中调用。注意，在控制器的`constructor`函数中，通过Angular的依赖注入机制，我们注入了一个与`ActivatedRoute`令牌关联的参数。注入的参数为我们提供了访问当前路由可见参数的能力。在`ngOnInit`中，我们采用命令式方法，订阅`params`属性值的变化，获取第一组参数，并将`dev`属性赋值为调用`this.developers.getUserById`的结果，其中所选开发者的标识符作为参数。
- en: 'Note that a more declarative and reactive approach would be to take advantage
    of the higher-order functions provided by RxJS, where we''d be able to get access
    to the selected developer using code similar to the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，利用RxJS提供的更高阶函数采取更声明性和响应式的方法会更好，我们可以通过类似以下代码的方式获取所选开发者：
- en: '`...`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`...`'
- en: '`get dev$() {`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`get dev$() {`'
- en: '`return this.route.params.map((params: any) =>`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`return this.route.params.map((params: any) =>`'
- en: '`this.developers.getUserById(parseInt(params[''id''])));`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`this.developers.getUserById(parseInt(params[''id'']));`'
- en: '`}`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`...`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`...`'
- en: Later, we can bind to the result of the invocation with the Angular's async
    pipe, that we will explain later in this chapter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以使用Angular的异步管道绑定到调用结果，我们将在本章后面解释该管道。
- en: Since the parameter we got from `routeParams.params['id']` is a string, we will
    need to parse it to a number in order to get the developer associated with the
    given route.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们从`routeParams.params['id']`获取的参数是一个字符串，我们需要将其解析为数字，以便获取与给定路由关联的开发者。
- en: 'Now, let''s define the child routes, which will be rendered in the template
    of `DeveloperDetails`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义子路由，这些路由将在`DeveloperDetails`的模板中渲染：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There is nothing new for us in the preceding declarations. The route definition
    follows the exact same rules we're already familiar with.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的声明中，对我们来说没有什么新的。路由定义遵循我们已熟悉的完全相同的规则。
- en: 'Now, to the template of the component, let''s add links associated with the
    individual nested routes:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为组件的模板添加与单个嵌套路由关联的链接：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Within the template, we declare two links that are relative to the current path.
    The first one points to `dev-basic-info`, which is the path of the first route
    defined within `devDetailsRoutes`, and the second one points to `dev-details-advanced`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，我们声明了两个相对于当前路径的链接。第一个链接指向`dev-basic-info`，这是在`devDetailsRoutes`中定义的第一个路由的路径，第二个链接指向`dev-details-advanced`。
- en: 'Since the implementations of the components associated with both routes are
    quite similar, let''s take a look only at `DeveloperBasicInfo`. The implementation
    of the second one can be found at `ch8/multi-page-model-driven/developer_advanced_info.ts`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与两个路由关联的组件的实现相当相似，让我们只看看`DeveloperBasicInfo`的实现。第二个组件的实现可以在`ch8/multi-page-model-driven/developer_advanced_info.ts`中找到：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding snippet, we inject the parent component using the `@Inject`
    parameter decorator. Inside `@Inject`, we use `forwardRef`, since we have a circular
    dependency between the `developer_basic_info` and `developer_details` packages
    (inside `developer_basic_info`, we import `developer_details`, and within `developer_details`,
    we import `developer_basic_info`).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用`@Inject`参数装饰器注入父组件。在`@Inject`内部，我们使用`forwardRef`，因为我们有`developer_basic_info`和`developer_details`包之间的循环依赖（在`developer_basic_info`中，我们导入`developer_details`，在`developer_details`中，我们导入`developer_basic_info`）。
- en: We need a reference to the instance of the parent component in order to get
    the instance of the current developer that corresponds to the selected route.
    We get this reference in the `ngOnInit` life cycle hook.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个对父组件实例的引用，以便获取与所选路由对应的当前开发者的实例。我们在`ngOnInit`生命周期钩子中获取这个引用。
- en: Transforming data with pipes
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管道转换数据
- en: Now it is time to take a look at the last building block that Angular provides
    for the development of applications that we haven't covered in detail yet—pipes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看Angular为我们开发应用程序提供的最后一个构建块——管道了，我们还没有详细讨论过。
- en: 'Just like filters in AngularJS, pipes are intended to encapsulate all the data
    transformation logic. Let''s take a look at the template of the home page of the
    application we have just developed:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 就像AngularJS中的过滤器一样，管道旨在封装所有的数据转换逻辑。让我们看看我们刚刚开发的应用程序的主页模板：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding snippet, depending on the value of the `popular` property,
    we show different data using the `NgSwitch` and `NgSwitchCase` directives. Although
    this works, it is redundant.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，根据`popular`属性的值，我们使用`NgSwitch`和`NgSwitchCase`指令显示不同的数据。虽然这可行，但它是多余的。
- en: Developing stateless pipes
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发无状态管道
- en: 'Let''s develop a pipe that transforms the value of the `popular` property and
    uses it in place of `NgSwitch` and `NgSwitchCase`. The pipe will accept three
    arguments: a value that should be transformed, a string that should be displayed
    when the value is truthy, and another string that should be displayed in case
    of a falsy value.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开发一个管道，它将`popular`属性的值进行转换，并用它来代替`NgSwitch`和`NgSwitchCase`。该管道将接受三个参数：一个需要转换的值，一个当值为真时应该显示的字符串，以及一个在值为假时应该显示的另一个字符串。
- en: 'With the use of an Angular custom pipe, we will be able to simplify the template
    to the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Angular自定义管道，我们可以将模板简化为以下形式：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can even use emojis, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用表情符号，如下所示：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We apply pipe to the value the same way we would do in AngularJS. The arguments
    we pass to the pipe should be separated by the colon (`:`) symbol.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将管道应用于值的方式与在AngularJS中做的一样。传递给管道的参数应该由冒号（`:`）符号分隔。
- en: 'In order to develop an Angular pipe, we will need the following imports:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发Angular管道，我们需要以下导入：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `Pipe` decorator can be used for adding metadata to the class that implements
    the data transformation logic. The `PipeTransform` interface is an interface with
    a single method, called `transform`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pipe` 装饰器可以用于向实现数据转换逻辑的类添加元数据。`PipeTransform` 接口是一个只有一个方法的接口，称为 `transform`：'
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding snippet is the entire implementation of `BooleanPipe`. The `name`
    type that we pass to the `@Pipe` decorator determines how we should reference
    it in templates.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段是 `BooleanPipe` 的完整实现。我们传递给 `@Pipe` 装饰器的 `name` 类型决定了我们在模板中如何引用它。
- en: 'The last thing we need to do before being able to use `BooleanPipe` is to add
    it to the list of declarations in our `AppModule` class:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在能够使用 `BooleanPipe` 之前，我们需要做的最后一件事是将它添加到我们的 `AppModule` 类的声明列表中：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using Angular's built-in pipes
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Angular 的内置管道
- en: 'Angular provides the following set of built-in pipes:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 提供以下内置管道集：
- en: '`CurrencyPipe`: This pipe is used for formatting currency data. As an argument,
    it accepts the abbreviation of the currency type (that is, `"EUR"`, `"USD"`, and
    so on). It can be used in the following way:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CurrencyPipe`：这个管道用于格式化货币数据。作为参数，它接受货币类型的缩写（即 `"EUR"`、`"USD"` 等）。它可以按以下方式使用：'
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`DatePipe`: This pipe is used for the transformation of dates. It can be used
    in the following way:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DatePipe`：这个管道用于日期的转换。它可以按以下方式使用：'
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`DecimalPipe`: This pipe is used for transformation of decimal numbers. The
    argument it accepts is of the following format: `"{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}"`.
    It can be used in the following way:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DecimalPipe`：这个管道用于十进制数字的转换。它接受的参数格式如下：`"{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}"`。它可以按以下方式使用：'
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`JsonPipe`: This transforms a JavaScript object into a JSON string. It can
    be used in the following way:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JsonPipe`：这个管道将 JavaScript 对象转换为 JSON 字符串。它可以按以下方式使用：'
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`LowerCasePipe`: This transforms a string to lowercase. It can be used in the
    following way:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LowerCasePipe`：这个管道将字符串转换为小写。它可以按以下方式使用：'
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`UpperCasePipe`: This transforms a string to uppercase. It can be used in the
    following way:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpperCasePipe`：这个管道将字符串转换为大写。它可以按以下方式使用：'
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`PercentPipe`: This transforms a number into a percentage. It can be used in
    the following way:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PercentPipe`：这个管道将数字转换为百分比。它可以按以下方式使用：'
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`SlicePipe`: This returns a slice of an array. The pipe accepts the start and
    the end indexes of the slice. It can be used in the following way:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SlicePipe`：这个管道返回数组的切片。管道接受切片的起始和结束索引。它可以按以下方式使用：'
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`AsyncPipe`: This is a stateful pipe that accepts an `Observable` object or
    a promise; we will take a look at it at the end of the chapter.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncPipe`：这是一个具有状态的管道，它接受一个 `Observable` 对象或一个承诺；我们将在本章末尾探讨它。'
- en: Developing stateful pipes
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发具有状态的管道
- en: There is one common thing among all the pipes mentioned earlier—all of them
    return exactly the same result each time we apply them to the same value and pass
    them the same set of arguments. Such pipes, which hold the referentially transparency
    property, are called **pure pipes**.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 所提到的所有管道中有一个共同点——每次我们将它们应用于相同的值并传递相同的参数集时，它们都返回完全相同的结果。这样的管道，具有引用透明性属性，被称为 **纯管道**。
- en: 'The `@Pipe` decorator accepts an object literal of the `{ name: string, pure?:
    boolean }` type, where the default value for the `pure` property is `true`. This
    means that when we define any given pipe, we can declare whether it is stateful
    or stateless. The pure property is important because, in case the pipe doesn''t
    produce side effects and returns the same result when applied to the same set
    of arguments, the change detection can be optimized.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Pipe` 装饰器接受一个 `{ name: string, pure?: boolean }` 类型的对象字面量，其中 `pure` 属性的默认值是
    `true`。这意味着当我们定义任何给定的管道时，我们可以声明它是具有状态的还是无状态的。纯属性很重要，因为如果管道不产生副作用并且在应用相同的参数集时返回相同的结果，则可以优化变更检测。'
- en: Now, let's build a stateful pipe. Our pipe will make an HTTP `get` request to
    a JSON API. For this purpose, we will use the `@angular/common/http` module.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建一个具有状态的管道。我们的管道将向一个 JSON API 发送 HTTP `get` 请求。为此，我们将使用 `@angular/common/http`
    模块。
- en: Note that having business logic in a pipe is not considered as best practice.
    This type of logic should be extracted into a service. The example here is for
    learning purposes only.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在管道中包含业务逻辑不被认为是最佳实践。这种类型的逻辑应该提取到服务中。这里的例子仅用于学习目的。
- en: 'In this case, the pipe needs to hold a state depending on the status of the
    request (that is, whether it is pending or completed). We will use the pipe in
    the following way:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，管道需要根据请求的状态（即它是否挂起或完成）保持一个状态。我们将以下这种方式使用管道：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This way, we apply the `fetchJson` pipe over the URL. Once we have the body
    of the response, we can apply the `json` pipe over it. This example also shows
    how we can chain pipes with Angular.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们在URL上应用了`fetchJson`管道。一旦我们有了响应体，我们就可以在它上面应用`json`管道。这个例子还展示了我们如何使用Angular链式管道。
- en: 'Similar to stateless pipes, for the development of stateful pipes, we have
    to decorate the class that implements the pipe''s logic with `@Pipe` and implement
    the `PipeTransform` interface. This time, because of the HTTP request functionality,
    we will also need to import the `HttpClient` class from the `@angular/common/http`
    module:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 与无状态管道类似，对于有状态管道的开发，我们必须用`@Pipe`装饰实现管道逻辑的类，并实现`PipeTransform`接口。这次，由于HTTP请求功能，我们还需要从`@angular/common/http`模块导入`HttpClient`类：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Each time it happens to apply the `fetchJson` pipe to an argument with a different
    value, we will need to make a new HTTP `get` request. This means that as the state
    of the pipe, we need to keep at least the values of the response of the remote
    service and the last URL:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 每次将`fetchJson`管道应用于具有不同值的参数时，我们都需要发起一个新的HTTP`get`请求。这意味着作为管道的状态，我们需要至少保留远程服务的响应值和最后一个URL的值：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The only piece of logic we need to implement is the `transform` method:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的唯一逻辑是`transform`方法：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Inside of it, we initially compare the URL passed as an argument with the one
    we already have (by default, its value will be `null`). If they are different,
    we initiate a new HTTP `get` request using the local instance of the `HttpClient`
    class, which was passed to the `constructor` function. Once the request is completed,
    we set the `data` property to the result.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，我们最初比较作为参数传递的URL与我们已有的一个（默认情况下，其值将为`null`）。如果它们不同，我们将使用传递给`constructor`函数的本地`HttpClient`类的实例发起一个新的HTTP`get`请求。一旦请求完成，我们将`data`属性设置为结果。
- en: Now, let's suppose that the pipe has started a `get` request, and before it
    is completed, the change detection mechanism invokes the pipe again. In this case,
    we will compare the `prevUrl` property with the `url` parameter. If they are the
    same, we won't perform a new request and will immediately return the value of
    the `data` property. If `prevUrl` has a different value from `url`, we will initiate
    a new request.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设管道已经开始了一个`get`请求，并且在它完成之前，变更检测机制再次调用了管道。在这种情况下，我们将比较`prevUrl`属性和`url`参数。如果它们相同，我们不会执行新的请求，并将立即返回`data`属性的值。如果`prevUrl`的值与`url`不同，我们将发起一个新的请求。
- en: Using stateful pipes
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用有状态管道
- en: 'Now, let''s use the pipe that we developed. The application that we will implement
    provides a text input and a button with the Get Avatar label to the user. Once
    the user enters a value in the text input and clicks on the button, the avatar
    corresponding to the GitHub user will appear below the text input, as shown in
    the following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们开发的管道。我们将实现的程序提供了一个文本输入和一个带有“获取头像”标签的按钮。一旦用户在文本输入中输入值并点击按钮，GitHub用户的头像将出现在文本输入下方，如下面的截图所示：
- en: '![](img/83f87144-99c0-40e7-af79-e1cec060e9a0.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/83f87144-99c0-40e7-af79-e1cec060e9a0.png)'
- en: Figure 3
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图3
- en: 'Now, let''s develop a sample component, which will allow us to enter the GitHub
    user''s handle:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开发一个示例组件，它将允许我们输入GitHub用户的handle：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The only thing left is to show the GitHub avatar of the user. We can easily
    achieve this by altering the template of the component with the following `img`
    declaration:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一事情就是显示用户的GitHub头像。我们可以通过以下`img`声明轻松地通过更改组件的模板来实现这一点：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Initially, we append the GitHub handle to the base URL used for fetching users
    from the API. Later, we will apply the `fetchJson` filter over it and get the
    `avatar_url` property from the returned result.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们将GitHub handle附加到用于从API获取用户的基URL。稍后，我们将对它应用`fetchJson`过滤器，并从返回的结果中获取`avatar_url`属性。
- en: Using Angular's AsyncPipe
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular的AsyncPipe
- en: 'Angular''s `AsyncPipe` `transform` method accepts an `Observable` object or
    a promise as an argument. Once the argument pushes a value (that is, the promise
    has been resolved or the `subscribe` callback of `Observable` is invoked), `AsyncPipe`
    will return it as a result. Let''s take a look at the following example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的 `AsyncPipe` `transform` 方法接受一个 `Observable` 对象或一个 promise 作为参数。一旦参数推送一个值（即，promise
    已解决或 `Observable` 的 `subscribe` 回调被调用），`AsyncPipe` 将将其作为结果返回。让我们看看以下示例：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we define an Angular component that has two properties, that is, `greetingPromise`
    of the `Promise<string>` type and `resolve` of the `Function` type. We initialized
    the `greetingPromise` property with a new `Promise<string>` instance, and as the
    value of the `resolve` property, we set the `resolve` callback of `promise`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个具有两个属性的 Angular 组件，即 `Promise<string>` 类型的 `greetingPromise` 和 `Function`
    类型的 `resolve`。我们使用一个新的 `Promise<string>` 实例初始化了 `greetingPromise` 属性，并将 `resolve`
    属性的值设置为 `promise` 的 `resolve` 回调函数。
- en: In `constructor` of the class, we start a time-out with the duration of `3000`
    ms, and inside of its callback, we resolve the promise. Once the promise is resolved,
    the value of the `{{ greetingPromise | async }}` expression will be evaluated
    to the `Foobar!` string. The end result that the user will see on the screen is
    the text, "Hello Foobar!".
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的 `constructor` 中，我们开始一个持续 `3000` 毫秒的定时器，并在其回调函数中解决 promise。一旦 promise 被解决，`{{
    greetingPromise | async }}` 表达式的值将被评估为 `Foobar!` 字符串。用户最终在屏幕上看到的文本是“Hello Foobar!”。
- en: The `async` pipe is extremely powerful when we combine it with `Observable`,
    which pushes a sequence of values. It automatically unsubscribes from `Observable`
    when the view it used gets destroyed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 `async` 管道与推送一系列值的 `Observable` 结合使用时，`async` 管道非常强大。当它所使用的视图被销毁时，它会自动取消订阅
    `Observable`。
- en: Using AsyncPipe with observables
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AsyncPipe 与 observables
- en: 'We''re already familiar with the concept of observables from the previous chapters.
    We can say that an `Observable` object allows us to subscribe to the emission
    of a sequence of values, for instance:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从前面的章节中熟悉了可观察对象的概念。我们可以这样说，一个 `Observable` 对象允许我们订阅一系列值的发射，例如：
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Once we subscribe to `Observable`, it will start emitting values each second,
    which will be printed in the console. Let''s combine this snippet with component
    definition and implement a simple timer:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们订阅了 `Observable`，它将每秒发射一个值，这些值将在控制台中打印出来。让我们将这个片段与组件定义结合起来，实现一个简单的计时器：
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The only thing left in order to be able to use the `timer` component is to
    add a template declaration. We can subscribe to `Observable` directly in the template
    using the `async` pipe:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用 `timer` 组件，我们只需添加一个模板声明。我们可以在模板中使用 `async` 管道直接订阅 `Observable`：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This way, each second we will get the new value emitted by `Observable`, and
    the `date` pipe will transform it into a readable form.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们每秒都会接收到 `Observable` 推出的新值，`date` 管道将其转换为可读形式。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a deep dive into the Angular's forms module, by developing
    a model-driven (reactive) form, combining it with the HTTP module. We took a look
    at some advanced features of the new component-based router and saw how we can
    use and develop custom stateful and stateless pipes.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过开发一个基于模型的（响应式）表单，结合 HTTP 模块，深入研究了 Angular 的表单模块。我们查看了一些新组件路由的高级功能，并了解了如何使用和开发自定义的有状态和无状态管道。
- en: The next chapter is dedicated to how we can make our Angular applications SEO-friendly
    by taking advantage of the server-side rendering that the module Universal provides.
    Another thing that we'll take a look at is Angular CLI and other tools that make
    our experience as developers better. Finally, we'll explain what ahead-of-time
    compilation is, in the context of Angular, and why we should take advantage of
    it in our applications.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将专门介绍如何利用模块 Universal 提供的服务端渲染功能，使我们的 Angular 应用程序更易于搜索引擎优化（SEO）。我们还将探讨 Angular
    CLI 和其他使开发者体验更好的工具。最后，我们将解释在 Angular 的背景下，什么是预编译（ahead-of-time compilation），以及为什么我们应该在我们的应用程序中利用它。
