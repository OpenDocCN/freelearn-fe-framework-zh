<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Protractor, a Step Ahead"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Protractor, a Step Ahead</h1></div></div></div><p>End-to-end testing is real fun as long as it interacts directly with the browser, but a good developer should know the advanced features of Protractor to perform large-scale application testing. Besides that, debugging is kind of a challenge in e2e testing as it depends on the DOM element of the browser.</p><p>Protractor has some APIs for debugging. This chapter will mostly cover those APIs and features, including the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up and configuring Protractor </li><li class="listitem" style="list-style-type: disc">Some advanced Protractor APIs such as browser, locator, and action</li><li class="listitem" style="list-style-type: disc">Debugging Protractor with the <code class="literal">browser.pause()</code> and <code class="literal">browser.debug()</code> APIs</li></ul></div><div class="section" title="Advanced setup and configuration"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Advanced setup and configuration</h1></div></div></div><p>In the previous chapter, we saw a basic and commonly used setup and configuration for Protractor. Here, we will take a look at some advanced configurations that make installation simpler and more powerful.
</p><div class="section" title="Installing Protractor globally"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec67"/>Installing Protractor globally</h2></div></div></div><p>Here are the steps to install Protractor globally:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Once Node.js has been installed and is available in command prompt, type the following command to install Protractor globally on the system:<pre class="programlisting">
<span class="strong"><strong>$ npm install -g protractor</strong></span>
</pre><p>The preceding command uses Node's <code class="literal">npm</code> command to install Protractor globally so that we can use Protractor just with the <code class="literal">protractor</code> command.</p></li><li class="listitem">Test whether the Protractor version can be determined as follows:<pre class="programlisting">
<span class="strong"><strong>$ protractor --version</strong></span>
</pre></li></ol></div></div><div class="section" title="Advanced configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec68"/>Advanced configuration</h2></div></div></div><p>In this section, we will be configuring Protractor a bit more using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Update the protractor <code class="literal">config</code> file to support multiple browsers in a single test suite. The <code class="literal">multiCapabilities</code> parameter is an array that takes multiple <code class="literal">browserName</code> objects for any test suite, as shown here:<pre class="programlisting">        exports.config = {  &#13;
          //...  &#13;
        multiCapabilities: [{&#13;
         'browserName': 'firefox' &#13;
        }, { &#13;
         'browserName': 'chrome' &#13;
        }]&#13;
        //... };</pre></li><li class="listitem">We can set advanced settings for browsers in the <code class="literal">capabilities</code> parameter; for example, for <code class="literal">chrome</code>, we can pass extra parameters as <code class="literal">chromeOptions</code>, as follows:<pre class="programlisting">        exports.config = {  &#13;
          //...  &#13;
          capabilities: { &#13;
            'browserName': 'chrome'&#13;
            'chromeOptions': {&#13;
              'args': ['show-fps-counter=true']&#13;
            }}]&#13;
        //... };</pre></li><li class="listitem">Sometimes, we may need to run Protractor directly without Selenium or WebDriver. This is possible by passing a parameter in the <code class="literal">config.js</code> file. The parameter is <code class="literal">directConnect: true</code> in the configuration object, as shown here: <pre class="programlisting">        exports.config = { &#13;
          //... &#13;
          directConnect: true, &#13;
          //... &#13;
        }; &#13;
</pre></li></ol></div><p>Great! We have configured Protractor a step ahead.</p></div></div></div>
<div class="section" title="Protractor APIs"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Protractor APIs</h1></div></div></div><p>The main activities of an e2e test for any web page are to get the DOM elements of that page, interact with them, assign an action to them, and share information with them; then, the user can get the current state of the website. To enable us to perform all these actions, Protractor provides a wide array of APIs (some are from the web driver). In this chapter, we will look at some commonly used APIs.</p><p>In the previous chapter, we saw how Protractor works with an Angular project, where we had to interact with UI elements. For that, we used a few Protractor APIs, such as <code class="literal">element.all</code>, <code class="literal">by.css</code>, <code class="literal">first</code>, <code class="literal">last</code>, and <code class="literal">getText</code>. However, we didn't see or understand the workings of these APIs in depth. To understand the workings of APIs in Protractor is very simple, but in real life we will mostly have to work with bigger, complex projects. Hence, it's important that we understand and know more about these APIs in order to interact with the UI and play with its events.</p><div class="section" title="Browser"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec69"/>Browser</h2></div></div></div><p>Protractor works with Selenium WebDriver, which is a browser automation framework. We can use a method from the Selenium WebDriver API to interact with the browser from the test spec. We will take a look at a few of them in the following sections.</p><p>To navigate the browser to a specific web address and load the mock modules for that page before the Angular load, we will use the <code class="literal">.get()</code> method by passing the specific address or relative path:</p><pre class="programlisting">browser.get(url); &#13;
browser.get('http://localhost:3000'); // This will navigate to&#13;
the localhost:3000 and will load mock module if needed &#13;
</pre><p>To get the current page's web URL, use the <code class="literal">CurrentUrl()</code> method, as shown here:</p><pre class="programlisting">browser.getCurrentUrl(); // will return http://localhost:3000 &#13;
</pre><p>To navigate to another page and browse it using in-page navigation, <code class="literal">setLocation</code> is used, as follows:</p><pre class="programlisting">browser.setLocation('new-page'); // will change the url and navigate to the new url, as our current url was http://localhost:3000, now it will change and navigate to http://locahost:3000/#/new-page &#13;
</pre><p>To get the title of the current page (basically, the title that is set in the HTML page), the <code class="literal">getTitle</code> method is used, as shown here:</p><pre class="programlisting">browser.getTitle(); // will return the page title of our page, for us it will return us "Angular Protractor Debug" &#13;
</pre><p>To reload the current page with the mocks module before the Angular load, the <code class="literal">refresh()</code> method is used, as follows:</p><pre class="programlisting">browser.refresh(); // this will reload the full page and definitely will load the mocks module as well. &#13;
</pre><p>To pause the test process, the <code class="literal">pause()</code> method is used. This is useful for debugging the test process, and we will use this test debugging section:</p><pre class="programlisting">browser.pause(); &#13;
</pre><p>To debug the test process, the <code class="literal">debugger()</code> method is used. This method is different and can be considered an advanced level of the <code class="literal">pause()</code> method. This is useful for advanced debugging of the test process, along with injecting custom helper function into the browser. We will use this test debugging section as well:</p><pre class="programlisting">browser.debugger(); &#13;
</pre><p>To close the current browser, <code class="literal">close()</code> is used. This is useful for complex multimodule testing, when we sometimes need to close the current browser before opening a new one:</p><pre class="programlisting">browser.close(); &#13;
</pre><p>To support Angular in Protractor, we have to set the <code class="literal">useAllAngularAppRoots</code> params to <code class="literal">true</code>. The logic behind doing this is that, when we set this parameter to <code class="literal">true</code>, it will search for all Angular apps in the page while the element finder traverses through the page:</p><pre class="programlisting">browser.useAllAngular2AppRoots; &#13;
</pre></div><div class="section" title="Elements"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec70"/>Elements</h2></div></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>Protractor itself exposes some global functions, and <code class="literal">element</code> is one of them. This function takes a locator (a kind of selector--we will discuss it in the next step) and returns an <code class="literal">ElementFinder</code>. This function basically finds a single element based on the locator, but it supports multiple element singing along with chaining another method as <code class="literal">element.all</code>, which also takes a locator and returns an <code class="literal">ElementFinderArray</code>. Both of them support chaining methods for the next action.</p></div></div><div class="section" title="element.all"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec19"/>element.all</h3></div></div></div><p>As we already know, <code class="literal">element.all</code> returns an <code class="literal">ElementArrayFinder</code> that supports chaining methods for the next action. We will look at a few of them and how they actually work:</p><p>To select multiple elements as an array with a specific locator, we should use <code class="literal">element.all</code>, as follows:</p><pre class="programlisting">element.all(Locator); &#13;
var elementArr = element.all(by.css('.selector'));  // return the ElementFinderArray &#13;
</pre><p>After getting a bunch of elements as an array, we may need to select a specific element. In that case, we should be chaining <code class="literal">get(position)</code> by passing the specific array index as the position number:</p><pre class="programlisting">element.all(Locator).get(position); &#13;
elementArr.get(0); // will return first element from the ElementFinderArray  &#13;
</pre><p>After getting a bunch of elements as an array, we might need to select child elements again with a preferred locator, and for that we can chain the <code class="literal">.all(locator)</code> method again with the existing elements, as shown here:</p><pre class="programlisting">element.all(Locator).all(Locator); &#13;
elementArr.all(by.css('.childSelector')); // will return another ElementFinderArray as child elements based on child locator  &#13;
</pre><p>After getting the desired elements, we might want to check whether the number of elements selected is as expected. There is a method, <code class="literal">count()</code>, that is used to chain to get the total number of selected elements:</p><pre class="programlisting">element.all(Locator).count(); &#13;
elementArr.count(); // will return the total number in the select element's array   &#13;
</pre><p>Similar to the <code class="literal">get(position)</code> method, we can get the first element from the array by chaining the <code class="literal">first()</code> method:</p><pre class="programlisting">element.all(Locator).first(); &#13;
elementArr.first(); // will return the first element from the element's array   &#13;
</pre><p>Similar to the <code class="literal">first()</code>method, we can get the last element from the array by chaining the <code class="literal">last()</code> method:</p><pre class="programlisting">element.all(Locator).last(); &#13;
elementArr.last(); // will return the last element from the element array   &#13;
</pre><p>As long as we have a bunch of elements as an array, we may need to traverse though the elements to take any action. In that case, we may need to go through a loop by chaining the <code class="literal">each()</code> method:</p><pre class="programlisting">element.all(Locator).each(Function) { }; &#13;
elementArr.each( function (element, index) { &#13;
    // ......  &#13;
}); // ... will loop through out the array elements &#13;
</pre><p>Just like the <code class="literal">each()</code> method, there is another method, <code class="literal">filter()</code>, to chain with the element array to traverse through the items and assign a filter to them:</p><pre class="programlisting">element.all(Locator).filter(Function) { }; &#13;
elementArr.filter( function (element, index) { &#13;
    // ......  &#13;
}); //... will apply filter function's action to all elements  &#13;
</pre></div><div class="section" title="element"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec20"/>element</h3></div></div></div><p>The <code class="literal">element</code> class returns <code class="literal">ElementFinder</code>, which means a single element in the element array, and this also supports chaining methods for the next action. In the previous examples, we saw how to obtain a single selected element from the element array so that all of the chaining methods work on that single element as well. There are a lot of chaining methods for working on a single element, and we will look at a few that are most commonly used.</p><p>By passing a specific locator as an argument to the <code class="literal">element</code> method, we can select a single DOM element, as shown here:</p><pre class="programlisting">element(Locator); &#13;
var elementObj = element(by.css('.selector'));  // return the ElementFinder based on locator  &#13;
</pre><p>After getting a specific single element, we may need to find the child element of the element on which we have to chain the <code class="literal">element.all</code> method with the rerun <code class="literal">elementFinder</code> object. For this, pass a specific locator to find the child <code class="literal">elementFinderArray</code>, as follows:</p><pre class="programlisting">element(Locator).element.all(Locator); &#13;
elementObj.element.all(by.css('.childSelector')); // will return another ElementFinderArray as child elements based on child locator  &#13;
</pre><p>After selecting a specific element, we might need to check whether that element is present while chaining the <code class="literal">isPresent()</code> method, as follows:</p><pre class="programlisting">element(Locator).isPresent(); &#13;
elementObj.isPresent(); // will return boolean if the selected element is exist or not.   &#13;
</pre></div></div><div class="section" title="Actions"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec71"/>Actions</h2></div></div></div><p>Actions mainly change the method that affects or triggers the selected DOM element. The goal of selecting a DOM element is to interact with it by triggerring some actions so that it can act like a real user. There are some commonly used actions for specific interaction. We will look at a few of them here.</p><p>To get the inner text or contained text of any element, we have to chain the <code class="literal">getText()</code>method with the <code class="literal">elementFinder</code> object after selecting the specific element, as follows:</p><pre class="programlisting">element(Locator).getText(); &#13;
var elementObj = element(by.css('.selector'));  // return the ElementFinder based on locator  &#13;
elementObj.getText(); // will return the contained text of that specific selected element  &#13;
</pre><p>To get the inner HTML of any element, we have to chain the <code class="literal">getInnerHtml()</code>method with the <code class="literal">elementFinder</code> object after selecting the specific element, as shown here:</p><pre class="programlisting">element.(Locator).getInnerHtml(); &#13;
elementObj.getInnerHtml(); // will return the inner html of the selected element.  &#13;
</pre><p>We can find any specific attribute value of any element by passing the attribute key to the <code class="literal">getAttribute()</code> method, which will chain with the selected <code class="literal">elementFinder</code> object, as follows:</p><pre class="programlisting">element(Locator).getAttribute('attribute'); &#13;
elementObj.getAttribute('data'); // will return the value of data attribute of that selected element if that have that attribute &#13;
</pre><p>In most cases, we need to clear the value of the input field. For that, we can chain the <code class="literal">clear()</code>method with the selected <code class="literal">elementFinder</code> object, as shown:</p><pre class="programlisting">element.(Locator).clear(); &#13;
elementObj.clear(); // Guessing the elementFinder is input/textarea, and after calling this clear() it will clear the value and reset it.    &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>Remember that it's only the input or texture that may have some value and needs you to clear/reset the value.</p></div></div><p>When we need to trigger a click event on any button, link, or image, after selecting a specific <code class="literal">elementFinder</code> object, we will need to chain the <code class="literal">click()</code> method, and it will act like a real click on that element:</p><pre class="programlisting">element.(Locator).click(); &#13;
elementObj.click(); // will trigger the click event as the selected element chaining it.    &#13;
</pre><p>Sometimes, we might need to trigger the <code class="literal">submit()</code> method for form submission. In that case, we have to chain the <code class="literal">submit()</code> method with the selected element. The selected element should be a <code class="literal">form</code> element:</p><pre class="programlisting">element.(Locator).submit(); &#13;
elementObj.submit(); // Will trigger the submit for the form &#13;
element as submit() work only for form element.   &#13;
</pre></div><div class="section" title="Locators"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec72"/>Locators</h2></div></div></div><p>Locators inform Protractor how to find a certain element in the DOM element. Protractor exports <code class="literal">locator</code> as a global factory function, which will be used with a global <code class="literal">by</code> object. We can use them in many ways based on our DOM, but let's look at some of the most commonly used ones.</p><p>We can select any element by passing any of the CSS selectors to the <code class="literal">by.css</code> method, as shown here:</p><pre class="programlisting">element(by.css(cssSelector));  &#13;
element.all(by.css(cssSelector)); &#13;
&lt;span class="selector"&gt;&lt;/span&gt; &#13;
element.all(by.css('.selector'));  // return the specific DOM element/elements that will have selector class on it &#13;
</pre><p>We can select any element by passing its element ID to the <code class="literal">by.id</code> method, as shown here:</p><pre class="programlisting">element(by.id(id)); &#13;
&lt;span id="selectorID"&gt;&lt;/span&gt;   &#13;
element(by.id('selectorID')); // return the specific DOM element that will have selectorID as element id on it  &#13;
</pre><p>We can also select a specific element or elements by tag name by passing it to <code class="literal">by.tagName</code>, as follows:</p><pre class="programlisting">element(by.tagName(htmlTagName)); &#13;
element.all(by.tagName(htmlTagName)); &#13;
&lt;span data="myData"&gt;Content&lt;/span&gt; &#13;
element.all(by.tagName('span')); // will return the DOM element/elements of all span tag.  &#13;
</pre><p>To select the DOM element of any specific input field, we can pass the name in the <code class="literal">by.name</code> method, as shown:</p><pre class="programlisting">element(by.name(elementName)); &#13;
&lt;input type="text" name="myInput"&gt; &#13;
element(by.name('myInput')); // will return the specific input field's DOM element that have name attr as myInput &#13;
</pre><p>Besides a CSS selector or ID, we can select a specific button by passing its text label to <code class="literal">by.buttonText</code>:</p><pre class="programlisting">&lt;button name="myButton"&gt;Click Me&lt;/button&gt; &#13;
element(by.buttonText('Click Me')); // will return the specific button that will have Click Me as label text  &#13;
element(by.buttonText(textLabel)); &#13;
</pre><p>We can find an element by passing the model name defined as an <code class="literal">ng-model</code> on <code class="literal">by.model</code>, as shown here:</p><pre class="programlisting">element.(by.model); &#13;
&lt;span ng-model="userName"&gt;&lt;/span&gt; &#13;
element(by.model('userName')); // will return that specific element which have defined userName as model name    &#13;
</pre><p>Similarly, we can find a specific DOM element by passing its binding defined with <code class="literal">ng-bind</code> in <code class="literal">by.bindings</code>, as follows:</p><pre class="programlisting">element.(by.binding); &#13;
&lt;span ng-bind="email"&gt;&lt;/span&gt; &#13;
element(by.binding('email')); // will return the element that have email as bindings with ng-bind  &#13;
</pre><p>Besides all the locators explained earlier, there is another way to find a specific DOM element: a custom locator. Here, we have to create a custom locator using <code class="literal">by.addLocator</code> by passing the locator name and callback. Then, we have to pass that custom locator with <code class="literal">by.customLocatorName(args)</code>, as shown here:</p><pre class="programlisting">element.(by.locatorName(args)); &#13;
&lt;button ng-click="someAction()"&gt;Click Me&lt;/button&gt; &#13;
by.addLocator('customLocator', function(args) { &#13;
    // .....  &#13;
}) &#13;
element(by. customLocator(args)); // will return the element that will match with the defined logic in the custom locator. This useful mostly when user need to select dynamic generated element.  &#13;
</pre></div></div>
<div class="section" title="Protractor tests - postmortem"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Protractor tests - postmortem</h1></div></div></div><p>It's kind of difficult to debug e2e tests as they depend on the entire ecosystem of an application. Sometimes they depend on prior actions such as login, and sometimes they depend on permissions. Another major barrier to debugging e2e is its dependency on WebDriver. As it acts differently with different operating systems and browsers, this makes it difficult to debug e2e. Besides that, it generates long error messages, which makes it difficult to separate browser related issues and test process errors.</p><p>Still, we will try to debug all e2e tests and see how that works for our case.
</p><div class="section" title="Types of failure"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec73"/>Types of failure</h2></div></div></div><p>There might be various reasons for the failure of a test suite as long as it depends on WebDriver and various parts throughout the system.</p><p>Let's look at some known failure types:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>WebDrive failure</strong></span>: WebDriver throws an error when a command can't be completed. For example, a browser can't get the address that's defined to help it navigate, or maybe an element is not found as expected.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>WebDriver unexpected failure</strong></span>: Sometimes, WebDriver fails and gives an error when it fails to update the web driver manager. This is a browser and OS-related issue, although it's not common.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Protractor failure for Angular</strong></span>: Protractor will fail when Angular is not found in the library as expected because the Protractor test depends on Angular itself.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Protractor Angular2 failure</strong></span>: Protractor will fail for an Angular project's test spec when the <code class="literal">useAllAngular2AppRoots</code> parameter is missing in the configuration because, without this, the test process will look at one single root element while expecting more elements in the process.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Protractor failure for timeout</strong></span>: Sometimes, Protractor fails for the timeout when the test spec falls into a loop or a long pool and fails to return data in time. However, a timeout is configurable, so it can be increased as needed.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Expectation failure</strong></span>: This is a common failure in the test spec.</li></ul></div></div><div class="section" title="Loading an existing project"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec74"/>Loading an existing project</h2></div></div></div><p>The code used in this test comes from <a class="link" href="ch04.html" title="Chapter 4. End-to-End Testing with Protractor">Chapter 4</a>, <span class="emphasis"><em>End to End Testing with Protractor</em></span>. We will copy the code to a new directory: <code class="literal">angular-protractor-debug</code>.</p><p>As a reminder, the application was a to-do application that had some items in the to-do list, and we added some items to it. It has a single component class, <code class="literal">AppComponent</code>, which has a list of items, and an <code class="literal">add</code> method.</p><p>The current directory should be structured as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_001.jpg" alt="Loading an existing project"/></div><p>
</p><p>After verifying that the folder structure is the same as shown in the preceding screenshot, the first job is to get the required dependencies, <code class="literal">node_modules</code>, locally by running the following:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install</strong></span>
</pre><p>This will install all the required modules. Now, let's build and run the project with the <code class="literal">npm</code> command:</p><pre class="programlisting">
<span class="strong"><strong>$ npm start</strong></span>
</pre><p>Everything should be fine now: the project should run on <code class="literal">http://localhost:3000</code>, and the output should be as shown:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_002.jpg" alt="Loading an existing project"/></div><p>
</p><p>With that, we are ready to go on to the next step of implementing a debugger in our Angular project.</p></div><div class="section" title="Including the debugger in the project"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec75"/>Including the debugger in the project</h2></div></div></div><p>Before adding the debugger to our project, let's run the e2e test in our existing project. We hope to pass without any failure in the e2e test specs.</p><p>Let's run it using the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ npm run e2e</strong></span>
</pre><p>As expected, our tests passed. The result is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_003.jpg" alt="Including the debugger in the project"/></div><p>
</p><p>We can add our debugging code in the same place where the passed test specs are, but let's keep the passed test case separate and play with the debugger in a different directory. Let's create a new directory, <code class="literal">debug/</code>. We will need two files in the directory: one for the configuration and the other for the spec.</p><p>For the Protractor configuration file, we can copy the <code class="literal">protractor.conf.js</code> file and rename it to <code class="literal">debugConf.js</code>.</p><p>Everything in the configuration will be the same as the previous configuration. However, we need to increase the default timeout for the Jasmine test, or the test will timeout during debugging.</p><p>Let's increase the timeout to <code class="literal">3000000</code> ms:</p><pre class="programlisting">exports.config = { &#13;
    // ....  &#13;
    jasmineNodeOpts: { &#13;
      showColors: true, &#13;
      defaultTimeoutInterval: 3000000 &#13;
    }, &#13;
    // ..... &#13;
}; &#13;
</pre><p>Next, we will need a spec file to which to write the test spec and debug tests. Save the new spec file as <code class="literal">app.debug.e2e.ts</code>. Oh yes, we will need to change the config file once again to define the spec files for debugging.</p><pre class="programlisting">exports.config = { &#13;
    // ....  &#13;
    specs: [ &#13;
      'app.debug.e2e.js' &#13;
    ], &#13;
    // ..... &#13;
}; &#13;
</pre><p>We can make a simple test spec file for <code class="literal">app.debug.e2e.ts</code>. Then, we can add debug codes and play with them.</p><p>Simple test specs are as shown:</p><pre class="programlisting">describe('AppComponent Tests', () =&gt; { &#13;
    beforeEach(() =&gt; { &#13;
        browser.get('/'); &#13;
    }); &#13;
 &#13;
    it('Test spec for debug and play', () =&gt; { &#13;
         &#13;
    }); &#13;
}); &#13;
</pre></div></div>
<div class="section" title="Pausing and debugging"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Pausing and debugging</h1></div></div></div><p>To debug any test spec, we must pause the test process and see what is going on step-by-step. Protractor also has built-in methods to pause the process. Here are two methods to pause and debug the test process:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">browser.pause()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">browser.debugger()</code></li></ul></div><div class="section" title="Using pause"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec76"/>Using pause</h2></div></div></div><p>Debugging Protractor tests becomes easy and simple with the <code class="literal">browser.pause()</code> command. Using the <code class="literal">pause()</code> method, we can enter the Protractor debugger control flow and execute some commands to check out what's happening in the control flow of the test. Mostly, developers use debuggers in tests when the test fails with an unknown error and there are long error messages.</p><p>After using the <code class="literal">browser.pause()</code> command, we can use a few more commands based on our needs.</p><p>Let's take a brief look:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">c</code>: If we type <code class="literal">c</code> as a command, it will move one step forward in the test, and we will see how the test command works in depth. If we plan to move forward with a test, it's better to do it quickly as there is a timeout issue ( the Jasmine default timeout), which we've learned about. We will see an example later on.</li><li class="listitem" style="list-style-type: disc"><code class="literal">repl</code>: By typing <code class="literal">repl</code> as a command, we can enter the interactive mode of debugging. It's known as as the interactive mode as, from there, we can interact directly with the browser from the terminal by typing WebDriver commands. A response, result, or error from the browser will be displayed on the terminal as well. We will see more hands-on examples later.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Ctrl + C</code>: Press <span class="emphasis"><em>
<span class="strong"><strong>Ctrl</strong></span>
</em></span> + C to exit pause mode and continue the test. When we will use this, the test will continue from the point where it paused.</li></ul></div><div class="section" title="A quick example"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec21"/>A quick example</h3></div></div></div><p>To use <code class="literal">browser.pause()</code> in test specifications, we will have to add the method to the test spec at the places we want to pause the test and watch the control flow for debugging. Here, we just have one test spec with a wrong/failing test case, we know it will fail, and we will find out why it failed.</p><p>We will have to add the <code class="literal">pause()</code> method, as shown, to the test <code class="literal">spec it() {}</code> function:</p><pre class="programlisting">it('Test spec for debug and play', () =&gt; { &#13;
  browser.pause(); &#13;
  // There is not element with the id="my_id", so this will fail&#13;
  the test &#13;
  expect(element(by.id('my_id')).getText()).toEqual('my text') &#13;
});  &#13;
</pre><p>It's time to run the test. As we've separated the test spec for the debugger, we will run the test via Protractor (not <code class="literal">npm</code>).</p><p>Let's run the test with the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ protractor debug/debugConf.js</strong></span>
</pre><p>As we have placed the <code class="literal">browser.pause()</code> method before the <code class="literal">expect()</code> method, it will pause there. We can see in the control flow that this makes it wait for Angular:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_004.jpg" alt="A quick example"/></div><p>
</p><p>We will move forward; for that, let's type <code class="literal">C</code>. It will run <code class="literal">executeAsyncScript</code> and will wait for Angular to load:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_005.jpg" alt="A quick example"/></div><p>
</p><p>We will move another step ahead by typing <code class="literal">C</code>. It will try to select the element based on the locator provided by us, that is, <code class="literal">element(by.id('my_id')</code>:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_006.jpg" alt="A quick example"/></div><p>
</p><p>We are close to getting the test result now. For that, we will have to move another step forward by typing <code class="literal">C</code>. Now, it will try to select the element based on the locator, and it will fail to select that. This will give a result with an error message, as expected:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_007.jpg" alt="A quick example"/></div><p>
</p></div><div class="section" title="Debugging with interactive mode"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec22"/>Debugging with interactive mode</h3></div></div></div><p>To enter interactive mode, we have to type <code class="literal">repl</code>, after which we can run any command used in the test spec.</p><p>Let's find the element and its text:</p><pre class="programlisting">&gt; element(by.id('my_id')).getText() &#13;
</pre><p>The result is the same as we got previously, by moving forward step by step, by typing <code class="literal">C</code>.</p><p><span class="strong"><strong>Result</strong></span>: <code class="literal">NoSuchElementError: No element found using locator: By (css selector,</code>
<code class="literal">*[id="my_id"])</code></p><p>Now, let's see how interactive mode works for a valid locator, when the <code class="literal">element</code>will be found:</p><pre class="programlisting">&gt; element.all(by.css('li')).first().getText() &#13;
</pre><p><span class="strong"><strong>Result</strong></span>: <code class="literal">test</code></p></div></div><div class="section" title="Using the debugger"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec77"/>Using the debugger</h2></div></div></div><p>Debugging with the <code class="literal">browser.debugger()</code> command is a bit complex and more advanced than using <code class="literal">browser.pause()</code>. With the <code class="literal">browser.pause()</code> command, we can pause the control flow of the test and inject the custom helper functions into the browser so that debugging happens in the same way as we would debug in a browser console.</p><p>This debugging should be under node in debug mode, like here in Protractor debugging. This debugging is not useful for someone bad at node debugging.</p><p>Here is an example:</p><p>To use the <code class="literal">browser.debugger()</code> method in the test spec, we will have to add the method to the test spec at the points where we want to set a breakpoint and watch the control flow.</p><p>For us, we have to add the <code class="literal">debugger()</code> method, as follows, to the <code class="literal">test spec it() {}</code> function, and this will be our breakpoint:</p><pre class="programlisting">it('Test spec for debug and play', () =&gt; { &#13;
  browser.debugger(); &#13;
  // There is not element with the id="my_id", so this will fail &#13;
the test &#13;
  expect(element(by.id('my_id')).getText()).toEqual('my text') &#13;
  });   &#13;
</pre><p>Now let's run it:</p><pre class="programlisting">
<span class="strong"><strong>$ protractor debug debug/debugConf.js</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>To run the debugger, we have to add <code class="literal">debug</code> to the command after <code class="literal">protractor</code>.</p></div></div><p>After running the command, we have to move forward by typing <code class="literal">C</code>, but here we need to do it just once. The output is as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_008.jpg" alt="Using the debugger"/></div><p>
</p></div></div>
<div class="section" title="Self-test questions"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Self-test questions</h1></div></div></div><p>Q1. <code class="literal">Selenium WebDriver</code> is a browser automation framework.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">True</li><li class="listitem" style="list-style-type: disc">False</li></ul></div><p>Q2. Using <code class="literal">browser.debugger()</code> is a simple way to debug Protractor.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">True</li><li class="listitem" style="list-style-type: disc">False</li></ul></div><p>Q3. What are <code class="literal">by.css()</code>, <code class="literal">by.id()</code>, and <code class="literal">by.buttonText()</code> called?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Elements</li><li class="listitem" style="list-style-type: disc">Locators</li><li class="listitem" style="list-style-type: disc">Actions</li><li class="listitem" style="list-style-type: disc">Browsers</li></ul></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Summary</h1></div></div></div><p>Protractor has various kinds of API. In this chapter, we tried to understand some of the most commonly used APIs with some examples. We also covered API types (such as browser, elements, locator, and actions), and how they are chained with one another, in some detail.</p><p>Debugging was introduced in this chapter, and we tried to learn a simple way to debug, using <code class="literal">browser.pause()</code>, in more detail, and then we moved on to a complex method (<code class="literal">browser.debugger()</code>), and understood that complex developers need node debugger experience.</p><p>In the next chapter, we will delve into more real-life projects; further, we will go through the top-down and bottom-up approaches and learn them both.</p></div></body></html>