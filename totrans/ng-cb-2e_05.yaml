- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular and RxJS – Awesomeness Combined
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Angular** and **RxJS** create a killer combination of awesomeness. By combining
    these, you can handle your data reactively, work with streams, and implement complex
    business logic in your Angular apps. That’s exactly what you’re going to learn
    about in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the recipes we’re going to cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Sequential and parallel HTTP calls in Angular with RxJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listening to multiple observable streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsubscribing streams to avoid memory leaks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Angular’s `async` pipe to unsubscribe streams automagically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `map` operator to transform data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `switchMap` and `debounceTime` operators with autocompletes for better
    performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom RxJS operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrying failed HTTP calls with RxJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the recipes in this chapter, ensure your setup is complete as per the ''Technical
    Requirements'' in the ''Angular-Cookbook-2E'' GitHub repository. For setup details,
    visit: [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md).
    The starter code for this chapter is located at [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter05](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: Sequential and parallel http calls in Angular with RxJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you’ll learn how to use different RxJS operators to make sequential
    and parallel HTTP calls in Angular apps. We’ll work with the famous Star Wars
    API (**swapi**) to get some data to display on the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter05/rx-seq-parallel-http`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_05_01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.1: The rx-seq-parallel-http app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running, we will move on to the steps for the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have an Angular app that uses the Star Wars API (swapi) to fetch a person
    from Star Wars, and the films the person has been in. All of this happens using
    a lot of HTTP calls, and our code is totally garbage so far. This is because we
    first show the loader, but we hide it before we’ve retrieved all the data. Also,
    if you keep refreshing the page, you’ll see that the sequence of the films can
    change each time. Hence, we see the UI jumping a lot. Our desired approach is
    to fetch the person, then fetch all the films, and then hide the loader. We will
    implement this approach using RxJS. Let’s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll avoid using the `setTimeout` function to rely on the person data
    being available in `1500ms`. We would rather move this inside the `subscribe`
    block and will also handle errors appropriately. Update the `fetchData` method
    inside the `app.component.ts` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This has a potential problem. And that is, as soon as the first film is retrieved,
    the loader is hidden because we set `this.loadingData` to `false`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we will add the `mergeMap` operator using the `pipe` method to be able
    to chain calls later. For now, we will just move the code for adding the `filmObjects`
    array in the `this.person` object inside the `mergeMap` callback. Update the `fetchData`
    method as follows now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the UI becomes *a bit better*. The loader still hides as soon as
    one of the films is retrieved from the server. However, we want to hide the loader
    when all of them have been retrieved. Also, the sequence of the films is still
    unpredictable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we’ll use the `forkJoin` function to make the API calls for the films
    in parallel and to wait for the combined response. We’re doing it instead of the
    `of` operator, which just passes the film URLs from the `mergeMap` function. Update
    the `fetchData` method as follows and update the imports at the top:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Woohoo! Now if you refresh the app, you’ll notice two things. First, the loader
    always stops only when all the data has been fetched. And second, the sequence
    of the films is always the same (and correct).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve finished the recipe, let’s move on to the next section to understand
    how it all works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `mergeMap` operator allows us to chain observables by returning an **observable**
    from its callback. You can think of it like how we chain `Promise.then`, but this
    is for observables. A popular alternative is the `switchMap` operator, which works
    like the `mergeMap` operator but also cancels the previous call/execution if called
    twice or more before the first call/execution completes. We first removed the
    `setTimeout` function (which is mostly nonsensical to put into the code for these
    cases because the result is not always predictable with respect to time) and moved
    the logic of fetching films inside the `subscribe` block of fetching the person.
    We also used the `of` operator to return the `personObject` object from the `mergeMap`
    function’s callback. The `mergeMap` function is used to chain observables together
    and, in our context, it can be chained to wait for one HTTP call to finish so
    we can execute the other ones. In *step 3*, we intend to execute multiple HTTP
    calls together in parallel for all the films for the person. We do this using
    the `forkJoin` operator, which takes an array of observables. In this case, those
    observables are HTTP calls for each film. `forkJoin` also makes it possible to
    wait for all the parallel calls to finish and then trigger the `subscribe` block’s
    callback. One more thing `forkJoin` does is it provides us with the responses
    in the form of an array having the responses in the same sequences as the observables.
    This makes the responses predictable, and we always show the same data on the
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Catch the Dot Game*—RxJS documentation ([https://www.learnrxjs.io/learn-rxjs/recipes/catch-the-dot-game](https://www.learnrxjs.io/learn-rxjs/recipes/catch-the-dot-game))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RxJS `mergeMap` operator documentation ([https://www.learnrxjs.io/learn-rxjs/operators/transformation/mergemap](https://www.learnrxjs.io/learn-rxjs/operators/transformation/mergemap))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RxJS `merge` operator documentation ([https://www.learnrxjs.io/learn-rxjs/operators/combination/forkjoin](https://www.learnrxjs.io/learn-rxjs/operators/combination/forkjoin))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listening to multiple observable streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we’ll work with the `combineLatest` operator to listen to multiple
    observable streams at once. Using this operator results in having an array as
    an output, combining all the streams. This approach is appropriate for when you
    want the latest output from all the streams, combined in a single subscription.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter05/rx-multiple-streams`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_05_02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.2: The rx-multiple-streams app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we have an app that displays a box. The box has a size (width
    and height), a border radius, a background color, and a color for its text. It
    also has four inputs using the **Reactive Forms** API to modify all the mentioned
    factors. Right now, we have to apply the changes manually with the click of a
    button even if the inputs change. What if we could subscribe to the changes to
    the inputs and update the box right away without having the user click the button?
    That’s what we’re going to do here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll begin by creating a method named `listenToInputChanges`. We’ll create
    an array of controls we want to work with. Update the code of `home.component.ts`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we’ll loop over the controls to give them the initial value so that when
    the observable stream is subscribed, they have a value to work with. Update the
    `listenToInputChanges` method further as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we’ll replace the `boxStyles` property with an `Observable` named `boxStyles$`.
    Then we’ll wrap the `valueChanges` streams of each form control inside a `combineLatest`
    operator to join them. Finally, we’ll assign the result of this joined stream
    to the `boxStyles$` observable. Update the `home.component.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we will use a `map` operator with `pipe` on the combined stream to map
    it to the `BoxStyle` type values. Update the `listenToInputChanges` method in
    the `home/home.component.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to remove the `setBoxStyles` and `applyChanges` methods and the usages
    of the `applyChanges` method from the `home.component.ts` file. Update the file,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to remove the usage of the `applyChanges` method from the template
    as well. Remove the `(ngSubmit)` handler from the `<form>` element in the `home.component.html`
    file so that it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to get rid of the `submit-btn-container` element from the `home.component.html`
    template as we don’t need it anymore. Delete the following chunk from the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we can work with the `boxStyles$` Observable, let’s use it in the
    template, i.e., the `home.component.html` file, instead of the `boxStyles` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And voilà! If you refresh the app, you should be able to see the box appearing
    with the default styles. And if you change any of the options, you’ll see the
    changes reflected as well.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations on finishing the recipe. You’re now the master of handling multiple
    streams using the `combineLatest` operator. See the next section to understand
    how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The beauty of Reactive Forms is that they provide much more flexibility than
    the regular `ngModel` binding or even template-driven forms. And for each form
    control, we can subscribe to its `valueChanges` observable, which receives a new
    value whenever the input is changed. So, instead of relying on the **Submit**
    button’s click, we subscribe directly to the `valueChanges` property of each **form
    control**. In a regular scenario, that would result in four different streams
    for four inputs, which means we would have four subscriptions that we need to
    take care of and make sure we unsubscribe them. This is where the `combineLatest`
    operator comes into play. We used the `combineLatest` operator to combine those
    four streams into one, which means we needed to unsubscribe only one stream on
    component destruction. But hey! Remember that we don’t need to do this if we use
    the `async` pipe? That’s exactly what we did. We removed the subscription from
    the `home.component.ts` file and used the `pipe` method with the `map` operator.
    The `map` operator transformed the data according to our needs and then returned
    the transformed data to be set to the `boxStyles$` observable. Finally, we used
    the `async` pipe in our template to subscribe to the `boxStyles$` observable and
    assigned its value as `[ngStyle]` to our box element. Since `valueChanges` is
    a `Subject` instead of a `ReplaySubject`, we also piped a `startWith` with `valueChanges`
    to provide an initial value. If we don’t use `startWith`, the box won’t show unless
    all the inputs have a value changed manually at least once. Try it!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`combineLatest` operator documentation ([https://www.learnrxjs.io/learn-rxjs/operators/combination/combinelatest](https://www.learnrxjs.io/learn-rxjs/operators/combination/combinelatest))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual representation of the `combineLatest` operator ([https://rxjs-dev.firebaseapp.com/api/index/function/combineLatest](https://rxjs-dev.firebaseapp.com/api/index/function/combineLatest))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsubscribing streams to avoid memory leaks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Streams are fun to work with and they’re awesome. You’ll know more about RxJS
    and streams when you’ve finished this chapter. One reality is facing unseen problems
    that occur when streams are used without caution. One of the biggest mistakes
    to make with streams is to not unsubscribe them when we no longer need them, and
    in this recipe, you’ll learn how to unsubscribe streams to avoid memory leaks
    in your Angular apps.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter05/rx-unsubscribing-streams`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_05_03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.3: The rxjs-unsubscribing-streams app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We currently have an app with two routes—that is, **Home** and **About**. This
    is to show you that unhandled subscriptions can cause memory leaks in an app.
    The default route is **Home**, and in the `HomeComponent` class, we handle a single
    stream that outputs data using the `interval` operator function:'
  prefs: []
  type: TYPE_NORMAL
- en: Tap the **Start Stream** button, and you should see the stream emitting values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, navigate to the **About** page by tapping the **About** button from the
    header (top right), and then come back to the **Home** page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you see anything weird? No? Everything looks fine, right? Well, not exactly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To see whether we have an unhandled subscription, let’s put `console.log` inside
    the `startStream` method in the `home.component.ts` file—specifically, inside
    the `subscribe` function’s block, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you now perform the same steps as mentioned in *Step 1*, you’ll see the
    following output on the console, as shown in *Figure 5.4*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_05_04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.4: interval emitting values on the About page'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Want to have some more fun? Try performing *Step 1* a couple of times without
    refreshing the page even once. What you’ll see will be *chaos!*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'So, to solve the issue, we’ll use the simplest approach—that is, unsubscribing
    the stream when the user navigates away from the route. Let’s implement the `ngOnDestroy`
    lifecycle method for that, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Great! If you follow the instructions from *Step 1* again, you’ll see that there’s
    no further log on the console once you navigate away from the **Home** page, and
    our app doesn’t have an unhandled stream causing memory leaks now. Read the next
    section to understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we create an `Observable/stream` and we subscribe to it, RxJS automagically
    adds our provided `subscribe` function block as a handler to the `Observable`.
    So, whenever there’s a value emitted from the `Observable`, our method is supposed
    to be called. The fun part is that Angular doesn’t automatically destroy that
    subscription/handler when the component unmounts or when you have navigated away
    from the route. That’s because the core of observables is **RxJS**, not Angular;
    therefore, it isn’t Angular’s responsibility to handle it.
  prefs: []
  type: TYPE_NORMAL
- en: Angular provides certain lifecycle methods, and we used the `OnDestroy` `(ngOnDestroy)`
    method. So, we used the `ngOnDestroy` method to call the `stopStream` method so
    that the subscription is destroyed as soon as the user navigates away from the
    page. This is possible because, when we navigate away from a route, Angular destroys
    that route and thus we can execute our `stopStream` method.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a complex Angular app, there will be cases where you’d have more than one
    subscription in a component, and when the component is destroyed, you’d want to
    clean all those subscriptions at once. Similarly, you might want to unsubscribe
    based on certain events/conditions rather than the `OnDestroy` lifecycle. Here
    is an example where you have multiple subscriptions in hand, and you want to clean
    up all of them together when the component is destroyed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we’re not saving the **subscription** from `streamSource` to `this.subscription`
    anymore, and we have also removed the code from the `stopStream` method. The reason
    for this is that we don’t have individual properties/variables for each subscription.
    Instead, we’ll have a single variable to work with. Let’s look at the following
    recipe steps to get things rolling:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll create a property in the `HomeComponent` class named `isStreamActive`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll import the `takeWhile` operator from `rxjs/operators`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll now use the `takeWhile` operator with each of our streams to make them
    work only when the `isStreamActive` property is set to `true`. Since `takeWhile`
    takes a `predicate` method, it should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you click the **Start Stream** button right now on the **Home** page, you
    still won’t see any output or logs because the `isStreamActive` property is still
    **undefined**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To make the streams work, we’ll set the `isStreamActive` property to `true`
    in the `startStream` method. The code should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After this step, if you now try to start the stream and navigate away from the
    page, you’ll still see the same issue with the streams—that is, they’ve not been
    unsubscribed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To unsubscribe all streams at once, we’ll set the value of `isStreamActive`
    to `false` in the `stopStream` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, update the template to handle which button is disabled based on the
    `isStreamActive` property instead of `subscription`. Update the `home.component.html`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And boom! Now, if you navigate away from the route while the streams are emitting
    values, the streams will stop immediately as soon as you navigate away from the
    **Home** route. Voilà!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Read about RxJS subscription ([https://www.learnrxjs.io/learn-rxjs/concepts/rxjs-primer#subscription](https://www.learnrxjs.io/learn-rxjs/concepts/rxjs-primer#subscription))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`takeWhile` operator docs ([https://www.learnrxjs.io/learn-rxjs/operators/filtering/takewhile](https://www.learnrxjs.io/learn-rxjs/operators/filtering/takewhile))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Angular’s async pipe to unsubscribe streams automatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you learned in the previous recipe, it is crucial to unsubscribe the streams
    you subscribe to. What if we had an even simpler way to unsubscribe them when
    the component gets destroyed—that is, letting Angular take care of it somehow?
    In this recipe, you’ll learn how to use Angular’s `async` pipe with an observable
    to directly bind the data in the stream to the Angular template instead of having
    to subscribe in the `*.component.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter05/ng-async-pipe`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_05_05.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.5: The ng-async-pipe app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The app we have right now has three streams/observables observing values at
    different intervals. We’re relying on the `isStreamActive` property to keep the
    subscription alive or make it stop when the property is set to `false`. We’ll
    remove the usage of `takeWhile` and somehow make everything work similarly to
    what we have right now.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add a property of type `Observable` in the `HomeComponent` class named
    `streamOutput$`. Update the code in the `home.component.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll now combine all the streams to give out a single output—that is, the
    `outputStreamData` array. We’ll remove all the existing `pipe` and `subscribe`
    functions from the `startStream` method, so the code should now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we want to stop the stream on the **Stop Stream** button click, we’ll
    use the `takeWhile` operator in the stream to work with the stream to only emit
    values when we click the **Start Stream** button and to stop when we hit the **Stop
    Stream** button. Update the `startStream` method in `home.component.ts` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remove the `ngOnDestroy` method since our stream is going to unsubscribe automatically
    when we leave the component (go to another route). This is because we’re using
    the `async` pipe and Angular itself handles the subscription and unsubscription
    for us when using the `async pipe`. Also, we should remove the `implements OnDestroy`
    statement and remove the `OnDestroy` import.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, modify the template in `home.component.html` to use the `streamOutput$`
    observable with the `async` pipe to loop over the output array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To verify that the subscription *really* gets destroyed on component destruction,
    let’s put `console.log` in the `startStream` method inside the `tap` operator,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Hurray! With this change, you can try refreshing the app; navigate away from
    the **Home** route, and you’ll see that the console logs stop as soon as you navigate
    away from the homepage. Also, you can start and stop the stream to see the output
    on the console. Do you feel great about what we just got by removing all that
    extra code? I certainly do. We’ll see in the next section how it all works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular’s `async` pipe automatically destroys/unsubscribes the subscription
    as soon as the component is destroyed. This gives us a great opportunity to use
    it where possible. In the recipe, we basically combined all the streams using
    the `merge` operator. The fun part was that for the `streamsOutput$` property,
    we wanted an observable of the output array on which we could loop over. However,
    merging the streams only combines them and emits the latest value emitted by any
    of the streams. So, we added a `pipe` function with the `scan` operator to take
    the latest output of the combined stream and add it to an array of all the previously
    emitted outputs. This sort of works like the `reduce` function of a JavaScript
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Fun fact—streams don’t emit any value unless they’re subscribed to. “*But Ahsan,
    we didn’t subscribe to the stream, we just merged and mapped the data. Where’s
    the subscription?*” Glad you asked. Angular’s `async` pipe subscribes to the stream
    itself, which triggers `console.log` as well, which we added in *Step 6* using
    the `tap` function.
  prefs: []
  type: TYPE_NORMAL
- en: IMPORTANT NOTE
  prefs: []
  type: TYPE_NORMAL
- en: The `async` pipe has a limitation, which is that you cannot stop the subscription
    until the component is destroyed. For cases where you want to subscribe and unsubscribe
    on a conditional basis, you’d want to go for operators such as the `takeWhile/takeUntil`
    operator or use a regular `unsubscribe` function yourself when the component is
    destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular `async` pipe documentation ([https://angular.io/api/common/AsyncPipe](https://angular.io/api/common/AsyncPipe))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the map operator to transform data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When making the API/HTTP calls in a web application, it is often the case that
    the server doesn’t return the data in a form that is easy to directly render to
    the UI. We often need some sort of transformation of the data received from the
    server to map it to something our UI can work with. In this recipe, you’re going
    to learn how to use the `map` operator to transform responses from an HTTP call.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter05/rx-map-operator`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_05_06.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.6: The rx-map-operator app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our template (`app.component.html`) for the app is set up already. And so is
    our `app.component.ts` file and the `appData` data structure that we require.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by creating a method in the `swapi.service.ts` file to fetch the
    data. We want only one function to be able to bring the data from different API
    calls, combine it, and return it. Update the file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*You’re going to see that TypeScript is mad at us. Don’t worry about it. We’ll
    make it happy in time*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s add the following code to first get the person, and then get the films
    of that person in the `fetchData` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we can decide what to do when we receive the films back.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We’ll map over the response from the `films` HTTP calls and add that to the
    `personInfo` object. Update the `swapi.service.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s use the `fetchData` method from `SwapiService` inside our `app.component.ts`file.
    Update the `fetchData` method in the file as follows and make sure you remove
    unused dependencies from the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And yes! If you now refresh the app, you’ll notice that the data is being displayed
    in the view:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_05_07.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.7: The UI showing the received data from swapi'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that you’ve finished the recipe, see the next section on how this works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `map` operator is one of the most used RxJS operators of all time. Especially
    in Angular when we make HTTP calls. In this recipe, our target was to do as little
    work as possible in the `app.component.ts` file. That’s because as one of the
    community-adopted practices, the component should request data from the service
    and the service should give it in such a way that it can be bound to the UI variables
    as is. The Angular documentation also encourages keeping the component’s code
    as tiny as possible. It is also generally a good idea to distribute your code
    into different layers, i.e., in components, services, pipes, etc. This is to be
    able to scale the application with ease, have better testing possibilities, and
    be able to easily replace the layers with a completely different thing. Therefore,
    we created this `fetchData` method in the `SwapiService` class to use the `fetchPerson`
    and `fetchPersonFilms` methods to first make the HTTP calls, and then we used
    the `map` operator to transform the data into exactly the data structure our component/UI
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`map` operator documentation ([https://www.learnrxjs.io/learn-rxjs/operators/transformation/map](https://www.learnrxjs.io/learn-rxjs/operators/transformation/map))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the switchMap and debounceTime operators with autocompletes for better
    performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a lot of apps, we have features such as searching content as the user types.
    This is a really good **User Experience** (**UX**) as the user doesn’t have to
    press a button to do a search. However, if we send an HTTP call to the server
    on every key press, that’s going to result in a lot of HTTP calls being sent,
    and we can’t know which HTTP call will complete first; thus, we can’t be sure
    if we will have the correct data shown in the view or not. In this recipe, you’ll
    learn how to use the `switchMap` operator to cancel out the last subscription
    and create a new one instead. This would result in canceling previous HTTP calls
    and keeping only one HTTP call—the last one. We’ll use the `debounceTime` operator
    to wait for the input to be idle before it even tries to make one call.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter05/rx-switchmap-operator`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_05_08.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.8: The rx-switchmap-operator app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have the app running locally, open **Chrome DevTools** and go to
    the **Network** tab. Type `wolf` in the search input, and you’ll see four calls
    being sent to the API server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18469_05_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.9: A separate HTTP call is sent for each input change'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can start typing into the search box on the homepage to see the filtered
    users, and if you see the **Network** tab, you’ll notice that whenever the input
    changes, we send a new HTTP call. Let’s avoid sending a call on each keypress
    by using the `switchMap` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the `switchMap` operator from `rxjs/operators` in the `users/users.component.ts`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now modify our subscription to the `username` form control— specifically,
    the `valueChanges` observable to use the `switchMap` operator for the `this.userService.searchUsers(query)`
    method call. This returns an `Observable` containing the result of the HTTP call.
    The code should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you refresh the app now, open **Chrome DevTools**, and check the network
    type while typing `wolf` really fast, you’ll see that all the previous calls are
    canceled and we only have the latest HTTP call succeeding:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_05_10.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.10: switchMap canceling prior HTTP calls'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Well, this looks better, but the `backend/api` endpoint still receives those
    calls.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We’re going to use the `debounceTime` operator now to wait for the search input
    to be idle before starting to execute a call. Update the `users.component.ts`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Figure 5.11* shows that there is only one call sent to the server, even after
    typing four letters in the search input:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_05_11.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.11: debounceTime waiting for the input to be idle'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Woot! We now have only one call that’ll succeed, process the data, and end up
    in the view; see the next section on how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `switchMap` operator cancels the previous (inner) subscription and subscribes
    to a new observable instead. In our case, the parent observable (the input element’s
    `valueChanges` emitter) emits a value, and the `switchMap` operator cancels the
    previous operation in progress. That’s why it cancels all the HTTP calls sent
    before in our example and just subscribes to the last one. However, the call still
    reaches the API endpoint. If this was our server, we may still receive the API
    calls, so we use the `debounceTime` operator on the form control to wait for the
    input to be idle (for 500 ms) before we even send our first call.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`switchMap` operator documentation ([https://www.learnrxjs.io/learn-rxjs/operators/transformation/switchmap](https://www.learnrxjs.io/learn-rxjs/operators/transformation/switchmap))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`debounceTime` operator documentation ([https://www.learnrxjs.io/learn-rxjs/operators/filtering/debouncetime](https://www.learnrxjs.io/learn-rxjs/operators/filtering/debouncetime))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom RxJS operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By following the other recipes in this chapter, I have to ask if you’ve become
    a fan of RxJS yet? *Have you?* Well, I am. And in this recipe, you’re going to
    level up your RxJS game. You’re going to create your own custom RxJS operator
    that just taps into any observable stream and logs the values on the console.
    We’ll call it the `logWithLabel` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter05/rx-custom-operator`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab. If you click the **Start Stream**
    button while you have the DevTools open, you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_05_12.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.12: The rx-custom-operator app running on http://localhost.4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s jump into the recipe steps in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re going to create a custom RxJS operator named `logWithLabel`, which will
    log the values of the observable stream on the console with a label.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file inside the `app` folder and name it `log-with-label.ts`.
    Then add the following code inside the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can import the `logWithLabel` operator from the `log-with-label.ts`
    file inside the `home/home.component.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And that’s it! If you refresh the app and click the **Start Stream** button,
    you can see the output using the `logWithLabel` operator, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_05_13.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.13: Logs using the logWithLabel custom RxJS operator'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See the next section to understand how it all works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A custom RxJS operator is a function that should take an observable source stream
    and return *something*. That *something* is usually an observable. In this recipe,
    we wanted to tap into the stream to log something on the console every time the
    stream emits a value. We also wanted to have a custom label for the logs for this
    stream. This is why we ended up creating the custom operator as a `factory` function
    that can take `label` as input, i.e., when we call the `logWithLabel` function
    (let’s call it `function A`), it returns a function (let’s call it `function B`)
    from within. The returned function (`B`) is what RxJS calls with the observable
    stream when we use the `logWithLabel` method inside the `pipe` function of the
    stream. Inside `function B`, we use the `tap` operator from RxJS to intercept
    the source observable and to log the values on the console using the `label` provided.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`tap` operator documentation ([https://rxjs.dev/api/operators/tap](https://rxjs.dev/api/operators/tap))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observable` documentation ([https://rxjs.dev/guide/observable](https://rxjs.dev/guide/observable))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrying failed HTTP calls with RxJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you’re going to learn how to retry HTTP calls smartly with RxJS
    operators. We’re going to use a technique called the **exponential backoff** technique.
    This means that we retry the HTTP calls but with each next call having a delay
    more than the previous time for the attempt, and we stop after several maximum
    tries. Sounds exciting? Let’s get into it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter05/rx-retry-http-calls`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project with the backend server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_05_14.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.14: The rx-retry-http-calls running on http://localhost.4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s jump into the recipe steps in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re going to create a custom RxJS operator named `backoff` that will retry
    the HTTP calls for us with the exponential `backoff` strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file inside the `app` folder and name it `retry-backoff.ts`. Then
    add the following code inside the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let’s use this operator in `app.component.ts` to retry the HTTP calls.
    Update the file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you refresh the app, you’ll notice that now we retry the HTTP calls. But
    all of the retries are done instantly (notice the **Waterfall** column), as shown
    in *Figure 5.15*. We don’t want that. We want every next try to be done with an
    increasing delay.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_05_15.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.15: Retrying HTTP calls multiple times instantly'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `retry-backoff.ts` file to add a delay using the `timer` operator
    and some calculations, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And that’s it! If you refresh the app, you’ll see that every next retry of
    the HTTP call has an increased delay compared to the previous one. Notice how
    far off the last HTTP call is in the **Waterfall** column (it is on the right
    edge of *Figure 5.16*):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_05_16.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.16: Retrying HTTP calls with exponential backoff'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See the next section to understand how it all works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `retry` operator has two overloads (at the time of writing this book). One
    of them takes `number` and RxJS will just have the observable retried the number
    of times equal to `number` (until it throws an exception). The other overload
    is that it takes a configuration object. In the configuration object, we’re using
    the `delay` function to handle our logic. The `delay` function receives `error`
    and the `retryCount` from RxJS, which we use to throw the error if we have already
    done our maximum tries or to pass forward `retryCount`. We get the maximum number
    of tries from our `retryBackoff` function’s arguments. Finally, we make the `map`
    and `mergeMap` opeartors work with `delay`. Using the `map` operator, we take
    a square of the `retryCount` variable’s value. And then, in the `mergeMap` operator,
    we multiply the square value with the delay provided to the `retryBackoff` function.
    As a result, every next request takes the delay equal to `((retryCount * retryCount)
    * delay)`. Notice that we’re using the `timer` function to have RxJS wait before
    it can retry the HTTP call again.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**RxJS custom operators** ([https://indepth.dev/posts/1421/rxjs-custom-operators](https://indepth.dev/posts/1421/rxjs-custom-operators))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exponential backoff** documentation ([https://angular.io/guide/practical-observable-usage#exponential-backoff](https://angular.io/guide/practical-observable-usage#exponential-backoff))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/AngularCookbook2e](Chapter_5.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1388317275422265.png)'
  prefs: []
  type: TYPE_IMG
