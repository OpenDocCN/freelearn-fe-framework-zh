- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Event and Data Handling in Vue.js
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue.js中的事件和数据处理
- en: Major frameworks have gained their popularity not only from their ability to
    break down big pages into small reusable components but also due to the simplicity
    with which these components can communicate with each other.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 主要框架不仅因其能够将大页面分解成小可重用组件的能力而受到欢迎，还因为它们可以以简单的方式相互通信。
- en: 'In this chapter, we are going to focus on how the data flows between different
    components. This exchange of information between components is handled in two
    different ways: parent to child with properties and child to parent with events.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注数据如何在不同的组件之间流动。组件之间的信息交换以两种不同的方式处理：通过属性从父组件到子组件，以及通过事件从子组件到父组件。
- en: We are going to start this chapter by introducing a few changes that have been
    committed in the Companion App since our last chapter. These modifications can
    be used as a good guide to help you develop your skills and consolidate what you
    have already learned. We are going to revisit properties by learning about more
    advanced techniques such as `validator` and `required` by creating our first reusable
    component in the form of a simple button. Then, we will learn how to handle native
    events such as `click` and `change`, and finally, introduce custom events that
    will allow our component to broadcast messages to the rest of the app.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始，介绍自上一章节以来在伴侣应用中提交的一些变化。这些修改可以用作一个好的指南，帮助你提高技能并巩固你已经学到的知识。我们将通过创建一个简单的按钮作为我们的第一个可重用组件，来重新审视属性，并学习更多高级技术，如`validator`和`required`。然后，我们将学习如何处理原生事件，如`click`和`change`，最后，介绍自定义事件，这将允许我们的组件向应用的其他部分广播消息。
- en: 'This chapter includes the following sections:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下部分：
- en: Exploring the Companion App changes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索伴侣应用的变化
- en: Deepening our knowledge of props
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解props
- en: Handling native events in Vue.js
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Vue.js中处理原生事件
- en: Connecting components with custom events
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义事件连接组件
- en: By the end of the chapter, you will have learned how to handle communication
    between multiple components. With this new knowledge, you should be able to move
    away from the individual components and start to think at a macro level by considering
    more complex application structures that include multiple components.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何处理多个组件之间的通信。有了这些新知识，你应该能够从单个组件转向宏观层面思考，考虑包含多个组件的更复杂的应用结构。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be able to follow this chapter, you should use a branch called `CH06`. To
    pull this branch, run the following command or use your GUI of choice to support
    you in this operation:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够跟随本章，你应该使用名为`CH06`的分支。要拉取此分支，请运行以下命令或使用你选择的GUI来支持此操作：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This branch is going to include a few changes. These will be explained in the
    first section of this chapter, but you can start and run the app to get familiar
    with its updated look and browse the repository.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分支将包括一些变化。这些变化将在本章的第一节中解释，但你也可以开始并运行应用，熟悉其更新的外观并浏览仓库。
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners)找到。
- en: Exploring the Companion App changes
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索伴侣应用的变化
- en: Until now, the Companion App had a very basic look and feel and its changes
    were completely made by the code that we wrote within the chapters, but things
    have changed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，伴侣应用的外观和感觉非常基础，其变化完全是由我们在章节中编写的代码所引起的，但情况已经改变。
- en: 'Let’s see how the application looks now:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看现在应用看起来是什么样子：
- en: '![Figure 6.1: Companion app with updated design and components](img/B21130_06_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1：更新设计和组件的伴侣应用](img/B21130_06_01.jpg)'
- en: 'Figure 6.1: Companion app with updated design and components'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：更新设计和组件的伴侣应用
- en: As you can observe in the previous screenshot, the Companion App has not only
    received a facelift with some updated styles but it also exhibits new components
    that will be used in the course of this and future chapters.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在前面的屏幕截图中所观察到的，伴侣应用不仅在外观上进行了更新，采用了新的样式，而且还展示了将在本章和未来章节中使用的新组件。
- en: These changes have been applied to be able to make the most of the book content,
    allowing us to focus on the new learning material without having to spend too
    much time creating the scaffolding and basic structure of components, but you
    should spend some time exploring the changes made and try to understand why and
    how things were implemented.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变更已被应用，以便充分利用书籍内容，使我们能够专注于新的学习材料，而无需花费太多时间创建组件的脚手架和基本结构，但你应该花一些时间探索所做的变更，并尝试理解为什么以及如何实现这些变更。
- en: All the changes and modifications that have been added since last chapter, use
    features that you have already been introduced to, and going through each change
    is a perfect exercise to enforce your learning.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 自上次章节以来添加的所有变更和修改都使用了你已经接触过的功能，逐一查看每个变更是一个完美的练习，可以加强你的学习。
- en: 'Two main groups of changes have been made to the app:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对应用进行了两组主要的变更：
- en: Folder and file changes
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件夹和文件变更
- en: Logic changes
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑变更
- en: Let’s look at these changes in detail, starting with the changes that affected
    folders and files.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细查看这些变更，从影响文件夹和文件的变更开始。
- en: Folders and file changes
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件夹和文件变更
- en: In the `CH06` branch, a few changes have taken place within the folders and
    files of the application. The changes were made to start to structure the app
    like a real production app, moving away from the simple “proof of concept” look
    and structure that the app had until now.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CH06`分支中，应用文件夹和文件中发生了一些变更。这些变更是为了开始将应用结构化，使其更像一个真实的生产应用，并远离应用至今为止简单的“概念证明”外观和结构。
- en: 'The changes made in the file structure are as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 文件结构所做的变更如下：
- en: Our first atom component with `TheLogo.vue` was added.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了第一个原子组件`TheLogo.vue`。
- en: In the previous chapter, the `SVG` element of the logo was hardcoded in the
    header of our Companion App. This has now been moved into its own file and it
    has been imported into `TheHeader.vue`.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上一章中，我们伴侣应用的logo的`SVG`元素被硬编码在头部。现在，它已经被移动到自己的文件中，并已导入到`TheHeader.vue`中。
- en: A sidebar called `SideBar.vue` was added to the UI.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在UI中添加了一个名为`SideBar.vue`的侧边栏。
- en: The layout of our app has been modified and we have added a new sidebar in the
    `organism` folder with the name `SideBar.vue`.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的应用布局已修改，并在`organism`文件夹中添加了一个名为`SideBar.vue`的新侧边栏。
- en: The ability to create posts with `CreatePost.vue` was scaffolded.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`CreatePost.vue`创建帖子的功能已搭建。
- en: The main container of our application now includes a new component aimed at
    creating new posts. This component just includes the HTML structure and some style,
    but it has no logic yet. The component can be found at `CreatePost.vue` in the
    `molecules` folder.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们应用的主要容器现在包含了一个旨在创建新帖子的新组件。这个组件只包括HTML结构和一些样式，但还没有逻辑。该组件位于`molecules`文件夹中的`CreatePost.vue`。
- en: We renamed `TheWelcome.vue` to `SocialPosts.vue`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`TheWelcome.vue`重命名为`SocialPosts.vue`。
- en: To better align our components with the newly updated layout, there was a need
    to remove the very generic `TheWelcome.vue` component and align it with the component
    structure. To do so, we have renamed the component `SocialPosts.vue` as it includes
    a list of social posts, and also moved it within the `molecules` folder.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了更好地将我们的组件与更新的布局对齐，需要移除非常通用的`TheWelcome.vue`组件，并将其与组件结构对齐。为此，我们将组件重命名为`SocialPosts.vue`，因为它包含了一系列社交帖子，并将其移动到`molecules`文件夹中。
- en: Now that we have found out about all the files and folder changes, it is time
    to see any code logic changes that may have been included in this update.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了所有文件和文件夹的变更，是时候查看可能包含在这个更新中的任何代码逻辑变更了。
- en: Logic changes
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑变更
- en: Just like the folder changes, the app has gone through a few modifications.
    These changes will align the app for future changes, and they also give you a
    glimpse of what it is like to work on a real project by adding more files and
    a more complex folder structure.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 就像文件夹变更一样，应用也经历了一些修改。这些变更将使应用适应未来的变更，并且通过添加更多文件和更复杂的文件夹结构，让你一窥在真实项目中工作的样子。
- en: 'If you were to finish this book with a repository that has a handful of components,
    you would not experience what it is like to work on a real application, and you
    will therefore fail to learn how to navigate the code base and, more importantly,
    structure your code base. For this reason, the app has been enhanced to have some
    more structures:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以包含少量组件的存储库结束这本书，你将无法体验到在真实应用中工作的感觉，因此你将无法学习如何导航代码库，更重要的是，如何结构化你的代码库。因此，应用被增强，以拥有更多的结构：
- en: 'Defining `homeView.vue`: At this moment in time, the application is a single
    page, but this will change later down the line. To start and align with those
    changes, we have started to define the `src`/`views`/`HomeViews.vue`) to include
    the sidebar, header, and main page body. This will allow us to create other pages
    in the future without the need to duplicate this structure.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义 `homeView.vue`：在这个时间点，应用程序是一个单页应用，但这一点会在以后发生变化。为了开始并适应这些变化，我们已经开始定义 `src/views/HomeViews.vue`
    以包括侧边栏、页眉和主页主体。这将允许我们在未来创建其他页面而无需重复此结构。
- en: 'Cleaning up the code in the header: The header file has been cleaned up. We
    removed the hardcoded logo and added a new icon next to the “Welcome” message.
    To complete the changes, we also added some styles to our components. Look at
    this file to remind yourself how to load external components.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理页眉中的代码：页眉文件已经被清理。我们移除了硬编码的标志，并在“欢迎”信息旁边添加了一个新图标。为了完成这些更改，我们还为我们的组件添加了一些样式。查看此文件以提醒自己如何加载外部组件。
- en: 'Making `SocialPost` render dynamic content with `v-for`: Up until now, `SocialPost`
    posts were individually and manually loaded in `SocialPosts.vue` (previously known
    as `TheWelcome.vue`). The rendering of multiple posts is now dynamic and it is
    handled by `v-for`. Using `v-for` has not only improved the readability of the
    component but also made it dynamic, allowing us to add `post` to our list without
    the need to manually change the HTML.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `v-for` 使 `SocialPost` 渲染动态内容：到目前为止，`SocialPost` 帖子是在 `SocialPosts.vue`（之前称为
    `TheWelcome.vue`）中单独和手动加载的。现在多个帖子的渲染是动态的，并由 `v-for` 处理。使用 `v-for` 不仅提高了组件的可读性，还使其动态化，允许我们无需手动更改
    HTML 就可以将 `post` 添加到我们的列表中。
- en: '![Figure 6.2: Git differences between the hardcoded version of SocialPost and
    the one using v-if](img/B21130_06_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2：SocialPost 的硬编码版本与使用 v-if 的版本之间的 Git 差异](img/B21130_06_02.jpg)'
- en: 'Figure 6.2: Git differences between the hardcoded version of SocialPost and
    the one using v-if'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2：SocialPost 的硬编码版本与使用 v-if 的版本之间的 Git 差异
- en: We have now finished explaining both the structural and logical changes included
    in this chapter. Before we move forward, there is one small detail that I want
    to mention and it is about the `:``key` property.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经解释了本章中包含的结构和逻辑更改。在我们继续前进之前，有一个小细节我想提到，那就是关于 `:key` 属性的。
- en: If you carefully check the previous screen, you will notice that the new version
    of the code (the right-hand side) has an extra property called `:key`. This property
    is a requirement when using `v-for` with Vue components.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细检查之前的屏幕，你会注意到新版本的代码（右侧）有一个额外的属性叫做 `:key`。这个属性在使用 Vue 组件的 `v-for` 时是必需的。
- en: The key value is used by the framework to prevent unnecessary re-rendering of
    the full list. In fact, Vue.js uses this attribute to keep track of which specific
    component instance changed and just update a specific node instead of the full
    list.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 键值被框架用来防止整个列表的不必要重新渲染。实际上，Vue.js 使用这个属性来跟踪哪个特定的组件实例已更改，并只更新特定的节点而不是整个列表。
- en: So, going forward, every time you use the `v-for` directives, you should remember
    to also set a unique key using `:key`. This is usually raised as a warning by
    linting tools. Providing this value helps Vue.js identify all the different nodes
    that it creates with `v-for`, and speeds up re-rendering if any of it changes.
    You should try to define a key whenever possible, unless the DOM created is very
    simple.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在前进的过程中，每次你使用 `v-for` 指令时，都应该记得使用 `:key` 设置一个唯一的键。这通常会被代码检查工具作为警告提出。提供这个值有助于
    Vue.js 识别它使用 `v-for` 创建的所有不同节点，并在其中任何一项发生变化时加快重新渲染的速度。你应该尽可能定义一个键，除非创建的 DOM 非常简单。
- en: Avoid using an array index
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用数组索引
- en: It is very common to see the array index being used as the `:key` value for
    a `v-for` loop. Unfortunately, this is a very bad practice as the index will change
    if an array item is removed, forcing Vue.js to re-render the full list and possibly
    produce bugs that are hard to spot.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见的是看到数组索引被用作 `v-for` 循环的 `:key` 值。不幸的是，这是一个非常不好的做法，因为如果移除数组项，索引将会改变，迫使 Vue.js
    重新渲染整个列表，并可能产生难以发现的错误。
- en: We are now up to speed with all the changes we have made. As mentioned previously,
    you should spend a few minutes familiarizing yourself with the changes and understand
    what was done and why.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经熟悉了我们所做的所有更改。如前所述，你应该花几分钟熟悉这些更改，并了解所做的工作及其原因。
- en: In the next section, we are going to start our journey with data flows and look
    closely at properties. This subject was already introduced in the previous chapter
    but it has more to offer, and it is time to learn about it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始我们的数据流之旅，并仔细研究属性。这个主题已经在上一章中介绍过，但它还有更多内容，现在是学习它的时候了。
- en: Deepening our knowledge of props
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解属性
- en: In [*Chapter 3*](B21130_03.xhtml#_idTextAnchor039), we introduced and started
    to use properties as a way to pass information from a component to its children.
    As our understanding of Vue.js is widening, it is time to expand our knowledge
    of this basic feature.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B21130_03.xhtml#_idTextAnchor039)中，我们介绍了并开始使用属性作为从组件传递信息到其子组件的方式。随着我们对Vue.js理解的加深，是时候扩展我们对这个基本功能的知识了。
- en: 'Just as a quick recap, so far, we have learned that properties (props) are
    defined using the `defineProps` compiler macro, like so:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 就像快速回顾一样，到目前为止，我们已经了解到属性（props）是通过`defineProps`编译器宏定义的，如下所示：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Doing so will allow our component to accept a prop called `name` of type `String`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做将允许我们的组件接受一个名为`name`的`String`类型属性：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this section, we are going to learn what other configurations properties
    have to offer. The ability to define a props type is not the only configuration
    available.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习属性还有哪些其他配置可以提供。定义属性类型的能力并不是唯一的配置。
- en: Props configurations
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性配置
- en: In most cases, just configuring a prop type, as previously shown, is more than
    enough, but there are times when fine control is needed, and the following configuration
    will help you.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，只需配置属性类型，如之前所示，就足够了，但有时需要精细控制，以下配置将有助于你。
- en: 'The syntax we used to declare properties has a name followed by the expected
    type, `PropsName: Type`, but to be able to use advanced configuration, we need
    to change the props to accept an object. So, the example that we provided before
    of `name: String` in object syntax will be as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '我们用来声明属性的语法是一个名称后跟期望的类型，`PropsName: Type`，但为了能够使用高级配置，我们需要将属性更改为接受一个对象。因此，我们之前提供的`name:
    String`在对象语法的示例将如下所示：'
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that the properties have an object, we can add extra configuration.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在属性有了对象，我们可以添加额外的配置。
- en: Multiple types
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多种类型
- en: 'A Vue.js prop can accept multiple types. To do so, we can just define the types
    as an array:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js属性可以接受多种类型。要做到这一点，我们只需将类型定义为数组：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Setting required properties
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置必需属性
- en: There are two types of properties, `required` or `optional`. Out of the box,
    all properties are set to be `optional` by the framework and this is done on purpose
    to align with the way native HTML handles attributes (e.g., `disabled` or `readonly`).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 属性有两种类型，`required`或`optional`。默认情况下，框架将所有属性设置为`optional`，这是故意的，以与原生HTML处理属性的方式保持一致（例如，`disabled`或`readonly`）。
- en: 'When developing components, you should always ask yourself whether the component
    can be rendered without the value of a prop value, and if not, make sure you set
    the prop as `required`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发组件时，你应该始终问自己组件是否可以在没有属性值的情况下渲染，如果不能，请确保将属性设置为`required`：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When a prop is required, if a user tries to implement the component without
    it, the component will throw an error and, in some cases, not render the component
    at all, depending on your settings.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个属性是必需的，如果用户尝试不传递它来实现组件，组件将抛出错误，在某些情况下，根据你的设置，甚至可能根本不渲染组件。
- en: Setting a properties fallback with a default value
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用默认值设置属性回退
- en: When a prop is set to `optional` and it is not passed, the component will give
    it an `undefined` value. This is okay for most cases, but there are situations
    in which you would like the properties to have a fallback value.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个属性被设置为`optional`且未传递时，组件将给它一个`undefined`值。这在大多数情况下是可以的，但有时你可能希望属性有一个回退值。
- en: 'It is common for beginner developers to achieve this using `v-if` in the HTML:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者开发者来说，使用HTML中的`v-if`来实现这一点是很常见的：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This solution is very verbose and should be replaced with a default prop value:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案非常冗长，应该用默认属性值替换：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When the `welcomeMsg` prop is not passed, the component will render the `Welcome`
    string. Our HTML can now be clean for logic:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当`welcomeMsg`属性未传递时，组件将渲染`Welcome`字符串。现在我们的HTML可以更干净地用于逻辑：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Arrays and object default initialization
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和对象的默认初始化
- en: 'Objects and arrays have a different syntax for `default` and must be returned
    by a factory function: `default: () => []` or `default: () => {}`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '对象和数组对于`default`有不同的语法，必须由工厂函数返回：`default: () => []`或`default: () => {}`。'
- en: Validating your properties
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证你的属性
- en: The last configuration that we are going to introduce is the ability to validate
    the value received. This is extremely helpful when your prop can just accept a
    specific set of values or if they have to be formatted in a specific way. A validator
    is a function that receives an argument equal to the prop value and is expected
    to return `true` to mark the validation or `false` to invalidate the validation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的最后一个配置是验证接收到的值的能力。这在你的属性只能接受一组特定值或它们必须以特定方式格式化时非常有用。验证器是一个接收等于属性值的参数的函数，并期望返回`true`以标记验证或返回`false`以使验证无效。
- en: 'So, for example, if we want to create a prop that can just accept two strings,
    `light` or `dark`, we would set the `validator` function as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想创建一个只能接受两个字符串`light`或`dark`的属性，我们将设置`validator`函数如下：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With the preceding lines of code, our component props, `theme`, will just accept
    these two values. If the wrong value is passed, the component will not render
    and will throw an error.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的代码行，我们的组件属性`theme`将只接受这两个值。如果传递了错误的值，组件将不会渲染并抛出错误。
- en: Creating a basic button
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个基本按钮
- en: To put everything that we have learned into practice, we are going to create
    a simple base button. Base components, such as the one offered by component libraries,
    accept multiple properties and are usually the best fit to utilize advanced properties
    settings.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们所学的一切付诸实践，我们将创建一个简单的基按钮。基础组件，如由组件库提供的组件，接受多个属性，通常是利用高级属性设置的最好选择。
- en: 'Our button is going to have the following features:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的按钮将具有以下功能：
- en: It will *require* a value that can be a string or number
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将需要可以是一个字符串或数字的值
- en: If will have an `optional` prop of `width` that defaults to `100px`
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将有一个`optional`的`width`属性，默认为`100px`
- en: It will have an `optional` theme that only accepts a `light` or `dark` value
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将有一个`optional`主题，只接受`light`或`dark`值
- en: 'The new button can be found in the `atoms` folder under the name `TheButton.vue`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 新的按钮可以在`atoms`文件夹下以`TheButton.vue`的名称找到：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The file is mostly defined. Its HTML includes a `button` element with placeholders
    for our properties and styles ready to accommodate our prop value. All that is
    left for this component is to define its properties. Before reading the following
    solution, try and use the preceding information to define the props by yourself.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 文件基本上已经定义。其HTML包括一个`button`元素，其中包含我们属性和样式的占位符，准备好容纳我们的属性值。这个组件剩下的只是定义其属性。在阅读以下解决方案之前，尝试使用前面的信息自己定义属性。
- en: 'When fully defined, the defined props should look like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当完全定义后，定义的属性应该看起来像这样：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Prop configurations are extremely powerful and so simple to use. Using them
    correctly can help save many lines of code in your template and will help you
    make your component more robust.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 属性配置非常强大且易于使用。正确使用它们可以帮助在模板中节省许多行代码，并有助于使组件更加健壮。
- en: In this section, we have learned how to use prop configurations and created
    a base button to help us understand its real usage. We learned how to provide
    multiple types, how to set a prop as `required`, how to define a default value,
    and last but not least, how to validate it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用属性配置并创建了一个基础按钮来帮助我们理解其实际用法。我们学习了如何提供多种类型，如何设置属性为`required`，如何定义默认值，以及最后但同样重要的是，如何验证它。
- en: 'In the next section, we will start to move our attention to another part of
    data handling: events. Events are used by children components to communicate with
    their parent component. We are going to first introduce the native element and
    then move on to define custom elements.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始将注意力转移到数据处理的其他部分：事件。事件被子组件用来与父组件通信。我们将首先介绍原生元素，然后继续定义自定义元素。
- en: Handling native events in Vue.js
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Vue.js中处理原生事件
- en: Since JavaScript’s inception, events have always played a vital role in the
    success of this programming language. For this reason, all JavaScript frameworks
    have made sure they offer a strong solution to handle native and custom events.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript的诞生，事件始终在编程语言的成功中扮演着至关重要的角色。因此，所有JavaScript框架都确保它们提供强大的解决方案来处理原生和自定义事件。
- en: We refer to native events as the ones built in HTML elements and APIs such as
    a `click` event triggered by `<button>`, a `change` event triggered by `<select>`,
    or a `load` event triggered by `<img>`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将原生事件称为内置在HTML元素和API中的事件，例如由`<button>`触发的`click`事件，由`<select>`触发的`change`事件，或由`<img>`触发的`load`事件。
- en: Just like with props and directives, Vue.js event handling seamlessly merges
    with the existing native syntax to handle events offered by HTML elements. In
    native HTML, all events handlers are prefixed with the word `on`, so a `click`
    event becomes `onclick` and a `change` event becomes `onchange`. Vue.js follows
    this convention by creating a directive (which, as we know, starts with `v-`)
    called `v-on`. So a `click` event in Vue is handled using `v-on:click` and a `change`
    event is listened to by using `v-on:change`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 就像与 props 和指令一样，Vue.js 事件处理无缝地与现有的原生语法结合，以处理 HTML 元素提供的事件。在原生 HTML 中，所有事件处理器都以
    `on` 字符开头，所以一个 `click` 事件变为 `onclick`，一个 `change` 事件变为 `onchange`。Vue.js 通过创建一个以
    `v-` 开头的指令（正如我们所知）来遵循这个约定，即 `v-on`。因此，Vue 中的 `click` 事件使用 `v-on:click` 处理，而 `change`
    事件使用 `v-on:change` 监听。
- en: You have probably noticed that this is not the syntax that we used in the code
    base so far. In fact, if you open up `SocialPost.vue`, you will notice that we
    used a different syntax where the event is prefixed with the `@` symbol.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了，这并不是我们在代码库中迄今为止使用的语法。实际上，如果你打开 `SocialPost.vue`，你会注意到我们使用了不同的语法，其中事件以
    `@` 符号作为前缀。
- en: This is just a nice shorthand provided by the Vue.js framework. Using the `@`
    sign not only simplifies the actual writing of the events but is also clearly
    marked as different from other directives.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是 Vue.js 框架提供的一个简洁的缩写。使用 `@` 符号不仅简化了事件的实际编写，而且与其他指令明显区分开来。
- en: 'Let’s see how these different methods would look when applied to `<button>`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些不同的方法在应用于 `<button>` 时会是什么样子：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Even if the syntax is not completely the same, it is very similar and intuitive
    to use.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 即使语法不完全相同，使用起来也非常相似且直观。
- en: There is a small difference to notice. In fact, in the native method to handle
    events, the method that is passed to `onclick` is actually called `onclick="method()"`,
    while in the Vue.js case, the methods are not called and they are just passed
    as a reference to the method name that will later be called by the framework engine,
    `@click="method`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个小的差异需要注意。实际上，在原生处理事件的方法中，传递给 `onclick` 的方法实际上被调用为 `onclick="method()"`，而在
    Vue.js 的情况下，方法不会被调用，它们只是作为方法名称的引用传递给框架引擎，即 `@click="method"`。
- en: 'It is time to make some changes to the code base by opening up `SideBar.vue`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候通过打开 `SideBar.vue` 来对代码库进行一些修改了：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This file is the one responsible for the new sidebar being displayed in our
    layout. This component includes a couple of elements and buttons that will be
    used as learning material in the course of this and future chapters.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件负责在我们布局中显示新的侧边栏。该组件包含一些元素和按钮，这些元素和按钮将在本章节和未来的章节中作为学习材料使用。
- en: For this section, we are going to focus on the current time displayed on the
    screen. More specifically, we are going to create the ability to update this time
    at the click of a button.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，我们将关注屏幕上显示的当前时间。更具体地说，我们将创建一个在点击按钮时更新这个时间的能力。
- en: Handling events is achieved in two steps. First, we create a method that includes
    all the logic to trigger the event, and then we attach this to the HTML.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 处理事件分为两个步骤。首先，我们创建一个包含触发事件所需所有逻辑的方法，然后将它附加到 HTML 上。
- en: 'Let’s create the method first:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建这个方法：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With the preceding change, clicking the button labeled **Update Time** will
    update the current time shown on the screen. Let’s break down how we achieved
    this.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的修改，点击标记为 **更新时间** 的按钮将更新屏幕上显示的当前时间。让我们分析一下我们是如何实现这一点的。
- en: First, we create a method for our event logic. This method is going to be prefixed
    with the word `on` followed by an identifier of the actual event – for example,
    `updateTimeClick` – generating a name equal to `onUpdateTimeClick`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为事件逻辑创建一个方法。这个方法将以 `on` 字符开头，后面跟着实际事件的标识符——例如，`updateTimeClick`——生成一个名为
    `onUpdateTimeClick` 的名称。
- en: The logic of this particular event is quite simple, but as we learned in the
    previous chapter, methods can be complex and also have side effects, so there
    is no limit to what an event can achieve.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定事件的逻辑相当简单，但正如我们在上一章所学，方法可以是复杂的，也可能有副作用，因此事件可以实现的目标没有限制。
- en: Next, we add the `click` directive in the HTML. We can either use `v-on:click`
    or `@click`. This will automatically link our Vue method with the native `click`
    event.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在 HTML 中添加 `click` 指令。我们可以使用 `v-on:click` 或 `@click`。这将自动将我们的 Vue 方法与原生的
    `click` 事件链接起来。
- en: 'This example should not have been too different from the one that we already
    covered in the earlier chapters, but event handling does not stop here. In fact,
    there are two important concepts that we need to learn about: event modifiers,
    which we are going to introduce right now, and event parameters, which will be
    covered later in the chapter.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子不应该与我们在早期章节中已经覆盖的例子有太大不同，但事件处理并没有停止。事实上，我们需要了解两个重要的概念：事件修饰符，我们现在将介绍，以及稍后在本章中将要介绍的参数。
- en: Event modifiers
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件修饰符
- en: While working with events in JavaScript, it is very common to modify the event
    by either preventing the default behavior (`event.preventDefault()`) or stopping
    the propagation of the event (`event.stopPropagation()`).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用JavaScript处理事件时，通过阻止默认行为（`event.preventDefault()`）或停止事件传播（`event.stopPropagation()`）来修改事件是非常常见的。
- en: This is where the event modifier comes into place. Vue.js offers us a simple
    syntax to trigger these logics directly from the HTML without the need to navigate
    through the event object.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是事件修饰符发挥作用的地方。Vue.js为我们提供了一个简单的语法，可以直接从HTML中触发这些逻辑，而无需通过事件对象进行导航。
- en: Vue.js offers many modifiers – from event modifiers (such as `.prevent`, `.stop`,
    and `.once`) to keyboard modifiers that allow you to listen to a specific button
    (such as `.enter`, `.tab`, and `.space`) and, finally, to mouse modifiers that
    allow you to trigger events on a specific mouse press with `.left`, `.right`,
    and `.middle`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js提供了许多修饰符——从事件修饰符（如`.prevent`、`.stop`和`.once`）到允许您监听特定按钮（如`.enter`、`.tab`和`.space`）的键盘修饰符，最后是允许您通过`.left`、`.right`和`.middle`触发特定鼠标点击事件的鼠标修饰符。
- en: 'Let’s break down the syntax of a Vue directive:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解Vue指令的语法：
- en: '![Figure 6.3: Breakdown of syntax for a Vue directive](img/B21130_06_03.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3：Vue指令的语法分解](img/B21130_06_03.jpg)'
- en: 'Figure 6.3: Breakdown of syntax for a Vue directive'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：Vue指令的语法分解
- en: 'A directive in Vue.js is made up of four main sections:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js中的指令由四个主要部分组成：
- en: The name of the directive – for example, `v-on`, `v-if`, or `@` if using the
    available shorthand.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令的名称——例如，`v-on`、`v-if`，或者在使用可用的缩写时使用`@`。
- en: An argument, such as `click` for a `click` event, or the name of a prop.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，对于`click`事件使用`click`，或者属性的名称。
- en: A modifier such as `prevent` or `stop`.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如`prevent`或`stop`这样的修饰符。
- en: The actual value required by the directives. In the case of an event handler,
    the value would be the function that is run when the event is triggered, while
    in the case of props, the value would be a simple variable.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令实际需要的值。在事件处理程序的情况下，值将是当事件被触发时运行的函数，而在属性的情况下，值将是一个简单的变量。
- en: Event modifiers are appended to the event directive, so, for example, for `preventDefault`,
    you would write `@click.prevent="methodName"`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 事件修饰符附加到事件指令上，所以例如，对于`preventDefault`，您将写`@click.prevent="methodName"`。
- en: Learning about all of these modifiers is out of the scope of this book as some
    of them (such as `capture` and `passive`) have very specific usage that is not
    always required. If you want to learn more, you can get more details in the Vue.js
    official documentation ([https://vuejs.org/guide/essentials/event-handling#event-modifiers](https://vuejs.org/guide/essentials/event-handling#event-modifiers)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 了解所有这些修饰符超出了本书的范围，因为其中一些（如`capture`和`passive`）有非常具体的用法，并不总是必需的。如果您想了解更多信息，可以在Vue.js官方文档中找到更多细节（[https://vuejs.org/guide/essentials/event-handling#event-modifiers](https://vuejs.org/guide/essentials/event-handling#event-modifiers)）。
- en: 'Before moving on, we are going to try and use one of these modifiers in our
    application: `.once`. This modifier prevents our event handler from being triggered
    more than once. This is very useful when you have actions that can just be performed
    once, for example, saving a new entry or updating a table row.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们将尝试在我们的应用程序中使用这些修饰符之一：`.once`。这个修饰符可以防止事件处理器被触发多次。当您有只能执行一次的操作时，这非常有用，例如，保存新条目或更新表格行。
- en: 'We are going to apply this to the same `click` event that we recently wrote.
    By doing so, we will just be able to update the current time once, as clicking
    the button multiple times will not perform any action:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用这个方法到我们最近写的同一个`click`事件上。通过这样做，我们只能更新一次当前时间，因为多次点击按钮不会执行任何操作：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The usage of the modifier is quite simple, as we have just shown. All we needed
    to do to prevent the event from being triggered more than once was add the word
    `.once` after our event directive.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符的使用非常简单，正如我们刚才所展示的。我们只需要在事件指令后添加单词 `.once`，以防止事件被触发多次。
- en: Modifiers are not just for events but for all directives
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符不仅用于事件，也用于所有指令
- en: The ability to provide a modifier to a directive, as shown previously, is not
    exclusive to events; in fact, modifiers are a feature available to directives
    in general. The only built-in directive to have modifiers is `v-on`, but you can
    create your own custom directive or use an external package that could have its
    own modifiers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，向指令提供修饰符的能力并不仅限于事件；实际上，修饰符是所有指令都可用的一项功能。唯一具有修饰符的内建指令是 `v-on`，但你可以创建自己的自定义指令或使用外部包，该包可能有自己的修饰符。
- en: After this brief introduction of native events, it is time to learn about custom
    events and how they can be used to broadcast messages between components.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在对原生事件做了简要介绍之后，现在是时候学习自定义事件以及它们如何用于在组件之间广播消息了。
- en: Connecting components with custom events
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义事件连接组件
- en: Frameworks such as Vue.js allow us to break down our application into very small
    components, sometimes as small as a single HTML element. This would not be possible
    without a strong communication system.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如 Vue.js 这样的框架允许我们将应用程序分解成非常小的组件，有时甚至小到单个 HTML 元素。没有强大的通信系统，这是不可能的。
- en: Native HTML elements offer events as a way for them to trigger actions and pass
    information to their parents, and Vue.js components use a very similar pattern
    by offering custom events.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 原生 HTML 元素提供事件作为它们触发动作和向父元素传递信息的方式，Vue.js 组件通过提供自定义事件使用一个非常相似的模式。
- en: Custom events are not something new, as they have been around JavaScript for
    quite some time, but they are usually very verbose to use in vanilla JavaScript,
    whereas with Vue.js, creating, emitting, and listening to custom events feels
    easy and intuitive. Let’s see how these are defined and used.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义事件并不是什么新鲜事物，因为它们在 JavaScript 中已经存在了一段时间，但它们在纯 JavaScript 中通常使用起来非常冗长，而使用
    Vue.js，创建、发出和监听自定义事件则感觉既简单又直观。让我们看看这些是如何定义和使用的。
- en: 'To learn about custom events, we are going to modify the Companion App by adding
    the ability for the user to delete a post:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解自定义事件，我们将通过添加用户删除帖子的功能来修改伴侣应用：
- en: '![Figure 6.4: Diagram displaying the flow of data between parent and child
    components](img/B21130_06_04.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4：显示父组件和子组件之间数据流的流程图](img/B21130_06_04.jpg)'
- en: 'Figure 6.4: Diagram displaying the flow of data between parent and child components'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4：显示父组件和子组件之间数据流的流程图
- en: As visualized by the preceding diagram, properties such as `Posts` are used
    by the parent to send information to the child. On the other hand, events are
    used for the child to emit information to the parent.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，属性如 `Posts` 由父组件用于向子组件发送信息。另一方面，事件用于子组件向父组件发出信息。
- en: In the example illustrated in *Figure 6**.4*, the `SocialPosts.vue` file sends
    a list of social posts to the child, and the child uses a custom event called
    `delete` to ask the parent to delete a post.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 *6**.4* 中所示的示例中，`SocialPosts.vue` 文件向子组件发送一系列社交帖子，子组件使用名为 `delete` 的自定义事件请求父组件删除帖子。
- en: 'Let’s see how to implement this custom event in the `SocialPost.vue` file.
    The first step requires us to trigger a native `click` event when the *delete*
    icon is clicked. Just as we did in the previous section, we achieve this by adding
    the `@click` directive in the HTML:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 `SocialPost.vue` 文件中实现这个自定义事件。第一步需要我们在点击 *删除* 图标时触发一个原生的 `click` 事件。就像我们在上一节中所做的那样，我们通过在
    HTML 中添加 `@click` 指令来实现这一点：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We then add the `onDeleteClick` method in the `<``script>` tag:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在 `<script>` 标签中添加 `onDeleteClick` 方法：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we need to define the event and trigger it when `onDeleteClick` is triggered:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义事件，并在 `onDeleteClick` 被触发时触发它：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We define emits using a compiler macro called `defineEmits`. This follows the
    same syntax of `defineProps` as it accepts an array of events that can be emitted
    by the component. In our case, we just defined one event of `delete`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个名为 `defineEmits` 的编译器宏来定义 emits。这与 `defineProps` 的语法相同，因为它接受一个可以由组件发出的事件的数组。在我们的例子中，我们只定义了一个
    `delete` 事件。
- en: '`defineEmits` returns a function that can be used to trigger our events. It
    is suggested to name this constant `emit` to align with the native `$emit` method
    available in Vue.js.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`defineEmits` 返回一个函数，可以用来触发我们的事件。建议将这个常量命名为 `emit`，以与 Vue.js 中可用的原生 `$emit`
    方法保持一致。'
- en: This function accepts two arguments. The first is the event name, and the second
    is just a parameter that will be passed to whoever listens to the event. In our
    case, this was defined with `emit('delete')`, where `delete` was our custom event
    name.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受两个参数。第一个是事件名称，第二个是传递给事件监听者的参数。在我们的例子中，这是通过 `emit('delete')` 定义的，其中 `delete`
    是我们的自定义事件名称。
- en: 'Now that the child custom event is fully set, it is time to ensure that the
    parent is listening to the event. Let’s go over `SocialPosts.vue` and put our
    skills to use:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在子自定义事件已经完全设置，是时候确保父组件正在监听这个事件了。让我们回顾一下 `SocialPosts.vue` 并运用我们的技能：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Listening to a custom event in Vue.js is no different from listening to a native
    event. In fact, both use the `v-on` (or `@`) directive, as shown by `@delete="onDelete"`.
    This code, just like other event listeners, will wait for the event to be triggered
    before running the provided function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue.js 中监听自定义事件与监听原生事件没有区别。事实上，两者都使用 `v-on`（或 `@`）指令，如 `@delete="onDelete"`
    所示。就像其他事件监听器一样，这段代码将等待事件被触发后再运行提供的函数。
- en: The method triggered by the event is called `onDelete` and uses plain JavaScript
    to remove the item from the `Posts` object. If we tried the current code, we would
    see that the functionality works as expected and the first post is deleted when
    the *delete* icon is clicked.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由事件触发的方法称为 `onDelete`，并使用纯 JavaScript 从 `Posts` 对象中删除项目。如果我们尝试当前的代码，我们会看到功能按预期工作，并且在点击
    *删除* 图标时删除了第一个帖子。
- en: This is great but not perfect, as we would like to choose which post to delete
    instead of hardcoding this to be the first post. To fix this bug, we would have
    to add an argument to define which one is the correct post to delete when declaring
    our custom event.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但还不够完美，因为我们希望选择要删除的帖子，而不是将这个值硬编码为第一个帖子。为了修复这个错误，我们必须在声明我们的自定义事件时添加一个参数来定义要删除的正确帖子。
- en: Event arguments
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件参数
- en: Until this moment, all the events that have been handled in the Companion App
    required access to neither the event object nor the external argument.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 直到这一刻，在伴侣应用中处理的所有事件都不需要访问事件对象或外部参数。
- en: Now, we are going to learn how you could expand your event handler to accept
    these extra values.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习如何扩展事件处理程序以接受这些额外的值。
- en: Since the methods attached to an event have access to all reactive data of a
    component, you may think that passing arguments may not be extremely useful, but
    this is not the case.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于附加到事件的方法可以访问组件的所有响应式数据，你可能会认为传递参数可能不是非常有用，但这并不是事实。
- en: In fact, arguments are extremely helpful when triggering an event from an element
    that is using `v-for` – just like in our case, in which we need to inform our
    event of the `post` index. Having access to the correct value of the post that
    is triggering the event is vital for the functionality to run correctly.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，当从使用 `v-for` 的元素中触发事件时，参数非常有用——就像在我们的例子中，我们需要通知事件 `post` 索引。访问触发事件的帖子的正确值对于功能正确运行至关重要。
- en: To be able to delete the correct post, we first need to add the value of the
    `post` index when triggering the event handler and then ensure that this value
    is read and used by the method.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够删除正确的帖子，我们首先需要在触发事件处理程序时添加 `post` 索引的值，然后确保这个值被读取并用于方法中。
- en: 'Let’s make the `post` index available by exposing it within `v-for`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过在 `v-for` 中暴露它来使 `post` 索引可用：
- en: '[PRE20]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, add the index to the event declaration:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将索引添加到事件声明中：
- en: '[PRE23]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, add the `postIndex` argument in the event handler:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在事件处理程序中添加 `postIndex` 参数：
- en: '[PRE30]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After these three modifications, we should be able to delete the correct post
    from our Companion App.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这三次修改后，我们应该能够从我们的伴侣应用中删除正确的帖子。
- en: Getting access to the events native object with $event
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `$event` 获取事件原生对象
- en: 'Event handlers have access to a special argument called `$event`. This is passed
    automatically to all events that have no argument or can be passed directly from
    the HTML when passing custom parameters: `<button @click="handler($event,` `customParameter)
    />"`.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理程序可以访问一个名为 `$event` 的特殊参数。这个参数自动传递给所有没有参数或可以直接从 HTML 传递自定义参数的事件：`<button
    @click="handler($event, customParameter) />"`。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have revisited previously learned topics by analyzing the
    changes in the Companion App. We then expanded our knowledge of props by introducing
    all their possible options. Next, we moved on to event handling by explaining
    how to use native HTML events within Vue.js components before closing the chapter
    with the definition of a custom event handler and how this can be used to flow
    information between components.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过分析伴侣应用程序中的变化，回顾了之前学过的主题。然后，通过介绍所有可能的选项，我们扩展了对props的知识。接下来，我们转向事件处理，解释了如何在Vue.js组件中使用原生HTML事件，并在本章结束时定义了自定义事件处理程序以及如何使用它来在组件之间传递信息。
- en: You should now be able to create and use custom events. With this knowledge,
    plus the additional knowledge on props, you should be able to work on larger applications
    that have multiple components. You should also make use of the changes that have
    been made in the Companion App to learn how to navigate the new code base.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够创建和使用自定义事件。有了这些知识，再加上关于props的额外知识，你应该能够处理具有多个组件的更大应用程序。你还应该利用在伴侣应用程序中做出的更改，学习如何导航新的代码库。
- en: In the next chapter, we are going to continue to build on the topic of “increase
    scope” by removing the hardcoded values, starting to use external APIs, learning
    how to handle side effects by watching for value changes, and overcoming the limitation
    of computed properties. These changes will increase the complexity of our application
    even further, while at the same time, providing us with a vital skill to increase
    our knowledge of the Vue.js framework.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过移除硬编码的值、开始使用外部API、通过观察值变化来学习如何处理副作用，以及克服计算属性的局限性，继续围绕“增加范围”这一主题进行构建。这些变化将进一步增加我们应用程序的复杂性，同时，也为我们提供了增加对Vue.js框架知识的重要技能。
