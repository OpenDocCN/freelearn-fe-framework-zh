- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RESTful APIs and Full-Stack Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 1*, *Introduction to Angular and Its Concepts*, I introduced you
    to the wider architecture in which web applications exist. The choices that are
    made in full-stack architecture can profoundly impact the success of your web
    application. You simply cannot afford to be ignorant of how the APIs you interact
    with are designed. In this chapter, we are going to cover how to implement a backend
    for your frontend using Node, Express, and Mongo. Combined with Angular, this
    stack of software is referred to as the MEAN stack.
  prefs: []
  type: TYPE_NORMAL
- en: My take on the MEAN stack is minimal MEAN, which prioritizes ease of use, happiness,
    and effectiveness, the main ingredients for a great **developer experience** (**DX**).
    To keep up with the theme, we'll implement the LemonMart server. This server will
    round out JWT auth from *Chapter 8*, *Designing Authentication and Authorization*.
    In addition, the server will support recipes that I am going to cover in *Chapter
    11*, *Recipes – Reusability, Routing, and Caching*, and *Chapter 12*, *Recipes
    – Master/Detail, Data Tables, and NgRx*.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers a lot of ground. It is designed to serve as a roadmap to
    the GitHub repository ([https://github.com/duluca/lemon-mart-server](https://github.com/duluca/lemon-mart-server)).
    I cover the architecture, design, and major components of the implementation.
    I highlight important pieces of code to explain how the solution comes together.
    However, unlike prior chapters, you cannot solely rely on the code sample provided
    in the text to complete your implementation. For the purposes of this book, it
    is more important that you understand why we are implementing various functionality
    over having a strong grasp of the implementation details. So, for this chapter,
    I recommend that you read and understand the server code versus trying to recreate
    it on your own.
  prefs: []
  type: TYPE_NORMAL
- en: You will need to take action towards the end of the chapter to implement a custom
    auth provider in your Angular app to authenticate against **lemon-mart-server**
    and also leverage Postman to generate test data, which will be useful in later
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: We begin by covering full-stack architecture, covering lemon-mart-server's monorepo
    design and how you can use Docker Compose to run a three-tier application with
    a web app, server, and a database. Then, we go over RESTful API design and documentation,
    leveraging the OpenAPI specification using [Swagger.io](http://Swagger.io), and
    implementation using Express.js. Then, we cover the implementation of a MongoDB
    **object document mapper** (**ODM**) using my DocumentTS library to store users
    with login credentials. We implement a token-based auth function and use it to
    secure our APIs. Finally, we leverage Postman to generate test data in our database
    using the APIs we have developed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Full-stack architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RESTful APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB ODM with DocumentTS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing JWT auth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating users with Postman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most up-to-date versions of the sample code for the book can be found on
    GitHub at the repository linked below. The repository contains the final and completed
    state of the code. This chapter requires Docker and Postman applications.
  prefs: []
  type: TYPE_NORMAL
- en: It is critical that you get **lemon-mart-server** up and running on your development
    environment and have **lemon-mart** communicate with it. Refer to the instructions
    documented here or in the `README` on GitHub to get your server up and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of this *chapter*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the **lemon-mart-server** repository using the `--recurse-submodules`
    option: `git clone --recurse-submodules` [https://github.com/duluca/lemon-mart-server](https://github.com/duluca/lemon-mart-server
    )'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the VS Code terminal, execute `cd web-app; git checkout master` to ensure
    that the submodule from [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
    is on the master branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Later, in the *Git submodules* section, you can configure the `web-app` folder
    to pull from your lemon-mart server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Execute `npm install` on the root folder to install dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that running the `npm install` command on the root folder triggers a script,
    which also installs dependencies under the `server` and `web-app` folders.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Execute `npm run init:env` on the root folder to configure environment variables
    in `.env` files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This command will create two `.env` files, one on the root folder and the other
    under the `server` folder, to contain your private configuration information.
    The initial files are generated based on the `example.env` file. You can modify
    these files later and set your own secure secrets.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Execute `npm run build` on the root folder, which builds both the server and
    the web app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the web app is built using a new configuration named `--configuration=lemon-mart-server`,
    which uses `src/environments/environment.lemon-mart-server.ts`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Execute `docker-compose up --build` to run containerized versions of the server,
    web app, and a MongoDB database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the web app is containerized using a new file named `nginx.Dockerfile`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigate to `http://localhost:8080` to view the web app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To log in, click on the **Fill** button to populate the email and password fields
    with the default demo credentials.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigate to `http://localhost:3000` to view the server landing page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `http://localhost:3000/api-docs` to view interactive API documentation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use `npm run start:database` to only start the database, and `npm start`
    on the `server` folder for debugging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use `npm run start:backend` to only start the database and the server,
    and `npm start` on the `web-app` folder for debugging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the case of examples from this *chapter* that are based on **lemon-mart**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the repository: [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart
    )'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `npm install` on the root folder to install dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code sample for this chapter is available under the sub-folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the Angular app for this chapter, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run Angular unit tests for this chapter, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run Angular e2e tests for this chapter, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To build a production-ready Angular app for this chapter, execute the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `dist/ch10` folder at the root of the repository will contain
    the compiled result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Beware that the source code in the book or on GitHub may not always match the
    code generated by the Angular CLI. There may also be slight differences in implementation
    between the code in the book and what's on GitHub because the ecosystem is ever-evolving.
    It is natural for the sample code to change over time. Also, on GitHub, expect
    to find corrections, fixes to support newer versions of libraries, or side-by-side
    implementations of multiple techniques for the reader to observe. The reader is
    only expected to implement the ideal solution recommended in the book. If you
    find errors or have questions, please create an issue or submit a pull request
    on GitHub for the benefit of all readers.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about updating Angular in the *Appendix C*, *Keeping Angular
    and Tools Evergreen*. You can find this appendix online from [https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.)
    or at [https://expertlysimple.io/stay-evergreen](https://expertlysimple.io/stay-evergreen).
  prefs: []
  type: TYPE_NORMAL
- en: With your LemonMart server up and running, we are ready to explore the architecture
    of the MEAN stack. By the end of this section, you should have your own version
    of LemonMart communicating with the server.
  prefs: []
  type: TYPE_NORMAL
- en: Full-stack architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Full-stack refers to the entire stack of software that makes an application
    work, all the way from databases to servers, APIs, and the web and/or mobile apps
    that leverage them. The mythical full-stack developer is all-knowing and can comfortably
    operate in all verticals of the profession. It is next to impossible to specialize
    in all things software-related and to be considered an expert in relation to every
    given topic. However, to be considered an expert in a single topic, you must also
    be well-versed in related topics. When learning a new topic, it is very helpful
    to keep your tooling and language consistent so that you can absorb the new information
    without additional noise. For these reasons, I opted to introduce you to the MEAN
    stack over Spring Boot using Java or ASP.NET using C#. By sticking to familiar
    tools and languages such as TypeScript, VS Code, npm, GitHub, Jasmine, Docker,
    and CircleCI, you can better understand how a full-stack implementation comes
    together and become a better web developer as a result.
  prefs: []
  type: TYPE_NORMAL
- en: Minimal MEAN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Choosing the Correct-Stack™ for your project is difficult. First and foremost,
    your technical architecture should be adequate to meet business needs. For example,
    if you''re trying to deliver an artificial intelligence project with Node.js,
    you''re likely using the wrong stack. Our focus will be on delivering web applications,
    but beyond that, we have other parameters to consider, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ease of use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Happiness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effectiveness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your development team will be working on your application for an extended
    period of time, then it is very important to consider factors beyond compatibility.
    Your stack, choice of tool, and coding style can have a significant impact if
    your code base is easy to use, keeps your developers happy, or makes them feel
    like effective contributors to the project.
  prefs: []
  type: TYPE_NORMAL
- en: A well configured stack is key for a great DX. This can be the difference between
    a towering stack of dried-out pancakes, or a delicious short stack with the right
    amount of butter and syrup over it.
  prefs: []
  type: TYPE_NORMAL
- en: By introducing too many libraries and dependencies, you can slow down your progress,
    make your code difficult to maintain, and find yourself in a feedback loop of
    introducing more libraries to resolve the issues of other libraries. The only
    way to win this game is to simply not play it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take your time to learn how to work with a few fundamental libraries,
    you can become a far more effective developer. In essence, you can do more with
    less. My advice would be to:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Think** before you write a single line of code, and apply the 80-20 rule.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wait** for libraries and tools to mature, skipping the betas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fast** by reducing your gluttony for new packages and tools, mastering the
    fundamentals instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Watch my 2017 Ng conference talk entitled *Do More with Less JavaScript* on
    YouTube at [https://www.youtube.com/watch?v=Sd1aM8181kc](https://www.youtube.com/watch?v=Sd1aM8181kc).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This minimalist mindset is the design philosophy behind minimal MEAN. You can
    review a reference implementation on GitHub at [https://github.com/duluca/minimal-mean](https://github.com/duluca/minimal-mean).
    Refer to the following diagram for the overall architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_10_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Minimal MEAN software stack and tooling'
  prefs: []
  type: TYPE_NORMAL
- en: Let's go over the components of the architecture one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Angular
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Angular is the presentation layer. Angular is a capable and reliable development
    platform. It is well understood and has a great community. You should definitely
    take the time to master the fundamentals of Angular before considering another
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries such as Angular Material, Angular Evergreen, and `angular-unit-test-helper`
    help you deliver optimal and great-looking solutions with minimal effort.
  prefs: []
  type: TYPE_NORMAL
- en: You may containerize your Angular (or any other web app) using the minimal Docker
    container, `duluca/minimal-nginx-web-server` or `duluca/minimal-node-web-server`.
  prefs: []
  type: TYPE_NORMAL
- en: Express
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Express.js will be our API layer. Express is a fast, unopinionated, and minimalist
    web framework for Node.js. Express has a vast plugin ecosystem that is almost
    guaranteed to meet every need. In minimal MEAN, we only leverage two packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cors`: To configure cross-origin resource sharing settings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`morgan`: To log HTTP requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, we use express parsers to parse incoming HTTP requests in `req.body`
    and the `express.static` function to serve the content of the `public` folder.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about Express.js at [https://expressjs.com/](https://expressjs.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Express.js runs on Node.js. We will be implementing the business layer in Node.
    Node is a lightweight and efficient JavaScript runtime, using an event-driven,
    non-blocking I/O model that makes it suitable for high-performance and real-time
    applications. Node runs everywhere, from fridges to smart watches. You can increase
    the reliability of your Node applications by using TypeScript to develop your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the blog post by Frank Rosner on non-blocking I/O for a more in-depth
    explanation of the topic at [https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/](https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/).
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, you're going to learn how to configure Node projects
    using TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Mongo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MongoDB represents the persistence layer. MongoDB is a document-oriented database
    with dynamic JSON-like schemas. The major benefit of using a JSON-based database
    is the fact that you don't need to transform your data from one format to another.
    You can retrieve, display, edit, and then update the data solely using JSON.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the MongoDB native driver for Node is mature, performant, and capable.
    I have developed a library called `document-ts`, which aims to simplify interacting
    with MongoDB by introducing rich document objects that are easy to code. DocumentTS
    is a very thin TypeScript-based MongoDB helper with optional, rich ODM convenience
    features.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about MongoDB at [https://www.mongodb.com/](https://www.mongodb.com/),
    and the DocumentTS library at [https://github.com/duluca/document-ts](https://github.com/duluca/document-ts).
  prefs: []
  type: TYPE_NORMAL
- en: Tooling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The tooling that supports your development is as important as your choice of
    software stack. Minimal MEAN leverages the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VS Code**: Great extension support, lightweight, fast, and cross-platform'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TypeScript**: Fast and easy-to-use transpiler with great linting support
    using tslint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Npm**: Multi-platform scripting and dependency management with a rich ecosystem
    of packages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub**: Flexible, free, and well supported Git host. GitHub flow enables
    gated code check-ins in tandem with a CI server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker**: Lightweight virtualization technology that encapsulates your environment
    configuration and settings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous Integration (CI)**: Critical to ensuring the delivery of quality
    code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jasmine**: Batteries-included unit testing framework that works with nyc/istanbul.js
    to deliver code coverage metrics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the tooling and language of choice we are using is the same as the
    ones we use for Angular development. This enables developers to be able to switch
    between frontend and backend development with minimal context switching.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered all major components and tooling for delivering a minimal
    MEAN stack app, let's start by creating a Git repository that can house our frontend
    and backend code.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a monorepo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can optimize your development experience by creating a monorepo, which contains
    your frontend and backend code. A monorepo allows developers to be able to jump
    between projects within the same IDE window. Developers can reference code more
    easily across projects, such as sharing TypeScript interfaces between the frontend
    and the backend, thereby ensuring that data objects line up every time. The CI
    server can build all projects at once to ensure that all components of the full-stack
    application remain in working order.
  prefs: []
  type: TYPE_NORMAL
- en: Note that a monorepo is different to multi-root workspaces in VS Code, where
    you can add multiple projects to show in the same IDE windows. A monorepo combines
    projects at the source control level. Read more about multi-root workspaces at
    [https://code.visualstudio.com/docs/editor/multi-root-workspaces](https://code.visualstudio.com/docs/editor/multi-root-workspaces).
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a quick tour of the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Monorepo structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Under the `lemon-mart-server` project, you are going to have three main folders,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `bin` folder contains helper scripts or tools, the `web-app` folder represents
    your frontend, and `server` contains the source code for the backend. In our case,
    the `web-app` folder is the `lemon-mart` project. Instead of copying and pasting
    the code from the existing project, we leverage Git submodules to link two repositories
    together.
  prefs: []
  type: TYPE_NORMAL
- en: Git submodules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Git submodules help you share code between multiple repositories, while keeping
    the commits separate. Frontend developers may choose to only work using the frontend
    repository, whereas full-stack developers will prefer access to all code. Git
    submodules also provide a convenient way for existing projects to be combined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by seeing how you can add your own `lemon-mart` project as a submodule
    of `lemon-mart-server`, leveraging the scripts that reside in the `package.json`
    file in the root folder of our monorepo:'
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you perform this action on the version of **lemon-mart-server**
    that you cloned from GitHub. Otherwise, you will need to create a new project
    and execute `npm init -y` to get things started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe the following `package.json` scripts that assist in the initialization,
    updating, and cleaning up of Git submodules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Update `webAppGitUrl` with the URL to your own project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `webapp:clean` to remove the existing `web-app` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, execute the `webapp:init` command to initialize your project in the
    `web-app` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Going forward, execute the `modules:update` command to update the code in the
    submodule. To pull the submodules after cloning the repo in another environment,
    execute `npm modules:init`. If you ever need to reset the environment and restart,
    then execute `webapp:clean` to clean Git's cache and remove the folder.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can have multiple submodules in your repository. The `modules:update`
    command will update all the submodules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your web application code is now available in the folder named `web-app`. Additionally,
    you should be able to see both projects under VS Code''s **Source Control** pane,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_10_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: VS Code Source Control Providers'
  prefs: []
  type: TYPE_NORMAL
- en: Using VS Code's source control, you can independently perform Git actions on
    either repository.
  prefs: []
  type: TYPE_NORMAL
- en: If things get messy with your submodule, simply `cd` into the submodule directory
    and execute `git pull` and then `git checkout master` to restore the master branch.
    Using this technique, you may checkout any branch from your project and submit
    PRs.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our submodule ready, let's see how the server project is configured.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Node project with TypeScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a new Node.js application using TypeScript, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The following steps are only relevant if you are creating a new server project.
    I recommend that you use the one already provided in the `lemon-mart-server` project
    that you cloned from GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a sub-folder `server`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change your current directory to the `server` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize npm to set up `package.json` in the `server` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the top-level `package.json` will be utilized for scripts that are
    relevant to the full-stack project. `server/package.json` will contain scripts
    and dependencies for the backend project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Configure your repository using `mrm-task-typescript-vscode`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `mrm` task configures VS Code for an optimized TypeScript development experience,
    similar to the way we did using `mrm-task-angular-vscode` in *Chapter 2*, *Setting
    Up Your Development Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the command has finished executing, the `project` folder appears as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The task configures the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Common npm packages used for scripting: cross-conf-env ([https://www.npmjs.com/package/cross-conf-env](https://www.npmjs.com/package/cross-conf-env)),
    npm-run-all ([https://www.npmjs.com/package/npm-run-all](https://www.npmjs.com/package/npm-run-all)),
    dev-norms ([https://www.npmjs.com/package/dev-norms](https://www.npmjs.com/package/dev-norms)),
    and rimraf ([https://www.npmjs.com/package/rimraf](https://www.npmjs.com/package/rimraf))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Npm scripts for styling, linting, building, and testing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`style` and `lint`: Check compliance in code styling and linting errors. They
    are intended for CI server usage.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`style:fix` and `lint:fix`: Apply code styling and linting rules to the code.
    Not all linting errors can be fixed automatically. You will need to address each
    error by hand.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`build`: Transpiles the code into the `dist` folder.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start`: Runs the transpiled code in Node.js.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prepublishOnly` and `prepare` scripts are only relevant if you''re developing
    an npm package. In that case, you should also implement a `.npmignore` file, which
    excludes the `src` and `tests` folders.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ImportSort`: Maintains the order of the `import` statements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Settings are added to `package.json`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Supporting npm packages are installed: import-sort, import-sort-cli, import-sort-parser-typescript,
    and import-sort-style-module'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TypeScript with tslint:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tsconfig.json`: Common TypeScript settings'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tsconfig.src.json`: Settings that are specific to the source code under the
    `src` folder'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tslint.json`: Linting rules'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Prettier plugin, which automatically formats the styling of our code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.prettierrc`: Prettier settings'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.prettierignore`: Files to ignore'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jasmine and nyc for unit testing and code coverage:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jasmine.json`: Testing settings.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.nycrc`: Code coverage settings.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `tests` folder: Contains `spec.ts` files, which include your tests and
    `tsconfig.spec.json`, which configures more relaxed settings that make it easier
    to write tests quickly.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `package.json`: Test scripts are created to build your tests using `build:test`
    and execute them with `npm test`. The `test:ci` command is intended for CI servers
    and `test:nyc` provides the code coverage report.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`example.env`: Used to document required environment variables that would be
    present in your private `.env` file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.env` is added to `.gitignore`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PR template: A pull request template that requests additional information from
    developers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'VS Code extensions, settings, and debugging configurations, respectively, in three
    files:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.vscode/extensions.json`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.vscode/settings.json`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.vscode/launch.json`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you are comfortable with the changes introduced to your project, verify
    that your project is in working order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the project by executing the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Before the `test` command is run, `npm run build && npm run build:test` is
    executed to transpile our TypeScript code to JavaScript. The output is placed
    in the `dist` folder, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that on your filesystem,`.js` and `.js.map` files are created alongside
    every `.ts` file. In `.vscode/settings.json`, we configure the `files.exclude`
    property to hide these files in the IDE so that they don't distract developers
    during development. Additionally, in `.gitignore`, we also ignore `.js` and `.js.map`
    files, so they don't get checked into our repository.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a barebones monorepo, we can configure our CI server.
  prefs: []
  type: TYPE_NORMAL
- en: CircleCI config
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the benefits of using Git submodules is that we can verify that our
    frontend and backend works in the same pipeline. We will implement two jobs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`build_server`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`build_webapp`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These jobs will follow the workflow shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The CI pipeline will build the server and the web app simultaneously, with
    an option to run the `deploy` job if the jobs succeed on the master branch. Refer
    to the `config.yml` file on GitHub on how to implement the `build_webapp` job,
    which is similar to the one you implemented in *Chapter 9*, *DevOps Using Docker*,
    but that includes a number of subtle differences to handle working with submodules
    and the folder structure changes. The pipeline for building the server is not
    too dissimilar to the web app one, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The pipeline checks out the code, verifies the security of the packages we're
    using with `audit-ci`, installs dependencies, checks for styling and linting errors,
    runs tests, and checks for code coverage levels.
  prefs: []
  type: TYPE_NORMAL
- en: The test commands implicitly build the server code, which is stored under the
    `dist` folder. In the final step, we move the `dist` folder into the workspace
    so that we can use it at a later stage.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's see how we can bring together all tiers of our app and run it using
    Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we have a three-tiered architecture, we need a convenient way to set up
    the infrastructure for our full-stack application. You can create scripts to start
    various Docker containers individually, but there's a purpose-built tool that
    runs multi-container applications called Docker Compose. Compose uses a YAML file
    format, named `docker-compose.yml`, so you declaratively define the configuration
    of your application. Compose allows you to adhere to infrastructure-as-code principles.
    Compose will also allow us to conveniently start a database instance without having
    to install a permanent and always-on database solution in our development environments.
  prefs: []
  type: TYPE_NORMAL
- en: You can use Compose to deploy your application on cloud services, scale the
    number of container instances you're running, and even run integration tests of your application
    on your CI server. Later in this section, we go over how you can run Docker Compose
    on CircleCI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the architecture of the following application with the communication
    port of each tier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_10_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Lemon Mart three-tier architecture'
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker Compose, we are able to describe the architecture shown here precisely.
    You can read more about Compose at [https://docs.docker.com/compose/](https://docs.docker.com/compose/).
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's implement a more efficient web server for Lemon Mart.
  prefs: []
  type: TYPE_NORMAL
- en: Using Nginx as the web server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our web app is already containerized as covered in *Chapter 9*, *DevOps Using
    Docker*. For this exercise, we will use the nginx-based container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new Dockerfile named `nginx.Dockerfile` to the root of your `web-app`.
    This image will be smaller than the Node-based one we have, since we''re using
    nginx as the web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's containerize our server.
  prefs: []
  type: TYPE_NORMAL
- en: Containerizing the server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we have been using mostly preconfigured Docker images to deploy our
    web app. The following is a more detailed implementation of a Node.js-based server:'
  prefs: []
  type: TYPE_NORMAL
- en: If you need it, refer to the *Containerizing the app using Docker* section in
    *Chapter 9*, *DevOps Using Docker*, as a refresher on Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by defining the `Dockerfile`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we ADD the `dist` folder to our server and then run it using nodes
    with CMD.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can read more about how our server container is configured by checking out
    `README.md` on the similarly configured `minimal-node-web-server` repo at [https://github.com/duluca/minimal-node-web-server](https://github.com/duluca/minimal-node-web-server).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, set up the cross-environment, **npm scripts for Docker**, which works on
    Windows 10 and macOS for our server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Install the npm scripts for the Docker task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Apply the npm scripts for Docker configuration, making sure to execute the
    command in the `server` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure your `package.json` with the configuration parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Be sure to build your app before building your Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring environment variables with DotEnv
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: DotEnv files are widely supported to store secrets conveniently in a `.env`
    file that is not checked in to your code repository. Docker and Compose natively
    support `.env` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by understanding the environment variables at the heart of the
    monorepo:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the `example.env` file at the root of the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Don't store any real secrets in `example.env`. Store them in the `.env` file.
    `example.env` is there to document the environment variables that are required
    for your project. In this case, I've populated my `example.env` file with sample
    values so that readers can run the example without having to configure all these
    parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Ensure that `init-dev-env` is installed in the root of the project by executing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `npm run init:env` script generates `.env` files based on the `example.env`
    file using the `init-dev-env` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **lemon-mart-server** the `example.env` file for the server exists in two
    places. First in the root of the project as `server-example.env` and second under
    `server/example.env`. This is done to increase the visibility of the sample configuration
    settings.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second `.env` file is generated for the server as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that this file contains the connection string to MongoDB, the secret we
    will use to encrypt our JWTs, and a seed user so that we can log in to the application.
    Normally, you wouldn't configure a password or a user ID for your seed users.
    These are only here to support repeatable demo code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we're ready to define the YAML file for Compose.
  prefs: []
  type: TYPE_NORMAL
- en: Define Docker-Compose YAML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s define a `docker-compose.yml` file in the root of the monorepo to reflect
    our architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: At the top, we build the `web-app` service using the nginx-based container.
    The `build` property automatically builds the `Dockerfile` for us. We are exposing
    the `web-app` on port `8080` and linking it to the `server` service. The `links`
    property creates an isolated Docker network to ensure that our containers can
    communicate with each other. By using the `depends_on` property, we ensure that
    the server is started before the `web-app` is started.
  prefs: []
  type: TYPE_NORMAL
- en: The `server` also uses the `build` property for an automatic `Dockerfile` build.
    It also uses the `env_file` property to load environment variables from the `.env`
    file under the `server` folder. Using the `environment` property, we override
    the `MONGO_URI` variable to use the internal Docker network name for the database
    container. The server both `links` and `depends_on` the database, which is named
    `lemondb`.
  prefs: []
  type: TYPE_NORMAL
- en: The `database` service pulls the `duluca/minimal-mongo` image from Docker Hub.
    Using the `restart` property, we ensure that the database will automatically restart
    if it crashes. We use the setup parameters within the `.env` file to configure
    and password-protect the database. Using the `volumes` property, we mount the
    database's storage directory to a local directory so that your data can persist
    across container reboots.
  prefs: []
  type: TYPE_NORMAL
- en: In a cloud environment, you can mount the volume of your database to your cloud
    provider's persistence solution, including AWS **Elastic File System** (**EFS**)
    or Azure File Storage.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we define a Docker volume named `dbdata` for data storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Occasionally, your database may stop working correctly. This can happen if
    you upgrade your container, use a different container, or use the same volume
    in another project. In this instance, you can reset the state of your Docker setup
    by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To run your infrastructure, you will be executing the `docker-compose up` command.
    You can also use the `-d` option to your infrastructure in detached mode. You
    stop it with the `down` command and remove the containers it creates by means
    of the `rm` command.
  prefs: []
  type: TYPE_NORMAL
- en: Before you can run your infrastructure, you will need to build your application,
    which is covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Orchestrating the Compose launch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Running `docker-compose up` is a convenient and simple way to start your infrastructure.
    However, you need your code to be built before building your containers. It is
    an easy step to overlook. Refer to some npm scripts that you can use to orchestrate
    the launch of your infrastructure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We implemented a `build` script that runs the `build` commands for the server
    and the web app. A `test` script can do the same for executing tests. We implemented
    an `npm start` command that can automatically run the `build` command and run
    `compose up`. As a bonus, we also implemented `start:backend` and `start:database`
    scripts that can run alternate `docker-compose` files to stand up just the server
    or the database. You may create these files by removing the unnecessary parts
    of the master `docker-compose.yml` file. Refer to the GitHub repo for examples.
  prefs: []
  type: TYPE_NORMAL
- en: When coding on the server, I normally execute `npm run start:database` to stand
    up the database and, in a separate terminal window, I launch the server using
    `npm start` from the `server` folder. This way, I can see logs being generated
    by both systems side by side.
  prefs: []
  type: TYPE_NORMAL
- en: Execute `npm start` to verify that your `docker-compose` configuration is working.
    Hit *Ctrl* + *C* to stop the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Compose on CircleCI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can execute your Compose infrastructure on CircleCI to verify the correctness
    of your configuration and run a quick integration test. Refer to the following
    updated workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We ensure that both `server` and `web-app` are built before running a new job
    named `test_compose`, which checks out the code, initializes the submodule, and
    copies the `dist` folders of both builds, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: After copying the `dist` files, the job then lays down the `.env` files from
    the CircleCI environment variables. Then, we run `docker-compose up` to stand
    up our server. Next, we test the `web-app` by running a `curl` command to retrieve
    its `index.html` file. We `run curl` after waiting for the server to become available
    using `dockerize -wait`. Similarly, we test the integration of our API server
    and the database by logging in using our demo user.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! Now, you have a pretty good understanding of how our full stack
    architecture is pieced together at a high level. In the latter half of this chapter,
    we will go over how the API is implemented, how it integrates with the database,
    and see how JWT auth works in tandem with the API and database.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue by diving into API design.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In full stack development, nailing down the API design early on is important.
    The API design itself is closely correlated with how your data contract will look.
    You may create RESTful endpoints or use the next-gen GraphQL technology. In designing
    your API, frontend and backend developers should collaborate closely to achieve
    shared design goals. Some high-level goals are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimize data transmitted between the client and server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stick to well-established design patterns (in other words, data pagination)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design to reduce business logic present in the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flatten data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not expose database keys or relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version endpoints from the get-go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design around major data entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should aim to implement the business logic in your RESTful API. Ideally,
    your frontend shouldn't contain anything more than presentation logic. Any `if`
    statement implemented by the frontend should also be verified in your backend.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in *Chapter 1*, *Introduction to Angular and Its Concepts*, it
    is critical to aim for a stateless design in both the backend and frontend. Every
    request should utilize non-blocking I/O methods and should not rely on any existing
    session. This is the key to infinitely scaling your web application using cloud
    hosting providers.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you're implementing a project, it is important to limit, if not eliminate,
    experimentation. This is especially true in full stack projects. The downstream
    effect of missteps in API design can be profound and impossible to correct once
    your application goes live.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's look into designing an API around major data entities. In this case,
    we'll review the implementation of an API surrounding users, including authentication.
    First we'll explore how we can define an endpoint using Swagger, so we can concretely
    communicate the intent of our design to team members.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that only significant pieces of code that are conceptually significant
    are covered in this chapter. While you may choose to implement this code from
    scratch, it is not necessary to get an understanding of how it works. If you choose
    to implement it from scratch, refer to the complete source code at [https://github.com/duluca/lemon-mart-server](https://github.com/duluca/lemon-mart-server)
    to follow along and bridge the gaps in your implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Later on, Swagger will become a documentation tool, reflecting the capability
    of our APIs.
  prefs: []
  type: TYPE_NORMAL
- en: API design with Swagger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Swagger will allow you to design and document your web API. For teams, it can
    act as a great communication tool between frontend and backend developers, thereby
    reducing a lot of friction. Additionally, defining your API surface early on allows
    implementation to begin without worrying about late-stage integration challenges.
  prefs: []
  type: TYPE_NORMAL
- en: We will implement a users API as we move on, so as to demonstrate how Swagger
    works.
  prefs: []
  type: TYPE_NORMAL
- en: I highly recommend installing the Swagger Viewer VS Code extension, which allows
    us to preview the YAML file without running any additional tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by exploring the `swagger.yaml` file at the root of the monorepo:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `swagger.yaml` in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the VS Code extension called Swagger Preview.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit *Ctrl* + *Shift* + *P*, or ![](img/B14094_10_15.png)+![](img/B14094_10_16.png)+`P`,
    to bring up the command palette and run **Preview Swagger**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See the preview, as shown here:![](img/B14094_10_04.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.4: Swagger.yaml preview'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the Swagger UI view, you are going to be able to try out commands and
    execute them against your server environment.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Swagger YAML file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll use Swagger spec version `openapi: 3.0.1`, which implements the OpenAPI
    standard. Let''s go over the major components of the `swagger.yaml` file here:'
  prefs: []
  type: TYPE_NORMAL
- en: For more information about how a Swagger file is defined, refer to [https://swagger.io/specification/](https://swagger.io/specification/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The YAML file starts with general information and target servers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Under `components`, we define common `securitySchemes` and responses, which
    define the authentication scheme we intend to implement and how the shape of our
    error message response will appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the usage of `$ref` to reuse repeating elements. You can see `ServerMessage`
    being defined here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Under `components`, we define shared data `schemas`, which declares the data
    entities that we either take in as input or return to the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Under `components`, we add shared `parameters`, making it easy to reuse common
    patterns such as paginated endpoints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Under `paths`, we begin defining REST endpoints, such as a `post` endpoint
    for the `/login` path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that `requestBody` defines input variables that are required with a type
    of `string`. Under `responses`, we can define how a successful `200` response
    and an unsuccessful `401` response to a request appear. In the former case, we
    return an `accessToken`, while in the latter case, we return an `UnauthorizedError`,
    as defined in Step 2.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Under `paths`, we continue by adding the following paths:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The OpenAPI spec is powerful, allowing you to define intricate requirements
    on how users should be able to interact with your API. The specification document
    at [https://swagger.io/docs/specification](https://swagger.io/docs/specification)
    is an invaluable resource while developing your own API definition.
  prefs: []
  type: TYPE_NORMAL
- en: Preview Swagger file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can validate your Swagger file at [https://swaggerhub.com](https://swaggerhub.com)
    for free. After you sign up for a free account, create a new project and define
    your YAML file. SwaggerHub will highlight any errors you made. It will also give
    you a preview of the web view, which is the same one you get with the Swagger
    Preview VS Code extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following screenshot to see how a valid Swagger YAML definition
    looks on SwaggerHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_10_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Valid Swagger YAML definition on SwaggerHub'
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to integrate this interactive documentation with our Express.js
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how you can implement such an API.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing APIs with Express.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we begin implementing our APIs, let's review the target file structure
    of our backend in sections, so we get an understanding of how the server is bootstrapped,
    how routing is configured for API endpoints, how public resources are served,
    and how services are configured. Minimal MEAN intentionally sticks to the basics,
    so you can learn more about the underlying technologies. While I have delivered
    production systems using minimal MEAN, you may not enjoy the barebones development
    experience as much as I do. In this case, you may consider Nest.js, which is a
    popular framework for implementing full stack Node.js apps. Nest.js has a rich
    feature set with an architecture and coding style that closely resemble Angular.
    I recommend using such a library after you have mastered the basics of the MEAN stack.
  prefs: []
  type: TYPE_NORMAL
- en: Kudos to Kamil Mysliwiec and Mark Pieszak for creating a great tool and vibrant
    community around Nest.js. You can read more about Nest.js at [https://nestjs.com/](https://nestjs.com/)
    and solicit consulting services at [https://trilon.io/](https://trilon.io/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s review the file structure of our Express server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s review the purpose and the interaction between these files by looking
    at a component diagram, giving us an overview of the architecture and the dependency
    tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_10_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Express server architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '`index.ts` contains a `start` function, which bootstraps the application leveraging
    three major helpers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`config.ts`: Manages environment variables and settings.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`app.ts`: Configures Express.js, defines all API paths, and then routers implement
    the paths and leverage services that contain the business logic. Services use
    models, such as `user.ts`, to access the database.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`document-ts`: Establishes a connection to the database and configures it,
    and leverages `user.ts` to configure a seed user during startup.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can see that the components at the top of the diagram are responsible for
    start up and configuration chores, including configuring API paths, which represent
    the **API** layer. The **Services** layer should contain most of the business
    logic for the app, while persistence is handled in the **Models** layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following implementation of `index.ts` without any database features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note that the last line of code shown, `start()`, is the function call that
    triggers the initialization of the server.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look into how the Express server is set up.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`App.ts` configures Express.js, along with serving static assets, routing,
    and versioning. Express.js leverages middleware functions to integrate with libraries
    or your own code, such as an authenticate method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, note that configuring Express is straightforward with
    the `use()` method. First, we configure `cors`, and then express parsers and `logger`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, using the `express.static` function, we serve the `public` folder at
    the root''s route, `/`, so we can display some useful information about our server,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_10_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: LemonMart server landing page'
  prefs: []
  type: TYPE_NORMAL
- en: We will cover how to configure the `/api-docs` endpoint, which is referenced
    above, in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we configure the router, which is defined in `api.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Routes and versioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Api.ts` configures the Express router. Refer to the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we have two child routes for `v1` and `v2`. It is critical to
    always version the APIs you implement. Once an API becomes public, it can be very
    tricky, even impossible sometimes, to simply phase out an API for a newer version.
    Even minor code changes or slight differences in the API can cause clients to
    break. You must pay careful attention to only making backward-compatible changes
    to your API.
  prefs: []
  type: TYPE_NORMAL
- en: At some point, you will have a need to completely rewrite the endpoint to meet
    new requirements, performance, and business needs, at which point you can simply
    implement a `v2` version of your endpoint, while leaving the `v1` implementation
    unchanged. This allows you to innovate at the pace you need to, while keeping
    legacy consumers of your app functional.
  prefs: []
  type: TYPE_NORMAL
- en: In short, you should version every API you create. By doing this, you force
    your consumers to version their HTTP calls to your API. As time goes on, you may
    transition, duplicate, and retire APIs under different versions. Consumers then
    have a choice to call whichever version of the API works for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuring a route is trivial. Let''s see the configuration for `v2`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The question mark at the end of `/users?` means that both `/user` and `/users`
    will work against operations implemented in `userRouter`. This is a great way
    to avoid typos, while allowing the developer to choose the plurality that makes
    sense for the operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `userRouter`, you can then implement GET, POST, PUT, and DELETE operations.
    Refer to the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you can observe the use of route parameters. You can
    consume route parameters through a request object, such as `req.params.userId`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that all routes in the sample code are tagged as `async` because they will
    all be making a database call, which we are going to `await`. If your route is
    synchronous, then you don't require the `async` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's look into services.
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We don't want to implement our business logic in the router files, which represents
    our API layer. The API layer should largely consist of transforming data and making
    calls to the business logic layer.
  prefs: []
  type: TYPE_NORMAL
- en: You can implement services using Node.js and TypeScript features. No fancy dependency
    injection is necessary. The sample application implements two services – `authService`
    and `userService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in `userService.ts`, you can implement a function called `createNewUser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`createNewUser` accepts `userData` in the shape of `IUser` and, when it is
    done creating the user, it returns an instance of `User`. We can then use this
    function in our router as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We can await the result of `createNewUser` and, if successful, return the created
    object as a response to the POST request.
  prefs: []
  type: TYPE_NORMAL
- en: Note that even though we are casting `req.body` as `IUser`, this is only a development
    time comfort feature. At runtime, the consumer may pass any number of properties
    to the body. Careless handling of request parameters is one of the primary ways
    in which your code can be maliciously exploited.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an understanding of the skeleton of our Express server, let's
    see how you can configure Swagger so that you can use it as a guide to implementation
    and create living documentation for your API.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Swagger with Express
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Configuring Swagger with Express is a manual process. Forcing yourself to manually
    document the endpoints has a great side effect. By slowing down, you will get
    the opportunity to consider your implementation from the consumer's perspective
    as well as the implementor's perspective. This perspective will help you to resolve
    potential issues with your endpoints during development, thereby avoiding costly reworking.
  prefs: []
  type: TYPE_NORMAL
- en: The major benefit of integrating Swagger with your server is that you will get
    the same interactive Swagger UI that was covered earlier in this chapter, so your
    testers and developers can discover or test your API directly from a web interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use two helper libraries to help us integrate Swagger into
    our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '`swagger-jsdoc`: This allows you to implement OpenAPI specs right on top of
    the relevant code by using the `@swagger` identifier in a `JSDoc` comment block,
    generating a `swagger.json` file as output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`swagger-ui-express`: This consumes the `swagger.json` file to display the
    interactive Swagger UI web interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s go over how Swagger is configured to work with Express.js:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The dependencies and type information for TypeScript are shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s go over the `docs-config.ts` file, which configures the base OpenAPI
    definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Modify the `servers` property to include the location of your testing, staging,
    or production environments. This allows consumers of your API to test the API
    using the web interface without additional tooling. Note that the `apis` property
    informs the code files that `swaggerJsdoc` should parse when constructing the
    `swagger.json` file. This routine runs during the bootstrapping of the server,
    which is why we reference the transpiled `.js` files instead of `.ts` files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Bootstrap the swagger config in `app.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Specs contain the content of the `swagger.json` file, which is then passed to
    `swaggerUi`. Then, using the server middleware, we can configure `swaggerUi` to
    host the web interface at `/api-docs`.
  prefs: []
  type: TYPE_NORMAL
- en: You already have the OpenAPI definitions that need to be used to complete the
    implementation of the application from the beginning of this chapter. Refer to
    the complete source code at [https://github.com/duluca/lemon-mart-server](https://github.com/duluca/lemon-mart-server)
    for additional help.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! Now you have a good understanding of how our Express server
    works. Next, let's look at how to connect to MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB ODM with DocumentTS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DocumentTS acts as an ODM, implementing a layer of models to enable rich and
    customizable interaction with database objects. ODM is the document-based database
    equivalent of an **Object Relational Mapper** (**ORM**) in relational databases.
    Think Hibernate or Entity Framework. If you're not familiar with these concepts,
    I recommend that you do further research before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: 'At its core, DocumentTS leverages the Node.js driver for MongoDB. This driver
    is implemented by the makers of MongoDB. It guarantees to offer the best performance
    and feature parity with new MongoDB releases, whereas third-party libraries often
    lag in supporting new features. Using the `database.getDbInstance` method, you
    can get access to the native driver directly. Otherwise, you will be accessing
    Mongo through models that you implement. Refer to the following diagram for an
    overview:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_10_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: DocumentTS overview'
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about MongoDB's Node.js driver at [https://mongodb.github.io/node-mongodb-native/](https://mongodb.github.io/node-mongodb-native/).
  prefs: []
  type: TYPE_NORMAL
- en: About DocumentTS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'DocumentTS provides three major features:'
  prefs: []
  type: TYPE_NORMAL
- en: '`connect()`: A MongoDB async connection harness'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Document` and `IDocument`: A base class and interface to help define your
    own models'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CollectionFactory`: Defines collections, organizes indexes, and aggregates
    queries alongside collection implementations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the convenience features that a DocumentTS collection provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get collection` returns the native MongoDB collection, so you can operate
    on it directly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`aggregate` allows you to run a MongoDB aggregation pipeline:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`findOne` and `findOneAndUpdate` simplify the operation of commonly used database
    functionality, automatically hydrating the models returned:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`findWithPagination` is by far the best feature of DocumentTS, allowing you
    to filter, sort, and paginate large collections of data. This function is geared
    toward use with data tables, so you specify searchable properties, turn off hydration,
    and use a debug feature to fine-tune your queries:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'DocumentTS aims to be reliable, optional, and convenient to use. DocumentTS
    directly exposes the developer to the native Node.js driver, so you learn how
    to work with MongoDB instead of some library. Developers can optionally leverage
    the library''s convenience features, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Define your own models through simple interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose fields that you want to automatically hydrate, such as child or related
    objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serialize calculated fields with every request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protect certain fields (such as passwords) from serialization so that they aren't
    accidently sent across the wire.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By being optional, DocumentTS allows developers to transition to new features
    in their own time. If performance becomes a concern, you can easily switch to
    native MongoDB calls to get the best performance. Using DocumentTS, you will spend
    more time reading MongoDB documentation than DocumentTS documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Mongoose is a popular library for interacting with MongoDB. However, it is a
    wrapper around MongoDB, requiring a full buy-in. Furthermore, the library abstracts
    away the native driver, so it is very sensitive to changes and updates in the
    ecosystem. You can read more about Mongoose at [https://mongoosejs.com/](https://mongoosejs.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Install MongoDB dependencies and type information for TypeScript with the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's see how we connect to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It can be a challenge to ensure that database connectivity exists when writing
    a fully async web application. `connect()` makes it easy to connect to a MongoDB
    instance and makes it safe to be called simultaneously from multiple threads starting
    up at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by configuring your environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that the `MONGO_URI` connection string resides in `server/.env`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to update the username, password, and database name, you''ll need
    to edit the following variables in the top level `.env` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember that `.env` changes only take effect when you restart your servers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s see how `document-ts` integrates with `index.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We attempt to connect to the database using a `try/catch` block. Once the Express
    server is up and running, we call `createIndexes`, which, in turn, calls a function
    with the same name on `UserCollection`. Beyond performance considerations, MongoDB
    indexes are necessary to enable fields to become searchable.
  prefs: []
  type: TYPE_NORMAL
- en: Models with IDocument
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may implement an `IUser` interface similar to the one in LemonMart. However,
    this one will be extending the `IDocument` defined in DocumentTS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `IUser` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The interfaces and base classes provided by DocumentTS aim to help you develop
    your business logic and database queries in a consistent manner. I encourage you
    to explore the base classes and interfaces by `Ctrl` + clicking on them so that
    you can see the source code behind them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, here is the `User` class extending `Document<T>` and implementing Swagger
    documentation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the properties, `getCalculatedPropertiesToInclude` and `getPropertiesToExclude`.
    These define whether a field should be serialized by the client or allowed to
    be written to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serialization and deserialization of data is the concept of transforming data
    into a format that can be stored or transported. Refer to the *Further reading*
    section for links to articles regarding serialization and the JSON data format.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`fullName` is a calculated property, so we don''t want to write this value
    to the database. However, `fullName` is useful for the client. On the other hand,
    the `password` property should never be transmitted back to the client, but obviously
    we need to be able to save it to the database for password comparison and changes.
    Upon saving, we pass in the `{ upsert }` object to instruct the database to update
    records even if partial information is provided.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Remember to provide the complete Swagger definition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'And finally, let''s go over `UserCollectionFactory`, which implements `CollectionFactory<T>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we create a unique index, so another user with the same email won't be
    able to register. We also create a weighted index, which can assist in writing
    filter queries. We apply the indexes right after we connect to the database in
    `index.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: '`userSearchQuery` is a somewhat contrived example to demonstrate aggregate
    queries in MongoDB. It is possible to execute far more sophisticated and high-performance
    queries using aggregation in MongoDB. You can read more about aggregation in MongoDB
    at [https://docs.mongodb.com/manual/aggregation](https://docs.mongodb.com/manual/aggregation).'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the file, we instantiate a `UserCollection` and export it,
    so it can be referenced from anywhere in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Note that `UserCollectionFactory` is not exported, as it is only needed in the
    `user.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how you can fetch data using the new user model.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing JWT auth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 8*, *Designing Authentication and Authorization*, we discussed how
    to implement a JWT-based authentication mechanism. In LemonMart, you implemented
    a base auth service that can be extended for custom authentication services.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll leverage three packages for our implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jsonwebtoken`: Used to create and encode JWTs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bcryptjs`: Used to hash and salt a user''s password before saving it in the
    database, so we never store a user''s password in plain text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uuid`: A generated universally unique identifier that is useful when resetting
    a user''s password to a random value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hash function is a consistently repeatable, one-way encryption method, which
    means you get the same output every time you provide the same input, but even
    if you have access to the hashed value, you cannot readily figure out what information
    it stores. We can, however, compare whether the user has entered the correct password
    by hashing the user's input and comparing the hash of their input to that of the
    stored hash of their password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the JWT auth-related dependencies and type information for TypeScript:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Observe the `User` model with password hashing functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using the `setPassword` method, you can hash the user-provided password and
    safely save it to the database. Later, we will use the `comparePassword` function
    to compare the user-provided value to the hashed password. We never store the
    user-provided value, so the system can never reproduce the user's password, making
    it a safe implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Login API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is the login method implementation in `authService` for `lemon-mart-server`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code sample implements a `createJwt` function to create a JWT
    per user. We also defined canned responses for auth failures. Note the vagueness
    of the incorrect email/password message, meaning that bad actors cannot fish the
    system to exploit the authentication system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the login API at `/v1/auth/login`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Note that when retrieving a user by email, keep in mind that emails are case-insensitive.
    So, you should always convert the input to lowercase. You can improve this implementation
    further by validating the email, and stripping any white space, script tags, or
    even rogue Unicode characters. Consider using libraries such as `express-validator`
    or `express-sanitizer`.
  prefs: []
  type: TYPE_NORMAL
- en: The `login` method leverages the `user.comparePassword` function to confirm
    the correctness of the password provided. The `createJwt` function then creates
    the `accessToken` to be returned to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `authenticate` function is a middleware that we can use in our API implementations
    to ensure that only authenticated users with appropriate permissions can access
    an endpoint. Remember that real security is achieved in your backend implementation
    and this authenticate function is your gate keeper.
  prefs: []
  type: TYPE_NORMAL
- en: '`authenticate` takes an optional `options` object to verify the current user''s
    role with the `requiredRole` property, so if an API is configured as shown below,
    only a manager can access that API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In certain cases, we want a user to be able to update their own records, but
    also allow managers to update everyone else''s records. In this case, we leverage
    the `permitIfSelf` property, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In this case, if the `_id` of the record being updated matches the current user's
    `_id`, then the user can update their own record. Since, `requiredRoleCanOverride`
    is set to `true` a manager can update any record. If it were set to `false`, this
    wouldn't be allowed. By mixing and matching these properties you can cover a vast
    majority of your gate keeping needs.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `idGetter` is a function delegate, so that you can specify how the
    `_id` property should be accessed, when the `authenticate` middleware executes.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following implementation of `authenticate` and `authenticateHelper`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The `authenticate` method is implemented as an Express.js middleware. It can
    read the request header for an authorization token, verify the validity of the
    JWT provided, load the current user, and inject it into the response stream, so
    an authenticated API endpoint can conveniently access the current user's information.
    This will be demonstrated by the `me` API. If successful, the middleware calls
    the `next()` function to yield control back to Express. If unsuccessful, then
    the API can't be called.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `authenticateHelper` returns useful error messages, so users aren't
    confused if they try to execute an action they're not permitted to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the implementation of the me API, which returns the currently logged-in
    user to the client via `/v1/auth/me`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `/v1/auth/me` method uses the `authenticate` middleware and simply
    returns the user who was loaded into the response stream.
  prefs: []
  type: TYPE_NORMAL
- en: Custom server auth provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a functional auth implementation in our server, we can implement
    a custom auth provider in LemonMart, as covered in *Chapter 8*, *Designing Authentication
    and Authorization*:'
  prefs: []
  type: TYPE_NORMAL
- en: You must implement this custom auth provider in your Angular app.
  prefs: []
  type: TYPE_NORMAL
- en: The code sample for this section is in the `projects/ch10` folder on the **lemon-mart**
    repo. Note that the sample is also accessible under the `web-app` folder.
  prefs: []
  type: TYPE_NORMAL
- en: In `environment.ts` and `environment.prod.ts`, implement a `baseUrl` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also select `authMode` as `AuthMode.CustomServer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install a helper library to programmatically access TypeScript enum values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the custom authentication provider as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `authProvider` method calls our `/v1/auth/login` method and `getCurrentUser`
    calls `/v1/auth/me` to retrieve the current user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ensure that calls to `login` methods always happen on HTTPS, otherwise you will
    be sending user credentials on the open internet. This is ripe for eavesdroppers
    on public Wi-Fi networks to steal user credentials.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update `authFactory` to return the new provider for the `AuthMode.CustomServer`
    option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `app.modules.ts`, update the `AuthService` provider''s `deps` property to
    inject `HttpClient` into `authFactory`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Start your web app to make sure that things are working.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let's implement the get user endpoint, so our auth provider can get the
    current user.
  prefs: []
  type: TYPE_NORMAL
- en: GET User by ID
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s implement the GET User by ID API endpoint, at `/v2/users/{id}`, in `userRouter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code sample, we query the database by user ID to find the record
    we're looking for. We import `UserCollection` and call the `findOne` method to
    get a `User` object back. Note that we are not leveraging the `userService`. Since
    we're only retrieving a single record and immediately sending the result back,
    the additional layer of abstraction is cumbersome. However, if you start adding
    any business logic to the retrieval of a user, then refactor the code to leverage
    `userService`.
  prefs: []
  type: TYPE_NORMAL
- en: We secure the endpoint using the `authenticate` middleware, allowing users to
    retrieve their records and managers to retrieve any record.
  prefs: []
  type: TYPE_NORMAL
- en: Generating users with Postman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, we covered how to create a POST method to create a
    new user in the *Services* subsection of the *Implementing APIs with* *Express.js*
    section. Using this POST endpoint and the Postman API client, we can quickly generate
    user records for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: You must generate test data in **lemon-mart-server** following the instructions
    below, which will be required in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Let's install and configure Postman.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://www.getpostman.com](https://www.getpostman.com) to download and
    install Postman.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Postman for authenticated calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to configure Postman so that we can access our authenticated
    endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: Bring up your server and database using either `docker-compose up` or `npm run
    start:backend`. Remember, make sure that, first and foremost, you're able to execute
    the sample server provided on GitHub at [https://github.com/duluca/lemon-mart-server](https://github.com/duluca/lemon-mart-server).
    Getting your own version of the server going is a secondary goal.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new collection named `LemonMart`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a POST request with the URL `http://localhost:3000/v1/auth/login`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the headers, set the key-value pair, Content-Type: `application/json`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the body section, provide the email and password for the demo user login
    that we defined in the top-level `.env` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Hit **Send** to log in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `accessToken`, as shown here:![](img/B14094_10_09.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.9: Setting up Postman'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the settings icon in the top-right corner to manage environments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new environment called LemonMart Server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable named `token`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the `accessToken` value you have as the current value (no parentheses).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Add**/**Update**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Going forward, when you add a new request in Postman, you must provide the
    token variable as an authorization header, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_10_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: Providing a token in Postman'
  prefs: []
  type: TYPE_NORMAL
- en: When using Postman, always make sure that the correct environment is selected
    in the dropdown in the top-right corner.
  prefs: []
  type: TYPE_NORMAL
- en: Switch over to the **Authorization** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Bearer Token** as the type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the token variable as `{{token}}`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you **Send** your request, you should see the results. Be mindful that
    when your token expires, you will need to repeat this process.
  prefs: []
  type: TYPE_NORMAL
- en: Postman automation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using Postman, we can automate the execution of requests. In order to create
    sample users in our system, we can leverage this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new POST request for `http://localhost:3000/v2/user` named **Create
    Users**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `token` in the **Authorization** tab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Body** tab, provide a templated JSON object, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the purposes of this example, I'm only templating the email and the first
    and last name fields. You may template all properties.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement a Postman **Pre-request Script**, which executes arbitrary logic
    before sending a request. The script will define an array of people, and one by
    one set the current environment variable to be the next row as requests are executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For more information on pre-request scripts, check out [https://learning.postman.com/docs/postman/scripts/pre-request-scripts/](https://learning.postman.com/docs/postman/scripts/pre-request-scripts/).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Switch to the **Pre-request Script** tab and implement the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`pm` is a global variable that stands for **P**ost**M**an.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the first line, we get the `people` array from the environment. During the
    first request, this won't exist, which allows us to initialize the array with
    our test data. Next, we shift to the next record, and set the individual variables
    we used in our templated request body. Then, we save the current state of the
    array back to the environment, so, during the next execution, we can shift to
    the next record, until such time as we run out of records.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement a `test` script in the **Tests** tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to save your request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we define a `test` script, which will continue to execute until `people.length`
    reaches zero. With each iteration, we call the **Create Users** request. When
    there are no people left, we call `null` to terminate the test.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you may imagine, you can combine multiple requests and multiple environment
    variables to execute sophisticated tests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, execute the script using **Runner**, located in the top-left corner of
    the screen:![](img/B14094_10_11.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.11: Runner button in the top-left corner of the Postman UI'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Update your `login` token before moving on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the runner as shown:![](img/B14094_10_12.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.12: Collection Runner configuration'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the **LemonMart** collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **LemonMart Server** environment, which contains the `token` variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Only select the **Create Users** request.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on **Run LemonMart** to execute.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If your run succeeded, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_10_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.13: Collection Runner results'
  prefs: []
  type: TYPE_NORMAL
- en: If you use Studio 3T as a MongoDB explorer, you can observe that all records
    have been created or you can check them out with Postman, when we implement the
    `/v2/users` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Note that since we have a unique email index, your run partially succeeds on
    the next run. POST requests for already created records will return a `400 Bad
    Request`.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about Studio 3T at [https://studio3t.com/](https://studio3t.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Put User
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already covered how to create a POST request in the *Services* section
    earlier in the chapter. Now, let''s see how you can update an existing user record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We set `userData` from the request body. We then `delete` the `_id` property
    that's in the body, since the URL parameter is the authoritative source of information.
    Additionally, this prevents a user's ID from being accidentally changed to a different value.
  prefs: []
  type: TYPE_NORMAL
- en: We then leverage the `findOneAndUpdate` method to locate and update the record.
    We query for the record using the ID. We update the record by using MongoDB's
    `$set` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we load the saved record from the database and return it back to the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: POST and PUT methods should always respond with the updated state of the record.
  prefs: []
  type: TYPE_NORMAL
- en: For our last piece of implementation, let's review API endpoints that can support
    paginated data tables.
  prefs: []
  type: TYPE_NORMAL
- en: Pagination and filtering with DocumentTS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By far the most useful functionality of DocumentTS is `findWithPagination`,
    as mentioned in the *About DocumentTS* section. Let''s leverage `findWithPagination`
    to implement the `/v2/users` endpoint, which can return all users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: We copy all the parameters from the URL using the `req.query` object as local
    variables. We define an additional property named `projectionKeyOrList` to limit
    the properties of a record that can be returned to the client. In this case, only
    the `email`, `role`, `_id`, and `name` properties will be returned. This minimizes
    the amount of data that is sent over the wire.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we simply pass the new `query` object to the `findWithPagination` function
    and return the results to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a new request in Postman to verify the correct functionality
    of your new endpoint, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_10_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.14: Calling get users with Postman'
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 12*, *Recipes – Master/Detail, Data Tables, and NgRx*, we will implement
    a paginated data table that takes advantage of the filtering, sorting, and data
    limiting features.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You now have a grasp on how code works across the entire stack
    of software, from the database to the frontend and back.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered full-stack architecture. You learned about building
    a minimal MEAN stack. You now know how to create a monorepo for a full-stack application
    and configure a Node.js server with TypeScript. You containerized your Node.js
    server and declaratively defined your infrastructure with Docker Compose. Using
    Docker Compose with CircleCI, you verified your infrastructure in a CI environment.
  prefs: []
  type: TYPE_NORMAL
- en: You designed a RESTful API using Swagger and the OpenAPI spec, set up an Express.js
    app and configured it such that you can integrate your Swagger definition as documentation
    for your APIs. You configured MongoDB with the DocumentTS ODM so you can easily
    connect and query documents. You defined a user model with password hashing features.
  prefs: []
  type: TYPE_NORMAL
- en: You then implemented a JWT-based authentication service. You implemented an
    `authenticate` middleware to secure API endpoints and allow role-based access.
    You learned how to interact with RESTful APIs using Postman. Using Postman's automation
    features, you generated test data. Finally, you implemented RESTful APIs for authentication
    functions and CRUD operations for users.
  prefs: []
  type: TYPE_NORMAL
- en: In the next two chapters, we will go over Angular recipes to create forms and
    data tables. You will want your Lemon Mart Server up and running to verify the
    correct functionality of your forms and tables as you implement them.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You secured your endpoints using the `authenticate` middleware. You configured
    Postman to send a valid token so that you can communicate with your secured endpoints.
    By way of an exercise, try removing the `authenticate` middleware and call the
    same endpoint with and without a valid token. Re-add the middleware and try the
    same thing again. Observe the different responses you get from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*What is DX? (Developer Experience)*, Albert Cavalcante, 2019: [https://medium.com/@albertcavalcante/what-is-dx-developer-experience-401a0e44a9d9](https://medium.com/@albertcavalcante/what-is-dx-developer-experience-401a0e44a9d9
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Overview of Blocking versus Non-Blocking*, 2020: [https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/](https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Explain Non-Blocking I/O like I''m Five, Frank Rosner*, 2019: [https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/](https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*OpenAPI Specification*, 2020: [https://swagger.io/docs/specification](https://swagger.io/docs/specification
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Serialization*, 2020: [https://en.wikipedia.org/wiki/Serialization](https://en.wikipedia.org/wiki/Serialization
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JSON*, 2020: [https://en.wikipedia.org/wiki/JSON](https://en.wikipedia.org/wiki/JSON
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Aggregation in MongoDB*, 2020: [https://docs.mongodb.com/manual/aggregation](https://docs.mongodb.com/manual/aggregation
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Answer the following questions as best as you can to ensure that you've understood
    the key concepts from this chapter without Googling. Do you need help answering
    the questions? See *Appendix D*, *Self-Assessment Answers* online at [https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf)
    or visit [https://expertlysimple.io/angular-self-assessment](https://expertlysimple.io/angular-self-assessment).
  prefs: []
  type: TYPE_NORMAL
- en: What are the main components that make for a great developer experience?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a `.env` file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `authenticate` middleware?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Docker Compose differ from using the `Dockerfile`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an ODM? How does it differ from an ORM?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is middleware?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the uses of Swagger?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you refactor the code for the `/v2/users/{id} PUT` endpoint in `userRouter.ts`,
    so the code is reusable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
