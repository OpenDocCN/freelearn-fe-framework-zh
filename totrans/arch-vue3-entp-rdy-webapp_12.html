<html><head></head><body>
<div id="_idContainer095">
<h1 class="chapter-number" id="_idParaDest-196"><a id="_idTextAnchor471"/><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 id="_idParaDest-197"><a id="_idTextAnchor472"/><span class="koboSpan" id="kobo.2.1">Deploying Enterprise-Ready Vue.js 3</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we explored everything related to </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">end-to-end</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">e2e</span></strong><span class="koboSpan" id="kobo.7.1">) testing. </span><span class="koboSpan" id="kobo.7.2">We learned in depth how to perform e2e testing on a Vue.js 3 component and pages. </span><span class="koboSpan" id="kobo.7.3">In addition, we also learned about end-to-end testing tools such as Cypress and Puppeteer, and how to use them to test an enterprise </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">project effectively.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, we will learn how to deploy Vue.js 3 projects to the AWS cloud. </span><span class="koboSpan" id="kobo.9.2">We will learn the best practices for deploying to AWS. </span><span class="koboSpan" id="kobo.9.3">In addition, we will learn how enterprise companies deploy their enterprise Vue.js </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">3 applications.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">Additionally, we will learn about and explore different deployment options and best practices to deploy your Vue.js 3 project to various cloud providers. </span><span class="koboSpan" id="kobo.11.2">We will learn how to deploy the app to AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">and Azure.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">We will cover the following key topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.15.1">Introduction </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">to CI/CD</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Overview </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">of CI/CD</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">What is a </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">deployment pipeline?</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Overview of </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">GitHub Actions</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Deploying </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">to AWS</span></span></li>
</ul>
<h1 id="_idParaDest-198"><a id="_idTextAnchor473"/><span class="koboSpan" id="kobo.25.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.26.1">To get started, I recommend reading through </span><a href="B17237_11.xhtml#_idTextAnchor420"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.27.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.28.1">, </span><em class="italic"><span class="koboSpan" id="kobo.29.1">Industry Standard End-to-End Testing</span></em><span class="koboSpan" id="kobo.30.1">, where we explored the concept of e2e testing and what to test from an array of components and methods available. </span><span class="koboSpan" id="kobo.30.2">We will rely heavily on the knowledge of that chapter in this chapter to learn about Vue.js 3 enterprise </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">unit testing.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">All the code files of this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">at </span></span><a href="https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-12"><span class="No-Break"><span class="koboSpan" id="kobo.34.1">https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-12</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.35.1">.</span></span></p>
<h1 id="_idParaDest-199"><a id="_idTextAnchor474"/><span class="koboSpan" id="kobo.36.1">Introduction to CI/CD</span></h1>
<p><span class="koboSpan" id="kobo.37.1">Developing an enterprise-level application is easy, but constantly deploying newly developed changes, bug fixes, or </span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.38.1">features to your users is a daunting process, especially if done frequently, and especially for enterprise-ready applications. </span><span class="koboSpan" id="kobo.38.2">In addition, as your application, teams, and deployment infrastructure grows in complexity, continuously releasing and deploying new changes, features, and products to customers can be a </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">complicated process.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">To solve the complicated process of developing, testing, and releasing software quickly and consistently, three related but distinct strategies have been created by developers and organizations to manage and automate </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">these processes.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">In the next section, we will explore these three pillars, called CI/CD, and explain each of these strategies and how they relate to each other. </span><span class="koboSpan" id="kobo.42.2">Most importantly, we will explore how to build and incorporate these strategies into our enterprise application life cycle so that it can transform our software development and </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">release practices.</span></span><a id="_idTextAnchor475"/></p>
<h1 id="_idParaDest-200"><a id="_idTextAnchor476"/><span class="koboSpan" id="kobo.44.1">Overview of CI/CD</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.45.1">CI</span></strong><span class="koboSpan" id="kobo.46.1">/</span><strong class="bold"><span class="koboSpan" id="kobo.47.1">CD</span></strong><span class="koboSpan" id="kobo.48.1"> stands for </span><strong class="bold"><span class="koboSpan" id="kobo.49.1">continuous integration</span></strong><span class="koboSpan" id="kobo.50.1">/</span><strong class="bold"><span class="koboSpan" id="kobo.51.1">continuous delivery</span></strong><span class="koboSpan" id="kobo.52.1">. </span><span class="koboSpan" id="kobo.52.2">It is a strategy that allows enterprise teams to ship software faster and more efficiently. </span><span class="koboSpan" id="kobo.52.3">It enables a streamlined approach for</span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.53.1"> getting products to the market more quickly than ever before, allowing for a steady stream of code to be released into production and providing a steady stream of new features and bug fixes through the most efficient means </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">of delivery.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">A CI/CD pipeline is written to automate the software delivery process from the development stage to the production environment. </span><span class="koboSpan" id="kobo.55.2">It builds, tests, and safely deploys a new version of </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">an application.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">The main advantage of automated pipelines is that it removes the manual errors that can be detected during deployment and provides standardized feedback loops to developers for faster </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">product iterations.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">CI/CD is a combination of different strategies and pillars that come together to create a strong pipeline for delivering enterprise software; we will explore these strategies in detail in </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">this section.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer088">
<span class="koboSpan" id="kobo.61.1"><img alt="Figure 12.1 – CI/CD﻿" src="image/Figure_12.01_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.62.1">Figure 12.1 – CI/CD</span><a id="_idTextAnchor477"/></p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor478"/><span class="koboSpan" id="kobo.63.1">Continuous integration</span></h2>
<p><span class="koboSpan" id="kobo.64.1">CI is a process that allows developers in a team to frequently integrate their code into a shared repository. </span><span class="koboSpan" id="kobo.64.2">These </span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.65.1">developers can write their code in isolation and integrate it using a continuous integration process. </span><span class="koboSpan" id="kobo.65.2">This practice encourages each developer to build in isolation and integrate code with the shared repository multiple times throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">the day.</span></span></p>
<p><span class="koboSpan" id="kobo.67.1">When code is integrated early in the development cycle, developers can discover conflicts at the boundaries between new and existing code early. </span><span class="koboSpan" id="kobo.67.2">This process minimizes the cost of integration by making it an </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">early consideration.</span></span></p>
<p><span class="koboSpan" id="kobo.69.1">By implementing a proper continuous integration strategy, development teams can reduce integration costs and respond to </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">defects early.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">For an enterprise team to succeed in robust, automated, and fast integration, deployment, and delivery of enterprise software, the culture of frequent iteration and responsiveness to build issues must </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">be cultivated</span><a id="_idTextAnchor479"/><span class="koboSpan" id="kobo.73.1">.</span></span></p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor480"/><span class="koboSpan" id="kobo.74.1">Continuous delivery</span></h2>
<p><span class="koboSpan" id="kobo.75.1">CD is an extension of continuous integration that is aimed at streamlining the software delivery process and allowing teams to deploy their code to production with ease and assurance. </span><span class="koboSpan" id="kobo.75.2">It seeks to</span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.76.1"> reduce the difficulty of the deployment or release process by automating the steps necessary to deploy a build, thus enabling code to be released securely at </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">any time.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">Additionally, continuous delivery is a process that allows for the automated transfer of finished code to various settings, such as testing and development. </span><span class="koboSpan" id="kobo.78.2">It provides a reliable and automated method for the code to be sent to </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">these areas.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">In addition, continuous delivery encompasses the provisioning and deployment of infrastructure, which can be done manually and involve multiple steps. </span><span class="koboSpan" id="kobo.80.2">This type of delivery usually automates these processes with the involvement of the </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">entire team.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">Continuous delivery relies on a deployment pipeline to automate the process of running increasingly comprehensive test suites against a build, with each stage being a sequential step. </span><span class="koboSpan" id="kobo.82.2">If the build fails the test, the team is notified, but if it passes, it is automatically advanced to the </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">next stage.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">It is essential for enterprise software teams to implement continuous delivery, as it automates the process between committing code to the repository and determining whether to deploy well-tested, functional builds to the production environment. </span><span class="koboSpan" id="kobo.84.2">This step helps ensure that the quality and accuracy of the code are automated, while the ultimate decision of what to release is left up to the </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">engineering tea</span><a id="_idTextAnchor481"/><span class="koboSpan" id="kobo.86.1">m.</span></span></p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor482"/><span class="koboSpan" id="kobo.87.1">Continuous deployment</span></h2>
<p><span class="koboSpan" id="kobo.88.1">Continuous deployment is an extension of continuous delivery that deploys each build that passes the full test cycle </span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.89.1">without manual intervention. </span><span class="koboSpan" id="kobo.89.2">This is beneficial, as manual deployment can cause delays and irregular deployment. </span><span class="koboSpan" id="kobo.89.3">A continuous deployment system will deploy any build that has gone through the deployment pipeline that was set up during the continuous </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">delivery stage.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">In addition, deploying your code automatically doesn’t mean that new features cannot be activated or deactivated conditionally. </span><span class="koboSpan" id="kobo.91.2">In fact, continuous deployment can be configured to only deploy a specific feature to a subset of users or be activated conditionally at a </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">later time.</span></span></p>
<p><span class="koboSpan" id="kobo.93.1">The debate surrounding continuous deployment is often focused on the safety of automated deployment and whether the risk it poses is worth the reward. </span><span class="koboSpan" id="kobo.93.2">Nevertheless, it can also be advantageous for organizations, as they can receive constant feedback on new features and quickly detect any errors before too much time and energy </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">is wasted.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">We have explored the </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.96.1">concept of CI/CD and how to automate deploying and releasing enterprise projects. </span><span class="koboSpan" id="kobo.96.2">In the next section, we will explore the deployment pipeline and how to create an enterprise-ready deployment pipeline for the enterprise Vue.js </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">3 applicat</span><a id="_idTextAnchor483"/><span class="koboSpan" id="kobo.98.1">ion.</span></span></p>
<h1 id="_idParaDest-204"><a id="_idTextAnchor484"/><span class="koboSpan" id="kobo.99.1">What is a deployment pipeline?</span></h1>
<p><span class="koboSpan" id="kobo.100.1">The deployment</span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.101.1"> pipeline streamlines the deployment and delivery of your enterprise application. </span><span class="koboSpan" id="kobo.101.2">It compiles the code, executes all the tests, and securely deploys a new version of </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">Automating your deployment and delivery processes using deployment pipelines removes manual errors, provides standardized feedback loops to developers, and enables fast </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">product iterations.</span></span></p>
<p><span class="koboSpan" id="kobo.105.1">Furthermore, when building enterprise products, your organizational structure and development team and pattern will determine the strategies used to create your deployment pipeline, as it can differ from project </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">to project.</span></span></p>
<p><span class="koboSpan" id="kobo.107.1">However, there are different strategies already used in enterprise projects that can be adopted and modified </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">if necessary.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">In deployment pipelines, there are required stages (or elements) that make up a CI/CD pipeline. </span><span class="koboSpan" id="kobo.109.2">In the next section, we are going to explore these elements and learn how to set up our deployment pipeline for our demo </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">enterprise pro</span><a id="_idTextAnchor485"/><span class="koboSpan" id="kobo.111.1">ject.</span></span></p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor486"/><span class="koboSpan" id="kobo.112.1">Elements of a deployment pipeline</span></h2>
<p><span class="koboSpan" id="kobo.113.1">A deployment </span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.114.1">pipeline is composed of executable instructions that any developer must follow in order to release a new version of a </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">software product.</span></span></p>
<p><span class="koboSpan" id="kobo.116.1">The beauty of an automated deployment pipeline is that it replaces the manual process of carrying out the exact specification laid out for the deployment and delivery of enterprise software by automating </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">the process.</span></span></p>
<p><span class="koboSpan" id="kobo.118.1">The following figure shows the typical software release stages in most </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">enterprise software:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer089">
<span class="koboSpan" id="kobo.120.1"><img alt="Figure 12.2 – Elements of a deployment pipeline" src="image/Figure_12.02_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.121.1">Figure 12.2 – Elements of a deployment pipeline</span></p>
<p><span class="koboSpan" id="kobo.122.1">These stages can be performed manually, provided each step is followed accordingly. </span><span class="koboSpan" id="kobo.122.2">However, the downside is enormous, as you can </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">see here:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.124.1">Time-consuming</span></strong><span class="koboSpan" id="kobo.125.1">: Manual </span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.126.1">deployment can take a long time to complete, especially if there are multiple components that need to </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">be deployed</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.128.1">Error-prone</span></strong><span class="koboSpan" id="kobo.129.1">: Manual deployment is prone to human errors, which can lead to costly mistakes </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">and downtime</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.131.1">Lack of scalability</span></strong><span class="koboSpan" id="kobo.132.1">: Manual deployment is not easily scalable, as it requires manual intervention for each component that needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">be deployed</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.134.1">To avoid this, an automated </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.135.1">deployment pipeline has been created to carry out the stages and alert the responsible developer of any errors, or to send notifications through email, Slack, and so on. </span><span class="koboSpan" id="kobo.135.2">Additionally, the pipeline can also notify the whole team when a successful deployment to production has </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">been completed.</span></span></p>
<p><span class="koboSpan" id="kobo.137.1">Now, let’s examine each of the stages to understand what goes in. </span><span class="koboSpan" id="kobo.137.2">This will aid us in understanding how to develop a good deployment pipeline for our enterprise Vue.js </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">3 appli</span><a id="_idTextAnchor487"/><span class="koboSpan" id="kobo.139.1">cation.</span></span></p>
<h3><span class="koboSpan" id="kobo.140.1">Source stage</span></h3>
<p><span class="koboSpan" id="kobo.141.1">At the source </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.142.1">stage, a pipeline is typically initiated by a source code repository. </span><span class="koboSpan" id="kobo.142.2">Whenever there is a change in the code, it notifies the CI/CD process to execute the related pipeline. </span><span class="koboSpan" id="kobo.142.3">Additionally, other common triggers include user-initiated workflows and automated </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">scheduled wo</span><a id="_idTextAnchor488"/><span class="koboSpan" id="kobo.144.1">rkflows.</span></span></p>
<h3><span class="koboSpan" id="kobo.145.1">Build stage</span></h3>
<p><span class="koboSpan" id="kobo.146.1">In the build stage, we combine the source code and all its dependencies to build a runnable instance of</span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.147.1"> the project that is intended to ship to the users. </span><span class="koboSpan" id="kobo.147.2">At this stage, the software is compiled or bundled together with </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">its dependencies.</span></span></p>
<p><span class="koboSpan" id="kobo.149.1">The build phase attempts to package the project to make it deployable. </span><span class="koboSpan" id="kobo.149.2">If the build stage encounters any problems, this is a sign of an underlying issue with the project’s setup or configuration and should be taken care of </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">ri</span><a id="_idTextAnchor489"/><span class="koboSpan" id="kobo.151.1">ght away.</span></span></p>
<h3><span class="koboSpan" id="kobo.152.1">Test stage</span></h3>
<p><span class="koboSpan" id="kobo.153.1">Once the build stage is finished </span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.154.1">successfully, the next step is to conduct the test stage. </span><span class="koboSpan" id="kobo.154.2">This stage involves running automated tests to make sure the code is accurate and the project is functioning correctly. </span><span class="koboSpan" id="kobo.154.3">This stage serves as a safeguard to ensure that any bugs that can be easily reproduced are not sent to the end users or passed through </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">the pipeline.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">At this stage, all the test cases written by developers (including, but not limited to, unit tests, integration tests, e2e testing, etc.) are all tested and checked to make sure they all pass before allowing the current build to proceed to the </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">deployment stage.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">The testing stage is critical for identifying any issues with the code that the developer may have</span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.159.1"> overlooked. </span><span class="koboSpan" id="kobo.159.2">This feedback is important to the developer as it is provided while the problem is still fresh in their mind. </span><span class="koboSpan" id="kobo.159.3">If any failures occur during the test stage, they can reveal problems i</span><a id="_idTextAnchor490"/><span class="koboSpan" id="kobo.160.1">n </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">the code.</span></span></p>
<h3><span class="koboSpan" id="kobo.162.1">Deploy stage</span></h3>
<p><span class="koboSpan" id="kobo.163.1">Prior to this stage, the</span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.164.1"> pipeline has created a functioning version of the new code or modifications that have passed all the predetermined tests and is now ready to </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">deploy it.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">Generally, there are multiple deployment environments that have been established for the development team, such as a “staging” environment for the product team, a “development” environment for the development team, and a “production” environment for the </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">end users.</span></span></p>
<p><span class="koboSpan" id="kobo.168.1">Depending on the team, organization, and model chosen, various deployment environments can be established. </span><span class="koboSpan" id="kobo.168.2">Teams that have adopted the Agile model of development, which is based on tests and real-time observation, often deploy to the staging environment for further manual testing and examination before pushing out accepted modifications to production for th</span><a id="_idTextAnchor491"/><span class="koboSpan" id="kobo.169.1">e </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">end users.</span></span></p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor492"/><span class="koboSpan" id="kobo.171.1">Overview of a deployment pipeline</span></h2>
<p><span class="koboSpan" id="kobo.172.1">In this section, we</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.173.1"> are going to explore a practical example of a deployment pipeline. </span><span class="koboSpan" id="kobo.173.2">Pipelines are the reflection of the complexity of a project. </span><span class="koboSpan" id="kobo.173.3">Therefore, configuring a pipeline that runs on every code change will save a team many pains and repetitive tasks in </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">the future.</span></span></p>
<p><span class="koboSpan" id="kobo.175.1">The following figure shows a clear example of a deployment pipeline and the different jobs that need to </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">be performed.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">source</span></strong><span class="koboSpan" id="kobo.179.1"> stage is triggered when changes are pushed to a specific branch that the CI/CD is activated on and it moves to the build stage where it compiles that code using a compiler, if any, or uses a </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">docker build</span></strong><span class="koboSpan" id="kobo.181.1"> process to build the </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">project’s image.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">Next, the testing</span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.184.1"> stage runs all the necessary and activated test cycles, such as unit tests, integration tests, and </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">end-to-end tests.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">After successful testing, the pipeline moves to the deploy stage, where the code is deployed to a live staging environment for further testing before finally deploying to the </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">production environment.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer090">
<span class="koboSpan" id="kobo.188.1"><img alt="Figure 12.3 – Example of a deployment pipeline" src="image/Figure_12.03_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.189.1">Figure 12.3 – Example of a deployment pipeline</span></p>
<p><span class="koboSpan" id="kobo.190.1">In the preceding figure, we have explored the overview of a deployment pipeline, the different stages, and</span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.191.1"> what goes under the hood of each different stage. </span><span class="koboSpan" id="kobo.191.2">In this section, we have explored deployment pipelines and the different stages that are involved in them. </span><span class="koboSpan" id="kobo.191.3">Next, we will discuss how to deploy our Pinterest demo to the AWS cloud using </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">G</span><a id="_idTextAnchor493"/><span class="koboSpan" id="kobo.193.1">itHub Actions.</span></span></p>
<h1 id="_idParaDest-207"><a id="_idTextAnchor494"/><span class="koboSpan" id="kobo.194.1">Overview of GitHub Actions</span></h1>
<p><span class="koboSpan" id="kobo.195.1">In the world of CI/CD, there are numerous tools have been created to automate the process of building, testing, and </span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.196.1">deploying projects. </span><span class="koboSpan" id="kobo.196.2">GitHub Actions happens to be one of those tools and has greatly </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">gained popularity.</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">GitHub Actions is a CI/CD platform that allows developers to automate the process of building, testing, and running </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">deployment pipelines.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">GitHub Actions became popular because it is directly integrated into GitHub and can be configured to create workflows that build and test every pull request to your repository or deploy merged pull requests </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">to production.</span></span></p>
<p><span class="koboSpan" id="kobo.202.1">There are tons of concepts to learn about GitHub Actions: the different terminologies, concepts, benefits, and advantages of using GitHub Actions over other CI/CD platforms. </span><span class="koboSpan" id="kobo.202.2">You can learn all this from the official documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">at </span></span><a href="https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions"><span class="No-Break"><span class="koboSpan" id="kobo.204.1">https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.205.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.206.1">Nevertheless, we will show you how to create a deployment pipeline for the Pinterest demo project we developed in </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">previous chapters.</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">Deploying an enterprise project is tedious and requires lots of checks to make sure that frequent bugs do not surface </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">in production.</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">There are many factors to check before deploying an enterprise project, from linting, formatting, and styling, to testing. </span><span class="koboSpan" id="kobo.210.2">The list is endless and sometimes depends on your team and how the development workflow is </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">set up.</span></span></p>
<p><span class="koboSpan" id="kobo.212.1">In the next section, we are going to explore the different stages or checks the project needs to pass before deploying</span><a id="_idTextAnchor495"/> <span class="No-Break"><span class="koboSpan" id="kobo.213.1">to production.</span></span></p>
<h2 id="_idParaDest-208"><a id="_idTextAnchor496"/><span class="koboSpan" id="kobo.214.1">Jobs in the deployment pipeline</span></h2>
<p><span class="koboSpan" id="kobo.215.1">The jobs in the deployment</span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.216.1"> pipeline vary from project to project and from team to team. </span><span class="koboSpan" id="kobo.216.2">In the following subsection, we look at some of the important jobs </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.217.1">you can build into your deployment pipeline to completely check your project before deployi</span><a id="_idTextAnchor497"/><span class="koboSpan" id="kobo.218.1">ng </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">to production.</span></span></p>
<h3><span class="koboSpan" id="kobo.220.1">Linting (Eslint, Stylelint, Prettier)</span></h3>
<p><span class="koboSpan" id="kobo.221.1">Linting is a process in which a linter program reviews the source code of a particular programming language or code base</span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.222.1"> to detect any potential issues such as errors, bugs, stylistic errors, and suspicious constructs. </span><span class="koboSpan" id="kobo.222.2">This is beneficial in recognizing both common and uncommon mistakes that can be made when coding. </span><span class="koboSpan" id="kobo.222.3">Furthermore, linting will go through your source code to identify any formatting discrepancies, check for compliance with coding standards and conventions, and pinpoint potential logical errors in </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">your program.</span></span></p>
<p><span class="koboSpan" id="kobo.224.1">Also, linting helps with developer experience in a team by creating a consistent code base throughout the </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">development team.</span></span></p>
<p><span class="koboSpan" id="kobo.226.1">We are going to set up linting in our pipeline to enforce consistency between the style guide, formatting, and naming conventions in our deployment pipeline, </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.228.1">
lint:
  runs-on: ubuntu-latest
  steps:
    - uses: actions/checkout@v3
    - run: |
        yarn</span><a id="_idTextAnchor498"/><span class="koboSpan" id="kobo.229.1">
        yarn lint</span></pre>
<h3><span class="koboSpan" id="kobo.230.1">Lighthouse budget checks</span></h3>
<p><span class="koboSpan" id="kobo.231.1">Lighthouse is an open source, automated </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.232.1">tool for improving the quality of web pages. </span><span class="koboSpan" id="kobo.232.2">This tool allows you to run tests against web pages (public or requiring authentication). </span><span class="koboSpan" id="kobo.232.3">It helps developers audit web pages for performance, accessibility, SEO, </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">and more.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">In addition, you can automate this process by adding it to your deployment pipeline to test for performance of your web page before deploying it to the users. </span><span class="koboSpan" id="kobo.234.2">This process allows enterprise-ready application developers to automate the process of testing the performance of the </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.235.1">application in </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">real time.</span></span></p>
<p><span class="koboSpan" id="kobo.237.1">The action allows us to set numerous options, including </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.239.1">Testing against </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">multiple paths</span></span></li>
<li><span class="koboSpan" id="kobo.241.1">Providing a </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">budget path</span></span></li>
<li><span class="koboSpan" id="kobo.243.1">The number of runs (how many times the CI should audit </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">an URL)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.245.1">We are going to set up the Lighthouse bot (</span><a href="https://github.com/ebidel/lighthousebot"><span class="koboSpan" id="kobo.246.1">https://github.com/ebidel/lighthousebot</span></a><span class="koboSpan" id="kobo.247.1">) with GitHub Actions to audit our deployment and User Experience (</span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">UX) integrity.</span></span></p>
<p><span class="koboSpan" id="kobo.249.1">Here is a snippet of the job setup </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">for Lighthouse:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.251.1">
lighthouse:
   runs-on: ubuntu-latest
   needs: deploy
   steps:
     - uses: actions/checkout@v2
     - name: Run Lighthouse on urls and validate with
             lighthouserc
       uses: treosh/lighthouse-ci-action@v7
       with:
         urls: |
           ${{ needs.deploy.outputs.preview-url }}
         budgetPath: ./budget.json
         runs: 3</span></pre>
<p><span class="koboSpan" id="kobo.252.1">The preceding code is used to add the Lighthouse plugin to the deployment pipeline, and the plugin uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">actions/checkout</span></strong><span class="koboSpan" id="kobo.254.1"> plugin to access the repository workspace in other to access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">budget.json</span></strong><span class="koboSpan" id="kobo.256.1"> file, which contains the task that Lighthouse should perform. </span><span class="koboSpan" id="kobo.256.2">This Lighthouse GitHub Action is extremely beneficial for websites that depend on Google search traffic. </span><span class="koboSpan" id="kobo.256.3">If not addressed early on, it is very common for the </span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.257.1">bundle sizes to become larger as a website is developed, resulting in a lower Lighthouse score. </span><span class="koboSpan" id="kobo.257.2">This action allows us to monitor any discrepanc</span><a id="_idTextAnchor499"/><span class="koboSpan" id="kobo.258.1">ies with </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">each commit.</span></span></p>
<h3><span class="koboSpan" id="kobo.260.1">Automated software testing</span></h3>
<p><span class="koboSpan" id="kobo.261.1">Software testing is a vital factor for determining the status of your enterprise application and making sure it </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.262.1">conforms to the project requirements. </span><span class="koboSpan" id="kobo.262.2">As explored in the previous chapters, we have developed three major types of software testing and have practiced how to create better testing suites for our Pinterest </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">application demo.</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">Therefore, we are going to set up three jobs to run the entire software testing suites for our demo application. </span><span class="koboSpan" id="kobo.264.2">In our demo, the software testing suite comprises </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.266.1">Unit testing</span></span></li>
<li><span class="koboSpan" id="kobo.267.1">Integration (</span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">component) testing</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.269.1">E2e testing</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.270.1">The job will run each of these tests and respond accordingly. </span><span class="koboSpan" id="kobo.270.2">If the test fails, it will pause the deployment and report the problem to the development team via Slack notifications or emails. </span><span class="koboSpan" id="kobo.270.3">Otherwise, if the test passes, it will continue to the </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">next stages.</span></span></p>
<p><span class="koboSpan" id="kobo.272.1">Here is the snippet of all the </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">test setups:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.274.1">
unit_test:
  runs-on: ubuntu-latest
  steps:
    - uses: actions/checkout@v3
    - run: |
        yarn
        yarn test:unit
component_test:
  runs-on: ubuntu-latest
  needs: unit_test
  steps:
    - uses: actions/checkout@v3
    - run: |
        yarn
        yarn test:component
e2e_test:
  runs-on: ubuntu-latest
  needs: component_test
  steps:
    - uses: actions/checkout@v3
    - run: |
        yarn
        yarn test:e2e</span></pre>
<p><span class="koboSpan" id="kobo.275.1">The script sets up the testing stage, which contains scripts to run different testing cycles such as unit testing, integration </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.276.1">testing, and e2e testing. </span><span class="koboSpan" id="kobo.276.2">In each of the pipeline jobs, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">actions/checkout</span></strong><span class="koboSpan" id="kobo.278.1"> to check out the workspace repository, and next, we run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">yarn</span></strong><span class="koboSpan" id="kobo.280.1"> command to install all the packages before proceeding to run the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">test</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.282.1"> command.</span></span></p>
<h3><span class="koboSpan" id="kobo.283.1">Netlify deployment for staging</span></h3>
<p><span class="koboSpan" id="kobo.284.1">Netlify is a comprehensive platform that enables you to integrate your preferred tools and APIs to construct the fastest websites, stores, and applications for the composable web. </span><span class="koboSpan" id="kobo.284.2">It allows you to utilize any frontend framework to construct, preview, and deploy to the worldwide network </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">from Git.</span></span></p>
<p><span class="koboSpan" id="kobo.286.1">You can deploy your enterprise application to several environments, such as development, staging, and production, depending on your </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">team’s setup.</span></span></p>
<p><span class="koboSpan" id="kobo.288.1">GitHub Actions allows you to create several workflows for deploying to these different environments. </span><span class="koboSpan" id="kobo.288.2">Within </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.289.1">each environment, you can set up different jobs to be performed. </span><span class="koboSpan" id="kobo.289.2">For instance, you might not want to check for Lighthouse performance again since it was already tested when deploying to </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">staging environments.</span></span></p>
<p><span class="koboSpan" id="kobo.291.1">Here is a snippet to set up the job to deploy </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">to Netlify:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.293.1">
deploy:
   runs-on: ubuntu-latest
   needs: e2e_test
   steps:
     - uses: actions/checkout@v2
     - name: Deploy to Netlify
       uses: nwtgck/actions-netlify@v1.2
       id: deploy-to-netlify
       with:
         publish-dir: './dist'
         production-branch: master
         github-token: ${{ secrets.GITHUB_TOKEN }}
         deploy-message: "Deploy from GitHub Actions"
         enable-pull-request-comment: false
         enable-commit-comment: true
         overwrites-pull-request-comment: true
       env:
         NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN
                              }}
         NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
       timeout-minutes: 1
   outputs:
     preview-url:
       ${{ steps.deploy-to-netlify.outputs.deploy-url }}</span></pre>
<p><span class="koboSpan" id="kobo.294.1">The preceding script uses the Netlify GitHub Action plugin to deploy the Vue.js 3 application to Netlify. </span><span class="koboSpan" id="kobo.294.2">It requires a Netlify token and secrets (which are added in the Secrets section of our GitHub repository) and finally, it provides the preview URL </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">after deployment.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">In the next section, we are</span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.297.1"> going to create a complete deployment pipeline with GitHub Actions to set up a staging application for more manual testing before pushing it to the master branch, which will trigger the produc</span><a id="_idTextAnchor500"/><span class="koboSpan" id="kobo.298.1">tion </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">deployment pipeline.</span></span></p>
<h1 id="_idParaDest-209"><a id="_idTextAnchor501"/><span class="koboSpan" id="kobo.300.1">Creating the deployment pipeline with GitHub Actions</span></h1>
<p><span class="koboSpan" id="kobo.301.1">To create a deployment </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.302.1">pipeline with GitHub Actions, we need to create configuration files for each pipeline </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">configuration environment.</span></span></p>
<p><span class="koboSpan" id="kobo.304.1">Follow the steps mentioned </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.305.1">next to create your first deployment pipeline for your staging environment using </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">GitHub Actions.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">Open the Pinterest demo application or clone it from the official repository for this chapter to see a complete setup of the </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">GitHub Actions.</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">If you’re following along, create a new file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">staging.yml</span></strong><span class="koboSpan" id="kobo.311.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">github/workflows</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.314.1"> folder.</span></span></p>
<p><span class="koboSpan" id="kobo.315.1">It’s important to note that the name of the folders must be exactly the same for GitHub Actions to pick the configuration </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.316.1">up when</span><a id="_idTextAnchor502"/><span class="koboSpan" id="kobo.317.1"> pushing to </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">your</span></span><span class="No-Break"><a id="_idIndexMarker522"/></span><span class="No-Break"><span class="koboSpan" id="kobo.319.1"> repository.</span></span></p>
<h3><span class="koboSpan" id="kobo.320.1">Pipeline for the staging environment</span></h3>
<p><span class="koboSpan" id="kobo.321.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">staging.yml</span></strong><span class="koboSpan" id="kobo.323.1"> file and add </span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.324.1">the following scripts to create a deployment pipeline for the </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">staging environment:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.326.1">
on:
pull_request:
  branches:
    - chapter-12
jobs:
lint:
  runs-on: ubuntu-latest
  steps:
    - uses: actions/checkout@v3
    - run: |
        yarn
        yarn lint
unit_test:
  runs-on: ubuntu-latest
  steps:
    - uses: actions/checkout@v3
    - run: |
        yarn
        yarn test:unit
component_test:
  runs-on: ubuntu-latest
  needs: unit_test
  steps:
    - uses: actions/checkout@v3
    - run: |
        yarn
        yarn test:component
e2e_test:
  runs-on: ubuntu-latest
  needs: component_test
  steps:
    - uses: actions/checkout@v3
    - run: |
        yarn
        yarn test:e2e
deploy:
   runs-on: ubuntu-latest
   needs: e2e_test
   steps:
     - uses: actions/checkout@v2
     - name: Deploy to Netlify
       uses: nwtgck/actions-netlify@v1.2
       id: deploy-to-netlify
       with:
         publish-dir: './dist'
         production-branch: master
         github-token: ${{ secrets.GITHUB_TOKEN }}
         deploy-message: "Deploy from GitHub Actions"
         enable-pull-request-comment: false
         enable-commit-comment: true
         overwrites-pull-request-comment: true
       env:
         NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
         NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
       timeout-minutes: 1
   outputs:
     preview-url:
       ${{ steps.deploy-to-netlify.outputs.deploy-url }}
lighthouse:
   runs-on: ubuntu-latest
   needs: deploy
   steps:
     - uses: actions/checkout@v2
     - name: Run Lighthouse on urls and validate with
             lighthouserc
       uses: treosh/lighthouse-ci-action@v7
       with:
         urls: |
           ${{ needs.deploy.outputs.preview-url }}
         budgetPath: ./budget.json
         runs: 3</span></pre>
<p><span class="koboSpan" id="kobo.327.1">In this section, we discussed</span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.328.1"> in detail how to automate the process of deploying your enterprise applications. </span><span class="koboSpan" id="kobo.328.2">We learned about deployment pipelines and how to create one with GitHub Actions. </span><span class="koboSpan" id="kobo.328.3">In the next section, we will learn how to deploy our app to </span><strong class="bold"><span class="koboSpan" id="kobo.329.1">AWS</span></strong><span class="koboSpan" id="kobo.330.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.331.1">Amazon Web Services</span></strong><span class="koboSpan" id="kobo.332.1">) production by automating the proc</span><a id="_idTextAnchor503"/><span class="koboSpan" id="kobo.333.1">ess using </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">deployment pipelines.</span></span></p>
<h1 id="_idParaDest-210"><a id="_idTextAnchor504"/><span class="koboSpan" id="kobo.335.1">Deploying to AWS</span></h1>
<p><span class="koboSpan" id="kobo.336.1">In this section, we are </span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.337.1">going to implement continuous deployment for the Vue.js 3 application with GitHub Actions and AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">App Runner.</span></span></p>
<p><span class="koboSpan" id="kobo.339.1">This process can be triggered manually after thoroughly checking the staging application to make sure it satisfies all requirements before pushing it to production. </span><span class="koboSpan" id="kobo.339.2">However, it can also be automated to happen immediately after the staging </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">is completed.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">In this demo, we are going to create the deployment pipeline for deploying to the AWS production server using AWS App Runner and also automate the process </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">at once.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.343.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.344.1">It’s advisable to trigger the deployment process manually, which gives room to manually check all the requirements on the staging environment before deploying a new release </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">to production.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">To deploy to AWS, you will need an AWS account and an AWS IAM account with proper permissions. </span><span class="koboSpan" id="kobo.346.2">In this section, we explored how to create pipelines and deploy our project to AWS. </span><span class="koboSpan" id="kobo.346.3">In the next section, we will continue deploying our project using Docker and the Dockerfile we c</span><a id="_idTextAnchor505"/><span class="koboSpan" id="kobo.347.1">reated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">previous chapters.</span></span></p>
<h2 id="_idParaDest-211"><a id="_idTextAnchor506"/><span class="koboSpan" id="kobo.349.1">Using Docker</span></h2>
<p><span class="koboSpan" id="kobo.350.1">In </span><a href="B17237_07.xhtml#_idTextAnchor230"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.351.1">Chapter 7</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.352.1">, Dockerizing a Vue 3 App</span></em><span class="koboSpan" id="kobo.353.1"> we </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.354.1">discussed the nitty-gritty involved in Dockerizing your Vue.js 3 project. </span><span class="koboSpan" id="kobo.354.2">In addition, we learned about the best practices and industry standards to Dockerize and deploy an enterprise Vue.js 3 </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">web application.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">We will use the Dockerfile we created for this project so that we can run it on AWS infrastructure as a </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">containerized</span></span><span class="No-Break"><a id="_idIndexMarker527"/></span><span class="No-Break"><span class="koboSpan" id="kobo.358.1"> application.</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">Update the Dockerfile we created before with the following </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.361.1">
# Use the official Node.js 14 Alpine image from https://hub.docker.com/_/node.
</span><span class="koboSpan" id="kobo.361.2"># Using an image with specific version tags allows deterministic builds.
</span><span class="koboSpan" id="kobo.361.3">FROM node:fermium-alpine3.14 AS builder
# Create and change to the app directory.
</span><span class="koboSpan" id="kobo.361.4">WORKDIR /app
# Copy important root files to the builder image.
</span><span class="koboSpan" id="kobo.361.5">COPY package*.json ./
# Install production dependencies.
</span><span class="koboSpan" id="kobo.361.6">RUN npm install
# Copy the Vue 3 source to the container image.
</span><span class="koboSpan" id="kobo.361.7">COPY . </span><span class="koboSpan" id="kobo.361.8">.
</span><span class="koboSpan" id="kobo.361.9"># build app for production with minification
RUN npm run build
# Production stage
FROM nginx:stable-alpine as production-stage
# Copy the Vue 3 source to the container image.
</span><span class="koboSpan" id="kobo.361.10">COPY --from=builder /app/dist /usr/share/nginx/html
VOLUME /app/node_modules
EXPOSE 80
# Run the Vue service on container startup.
</span><span class="koboSpan" id="kobo.361.11">CMD ["nginx", "-g", "daemon off;"]</span></pre>
<p><span class="koboSpan" id="kobo.362.1">This is the same Dockerfile we used in the previous chapter to Dockerize our project. </span><span class="koboSpan" id="kobo.362.2">You can refer back to the </span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.363.1">chapter to learn more about Dockerizing your Vue.js </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">3 application.</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">The base image will be </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">nginx:stable-alpine</span></strong><span class="koboSpan" id="kobo.367.1"> and the application will be listening on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">80</span></strong><span class="koboSpan" id="kobo.369.1">. </span><span class="koboSpan" id="kobo.369.2">For step-by-step Dockerizing guidelines, please refer to the official documentation from Vue.js </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">at </span></span><a href="https://v2.vuejs.org/v2/cookbook/dockerize-vuejs-app.html?redirect=true"><span class="No-Break"><span class="koboSpan" id="kobo.371.1">https://v2.vuejs.org/v2/cookbook/dockerize-vuejs-app.html?redirect=true</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.372.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.373.1">You can test the application container using the following Docker Compose command since we have already defined the </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.375.1"> file in </span><a href="B17237_07.xhtml#_idTextAnchor230"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.376.1">Chapter 7</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.377.1">, Dockerizing a Vue </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.378.1">3 App</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.380.1">
docker build -t vue-paper-dashboard .
</span><span class="koboSpan" id="kobo.380.2">docker run -dt --name vue-paper-dashboard -p 8080:80 vue-paper-dashboard:latest</span></pre>
<p><span class="koboSpan" id="kobo.381.1">After running the application container successfully, you should be able to access the dashboard via the same address as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">npm run dev</span></strong><span class="koboSpan" id="kobo.383.1"> command. </span><span class="koboSpan" id="kobo.383.2">N</span><a id="_idTextAnchor507"/><span class="koboSpan" id="kobo.384.1">ext, let’s provision </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">AWS resources.</span></span></p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor508"/><span class="koboSpan" id="kobo.386.1">Provisioning AWS resources</span></h2>
<p><span class="koboSpan" id="kobo.387.1">We will use</span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.388.1"> GitHub Actions to deploy our Vue.js 3 application to AWS continuously, so we need to create an IAM account and a user-managed role on AWS, w</span><a id="_idTextAnchor509"/><span class="koboSpan" id="kobo.389.1">hich will be used in the </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">next steps.</span></span></p>
<h3><span class="koboSpan" id="kobo.391.1">Creating an IAM account</span></h3>
<p><span class="koboSpan" id="kobo.392.1">This IAM account will be </span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.393.1">used by GitHub Actions agents. </span><span class="koboSpan" id="kobo.393.2">Access the console at </span><a href="https://us-east-1.console.aws.amazon.com/iamv2/home#/home"><span class="koboSpan" id="kobo.394.1">https://us-east-1.console.aws.amazon.com/iamv2/home#/home</span></a><span class="No-Break"> </span><span class="koboSpan" id="kobo.395.1">and create an IAM account and a user-managed role </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">on AWS.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer091">
<span class="koboSpan" id="kobo.397.1"><img alt="Figure 12.4 – Creating a new user in IAM for GitHub Actions" src="image/Figure_12.04_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.398.1">Figure 12.4 – Creating a new user in IAM for GitHub Actions</span></p>
<p><span class="koboSpan" id="kobo.399.1">Click on the </span><strong class="bold"><span class="koboSpan" id="kobo.400.1">Next: Permissions</span></strong><span class="koboSpan" id="kobo.401.1"> option and click the </span><strong class="bold"><span class="koboSpan" id="kobo.402.1">Create User</span></strong><span class="koboSpan" id="kobo.403.1"> button. </span><span class="koboSpan" id="kobo.403.2">Lastly, click on </span><strong class="bold"><span class="koboSpan" id="kobo.404.1">Download.csv</span></strong><span class="koboSpan" id="kobo.405.1"> to download</span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.406.1"> the credential for the new user and save it s</span><a id="_idTextAnchor510"/><span class="koboSpan" id="kobo.407.1">omewhere—we will need to use </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">it soon.</span></span></p>
<h3><span class="koboSpan" id="kobo.409.1">Creating a role for the IAM user</span></h3>
<p><span class="koboSpan" id="kobo.410.1">In this demonstration, we will be making a new role called </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">app-runner-service-role</span></strong><span class="koboSpan" id="kobo.412.1"> and attaching the </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">AWSAppRunnerServicePolicyForECRAccess</span></strong><span class="koboSpan" id="kobo.414.1"> policy. </span><span class="koboSpan" id="kobo.414.2">This role will be used by AWS </span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.415.1">App Runner services to give them access to Elastic Container Register (ECR) in order to manage our </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">Docker image.</span></span></p>
<p><span class="koboSpan" id="kobo.417.1">To create a service role, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.419.1">Click on the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.420.1">Role</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.421.1"> menu.</span></span></li>
<li><span class="koboSpan" id="kobo.422.1">Click on the </span><strong class="bold"><span class="koboSpan" id="kobo.423.1">Create Role</span></strong><span class="koboSpan" id="kobo.424.1"> button, select the </span><strong class="bold"><span class="koboSpan" id="kobo.425.1">Custom Trusted Policy</span></strong><span class="koboSpan" id="kobo.426.1"> option, and enter the </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">following JSON:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.428.1">
{
   "Version": "2012-10-17",
   "Statement": [
       {
           "Effect": "Allow",
           "Principal": {
               "Service":
                 "build.apprunner.amazonaws.com"
           },
           "Action": "sts:AssumeRole"
       }
   ]
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.429.1">This code snippet is a JSON file that is used to create a custom trusted policy for deploying to </span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.430.1">Amazon </span><strong class="bold"><span class="koboSpan" id="kobo.431.1">Elastic Container </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.432.1">Service</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.433.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.434.1">ECS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.436.1">After successfully creating </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">app-runner-service-role</span></strong><span class="koboSpan" id="kobo.438.1">, as shown in the following figure, make sure to copy and note the Amazon Resourse Name (ARN), as it will be </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">used later.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer092">
<span class="koboSpan" id="kobo.440.1"><img alt="Figure 12.5 – Creating app-runner-service-role" src="image/Figure_12.05_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.441.1">Figure 12.5 – Creating app-runner-service-role</span></p>
<p><span class="koboSpan" id="kobo.442.1">In this section, we worked through the step-by-step process of creating </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">app-runner-service-role</span></strong><span class="koboSpan" id="kobo.444.1"> and the </span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.445.1">Amazon IAM permission for ECS deployment. </span><span class="koboSpan" id="kobo.445.2">In the next section, we will</span><a id="_idTextAnchor511"/><span class="koboSpan" id="kobo.446.1"> be creating a policy for the </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">IAM user.</span></span></p>
<h3><span class="koboSpan" id="kobo.448.1">Creating a policy for the IAM user</span></h3>
<p><span class="koboSpan" id="kobo.449.1">Navigate to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">github-vue-pinterest-demo</span></strong><span class="koboSpan" id="kobo.451.1"> IAM permission and attach the following inline </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.452.1">policy, which will grant permission to GitHub Actions (via the IAM role) to work with ECR and </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">App </span></span><span class="No-Break"><a id="_idIndexMarker536"/></span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">Runner:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.455.1">
{
   "Version": "2012-10-17",
   "Statement": [
       {
           "Sid": "VisualEditor0",
           "Effect": "Allow",
           "Action": "apprunner:*",
           "Resource": "*"
       },
       {
           "Sid": "VisualEditor1",
           "Effect": "Allow",
           "Action": [
               "iam:PassRole",
               "iam:CreateServiceLinkedRole"
           ],
           "Resource": "*"
       },
       {
           "Sid": "VisualEditor2",
           "Effect": "Allow",
           "Action": "sts:AssumeRole",
           "Resource": "{ENTER_YOUR_SERVICE_ROLE_ARN_HERE}"
       },
       {
           "Sid": "VisualEditor3",
           "Effect": "Allow",
           "Action": [
               "ecr:GetDownloadUrlForLayer",
               "ecr:BatchGetImage",
               "ecr:BatchCheckLayerAvailability",
               "ecr:PutImage",
               "ecr:InitiateLayerUpload",
               "ecr:UploadLayerPart",
               "ecr:CompleteLayerUpload",
               "ecr:GetAuthorizationToken"
           ],
           "Resource": "*"
       }
   ]
}</span></pre>
<p><span class="koboSpan" id="kobo.456.1">By updating the IAM policy to be more specific (i.e., ARN-specific instead of wildcard), the security concerns </span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.457.1">associated with the preceding JSON can be addressed by creating </span><a id="_idTextAnchor512"/><span class="koboSpan" id="kobo.458.1">a policy and attaching it to the </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">IAM user.</span></span></p>
<h3><span class="koboSpan" id="kobo.460.1">Creating an ECR private repository</span></h3>
<p><span class="koboSpan" id="kobo.461.1">We’re almost there; one final step is to</span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.462.1"> create a private repository on ECR to manage our Docker images. </span><span class="koboSpan" id="kobo.462.2">Add a repository name of your choice into the box provided, and click on the </span><strong class="bold"><span class="koboSpan" id="kobo.463.1">Create</span></strong><span class="koboSpan" id="kobo.464.1"> button, leaving the remaining options as </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">their defaults.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer093">
<span class="koboSpan" id="kobo.466.1"><img alt="Figure 12.6 – Creating a private repository named vue-pinterest-demo" src="image/Figure_12.06_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.467.1">Figure 12.6 – Creating a private repository named vue-pinterest-demo</span></p>
<p><span class="koboSpan" id="kobo.468.1">After creating your ECR</span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.469.1"> instance, head over to your GitHub repository and add all the secrets and environment variables needed to deploy </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.471.1">In this section, we created the ECR instance and added our secrets to our GitHub repository, along with all the environment variables needed. </span><span class="koboSpan" id="kobo.471.2">In the next section, we will look at how to work with GitHub </span><a id="_idTextAnchor513"/><span class="koboSpan" id="kobo.472.1">Actions to automate the </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">deployment process.</span></span></p>
<h3><span class="koboSpan" id="kobo.474.1">Working with GitHub Actions</span></h3>
<p><span class="koboSpan" id="kobo.475.1">In this section, we will be </span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.476.1">working with GitHub Actions and automating the process of deploying your application to Amazon ECR. </span><span class="koboSpan" id="kobo.476.2">We will start by adding the Amazon secrets to our GitHub repository. </span><span class="koboSpan" id="kobo.476.3">Follow these steps to add </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">your secrets:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.478.1">Go to </span><strong class="bold"><span class="koboSpan" id="kobo.479.1">Settings</span></strong><span class="koboSpan" id="kobo.480.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.481.1">Secrets</span></strong><span class="koboSpan" id="kobo.482.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.483.1">Actions</span></strong><span class="koboSpan" id="kobo.484.1"> in your GitHub repository and add all the necessary </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">secret variables.</span></span></li>
<li><span class="koboSpan" id="kobo.486.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">new_user_credentials.csv</span></strong><span class="koboSpan" id="kobo.488.1"> file you downloaded when you created the </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">IAM user.</span></span></li>
<li><span class="koboSpan" id="kobo.490.1">Copy the values for </span><strong class="bold"><span class="koboSpan" id="kobo.491.1">AWS_ACCESS_KEY_ID</span></strong><span class="koboSpan" id="kobo.492.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.493.1">AWS_SECRET_ACCESS_KEY</span></strong><span class="koboSpan" id="kobo.494.1"> and paste them into your GitHub Secrets as your </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">environment variable.</span></span></li>
<li><span class="koboSpan" id="kobo.496.1">Additionally, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">us-east-1 for AWS_REGION</span></strong><span class="koboSpan" id="kobo.498.1"> and your ARN of </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">app-runner-service-role</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.500.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">ROLE_ARN</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.503.1">After adding your credentials successfully, in the next section, we will create a pipeline for deploying the enterprise project to AWS App R</span><a id="_idTextAnchor514"/><span class="koboSpan" id="kobo.504.1">unner using ECR to manage our </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">Docker images.</span></span></p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor515"/><span class="koboSpan" id="kobo.506.1">Pipeline for the production environment</span></h2>
<p><span class="koboSpan" id="kobo.507.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">production.yml</span></strong><span class="koboSpan" id="kobo.509.1"> file and add the following scripts to create a deployment pipeline for the </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">production </span></span><span class="No-Break"><a id="_idIndexMarker541"/></span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">environment:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.512.1">
name: PRODUCTION - Deploy container to AWS App Runner
on:
 push:
   branches:
     - master
 workflow_dispatch: # Allow manual invocation of the
                    # workflow
env:
 ENVIRONMENT_NAME: production
 ECR_REPOSITORY_NAME: vue-pinterest-demo
jobs:
 deploy:
   runs-on: ubuntu-latest
   steps:
     - name: Checkout
       uses: actions/checkout@v2
       with:
         persist-credentials: false
     - name: Configure AWS credentials
       id: aws-credentials
       uses: aws-actions/configure-aws-credentials@v1
       with:
         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
         aws-secret-access-key:
           ${{ secrets.AWS_SECRET_ACCESS_KEY }}
         aws-region: ${{ secrets.AWS_REGION }}
     - name: Login to Amazon ECR
       id: ecr-login
       uses: aws-actions/amazon-ecr-login@v1
     - name: Build, tag, and push image to Amazon ECR
       id: build-image
       env:
         ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
         ECR_REPOSITORY: ${{ env.ECR_REPOSITORY_NAME }}
         IMAGE_TAG: ${{ github.sha }}
       run: |
         docker build -t
         $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
</span><span class="koboSpan" id="kobo.512.2">         docker push
         $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
         echo "::set-output name=
           image::$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
     - name: Deploy to App Runner
       id: deploy-app
       uses: awslabs/amazon-app-runner-deploy@main
       with:
         service: erp-app-${{ env.ENVIRONMENT_NAME }}
         image: ${{ steps.build-image.outputs.image }}
         access-role-arn: ${{ secrets.ROLE_ARN }}
         region: ${{ secrets.AWS_REGION }}
         cpu : 1
         memory : 2
         port: 80
         wait-for-service-stability: false
     - name: App Runner output
       run: echo "App runner output
         ${{ steps.deploy-app.outputs.service-id }}"</span></pre>
<p><span class="koboSpan" id="kobo.513.1">If everything is successful, navigate to the App Runner service console; there will be a service with the name</span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.514.1"> you specified. </span><span class="koboSpan" id="kobo.514.2">You can click on the default domain name to preview your application or set up a custom </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">domain name.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer094">
<span class="koboSpan" id="kobo.516.1"><img alt="Figure 12.﻿7 – Preview of the Pinterest demo application" src="image/Figure_12.07_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.517.1">Figure 12.</span><a id="_idTextAnchor516"/><span class="koboSpan" id="kobo.518.1">7 – Preview of the Pinterest demo application</span></p>
<h1 id="_idParaDest-214"><a id="_idTextAnchor517"/><span class="koboSpan" id="kobo.519.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.520.1">In this chapter, we learned how to deploy Vue.js 3 projects to the AWS cloud and some of the best practices for deploying to AWS. </span><span class="koboSpan" id="kobo.520.2">We explored continuous integration and continuous delivery by exploring deployment pipelines, showing the different deployment staging, and how to configure each of them to perform specific jobs. </span><span class="koboSpan" id="kobo.520.3">We also examined how each stage performs and how to deploy to a </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">staging environment.</span></span></p>
<p><span class="koboSpan" id="kobo.522.1">Additionally, we explored different deployment options and how to deploy using Docker with Amazon ECR. </span><span class="koboSpan" id="kobo.522.2">We learned practically how to create an account and set up Amazon ECR with Docker and finally, we implemented automated deployment using CI/CD, Docker, Amazon ECR, and </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">GitHub Actions.</span></span></p>
<p><span class="koboSpan" id="kobo.524.1">In the next chapter, we will explore the definitive guide to Nuxt.js. </span><span class="koboSpan" id="kobo.524.2">You will learn the nitty-gritty of Nuxt.js and how to build and deliver enterprise SSR projects with Vue.js 3. </span><span class="koboSpan" id="kobo.524.3">We will explore the definitive guide to Gridsome, and you will learn the nitty-gritty of Gridsome and how to build and deliver enterprise CSR projects with </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">Vue.js 3.</span></span></p>
</div>
</body></html>