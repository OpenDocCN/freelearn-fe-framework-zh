- en: Chapter 7. Progress Bars
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章. 进度条
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Displaying file upload progress
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示文件上传进度
- en: Animating progress changes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画化进度变化
- en: Creating progress indicator widgets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建进度指示器小部件
- en: Using states to warn about thresholds
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用状态警告阈值
- en: Giving progressbars labels
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给进度条添加标签
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The **progressbar** widget is quite simple—in that it doesn't have many moving
    parts. In fact, it has exactly one moving part, that is, the value bar. But simplicity
    doesn't make the progressbar any less powerful than other widgets. We'll look
    at how we can leverage this simplicity throughout this chapter. The progressbar
    can express anything from file upload progress to server-side processes to capacity
    utilization.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**progressbar** 小部件相当简单——因为它没有太多的移动部分。事实上，它只有一个移动部分，即值栏。但是简单并不意味着进度条比其他小部件功能更弱。我们将看看如何在本章中利用这种简单性。进度条可以表达从文件上传进度到服务器端进程再到容量利用率的任何内容。'
- en: Displaying file upload progress
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示文件上传进度
- en: It would be nice if there was a straightforward way to display the progress
    of a file upload using the progressbar widget. Unfortunately, we are afforded
    no such luxury. The uploading of a file happens between the transitions of pages.
    However, the necessary hacks to display the upload progress using the progressbar
    widgets have shrunk in size, thanks to the modern standards and browsers. Let's
    take a look at how we can take advantage of the `onprogress` event of the XML
    HTTP Request object in **Ajax** requests.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一种简单直接的方法可以使用进度条小部件显示文件上传的进度就好了。不幸的是，我们没有这样的奢侈。文件的上传发生在页面转换之间。然而，使用进度条小部件显示上传进度所需的必要技巧，由于现代标准和浏览器的发展，已经变得更加简洁。让我们看看如何利用**Ajax**请求中
    XML HTTP 请求对象的 `onprogress` 事件。
- en: Getting ready
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this demonstration, we will create a simple form with a simple file field.
    Inside the form, we'll create some HTML for displaying the progressbar widget.
    It'll be hidden until the user initiates a file upload.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们将创建一个带有简单文件字段的简单表单。在表单内部，我们将创建一些用于显示进度条小部件的 HTML。它将在用户启动文件上传之前被隐藏。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法...
- en: The bulk of the work required to update the progressbar widget during a file
    upload is actually performed in the Ajax request machinery and in the `onprogress`
    event handler. The following code is a really good illustration of why widget
    designers should aim for simplicity. The resulting widget is applicable to a wide
    variety of contexts.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 更新文件上传过程中更新进度条小部件所需的大部分工作实际上是在 Ajax 请求机制和 `onprogress` 事件处理程序中完成的。以下代码很好地说明了为什么小部件设计者应该以简单为目标。生成的小部件适用于各种情境。
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you run this example and actually upload a file locally at `http://127.0.0.1:`
    `8000/`, you'll want to use a large file. Smaller files will upload too fast and
    in too short a time. A larger file upload will enable you to see something like
    the following during an upload.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此示例并在本地上传文件到 `http://127.0.0.1:` `8000/`，您会希望使用一个较大的文件。较小的文件上传速度太快，时间太短。较大的文件上传将使您能够在上传过程中看到以下内容。
- en: '![How to do it...](img/2186OS_07_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![操作方法...](img/2186OS_07_01.jpg)'
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Accompanying the code in this book is a minimal Python server that will serve
    this demo upload page and will process the file upload requests. The example can
    be rearranged without much effort to work with any upload server, but the Python
    server supplied only requires that Python be installed. Again, this isn't a requirement,
    but it's just a handy server if you're eager to see the client code in action.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码附带了一个最小的 Python 服务器，用于提供此演示上传页面并处理文件上传请求。该示例可以很容易地重新排列以与任何上传服务器配合使用，但是提供的
    Python 服务器只需要安装 Python 即可。再次强调，这不是一个要求，但如果您渴望看到客户端代码运行的话，这只是一个方便的服务器。
- en: How it works...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The goal of this example is to update the progressbar widget in real time, as
    the file upload progress changes. There are several plugins that will provide
    this capability, but if you're writing a jQuery UI application, you might as well
    standardize on the progressbar widget. The first thing we do, once the document
    is ready, is create the progressbar widget used to display the file upload progress.
    `#upload-container` is initially hidden using the `ui-helper-hidden` class, as
    we don't need to display the progress of an upload until an upload is actually
    taking place.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例的目标是实时更新进度条小部件，随着文件上传进度的改变而改变。有几个插件可以提供这种功能，但如果您正在编写jQuery UI应用程序，最好统一使用进度条小部件。一旦文档准备就绪，我们首先创建用于显示文件上传进度的进度条小部件。
    `#upload-container` 最初使用`ui-helper-hidden`类隐藏，因为我们不需要在上传正在进行之前显示上传进度。
- en: Next, we set up our event handler for the `submit` event of our upload form.
    This handler, before doing anything else, prevents the default form submission
    from taking place. We're essentially substituting our own behavior for the default
    form submission implemented by the browser. The reason we need to override this
    behavior is so that we stay on the page, and apply updates to our progressbar
    widget.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置我们上传表单的`submit`事件的事件处理程序。在执行任何其他操作之前，此处理程序防止默认表单提交。本质上，我们用我们自己的行为替换了浏览器实现的默认表单提交。我们需要覆盖此行为的原因是为了留在页面上，并对我们的进度条小部件应用更新。
- en: Next, we set up the `$.ajax()` call that actually sends our selected files to
    the server. We take the `url` argument from the form itself. The next several
    arguments are prerequisites to sending multipart form data, including selected
    files, as part of an Ajax request. The `xhr` option is where we supply a function
    that returns the `xhr` object used internally by the `$.ajax()` function. This
    is our opportunity to hijack the `xhr` object and attach additional behavior to
    it. We're mainly interested in adding new behavior to the `onprogress` event.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置实际将我们选定的文件发送到服务器的`$.ajax()`调用。我们从表单本身获取`url`参数。接下来的几个参数是发送多部分表单数据的先决条件，包括作为Ajax请求的一部分的选定文件。
    `xhr` 选项是我们提供返回`xhr`对象的函数，内部由`$.ajax()`函数使用。这是我们截取`xhr`对象并附加其他行为的机会。我们主要感兴趣的是向`onprogress`事件添加新行为。
- en: After we've made sure that the upload object, an instance of `XMLHttpRequestUpload`,
    actually exists, we can define our `onprogress` event handler function.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 确保上传对象`XMLHttpRequestUpload`实际存在后，我们可以定义我们的`onprogress`事件处理程序函数。
- en: Firstly, we calculate the actual upload percentage, using the `loaded` and `total`
    properties of the event. Next, we show the progress container and update the percentage
    label using the value in `uploadPercent`. Finally, we make sure that the `max`
    option of the upload progressbar widget is set to `total`, and we set the current
    value of the progressbar using the `value()` method.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用事件的`loaded`和`total`属性计算实际上传百分比。接下来，我们显示进度容器，并使用`uploadPercent`中的值更新百分比标签。最后，我们确保上传进度条小部件的`max`选项设置为`total`，并使用`value()`方法设置进度条的当前值。
- en: Animating progress changes
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画化进度变化
- en: The progressbar widget changes its visual appearance each time the `value` or
    the `max` option is set. For example, the default value for `value` is `0` and
    the default value for `max` is `100`. So when the progressbar widget is displayed
    with these values, we don't actually see the graphical bar, yet that depicts the
    progress percentage. However, setting the `value` option will update this bar.
    If the bar is already visible, a change in the `value` option results in a change
    of the width for the progressbar. These changes, using the default progressbar
    implementation, simply change the widget instantaneously. Let's look at how we
    can modify the widget to support a smooth transition between progressbar values.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 进度条小部件在设置`value`或`max`选项时会改变其视觉外观。例如， `value` 的默认值为`0`， `max` 的默认值为`100`。因此，当以这些值显示进度条小部件时，我们实际上并不看到图形化的条，然而这表示了进度百分比。但是，设置`value`选项将更新此条。如果条已经可见，则`value`选项的更改会导致进度条的宽度改变。使用默认进度条实现，这些更改会立即改变小部件。让我们看看如何修改小部件以支持进度条值之间的平滑过渡。
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll use the following simple markup as the basis of our progressbar widget
    instance:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下简单的标记作为我们进度条小部件实例的基础：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And, here is the JavaScript used to customize the progressbar widget in order
    to support animating changes in progress:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是用于定制进度条小部件以支持动画更改进度的JavaScript代码：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This example includes an updater that will increment the progressbar value at
    every 0.7 seconds interval. You'll notice the smooth width transition applied
    as the value changes. To contrast this change with the default behavior, set the
    `animate` option to `false`. You'll now start to really notice the visual jumps
    the bar makes each time the value is updated.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例包括一个更新器，将每0.7秒的间隔递增进度条值。您会注意到随着值的变化应用的平滑宽度过渡。与默认行为相比较，将`animate`选项设置为`false`，您现在将真正注意到每次更新值时进度条所做的视觉跳跃。
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our example code extends the progressbar widget by adding a new `animate` option.
    The new `animate` option defaults to `false`. The other change we're introducing
    to the progressbar widget is the new implementation of the `_refreshValue()` method,
    which is called internally by the widget any time the `value` option changes.
    This method is responsible for making the visual width change on the `div` element
    `progress`. This is representative of the progress between `value` and `max`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例代码通过添加一个新的`animate`选项来扩展进度条小部件。新的`animate`选项默认为`false`。我们向进度条小部件引入的另一个更改是`_refreshValue()`方法的新实现，该方法在`value`选项更改时由小部件内部调用。此方法负责使`div`元素`progress`上的可视宽度发生变化。这代表了`value`和`max`之间的进度。
- en: Much of this code is borrowed from the original implementation of `_refreshValue()`,
    as we're only making minor changes. First, we check if the `animate` option we've
    added to the widget has a `true` value. If not, we just continue with the original
    implementation. Otherwise, we use the same code, but make a slight adjustment
    with how the width is applied. Then, we're calling `stop( true, true )` to complete
    the current animation and to clear the animation queue. Next, instead of using
    the `width()` function as does the original implementation, we're setting the
    width by calling `animate()`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 很多这段代码都是从`_refreshValue()`的原始实现中借鉴而来的，因为我们只做了些微的修改。首先，我们检查了我们添加到小部件中的`animate`选项是否为`true`值。如果不是，则我们继续使用原始实现。否则，我们使用相同的代码，但对应用宽度的方式进行了轻微调整。然后，我们调用`stop(true,
    true)`来完成当前动画并清除动画队列。接下来，我们不再像原始实现那样使用`width()`函数，而是通过调用`animate()`来设置宽度。
- en: There's more...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这还不是全部...
- en: As always, we're not limited to using the jQuery `animate()` function to apply
    effects to the visual transitions between progressbar values. Instead of the `animate()`
    function, we could apply CSS transitions to progressbar values. Of course, the
    drawback is that not all browsers support CSS transitions, and we get into vendor-specific
    style rules. Nonetheless, let's compare the previous approach with that of using
    the CSS styles to animate the progressbar.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，我们不局限于使用jQuery的`animate()`函数来对进度条值之间的视觉过渡应用效果。除了`animate()`函数之外，我们还可以将CSS过渡应用于进度条值。当然，缺点是并非所有浏览器都支持CSS过渡，并且我们涉及到特定于供应商的样式规则。尽管如此，让我们将先前的方法与使用CSS样式来动画进度条进行比较。
- en: 'We will use the same markup, but we''ll introduce the following styles into
    the page:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用相同的标记，但我们将向页面引入以下样式：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And, here are the necessary changes to the JavaScript code. It looks similar
    to the previous code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是JavaScript代码的必要更改。它看起来与之前的代码类似。
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Running this example will not look all that different from the previous implementation
    of the `animate` option. The transition will behave much in the same way. The
    key difference here is that we are extending the theme framework. We have introduced
    a new CSS class for the progressbar widget—`ui-progressbar-animated`. The selector,
    `.ui-progressbar-animated > .ui-progressbar-value,` applies to the progressbar
    value `div`, the one that changes width. And, this is exactly what our new styles
    do. They transition width property value changes over a span of 0.7 seconds.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例将与先前的`animate`选项实现看起来并无太大不同。过渡行为将基本相同。这里的关键区别在于我们正在扩展主题框架。我们为进度条小部件引入了一个新的CSS类——`ui-progressbar-animated`。选择器`.ui-progressbar-animated
    > .ui-progressbar-value，`适用于进度条值`div`，即宽度发生变化的元素。而我们的新样式正是如此。它们在0.7秒的时间段内过渡宽度属性值的变化。
- en: The JavaScript code is the chief benefactor of this approach simply because
    there is less change in the progressbar widget. For instance, we're no longer
    overriding the `_refreshValue()` method. Instead, we're overriding `_create()`,
    and adding the `ui-progressbar-animated` class to the element if the `animated`
    option is `true`. This is how our new styles are put into action. The rest of
    the JavaScript that instantiates the widget and the value updater is no different
    from the previous example.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要受益者是JavaScript代码，因为进度条小部件的变化较少。例如，我们不再覆盖`_refreshValue()`方法。相反，我们正在覆盖`_create()`方法，并且如果`animated`选项为`true`，则在元素中添加`ui-progressbar-animated`类。这是我们新样式如何生效的方式。其余实例化小部件和值更新器的JavaScript与前一个示例没有任何不同。
- en: Creating progressindicator widgets
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建进度指示器小部件
- en: The progressbar widget is intended to show the progress of some process. The
    end goal is the `max` option specified when creating the widget, which defaults
    to `100`. If we know the size of the data we are processing ahead of time, we
    would use the `max` option to reflect this end goal. However, we are sometimes
    faced with the scenario where we have some processing to do on the client; or,
    we are waiting for some backend process to complete and send a response back to
    the client. For example, the user has initiated a backend task using the API,
    and they're now waiting for a response. The bottom line is, we want to illustrate
    to the user that progress is being made, and we just don't know how much progress
    has been made.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 进度条小部件旨在显示某个过程的进度。最终目标是在创建小部件时指定的`max`选项，默认为`100`。如果我们事先知道正在处理的数据的大小，我们将使用`max`选项来反映此最终目标。但是，有时我们面临的情况是在客户端执行一些处理；或者，我们正在等待某个后端进程完成并将响应发送回客户端。例如，用户使用API启动了后端任务，现在他们正在等待响应。关键是，我们希望向用户说明正在进行进度，而不知道已经完成了多少进度。
- en: To display the fact that progress is being made, despite not knowing how much
    progress, we need an indicator widget. We can write our own widget to achieve
    this, extending the progressbar widget, since we can reuse many components there.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示进度正在进行，尽管不知道有多少进度，我们需要一个指示器小部件。我们可以编写自己的小部件来实现这一点，扩展进度条小部件，因为我们可以在那里重用许多组件。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: For our progressindicator widget, we will use the same HTML as we would for
    a basic progressbar widget.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的进度指示器小部件，我们将使用与基本进度条小部件相同的HTML。
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, we have some slight adjustments to make in the progressbar CSS styles.
    These apply to the value bar inside the progressbar `div`. We're removing the
    `border` and the `margin` since this looks better when sliding the value bar back
    and forth.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要对进度条的CSS样式进行一些轻微的调整。这些应用于进度条`div`内部的值栏。我们去掉了`border`和`margin`，因为在来回滑动值栏时这样看起来更好。
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, we come to the implementation of the progressindicator widget. This code
    will also create an instance of our progressindicator widget.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来实现进度指示器小部件。此代码还将创建我们的进度指示器小部件的实例。
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you look at this progressindicator widget in the browser, you will see that
    it animates the value bar of the progressbar widget by sliding it back and forth,
    indicating that something is happening.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中查看此进度指示器小部件，您将看到它通过来回滑动进度条小部件的值栏来进行动画处理，表示正在发生某事。
- en: '![How to do it...](img/2186OS_07_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/2186OS_07_02.jpg)'
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理…
- en: We have created a new progressindicator widget that inherits the progressbar
    widget capabilities. The goal behind the progressindicator widget is to take the
    progress value bar `div`, set a width on it, and slide it back and forth within
    the progressbar container `div`. Visually, this indicates that something is taking
    place behind the scene. This type of graphical depiction of an activity is universally
    reassuring to users, as it gives the sense that something is happening, and the
    application isn't broken.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的进度指示器小部件，继承了进度条小部件的功能。进度指示器小部件的目标是获取进度值栏`div`，在其中设置宽度，并在进度条容器`div`内滑动。视觉上，这表示幕后正在发生某事。这种图形化描述活动是对用户普遍令人放心的，因为它给人一种正在发生某事的感觉，并且应用程序没有崩溃。
- en: The first method we're overriding in the definition of the new progressindicator
    widget is the `_create()` method of the progressbar. Here, we're calling the original
    constructor of the progressbar widget, since we need all the UI components in
    place before we start making changes. Next, we use the `value()` method to give
    the value bar `div` a width. We're hardcoding this value in the `progressindicator()`
    constructor simply because the developer using this widget has no need to change
    it; we only need to set the width of the element. To further simplify this widget,
    we're removing the corner classes from the elements. We could leave them, but
    then we would have to handle several corner cases when it comes to animating the
    bar, as we're after a simple widget here, one that requires no configuration on
    behalf of the developer using the widget.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在新进度指示器小部件的定义中，我们要重写的第一个方法是进度条的`_create()`方法。在这里，我们调用进度条小部件的原始构造函数，因为我们在开始进行更改之前需要所有的UI组件就位。接下来，我们使用`value()`方法为值条`div`设置宽度。我们在`progressindicator()`构造函数中硬编码了此值，只是因为使用此小部件的开发人员没有必要更改它；我们只需要设置元素的宽度。为了进一步简化此小部件，我们从元素中删除了角类。我们可以留下它们，但是在动画条时我们将不得不处理几种角例，因为我们追求的是一个简单的小部件，一个不需要开发人员进行配置的小部件。
- en: Still inside the `_create()` method, we define two utility functions for executing
    animation. As you may have guessed, the `_right()` function slides the progress
    value bar to the right while the `_left()` function slides it to the left. We're
    calling the `animate()` jQuery function on the `valueDiv` property of this widget.
    The `_right()` function slides the value `div` to the right by updating the `margin-left`
    value. You'll notice that the `margin` variable is defined locally inside `_create()`.
    This is done by calculating how much space we have to the right of the value `div`,
    which means that we set this value as the `margin-left` to slide it over to the
    right. To slide it back to the left again, we simply set the `margin-left` CSS
    property back to `0px` in the `_left()` function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在`_create()`方法内部，我们定义了两个用于执行动画的实用函数。正如你可能猜到的那样，`_right()`函数将进度值条向右滑动，而`_left()`函数将其向左滑动。我们在该小部件的`valueDiv`属性上调用了`animate()`jQuery函数。`_right()`函数通过更新`margin-left`值将值`div`向右滑动。您会注意到，`margin`变量在`_create()`内部局部定义。这是通过计算我们在值`div`右侧有多少空间来完成的，这意味着我们将此值设置为`margin-left`以将其向右滑动。要再次将其向左滑动，我们只需在`_left()`函数中将`margin-left`
    CSS属性设置回`0px`。
- en: The animation is bootstrapped by calling `_right()` at the bottom of the `_create()`
    method. The progress indicator animation loop happens by passing `_left()` as
    a callback to the initial animation. Likewise, we pass `_right()` as the animation
    completion callback inside the `_left()` function. This process will continue
    until the widget is destroyed. The `_destroy()` method is overridden by our widget
    simply to make sure that all animations stop immediately. This includes any queued
    animations waiting to execute. We then continue destroying the widget by calling
    the original `_destroy()` implementation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`_create()`方法的底部调用`_right()`来引导动画。通过将`_left()`作为初始动画的回调传递，进度指示器动画循环发生。同样，在`_left()`函数内部将`_right()`作为动画完成回调传递。此过程将继续直到小部件被销毁。我们的小部件重写了`_destroy()`方法，只是为了确保所有动画立即停止。这包括任何等待执行的排队动画。然后，我们通过调用原始的`_destroy()`实现来继续销毁小部件。
- en: There's more...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: One advantage to our progressindicator widget is that it provides a very simple
    API. You can create and destroy the widget as needed, without having to deal with
    any intermediary steps. Ideally, this widget would have a very short lifespan,
    perhaps as little as one second (barely enough time to see one animation cycle).
    Sometimes, however, things may take a little longer. If this widget were to display
    for an extended period of time, it could pose a problem to the application. The
    jQuery `animate()` function wasn't designed to run animations in an infinite loop.
    Nor is our widget designed to be displayed for extended periods of time. The problem
    is that `animate()` uses timers and can really eat away at the CPU cycles on the
    client. Not only could this be disruptive to our application, but for others running
    on the user's machine too.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的进度指示器小部件的一个优点是它提供了一个非常简单的 API。您可以根据需要创建和销毁小部件，而无需处理任何中间步骤。理想情况下，这个小部件的寿命会非常短，可能只有一秒钟（刚好足够看到一个动画循环）。然而，有时候可能需要更长一点。如果这个小部件要长时间显示，它可能会对应用程序造成问题。jQuery
    的`animate()`函数并不是设计成无限循环运行动画的。我们的小部件也不是设计成长时间显示的。问题在于`animate()`使用计时器，可能会大幅消耗客户端的
    CPU 周期。这不仅可能对我们的应用程序造成破坏，还可能对在用户机器上运行的其他应用程序造成影响。
- en: 'Despite this being a relatively minor concern, let''s look at an alternative
    implementation of our progressindicator widget, one that uses CSS animations.
    Here is how we would define our animations in the CSS:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个相对较小的问题，让我们来看看我们的进度指示器小部件的另一种实现方式，即使用 CSS 动画。以下是我们如何在 CSS 中定义动画的方式：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And, here is the modified JavaScript implementation of our `progressindicator`
    widget that knows how to make use of the previous CSS:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，这是我们的`progressindicator`小部件的修改后的 JavaScript 实现，它知道如何利用先前的 CSS：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, if you view this modified version of the widget in your browser, you should
    see a nearly identical result when compared with the previous implementation.
    The key difference of course being that the animation is specified in the CSS
    and executed directly by the browser. The browser can handle these types of CSS
    animations much more efficiently than the JavaScript based counterparts. The browser
    only needs to read the animation specification once, and then it runs the animation
    internally, using native code as opposed to executing JavaScript, and directly
    manipulating the DOM. We could run this version all day, and the browser would
    happily chug along.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在浏览器中查看这个小部件的修改版本，你应该会发现与以前的实现相比几乎完全一样的结果。当然，关键的区别在于动画是在 CSS 中指定并直接由浏览器执行。与基于
    JavaScript 的对应物相比，浏览器可以更有效地处理这些类型的 CSS 动画。浏览器只需要一次读取动画规范，然后在内部运行动画，使用本机代码而不是执行
    JavaScript 并直接操作 DOM。我们可以让这个版本运行一整天，浏览器会愉快地继续运行。
- en: But this version of progressindicator isn't without its pitfalls. Firstly, let's
    take a closer look at the CSS. The very fact that we're relying on CSS animations
    to begin with isn't the best bet given the disparity in browser adoption. Here,
    we're getting ourselves into a browser vendor prefix mess with our style. Support,
    in general, isn't too bad though, as IE is the only browser that doesn't support
    CSS animations; but the definition of the animations are straightforward. In the
    `.ui-progressindicator > .ui-progressbar-value` selector, we are specifying that
    the indicator animation will run for `2` seconds and will repeat infinitely. The
    `@keyframes` indicator animation specifies how the `margin-left` property itself
    changes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这个版本的进度指示器并不是没有缺点的。首先，让我们仔细看看 CSS。事实上，我们依赖 CSS 动画本身并不是最好的选择，因为不同浏览器对其支持存在差异。在这里，通过我们的样式，我们将自己陷入了浏览器厂商前缀混乱的困境。总的来说，支持还不错，因为只有
    IE 不支持 CSS 动画；但是动画的定义很直接。在`.ui-progressindicator > .ui-progressbar-value`选择器中，我们指定了指示器动画将运行`2`秒，并且会无限重复。`@keyframes`指示器动画指定了`margin-left`属性本身的变化方式。
- en: In JavaScript, you will notice that the code itself is much simpler. This is
    because it now has much less responsibility. Mainly, it needs to add the `ui-progressindicator`
    class to the widget's DOM element on creation, and remove the class on destruction.
    You will also notice that there is no longer a margin calculation taking place
    in the JavaScript code that implements the widget. We have instead moved these
    numbers to the CSS that defines the widget animation as hard-coded values. Again,
    this is simply a trade-off that the widget designer must consider. We are exchanging
    higher maintenance costs in the CSS for more efficient animations, and questionable
    browser support for our widget for simpler JavaScript.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，你会注意到代码本身要简单得多。这是因为它现在负责的事情要少得多。主要是，在创建时需要将 `ui-progressindicator`
    类添加到小部件的 DOM 元素上，并在销毁时删除该类。你还会注意到，在实现小部件的 JavaScript 代码中不再进行边距计算。相反，我们将这些数字移到了定义小部件动画的
    CSS 中作为硬编码值。再次强调，这只是小部件设计者必须考虑的一个权衡。我们在 CSS 中交换了更高的维护成本以获得更高效的动画，并为我们的小部件提供了更简单的
    JavaScript，以牺牲可疑的浏览器支持。
- en: Using states to warn about thresholds
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用状态来警告阈值
- en: The progressbar widget isn't restricted to marking the progression toward some
    end point. It can also be used as a marker for utilization of some resource. For
    example, your application might allow the user to store 100 MB worth of image
    data. It might make sense to show them how much of this capacity is currently
    in use. The progressbar widget is an ideal solution for graphically depicting
    resource utilization scenarios such as these. Taking things a step further, we
    might also want to warn the user about utilization thresholds. That is, at a certain
    percentage, the resource is getting near capacity, but the user still has time
    to do something about it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 进度条小部件不仅限于标记朝某个结束点的进展。它还可以用作某些资源利用的标记。例如，你的应用程序可能允许用户存储 100 MB 的图像数据。显示当前使用了多少容量可能是有意义的。进度条小部件是图形化显示此类资源利用情况的理想解决方案。更进一步，我们可能还希望警告用户关于使用阈值。也就是说，在某个百分比下，资源接近容量，但用户仍然有时间对此做出反应。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this demonstration, we will create two simple `div` elements for the two
    progressbar widgets we want to display:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们将为要显示的两个进度条小部件创建两个简单的 `div` 元素：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here is the JavaScript code that extends the progressbar widget, providing
    a new option for specifying threshold values:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是扩展进度条小部件的 JavaScript 代码，提供了一个新的选项来指定阈值：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We instantiate two progressbar widgets here and launch a basic timer interval
    that changes the value of both the progressbar widgets after every 1.30 seconds.
    If you look at this example in your browser, you will notice that one or both
    progressbar widgets will enter the error state because the value has surpassed
    the supplied threshold value.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里实例化了两个进度条小部件，并启动了一个基本的定时器间隔，每 1.30 秒更改一次两个进度条小部件的值。如果你在浏览器中查看此示例，你会注意到一个或两个进度条小部件将进入错误状态，因为值已超过提供的阈值。
- en: '![How to do it...](img/2186OS_07_03.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/2186OS_07_03.jpg)'
- en: How it works...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The new `threshold` option we've added to the progressbar widget is a number
    expressed as a percentage. This is the threshold of the progressbar at which the
    state changes in order to give the user a visual warning. This is achieved by
    overriding the `_percentage()` method. Here, we get the actual percentage value
    by calling the original implementation of `_percentage()` and storing it in `percentage`.
    We then make sure that the `threshold` value is nonzero and that the calculated
    percentage is greater than the `threshold` value. The `_percentage()` method is
    called internally by the progressbar widget each time the value is updated, and
    the visual display changes. So in our implementation of `_percentage()`, if we're
    over the threshold, we add the `ui-state-error` class to the `valueDiv` element,
    the graphical bar inside the progress bar that moves from left to right. Otherwise,
    we're below the threshold, and must be sure to remove the `ui-state-error` class.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到进度条小部件的新 `threshold` 选项是一个以百分比表示的数字。这是进度条的阈值，在这个阈值上，状态会改变以向用户发出视觉警告。这是通过重写
    `_percentage()` 方法来实现的。在这里，我们通过调用 `_percentage()` 的原始实现并将其存储在 `percentage` 中来获得实际的百分比值。然后，我们确保
    `threshold` 值非零，并且计算出的百分比大于 `threshold` 值。每次更新值时，进度条小部件都会内部调用 `_percentage()`
    方法，并且视觉显示会发生变化。因此，在我们的 `_percentage()` 实现中，如果超过阈值，我们将 `ui-state-error` 类添加到 `valueDiv`
    元素中，该元素是进度条内部移动的图形条。否则，我们低于阈值，并且必须确保删除 `ui-state-error` 类。
- en: Once we've created the two widgets, we're using `setInterval()` to continuously
    assign a random value to both the progressbars. You can sit back and watch how
    the progressbar widgets change state depending on whether the data fed into them
    crosses over the thresholds that we've specified. In this case, the `#cpu-utilization`
    progressbar has a threshold of `80` percent, while the `#memory-utilization` progressbar
    has a threshold of `85%`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了两个小部件，我们就使用 `setInterval()` 不断为两个进度条分配一个随机值。您可以坐下来观看进度条小部件如何根据输入的数据是否跨越我们指定的阈值而改变状态。在这种情况下，`#cpu-utilization`
    进度条的阈值为 `80`%，而 `#memory-utilization` 进度条的阈值为 `85%`。
- en: Giving progressbars labels
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给进度条添加标签
- en: The graphical bar that changes width to reflect the progress percentage does
    a fine job. The power of the progressbar widget is in the ability to see, at a
    glance, how much progress has been made, or how much of a resource is being utilized.
    But there are times when we could use some accuracy with regard to the percentage,
    that is, a label showing the underlying percentage.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 反映进度百分比变化宽度的图形条表现得很好。进度条小部件的强大之处在于一眼就能看到已经完成了多少进度，或者正在利用多少资源。但有时候我们可能需要一些关于百分比的准确度，即显示底层百分比的标签。
- en: The progressbar widget has the ability to display the label inside the progressbar
    container, which is more intuitive than displaying the percentage label outside
    of the widget. Let's look at how we can extend the theme CSS, supply additional
    markup to the widget, and extend the progressbar to take advantage of these new
    additional features in order to display the label.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 进度条小部件具有在进度条容器内显示标签的功能，这比在小部件外部显示百分比标签更直观。让我们看看如何扩展主题 CSS，为小部件提供额外的标记，并扩展进度条以利用这些新的附加功能来显示标签。
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We'll create the HTML for our two progressbar widgets first.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为我们的两个进度条小部件创建 HTML。
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, we'll add the CSS class required by the progressbar label.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加进度条标签所需的 CSS 类。
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Finally, we'll extend the progressbar widget itself, tying together this new
    HTML and the new CSS.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将扩展进度条小部件本身，将这个新的 HTML 和新的 CSS 绑定在一起。
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can now view these two progressbars in the browser, and you'll notice that
    the two labels, showing the percentage value, are positioned in the center of
    the widget.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以在浏览器中查看这两个进度条，您会注意到两个标签显示百分比值的位置位于小部件的中心。
- en: '![How to do it...](img/2186OS_07_04.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/2186OS_07_04.jpg)'
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'By default, the progressbar widget does not support labels, and so we have
    to place the label `div` inside the progressbar `div`. We also give this new label
    `div` the `ui-progressbar-label` class, which is consistent with the jQuery UI
    theme naming convention. This class actually serves two purposes: inside the widget
    customizations that we have introduced, we use this class to search for the label
    `div` and to apply label styles.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，进度条小部件不支持标签，因此我们必须将标签 `div` 放在进度条 `div` 中。我们还给这个新的标签 `div` 添加了 `ui-progressbar-label`
    类，这与 jQuery UI 主题命名规范一致。这个类实际上有两个作用：在我们引入的小部件自定义中，我们使用这个类来搜索标签 `div` 并应用标签样式。
- en: The CSS rules specified in `ui-progressbar-label` help to position the label
    text in the middle of the progressbar element. We give the label `div` a width
    of `100%` and align the text horizontally using the `text-align` property. Finally,
    we make the `font-weight` of the label `bold` in order to stand out; otherwise,
    it is difficult to see it against the background of the progressbar.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ui-progressbar-label` 中指定的 CSS 规则有助于将标签文本定位在进度条元素的中间。我们给标签 `div` 一个宽度为 `100%`，并使用
    `text-align` 属性水平对齐文本。最后，我们使标签的 `font-weight` 为 `bold` 以使其突出显示；否则，在进度条的背景下很难看到它。
- en: The customized JavaScript implementation of the progressbar widget that we've
    introduced here overrides the `_create()` method. We create a new instance variable
    called `labelDiv`, which stores a reference to our new element. We then call the
    original `_create()` implementation and the constructor carries on as normal,
    creating the value `div` beside our new label element. We're also overriding the
    `_refreshValue()` method in order to update the content of the `labelDiv`. The
    `_refreshValue()` method gets invoked internally by the widget any time the value
    changes and the progressbar widget needs to update the value display. We're extending
    this behavior by updating the `labelDiv` value using the `_percentage()` number,
    before resuming with the original implementation of `_refreshValue()`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里介绍的进度条小部件的自定义 JavaScript 实现覆盖了 `_create()` 方法。我们创建了一个称为 `labelDiv` 的新实例变量，它存储对我们新元素的引用。然后我们调用原始的
    `_create()` 实现，构造函数继续正常进行，创建我们的新标签元素旁边的值 `div`。我们还重写了 `_refreshValue()` 方法以更新
    `labelDiv` 的内容。`_refreshValue()` 方法在任何时候内部被小部件调用，当值改变并且进度条小部件需要更新值显示时，会更新 `labelDiv`
    的值。我们通过在恢复 `_refreshValue()` 的原始实现之前使用 `_percentage()` 数字来扩展此行为。
- en: There's more...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: One potential issue we may encounter with this approach to implementing progressbar
    labels is the fact that we have to change the HTML structure. This violates the
    DRY principle, because every label `div` we are adding, for each progressbar widget
    we create, is exactly the same. Further, we may want to apply labels to progressbar
    widgets that already exist in an application. Altering the HTML in an already
    functional widget is not the best approach. Let's think about how we can improve
    the previous code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实施进度条标签的这种方法可能遇到的一个潜在问题是，我们必须改变 HTML 结构。这违反了 DRY 原则，因为我们为每个创建的进度条小部件添加的每个标签
    `div` 都是完全相同的。此外，我们可能希望为已存在于应用程序中的进度条小部件应用标签。改变已经正常工作的小部件的 HTML 不是最好的方法。让我们想想如何改进之前的代码。
- en: The CSS we have created that positions and styles the label element is fine.
    It follows the correct naming conventions and it applies to all progressbar widget
    instances. What we want to change is the necessary markup used to instantiate
    a progressbar widget with a label displayed. The question is how. Ideally, through
    an option that lets the developer toggle the label on and off. The widget itself
    would then be responsible for inserting the label `div` where necessary since
    it is the same for all instances of the widget, which in turn means minimal JavaScript
    code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的用于定位和样式化标签元素的 CSS 是可以的。它遵循正确的命名约定，并适用于所有进度条小部件实例。我们想要更改的是用于实例化带有显示的标签的进度条小部件的必要标记。问题是如何。理想情况下，通过一个选项，让开发人员切换标签的显示和隐藏。然后小部件本身将负责在必要时插入标签
    `div`，因为它对于小部件的所有实例都是相同的，这反过来意味着最小的 JavaScript 代码。
- en: 'Let''s take a look at the simplified markup, following the same previous example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们看一下简化的标记，遵循与之前相同的例子:'
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We are now back to the original markup that the progressbar widget expects before
    we introduced our modifications. Now let's update the widget code to make use
    of this markup by adding a new option.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在回到了进度条小部件在我们引入修改之前期望的原始标记。 现在让我们更新小部件代码以利用这个标记，通过添加一个新选项。
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we're extending the progressbar widget with the new `label` option, which
    defaults to `false`. The idea is that when this value is `true`, we insert the
    label `div` into the progressbar container. Our modifications to the `_create()`
    and `_refreshValue()` methods are largely the same as the previous code, except
    now we're checking if the `label` option is turned on before executing our custom
    behavior. As you can see, we're supplying this new label option to the `#network-utilization`
    div, but not the `#storage-utilization` div.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过新的`label`选项扩展了进度条小部件，该选项默认为`false`。 思路是当这个值为`true`时，我们将`label div`插入到进度条容器中。
    我们对`_create()`和`_refreshValue()`方法的修改基本与先前的代码相同，只是现在我们在执行自定义行为之前检查`label`选项是否已打开。
    正如您所看到的，我们将这个新的标签选项提供给了`#network-utilization` div，但没有提供给`#storage-utilization`
    div。
- en: '![There''s more...](img/2186OS_07_05.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容请参考...](img/2186OS_07_05.jpg)'
