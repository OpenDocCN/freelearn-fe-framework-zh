- en: Text - Collecting Text Input
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本 - 收集文本输入
- en: 'In this chapter, you''ll learn about the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解以下主题：
- en: Controlling input with state
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用状态控制输入
- en: Placeholder and helper text
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 占位符和辅助文本
- en: Validation and error display
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证和错误显示
- en: Password fields
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码字段
- en: Multiline input
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多行输入
- en: Input adornments
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入装饰
- en: Input masking
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入掩码
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Material-UI has a flexible text input component that can be used in a variety
    of ways to collect user input. Its usages range from collecting simple one-liner
    text input to masked input adorned with icons.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Material-UI有一个灵活的文本输入组件，可以以多种方式使用来收集用户输入。它的用法范围从收集简单的单行文本输入到带有图标的掩码输入。
- en: Controlling input with state
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用状态控制输入
- en: The `TextField` component can be controlled by the React component, `state`,
    just like regular HTML text input elements. As with other types of form controls,
    the actual value is often the starting point—the state for each form control grows
    more complex as more functionality is added.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextField`组件可以通过React组件的`state`来控制，就像常规HTML文本输入元素一样。与其他类型的表单控件一样，实际值通常是起点——随着更多功能的添加，每个表单控件的状态会变得更加复杂。'
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Just like any other text input element, you need to provide the `TextField`
    component with an `onChange` event handler that updates the state for the input.
    Without this handler, the value of the input won''t change as the user types.
    Let''s look at an example where three text fields are rendered and they''re each
    controlled by their own piece of state:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他文本输入元素一样，你需要为`TextField`组件提供一个`onChange`事件处理器来更新输入的状态。没有这个处理器，用户输入时输入的值不会改变。让我们看看一个例子，其中渲染了三个文本字段，并且它们各自由自己的状态控制：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When you first load the screen, here''s what you''ll see:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你首次加载屏幕时，你会看到以下内容：
- en: '![](img/d8024952-a0e0-408b-abda-dcf7598f720c.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8024952-a0e0-408b-abda-dcf7598f720c.png)'
- en: 'If you type in each of the text fields, you''ll update the state of the component
    for the screen:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入每个文本字段，你将更新屏幕上组件的状态：
- en: '![](img/0ea51776-70c6-4e2c-a1fb-08c4cc328278.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ea51776-70c6-4e2c-a1fb-08c4cc328278.png)'
- en: How it works...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The setter functions that are created with `useState()`: `setFirst()`, `setSecond()`,
    and `setThird()`, change the value of the `TextField` component by changing the
    state that''s used by the component in the `onChange` event.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`useState()`创建的设置函数：`setFirst()`、`setSecond()`和`setThird()`，通过改变组件在`onChange`事件中使用的状态来改变`TextField`组件的值。
- en: The `TextField` component is a convenient abstraction that builds on other Material-UI
    components, such as `FormControl` and `Input`. You could achieve the exact same
    result by replacing `TextField` with each of these components. But all you would
    get is more code to maintain.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextField`组件是一个方便的抽象，它建立在其他Material-UI组件（如`FormControl`和`Input`）之上。你可以通过用这些组件中的任何一个替换`TextField`来达到完全相同的结果。但你会得到更多的代码来维护。'
- en: There's more...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: What if, instead of only keeping the `TextField` value in the component state,
    you also kept the `id` and `label` information as well? It might seem confusing
    to store values that never change as a state, but the trade-off is that you can
    have the state data drive what's rendered by the component instead of having to
    repeat the same `TextField` components over and over.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果，除了只在组件状态中保留`TextField`值之外，你还保留了`id`和`label`信息呢？将永远不会改变的价值作为状态存储可能会显得有些混乱，但权衡是你可以让状态数据驱动组件渲染的内容，而不是不得不反复重复相同的`TextField`组件。
- en: 'First, let''s change the shape of the component state, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们改变组件状态的结构，如下所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Instead of an object with string properties to hold the text field values,
    the `inputs` state is an array of objects. It''s an array so that the component
    can iterate over the values while maintaining their order. Each object has everything
    necessary to render `TextField`. Let''s look at the updated markup next:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用具有字符串属性的对象来保存文本字段值不同，`inputs`状态是一个对象数组。它是一个数组，这样组件就可以在保持顺序的同时遍历值。每个对象都有渲染`TextField`所需的一切。让我们看看更新的标记：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Each `Grid` item now maps to an element from the `inputs` array. If you need
    to add, remove, or change something about one of these text fields, you can do
    so by updating the state. Finally, let''s see what the `onChange()` implementation
    looks like:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Grid`项现在映射到`inputs`数组中的一个元素。如果你需要添加、删除或更改这些文本字段中的任何一个，你可以通过更新状态来实现。最后，让我们看看`onChange()`的实现：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `onChange()` function updates an item in an array, the `inputs` array. First,
    it finds the `index` of the item to update, based on the text field `id`. Then,
    it updates the `value` property with the value of the text field.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`onChange()` 函数更新数组中的一个项目，即 `inputs` 数组。首先，它根据文本字段的 `id` 找到要更新的项目的 `index`。然后，它使用文本字段的值更新
    `value` 属性。'
- en: The functionality is the exact same as before, with a different approach that
    requires less JSX markup.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 功能与之前完全相同，但采用了更少 JSX 标记的方法。
- en: See also
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: '`TextField` demos: [https://material-ui.com/demos/text-fields/](https://material-ui.com/demos/text-fields/)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextField` 示例：[https://material-ui.com/demos/text-fields/](https://material-ui.com/demos/text-fields/)'
- en: '`TextField` API documentation: [https://material-ui.com/api/text-field/](https://material-ui.com/api/text-field/)'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextField` API 文档：[https://material-ui.com/api/text-field/](https://material-ui.com/api/text-field/)'
- en: Placeholder and helper text
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 占位符和辅助文本
- en: At a minimum, text fields should have a label so that the user knows what to
    type. But a label on its own can be downright confusing—especially if you have
    several text fields on the same screen. To help the user understand what to type,
    you can utilize `placeholder` and `helperText` in addition to `label`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，文本字段应该有一个标签，以便用户知道要输入什么。但仅有的标签可能会非常令人困惑——尤其是如果你在同一屏幕上有多个文本字段。为了帮助用户理解要输入什么，你可以利用
    `placeholder` 和 `helperText`，除了 `label` 之外。
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s write some code that showcases various `label`, `placeholder`, and `helperText`
    configurations you can use with the `TextField` component:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，展示你可以与 `TextField` 组件一起使用的各种 `label`、`placeholder` 和 `helperText`
    配置：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here''s what the four text fields look like:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是四个文本字段的模样：
- en: '![](img/25391d7d-8f72-4426-b852-3f47470da137.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25391d7d-8f72-4426-b852-3f47470da137.png)'
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's take a look at each of these text fields and break down their strengths
    and weaknesses.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看这些文本字段，并分析它们的优缺点。
- en: 'First, there''s a text field with a `label` component only:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有一个只包含 `label` 组件的文本字段：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When you only have `label`, it is displayed where the user would enter text:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只有 `label` 时，它将显示在用户输入文本的位置：
- en: '![](img/9b0626b6-ecd4-4027-918e-211150f60b6a.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b0626b6-ecd4-4027-918e-211150f60b6a.png)'
- en: 'When the user navigates to the text field and it receives focus, the `label`
    shrinks and moves out of the way:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户导航到文本字段并获得焦点时，`label` 缩小并移开：
- en: '![](img/03fe8f73-1944-411e-9e59-df5c5619237f.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03fe8f73-1944-411e-9e59-df5c5619237f.png)'
- en: 'The next text field specifies placeholder text using the `placeholder` property:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个文本字段使用 `placeholder` 属性指定占位文本：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `placeholder` text should provide the user with an example of a valid value
    if possible:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，`placeholder` 文本应向用户提供一个有效值的示例：
- en: '![](img/0e6f3ced-f537-423a-8a42-275e56e9c4bb.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e6f3ced-f537-423a-8a42-275e56e9c4bb.png)'
- en: 'When the user starts entering text, the `placeholder` value goes away:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户开始输入文本时，`placeholder` 值消失：
- en: '![](img/9006a19c-5496-46e9-85d9-394f8e24f94d.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9006a19c-5496-46e9-85d9-394f8e24f94d.png)'
- en: 'The next text field provides the `helperText` property with a value:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个文本字段提供了 `helperText` 属性的值：
- en: '![](img/46b2b250-5ad6-4e09-bc12-654793bd8fdc.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46b2b250-5ad6-4e09-bc12-654793bd8fdc.png)'
- en: 'The helper text of a text field is static in the sense that it''s always visible
    and doesn''t move, even after the user starts typing. Lastly, text fields can
    have all three properties that help the user figure out what value to provide:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 文本字段的辅助文本在静态意义上是始终可见的，即使用户开始输入也不会移动。最后，文本字段可以具有所有三个帮助用户确定应提供什么值的属性：
- en: A label that tells the user what the value is
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个告诉用户值是什么的标签
- en: Placeholder text that provides an example value
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供示例值的占位文本
- en: Helper text that gives more of an explanation of why the value is needed
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供更多解释为什么需要值的辅助文本
- en: 'When you combine these three properties, you''re increasing the likelihood
    that the user will understand what to type. When the text field is unfocused,
    the label and the helper text are visible:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你结合这三个属性时，你正在增加用户理解应输入什么内容的可能性。当文本字段未获得焦点时，标签和辅助文本是可见的：
- en: '![](img/cb208c84-4ee7-4935-8206-e77698bcf5f6.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb208c84-4ee7-4935-8206-e77698bcf5f6.png)'
- en: 'When the text field receives focus, the label shrinks and the placeholder value
    is revealed:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当文本字段获得焦点时，标签缩小，占位符值被揭示：
- en: '![](img/d42f7cac-235b-44dc-ae5c-f43fd3887427.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d42f7cac-235b-44dc-ae5c-f43fd3887427.png)'
- en: See also
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: '`TextField` demos: [https://material-ui.com/demos/text-fields/](https://material-ui.com/demos/text-fields/)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextField` 示例：[https://material-ui.com/demos/text-fields/](https://material-ui.com/demos/text-fields/)'
- en: '`TextField` API documentation: [https://material-ui.com/api/text-field/](https://material-ui.com/api/text-field/)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextField` API 文档：[https://material-ui.com/api/text-field/](https://material-ui.com/api/text-field/)'
- en: Validation and error display
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证和错误显示
- en: Even with helper text, placeholders, and labels, users will inevitably enter
    something that's not quite right. It's not that they are trying to mess things
    up (some are, to be fair); it's that mistakes happen. When mistakes are made,
    text input fields need to be marked as being in an error state.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有辅助文本、占位符和标签，用户也难免会输入一些不太正确的东西。并不是他们试图搞砸事情（公平地说，有些人确实如此）；而是错误总是会发生。当出现错误时，文本输入字段需要标记为处于错误状态。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s say that you have two inputs: a phone number and an email address, and
    you want to make sure that the values provided by the user are correct.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个输入：一个电话号码和一个电子邮件地址，并且你想要确保用户提供的值是正确的。
- en: 'Please note: Validation isn''t perfect. Thankfully, this piece can work, however,
    you need it to and you''ll still get all of the Material-UI pieces.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意：验证并不完美。幸运的是，这个组件可以工作，只要你需要它，你仍然会得到所有的 Material-UI 组件。
- en: 'Here''s the code to do it:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现它的代码：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `ValidationAndErrorDisplay` component will render two `TextField` components
    on the screen. This is what they look like when the screen first loads:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValidationAndErrorDisplay` 组件将在屏幕上渲染两个 `TextField` 组件。这是屏幕首次加载时的样子：'
- en: '![](img/7b8d39f4-978d-446f-956a-87e915e50775.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b8d39f4-978d-446f-956a-87e915e50775.png)'
- en: 'The Phone and Email text fields are just regular text fields with labels, helper
    text, and placeholders. For example, when the Phone field receives focus, it looks
    like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 电话和电子邮件文本字段只是带有标签、辅助文本和占位符的常规文本字段。例如，当电话字段获得焦点时，它看起来像这样：
- en: '![](img/e75273ea-ba88-4bde-9ae0-01b6bdd1f234.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e75273ea-ba88-4bde-9ae0-01b6bdd1f234.png)'
- en: 'As you start typing, the value of the text field is validated against a phone
    format regular expression. Here''s what the field looks like when it has an invalid
    phone number value:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始输入时，文本字段的值会与电话格式的正则表达式进行验证。以下是当字段具有无效电话号码值时的样子：
- en: '![](img/810fbb72-4907-491c-bcfb-a5941ec70789.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/810fbb72-4907-491c-bcfb-a5941ec70789.png)'
- en: 'Then, once you have a valid phone number value, the state of the text field
    goes back to normal:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一旦你有一个有效的电话号码值，文本字段的状况就会恢复到正常：
- en: '![](img/2f2b37a4-9080-4505-bc7b-93d6c691bc0d.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f2b37a4-9080-4505-bc7b-93d6c691bc0d.png)'
- en: The Email field works the same way—the only difference is the regular expression
    used to validate the format of the value.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件字段的工作方式相同——唯一的区别是用于验证值格式的正则表达式。
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start by taking a look at the state of the `ValidationAndErrorDisplay`
    component:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看 `ValidationAndErrorDisplay` 组件的状态：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `inputs` array is mapped to `TextField` components by the `render()` method.
    Each object in this array has properties that map directly to the `TextField`
    component. For instance, `id`, `label`, `placeholder`—these are all `TextField`
    properties. The objects each have two functions that help with validating the
    text field values. First, `getHelperText()` returns either the default helper
    text, or error text that replaces the helper text if the `error` argument is true.
    The `isValid()` function validates the `value` argument against a regular expression
    and returns `true` if it matches.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`inputs` 数组通过 `render()` 方法映射到 `TextField` 组件。这个数组中的每个对象都有直接映射到 `TextField`
    组件的属性。例如，`id`、`label`、`placeholder`——这些都是 `TextField` 的属性。每个对象都有两个帮助验证文本字段值的函数。首先，`getHelperText()`
    返回默认的辅助文本，或者如果 `error` 参数为真，则替换辅助文本的错误文本。`isValid()` 函数将 `value` 参数与正则表达式进行验证，如果匹配则返回
    `true`。'
- en: 'Next, let''s look at the `onChange()` handler:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `onChange()` 处理程序：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As the user types, this function updates the value state of the given text field.
    It also calls the `isValid()` function, passing it the updated value. The `error`
    state is set to `true` if the value is invalid. The `helperText` state is also
    updated using `getHelperText()`, which also depends on the validity of the value.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 随着用户输入，此函数会更新给定文本字段的值状态。它还会调用 `isValid()` 函数，并将更新后的值传递给它。如果值无效，则将 `error` 状态设置为
    `true`。`helperText` 状态也会通过 `getHelperText()` 更新，这同样取决于值的有效性。
- en: There's more...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'What if this example could be modified so that you didn''t have to store error
    messages as a state, or have a function to change the helper text of the text
    field? To do this, you could introduce a new `TextField` abstraction that handles
    setting the `error` property and changes the `helperText` component when the value
    is `invalid`. Here''s the new component:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个例子可以被修改，以至于您不需要将错误信息作为状态存储，或者不需要一个函数来更改文本框的辅助文本？为了做到这一点，您可以引入一个新的`TextField`抽象，该抽象处理设置`error`属性，并在值无效时更改`helperText`组件。以下是新的组件：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Instead of having a function that returns `true` if the data is valid, the `MyTextField`
    component expects an `isInvalid()` property that returns `false` if the data is
    valid and an `error` message when it's `invalid`. Then, the `error` property can
    use this value, which changes the color of the text field to indicate that it's
    in an error state and the `helperText` property can use either the string that
    is returned by the `isInvalid()` function, or the `helperText` property that was
    passed to the component.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与返回`true`表示数据有效的函数不同，`MyTextField`组件期望一个`isInvalid()`属性，当数据有效时返回`false`，当数据无效时返回错误信息。然后，`error`属性可以使用这个值，这将改变文本框的颜色以指示它处于错误状态，而`helperText`属性可以使用`isInvalid()`函数返回的字符串，或者传递给组件的`helperText`属性。
- en: 'Next, let''s look at the state that the `ValidationAndErrorDisplay` component
    uses now:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`ValidationAndErrorDisplay`组件现在使用的状态：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The inputs no longer need the `getHelperText()` function or the `error` state.
    The `isInvalid()` function returns the error helper text when the value is invalid.
    Next, let''s look at the `onChange()` handler:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 输入不再需要`getHelperText()`函数或`error`状态。`isInvalid()`函数在值无效时返回错误辅助文本。接下来，让我们看看`onChange()`处理程序：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, it doesn't have to touch the `error` state, or worry about updating the
    helper text, or about calling any validation functions—this is all handled by
    `MyTextField` now.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它不需要接触`error`状态，也不必担心更新辅助文本，或者调用任何验证函数——所有这些现在都由`MyTextField`处理。
- en: See also
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`TextField` demos: [https://material-ui.com/demos/text-fields/](https://material-ui.com/demos/text-fields/)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextField`演示：[https://material-ui.com/demos/text-fields/](https://material-ui.com/demos/text-fields/)'
- en: '`TextField` API documentation: [https://material-ui.com/api/text-field/](https://material-ui.com/api/text-field/)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextField` API文档：[https://material-ui.com/api/text-field/](https://material-ui.com/api/text-field/)'
- en: Password fields
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码字段
- en: Password fields are a special type of text input that hides the individual characters
    on the screen as they are typed. Material-UI `TextField` components support this
    type of field by changing the value of the `type` property.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 密码字段是一种特殊的文本输入类型，在输入时隐藏单个字符。Material-UI `TextField`组件通过改变`type`属性的值来支持这种类型的字段。
- en: How to do it...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here''s a simple example that changes a regular text input into a `password`
    input that prevents the value from displaying on the screen:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子，它将常规文本输入转换为防止在屏幕上显示值的`password`输入：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here''s what the screen looks like when it first loads:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是首次加载时的屏幕样子：
- en: '![](img/9a6e6e19-0632-4b5f-b229-446065797c30.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a6e6e19-0632-4b5f-b229-446065797c30.png)'
- en: If you change the value of the Password field, any new characters remain hidden,
    even though the actual value typed is stored in the `password` state of the `PasswordFields`
    component.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更改密码字段的值，任何新的字符都将保持隐藏，尽管实际输入的值存储在`PasswordFields`组件的`password`状态中。
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `type` property tells the `TextField` component to use a password HTML `input`
    element. This is how the value remains hidden as the user types it, or if the
    field is pre-populated with a `password` value. Sometimes, Password fields can
    be autofilled.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`type`属性告诉`TextField`组件使用密码HTML `input`元素。这就是为什么用户在输入时值保持隐藏，或者如果字段预先填充了密码值。有时，密码字段可以被自动填充。'
- en: There's more...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can use the `autoComplete` property to control how password values are
    automatically filled by the browser. A common case for this value is to have the
    Password field automatically filled on a login screen once the Username field
    is filled. Here''s an example of how you can use this property when you have Username
    and Password fields on the screen:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`autoComplete`属性来控制浏览器如何自动填充密码值。这个值的一个常见用例是在用户名字段填写后，自动在登录屏幕上填充密码字段。以下是一个在屏幕上具有用户名和密码字段时如何使用此属性的示例：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first `TextField` component uses the `autoComplete` value of `username`.
    It also passes `{ name: ''username'' }` to `InputProps` so that the `name` property
    is set on the `<input>` element. The reason you need to do this is so that, in
    the second `TextField` component, the `autoComplete` value of `current-password`
    tells the browser to look up the password based on the `username` field value.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '第一个 `TextField` 组件使用了 `autoComplete` 的 `username` 值。它还向 `InputProps` 传递了 `{
    name: ''username'' }`，以便在 `<input>` 元素上设置 `name` 属性。你需要这样做的原因是，在第二个 `TextField`
    组件中，`autoComplete` 的 `current-password` 值告诉浏览器根据 `username` 字段值查找密码。'
- en: Not all browsers implement this functionality the same. In order for any credentials
    to be automatically filled in text fields, they have to be saved using the native
    browser credential remembering tool.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有浏览器都实现了这一功能。为了使任何凭据能够自动填充到文本字段中，它们必须使用原生的浏览器凭据记住工具保存。
- en: See also
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`TextField` demos: [https://material-ui.com/demos/text-fields/](https://material-ui.com/demos/text-fields/)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextField` 演示：[https://material-ui.com/demos/text-fields/](https://material-ui.com/demos/text-fields/)'
- en: '`TextField` API documentation: [https://material-ui.com/api/text-field/](https://material-ui.com/api/text-field/)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextField` API 文档：[https://material-ui.com/api/text-field/](https://material-ui.com/api/text-field/)'
- en: Multiline input
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多行输入
- en: For some fields, users need the ability to provide text values that span multiple
    lines. The `multiline` property helps accomplish this goal.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些字段，用户需要提供多行文本值的能力。`multiline` 属性有助于实现这一目标。
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s say that you have a field that could require multiple lines of text,
    provided by the user. You can specify the `multiline` property to allow for this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个可能需要多行文本的字段，由用户提供。您可以指定 `multiline` 属性以允许这样做：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The text field looks like a normal field when the screen first loads, because
    it has one row by default:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当屏幕首次加载时，文本字段看起来像一个普通字段，因为它默认只有一行：
- en: '![](img/3a19c398-c8e5-45c3-9dec-9d0913d74504.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3a19c398-c8e5-45c3-9dec-9d0913d74504.png)'
- en: 'You can enter as many lines as you need to in this text field. New lines are
    started by pressing *Enter*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个文本字段中输入你需要的任意多行。新行通过按下 *Enter* 键开始：
- en: '![](img/3e2e2af7-818a-4787-b57c-34a6c8067726.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3e2e2af7-818a-4787-b57c-34a6c8067726.png)'
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `multiline` Boolean property is used to indicate to the `TextField` component
    that `multiline` support is needed for the field. With the preceding example,
    you might run into a couple of issues if you''re planning on using the `multiline`
    input in a crowded space, such as a screen with many other fields on it or in
    a dialog:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiline` 布尔属性用于向 `TextField` 组件指示该字段需要 `multiline` 支持。在先前的示例中，如果你计划在一个拥挤的空间中使用
    `multiline` 输入，比如屏幕上有许多其他字段或是在对话框中，你可能会遇到一些问题：'
- en: The height of the field changes as the user presses *Enter*, adding more rows
    to the component. This might cause layout problems as other elements are moved
    around.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户按下 *Enter* 键时，字段的高度会改变，向组件添加更多行。这可能会引起布局问题，因为其他元素会被移动。
- en: If the field starts with one row and looks like a regular single-line text input,
    then the user might not realize that they can enter multiple lines of text in
    the field.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果字段从一行开始并且看起来像常规的单行文本输入，那么用户可能不会意识到他们可以在字段中输入多行文本。
- en: There's more...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'To help prevent scenarios where a dynamically-sized `multiline` text field
    might cause problems, you can specify the number of rows used by a `multiline`
    text field. Here''s an example of how to use the `rows` property:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助防止动态大小的 `multiline` 文本字段可能引起的问题，您可以指定 `multiline` 文本字段使用的行数。以下是如何使用 `rows`
    属性的示例：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, the text field will have exactly five rows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，文本字段将正好有五行：
- en: '![](img/d5ad81ce-816c-4031-8f1f-981b822fc656.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d5ad81ce-816c-4031-8f1f-981b822fc656.png)'
- en: If the user enters more than five lines of text, a vertical scrollbar will be
    displayed—the height of the text doesn't change and can't impact the layout of
    other surrounding components. You can impose the same type of height restriction
    on the `TextField` component by using the `rowsMax` property instead of `rows`.
    The difference is that the text field will start out with one row and will grow
    as the user adds new lines. But if you set `rowsMax` to `5`, the text field will
    not exceed five rows.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入超过五行的文本，将显示垂直滚动条——文本的高度不会改变，并且不会影响其他周围组件的布局。您可以通过使用 `rowsMax` 属性而不是 `rows`
    来对 `TextField` 组件施加相同类型的高度限制。区别在于文本字段将从一个行开始，并在用户添加新行时增长。但如果将 `rowsMax` 设置为 `5`，文本字段将不会超过五行。
- en: See also
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`TextField` demos: [https://material-ui.com/demos/text-fields/](https://material-ui.com/demos/text-fields/)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextField` 演示：[https://material-ui.com/demos/text-fields/](https://material-ui.com/demos/text-fields/)'
- en: '`TextField` API documentation: [https://material-ui.com/api/text-field/](https://material-ui.com/api/text-field/)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextField` API 文档：[https://material-ui.com/api/text-field/](https://material-ui.com/api/text-field/)'
- en: Input adornments
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入装饰
- en: Material-UI `Input` components have properties that allow you to customize the
    way that they look and behave. The idea is that you can adorn inputs with other
    Material-UI components to extend the functionality of basic text inputs in a way
    that makes sense for the users of your application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Material-UI `Input` 组件具有允许你自定义其外观和行为属性的属性。想法是你可以用其他 Material-UI 组件装饰输入，以扩展基本文本输入的功能，使其对应用用户有意义。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Let's say that your app has several screens that have password inputs. The users
    of your app like the ability to see passwords as they're typed. By default, values
    will be hidden, but if the input component itself had a button that toggles the
    visibility of the value, that would make your users happy.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的应用有几个屏幕，这些屏幕都有密码输入。你的应用用户喜欢在输入密码时能够看到密码。默认情况下，值将被隐藏，但如果输入组件本身有一个切换值可见性的按钮，这将使你的用户感到高兴。
- en: 'Here''s an example of a generic component that will adorn password fields with
    a visibility toggle button:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例，展示了一个通用的组件，它将为密码字段添加一个可见性切换按钮：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is what you''ll see if you start typing without clicking on the toggle
    visibility button:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开始输入而不点击切换可见性按钮，你会看到这样的效果：
- en: '![](img/930874fb-fa0e-486a-afd1-8f3b1b38adab.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/930874fb-fa0e-486a-afd1-8f3b1b38adab.png)'
- en: 'Here''s what the Password field looks like if we click on the toggle visibility
    button:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击切换可见性按钮，密码字段看起来是这样的：
- en: '![](img/49398d97-f542-4a88-988c-d61ea6aad051.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/49398d97-f542-4a88-988c-d61ea6aad051.png)'
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s take a closer look at the `PasswordField` component:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看 `PasswordField` 组件：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This component maintains a piece of state called `visible`. The reason that
    `PasswordField` maintains this state instead of the parent component is because
    of the separation of concerns principle. The parent component, for example, probably
    needs access to the value of the password field. This value gets passed into `PasswordField`
    as a property. However, only `PasswordField` cares about the `visibility` state.
    So, by keeping it encapsulated within this component, you've simplified any code
    that uses `PasswordField`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件维护一个名为 `visible` 的状态。`PasswordField` 维护这个状态而不是父组件的原因是关注点分离原则。例如，父组件可能需要访问密码字段的值。这个值作为属性传递到
    `PasswordField`。然而，只有 `PasswordField` 关心 `visibility` 状态。因此，通过将其封装在这个组件中，你简化了任何使用
    `PasswordField` 的代码。
- en: The other valuable aspect of this abstraction is the adornment itself. The `type`
    property changes as the `visible` state changes—this is the mechanism that reveals
    or hides the password value. The `endAdornment` property is passed to the `Input`
    component that `TextField` renders, passed via `InputProps`. This is how you can
    add components to the field. In this example, you're adding an icon button to
    the right-hand side (end) of the input. The icon here changes based on the visible
    state and, when clicked, the `toggleVisible()` method is called to actually change
    the visible state.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个抽象的另一个有价值的方面是装饰本身。`type` 属性随着 `visible` 状态的变化而变化——这是显示或隐藏密码值的机制。`endAdornment`
    属性传递给 `TextField` 渲染的 `Input` 组件，通过 `InputProps` 传递。这就是你如何向字段添加组件的方式。在这个例子中，你正在向输入的右侧（末端）添加一个图标按钮。这里的图标根据可见性状态变化，并且当点击时，会调用
    `toggleVisible()` 方法来实际改变可见性状态。
- en: There's more...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can use input adornments for more than buttons that reveal the value of
    a password field. For example, in a field that is validated, you can use input
    adornments to help visualize the validation state of the field. Let''s say that
    you need to validate an email field as the user types. You could create an abstraction
    in the form of a component that changes the color and the adornment of the component
    based on the result of validating what the user has provided. Here''s what that
    component looks like:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用输入装饰来做的不仅仅是显示密码字段的值按钮。例如，在一个需要验证的字段中，你可以使用输入装饰来帮助可视化字段的状态。假设你需要验证用户输入的电子邮件字段。你可以创建一个组件形式的抽象，根据用户提供的验证结果改变组件的颜色和装饰。这个组件看起来是这样的：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The idea with `ValidationField` is to take an `isValid()` function property
    and use it to test the value property. If it returns `true`, then `startAdornment`
    is a checkmark. If `isValid()` returns `false`, then `startAdornment` is a red
    *x*. Here''s how the component is used:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValidationField` 的想法是获取一个 `isValid()` 函数属性，并使用它来测试值属性。如果它返回 `true`，则 `startAdornment`
    是一个勾选标记。如果 `isValid()` 返回 `false`，则 `startAdornment` 是一个红色的 *x*。以下是组件的使用方法：'
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `ValidationField` component can be used almost identically to `TextField`.
    The one addition is the `isValid` property. Any state is handled outside of `ValidationField`,
    which means that `isValid()` is called any time the value changes, and will update
    the appearance of the component to reflect the validity of the data. By way of
    an added bonus: you don''t actually have to store any kind of error state anywhere,
    because `ValidationField` derives everything that it needs from the value and
    `isValid` properties.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValidationField` 组件几乎可以与 `TextField` 一样使用。唯一的增加是 `isValid` 属性。任何状态都在 `ValidationField`
    之外处理，这意味着 `isValid()` 会在值更改时被调用，并将更新组件的外观以反映数据的有效性。作为额外的奖励：你实际上不需要在任何地方存储任何类型的错误状态，因为
    `ValidationField` 从值和 `isValid` 属性中推导出它所需的一切。'
- en: 'Here''s what the field looks like with an invalid email address:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是带有无效电子邮件地址的字段看起来像什么：
- en: '![](img/91f68951-9510-4ca3-bc1a-5881aee255a0.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91f68951-9510-4ca3-bc1a-5881aee255a0.png)'
- en: 'Here''s what the field looks like with a valid email address:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是带有有效电子邮件地址的字段看起来像什么：
- en: '![](img/1ee21ae7-f4cf-4f60-96e6-423060dfa997.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ee21ae7-f4cf-4f60-96e6-423060dfa997.png)'
- en: See also
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`TextField` demos: [https://material-ui.com/demos/text-fields/](https://material-ui.com/demos/text-fields/)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextField` 演示：[https://material-ui.com/demos/text-fields/](https://material-ui.com/demos/text-fields/)'
- en: '`TextField` API documentation: [https://material-ui.com/api/text-field/](https://material-ui.com/api/text-field/)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextField` API 文档：[https://material-ui.com/api/text-field/](https://material-ui.com/api/text-field/)'
- en: '`IconButton` API documentation: [https://material-ui.com/api/icon-button/](https://material-ui.com/api/icon-button/)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IconButton` API 文档：[https://material-ui.com/api/icon-button/](https://material-ui.com/api/icon-button/)'
- en: '`InputAdornment` API documentation: [https://material-ui.com/api/input-adornment/](https://material-ui.com/api/input-adornment/)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InputAdornment` API 文档：[https://material-ui.com/api/input-adornment/](https://material-ui.com/api/input-adornment/)'
- en: Input masking
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入掩码
- en: Some text inputs require values with a specific format. With Material-UI `TextField`
    components, you can add masking capabilities that help guide the user toward providing
    the correct format.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一些文本输入需要具有特定格式的值。使用 Material-UI `TextField` 组件，你可以添加掩码功能，这有助于引导用户提供正确的格式。
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s say that you have phone number and email fields and you want to provide
    an input mask for each. Here''s how you can use the `MaskedInput` component from
    `react-text-mask` with `TextField` components to add masking abilities:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个电话号码和电子邮件字段，并且你想要为每个字段提供一个输入掩码。以下是你可以如何使用来自 `react-text-mask` 的 `MaskedInput`
    组件与 `TextField` 组件一起添加掩码功能：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here''s what the screen looks like when it first loads:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是屏幕首次加载时的样子：
- en: '![](img/eefc70ba-4ed3-4d28-ac55-7e79a69076ec.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eefc70ba-4ed3-4d28-ac55-7e79a69076ec.png)'
- en: 'Once you start typing a value into the Phone field, the format mask appears:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始在电话字段中输入值时，格式掩码就会出现：
- en: '![](img/1748999d-66b2-4e88-ad00-42e2597f9915.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1748999d-66b2-4e88-ad00-42e2597f9915.png)'
- en: 'Here''s what the completed value looks like—the user never has to type `(`,
    `)`, or `-`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是完成后的值看起来像什么——用户永远不需要输入 `(`，`)` 或 `-`：
- en: '![](img/061f343c-d584-4ca4-b4e6-910d33d9e61b.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/061f343c-d584-4ca4-b4e6-910d33d9e61b.png)'
- en: 'Here''s what the completed Email value looks like:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是完成后的电子邮件值看起来像什么：
- en: '![](img/27b064e0-fbc5-46a2-923d-ea369d627a79.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27b064e0-fbc5-46a2-923d-ea369d627a79.png)'
- en: With the email input, the user will actually have to type `@` and `.` because
    the mask doesn't know how many characters are in any part of the email address.
    It does, however, prevent the user from putting either of these characters in
    the wrong place.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子邮件输入中，用户实际上必须输入 `@` 和 `.`，因为掩码不知道电子邮件地址的任何部分有多少个字符。然而，它确实阻止用户将这两个字符放在错误的位置。
- en: How it works...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To make this work, you created a `PhoneInput` component and an `EmailInput`
    component. The idea of each is to provide a basic abstraction around the `MaskedInput`
    component. Let''s take a closer look at each, starting with `PhoneInput`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这起作用，你创建了一个 `PhoneInput` 组件和一个 `EmailInput` 组件。每个组件的想法是围绕 `MaskedInput` 组件提供基本的抽象。让我们更详细地看看每个组件，从
    `PhoneInput` 开始：
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The properties that are passed to `PhoneInput` are forwarded to `MaskedInput`
    for the most part. The `ref` property needs to be set explicitly because it's
    named differently. The `placeholder` property is set to be whitespace. The `mask`
    property is the most important—this is what determines the pattern that the user
    sees as they start typing. The value passed to `mask` is an array with regular
    expressions and string characters. The string characters are what show up when
    the user starts typing—in the case of phone number, these are the `(`, `)`, and
    `-` characters. The regular expressions are the dynamic pieces that match against
    what the user types. With a phone number, any digit will do, but symbols and letters
    aren't allowed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`PhoneInput`的属性大部分被转发到`MaskedInput`。由于名称不同，`ref`属性需要显式设置。`placeholder`属性被设置为空白。`mask`属性是最重要的——这是用户在开始输入时看到的模式。传递给`mask`的值是一个包含正则表达式和字符串字符的数组。字符串字符是用户开始输入时显示的内容——在电话号码的情况下，这些是`(`、`)`和`-`字符。正则表达式是与用户输入匹配的动态部分。对于电话号码，任何数字都可以，但不允许符号和字母。
- en: 'Let''s look at the `EmailInput` component now:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看`EmailInput`组件：
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This follows the same approach as `PhoneInput`. The main difference is that,
    instead of passing an array of strings and regular expressions, the `emailMask`
    function (imported from `react-text-mask`) is used.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`PhoneInput`采用相同的方法。主要区别在于，不是传递一个字符串数组和正则表达式，而是使用从`react-text-mask`导入的`emailMask`函数。
- en: 'Now that you have these two masked inputs, you use them by passing them to
    the `inputComponent` property:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了这两个掩码输入，你可以通过将它们传递给`inputComponent`属性来使用它们：
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See also
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`TextField` demos: [https://material-ui.com/demos/text-fields/](https://material-ui.com/demos/text-fields/)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextField`演示：[https://material-ui.com/demos/text-fields/](https://material-ui.com/demos/text-fields/)'
- en: '`TextField` API documentation: [https://material-ui.com/api/text-field/](https://material-ui.com/api/text-field/)'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextField` API文档：[https://material-ui.com/api/text-field/](https://material-ui.com/api/text-field/)'
- en: React text mask: [https://github.com/text-mask/text-mask](https://github.com/text-mask/text-mask)
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React文本掩码：[https://github.com/text-mask/text-mask](https://github.com/text-mask/text-mask)
