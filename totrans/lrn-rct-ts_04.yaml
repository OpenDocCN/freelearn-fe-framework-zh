- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using React Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about React’s common Hooks and how to use them
    with TypeScript. We will implement the knowledge of all these Hooks in a React
    component that allows a user to adjust a score for a person. We will start by
    exploring the effect Hook and begin to understand use cases where it is useful.
    We will then delve into two state Hooks, `useState` and `useReducer`, understanding
    when it is best to use each one. After that, we will cover the ref Hook and how
    it differs from the state Hook, and then the memo and callback Hooks, looking
    at how they can help performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the effect Hook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using state Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the ref Hook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the memo Hook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the callback Hook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the following technologies in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Browser**: A modern browser such as Google Chrome'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node.js** and **npm**: You can install them from [https://nodejs.org/en/download/](https://nodejs.org/en/download/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Code**: You can install it from [https://code.visualstudio.com/](https://code.visualstudio.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the code snippets in this chapter can be found online at [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter4](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter4).
  prefs: []
  type: TYPE_NORMAL
- en: Using the effect Hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about the effect Hook and where it is useful.
    We will then create a new React project and a component that makes use of the
    effect Hook.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the effect Hook parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The effect Hook is used for component side effects. A component side effect
    is something executed outside the scope of the component such as a web service
    request. The effect Hook is defined using the `useEffect` function from React.
    `useEffect` contains two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: A function that executes the effect; at a minimum, this function runs each time
    the component is rendered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional array of dependencies that cause the effect function to rerun when
    changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example of the `useEffect` Hook in a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding effect Hook is passed an effect function called `someEffect`.
    No effect dependencies have been passed, so the effect function is executed each
    time the component renders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, an anonymous arrow function is used for the effect function. Here’s
    the same example but with an anonymous effect function instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this version of the code is a little shorter and arguably easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another example of an effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This time the effect has a dependency on a `search` prop. So, the `search` prop
    is defined in an array in the effect Hook’s second parameter. The effect function
    will run every time the value of `search` changes.
  prefs: []
  type: TYPE_NORMAL
- en: The rules of Hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some rules that all Hooks, including `useEffect`, must obey:'
  prefs: []
  type: TYPE_NORMAL
- en: A Hook can only be called at the top level of a function component. So, a Hook
    can’t be called in a loop or in a nested function such as an event handler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Hook can’t be called conditionally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Hook can only be used in function components and not class components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example is a violation of the rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a violation because `useEffect` is called in a handler function rather
    than at the top level. A corrected version is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`useEffect` has been lifted to the top level and now depends on the `clicked`
    state that is set in the handler function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is another example that violates the rules of Hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The violation is because `useEffect` is called conditionally. If `someProp`
    is falsy, `null` is returned from the component and `useEffect` is never called.
    So, the condition is that `useEffect` is only called when `someProp` is truthy.
  prefs: []
  type: TYPE_NORMAL
- en: 'A corrected version is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`useEffect` has been lifted above the condition. The condition has also been
    put inside the effect function so that its logic is only executed when `someProp`
    is truthy.'
  prefs: []
  type: TYPE_NORMAL
- en: Effect cleanup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An effect can return a function that performs cleanup logic when the component
    is unmounted. Cleanup logic ensures nothing is left that could cause a memory
    leak. Let’s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding effect function attaches an event handler to the `document` element.
    The event handler is never detatched though, so multiple event handlers will become
    attached to the `document` element as the effect is rerun. This problem is resolved
    by returning a `cleanup` function that detaches the event handler as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Often, an anonymous arrow function is used for the cleanup function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: An anonymous arrow function is a little shorter than the named function in the
    previous example.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore a common use case for the effect Hook.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by creating a new project in Visual Studio Code using Create React
    App. We learned how to do this in [*Chapter 3*](B19051_03.xhtml#_idTextAnchor072)*,
    Setting Up React and TypeScript* – the steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Visual Studio Code in a blank folder of your choice and run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create React App will take a minute or so to create the project. The app is
    called `app` in the proceeding command, but feel free to change this.
  prefs: []
  type: TYPE_NORMAL
- en: Reopen Visual Studio Code in the `app` folder that has just been created (or
    whatever you called the app).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install Prettier and its libraries to allow it to work with ESLint. Run the
    following command in the terminal to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enable Visual Studio Code to automatically format code as files are saved.
    To do this, create a `.vscode` folder in the project root and create a `settings.json`
    file containing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the ESLint configuration to allow Prettier to manage the styling rules.
    To do this, add the following highlighted line to the `eslintConfig` section in
    `package.json`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following Prettier configuration in a file called `.prettierrc.json`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove the following files from the `src` folder, because these aren’t needed
    in this project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`App.test.tsx`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Logo.svg`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Open `index.tsx` and save the file without making any changes. This will remove
    any formatting issues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `App.tsx` and replace the content with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Start the app running in development mode by running `npm start` in the terminal.
    The app contains a blank page at the moment. Keep the app running as we explore
    the different Hooks in a React component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That’s the project created. Next, we will use the effect Hook.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data using the effect Hook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common use of the effect Hook is fetching data. Carry out the following steps
    to implement an effect that fetches a person’s name:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a function that will simulate a data request. To do this, create a file
    called `getPerson.ts` in the `src` folder and then add the following content to
    this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The function asynchronously returns an object, `{ name: "Bob" }`, after a second
    has elapsed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the type annotation for the return type, `Promise<Person>`. The `Promise`
    type represents a JavaScript `Promise`, which is something that will eventually
    be completed. The `Promise` type has a generic argument for the item type that
    is resolved in the promise, which is `Person` in this example. For more information
    on JavaScript promises, see the following link: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create a React component that will eventually display a person
    and a score. Create a file called `PersonScore.tsx` in the `src` folder and then
    add the following contents to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `useEffect` Hook has been imported from React and the `getPerson` function
    we have just created has also been imported. At the moment, the component simply
    returns `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following effect above the return statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The effect calls the `getPerson` function and outputs the returned person to
    the console. The effect is only executed after the component is initially rendered
    because an empty array has been specified as the effect dependencies in its second
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `App.tsx` and render the `PersonScore` component inside the `div` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go to the running app in the browser and go to the `person` object appears
    in the console, which verifies that the effect that fetches the `person` data
    ran properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The effect output](img/B19051_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The effect output
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also notice that the effect function has been executed twice rather
    than once. This behavior is intentional and only happens in development mode with
    React Strict Mode. This will eventually allow a future React feature to preserve
    the state when sections of the UI are removed. See this blog post from the React
    team for more information on this behavior: https://reactjs.org/blog/2022/03/29/react-v18.html#new-strict-mode-behaviors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will refactor how the effect function is called to expose an interesting
    problem. Open `PersonScore.tsx` and change the `useEffect` call to use the `async`/`await`
    syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The `async`/`await` syntax is an alternative way to write asynchronous code.
    Many developers prefer it because it reads like synchronous code. For more information
    on `async`/`await`, see the following link: [https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises#async_and_await](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises#async_and_await).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code is arguably more readable, but React raises an error. Look
    in the browser’s console and you’ll see the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Effect async error](img/B19051_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Effect async error
  prefs: []
  type: TYPE_NORMAL
- en: The error is very informative – the `useEffect` Hook doesn’t allow a function
    marked with `async` to be passed into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, update the code and use the approach suggested in the error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A nested asynchronous function has been defined and immediately called in the
    effect function; this works nicely.
  prefs: []
  type: TYPE_NORMAL
- en: 'This implementation of the effect is arguably less readable than the initial
    version. So, switch back to that version before continuing to the next section.
    The code is available to copy from the following link: [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter4/Section1-Using-the-effect-hook/src/PersonScore.tsx](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter4/Section1-Using-the-effect-hook/src/PersonScore.tsx).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That completes our exploration of the effect Hook – here’s a recap:'
  prefs: []
  type: TYPE_NORMAL
- en: The effect Hook is used to execute component side effects when a component is
    rendered or when certain props or states change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A common use case for the effect Hook is fetching data. Another use case is
    where DOM events need to be manually registered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any required effect cleanup can be done in a function returned by the effect
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will learn about the two state Hooks in React. Keep the app running
    as we move to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using state Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already learned about the `useState` Hook in previous chapters, but
    here we will look at it again and compare it against another state Hook we haven’t
    covered yet, `useReducer`. We will expand the `PersonScore` component we created
    in the last section to explore these state Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Using useState
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a reminder, the `useState` Hook allows state to be defined in a variable.
    The syntax for `useState` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: We will enhance the `PersonScore` component we created in the last section to
    store the person’s name in `state`. We will also have `state` for a score that
    is incremented, decremented, and reset using some buttons in the component. We
    will also add the `loading` state to the component, which will show a loading
    indicator when `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `PersonScore.tsx` and add `useState` to the React import statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following state definitions for `name`, `score`, and `loading` at the
    top of the component function, above the `useEffect` call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `score` state is initialized to `0` and `loading` is initialized to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the effect function to set the `loading` and `name` state values after
    the person data has been fetched. This should replace the existing `console.log`
    statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the person has been fetched, `loading` is set to `false`, and `name` is
    set to the person’s name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following `if` statement in between the `useEffect` call and
    the return statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This displays a loading indicator when the `loading` state is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the component’s return statement from outputting nothing to outputting
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The person’s name and score are displayed in a header with **Add**, **Subtract**,
    and **Reset** buttons underneath (don’t worry that the output is unstyled – we
    will learn how to style components in the next chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – The PersonScore component after data has been fetched](img/B19051_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – The PersonScore component after data has been fetched
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the **Add** button so that it increments the score when clicked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The button click event calls the score state setter to increment the state.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an alternative method of updating the state values based on their
    previous value. The alternative method uses a parameter in the state setter that
    gives the previous state value, so our example could look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: This is arguably a little harder to read, so we’ll stick to our initial method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add score state setters to the other buttons as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the running app, click the different buttons. They should change the score
    as you would expect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.4 – The PersonScore component after the button is clicked](img/B19051_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – The PersonScore component after the button is clicked
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we finish this exercise, let’s take some time to understand when the
    state values are actually set. Update the effect function to output the state
    values after they are set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Perhaps we would expect `false` and `"Bob"` as the output to the console? However,
    `true` and `undefined` are the output to the console. This is because updating
    state values is not immediate – instead, they are batched and updated before the
    next render. So, it isn’t until the next render that `loading` will be `false`,
    and `name` will be `"Bob"`.
  prefs: []
  type: TYPE_NORMAL
- en: We no longer need the `console.log` statement we added in this step, so remove
    it before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn about an alternative React Hook for using state.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding useReducer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`useReducer` is an alternative method of managing state. It uses a **reducer**
    function for state changes, which takes in the current state value and returns
    the new state value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a `useReducer` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: So, `useReducer` takes in a reducer function and the initial state value as
    parameters. It then returns a tuple containing the current state value and a function
    to **dispatch** state changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dispatch function takes in an argument that describes the change. This
    object is called an `dispatch` call is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no defined structure for an action, but it is common practice for
    it to contain a property, such as `type`, to specify the type of change. Other
    properties in the action can vary depending on the type of change. Here’s another
    example of a `dispatch` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: This time, the action only needs the type to change the necessary state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Turning our attention to the reducer function, it has parameters for the current
    state value and the action. Here’s an example code snippet of a reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: The reducer function usually contains a `switch` statement based on the action
    type. Each switch branch makes the required changes to the state and returns the
    updated state. A new state object is created during the state change – the current
    state is never mutated. A mutating state would result in the component not re-rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'The types for `useReducer` can be explicitly defined in its generic parameter
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '`Reducer` is a standard React type that has generic parameters for the type
    of state and the type of action.'
  prefs: []
  type: TYPE_NORMAL
- en: So, `useReducer` is more complex than `useState` because state changes go through
    a reducer function that we must implement. This benefits complex state objects
    with related properties or when a state change depends on the previous state value.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will implement state using `useReducer`.
  prefs: []
  type: TYPE_NORMAL
- en: Using useReducer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will refactor the `PersonScore` component we have been working on to use
    `useReducer` instead of `useState`. To do this, carry out the following steps.
    The code snippets used are available to copy from [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter4/Section2-Using-state-hooks/2-Using-useReducer/src/PersonScore.tsx](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter4/Section2-Using-state-hooks/2-Using-useReducer/src/PersonScore.tsx):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `PersonScore.tsx` and import `useReducer` instead of `useState` from React:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will have the state in a single object, so define a type for the state beneath
    the import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s also define types for all the action objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These action objects represent all the ways in which state can change. The action
    object types are combined using a union type, allowing an action to be any of
    these.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, define the following reducer function underneath the type definitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The reducer function contains a `switch` statement that makes appropriate state
    changes for each type of action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the nice IntelliSense when referencing the `state` and `action` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – IntelliSense inside the reducer function](img/B19051_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – IntelliSense inside the reducer function
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `PersonScore` component, replace the `useState` calls with the following
    `useReducer` call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The state has been initialized with an `undefined` name, a score of `0`, and
    `loading` set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The current state value has been destructured into `name`, `score`, and `loading`
    variables. If you hover over these destructured state variables, you will see
    that their types have been inferred correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to amend the places in the component that update the state. Start
    with the effect function and dispatch an initialize action after the person has
    been returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, dispatch the relevant actions in the button click handlers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you try clicking the buttons in the running app, they will correctly update.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That completes our exploration of the `useReducer` Hook. It is more useful for
    complex state management situations than `useState`, for example, when the state
    is a complex object with related properties and state changes depend on previous
    state values. The `useState` Hook is more appropriate when the state is based
    on primitive values independent of any other state.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue to expand the `PersonScore` component in the following sections.
    Next, we will learn how to move the focus to the **Add** button using the ref
    Hook.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ref Hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about the ref Hook and where it is useful. We
    will then walk through a common use case of the ref Hook by enhancing the `PersonScore`
    component we have been working on.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the ref Hook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ref Hook is called `useRef` and it returns a variable whose value is persisted
    for the lifetime of a component. This means that the variable doesn’t lose its
    value when a component re-renders.
  prefs: []
  type: TYPE_NORMAL
- en: The value returned from the ref Hook is often referred to as a **ref**. The
    ref can be changed without causing a re-render.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the syntax for `useRef`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'An initial value can optionally be passed into `useRef`. The type of the ref
    can be explicitly defined in a generic argument for `useRef`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: The generic argument is useful when no initial value is passed or is `null`.
    This is because TypeScript won’t be able to infer the type correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of the ref is accessed via its `current` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of the ref can be updated via its current property as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'A common use of the `useRef` Hook is to access HTML elements imperatively.
    HTML elements have a `ref` attribute in JSX that can be assigned to a ref. The
    following is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: The ref used here is called `inputRef` and is initially `null`. So, it is explicitly
    given a type of `HTMLInputElement`, which is a standard type for input elements.
    The ref is then assigned to the `ref` attribute on an input element in JSX. All
    the input’s properties and methods are then accessible via the ref’s `current`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will use the `useRef` Hook in the `PersonScore` component.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ref Hook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will enhance the `PersonScore` component we have been working on to use
    `useRef` to move the focus to the **Add** button. To do this, carry out the following
    steps. All the code snippets used are available at [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter4/Section3-Using-the-ref-hook/src/PersonScore.tsx](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter4/Section3-Using-the-ref-hook/src/PersonScore.tsx):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `PersonScore.tsx` and import `useRef` from React:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a ref for the `useReducer` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The ref is named `addButtonRef` and is initially `null`. It is given the standard
    `HTMLButtonElement` type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: All the standard HTML elements have corresponding TypeScript types for React.
    Right-click on the `HTMLButtonElement` type and choose **Go to Definition** to
    discover all these types. The React TypeScript types will open containing all
    the HTML element types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign the ref to the `ref` attribute on the **Add** button JSX element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have a reference to the `focus` method to move the focus to it
    when the person’s information has been fetched. Let’s add another effect to do
    this below the existing effect that fetches the person:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE206]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE207]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE208]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE209]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE211]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE212]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE213]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE214]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The effect is executed when the `loading` state is `true`, which will be after
    the person has been fetched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the `?` symbol after the `current` property on the ref. This is the
    `focus` method to be invoked without having to check that `current` is not `null`.
    Visit the following link for more information about optional chaining: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have moved the focus to the **Add** button in the existing effect
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: However, this is mixing the concerns of fetching data, setting state, and setting
    focus to a button. Mixing concerns like this can make components hard to understand
    and change.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you refresh the browser containing the running app, you will see a focus
    indicator on the **Add** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.6 – The focused Add button](img/B19051_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – The focused Add button
  prefs: []
  type: TYPE_NORMAL
- en: If you press the *Enter* key, you will see that the **Add** button is clicked
    and the score incremented. This proves that the **Add** button is focused.
  prefs: []
  type: TYPE_NORMAL
- en: That completes the enhancement and our exploration of the ref Hook.
  prefs: []
  type: TYPE_NORMAL
- en: To recap, the `useRef` Hook creates a mutatable value and doesn’t cause a re-render
    when changed. It is commonly used to access HTML elements in React imperatively.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn about the memo Hook.
  prefs: []
  type: TYPE_NORMAL
- en: Using the memo Hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about the memo Hook and where it is useful. We
    will then walk through an example in the `PersonScore` component we have been
    working on.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the memo Hook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The memo Hook creates a memoized value and is beneficial for values that have
    computationally expensive calculations. The Hook is called `useMemo` and the syntax
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: A function that returns the value to memoize is passed into `useMemo` as the
    first argument. The function in this first argument should perform the expensive
    calculation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second argument passed to `useMemo` is an array of dependencies. So, if
    the `expensiveCalculation` function has dependencies `a` and `b`, the call will
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: When any dependencies change, the function in the first argument is executed
    again to return a new value to memoize. In the previous example, a new version
    of `memoizedValue` is created every time `a` or `b` changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type of the memoized value is inferred but can be explicitly defined in
    a generic parameter on `useMemo`. The following is an example of explicitly defining
    that the memoized value should have a `number` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will experiment with `useMemo`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the memo Hook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the `PersonScore` component we have been working on to play with
    the `useMemo` Hook. To do so, carry out the following steps. The code snippets
    used are available at [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter4/Section4-Using-the-memo-hook](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter4/Section4-Using-the-memo-hook):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `PersonScore.tsx` and import `useMemo` from React:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE221]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE222]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE223]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE224]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE225]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following expensive function below the import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE227]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE228]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE229]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE230]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE231]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE232]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE233]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function adds all the numbers between `0` and `10000` and will take a while
    to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a call to the function in the `PersonScore` component beneath the effects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE235]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE236]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE237]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE238]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the result of the function call to the JSX underneath `name` and `score`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE240]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE241]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE242]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE243]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE244]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE245]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Refresh the browser containing the app and click the buttons. If you look in
    the console, you will see that the expensive function is executed every time the
    component is re-rendered after a button click.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.7 – The expensive function executed multiple times](img/B19051_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – The expensive function executed multiple times
  prefs: []
  type: TYPE_NORMAL
- en: Remember that a double render occurs in development mode and React’s Strict
    Mode. So, once a button is clicked, you will see **Executing silly function**
    in the console twice.
  prefs: []
  type: TYPE_NORMAL
- en: An expensive function executing each time a component is re-rendered can lead
    to performance problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rework the call to `sillyExpensiveFunction` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE247]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE248]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE249]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `useMemo` Hook is used to memoize the value from the function call.
  prefs: []
  type: TYPE_NORMAL
- en: Refresh the browser containing the running app and click the buttons. If you
    look in the console, you will see that the expensive function isn’t executed when
    the buttons are clicked because the memoized value is used instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.8 – The expensive function call memoized](img/B19051_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – The expensive function call memoized
  prefs: []
  type: TYPE_NORMAL
- en: That completes our exploration of the `useMemo` Hook. The takeaway from this
    section is that the `useMemo` Hook helps improve the performance of function calls
    by memoizing their results and using the memoized value when the function is re-executed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at another Hook that can help performance.
  prefs: []
  type: TYPE_NORMAL
- en: Using the callback Hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about the callback Hook and where it is useful.
    We will then use the Hook in the `PersonScore` component we have been working
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the callback Hook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The callback Hook memoizes a function so that it isn’t recreated on each render.
    The Hook is called `useCallback` and the syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: 'A function that executes the function to memoize is passed into `useCallback`
    as the first argument. The second argument passed to `useCallback` is an array
    of dependencies. So, if the `someFunction` function has dependencies `a` and `b`,
    the call will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: When any dependencies change, the function in the first argument is executed
    again to return a new function to memoize. In the previous example, a new version
    of `memoizedCallback` is created every time `a` or `b` changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type of the memoized function is inferred but can be explicitly defined
    in a generic parameter on `useCallback`. Here is an example of explicitly defining
    that the memoized function has no parameters and returns `void`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: A common use case for `useCallback` is to prevent unnecessary re-renders of
    child components. Before trying `useCallback`, we will take the time to understand
    when a component is re-rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding when a component is re-rendered
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already understand that a component re-renders when its state changes. Consider
    the following component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: When `someState` changes, `SomeComponent` will re-render – for example, when
    the button is clicked. In addition, `ChildComponent` and `AnotherChildComponent`
    will re-render when `someState` changes. This is because a component is re-rendered
    when its parent is re-rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'It may seem like this re-rendering behavior will cause performance problems
    – particularly when a component is rendered near the top of a large component
    tree. However, it rarely does cause performance issues. This is because the DOM
    will only be updated after a re-render if the virtual DOM changes, and updating
    the DOM is the slow part of the process. In the preceding example, the DOM for
    `ChildComponent` won’t be updated when `SomeComponent` is re-rendered if the definition
    of `ChildComponent` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: The DOM for `ChildComponent` won’t be updated during a re-render because the
    virtual DOM will be unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: While this re-rendering behavior generally doesn’t cause performance problems,
    it can cause performance issues if a computationally expensive component is frequently
    re-rendered or a component with a slow side effect is frequently re-rendered.
    For example, we would want to avoid unnecessary re-renders in components with
    a side effect that fetches data.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a function called `memo` in React that can be used to prevent unnecessary
    re-renders. The memo function can be applied as follows to `ChildComponent` to
    prevent unnecessary re-renders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: The `memo` function wraps the component and memoizes the result for a given
    set of props. The memoized function is then used during a re-render if the props
    are the same. Note that the preceding code snippet uses arrow function syntax
    so that the component can be a named export.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, React’s `memo` function can prevent the unnecessary re-rendering
    of slow components.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will use the `memo` function and the `useCallback` Hook to prevent
    unnecessary re-renders.
  prefs: []
  type: TYPE_NORMAL
- en: Using the callback Hook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now refactor the `PersonScore` component by extracting the `Reset`.
    This will lead to unnecessary re-rendering of the `Reset` component, which we
    will resolve using React’s `memo` function and the `useCallback` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, carry out the following steps. The code snippets used are available
    at [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter4/Section5-Using-the-callback-hook](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter4/Section5-Using-the-callback-hook):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new file in the `src` folder for the reset button called
    `Reset.tsx` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE257]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE258]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE259]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE260]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE261]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE262]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The component takes in a click handler and displays the reset button. The component
    also outputs **render Reset** to the console so that we can clearly see when the
    component is re-rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `PersonScore.tsx` and import the `Reset` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the existing reset button with the new `Reset` component as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE265]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE266]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE267]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE268]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE269]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE270]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go to the app running in the browser and open React’s DevTools. Make sure the
    **Highlight updates when components render.** option is ticked in the **Components**
    panel’s settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.9 – The re-render highlight option](img/B19051_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – The re-render highlight option
  prefs: []
  type: TYPE_NORMAL
- en: In the browser, the `Reset` is unnecessarily re-rendered. You will also see
    the re-render highlight around the **Reset** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.10 – The unnecessary re-renders of the Reset component](img/B19051_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – The unnecessary re-renders of the Reset component
  prefs: []
  type: TYPE_NORMAL
- en: Use the browser’s DevTools to inspect the DOM. To do this, right-click on the
    `h3` element content was updated – none of the other elements are highlighted
    due to an update occurring.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.11 – The h3 element was updated after a re-render](img/B19051_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – The h3 element was updated after a re-render
  prefs: []
  type: TYPE_NORMAL
- en: Even though `Reset` is unnecessarily re-rendered, it doesn’t result in a DOM
    update. In addition, `Reset` isn’t computationally expensive and doesn’t contain
    any side effects. So, the unnecessary render isn’t really a performance problem.
    However, we will use this example to learn how to use React’s `memo` function,
    and the `useCallback` Hook can prevent the unnecessary render.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now add React’s `memo` function to try to prevent unnecessary re-renders.
    Open `React.tsx` and add a React import statement to import `memo` at the top
    of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, wrap `memo` around the `Reset` component as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE273]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE274]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE275]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In addition, add the following line beneath the `Reset` component definition
    so that it has a meaningful name in React’s DevTools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the browser, click the `Reset` is *still* unnecessarily re-rendered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will use React’s DevTools to start to understand why Reset is still unnecessarily
    re-rendered when its result is memoized. Open the **Profiler** panel and click
    the cog icon to open the settings. Go to the **Profiler** settings section and
    make sure **Record why each component rendered while profiling.** is ticked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Ensuring the Record why each component rendered while profiling.
    option is ticked](img/B19051_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – Ensuring the Record why each component rendered while profiling.
    option is ticked
  prefs: []
  type: TYPE_NORMAL
- en: Click the blue circle icon to start profiling and then click the **Add** button
    in our app. Click the red circle icon to stop profiling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the flamegraph that appears, click the `Reset` component re-render:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Information about the Reset re-render](img/B19051_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – Information about the Reset re-render
  prefs: []
  type: TYPE_NORMAL
- en: So, the unnecessary `Reset` render is happening because the `onClick` prop changes.
    The `onClick` handler contains the same code, but a new instance of the function
    is created on every render. This means `onClick` will have a different reference
    on each render. The changing `onClick` prop reference means that the memorized
    result from `Reset` isn’t used and a re-render occurs instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `useCallback` Hook to memoize the `onClick` handler and prevent
    the re-render. Open `PersonScore.tsx` and start by refactoring the handler into
    a named function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE278]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE279]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE280]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE281]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE282]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE283]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE284]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE285]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE286]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE287]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE288]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add `useCallback` to the React import statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE290]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE291]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE292]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE293]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE294]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE295]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, wrap `useCallback` around the click handler we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE297]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE298]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE299]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, if you click the `Reset` is no longer unnecessarily re-rendered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That completes our exploration of the `useCallback` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a quick recap of everything we learned in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: A component is re-rendered when its parent is re-rendered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React’s `memo` function can be used to prevent unnecessary re-renders to child
    components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useCallback` can be used to memoize functions. This can be used to create
    a stable reference for function props passed to child components to prevent unnecessary
    re-renders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React’s `memo` function and `useCallback` should be used wisely – make sure
    they help performance before using them because they increase the complexity of
    the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will summarize the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned that all React Hooks must be called at the top level
    of a function component and can’t be called conditionally.
  prefs: []
  type: TYPE_NORMAL
- en: The `useEffect` Hook can be used to execute component side effects when it is
    rendered. We learned how to use `useEffect` to fetch data, which is a common use
    case.
  prefs: []
  type: TYPE_NORMAL
- en: '`useReducer` is an alternative to `useState` for using state, and we experienced
    using both approaches in our `PersonScore` example component. `useState` is excellent
    for primitive state values. `useReducer` is great for complex object state values,
    particularly when state changes depend on previous state values.'
  prefs: []
  type: TYPE_NORMAL
- en: The `useRef` Hook creates a mutatable value and doesn’t cause a re-render when
    changed. We used `useRef` to set focus to an HTML element after it was rendered,
    which is a common use case.
  prefs: []
  type: TYPE_NORMAL
- en: The `useMemo` and `useCallback` Hooks can be used to memoize values and functions,
    respectively, and can be used for performance optimization. The examples we used
    for these Hooks were a little contrived and using `useCallback` didn’t improve
    performance, so remember to check that the use of these Hooks does improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: So far in this book, the components we have created are unstyled. In the next
    chapter, we will learn several approaches for styling React components.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to check what you have learned about React Hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: The following component renders some text for 5 seconds. This is problematic
    though – what is the problem?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE301]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE302]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE303]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE304]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE305]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE306]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE307]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE308]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE309]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The following code is a snippet from a React component that fetches some data
    and stores it in state. There are several problems with this code though – can
    you spot any of the problems?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE311]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE312]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE313]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE314]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How many times will the following component re-render in production mode when
    the button is clicked? Also, what will the button content be after one click?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE316]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE317]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE318]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE319]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE320]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE321]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE322]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE323]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE324]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE325]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE326]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE327]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE328]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How many times will the following component re-render in production mode when
    the button is clicked? Also, what will the button content be after one click?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE330]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE331]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE332]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE333]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE334]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE335]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE336]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE337]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE338]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE339]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE340]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Consider the following `reducer` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE342]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE343]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE344]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE345]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE346]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE347]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE348]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE349]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE350]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE351]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE352]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE353]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE354]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What will the type of the `action` parameter be narrowed down to in the `"backwards"`
    switch branch?
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following `Counter` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE356]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE357]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE358]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE359]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE360]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE361]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE362]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE363]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE364]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE365]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What will the button content be after it is clicked once?
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following `Counter` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE367]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE368]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE369]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE370]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE371]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE372]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE373]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE374]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE375]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE376]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What will the button content be after it is clicked twice?
  prefs: []
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The problem with the component is that both `useState` and `useEffect` are
    called conditionally (when the `text` prop is defined), and React doesn’t allow
    its Hooks to be called conditionally. Placing the Hooks before the `if` statement
    resolves the problem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE378]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE379]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE380]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE381]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE382]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE383]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE384]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE385]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE386]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The main problem with the code is that the effect function can’t be marked
    as asynchronous with the `async` keyword. A solution is to revert to the older
    promise syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE388]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE389]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE390]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The other major problem is that no dependencies are defined in the call to
    `useEffect`. This means the effect function will be executed on every render.
    The effect function sets some state, which causes a re-render. So, the component
    will keep re-rendering, and the effect function will keep executing indefinitely.
    An empty array passed into the second argument of `useEffect` will resolve the
    problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: 'Another problem is that the `data` state will have the `any[]` type, which
    isn’t ideal. In this case, it is probably better to explicitly define the type
    of the state as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: 'The last problem is that the data state could be set after the component has
    been unmounted, which can lead to memory leaks. A solution is to set a flag when
    the component is unmounted and not set the state when the flag is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: The button will only render once in production mode because state changes are
    batched.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The state isn’t changed until the next render, so clicking the button once will
    result in `count` being set to `1`, which means the button content will be `1`.
  prefs: []
  type: TYPE_NORMAL
- en: The button will not re-render when the button is clicked because changes to
    a ref don’t cause a re-render.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `counter` ref will be incremented when the button is clicked. However, because
    a re-render doesn’t occur, the button content will still be `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript will narrow the type of the `action` parameter to `{ type: ''backwards`
    `''; steps: number }` in the `''backwards''` switch branch.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The button’s content will always be `0` because the initial count of `0` is
    memoized and never updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The button content will be `1` after one click and will stay as `1` after subsequent
    clicks. So, after two clicks, it will be `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The key here is that the `handleClick` function is only created when the component
    is initially rendered because `useCallback` memoizes it. So, the `count` state
    will always be `0` within the memoized function. This means the `count` state
    will always be updated to `1`, which will appear in the button content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: App Fundamentals'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part covers the fundamental topics for building apps that are outside the
    core of React. These topics are styling, clientside routing, and forms. Each topic
    involves different approaches that you can take, along with the benefits of each
    one. We will also cover several popular third-party libraries that are commonly
    used for these parts of an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B19051_05.xhtml#_idTextAnchor127), *Approaches to Styling React
    Frontends*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19051_06.xhtml#_idTextAnchor151), *Routing with React Router*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19051_07.xhtml#_idTextAnchor188), *Working with Forms*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
