- en: '28'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Going Offline
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users expect applications to operate seamlessly with unreliable network connections.
    If your mobile application can’t cope with transient network issues, your users
    will use a different app. When there’s no network, you have to persist data locally
    on the device. Alternatively, perhaps your app doesn’t even require network access,
    in which case you’ll still need to store data locally.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how to do those three things with React Native.
    First, you’ll learn how to detect the state of the network connection. Second,
    you’ll learn how to store data locally. Lastly, you’ll learn how to synchronize
    local data that’s been stored due to network problems once it comes back online.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the state of the network
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing application data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing application data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter28](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter28).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the state of the network
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your code tries to make a request over the network while disconnected using
    `fetch()`, for example an error will occur. You probably have error-handling code
    in place for these scenarios already, since the server could return some other
    type of error.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: However, in the case of connectivity trouble, you might want to detect this
    issue before the user attempts to make network requests.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: There are two potential reasons for proactively detecting the network state.
    The first one is to prevent the user from performing any network requests until
    you’ve detected that the app is back online. To do that, you can display a friendly
    message to the user stating that, since the network is disconnected, they can’t
    do anything. The other possible benefit of early network state detection is that
    you can prepare to perform actions offline and sync the app state when the network
    is connected again.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some code that uses the `NetInfo` utility from the `@react-native-community/netinfo`
    package to handle changes in network state:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`connectedMap` covers all connection states and will help us to render them
    on the screen. Let’s now see the `App` component:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This component will render the state of the network based on the string values
    in `connectedMap`. The `onNetworkChange` event of the `NetInfo` object will cause
    the connected state to change.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when you run this app for the first time, the screen might look
    like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![Picture 1](img/B19636_28_01.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: 'Figure 28.1: Connected state'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, if you turn off networking on your host machine, the network state will
    change on the emulated device as well, causing the state of our application to
    change, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![Picture 2](img/B19636_28_02.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: 'Figure 28.2: Disconnected state'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: This is how you can use network state detection in the app. As discussed, together
    with showing the message, you can use network state to prevent users from making
    API requests. Another valuable approach would be to save user inputs locally until
    the network gets back online. Let’s explore it in the next section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何在应用中使用网络状态检测。正如讨论的那样，除了显示消息外，你还可以使用网络状态来防止用户发起API请求。另一种有价值的方法是在网络恢复在线之前将用户输入本地保存。让我们在下一节中探讨它。
- en: Storing application data
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储应用程序数据
- en: To store data on the device, there is a special cross-platform solution called
    `AsyncStorage` API. It works the same on both the iOS and Android platforms. You
    would use this API for applications that don’t require any network connectivity
    in the first place or to store data that will eventually be synchronized using
    an API endpoint once a network becomes available.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要在设备上存储数据，有一个特殊的跨平台解决方案，称为`AsyncStorage` API。它在iOS和Android平台上工作方式相同。你会使用这个API来处理最初不需要任何网络连接的应用程序，或者存储最终将通过网络可用时使用API端点同步的数据。
- en: 'To install the `async-storage` package, run the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`async-storage`包，请运行以下命令：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s look at some code that allows the user to enter a `key` and a `value`
    and then stores them:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些允许用户输入一个`key`和一个`value`并将它们存储起来的代码：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `key`, `value`, and `source` values will handle our state. To save it in
    `AsyncStorage`, we need to define functions:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`key`、`value`和`source`值将处理我们的状态。为了将其保存到`AsyncStorage`，我们需要定义函数：'
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We’ve defined handlers to save values from the inputs, clear `AsyncStorage`,
    and load saved items when we start the app. Here’s the markup that’s rendered
    by the `App` component:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了处理程序来保存输入中的值、清除`AsyncStorage`以及在启动应用时加载已保存的项目。以下是`App`组件渲染的标记：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The markup in the preceding code block is represented as inputs and buttons
    to create, save, and delete items. Next, we will render the list of items with
    the `FlatList` component:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码块中的标记表示为创建、保存和删除项的输入和按钮。接下来，我们将使用`FlatList`组件渲染项目列表：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Before we walk through what this code is doing, let’s take a look at the following
    screen, since it’ll explain most of what we’re going to cover when storing application
    data:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们遍历这段代码的功能之前，让我们看看以下屏幕，因为它将解释我们将在存储应用程序数据时覆盖的大部分内容：
- en: '![Picture 3](img/B19636_28_03.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片3](img/B19636_28_03.png)'
- en: 'Figure 28.3: Storing application data'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图28.3：存储应用程序数据
- en: As you can see in *Figure 28.3*, there are two input fields and two buttons.
    The fields allow the user to enter a new `key` and `value`. The **Add** button
    allows the user to store this key-value pair locally on their device, while the
    **Clear** button clears any existing items that have been stored previously.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在*图28.3*中看到的，有两个输入字段和两个按钮。这些字段允许用户输入新的`key`和`value`。**添加**按钮允许用户将这个键值对本地存储在他们的设备上，而**清除**按钮则清除之前存储的任何现有项。
- en: 'The `AsyncStorage` API works the same for both iOS and Android. Under the hood,
    `AsyncStorage` works very differently, depending on which platform it’s running
    on. The reason React Native is able to expose the same storage API on both platforms
    is due to its simplicity: it’s just key-value pairs. Anything more complex than
    that is left up to the application developer.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncStorage` API在iOS和Android上工作方式相同。在底层，`AsyncStorage`根据其运行的平台而有很大不同。React
    Native能够在两个平台上公开相同的存储API的原因在于其简单性：它只是键值对。任何比这更复杂的东西都留给应用开发者处理。'
- en: The abstractions that you’ve created around `AsyncStorage` in this example are
    minimal. The idea is to set and get items. However, even straightforward actions
    like this deserve an abstraction layer. For example, the `setItem()` method you’ve
    implemented here will make the asynchronous call to `AsyncStorage` and update
    the item’s state once that has been completed. Loading items is even more complicated
    because you need to get the keys and values as two separate asynchronous operations.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，围绕`AsyncStorage`创建的抽象是最小的。想法是设置和获取项。然而，即使是这样的直接操作也值得有一个抽象层。例如，你在这里实现的`setItem()`方法将异步调用`AsyncStorage`并在完成更新后更新项的状态。加载项甚至更复杂，因为你需要作为两个单独的异步操作获取键和值。
- en: The reason we do this is to keep the UI responsive. If there are pending screen
    repaints that need to happen while data is being written to disk, preventing those
    from happening by blocking them would lead to a suboptimal user experience.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是为了保持 UI 的响应性。如果在数据写入磁盘时需要发生待处理的屏幕重绘，阻止这些操作会导致用户体验不佳。
- en: In the next section, you’ll learn how to synchronize data that’s been stored
    locally while the device is offline with remote services once the device comes
    back online.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何在设备重新上线后，同步设备离线时存储的数据与远程服务。
- en: Synchronizing application data
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步应用程序数据
- en: So far in this chapter, you’ve learned how to detect the state of a network
    connection and how to store data locally in a React Native application. Now, it’s
    time to combine these two concepts and implement an app that can detect network
    outages and continue to function.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，你已经学习了如何在 React Native 应用程序中检测网络连接状态以及如何本地存储数据。现在，是时候将这两个概念结合起来，实现一个可以检测网络中断并继续工作的应用程序。
- en: The basic idea is to only make network requests when you know for sure that
    the device is online. If you know that it isn’t, you can store any changes in
    the state locally. Then, when you’re back online, you can synchronize those stored
    changes with the remote API.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的想法是在确定设备在线时才进行网络请求。如果你知道它不在线，你可以将任何状态更改保存在本地。然后，当你再次在线时，你可以使用远程 API 同步这些已保存的更改。
- en: 'Let’s implement a simplified React Native app that does this. The first step
    is to implement an abstraction that sits between the React components and the
    network calls that store data. We’ll call this module `store.ts`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个简化的 React Native 应用程序来完成这个任务。第一步是实现一个位于 React 组件和网络调用存储数据之间的抽象。我们将把这个模块称为
    `store.ts`：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `set` method depends on the `connected` variable, and depending on whether
    there is an internet connection or not, it handles the different logic. Actually,
    the `get` method also follows the same approach:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 方法依赖于 `connected` 变量，并且根据是否有互联网连接，它处理不同的逻辑。实际上，`get` 方法也遵循相同的方法：'
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This module exports two functions, `set()` and `get()`. Their jobs are to set
    and get data, respectively. Since this is just a demonstration of how to sync
    between local storage and network endpoints, this module just mocks the actual
    network with the `fakeNetworkData` object.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本模块导出两个函数，`set()` 和 `get()`。它们分别负责设置和获取数据。由于这只是演示如何在本地存储和网络端点之间同步的一种方式，因此本模块仅使用
    `fakeNetworkData` 对象模拟实际的网络。
- en: Let’s start by looking at the `set()` function. It’s an asynchronous function
    that will always return a promise that resolves to a Boolean value. If it’s true,
    it means that you’re online and that the call over the network was successful.
    If it’s false, it means that you’re offline, and `AsyncStorage` was used to save
    the data.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看 `set()` 函数。它是一个异步函数，它总是返回一个解析为布尔值的承诺。如果是真的，这意味着你在线上，并且网络调用是成功的。如果是假的，这意味着你离线，使用了
    `AsyncStorage` 来保存数据。
- en: The same approach is used with the `get()` function. It returns a promise that
    resolves a Boolean value that indicates the state of the network. If a key argument
    is provided, then the value for that key is looked up. Otherwise, all the values
    are returned, either from the network or from `AsyncStorage`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `get()` 函数使用相同的方法。它返回一个解析为布尔值的承诺，该值指示网络的状态。如果提供了键参数，则查找该键的值。否则，返回所有值，无论是从网络还是从
    `AsyncStorage`。
- en: 'In addition to these two functions, this module does two other things:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两个函数之外，本模块还做两件事：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It uses `NetInfo.fetch()` to set the connected state. Then, it adds a listener
    to listen for changes in the network state. This is how items that were saved
    locally when you were offline become synced with the network when it’s connected
    again.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用 `NetInfo.fetch()` 来设置连接状态。然后，它添加一个监听器来监听网络状态的变化。这就是在你离线时保存的项在再次连接时与网络同步的方式。
- en: 'Now, let’s check out the main application that uses these functions:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查使用这些函数的主要应用程序：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we have defined the state variables that we will use in the `Switch`
    components:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了将在 `Switch` 组件中使用的状态变量：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `save()` function helps us to reuse logic in a different `Switch` component.
    Next, we have the `useEffect` hook to get saved data when the page renders for
    the first time:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`save()` 函数帮助我们重用在不同的 `Switch` 组件中的逻辑。接下来，我们有 `useEffect` 钩子，用于在页面首次渲染时获取保存的数据：'
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, let’s take a look at the final markup of the page:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看页面的最终标记：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The job of the `App` component is to save the state of three `Switch` components,
    which is difficult when you’re providing the user with a seamless transition between
    online and offline modes. Thankfully, your `set()` and `get()` abstractions, which
    are implemented in another module, hide most of the details from the application’s
    functionality.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`组件的职责是保存三个`Switch`组件的状态，当你向用户提供在线和离线模式之间的无缝过渡时，这很困难。幸运的是，你的`set()`和`get()`抽象，这些抽象在另一个模块中实现，隐藏了应用功能的大部分细节。'
- en: Note, however, that you need to check the state of the network in this module
    before you attempt to load any items. If you don’t do this, then the `get()` function
    will assume that you’re offline, even if the connection is fine.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，在尝试加载任何项目之前，你需要在此模块中检查网络状态。如果你不这样做，那么`get()`函数将假设你处于离线状态，即使连接良好。
- en: 'Here’s what the app looks like:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是应用的外观：
- en: '![Picture 4](img/B19636_28_04.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片 4](img/B19636_28_04.png)'
- en: 'Figure 28.4: Synchronizing application data'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图28.4：同步应用数据
- en: Note that you won’t actually see the **Saved Offline** message until you change
    something in the UI.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你实际上只有在更改UI中的内容后才会看到“**已保存离线**”的消息。
- en: Summary
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced us to storing data offline in React Native applications.
    The main reason we would want to store data locally is when the device goes offline
    and our app can’t communicate with a remote API. However, not all applications
    require API calls, and `AsyncStorage` can be used as a general-purpose storage
    mechanism. We just need to implement the appropriate abstractions around it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们介绍了在React Native应用程序中离线存储数据。我们想要本地存储数据的主要原因是当设备离线且我们的应用无法与远程API通信时。然而，并非所有应用都需要API调用，`AsyncStorage`可以用作通用存储机制。我们只需要在它周围实现适当的抽象。
- en: We also learned how to detect changes in the network state of React Native apps.
    It’s important to know when the device has gone offline so that our storage layer
    doesn’t make pointless attempts at network calls. Instead, we can let the user
    know that the device is offline and then synchronize the application state when
    a connection is available.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何检测React Native应用的网络状态变化。知道设备何时离线很重要，这样我们的存储层就不会进行无谓的网络调用。相反，我们可以让用户知道设备处于离线状态，然后在有连接可用时同步应用状态。
- en: In the next chapter, we’ll learn how to import and use UI components from the
    NativeBase library.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何从NativeBase库中导入和使用UI组件。
- en: Join us on Discord!
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord频道！
- en: Read this book alongside other users and the authors themselves. Ask questions,
    provide solutions to other readers, chat with the authors, and more. Scan the
    QR code or visit the link to join the community.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户和作者本人一起阅读这本书。提出问题，为其他读者提供解决方案，与作者聊天，等等。扫描二维码或访问链接加入社区。
- en: '[https://packt.link/ReactAndReactNative5e](https://packt.link/ReactAndReactNative5e)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/ReactAndReactNative5e](https://packt.link/ReactAndReactNative5e)'
- en: '![](img/QR_Code196803360665486921.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code196803360665486921.png)'
