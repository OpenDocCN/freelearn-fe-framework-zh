<html><head></head><body>
<div id="_idContainer045">
<h1 class="chapter-number" id="_idParaDest-157"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-158"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.2.1">Working with File Uploads</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Uploading files is </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.4.1">something we do all the time on the web. </span><span class="koboSpan" id="kobo.4.2">The web provides built-in support for uploading files. </span><span class="koboSpan" id="kobo.4.3">However, uploading and processing files as part of a form submission still requires some additional considerations that we will cover in this chapter. </span><span class="koboSpan" id="kobo.4.4">This chapter is split into </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">four sections:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.6.1">Using multi-part form data </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">in Remix</span></span></li>
<li><span class="koboSpan" id="kobo.8.1">Processing files on </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">the server</span></span></li>
<li><span class="koboSpan" id="kobo.10.1">Authorizing access to assets with </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">resource routes</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Forwarding files to </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">third-party services</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.14.1">In this chapter, we will iterate on BeeRich to support file uploads. </span><span class="koboSpan" id="kobo.14.2">First, we will update the creation and edit forms to allow adding and removing attachments. </span><span class="koboSpan" id="kobo.14.3">Next, we will refactor the </span><strong class="source-inline"><span class="koboSpan" id="kobo.15.1">action</span></strong><span class="koboSpan" id="kobo.16.1"> functions to process the attached files on the server. </span><span class="koboSpan" id="kobo.16.2">Further, we will investigate how to authorize access to uploaded files. </span><span class="koboSpan" id="kobo.16.3">Finally, we will learn about file size considerations and discuss different file </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">storage solutions.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">After reading this chapter, you will understand how to work with multi-part form data in Remix. </span><span class="koboSpan" id="kobo.18.2">You will know how to use Remix’s file upload helpers and how to use resource routes to authorize access to uploaded files. </span><span class="koboSpan" id="kobo.18.3">You will have also gained a theoretical understanding of what to consider when processing files and how to forward files to </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">third-party services.</span></span></p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.20.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.21.1">You can find the code for this chapter </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">here: </span></span><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/10-working-with-file-uploads/"><span class="No-Break"><span class="koboSpan" id="kobo.23.1">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/10-working-with-file-uploads/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.24.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">Before starting this chapter, follow the instructions in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.26.1">README.md</span></strong><span class="koboSpan" id="kobo.27.1"> file in this chapter’s folder on GitHub to clean up the experiments from </span><a href="B17399_09.xhtml#_idTextAnchor137"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.28.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.29.1">, </span><em class="italic"><span class="koboSpan" id="kobo.30.1">Assets and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.31.1">Metadata Handling</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">.</span></span></p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.33.1">Using multi-part form data in Remix</span></h1>
<p><span class="koboSpan" id="kobo.34.1">By default, form data is </span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.35.1">encoded using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">application/x-www-form-urlencoded</span></strong><span class="koboSpan" id="kobo.37.1"> encoding type. </span><span class="koboSpan" id="kobo.37.2">URL-encoded form data appends the form data as key-value pairs to the request URL as search parameters. </span><span class="koboSpan" id="kobo.37.3">To attach files to </span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.38.1">HTML forms, we need to change the form’s encoding type. </span><span class="koboSpan" id="kobo.38.2">Appending form data to the URL is not the right approach when transferring binary data such as files. </span><span class="koboSpan" id="kobo.38.3">In this section, you will learn how to use multi-part encoding to support </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">file uploads.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">There are three different encoding types for HTML </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">form elements:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">application/x-www-form-urlencoded</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">multipart/form-data</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">text/plain</span></strong></span></li>
</ul>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">text/plain</span></strong><span class="koboSpan" id="kobo.46.1"> is not what we are looking for. </span><span class="koboSpan" id="kobo.46.2">Plaintext encoding is not used for client-server communication as it submits the data in a human-readable format. </span><span class="koboSpan" id="kobo.46.3">Instead, we want to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">multipart/form-data</span></strong><span class="koboSpan" id="kobo.48.1"> encoding, which places the form data into the request body, making it possible to include and stream </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">binary files.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">Let’s update the expense creation and edit forms to allow users to attach files. </span><span class="koboSpan" id="kobo.50.2">First, let’s go ahead and make the changes to the expense </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">creation form:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.52.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">dashboard.expenses._index.tsx</span></strong><span class="koboSpan" id="kobo.54.1"> route module in </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">an editor.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.56.1">The route component currently renders a form with input fields for the expense’s title, description, </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">and amount.</span></span></p></li>
<li><span class="koboSpan" id="kobo.58.1">Update the form encoding type to </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">multipart/form-data</span></strong><span class="koboSpan" id="kobo.60.1"> and add a file </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">input field:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.62.1">
&lt;Form method="POST" action="/dashboard/expenses/?index" </span><strong class="bold"><span class="koboSpan" id="kobo.63.1">encType="multipart/form-data"</span></strong><span class="koboSpan" id="kobo.64.1">&gt;  &lt;Input label="Title:" type="text" name="title" placeholder="Dinner for Two" required /&gt;  &lt;Textarea label="Description:" name="description" /&gt;  &lt;Input label="Amount (in USD):" type="number" defaultValue={0} name="amount" required /&gt;  </span><strong class="bold"><span class="koboSpan" id="kobo.65.1">&lt;Input label="Attachment" type="file" name="attachment" /&gt;</span></strong><span class="koboSpan" id="kobo.66.1">  &lt;Button type="submit" disabled={isSubmitting} isPrimary&gt;    {isSubmitting ? </span><span class="koboSpan" id="kobo.66.2">'Creating'…'': 'Cre'te'}  &lt;/Button&gt;&lt;/Form&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.67.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">encType</span></strong><span class="koboSpan" id="kobo.69.1"> property</span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.70.1"> sets the encoding type for the HTML form element. </span><span class="koboSpan" id="kobo.70.2">The default value, </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">application/x-www-form-urlencoded</span></strong><span class="koboSpan" id="kobo.72.1">, is what we’ve used thus far in BeeRich. </span><span class="koboSpan" id="kobo.72.2">For file uploads, we must update </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">encyType</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.74.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">multipart/form-data</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.77.1">Note that</span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.78.1"> the input element’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">multiple</span></strong><span class="koboSpan" id="kobo.80.1"> property can be used to attach several files to one input field. </span><span class="koboSpan" id="kobo.80.2">By default, the input element’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">multiple</span></strong><span class="koboSpan" id="kobo.82.1"> property is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">false</span></strong><span class="koboSpan" id="kobo.84.1">. </span><span class="koboSpan" id="kobo.84.2">This means the input field lets the user attach only </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">one file.</span></span></p></li> <li><span class="koboSpan" id="kobo.86.1">Now, run the app locally (</span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">npm run dev</span></strong><span class="koboSpan" id="kobo.88.1">) and inspect the </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">updated UI.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.90.1">As visible in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.91.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.92.1">.1</span></em><span class="koboSpan" id="kobo.93.1">, the expense creation form now contains an attachment </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">input field.</span></span></p></li>
<li><span class="koboSpan" id="kobo.95.1">Fill out and submit the expense </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">creation form.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.97.1">Note that the form submission still works. </span><span class="koboSpan" id="kobo.97.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">request.formData</span></strong><span class="koboSpan" id="kobo.99.1"> function can parse both URL-encoded and multi-part form data. </span><span class="koboSpan" id="kobo.99.2">One downside of </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">request.formData</span></strong><span class="koboSpan" id="kobo.101.1"> is that it loads all the form data into server memory. </span><span class="koboSpan" id="kobo.101.2">We will see what alternatives we have later in </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">this chapter:</span></span></p></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer043">
<span class="koboSpan" id="kobo.103.1"><img alt="Figure 10.1 – Screenshot of a form with an attachment input field" src="image/Figure_10.01_B17399.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.104.1">Figure 10.1 – Screenshot of a form with an attachment input field</span></p>
<p><span class="koboSpan" id="kobo.105.1">Great! </span><span class="koboSpan" id="kobo.105.2">Just like</span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.106.1"> that, we added an attachment to the expense creation form. </span><span class="koboSpan" id="kobo.106.2">As always, apply the same changes to the invoice </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">creation form.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">The </span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.109.1">expense creation form can now include an optional file attachment. </span><span class="koboSpan" id="kobo.109.2">In the next section, we will read the uploaded file on the server and persist it to the filesystem. </span><span class="koboSpan" id="kobo.109.3">However, we also need to associate saved attachments with the expenses. </span><span class="koboSpan" id="kobo.109.4">Let’s update the database schema so that it supports adding attachments to expenses </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">and invoices:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.111.1">First, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">prisma/schema.prisma</span></strong><span class="koboSpan" id="kobo.113.1"> file in </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">your editor.</span></span></li>
<li><span class="koboSpan" id="kobo.115.1">Add the following line to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">Expense</span></strong><span class="koboSpan" id="kobo.117.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">Invoice</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.119.1">database models:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.120.1">attachment String?</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.121.1">In our database, we only store the filename of the attachment and not the attachment data itself. </span><span class="koboSpan" id="kobo.121.2">Most databases can store files, but usually, it is recommended to have a dedicated file storage, as storing files in the database may affect the overall query performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">the database.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.123.1">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">attachment</span></strong><span class="koboSpan" id="kobo.125.1"> field is marked as optional since we added a question mark symbol after the </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">data type.</span></span></p></li> <li><span class="koboSpan" id="kobo.127.1">Save the changes and run </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">npx prisma format</span></strong><span class="koboSpan" id="kobo.129.1"> in the terminal at the project’s root to format the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">schema.prisma</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.131.1"> file.</span></span></li>
<li><span class="koboSpan" id="kobo.132.1">Next, execute </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">npm run build</span></strong><span class="koboSpan" id="kobo.134.1"> to update the Prisma client </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">and types.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.136.1">Under the hood, Prisma generates types based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">schema.prisma</span></strong><span class="koboSpan" id="kobo.138.1"> file. </span><span class="koboSpan" id="kobo.138.2">After running </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">npm run build</span></strong><span class="koboSpan" id="kobo.140.1">, the expense and invoice types include the optional </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">attachment</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.142.1"> property.</span></span></p></li>
<li><span class="koboSpan" id="kobo.143.1">Finally, run </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">npm run update:db</span></strong><span class="koboSpan" id="kobo.145.1"> to synchronize your local SQLite database schema with the updated </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">Prisma schema.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.147.1">Once an</span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.148.1"> expense has been created, we want to let users view </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.149.1">and remove their current attachment. </span><span class="koboSpan" id="kobo.149.2">If no attachment is set, we further want users to be able to upload a new attachment. </span><span class="koboSpan" id="kobo.149.3">Next, let’s update the expense edit form to add </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">this functionality:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.151.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">dashboard.expenses.$id.tsx</span></strong><span class="koboSpan" id="kobo.153.1"> route module in </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">your editor.</span></span></li>
<li><span class="koboSpan" id="kobo.155.1">Update the route component’s form encoding type so that it supports </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">file uploads:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.157.1">
&lt;Form method="POST" action={`/dashboard/expenses/${expense.id}`} key={expense.id} </span><strong class="bold"><span class="koboSpan" id="kobo.158.1">encType="multipart/form-data"</span></strong><span class="koboSpan" id="kobo.159.1">&gt;</span></pre></li> <li><span class="koboSpan" id="kobo.160.1">Next, inspect the </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">loader</span></strong><span class="koboSpan" id="kobo.162.1"> function’s </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">return value.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.164.1">We need to access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">expense.attachment</span></strong><span class="koboSpan" id="kobo.166.1"> property on the client. </span><span class="koboSpan" id="kobo.166.2">Note that we already return the full expense object. </span><span class="koboSpan" id="kobo.166.3">This automatically includes the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">expense.attachment</span></strong><span class="koboSpan" id="kobo.168.1"> property. </span><span class="koboSpan" id="kobo.168.2">We can go ahead and read the property in the route’s component without changing the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">loader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.170.1"> function.</span></span></p></li>
<li><span class="koboSpan" id="kobo.171.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">app/components/forms.tsx</span></strong><span class="koboSpan" id="kobo.173.1"> file in your editor and inspect the implementation of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">Attachment</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.175.1"> component.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.176.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">Attachment</span></strong><span class="koboSpan" id="kobo.178.1"> component expects a </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">label</span></strong><span class="koboSpan" id="kobo.180.1"> property and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">attachmentUrl</span></strong><span class="koboSpan" id="kobo.182.1"> property and renders an anchor tag linking to the attachment. </span><span class="koboSpan" id="kobo.182.2">It further includes a submit button and a hidden input field </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">attachmentUrl</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.186.1">Let's</span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.187.1"> use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">Attachment</span></strong><span class="koboSpan" id="kobo.189.1"> component within the edit forms to let users view and delete their expense and </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">invoice attachments.</span></span></p></li>
<li><span class="koboSpan" id="kobo.191.1">Import</span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.192.1"> the reusable </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">Attachment</span></strong><span class="koboSpan" id="kobo.194.1"> component </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">dashboard.expenses.$id.tsx</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.198.1">
import { </span><strong class="bold"><span class="koboSpan" id="kobo.199.1">Attachment</span></strong><span class="koboSpan" id="kobo.200.1">, Form, Input, Textarea } from '~/components/forms';</span></pre></li> <li><span class="koboSpan" id="kobo.201.1">Add the following code below the last input field in </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">dashboard.expenses.$id.tsx</span></strong><span class="koboSpan" id="kobo.203.1">, right before the </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">submit button:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.205.1">
{expense.attachment ? </span><span class="koboSpan" id="kobo.205.2">(  &lt;Attachment    label="Current Attachment"  attachmentUrl={`/dashboard/expenses/${expense.id}/attachments/${expense.attachment}`}  /&gt;) : (  &lt;Input label="New Attachment" type="file" name="attachment" /&gt;)}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.206.1">If the expense object has an attachment, then we render the </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">Attachment</span></strong><span class="koboSpan" id="kobo.208.1"> component, which displays a link to the attachment and a submit button to remove the attachment. </span><span class="koboSpan" id="kobo.208.2">Otherwise, we display the same input field as in the expense creation form so that users can add a </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">new attachment.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.210.1">Notice that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">attachmentUrl</span></strong><span class="koboSpan" id="kobo.212.1"> property value points to a new </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">path: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">dashboard/expenses/$id/attachments/$</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.216.1">Run the application locally and inspect the new file input field on the expense </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">edit form.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.218.1">We need to</span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.219.1"> add</span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.220.1"> a new route module that handles access to file attachments. </span><span class="koboSpan" id="kobo.220.2">The new route module will be a resource route nested within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">dashboard/expenses/$id</span></strong><span class="koboSpan" id="kobo.222.1"> path. </span><span class="koboSpan" id="kobo.222.2">Let’s create the necessary route structure for the new </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">route module:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.224.1">Rename the </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">dashboard.expenses.$id.tsx</span></strong><span class="koboSpan" id="kobo.226.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">dashboard.expenses.$id._index.tsx</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.230.1">The route module still matches the same path as before. </span><span class="koboSpan" id="kobo.230.2">As an index route, it now acts as the default child route for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">$id</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.232.1">path segment.</span></span></p></li>
<li><span class="koboSpan" id="kobo.233.1">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">action</span></strong><span class="koboSpan" id="kobo.235.1"> attribute on all forms that are submitted </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">dashboard.expenses.$id._index.tsx</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.239.1">We moved the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">action</span></strong><span class="koboSpan" id="kobo.241.1"> function in </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">dashboard.expenses.$id.tsx</span></strong><span class="koboSpan" id="kobo.243.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">dashboard.expenses.$id._index.tsx</span></strong><span class="koboSpan" id="kobo.245.1">. </span><span class="koboSpan" id="kobo.245.2">This changes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">action</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.247.1">function’s path.</span></span></p><ol><li class="Alphabets"><span class="koboSpan" id="kobo.248.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">dashboard.expenses.tsx</span></strong><span class="koboSpan" id="kobo.250.1"> parent route module and update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">deleteProps</span></strong><span class="koboSpan" id="kobo.252.1"> property of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">ListLinkItem</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.254.1"> component:</span></span></li></ol><pre class="source-code"><span class="koboSpan" id="kobo.255.1">
deleteProps={{  ariaLabel: `Delete expense ${expense.title}`,  action: `/dashboard/expenses/${expense.id}</span><strong class="bold"><span class="koboSpan" id="kobo.256.1">?index</span></strong><span class="koboSpan" id="kobo.257.1">`,}}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.258.1">We added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">?index</span></strong><span class="koboSpan" id="kobo.260.1"> flag to tell Remix that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">action</span></strong><span class="koboSpan" id="kobo.262.1"> function can be found in </span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.263.1">the index file instead of the layout parent </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">route module.</span></span></p><ol><li class="Alphabets" value="2"><span class="koboSpan" id="kobo.265.1">Open the </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.266.1">new </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">dashboard.expenses.$id._index.tsx</span></strong><span class="koboSpan" id="kobo.268.1"> route module and add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">?index</span></strong><span class="koboSpan" id="kobo.270.1"> search parameter to the form’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">action </span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">prop:</span></span></li></ol><pre class="source-code"><span class="koboSpan" id="kobo.273.1">&lt;Form  method="POST"  action={`/dashboard/expenses/${expense.id}</span><strong class="bold"><span class="koboSpan" id="kobo.274.1">?index</span></strong><span class="koboSpan" id="kobo.275.1">`}  key={expense.id}  </span><strong class="bold"><span class="koboSpan" id="kobo.276.1">encType="multipart/form-data"</span></strong><span class="koboSpan" id="kobo.277.1">&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.278.1">This sets the action of the expense edit form to the updated route module path. </span><span class="koboSpan" id="kobo.278.2">Alternatively, we could omit the action path here. </span><span class="koboSpan" id="kobo.278.3">Remix ensures that, by default, every route module submits to its own </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">action</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.280.1"> function.</span></span></p></li> <li><span class="koboSpan" id="kobo.281.1">Next, create a new splat route module </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">dashboard.expenses.$id.attachments.$.tsx</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.285.1">Splats are wildcard route parameters that match the rest of the URL path starting from its location. </span><span class="koboSpan" id="kobo.285.2">Regardless of what subpath follows </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">/dashboard/expenses/$id/attachments/</span></strong><span class="koboSpan" id="kobo.287.1">, the splat parameter matches and stores the subpath </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">params['*']</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.291.1">For instance, if a user visits the </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">/dashboard/expenses/$id/attachments/bees/cool-bees.png</span></strong><span class="koboSpan" id="kobo.293.1"> URL path, then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">params['*']</span></strong><span class="koboSpan" id="kobo.295.1"> splat parameter contains the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">bees/cool-bees.png</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.297.1"> string.</span></span></p></li>
<li><span class="koboSpan" id="kobo.298.1">Add the</span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.299.1"> following code to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">dashboard.expenses.$id.attachments.$.tsx</span></strong><span class="koboSpan" id="kobo.301.1"> splat </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">route module:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.303.1">
import type { LoaderFunctionArgs } from '@remix-run/node';export async function loader({ request, params }: LoaderFunctionArgs) {  const { id } = params;  </span><strong class="bold"><span class="koboSpan" id="kobo.304.1">const slug = params['*'];</span></strong><span class="koboSpan" id="kobo.305.1">  if (!id || !slug) throw Error('id and slug route parameters must be defined');  console.log({ id, slug });  return new Response('Coming soon!');}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.306.1">For now, we read the splat route and expense identifier parameters. </span><span class="koboSpan" id="kobo.306.2">Then, we log the route parameters to the terminal and return a </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">text response.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.308.1">We will </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.309.1">update this code later in this chapter once we’ve taken care of persisting attachments on </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">the server.</span></span></p></li> <li><span class="koboSpan" id="kobo.311.1">Now, run the app locally (</span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">npm run dev</span></strong><span class="koboSpan" id="kobo.313.1">) and open the application in a new </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">browser window.</span></span></li>
<li><span class="koboSpan" id="kobo.315.1">Sign or log in to BeeRich and create a </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">new expense.</span></span></li>
<li><span class="koboSpan" id="kobo.317.1">Navigate to an expense details page by clicking on an expense in the expense overview list on </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">the dashboard.</span></span></li>
<li><span class="koboSpan" id="kobo.319.1">Append the: </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">/attachments/bees/cool-bees.png</span></strong><span class="koboSpan" id="kobo.321.1"> path to the URL in the </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">browser window.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.323.1">You should see the </span><strong class="bold"><span class="koboSpan" id="kobo.324.1">Coming soon</span></strong><span class="koboSpan" id="kobo.325.1"> text in your browser window. </span><span class="koboSpan" id="kobo.325.2">Resource routes allow</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.326.1"> us to return any kind of response from </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">loader</span></strong><span class="koboSpan" id="kobo.328.1"> functions, not just data for our </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">route components.</span></span></p></li>
<li><span class="koboSpan" id="kobo.330.1">Investigate the terminal and review the output of </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">console.log({ id, slug })</span></strong><span class="koboSpan" id="kobo.332.1">. </span><span class="koboSpan" id="kobo.332.2">Change the URL in the browser window to see how the </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">output changes.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.334.1">Great! </span><span class="koboSpan" id="kobo.334.2">We created </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.335.1">the required route module structure for our file upload functionality. </span><span class="koboSpan" id="kobo.335.2">As always, make sure to update the income route files to practice what you’ve learned in this section. </span><span class="koboSpan" id="kobo.335.3">Run the application locally to debug </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">your implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.337.1">In this section, you learned how to set the encoding type on an HTML form element and add file input fields. </span><span class="koboSpan" id="kobo.337.2">You further practiced working with splat route modules and resource routes. </span><span class="koboSpan" id="kobo.337.3">Next, we will utilize Remix’s file upload helper functions on the server to write the incoming files to </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">the filesystem.</span></span></p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.339.1">Processing files on the server</span></h1>
<p><span class="koboSpan" id="kobo.340.1">There are</span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.341.1"> several important considerations when handling file uploads on the server, most importantly the file size. </span><span class="koboSpan" id="kobo.341.2">In this section, we will learn how to process files in Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">action</span></strong><span class="koboSpan" id="kobo.343.1"> functions. </span><span class="koboSpan" id="kobo.343.2">We will start with a naïve implementation before refactoring the code and taking more concerns </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">into account.</span></span></p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.345.1">Loading files into memory</span></h2>
<p><span class="koboSpan" id="kobo.346.1">Let’s get </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.347.1">started by implementing some utilities for working </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">with files:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.349.1">Create a new </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">app/modules/attachments.server.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.351.1"> file.</span></span></li>
<li><span class="koboSpan" id="kobo.352.1">Add the following code </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">attachments.server.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.356.1">
import fs from 'fs';import path from 'path';export async function writeFile(file: File) {  const localPath = path.join(process.cwd(), 'public', file.name);  const arrayBufferView = new Uint8Array(await file.arrayBuffer());  fs.writeFileSync(localPath, arrayBufferView);}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.357.1">The added </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">writeFile</span></strong><span class="koboSpan" id="kobo.359.1"> function accepts a file and writes it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">public</span></strong><span class="koboSpan" id="kobo.361.1"> folder. </span><span class="koboSpan" id="kobo.361.2">Note that this is not our end solution but an </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">intermediate step.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.363.1">The </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.364.1">way we access the filesystem depends on the underlying server runtime. </span><span class="koboSpan" id="kobo.364.2">BeeRich runs on a Node.js runtime. </span><span class="koboSpan" id="kobo.364.3">Hence, in BeeRich, we use Node.js libraries to write to </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">the filesystem.</span></span></p></li> <li><span class="koboSpan" id="kobo.366.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">dashboard.expenses._index.tsx</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.368.1">route module.</span></span></li>
<li><span class="koboSpan" id="kobo.369.1">Update the route module’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">action</span></strong><span class="koboSpan" id="kobo.371.1"> function, </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">as follows:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.373.1">import { writeFile } from '~/modules/attachments.server';</span></strong><span class="koboSpan" id="kobo.374.1">export async function action({ request }: ActionFunctionArgs) {  const userId = await requireUserId(request);  const formData = await request.formData();</span><strong class="bold"><span class="koboSpan" id="kobo.375.1">  const file = formData.get('attachment');</span></strong><strong class="bold"><span class="koboSpan" id="kobo.376.1">  if (file &amp;&amp; file instanceof File) {</span></strong><strong class="bold"><span class="koboSpan" id="kobo.377.1">    writeFile(file);</span></strong><strong class="bold"><span class="koboSpan" id="kobo.378.1">  }</span></strong><span class="koboSpan" id="kobo.379.1">  …}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.380.1">We access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">attachment</span></strong><span class="koboSpan" id="kobo.382.1"> form data entry, check whether it is a file, and then pass it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">writeFile</span></strong><span class="koboSpan" id="kobo.384.1"> function. </span><span class="koboSpan" id="kobo.384.2">Currently, </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">writeFile</span></strong><span class="koboSpan" id="kobo.386.1"> writes the uploaded file to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">public</span></strong><span class="koboSpan" id="kobo.388.1"> folder for easy </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">public access.</span></span></p></li> <li><span class="koboSpan" id="kobo.390.1">Run BeeRich locally to test the </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">current implementation.</span></span></li>
<li><span class="koboSpan" id="kobo.392.1">Fill out the expense creation form, attach a file, and </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">click </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.394.1">Create</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.396.1">You should see the selected file pop up in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">public</span></strong><span class="koboSpan" id="kobo.398.1"> folder in your editor. </span><span class="koboSpan" id="kobo.398.2">Just like that, we can upload a file to the server and write it to </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">the filesystem.</span></span></p></li>
<li><span class="koboSpan" id="kobo.400.1">You </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.401.1">can now access the file by navigating to </span><a href="http://localhost:3000/$file-name"><span class="koboSpan" id="kobo.402.1">http://localhost:3000/$file-name</span></a><span class="koboSpan" id="kobo.403.1">. </span><span class="koboSpan" id="kobo.403.2">Note that you must also add the file extension to </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">the path.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.405.1">Theoretically, we could now read the filename on the server and save it to the expense object in the database. </span><span class="koboSpan" id="kobo.405.2">Since all files in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">public</span></strong><span class="koboSpan" id="kobo.407.1"> folder are already accessible over the web, we could let users access their files by linking </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">/$filename</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">Unfortunately, there are some limitations to the current </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">naïve implementation:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.413.1">Filename collisions</span></span></li>
<li><span class="koboSpan" id="kobo.414.1">File </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">size limitations</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.416.1">Privacy concerns</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.417.1">With the current implementation, we do not manage filenames to avoid collisions. </span><span class="koboSpan" id="kobo.417.2">What if two users upload a file with the same name? </span><span class="koboSpan" id="kobo.417.3">We also don’t handle file size limitations. </span><span class="koboSpan" id="kobo.417.4">Large files can easily eat up the runtime memory on a server. </span><span class="koboSpan" id="kobo.417.5">Hence, it is important that we either limit the file size a user can upload or better implement the file upload handler in a way that it processes the incoming file as a stream of data where the file is handled in chunks rather than trying to load the whole file into memory </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">at once.</span></span></p>
<p><span class="koboSpan" id="kobo.419.1">Further, by storing files in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">public</span></strong><span class="koboSpan" id="kobo.421.1"> folder, we make the files publicly accessible. </span><span class="koboSpan" id="kobo.421.2">Anyone can try to guess filenames until they are lucky and able to access a file of another user – this is a huge security concern, especially when we are talking about sensitive data such </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.422.1">as invoices </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">and expenses.</span></span></p>
<p><span class="koboSpan" id="kobo.424.1">Luckily, we can solve all these problems by taking advantage of Remix’s primitives and conventions. </span><span class="koboSpan" id="kobo.424.2">Let’s solve the first two concerns first using Remix’s upload handler </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">helper functions.</span></span></p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.426.1">Using Remix’s upload handler helper functions</span></h2>
<p><span class="koboSpan" id="kobo.427.1">Remix offers </span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.428.1">a set of helper functions to</span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.429.1"> manage file uploads. </span><span class="koboSpan" id="kobo.429.2">We will use the following ones to improve the current </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">naïve implementation:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">unstable_composeUploadHandlers</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">unstable_createFileUploadHandler</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">unstable_createMemoryUploadHandler</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">unstable_parseMultipartFormData</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.435.1">Note that the functions currently include an </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">unstable_</span></strong><span class="koboSpan" id="kobo.437.1"> prefix. </span><span class="koboSpan" id="kobo.437.2">This means their implementation may be up to change in </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">future releases.</span></span></p>
<p><span class="koboSpan" id="kobo.439.1">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">get started:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.441.1">First, create a new folder in the project’s root called </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">attachments</span></strong><span class="koboSpan" id="kobo.443.1">. </span><span class="koboSpan" id="kobo.443.2">This is where we will store all attached files on </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">the server.</span></span></li>
<li><span class="koboSpan" id="kobo.445.1">Next, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">app/modules/attachments.server.ts</span></strong><span class="koboSpan" id="kobo.447.1"> file in </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">your editor.</span></span></li>
<li><span class="koboSpan" id="kobo.449.1">Remove the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">writeFile</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.451.1"> function.</span></span></li>
<li><span class="koboSpan" id="kobo.452.1">Instead, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">unstable_createFileUploadHandler</span></strong><span class="koboSpan" id="kobo.454.1"> function to create a new file </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">upload handler:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.456.1">
import type { UploadHandler } from '@remix-run/node';import {  unstable_composeUploadHandlers,  unstable_createFileUploadHandler,  unstable_createMemoryUploadHandler,} from '@remix-run/node';const standardFileUploadHandler = unstable_createFileUploadHandler({  directory: './attachments',  avoidFileConflicts: true,});</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.457.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">unstable_createFileUploadHandler</span></strong><span class="koboSpan" id="kobo.459.1"> function takes a configuration </span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.460.1">object to specify where to store the uploaded files. </span><span class="koboSpan" id="kobo.460.2">It also lets us set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">avoidFileConflicts</span></strong><span class="koboSpan" id="kobo.462.1"> flag to create </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">unique filenames.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.464.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">standardFileUploadHandler</span></strong><span class="koboSpan" id="kobo.466.1"> function is responsible for writing the uploaded</span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.467.1"> files to the filesystem. </span><span class="koboSpan" id="kobo.467.2">Refer to the Remix documentation for more information about the available configuration </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">options: </span></span><a href="https://remix.run/docs/en/2.0.0/utils/unstable-create-file-upload-handler"><span class="No-Break"><span class="koboSpan" id="kobo.469.1">https://remix.run/docs/en/2.0.0/utils/unstable-create-file-upload-handler</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.470.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.471.1">Next, create a custom file upload </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">handler function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.473.1">
const attachmentsUploadHandler: UploadHandler = async (args) =&gt; {  if (args.name !== 'attachment' || !args.filename) return null;  </span><strong class="bold"><span class="koboSpan" id="kobo.474.1">const file = await standardFileUploadHandler(args);</span></strong><span class="koboSpan" id="kobo.475.1">  if (!file) return null;  if (typeof file === 'string') return file;  </span><strong class="bold"><span class="koboSpan" id="kobo.476.1">return file.name;</span></strong><span class="koboSpan" id="kobo.477.1">};</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.478.1">We wrap </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">standardFileUploadHandler</span></strong><span class="koboSpan" id="kobo.480.1"> to add a bit of helper logic. </span><span class="koboSpan" id="kobo.480.2">First, we ensure that we only process file attachments with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">attachment</span></strong><span class="koboSpan" id="kobo.482.1"> input name. </span><span class="koboSpan" id="kobo.482.2">Then, we make sure to return the filename or </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">null</span></strong><span class="koboSpan" id="kobo.484.1"> if no file </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">was attached.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.486.1">Notice</span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.487.1"> that </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">attachmentsUploadHandler</span></strong><span class="koboSpan" id="kobo.489.1"> implements Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">UploadHandler</span></strong><span class="koboSpan" id="kobo.491.1"> type. </span><span class="koboSpan" id="kobo.491.2">This</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.492.1"> allows us to compose it together with Remix’s file </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">helper functions.</span></span></p></li> <li><span class="koboSpan" id="kobo.494.1">Use Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">unstable_composeUploadHandlers</span></strong><span class="koboSpan" id="kobo.496.1"> function to compose our </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">attachmentsUploadHandler</span></strong><span class="koboSpan" id="kobo.498.1"> helper function and </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">Remix’s </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">unstable_createMemoryUploadHandler</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.502.1">
export const uploadHandler = unstable_composeUploadHandlers(  attachmentsUploadHandler,  unstable_createMemoryUploadHandler(),);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.503.1">With that, we’ve created a higher-level </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">uploadHandler</span></strong><span class="koboSpan" id="kobo.505.1"> helper function composed of two </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">upload handlers.</span></span></p><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">uploadHandler</span></strong><span class="koboSpan" id="kobo.508.1"> calls the two handlers for each form data entry. </span><span class="koboSpan" id="kobo.508.2">First, we attempt to handle the form data entry with </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">attachmentsUploadHandler</span></strong><span class="koboSpan" id="kobo.510.1">. </span><span class="koboSpan" id="kobo.510.2">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">attachmentsUploadHandler</span></strong><span class="koboSpan" id="kobo.512.1"> returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">null</span></strong><span class="koboSpan" id="kobo.514.1">, then we also attempt to handle the form data entry </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">unstable_createMemoryUploadHandler</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.518.1">As its name suggests, Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">unstable_createMemoryUploadHandler</span></strong><span class="koboSpan" id="kobo.520.1"> will handle all other form data fields and upload them to server memory so that we can access it, as usual, using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">FormData</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.522.1"> interface.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.523.1">Great work! </span><span class="koboSpan" id="kobo.523.2">Let’s update our </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">action</span></strong><span class="koboSpan" id="kobo.525.1"> functions so that they utilize the new </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">upload handler:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.527.1">Open</span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.528.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">dashboard.expenses._index.tsx</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.530.1">route module.</span></span></li>
<li><span class="koboSpan" id="kobo.531.1">Remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">writeFile</span></strong><span class="koboSpan" id="kobo.533.1"> import and naïve implementation in the route module’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">action</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.535.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.536.1">
const file = formData.get('attachment');if (file &amp;&amp; file instanceof File) {  writeFile(file);}</span></pre></li> <li><span class="koboSpan" id="kobo.537.1">Import </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">unstable_parseMultipartFormData</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.539.1">from Remix:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.540.1">
import { redirect, </span><strong class="bold"><span class="koboSpan" id="kobo.541.1">unstable_parseMultipartFormData</span></strong><span class="koboSpan" id="kobo.542.1"> } from '@remix-run/node';</span></pre></li> <li><span class="koboSpan" id="kobo.543.1">Import </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">uploadHandler</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.545.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">app/modules/attachments.server.tsx</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.548.1">
import { </span><strong class="bold"><span class="koboSpan" id="kobo.549.1">uploadHandler</span></strong><span class="koboSpan" id="kobo.550.1"> } from '~/modules/attachments.server';</span></pre></li> <li><span class="koboSpan" id="kobo.551.1">Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">parseMultipartFormData</span></strong><span class="koboSpan" id="kobo.553.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">replace </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">request.formData()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.557.1">
const formData = await unstable_parseMultipartFormData(request, uploadHandler);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.558.1">Here, we</span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.559.1"> let </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">unstable_parseMultipartFormData</span></strong><span class="koboSpan" id="kobo.561.1"> handle the multipart form data using our custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">uploadHandler</span></strong><span class="koboSpan" id="kobo.563.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">unstable_parseMultipartFormData</span></strong><span class="koboSpan" id="kobo.565.1"> calls our higher-order upload handler for every form data entry. </span><span class="koboSpan" id="kobo.565.2">The composed upload handler loops through our upload handlers until one of them returns neither </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">null</span></strong><span class="koboSpan" id="kobo.567.1"> nor </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">undefined</span></strong><span class="koboSpan" id="kobo.569.1">. </span><span class="koboSpan" id="kobo.569.2">The attachment form data entry is processed by the file upload handler, returning the file name of the uploaded file, or null if no file has been submitted. </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">unstable_createMemoryUploadHandler</span></strong><span class="koboSpan" id="kobo.571.1"> handles all other form data </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">for us.</span></span></p></li> <li><span class="koboSpan" id="kobo.573.1">Next, add the code </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.574.1">to read the attachment form data and update the </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">database query:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.576.1">
export async function action({ request }: ActionFunctionArgs) {  const userId = await requireUserId(request);  </span><strong class="bold"><span class="koboSpan" id="kobo.577.1">const formData = await unstable_parseMultipartFormData(request, uploadHandler);</span></strong><span class="koboSpan" id="kobo.578.1">  const title = formData.get('title');  const description = formData.get('description');  const amount = formData.get('amount');  if (typeof title !== 'string' || typeof description !== 'string' || typeof amount !== 'string') {    throw Error('something went wrong');  }  const amountNumber = Number.parseFloat(amount);  if (Number.isNaN(amountNumber)) {    throw Error('something went wrong');  }  </span><strong class="bold"><span class="koboSpan" id="kobo.579.1">let attachment = formData.get('attachment');</span></strong><span class="koboSpan" id="kobo.580.1">  </span><strong class="bold"><span class="koboSpan" id="kobo.581.1">if (!attachment || typeof attachment !== 'string') {</span></strong><span class="koboSpan" id="kobo.582.1">    </span><strong class="bold"><span class="koboSpan" id="kobo.583.1">attachment = null;</span></strong><span class="koboSpan" id="kobo.584.1">  </span><strong class="bold"><span class="koboSpan" id="kobo.585.1">}</span></strong><span class="koboSpan" id="kobo.586.1">  const expense = await db.expense.create({    data: {      title,      description,      amount: amountNumber,      currencyCode: 'USD',      </span><strong class="bold"><span class="koboSpan" id="kobo.587.1">attachment,</span></strong><span class="koboSpan" id="kobo.588.1">      user: {        connect: {          id: userId,        },      },    },  });  return redirect(`/dashboard/expenses/${expense.id}`);}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.589.1">We </span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.590.1">now use a custom upload </span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.591.1">handler to write the incoming stream of file data chunks to the filesystem and persist the associated filename in </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">the database.</span></span></p></li> <li><span class="koboSpan" id="kobo.593.1">Run BeeRich locally and test uploading a file with the expense </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">creation form.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.595.1">You should be able to see the attached files in the new </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">attachments</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.597.1"> folder.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.598.1">Note that the file upload will fail if the file size exceeds 30 MB. </span><span class="koboSpan" id="kobo.598.2">This is Remix’s default maximum file size. </span><span class="koboSpan" id="kobo.598.3">The file size can be increased by updating the configuration options that are passed </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">unstable_createFileUploadHandler</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">.</span></span></p></li>
</ol>
<p><span class="koboSpan" id="kobo.602.1">Congratulations! </span><span class="koboSpan" id="kobo.602.2">You successfully added a file upload to the expense creation form. </span><span class="koboSpan" id="kobo.602.3">Make sure you apply the same changes to the income routes before moving on to the next section. </span><span class="koboSpan" id="kobo.602.4">Reuse the helper functions in </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">attachments.server.ts</span></strong><span class="koboSpan" id="kobo.604.1"> to update the invoice creation </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">action</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.606.1"> function.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.607.1">Preventing server memory overflows</span></p>
<p class="callout"><span class="koboSpan" id="kobo.608.1">When working with file uploads, we must keep memory limitations in mind. </span><span class="koboSpan" id="kobo.608.2">Large file sizes can easily overwhelm our servers. </span><span class="koboSpan" id="kobo.608.3">This is why it’s important to handle incoming files in chunks instead of loading them fully into memory. </span><span class="koboSpan" id="kobo.608.4">Remix’s file upload helpers help us avoid filenaming collisions and let us stream file data to avoid server </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">memory overflows.</span></span></p>
<p><span class="koboSpan" id="kobo.610.1">Next, we will </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.611.1">update the expense edit form so </span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.612.1">that it can also handle </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">file uploads:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.614.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">dashboard.expenses.$id._index.tsx</span></strong><span class="koboSpan" id="kobo.616.1"> file in </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">your editor.</span></span></li>
<li><span class="koboSpan" id="kobo.618.1">Again, import </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">unstable_parseMultipartFormData</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.620.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">uploadHandler</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.623.1">
import { json, redirect, </span><strong class="bold"><span class="koboSpan" id="kobo.624.1">unstable_parseMultipartFormData</span></strong><span class="koboSpan" id="kobo.625.1"> } from '@remix-run/node';import { </span><strong class="bold"><span class="koboSpan" id="kobo.626.1">uploadHandler</span></strong><span class="koboSpan" id="kobo.627.1"> } from '~/modules/attachments.server';</span></pre></li> <li><span class="koboSpan" id="kobo.628.1">Next, update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">action</span></strong><span class="koboSpan" id="kobo.630.1"> function with the </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.632.1">
export async function action({ params, request }: ActionFunctionArgs) {  const userId = await requireUserId(request);  const { id } = params;  if (!id) throw Error('id route parameter must be defined');</span><strong class="bold"><span class="koboSpan" id="kobo.633.1">  let formData: FormData;</span></strong><strong class="bold"><span class="koboSpan" id="kobo.634.1">  const contentType = request.headers.get('content-type');</span></strong><strong class="bold"><span class="koboSpan" id="kobo.635.1">  if (contentType?.toLowerCase().includes('multipart/form-data')) {</span></strong><strong class="bold"><span class="koboSpan" id="kobo.636.1">    formData = await unstable_parseMultipartFormData(request, uploadHandler);</span></strong><strong class="bold"><span class="koboSpan" id="kobo.637.1">  } else {</span></strong><strong class="bold"><span class="koboSpan" id="kobo.638.1">    formData = await request.formData();</span></strong><strong class="bold"><span class="koboSpan" id="kobo.639.1">  }</span></strong><span class="koboSpan" id="kobo.640.1">  const intent = formData.get('intent');  if (intent === 'delete') {    return deleteExpense(request, id, userId);  }  if (intent === 'update') {    return updateExpense(formData, id, userId);  }  throw new Response('Bad request', { status: 400 });}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.641.1">Notice </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.642.1">that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">action</span></strong><span class="koboSpan" id="kobo.644.1"> function </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.645.1">distinguishes between </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">delete</span></strong><span class="koboSpan" id="kobo.647.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">update</span></strong><span class="koboSpan" id="kobo.649.1"> form submissions. </span><span class="koboSpan" id="kobo.649.2">The delete form submission originates from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">ListLinkItem</span></strong><span class="koboSpan" id="kobo.651.1"> component, while the update submission originates from the expense edit form in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">dashboard.expenses.$id._index.tsx</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.653.1">route module.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.654.1">Earlier in the chapter, we updated the expense edit form encoding to multi-part encoding, but we did not do the same to the expense deletion form. </span><span class="koboSpan" id="kobo.654.2">Hence, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">action</span></strong><span class="koboSpan" id="kobo.656.1"> function must be able to support both multipart and URL-encoded form data. </span><span class="koboSpan" id="kobo.656.2">For this, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">content-type</span></strong><span class="koboSpan" id="kobo.658.1"> header to distinguish which form encoding has been used and only use </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">parseMultipartFormData</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.660.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">multipart/form-data</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.663.1">Next, update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">updateExpense</span></strong><span class="koboSpan" id="kobo.665.1"> function so that it reads the </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">attachment</span></strong><span class="koboSpan" id="kobo.667.1"> form data</span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.668.1"> entry and adds the value to the database </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">update query:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.670.1">let attachment: FormDataEntryValue | null | undefined = formData.get('attachment');</span></strong><strong class="bold"><span class="koboSpan" id="kobo.671.1">if (!attachment || typeof attachment !== 'string') {</span></strong><strong class="bold"><span class="koboSpan" id="kobo.672.1">  attachment = undefined;</span></strong><strong class="bold"><span class="koboSpan" id="kobo.673.1">}</span></strong><span class="koboSpan" id="kobo.674.1">await db.expense.update({  where: { id_userId: { id, userId } },  data: { title, description, amount: amountNumber, </span><strong class="bold"><span class="koboSpan" id="kobo.675.1">attachment</span></strong><span class="koboSpan" id="kobo.676.1"> },});</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.677.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">updateExpense</span></strong><span class="koboSpan" id="kobo.679.1"> function is called when the edit expense form is submitted. </span><span class="koboSpan" id="kobo.679.2">Here, we want to ensure that newly uploaded attachments are added</span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.680.1"> to the expense </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">update query.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.682.1">Note that we already persisted the file to the filesystem when calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">unstable_parseMultipartFormData(request, uploadHandler)</span></strong><span class="koboSpan" id="kobo.684.1">. </span><span class="koboSpan" id="kobo.684.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">updateExpense</span></strong><span class="koboSpan" id="kobo.686.1"> function ensures that the expense entry in the database is </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">updated accordingly.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.688.1">We must also make sure we clean up the filesystem whenever an attachment is removed or the associated expense </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">is del</span><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.690.1">eted.</span></span></p></li> <li><span class="koboSpan" id="kobo.691.1">Add the following function to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">attachments.server.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.693.1"> file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.694.1">
import fs from 'fs';import path from 'path';export function deleteAttachment(fileName: string) {  const localPath = path.join(process.cwd(), 'attachments', fileName);  try {    fs.unlinkSync(localPath);  } catch (error) {    console.error(error);  }}</span></pre><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">deleteAttachment</span></strong><span class="koboSpan" id="kobo.696.1"> receives a </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">fileName</span></strong><span class="koboSpan" id="kobo.698.1"> and deletes the associated file from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">attachments</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.700.1"> folder.</span></span></p></li> <li><span class="koboSpan" id="kobo.701.1">Import </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">deleteAttachment</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.703.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">dashboard.expenses.$id._index.tsx</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.706.1">
import { </span><strong class="bold"><span class="koboSpan" id="kobo.707.1">deleteAttachment</span></strong><span class="koboSpan" id="kobo.708.1">, uploadHandler } from '~/modules/attachments.server';</span></pre></li> <li><span class="koboSpan" id="kobo.709.1">Next, implement </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.710.1">a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">removeAttachment</span></strong><span class="koboSpan" id="kobo.712.1"> function, which </span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.713.1">we will call in the route module’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">action</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.715.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.716.1">
async function removeAttachment(formData: FormData, id: string, userId: string): Promise&lt;Response&gt; {  const attachmentUrl = </span><strong class="bold"><span class="koboSpan" id="kobo.717.1">formData.get('attachmentUrl');</span></strong><span class="koboSpan" id="kobo.718.1">  if (!attachmentUrl || typeof attachmentUrl !== 'string') {    throw Error('something went wrong');  }  const fileName = attachmentUrl.split('/').pop();  if (!fileName) throw Error('something went wrong');  await db.expense.update({    where: { id_userId: { id, userId } },    </span><strong class="bold"><span class="koboSpan" id="kobo.719.1">data: { attachment: null },</span></strong><span class="koboSpan" id="kobo.720.1">  });  </span><strong class="bold"><span class="koboSpan" id="kobo.721.1">deleteAttachment(fileName);</span></strong><span class="koboSpan" id="kobo.722.1">  return json({ success: true });}</span></pre><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">removeAttachment</span></strong><span class="koboSpan" id="kobo.724.1"> is called within the route module’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">action</span></strong><span class="koboSpan" id="kobo.726.1"> function when</span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.727.1"> the submit button carries the </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">remove-attachment</span></strong><span class="koboSpan" id="kobo.729.1"> value, which is implemented in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">Attachment</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.731.1"> component.</span></span></p></li> <li><span class="koboSpan" id="kobo.732.1">Update the</span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.733.1"> route module’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">action</span></strong><span class="koboSpan" id="kobo.735.1"> function so that it handles the </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">remove-attachment</span></strong><span class="koboSpan" id="kobo.737.1"> form’s </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">action intent:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.739.1">
const intent = formData.get('intent');if (intent === 'delete') {  return deleteExpense(request, id, userId);}if (intent === 'update') {  return updateExpense(formData, id, userId);}</span><strong class="bold"><span class="koboSpan" id="kobo.740.1">if (intent === 'remove-attachment') {</span></strong><strong class="bold"><span class="koboSpan" id="kobo.741.1">  return removeAttachment(formData, id, userId);</span></strong><strong class="bold"><span class="koboSpan" id="kobo.742.1">}</span></strong><span class="koboSpan" id="kobo.743.1">throw new Response('Bad request', { status: 400 });</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.744.1">If you aren’t sure where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">remove-attachment</span></strong><span class="koboSpan" id="kobo.746.1"> value originates from, investigate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">Attachment</span></strong><span class="koboSpan" id="kobo.748.1"> component in </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">app/components/forms.tsx</span></strong><span class="koboSpan" id="kobo.750.1">. </span><span class="koboSpan" id="kobo.750.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">Attachment</span></strong><span class="koboSpan" id="kobo.752.1"> component contains a hidden input field for </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">attachmentUrl</span></strong><span class="koboSpan" id="kobo.754.1"> and a submit button with a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">remove-attachment</span></strong><span class="koboSpan" id="kobo.756.1">. </span><span class="koboSpan" id="kobo.756.2">The component is nested in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">dashboard.expenses.$id._index.tsx</span></strong><span class="koboSpan" id="kobo.758.1"> route module’s form and submits to the same </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">action</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.760.1"> function.</span></span></p></li> <li><span class="koboSpan" id="kobo.761.1">Finally, update </span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.762.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">deleteExpense</span></strong><span class="koboSpan" id="kobo.764.1"> function in the same file to remove the attachment when an expense </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">is deleted:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.766.1">const expense = </span></strong><span class="koboSpan" id="kobo.767.1">await db.expense.delete({ where: { id_userId: { id, userId } } });</span><strong class="bold"><span class="koboSpan" id="kobo.768.1">if (expense.attachment) {</span></strong><strong class="bold"><span class="koboSpan" id="kobo.769.1">  deleteAttachment(expense.attachment);</span></strong><strong class="bold"><span class="koboSpan" id="kobo.770.1">}</span></strong></pre></li> <li><span class="koboSpan" id="kobo.771.1">Now that </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.772.1">you’ve done all the hard work, run </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">npm run dev</span></strong><span class="koboSpan" id="kobo.774.1"> and open a browser window to test </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">the implementation.</span></span></li>
<li><span class="koboSpan" id="kobo.776.1">Create an expense with an attachment. </span><span class="koboSpan" id="kobo.776.2">Check the </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">attachments</span></strong><span class="koboSpan" id="kobo.778.1"> folder in </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">your editor.</span></span></li>
<li><span class="koboSpan" id="kobo.780.1">Remove the attachment by clicking the </span><strong class="bold"><span class="koboSpan" id="kobo.781.1">X</span></strong><span class="koboSpan" id="kobo.782.1"> button next to the </span><strong class="bold"><span class="koboSpan" id="kobo.783.1">Current Attachment</span></strong><span class="koboSpan" id="kobo.784.1"> link. </span><span class="koboSpan" id="kobo.784.2">Again, investigate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">attachments</span></strong><span class="koboSpan" id="kobo.786.1"> folder to see whether the file was </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">deleted successfully.</span></span></li>
<li><span class="koboSpan" id="kobo.788.1">Next, add a new attachment to the same expense using the edit form and investigate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">attachments</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.790.1">folder again.</span></span></li>
<li><span class="koboSpan" id="kobo.791.1">Finally, delete the expense by clicking the </span><strong class="bold"><span class="koboSpan" id="kobo.792.1">X</span></strong><span class="koboSpan" id="kobo.793.1">  button in the expense overview list and check whether the file </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">was deleted:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer044">
<span class="koboSpan" id="kobo.795.1"><img alt="Figure 10.2 – Screenshot of the updated expense edit form" src="image/Figure_10.02_B17399.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.796.1">Figure 10.2 – Screenshot of the updated expense edit form</span></p>
<p><span class="koboSpan" id="kobo.797.1">As </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.798.1">visible in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.799.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.800.1">.2</span></em><span class="koboSpan" id="kobo.801.1">, the expense edit </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.802.1">form should now correctly switch between the current attachment and the attachment input field if no attachment is set. </span><span class="koboSpan" id="kobo.802.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.803.1">X</span></strong><span class="koboSpan" id="kobo.804.1"> button next to the </span><strong class="bold"><span class="koboSpan" id="kobo.805.1">Current Attachment</span></strong><span class="koboSpan" id="kobo.806.1"> link should now remove the attachment from the expense database entry and delete the file from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">attachments</span></strong><span class="koboSpan" id="kobo.808.1"> folder. </span><span class="koboSpan" id="kobo.808.2">Deleting an expense should also remove the associated attached file from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">attachments</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.810.1"> folder.</span></span></p>
<p><span class="koboSpan" id="kobo.811.1">Before moving on, update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">income</span></strong><span class="koboSpan" id="kobo.813.1"> routes to practice what you have learned in this section. </span><span class="koboSpan" id="kobo.813.2">Once the </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">income</span></strong><span class="koboSpan" id="kobo.815.1"> routes have been updated, you can move on to the </span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">next section.</span></span></p>
<p><span class="koboSpan" id="kobo.817.1">In this section, you </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.818.1">learned how to work </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.819.1">with Remix’s file upload helper functions. </span><span class="koboSpan" id="kobo.819.2">You now understand the considerations that come into play when managing file uploads and how to use Remix’s utilities to avoid memory and filenaming collisions. </span><span class="koboSpan" id="kobo.819.3">Next, we will implement the splat route to give BeeRich users secure access to </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">their attachments.</span></span></p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.821.1">Authorizing access to assets with resource routes</span></h2>
<p><span class="koboSpan" id="kobo.822.1">In </span><a href="B17399_09.xhtml#_idTextAnchor137"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.823.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.824.1">, </span><em class="italic"><span class="koboSpan" id="kobo.825.1">Assets and Metadata Handling</span></em><span class="koboSpan" id="kobo.826.1">, you practiced exposing assets via resource</span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.827.1"> routes. </span><span class="koboSpan" id="kobo.827.2">We will now expand on that by dynamically creating a file download for the requested expense attachment. </span><span class="koboSpan" id="kobo.827.3">We</span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.828.1"> will implement the splat route responsible for exposing the attachments and ensure that only authorized users can access </span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">their files:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.830.1">First, let’s add one more helper function to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">attachments.server.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.832.1"> file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.833.1">
export function buildFileResponse(fileName: string): Response {  const localPath = path.join(process.cwd(), 'attachments', fileName);  try {    const file = fs.readFileSync(localPath);    return </span><strong class="bold"><span class="koboSpan" id="kobo.834.1">new Response(file, {</span></strong><strong class="bold"><span class="koboSpan" id="kobo.835.1">      headers: {</span></strong><strong class="bold"><span class="koboSpan" id="kobo.836.1">        'Content-Type': 'application/octet-stream',</span></strong><strong class="bold"><span class="koboSpan" id="kobo.837.1">        'Content-Disposition': `attachment;          filename="${fileName}"`,</span></strong><strong class="bold"><span class="koboSpan" id="kobo.838.1">      },</span></strong><strong class="bold"><span class="koboSpan" id="kobo.839.1">    });</span></strong><span class="koboSpan" id="kobo.840.1">  } catch (error) {    console.error(error);    return new Response('Not Found', { status: 404 });  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.841.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">buildFileResponse</span></strong><span class="koboSpan" id="kobo.843.1"> function takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">fileName</span></strong><span class="koboSpan" id="kobo.845.1"> string and attempts to stream the associated file into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">Response</span></strong><span class="koboSpan" id="kobo.847.1"> object. </span><span class="koboSpan" id="kobo.847.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">content-disposition</span></strong><span class="koboSpan" id="kobo.849.1"> header ensures that the response is treated as a </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">file download.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.851.1">Again, we </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.852.1">avoid loading the full file</span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.853.1"> into memory. </span><span class="koboSpan" id="kobo.853.2">Instead, we make sure to read the file into a buffer and manage it in chunks to avoid exceeding the server’s </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">memory capabilities.</span></span></p></li> <li><span class="koboSpan" id="kobo.855.1">Next, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">dashboard.expenses.$id.attachments.$.tsx</span></strong><span class="koboSpan" id="kobo.857.1"> splat route module and replace its content with the </span><span class="No-Break"><span class="koboSpan" id="kobo.858.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.859.1">
import type { LoaderFunctionArgs } from '@remix-run/node';import { redirect } from '@remix-run/router';import { </span><strong class="bold"><span class="koboSpan" id="kobo.860.1">buildFileResponse</span></strong><span class="koboSpan" id="kobo.861.1"> } from '~/modules/attachments.server';import { db } from '~/modules/db.server';import { requireUserId } from '~/modules/session/session.server';export async function loader({ request, params }: LoaderFunctionArgs) {  </span><strong class="bold"><span class="koboSpan" id="kobo.862.1">const userId = await requireUserId(request);</span></strong><span class="koboSpan" id="kobo.863.1">  const { id } = params;  const slug = params['*'];  if (!id || !slug) throw Error('id and slug route parameters must be defined');  const expense = await db.expense.findUnique({ where: { </span><strong class="bold"><span class="koboSpan" id="kobo.864.1">id_userId: { id, userId }</span></strong><span class="koboSpan" id="kobo.865.1"> } });  if (!expense || !expense.attachment) throw new Response('Not found', { status: 404 });  if (slug !== expense.attachment) return redirect(`/dashboard/expenses/${id}/attachments/${expense.attachment}`);  </span><strong class="bold"><span class="koboSpan" id="kobo.866.1">return buildFileResponse(expense.attachment);</span></strong><span class="koboSpan" id="kobo.867.1">}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.868.1">We </span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.869.1">secure the resource route by</span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.870.1"> requiring a user session. </span><span class="koboSpan" id="kobo.870.2">We further query the database by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">id</span></strong><span class="koboSpan" id="kobo.872.1"> parameter of the expense of the </span><span class="No-Break"><span class="koboSpan" id="kobo.873.1">requested attachment.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.874.1">Notice that we query by a combination of expense </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">id</span></strong><span class="koboSpan" id="kobo.876.1"> and user </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">id</span></strong><span class="koboSpan" id="kobo.878.1">. </span><span class="koboSpan" id="kobo.878.2">This ensures that a user can only access their </span><span class="No-Break"><span class="koboSpan" id="kobo.879.1">own expenses.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.880.1">We then do some sanity checks before returning the response created by our new </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">buildFileResponse</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.882.1">helper function.</span></span></p></li> <li><span class="koboSpan" id="kobo.883.1">It’s time to test the implementation. </span><span class="koboSpan" id="kobo.883.2">Try to download a current attachment. </span><span class="koboSpan" id="kobo.883.3">Clicking on the </span><strong class="bold"><span class="koboSpan" id="kobo.884.1">Current Attachment</span></strong><span class="koboSpan" id="kobo.885.1"> link should initiate a </span><span class="No-Break"><span class="koboSpan" id="kobo.886.1">file download.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.887.1">Great work! </span><span class="koboSpan" id="kobo.887.2">You implemented a full stack file upload feature in BeeRich that spans several different forms, routes, </span><span class="No-Break"><span class="koboSpan" id="kobo.888.1">and utilities.</span></span></p>
<p><span class="koboSpan" id="kobo.889.1">Before moving on, make sure you implement the income splat route. </span><span class="koboSpan" id="kobo.889.2">Repeating this work on the income routes will help you practice all the </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">new concepts.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.891.1">Restricting access to user files</span></p>
<p class="callout"><span class="koboSpan" id="kobo.892.1">It is important to remember that files in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">public</span></strong><span class="koboSpan" id="kobo.894.1"> folder are publicly accessible over the internet. </span><span class="koboSpan" id="kobo.894.2">We must ensure that private user data is protected by authorization code. </span><span class="koboSpan" id="kobo.894.3">In Remix, we can use resource routes to dynamically check access rights before granting access to </span><span class="No-Break"><span class="koboSpan" id="kobo.895.1">user files.</span></span></p>
<p><span class="koboSpan" id="kobo.896.1">In this </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.897.1">section, you </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.898.1">learned how to create dynamic responses and expose assets via resource routes. </span><span class="koboSpan" id="kobo.898.2">You now understand how to authorize users in resource routes to restrict access. </span><span class="koboSpan" id="kobo.898.3">Next, we will discuss forwarding files to </span><span class="No-Break"><span class="koboSpan" id="kobo.899.1">third-party services.</span></span></p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.900.1">Forwarding files to third-party services</span></h1>
<p><span class="koboSpan" id="kobo.901.1">So far, we </span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.902.1">are hosting our user files on the server’s filesystem. </span><span class="koboSpan" id="kobo.902.2">This is sufficient for the educative scope of BeeRich. </span><span class="koboSpan" id="kobo.902.3">However, when </span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.903.1">working with user files, we should also consider hosting them on a dedicated file storage service. </span><span class="koboSpan" id="kobo.903.2">This section quickly outlines what else we need to consider when working with </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">user files.</span></span></p>
<p><span class="koboSpan" id="kobo.905.1">Hosting user files directly on a web server may not be sufficient for most use cases. </span><span class="koboSpan" id="kobo.905.2">Hosting files locally may be hard to scale and requires you to secure sensitive user files and backups on your systems. </span><span class="koboSpan" id="kobo.905.3">Additionally, reading and writing to disk might create a lot of overhead for the web server that can be avoided by delegating the reads and writes to a </span><span class="No-Break"><span class="koboSpan" id="kobo.906.1">third-party service.</span></span></p>
<p><span class="koboSpan" id="kobo.907.1">Most popular third-party storage services offer APIs to stream files. </span><span class="koboSpan" id="kobo.907.2">This allows us to receive the file upload as a stream of data so that we can forward the stream to a third-party service. </span><span class="koboSpan" id="kobo.907.3">After the upload is completed, the storage API usually provides a URL to the uploaded file, which we can use in our database to link to the </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">new file.</span></span></p>
<p><span class="koboSpan" id="kobo.909.1">Remix’s upload handler primitives let you create custom handlers for different third-party services. </span><span class="koboSpan" id="kobo.909.2">Instead of writing to the local filesystem, we can create an upload handler that streams the data to a </span><span class="No-Break"><span class="koboSpan" id="kobo.910.1">cloud provider.</span></span></p>
<p><span class="koboSpan" id="kobo.911.1">Popular file hosting providers include AWS S3, Cloudflare, Cloudinary, Firebase, and Vercel. </span><span class="koboSpan" id="kobo.911.2">You can find an </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.912.1">example implementation</span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.913.1"> that uses Cloudinary in the </span><em class="italic"><span class="koboSpan" id="kobo.914.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.915.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.916.1"> section.</span></span></p>
<h1 id="_idParaDest-166"><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.917.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.918.1">In this chapter, you learned how to add files to HTML forms and how to handle file uploads </span><span class="No-Break"><span class="koboSpan" id="kobo.919.1">in Remix.</span></span></p>
<p><span class="koboSpan" id="kobo.920.1">HTML forms support different encoding types. </span><span class="koboSpan" id="kobo.920.2">Multipart form encoding adds the form data to the response body. </span><span class="koboSpan" id="kobo.920.3">This is required when appending binary data, such as files. </span><span class="koboSpan" id="kobo.920.4">On the server, we can then stream in the response body and handle the uploaded files </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">in chunks.</span></span></p>
<p><span class="koboSpan" id="kobo.922.1">By reading this chapter, you now understand that Remix provides a set of file upload utilities for handling file uploads. </span><span class="koboSpan" id="kobo.922.2">Remix utilities help us avoid filenaming collisions and allow us to configure file size limits and file streaming. </span><span class="koboSpan" id="kobo.922.3">We can further compose several file upload handlers together and implement custom wrappers by implementing the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">UploadHandler</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.924.1"> type.</span></span></p>
<p><span class="koboSpan" id="kobo.925.1">Next, you learned how to restrict access to a resource route by authenticating user sessions and ensuring authorized database queries that query for a unique combination of entity </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">id</span></strong><span class="koboSpan" id="kobo.927.1"> and user </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">id</span></strong><span class="koboSpan" id="kobo.929.1">. </span><span class="koboSpan" id="kobo.929.2">We must not place user files in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">public</span></strong><span class="koboSpan" id="kobo.931.1"> folder. </span><span class="koboSpan" id="kobo.931.2">Instead, we must leverage resource routes and custom </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">authorization logic.</span></span></p>
<p><span class="koboSpan" id="kobo.933.1">Finally, we discussed the usage of third-party file hosting services. </span><span class="koboSpan" id="kobo.933.2">You now understand that using a third-party service may be more scalable and allow us to offload much of the complexity of storing files to a </span><span class="No-Break"><span class="koboSpan" id="kobo.934.1">third-party service.</span></span></p>
<p><span class="koboSpan" id="kobo.935.1">Congratulations! </span><span class="koboSpan" id="kobo.935.2">Just like that, you made it through the second part of this book. </span><span class="koboSpan" id="kobo.935.3">In the next chapter, we’ll kick off the advanced topics of this book and learn more about optimistic UIs. </span><span class="koboSpan" id="kobo.935.4">Keep going to unlock the full potential of the web platform </span><span class="No-Break"><span class="koboSpan" id="kobo.936.1">with Remix.</span></span></p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.937.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.938.1">You can learn more about the HTML form element’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">enctype</span></strong><span class="koboSpan" id="kobo.940.1"> property via MDN Web </span><span class="No-Break"><span class="koboSpan" id="kobo.941.1">Docs: </span></span><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/enctype"><span class="No-Break"><span class="koboSpan" id="kobo.942.1">https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/enctype</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.943.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.944.1">You can find additional information about HTTP POST requests via MDN Web </span><span class="No-Break"><span class="koboSpan" id="kobo.945.1">Docs: </span></span><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST"><span class="No-Break"><span class="koboSpan" id="kobo.946.1">https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.947.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.948.1">Review this example implementation from Remix’s example repository for uploading files to </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">Cloudinary: </span></span><a href="https://github.com/remix-run/examples/tree/main/file-and-cloudinary-upload"><span class="No-Break"><span class="koboSpan" id="kobo.950.1">https://github.com/remix-run/examples/tree/main/file-and-cloudinary-upload</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.951.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.952.1">You can learn more about Remix’s file upload helpers by reading the </span><span class="No-Break"><span class="koboSpan" id="kobo.953.1">Remix documentation:</span></span></p>
<ul>
<li><a href="https://remix.run/docs/en/2.0.0/utils/parse-multipart-form-data"><span class="No-Break"><span class="koboSpan" id="kobo.954.1">https://remix.run/docs/en/2.0.0/utils/parse-multipart-form-data</span></span></a></li>
<li><a href="https://remix.run/docs/en/2.0.0/utils/unstable-create-file-upload-handler"><span class="No-Break"><span class="koboSpan" id="kobo.955.1">https://remix.run/docs/en/2.0.0/utils/unstable-create-file-upload-handler</span></span></a></li>
<li><a href="https://remix.run/docs/en/2.0.0/utils/unstable-create-memory-upload-handler"><span class="No-Break"><span class="koboSpan" id="kobo.956.1">https://remix.run/docs/en/2.0.0/utils/unstable-create-memory-upload-handler</span></span></a></li>
</ul>
</div>


<div class="Content" id="_idContainer046">
<h1 id="_idParaDest-168" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.1.1">Part 3 – Advanced Concepts of Full Stack Web Development with Remix</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this final part, you will practice advanced concepts of full stack web development, such as optimistic UI, caching strategies, HTML streaming, and real-time data updates. </span><span class="koboSpan" id="kobo.2.2">You will again iterate on BeeRich to practice the studied concepts. </span><span class="koboSpan" id="kobo.2.3">You will also dig deeper into session management and understand what it means to deploy to the edge. </span><span class="koboSpan" id="kobo.2.4">Finally, you will learn about migration strategies to Remix and learn how to keep a Remix application up </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">to date.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B17399_11.xhtml#_idTextAnchor167"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 11</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Optimistic UI</span></em></li>
<li><a href="B17399_12.xhtml#_idTextAnchor181"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 12</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Caching Strategies</span></em></li>
<li><a href="B17399_13.xhtml#_idTextAnchor194"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 13</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Deferring Loader Data</span></em></li>
<li><a href="B17399_14.xhtml#_idTextAnchor204"><em class="italic"><span class="koboSpan" id="kobo.15.1">Chapter 14</span></em></a><span class="koboSpan" id="kobo.16.1">, </span><em class="italic"><span class="koboSpan" id="kobo.17.1">Real-Time with Remix</span></em></li>
<li><a href="B17399_15.xhtml#_idTextAnchor214"><em class="italic"><span class="koboSpan" id="kobo.18.1">Chapter 15</span></em></a><em class="italic"><span class="koboSpan" id="kobo.19.1">,</span></em> <em class="italic"><span class="koboSpan" id="kobo.20.1">Advanced Session Management</span></em></li>
<li><a href="B17399_16.xhtml#_idTextAnchor221"><em class="italic"><span class="koboSpan" id="kobo.21.1">Chapter 16</span></em></a><span class="koboSpan" id="kobo.22.1">, </span><em class="italic"><span class="koboSpan" id="kobo.23.1">Developing for the Edge</span></em></li>
<li><a href="B17399_17.xhtml#_idTextAnchor230"><em class="italic"><span class="koboSpan" id="kobo.24.1">Chapter 17</span></em></a><span class="koboSpan" id="kobo.25.1">, </span><em class="italic"><span class="koboSpan" id="kobo.26.1">Migration and Upgrade Strategies</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer047">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer048">
</div>
</div>
</body></html>