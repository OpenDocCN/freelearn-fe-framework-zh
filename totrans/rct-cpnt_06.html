<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Changing Views"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Changing Views</h1></div></div></div><p>In the previous chapter, we covered a bit about material design, and as a result, we split the login and page admin sections into different files. We stopped short of making the login redirect us to the page admin section.</p><p>In this chapter, you will learn how to change sections without reloading the page. We'll use this knowledge to create public pages for the website our CMS is meant to control.</p><p>We'll see how to work with the browser's address bar and location history. We'll also learn how to use popular libraries to abstract these things for us, so we can save time on writing boilerplate and concentrate on making our interfaces great!</p><div class="section" title="Location, location, location!"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec37"/>Location, location, location!</h1></div></div></div><p>Before we can learn <a id="id137" class="indexterm"/>about alternatives to reloading pages, let's take a look at how the browser manages reloads.</p><p>You've probably encountered the <code class="literal">window</code> object. It's a global catch-all object for browser-based functionality and state. It's also the default <code class="literal">this</code> scope in any HTML page:</p><div class="mediaobject"><img src="graphics/5268_06_01.jpg" alt="Location, location, location!"/></div><p>We've even accessed <a id="id138" class="indexterm"/>
<code class="literal">window</code> earlier. When we rendered to <code class="literal">document.body</code> or used <code class="literal">document.querySelector</code>, these properties and methods were called on the <code class="literal">window</code> object. It's the same as calling <code class="literal">window.document.querySelector</code>.</p><p>Most of the time, <code class="literal">document</code> is the only property we need. That doesn't mean it's the only property useful to us. Try the following in the console:</p><div class="informalexample"><pre class="programlisting">console.log(window.location);</pre></div><p>You should see something similar to the following:</p><div class="informalexample"><pre class="programlisting">Location {
    hash: ""
    host: "127.0.0.1:3000"
    hostname: "127.0.0.1"
    href: "http://127.0.0.1:3000/examples/login.html"
    origin: "http://127.0.0.1:3000"
    pathname: "/examples/login.html"
    port: "3000"
    ...
}</pre></div><p>If we were trying to work out which components to show based on the browser URL, this would be an excellent place to start. Not only can we read from this object, but we can also write to it:</p><div class="informalexample"><pre class="programlisting">&lt;script&gt;
    window.location.href = "http://material-ui.com";
&lt;/script&gt;</pre></div><p>Putting this in an HTML page or entering that line of JavaScript in the console will redirect the browser to <a class="ulink" href="http://www.material-ui.com">www.material-ui.com</a>. It's the same as clicking on a link to that website. And, if it's redirected to a different page (than the one the browser is pointing at), then it will cause a full page reload.</p><div class="section" title="A bit of history"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec16"/>A bit of history</h2></div></div></div><p>So how does this<a id="id139" class="indexterm"/> help us? We're trying to avoid full page reloads, after all. Let's experiment with this object.</p><p>Let's see what happens when we add something like <code class="literal">#page-admin</code> to the URL.</p><div class="mediaobject"><img src="graphics/5268_06_02.jpg" alt="A bit of history"/></div><p>Adding <code class="literal">#page-admin</code> to the URL leads to the <code class="literal">window.location.hash</code> property being populated with the same. What's more, changing the hash value won't reload the page! It's the same as clicking on a link that had a hash in the <code class="literal">href</code> attribute. We can modify it without causing full <a id="id140" class="indexterm"/>page reloads, and each modification will store a new entry in the browser history.</p><p>Using this trick, we can step through a number of different states without reloading the page, and we will be able to backtrack each with the browser's back button.</p></div><div class="section" title="Using browser history"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec17"/>Using browser history</h2></div></div></div><p>Let's put this trick to <a id="id141" class="indexterm"/>use in our CMS. First, let's add a couple of functions to our <code class="literal">Nav</code> component:</p><div class="informalexample"><pre class="programlisting">export default (props) =&gt; {
    // ...define class names

<span class="strong"><strong>    var redirect = (event, section) =&gt; {</strong></span>
<span class="strong"><strong>        window.location.hash = `#${section}`;</strong></span>
<span class="strong"><strong>        event.preventDefault();</strong></span>
<span class="strong"><strong>    }</strong></span>

    return &lt;div className={drawerClassNames}&gt;
        &lt;header className="demo-drawer-header"&gt;
            &lt;img src="images/user.jpg"
                 className="demo-avatar" /&gt;
        &lt;/header&gt;
        &lt;nav className={navClassNames}&gt;
            &lt;a className="mdl-navigation__link"
               href="/examples/login.html"
               onClick={(e) =&gt; redirect(e, "login")}&gt;
                &lt;i className={buttonIconClassNames}
                   role="presentation"&gt;
                    lock
                &lt;/i&gt;
                Login
            &lt;/a&gt;
            &lt;a className="mdl-navigation__link"
               href="/examples/page-admin.html"
               onClick={(e) =&gt; redirect(e, "page-admin")}&gt;
                &lt;i className={buttonIconClassNames}
                   role="presentation"&gt;
                    pages
                &lt;/i&gt;
                Pages
            &lt;/a&gt;
        &lt;/nav&gt;
    &lt;/div&gt;;
};</pre></div><p>We add an <code class="literal">onClick</code> attribute to our navigation links. We created a special function that will change <code class="literal">window.location.hash</code> and prevent the default full page reload behavior the links would otherwise have caused.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>This is a neat use of the arrow functions, but we're ultimately creating three new functions in each render call. Remember that this can be expensive, so it's best to move the function creation out of render. We'll replace this shortly.</p></div></div><p>It's also interesting to<a id="id142" class="indexterm"/> see template strings in action. Instead of <code class="literal">"#" + section</code>, we can use <code class="literal">'#${section}'</code> to interpolate the section name. It's not as useful in small strings, but becomes increasingly useful in large ones.</p><p>Clicking on the navigation links will now change the URL hash. We can add to this behavior by rendering different components when the navigation links are clicked on:</p><div class="informalexample"><pre class="programlisting">import React from "react";
import ReactDOM from "react-dom";
import Component from "src/component";
import Login from "src/login";
import Backend from "src/backend";
import PageAdmin from "src/page-admin";

class Nav extends Component {
    render() {
        // ...define class names

        return &lt;div className={drawerClassNames}&gt;
            &lt;header className="demo-drawer-header"&gt;
                &lt;img src="images/user.jpg"
                     className="demo-avatar" /&gt;
            &lt;/header&gt;
            &lt;nav className={navClassNames}&gt;
                &lt;a className="mdl-navigation__link"
                   href="/examples/login.html"
                   onClick={(e) =&gt; this.redirect(e, "login")}&gt;
                    &lt;i className={buttonIconClassNames}
                       role="presentation"&gt;
                        lock
                    &lt;/i&gt;
                    Login
                &lt;/a&gt;
                &lt;a className="mdl-navigation__link"
                   href="/examples/page-admin.html"
                   onClick={(e) =&gt; this.redirect(e, "page-admin")}&gt;
                    &lt;i className={buttonIconClassNames}
                       role="presentation"&gt;
                        pages
                    &lt;/i&gt;
                    Pages
                &lt;/a&gt;
            &lt;/nav&gt;
        &lt;/div&gt;;
    }

<span class="strong"><strong>    redirect(event, section) {</strong></span>
<span class="strong"><strong>        window.location.hash = '#${section}';</strong></span>

<span class="strong"><strong>        var component = null;</strong></span>

<span class="strong"><strong>        switch (section) {</strong></span>
<span class="strong"><strong>            case "login":</strong></span>
<span class="strong"><strong>                component = &lt;Login /&gt;;</strong></span>
<span class="strong"><strong>                break;</strong></span>
<span class="strong"><strong>            case "page-admin":</strong></span>
<span class="strong"><strong>                var backend = new Backend();</strong></span>
<span class="strong"><strong>                component = &lt;PageAdmin backend={backend} /&gt;;</strong></span>
<span class="strong"><strong>                break;</strong></span>
<span class="strong"><strong>        }</strong></span>

<span class="strong"><strong>        var layoutClassNames = [</strong></span>
<span class="strong"><strong>            "demo-layout",</strong></span>
<span class="strong"><strong>            "mdl-layout",</strong></span>
<span class="strong"><strong>            "mdl-js-layout",</strong></span>
<span class="strong"><strong>            "mdl-layout--fixed-drawer"</strong></span>
<span class="strong"><strong>        ].join(" ");</strong></span>

<span class="strong"><strong>        ReactDOM.render(</strong></span>
<span class="strong"><strong>            &lt;div className={layoutClassNames}&gt;</strong></span>
<span class="strong"><strong>                &lt;Nav /&gt;</strong></span>
<span class="strong"><strong>                {component}</strong></span>
<span class="strong"><strong>            &lt;/div&gt;,</strong></span>
<span class="strong"><strong>            document.querySelector(".react")</strong></span>
<span class="strong"><strong>        );</strong></span>

<span class="strong"><strong>        event.preventDefault();</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>};</strong></span>

<span class="strong"><strong>export default Nav;</strong></span>
</pre></div><p>We've had to convert the <code class="literal">Nav</code> function to a <code class="literal">Nav</code> class. We want to create the redirect method outside<a id="id143" class="indexterm"/> of render (as that is more efficient) and also isolate the choice of which component to render.</p><p>Using a class also gives us a way to name and reference the <code class="literal">Nav</code> component, so we can create a new instance to overwrite it from within the <code class="literal">redirect</code> method. It's not ideal to package this kind of code within a component, so we'll clean that up in a bit.</p><p>We can now switch between different sections without full page reloads.</p><p>There is one problem still to solve. When we use the browser's back button, the components don't change to reflect the component that should be shown for each hash. We can solve this in a couple of ways. The first approach we can try is checking the hash frequently:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>componentDidMount() {</strong></span>
<span class="strong"><strong>    var hash = window.location.hash;</strong></span>

<span class="strong"><strong>    setInterval(() =&gt; {</strong></span>
<span class="strong"><strong>        if (hash !== window.location.hash) {</strong></span>
<span class="strong"><strong>            hash = window.location.hash;</strong></span>
<span class="strong"><strong>            this.redirect(null, hash.slice(1), true);</strong></span>
<span class="strong"><strong>        }</strong></span>
<span class="strong"><strong>    }, 100);</strong></span>
<span class="strong"><strong>}</strong></span>

redirect(event, section, <span class="strong"><strong>respondingToHashChange = false) {</strong></span>
<span class="strong"><strong>    if (!respondingToHashChange) {</strong></span>
<span class="strong"><strong>        window.location.hash = `#${section}`;</strong></span>
<span class="strong"><strong>    }</strong></span>

    var component = null;

    switch (section) {
        case "login":
            component = &lt;Login /&gt;;
            break;
        case "page-admin":
            var backend = new Backend();
            component = &lt;PageAdmin backend={backend} /&gt;;
            break;
    }

    var layoutClassNames = [
        "demo-layout",
        "mdl-layout",
        "mdl-js-layout",
        "mdl-layout--fixed-drawer"
    ].join(" ");

    ReactDOM.render(
        &lt;div className={layoutClassNames}&gt;
            &lt;Nav /&gt;
            {component}
        &lt;/div&gt;,
        document.querySelector(".react")
    );

<span class="strong"><strong>    if (event) {</strong></span>
<span class="strong"><strong>        event.preventDefault();</strong></span>
<span class="strong"><strong>    }</strong></span>
}</pre></div><p>Our <code class="literal">redirect</code> method has an extra parameter, to apply the new hash whenever we're not responding to a <a id="id144" class="indexterm"/>hash change. We also wrapped the call to <code class="literal">event.preventDefault</code> in case we don't have a click event to work with. Other than these changes, the <code class="literal">redirect</code> method is the same.</p><p>We also added a <code class="literal">componentDidMount</code> method in which we make a call to <code class="literal">setInterval</code>. We stored the initial <code class="literal">window.location.hash</code> property and checked 10 times a second to see whether it has changed. The hash value is <code class="literal">#login</code> or <code class="literal">#page-admin</code>, so we sliced the first character off and passed the rest to the <code class="literal">redirect</code> method.</p><p>Try clicking on the<a id="id145" class="indexterm"/> different navigation links and then using the browser's back button.</p><p>The second option is to use the newish <code class="literal">pushState</code> and <code class="literal">popState</code> methods on the <code class="literal">window.history</code> object. They're not very well supported yet, so you need to be careful when you handle older browsers, or ensure that you don't need to handle them.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>You can<a id="id146" class="indexterm"/> learn more<a id="id147" class="indexterm"/> about <code class="literal">pushState</code> and <code class="literal">popState</code> at <a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/API/History_API">https://developer.mozilla.org/en-US/docs/Web/API/History_API</a>.</p></div></div><p>There's an easier way to respond to users clicking links: the <code class="literal">hashchange</code> event. Instead of adding the <code class="literal">onClick</code> events to each of the links (and calling the <code class="literal">redirect</code> function every time), we can<a id="id148" class="indexterm"/> listen for the <code class="literal">hashchange</code> events and change to the appropriate view. There's a great tutorial on this at <a class="ulink" href="https://medium.com/@tarkus/react-js-routing-from-scratch-246f962ededf">https://medium.com/@tarkus/react-js-routing-from-scratch-246f962ededf</a>.</p></div></div></div>
<div class="section" title="Using a router"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec38"/>Using a router</h1></div></div></div><p>Our hash code<a id="id149" class="indexterm"/> is functional but invasive. We shouldn't call the <code class="literal">render</code> method from inside a component (at least not the one we own). So, we will instead use a popular router to manage this stuff for us.</p><p>Download the router with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install react-router --save</strong></span>
</pre></div><p>Then, we need to put <code class="literal">login.html</code> and <code class="literal">page-admin.html</code> back into the same file:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;script src="/node_modules/babel-core/browser.js"&gt;&lt;/script&gt;
        &lt;script src="/node_modules/systemjs/dist/system.js"&gt;&lt;/script&gt;
        &lt;script src="https://storage.googleapis.com/code.getmdl.io/1.0.6/material.min.js"&gt;&lt;/script&gt;
        &lt;link rel="stylesheet" href="https://storage.googleapis.com/code.getmdl.io/1.0.6/material.indigo-pink.min.css" /&gt;
        &lt;link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" /&gt;
        &lt;link rel="stylesheet" href="admin.css" /&gt;
    &lt;/head&gt;
    &lt;body class="
        mdl-demo
        mdl-color--grey-100
        mdl-color-text--grey-700
        mdl-base"&gt;
        &lt;div class="react"&gt;&lt;/div&gt;
        &lt;script&gt;
            System.config({
                "transpiler": "babel",
                "map": {
                    "react": "/examples/react/react",
                    "react-dom": "/examples/react/react-dom",
<span class="strong"><strong>                    "router": "/node_modules/react-router/umd/ReactRouter"</strong></span>
                },
                "baseURL": "../",
                "defaultJSExtensions": true
            });

<span class="strong"><strong>            System.import("examples/admin");</strong></span>
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre></div><p>Notice how <a id="id150" class="indexterm"/>we've added the <code class="literal">ReactRouter</code> file to the import map? We'll use that in <code class="literal">admin.js</code>. First, let's define our <code class="literal">layout</code> component:</p><div class="informalexample"><pre class="programlisting">import React from "react";
import ReactDOM from "react-dom";
import Component from "src/component";
import Nav from "src/nav";
import Login from "src/login";
import Backend from "src/backend";
import PageAdmin from "src/page-admin";
import {Router, browserHistory, IndexRoute, Route} from "router";

var App = function(props) {
    var layoutClassNames = [
        "demo-layout",
        "mdl-layout",
        "mdl-js-layout",
        "mdl-layout--fixed-drawer"
    ].join(" ");

    return (
        &lt;div className={layoutClassNames}&gt;
            &lt;Nav /&gt;
            {props.children}
        &lt;/div&gt;
    );
};</pre></div><p>This creates the<a id="id151" class="indexterm"/> page layout we've been using and allows a dynamic content component. Every React component has a <code class="literal">this.props.children</code> property (or <code class="literal">props.children</code> in the case of a <code class="literal">function</code> component), which is an array of nested components. For example, consider the following component:</p><div class="informalexample"><pre class="programlisting">&lt;App&gt;
    &lt;Login /&gt;
&lt;/App&gt;</pre></div><p>Inside the <code class="literal">App</code> component, <code class="literal">this.props.children</code> will contain a single item: an instance of the <code class="literal">Login</code>. Next, we'll define handler components for the two sections we want to route:</p><div class="informalexample"><pre class="programlisting">var LoginHandler = function() {
    return &lt;Login /&gt;;
};

var PageAdminHandler = function() {
    var backend = new Backend();
    return &lt;PageAdmin backend={backend} /&gt;;
};</pre></div><p>We don't really need to wrap <code class="literal">Login</code> in <code class="literal">LoginHandler</code>, but I chose to do it to be consistent with <code class="literal">PageAdminHandler</code>. <code class="literal">PageAdmin</code> expects an instance of <code class="literal">Backend</code>, so we have to wrap it, as we see in this example.</p><p>Now, we can define routes for our CMS:</p><div class="informalexample"><pre class="programlisting">ReactDOM.render(
<span class="strong"><strong>    &lt;Router history={browserHistory}&gt;</strong></span>
<span class="strong"><strong>        &lt;Route path="/" component={App}&gt;</strong></span>
<span class="strong"><strong>            &lt;IndexRoute component={LoginHandler} /&gt;</strong></span>
<span class="strong"><strong>            &lt;Route path="login" component={LoginHandler} /&gt;</strong></span>
<span class="strong"><strong>            &lt;Route path="page-admin" component={PageAdminHandler} /&gt;</strong></span>
<span class="strong"><strong>        &lt;/Route&gt;</strong></span>
<span class="strong"><strong>    &lt;/Router&gt;,</strong></span>
    document.querySelector(".react")
);</pre></div><p>There's a single root<a id="id152" class="indexterm"/> route for the path <code class="literal">/</code>. It creates an instance of <code class="literal">App</code>, so we always get the same layout. Then, we nest a <code class="literal">"login"</code> route and a <code class="literal">"page-admin"</code> route. These create instances of their respective components. We also define <code class="literal">IndexRoute</code> so that the login page will be displayed as a landing page.</p><p>We need to remove our custom history code from <code class="literal">Nav</code>:</p><div class="informalexample"><pre class="programlisting">import React from "react";
import ReactDOM from "react-dom";
<span class="strong"><strong>import { Link } from "router";</strong></span>

export default (props) =&gt; {
    // ...define class names

    return &lt;div className={drawerClassNames}&gt;
        &lt;header className="demo-drawer-header"&gt;
            &lt;img src="images/user.jpg"
                 className="demo-avatar" /&gt;
        &lt;/header&gt;
        &lt;nav className={navClassNames}&gt;
<span class="strong"><strong>            &lt;Link className="mdl-navigation__link" to="login"&gt;</strong></span>
                &lt;i className={buttonIconClassNames}
                   role="presentation"&gt;
                    lock
                &lt;/i&gt;
                Login
<span class="strong"><strong>            &lt;/Link&gt;</strong></span>
<span class="strong"><strong>            &lt;Link className="mdl-navigation__link" to="page-admin"&gt;</strong></span>
                &lt;i className={buttonIconClassNames}
                   role="presentation"&gt;
                    pages
                &lt;/i&gt;
                Pages
<span class="strong"><strong>            &lt;/Link&gt;</strong></span>
        &lt;/nav&gt;
    &lt;/div&gt;;
};</pre></div><p>Also, since we no longer need a separate <code class="literal">redirect</code> method, we can convert the class back into a statement component (<code class="literal">function</code>).</p><p>Note that we<a id="id153" class="indexterm"/> swapped anchor components for a new <code class="literal">Link</code> component. This interacts with the router to show the correct section when we click on the navigation links. We can also change the route paths without the need to update this component (unless we also change the route names).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>In the preceding chapter, we split <code class="literal">index.html</code> into <code class="literal">login.html</code> and <code class="literal">page-admin.html</code> to see both sections just by changing the URL. In this chapter, we joined them back together, since we have a router to switch between them. You'll need to make the same changes or use the example code for this chapter in order for the examples to work.</p></div></div></div>
<div class="section" title="Creating public pages"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec39"/>Creating public pages</h1></div></div></div><p>Now that we <a id="id154" class="indexterm"/>can easily switch between CMS sections, we can use the same trick to show the public pages of our website. Let's create a new HTML page just for these:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
<span class="strong"><strong>        &lt;script src="/node_modules/babel-core/browser.js"&gt;&lt;/script&gt;</strong></span>
<span class="strong"><strong>        &lt;script src="/node_modules/systemjs/dist/system.js"&gt;&lt;/script&gt;</strong></span>
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class="react"&gt;&lt;/div&gt;
        &lt;script&gt;
            System.config({
                "transpiler": "babel",
                "map": {
                    "react": "/examples/react/react",
                    "react-dom": "/examples/react/react-dom",
                    "router": "/node_modules/react-router/umd/ReactRouter"
                },
                "baseURL": "../",
                "defaultJSExtensions": true
            });

            System.import("examples/index");
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre></div><p>This is a reduced form of <code class="literal">admin.html</code> without the material design resources. I think we can ignore the <a id="id155" class="indexterm"/>appearance of these pages for the moment while we focus on the navigation.</p><p>The public pages are stateless, so we can use the <code class="literal">function</code> components for them. Let's begin with the layout component:</p><div class="informalexample"><pre class="programlisting">var App = function(props) {
    return (
        &lt;div className="layout"&gt;
            &lt;Nav pages={props.route.backend.all()} /&gt;
            {props.children}
        &lt;/div&gt;
    );
};</pre></div><p>This is similar to the <code class="literal">App</code> admin component, but it also has a reference to <code class="literal">Backend</code>. We then define it when we render the components:</p><div class="informalexample"><pre class="programlisting">var backend = new Backend();

ReactDOM.render(
    &lt;Router history={browserHistory}&gt;
        &lt;Route path="/" component={App} backend={backend}&gt;
<span class="strong"><strong>            &lt;IndexRoute component={StaticPage} backend={backend} /&gt;</strong></span>
<span class="strong"><strong>            &lt;Route path="pages/:page" component={StaticPage} backend={backend} /&gt;</strong></span>
        &lt;/Route&gt;
    &lt;/Router&gt;,
    document.querySelector(".react")
);</pre></div><p>For this to work, we also need to define <code class="literal">StaticPage</code>:</p><div class="informalexample"><pre class="programlisting">var StaticPage = function(props) {
    var id = props.params.page || 1;
    var backend = props.route.backend;

    var pages = backend.all().filter(
        (page) =&gt; {
            return page.id == id;
        }
    );

    if (pages.length &lt; 1) {
        return &lt;div&gt;not found&lt;/div&gt;;
    }

    return (
        &lt;div className="page"&gt;
            &lt;h1&gt;{pages[0].title}&lt;/h1&gt;
            {pages[0].content}
        &lt;/div&gt;
    );
};</pre></div><p>This component is <a id="id156" class="indexterm"/>more interesting. We access the <code class="literal">params</code> property, which is a map of all the URL path parameters defined for this route. We have <code class="literal">:page</code> in the path (<code class="literal">pages/:page</code>), so when we go to <code class="literal">pages/1</code>, the <code class="literal">params</code> object is <code class="literal">{"page":1}</code>.</p><p>We also pass <code class="literal">Backend</code> to <code class="literal">Page</code>, so we can fetch all pages and filter them by <code class="literal">page.id</code>. If no <code class="literal">page.id</code> is provided, we default to <code class="literal">1</code>.</p><p>After filtering, we check whether there are any pages. If not, we return a simple <span class="strong"><strong>Not found</strong></span> message. Otherwise, we render the content of the first page in the array (since we expect the array to have a length of at least <code class="literal">1</code>).</p><p>We now have a page for the public pages of the website:</p><div class="mediaobject"><img src="graphics/5268_06_03.jpg" alt="Creating public pages"/></div><p>We can also<a id="id157" class="indexterm"/> add the <code class="literal">onEnter</code> and <code class="literal">onLeave</code> callbacks to each of our routes:</p><div class="informalexample"><pre class="programlisting">&lt;Route path="pages/:page"
    component={StaticPage}
    backend={backend}
    onEnter={props =&gt; console.log("entering")}
    onLeave={() =&gt; console.log("leaving")} /&gt;</pre></div><p>As the current route changes, the previous route will trigger <code class="literal">onLeave</code>, as will each parent component up the inheritance chain. Once all the <code class="literal">onLeave</code> callbacks are triggered, the router will begin to trigger the <code class="literal">onEnter</code> callbacks down the inheritance chain. We didn't really use inheritance much (owing to how simple our navigation is), but it's still important to remember that <code class="literal">onLeave</code> is triggered before <code class="literal">onEnter</code>.</p><p>This is useful if we want to commit any unsaved data to our backend, log the progress of a user through the interface or anything else that might depend on the user navigating between pages on the site.</p><p>In addition to this, we want to animate different pages as they are rendered. We can combine them with <code class="literal">React.addons.CSSTransitionGroup</code>, which we saw in <a class="link" href="ch04.html" title="Chapter 4. Styling and Animating Components">Chapter 4</a>, <span class="emphasis"><em>Styling and Animating Components</em></span>. As new components are rendered inside the <code class="literal">App</code> component, we will be able to animate them in exactly the same way. Just include <code class="literal">div.layout</code> in a <code class="literal">React.addons.CSSTransitionGroup</code> component and you should be all set!</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec40"/>Summary</h1></div></div></div><p>In this chapter, you learned about how the browser stores URL history, and how we can manipulate it to load different sections without full page reloads. It introduced a bit of complexity, but we also saw that there are other alternatives (for example, the <code class="literal">hashchange</code> event) that reduce the complexity while still reducing the number of full page reloads we need to perform.</p><p>You also learned about a popular React router and used it to abstract the manual location tracking or changing we had to do before.</p><p>In the next chapter, you'll learn about server-side rendering and application structure.</p></div></body></html>