<html><head></head><body>
  <div id="_idContainer580">
    <h1 class="chapterNumber">10</h1>
    <h1 class="chapterTitle" id="_idParaDest-344">RESTful APIs and Full-Stack Implementation</h1>
    <p class="normal">In <em class="italics">Chapter 1</em>, <em class="italics">Introduction to Angular and Its Concepts</em>, I introduced you to the wider architecture in which web applications exist. The choices that are made in full-stack architecture can profoundly impact the success of your web application. You simply cannot afford to be ignorant of how the APIs you interact with are designed. In this chapter, we are going to cover how to implement a backend for your frontend using Node, Express, and Mongo. Combined with Angular, this stack of software is referred to as the MEAN stack.</p>
    <p class="normal">My take on the MEAN stack is minimal MEAN, which prioritizes ease of use, happiness, and effectiveness, the main ingredients for a great <strong class="bold">developer experience</strong> (<strong class="bold">DX</strong>). To keep up with the theme, we'll implement the LemonMart server. This server will round out JWT auth from <em class="italics">Chapter 8</em>, <em class="italics">Designing Authentication and Authorization</em>. In addition, the server will support recipes that I am going to cover in <em class="italics">Chapter 11</em>, <em class="italics">Recipes – Reusability, Routing, and Caching</em>, and <em class="italics">Chapter 12</em>, <em class="italics">Recipes – Master/Detail, Data Tables, and NgRx</em>. </p>
    <p class="normal">This chapter covers a lot of ground. It is designed to serve as a roadmap to the GitHub repository (<a href="https://github.com/duluca/lemon-mart-server"><span class="url">https://github.com/duluca/lemon-mart-server</span></a>). I cover the architecture, design, and major components of the implementation. I highlight important pieces of code to explain how the solution comes together. However, unlike prior chapters, you cannot solely rely on the code sample provided in the text to complete your implementation. For the purposes of this book, it is more important that you understand why we are implementing various functionality over having a strong grasp of the implementation details. So, for this chapter, I recommend that you read and understand the server code versus trying to recreate it on your own. </p>
    <div class="note">
      <p class="Information-Box--PACKT-">You will need to take action towards the end of the chapter to implement a custom auth provider in your Angular app to authenticate against <strong class="bold">lemon-mart-server</strong> and also leverage Postman to generate test data, which will be useful in later chapters.</p>
    </div>
    <p class="normal">We begin by covering full-stack architecture, covering lemon-mart-server's monorepo design and how you can use Docker Compose to run a three-tier application with a web app, server, and a database. Then, we go over RESTful API design and documentation, leveraging the OpenAPI specification using <a href="http://Swagger.io"><span class="url">Swagger.io</span></a>, and implementation using Express.js. Then, we cover the implementation of a MongoDB <strong class="bold">object document mapper</strong> (<strong class="bold">ODM</strong>) using my DocumentTS library to store users with login credentials. We implement a token-based auth function and use it to secure our APIs. Finally, we leverage Postman to generate test data in our database using the APIs we have developed.</p>
    <p class="normal">In this chapter, you will learn about the following:</p>
    <ul>
      <li class="list">Full-stack architecture</li>
      <li class="list">Docker Compose</li>
      <li class="list">RESTful APIs</li>
      <li class="list">MongoDB ODM with DocumentTS</li>
      <li class="list">Implementing JWT auth</li>
      <li class="list">Generating users with Postman</li>
    </ul>
    <p class="normal">The most up-to-date versions of the sample code for the book can be found on GitHub at the repository linked below. The repository contains the final and completed state of the code. This chapter requires Docker and Postman applications.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">It is critical that you get <strong class="bold">lemon-mart-server</strong> up and running on your development environment and have <strong class="bold">lemon-mart</strong> communicate with it. Refer to the instructions documented here or in the <code class="Code-In-Text--PACKT-">README</code> on GitHub to get your server up and running.</p>
    </div>
    <p class="normal">In the case of this<em class="italics"> chapter</em>:</p>
    <ol>
      <li class="list">Clone the <strong class="bold">lemon-mart-server</strong> repository using the <code class="Code-In-Text--PACKT-">--recurse-submodules</code> option: <code class="Code-In-Text--PACKT-">git clone --recurse-submodules</code> <a href="https://github.com/duluca/lemon-mart-server "><span class="url">https://github.com/duluca/lemon-mart-server</span></a></li>
      <li class="list">In the VS Code terminal, execute <code class="Code-In-Text--PACKT-">cd web-app; git checkout master</code> to ensure that the submodule from <a href="https://github.com/duluca/lemon-mart"><span class="url">https://github.com/duluca/lemon-mart</span></a> is on the master branch.<div class="note">
          <p>Later, in the <em class="italics">Git submodules</em> section, you can configure the <code class="Code-In-Text--PACKT-">web-app</code> folder to pull from your lemon-mart server.</p>
        </div>
      </li>
      <li class="list">Execute <code class="Code-In-Text--PACKT-">npm install</code> on the root folder to install dependencies.<div class="note">
          <p>Note that running the <code class="Code-In-Text--PACKT-">npm install</code> command on the root folder triggers a script, which also installs dependencies under the <code class="Code-In-Text--PACKT-">server</code> and <code class="Code-In-Text--PACKT-">web-app</code> folders.</p>
        </div>
      </li>
      <li class="list">Execute <code class="Code-In-Text--PACKT-">npm run init:env</code> on the root folder to configure environment variables in <code class="Code-In-Text--PACKT-">.env</code> files.<div class="note">
          <p>This command will create two <code class="Code-In-Text--PACKT-">.env</code> files, one on the root folder and the other under the <code class="Code-In-Text--PACKT-">server</code> folder, to contain your private configuration information. The initial files are generated based on the <code class="Code-In-Text--PACKT-">example.env</code> file. You can modify these files later and set your own secure secrets.</p>
        </div>
      </li>
      <li class="list">Execute <code class="Code-In-Text--PACKT-">npm run build</code> on the root folder, which builds both the server and the web app.<div class="note">
          <p>Note that the web app is built using a new configuration named <code class="Code-In-Text--PACKT-">--configuration=lemon-mart-server</code>, which uses <code class="Code-In-Text--PACKT-">src/environments/environment.lemon-mart-server.ts</code>.</p>
        </div>
      </li>
      <li class="list">Execute <code class="Code-In-Text--PACKT-">docker-compose up --build</code> to run containerized versions of the server, web app, and a MongoDB database.<div class="note">
          <p>Note that the web app is containerized using a new file named <code class="Code-In-Text--PACKT-">nginx.Dockerfile</code>.</p>
        </div>
      </li>
      <li class="list">Navigate to <code class="Code-In-Text--PACKT-">http://localhost:8080</code> to view the web app.<div class="note">
          <p>To log in, click on the <strong class="screen-text">Fill</strong> button to populate the email and password fields with the default demo credentials.</p>
        </div>
      </li>
      <li class="list">Navigate to <code class="Code-In-Text--PACKT-">http://localhost:3000</code> to view the server landing page.</li>
      <li class="list">Navigate to <code class="Code-In-Text--PACKT-">http://localhost:3000/api-docs</code> to view interactive API documentation.</li>
      <li class="list">You can use <code class="Code-In-Text--PACKT-">npm run start:database</code> to only start the database, and <code class="Code-In-Text--PACKT-">npm start</code> on the <code class="Code-In-Text--PACKT-">server</code> folder for debugging.</li>
      <li class="list" value="11">You can use <code class="Code-In-Text--PACKT-">npm run start:backend</code> to only start the database and the server, and <code class="Code-In-Text--PACKT-">npm start</code> on the <code class="Code-In-Text--PACKT-">web-app</code> folder for debugging.</li>
    </ol>
    <p class="normal">In the case of examples from this<em class="italics"> chapter</em> that are based on <strong class="bold">lemon-mart</strong>:</p>
    <ol>
      <li class="list" value="1">Clone the repository: <a href="https://github.com/duluca/lemon-mart "><span class="url">https://github.com/duluca/lemon-mart</span></a></li>
      <li class="list">Execute <code class="Code-In-Text--PACKT-">npm install</code> on the root folder to install dependencies.</li>
      <li class="list">The code sample for this chapter is available under the sub-folder:
        <pre class="programlisting"><code class="hljs">projects/ch10
</code></pre>
      </li>
      <li class="list">To run the Angular app for this chapter, execute the following command:
        <pre class="programlisting"><code class="hljs nginx"><span class="hljs-attribute">npx</span> ng serve ch10
</code></pre>
      </li>
      <li class="list">To run Angular unit tests for this chapter, execute the following command:
        <pre class="programlisting"><code class="hljs bash">npx ng <span class="hljs-built_in">test</span> ch10 --watch=<span class="hljs-literal">false</span>
</code></pre>
      </li>
      <li class="list">To run Angular e2e tests for this chapter, execute the following command:
        <pre class="programlisting"><code class="hljs nginx"><span class="hljs-attribute">npx</span> ng e2e ch10
</code></pre>
      </li>
      <li class="list" value="7">To build a production-ready Angular app for this chapter, execute the following command:
        <pre class="programlisting"><code class="hljs ada">npx ng build ch10 <span class="hljs-comment">--prod</span>
</code></pre>
        <div class="packt_tip">
          <p>Note that the <code class="Code-In-Text--PACKT-">dist/ch10</code> folder at the root of the repository will contain the compiled result.</p>
        </div>
      </li>
    </ol>
    <div class="note">
      <p class="Information-Box--PACKT-">Beware that the source code in the book or on GitHub may not always match the code generated by the Angular CLI. There may also be slight differences in implementation between the code in the book and what's on GitHub because the ecosystem is ever-evolving. It is natural for the sample code to change over time. Also, on GitHub, expect to find corrections, fixes to support newer versions of libraries, or side-by-side implementations of multiple techniques for the reader to observe. The reader is only expected to implement the ideal solution recommended in the book. If you find errors or have questions, please create an issue or submit a pull request on GitHub for the benefit of all readers.</p>
    </div>
    <p class="normal"/>
    <div class="packt_tip">
      <p>You can read more about updating Angular in the <em class="italics">Appendix C</em>, <em class="italics">Keeping Angular and Tools Evergreen</em>. You can find this appendix online from <a href="https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen."><span class="url">https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf</span></a> or at <a href="https://expertlysimple.io/stay-evergreen"><span class="url">https://expertlysimple.io/stay-evergreen</span></a>.</p>
    </div>
    <p class="normal">With your LemonMart server up and running, we are ready to explore the architecture of the MEAN stack. By the end of this section, you should have your own version of LemonMart communicating with the server.</p>
    <h1 class="title" id="_idParaDest-345">Full-stack architecture</h1>
    <p class="normal">Full-stack refers to the entire stack of software that makes an application work, all the way from <a id="_idIndexMarker1085"/>databases to servers, APIs, and the web and/or mobile apps that leverage them. The mythical full-stack developer is all-knowing and can comfortably operate in all verticals of the profession. It is next to impossible to specialize in all things software-related and to be considered an expert in relation to every given topic. However, to be considered an expert in a single topic, you must also be well-versed in related topics. When learning a new topic, it is very helpful to keep your tooling and language consistent so that you can absorb the new information without additional noise. For these reasons, I opted to introduce you to the MEAN stack over Spring Boot using Java or ASP.NET using C#. By sticking to familiar tools and languages such as TypeScript, VS Code, npm, GitHub, Jasmine, Docker, and CircleCI, you can better understand how a full-stack implementation comes together and become a better web developer as a result.</p>
    <h2 class="title" id="_idParaDest-346">Minimal MEAN</h2>
    <p class="normal">Choosing the Correct-Stack™ for your project is difficult. First and foremost, your technical <a id="_idIndexMarker1086"/>architecture should be adequate to meet business needs. For example, if you're trying to deliver an artificial intelligence project <a id="_idIndexMarker1087"/>with Node.js, you're likely using the wrong stack. Our focus will be on delivering web applications, but beyond that, we have other parameters to consider, including the following:</p>
    <ul>
      <li class="list">Ease of use</li>
      <li class="list">Happiness</li>
      <li class="list">Effectiveness</li>
    </ul>
    <p class="normal">If your development team will be working on your application for an extended period of time, then it is very important to consider factors beyond compatibility. Your stack, choice of tool, and coding style can have a significant impact if your code base is easy to use, keeps your developers happy, or makes them feel like effective contributors to the project.</p>
    <p class="normal">A well configured stack is key for a great DX. This can be the difference between a towering stack of dried-out pancakes, or a delicious short stack with the right amount of butter and syrup over it.</p>
    <p class="normal">By introducing <a id="_idIndexMarker1088"/>too many libraries and dependencies, you can slow down your progress, make your code difficult to maintain, and find yourself in a feedback <a id="_idIndexMarker1089"/>loop of introducing more libraries to resolve the issues of other libraries. The only way to win this game is to simply not play it.</p>
    <p class="normal">If you take your time to learn how to work with a few fundamental libraries, you can become a far more effective developer. In essence, you can do more with less. My advice would be to:</p>
    <ul>
      <li class="list"><strong class="bold">Think</strong> before you write a single line of code, and apply the 80-20 rule.</li>
      <li class="list"><strong class="bold">Wait</strong> for libraries and tools to mature, skipping the betas.</li>
      <li class="list"><strong class="bold">Fast</strong> by reducing your gluttony for new packages and tools, mastering the fundamentals instead.<div class="packt_tip">
          <p>Watch my 2017 Ng conference talk entitled <em class="italics">Do More with Less JavaScript</em> on YouTube at <a href="https://www.youtube.com/watch?v=Sd1aM8181kc"><span class="url">https://www.youtube.com/watch?v=Sd1aM8181kc</span></a>.</p>
        </div>
      </li>
    </ul>
    <p class="normal">This minimalist <a id="_idIndexMarker1090"/>mindset is the design philosophy behind minimal MEAN. You can review a reference implementation on GitHub at <a href="https://github.com/duluca/minimal-mean"><span class="url">https://github.com/duluca/minimal-mean</span></a>. Refer to the following diagram for the overall architecture: </p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_10_01.png"/></figure>
    <p class="packt_figref">Figure 10.1: Minimal MEAN software stack and tooling</p>
    <p class="normal">Let's go <a id="_idIndexMarker1091"/>over the <a id="_idIndexMarker1092"/>components of the architecture one by one.</p>
    <h3 class="title" id="_idParaDest-347">Angular</h3>
    <p class="normal">Angular is the presentation layer. Angular is a capable and reliable development platform. It is <a id="_idIndexMarker1093"/>well understood and has a great community. You should definitely take the time to master the fundamentals of Angular before considering another option.</p>
    <p class="normal">Libraries such <a id="_idIndexMarker1094"/>as Angular Material, Angular Evergreen, and <code class="Code-In-Text--PACKT-">angular-unit-test-helper</code> help you deliver optimal and great-looking solutions with minimal effort.</p>
    <p class="normal">You may containerize your Angular (or any other web app) using the minimal Docker container, <code class="Code-In-Text--PACKT-">duluca/minimal-nginx-web-server</code> or <code class="Code-In-Text--PACKT-">duluca/minimal-node-web-server</code>.</p>
    <h3 class="title" id="_idParaDest-348">Express</h3>
    <p class="normal">Express.js will be <a id="_idIndexMarker1095"/>our API layer. Express is a fast, unopinionated, and minimalist <a id="_idIndexMarker1096"/>web framework for Node.js. Express has a vast plugin ecosystem that is almost guaranteed to meet every need. In minimal MEAN, we only leverage two packages:</p>
    <ul>
      <li class="list"><code class="Code-In-Text--PACKT-">cors</code>: To configure <a id="_idIndexMarker1097"/>cross-origin resource sharing settings</li>
      <li class="list"><code class="Code-In-Text--PACKT-">morgan</code>: To log <a id="_idIndexMarker1098"/>HTTP requests</li>
    </ul>
    <p class="normal">In addition, we use express parsers to parse incoming HTTP requests in <code class="Code-In-Text--PACKT-">req.body</code> and the <code class="Code-In-Text--PACKT-">express.static</code> function to serve the content of the <code class="Code-In-Text--PACKT-">public</code> folder.</p>
    <p class="normal">You can read <a id="_idIndexMarker1099"/>more about Express.js at <a href="https://expressjs.com/"><span class="url">https://expressjs.com/</span></a>.</p>
    <h3 class="title" id="_idParaDest-349">Node</h3>
    <p class="normal">Express.js runs on Node.js. We will be implementing the business layer in Node. Node is a lightweight <a id="_idIndexMarker1100"/>and efficient JavaScript runtime, using an event-driven, non-blocking I/O model that makes it suitable for high-performance and real-time applications. Node runs <a id="_idIndexMarker1101"/>everywhere, from fridges to smart watches. You can increase the reliability of your Node applications by using TypeScript to develop your application.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Refer to <a id="_idIndexMarker1102"/>the blog post by Frank Rosner on non-blocking I/O for a more in-depth explanation of the topic at <a href="https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/"><span class="url">https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/</span></a>.</p>
    </div>
    <p class="normal">Later in this chapter, you're going to learn how to configure Node projects using TypeScript.</p>
    <h3 class="title" id="_idParaDest-350">Mongo</h3>
    <p class="normal">MongoDB represents the persistence layer. MongoDB is a document-oriented database with dynamic JSON-like schemas. The major benefit of using a JSON-based database is the fact that <a id="_idIndexMarker1103"/>you don't need to transform your data from one format to another. You can retrieve, display, edit, and then update the data solely using JSON.</p>
    <p class="normal">In addition, the <a id="_idIndexMarker1104"/>MongoDB native driver for Node is mature, performant, and capable. I have developed a library called <code class="Code-In-Text--PACKT-">document-ts</code>, which aims to simplify interacting with MongoDB by introducing rich document objects that are easy to code. DocumentTS is a very thin TypeScript-based MongoDB helper with optional, rich ODM convenience features.</p>
    <p class="normal">You can <a id="_idIndexMarker1105"/>read more about MongoDB at <a href="https://www.mongodb.com/"><span class="url">https://www.mongodb.com/</span></a>, and the <a id="_idIndexMarker1106"/>DocumentTS library at <a href="https://github.com/duluca/document-ts"><span class="url">https://github.com/duluca/document-ts</span></a>.</p>
    <h3 class="title" id="_idParaDest-351">Tooling</h3>
    <p class="normal">The tooling <a id="_idIndexMarker1107"/>that supports your development is as important <a id="_idIndexMarker1108"/>as your choice of software stack. Minimal MEAN leverages the following:</p>
    <ul>
      <li class="list"><strong class="bold">VS Code</strong>: Great <a id="_idIndexMarker1109"/>extension support, lightweight, fast, and cross-platform</li>
      <li class="list"><strong class="bold">TypeScript</strong>: Fast <a id="_idIndexMarker1110"/>and easy-to-use transpiler with great linting support using tslint</li>
      <li class="list"><strong class="bold">Npm</strong>: Multi-platform <a id="_idIndexMarker1111"/>scripting and dependency management with a rich ecosystem of packages</li>
      <li class="list"><strong class="bold">GitHub</strong>: Flexible, free, and <a id="_idIndexMarker1112"/>well supported Git host. GitHub flow enables gated code check-ins in tandem with a CI server</li>
      <li class="list"><strong class="bold">Docker</strong>: Lightweight <a id="_idIndexMarker1113"/>virtualization technology that encapsulates your environment configuration and settings</li>
      <li class="list"><strong class="bold">Continuous Integration (CI)</strong>: Critical <a id="_idIndexMarker1114"/>to ensuring the delivery of quality code</li>
      <li class="list"><strong class="bold">Jasmine</strong>: Batteries-included <a id="_idIndexMarker1115"/>unit testing framework that works with nyc/istanbul.js to deliver code coverage metrics</li>
    </ul>
    <p class="normal">Note that the tooling and language of choice we are using is the same as the ones we use for Angular development. This enables developers to be able to switch between frontend and backend development with minimal context switching.</p>
    <p class="normal">Now that we have covered all major components and tooling for delivering a minimal MEAN stack app, let's start by creating a Git repository that can house our frontend and backend code.</p>
    <h2 class="title" id="_idParaDest-352">Configuring a monorepo</h2>
    <p class="normal">You can optimize your development experience by creating a monorepo, which contains your frontend <a id="_idIndexMarker1116"/>and backend code. A monorepo allows developers to be able to jump between projects within the same IDE window. Developers <a id="_idIndexMarker1117"/>can reference code more easily across projects, such as sharing TypeScript interfaces between the frontend and the backend, thereby ensuring that data objects line up every time. The CI server can build all projects at once to ensure that all components of the full-stack application remain in working order.</p>
    <div class="packt_tip">
      <p>Note that a monorepo is different to multi-root workspaces in VS Code, where you can add multiple projects to show in the same IDE windows. A monorepo combines <a id="_idIndexMarker1118"/>projects at the source control level. Read more about multi-root workspaces at <a href="https://code.visualstudio.com/docs/editor/multi-root-workspaces"><span class="url">https://code.visualstudio.com/docs/editor/multi-root-workspaces</span></a>.</p>
    </div>
    <p class="normal">Let's <a id="_idIndexMarker1119"/>take a <a id="_idIndexMarker1120"/>quick tour of the code base.</p>
    <h3 class="title" id="_idParaDest-353">Monorepo structure</h3>
    <p class="normal">Under the <code class="Code-In-Text--PACKT-">lemon-mart-server</code> project, you <a id="_idIndexMarker1121"/>are going to have three main folders, as shown here:</p>
    <pre class="programlisting"><code class="hljs pgsql">lemon-mart-<span class="hljs-keyword">server</span>
├───bin
├───web-app (<span class="hljs-keyword">default</span> Angular setup)
├───<span class="hljs-keyword">server</span>
│   ├───src
│   │   ├───models
│   │   ├───<span class="hljs-built_in">public</span>
│   │   ├───services
│   │   ├───v1
│   │   │   └───routes
│   │   └───v2
│   │       └───routes
│   └───tests
|   package.json
|   README.md
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">bin</code> folder contains helper scripts or tools, the <code class="Code-In-Text--PACKT-">web-app</code> folder represents your frontend, and <code class="Code-In-Text--PACKT-">server</code> contains the source code for the backend. In our case, the <code class="Code-In-Text--PACKT-">web-app</code> folder is the <code class="Code-In-Text--PACKT-">lemon-mart</code> project. Instead of copying and pasting the code from the existing project, we leverage Git submodules to link two repositories together.</p>
    <h3 class="title" id="_idParaDest-354">Git submodules</h3>
    <p class="normal">Git submodules help <a id="_idIndexMarker1122"/>you share code between multiple repositories, while keeping the commits separate. Frontend developers may choose to <a id="_idIndexMarker1123"/>only work using the frontend repository, whereas full-stack developers will prefer access to all code. Git submodules also provide a convenient way for existing projects to be combined.</p>
    <p class="normal">Let's start by seeing how you can add your own <code class="Code-In-Text--PACKT-">lemon-mart</code> project as a submodule of <code class="Code-In-Text--PACKT-">lemon-mart-server</code>, leveraging the scripts that reside in the <code class="Code-In-Text--PACKT-">package.json</code> file in the root folder of our monorepo:</p>
    <div class="note">
      <p class="Information-Box--PACKT-">I recommend that you perform this action on the version of <strong class="bold">lemon-mart-server</strong> that you cloned from GitHub. Otherwise, you will need to create a new project and execute <code class="Code-In-Text--PACKT-">npm init -y</code> to get things started.</p>
    </div>
    <ol>
      <li class="list" value="1">Observe the <a id="_idIndexMarker1124"/>following <code class="Code-In-Text--PACKT-">package.json</code> scripts <a id="_idIndexMarker1125"/>that assist in the initialization, updating, and cleaning up of Git submodules:
        <pre class="programlisting"><code class="hljs kotlin"><strong><span class="hljs-keyword">package</span>.json</strong>
  <span class="hljs-string">"config"</span>: {
  ...
    <span class="hljs-string">"webAppGitUrl"</span>: <span class="hljs-string">"https://github.com/duluca/lemon-mart.git"</span>
  },
  <span class="hljs-string">"scripts"</span>: {
    <span class="hljs-string">"webapp:clean"</span>: <span class="hljs-string">"cross-conf-env rimraf web-app &amp;&amp; git rm -r --cached web-app"</span>,
    <span class="hljs-string">"webapp:init"</span>: <span class="hljs-string">"cross-conf-env git submodule add <span class="hljs-variable">$npm_package_config_webAppGitUrl</span> web-app"</span>,
    <span class="hljs-string">"postwebapp:init"</span>: <span class="hljs-string">"git submodule status web-app"</span>,
    <span class="hljs-string">"modules:init"</span>: <span class="hljs-string">"git submodule update --init --recursive"</span>,
    <span class="hljs-string">"modules:update"</span>: <span class="hljs-string">"git submodule update --recursive --remote"</span>
  },
</code></pre>
      </li>
      <li class="list">Update <code class="Code-In-Text--PACKT-">webAppGitUrl</code> with the URL to your own project.</li>
      <li class="list">Execute <code class="Code-In-Text--PACKT-">webapp:clean</code> to remove the existing <code class="Code-In-Text--PACKT-">web-app</code> folder.</li>
      <li class="list" value="4">Finally, execute the <code class="Code-In-Text--PACKT-">webapp:init</code> command to initialize your project in the <code class="Code-In-Text--PACKT-">web-app</code> folder:
        <pre class="programlisting"><code class="hljs dockerfile">$ npm <span class="hljs-keyword">run</span><span class="bash"> webapp:init</span>
</code></pre>
      </li>
    </ol>
    <p class="normal">Going forward, execute the <code class="Code-In-Text--PACKT-">modules:update</code> command to update the code in the submodule. To pull the submodules after cloning the repo in another environment, execute <code class="Code-In-Text--PACKT-">npm modules:init</code>. If you ever need to reset the environment and restart, then execute <code class="Code-In-Text--PACKT-">webapp:clean</code> to clean Git's cache and remove the folder.</p>
    <div class="packt_tip">
      <p>Note that you can have multiple submodules in your repository. The <code class="Code-In-Text--PACKT-">modules:update</code> command will update all the submodules.</p>
    </div>
    <p class="normal">Your web <a id="_idIndexMarker1126"/>application code is now available in the folder named <code class="Code-In-Text--PACKT-">web-app</code>. Additionally, you should <a id="_idIndexMarker1127"/>be able to see both projects <a id="_idIndexMarker1128"/>under VS Code's <strong class="bold">Source Control</strong> pane, as shown:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_10_02.png"/></figure>
    <p class="packt_figref">Figure 10.2: VS Code Source Control Providers</p>
    <p class="normal">Using VS Code's source control, you can independently perform Git actions on either repository.</p>
    <div class="packt_tip">
      <p>If things get messy with your submodule, simply <code class="Code-In-Text--PACKT-">cd</code> into the submodule directory and execute <code class="Code-In-Text--PACKT-">git pull</code> and then <code class="Code-In-Text--PACKT-">git checkout master</code> to restore the master branch. Using this technique, you may checkout any branch from your project and submit PRs.</p>
    </div>
    <p class="normal">Now that we have our submodule ready, let's see how the server project is configured.</p>
    <h3 class="title" id="_idParaDest-355">Configuring a Node project with TypeScript</h3>
    <p class="normal">To create <a id="_idIndexMarker1129"/>a new Node.js application <a id="_idIndexMarker1130"/>using TypeScript, perform the following steps:</p>
    <div class="note">
      <p class="Information-Box--PACKT-">The following steps are only relevant if you are creating a new server project. I recommend that you use the one already provided in the <code class="Code-In-Text--PACKT-">lemon-mart-server</code> project that you cloned from GitHub.</p>
    </div>
    <ol>
      <li class="list" value="1">Create a sub-folder <code class="Code-In-Text--PACKT-">server</code>:
        <pre class="programlisting"><code class="hljs routeros">$ mkdir<span class="hljs-built_in"> server
</span></code></pre>
      </li>
      <li class="list">Change your current directory to the <code class="Code-In-Text--PACKT-">server</code> folder:
        <pre class="programlisting"><code class="hljs routeros">$ cd<span class="hljs-built_in"> server
</span></code></pre>
      </li>
      <li class="list">Initialize npm to set up <code class="Code-In-Text--PACKT-">package.json</code> in the <code class="Code-In-Text--PACKT-">server</code> folder:
        <pre class="programlisting"><code class="hljs coffeescript">$ <span class="hljs-built_in">npm</span> init -y
</code></pre>
        <div class="packt_tip">
          <p class="Tip-Within-Bullet--PACKT-">Note that the top-level <code class="Code-In-Text--PACKT-">package.json</code> will be utilized for scripts that are relevant to the full-stack project. <code class="Code-In-Text--PACKT-">server/package.json</code> will contain scripts and dependencies for the backend project.</p>
        </div>
      </li>
      <li class="list" value="4">Configure your repository using <code class="Code-In-Text--PACKT-">mrm-task-typescript-vscode</code>:
        <pre class="programlisting"><code class="hljs elixir"><span class="hljs-variable">$ </span>npm i -g mrm-task-typescript-vscode
<span class="hljs-variable">$ </span>npx mrm typescript-vscode
</code></pre>
      </li>
    </ol>
    <p class="normal">The <code class="Code-In-Text--PACKT-">mrm</code> task <a id="_idIndexMarker1131"/>configures VS Code for <a id="_idIndexMarker1132"/>an optimized TypeScript development experience, similar to the way we did using <code class="Code-In-Text--PACKT-">mrm-task-angular-vscode</code> in <em class="italics">Chapter 2</em>, <em class="italics">Setting Up Your Development Environment</em>.</p>
    <p class="normal">When the command has finished executing, the <code class="Code-In-Text--PACKT-">project</code> folder appears as shown here:</p>
    <pre class="programlisting"><code class="hljs css"><span class="hljs-selector-tag">server</span>
│   <span class="hljs-selector-class">.gitignore</span>
│   <span class="hljs-selector-class">.nycrc</span>
│   <span class="hljs-selector-class">.prettierignore</span>
│   <span class="hljs-selector-class">.prettierrc</span>
│   <span class="hljs-selector-tag">example</span><span class="hljs-selector-class">.env</span>
│   <span class="hljs-selector-tag">jasmine</span><span class="hljs-selector-class">.json</span>
│   <span class="hljs-selector-tag">package-lock</span><span class="hljs-selector-class">.json</span>
│   <span class="hljs-selector-tag">package</span><span class="hljs-selector-class">.json</span>
│   <span class="hljs-selector-tag">pull_request_template</span><span class="hljs-selector-class">.md</span>
│   <span class="hljs-selector-tag">tsconfig</span><span class="hljs-selector-class">.json</span>
│   <span class="hljs-selector-tag">tsconfig</span><span class="hljs-selector-class">.src</span><span class="hljs-selector-class">.json</span>
│   <span class="hljs-selector-tag">tslint</span><span class="hljs-selector-class">.json</span>
│
├───<span class="hljs-selector-class">.vscode</span>
│       <span class="hljs-selector-tag">extensions</span><span class="hljs-selector-class">.json</span>
│       <span class="hljs-selector-tag">launch</span><span class="hljs-selector-class">.json</span>
│       <span class="hljs-selector-tag">settings</span><span class="hljs-selector-class">.json</span>
│
├───<span class="hljs-selector-tag">src</span>
│       <span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.ts</span>
│
└───<span class="hljs-selector-tag">tests</span>
│       <span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.spec</span><span class="hljs-selector-class">.ts</span>
│       <span class="hljs-selector-tag">tsconfig</span><span class="hljs-selector-class">.spec</span><span class="hljs-selector-class">.json</span>
</code></pre>
    <p class="normal">The task <a id="_idIndexMarker1133"/>configures the following:</p>
    <ul>
      <li class="list">Common <a id="_idIndexMarker1134"/>npm packages used for scripting: cross-conf-env (<a href="https://www.npmjs.com/package/cross-conf-env"><span class="url">https://www.npmjs.com/package/cross-conf-env</span></a>), npm-run-all (<a href="https://www.npmjs.com/package/npm-run-all"><span class="url">https://www.npmjs.com/package/npm-run-all</span></a>), dev-norms (<a href="https://www.npmjs.com/package/dev-norms"><span class="url">https://www.npmjs.com/package/dev-norms</span></a>), and rimraf (<a href="https://www.npmjs.com/package/rimraf"><span class="url">https://www.npmjs.com/package/rimraf</span></a>)</li>
      <li class="list">Npm <a id="_idIndexMarker1135"/>scripts for styling, linting, building, and testing:<ul>
          <li class="Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">style</code> and <code class="Code-In-Text--PACKT-">lint</code>: Check compliance in code styling and linting errors. They are intended for CI server usage.</li>
          <li class="Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">style:fix</code> and <code class="Code-In-Text--PACKT-">lint:fix</code>: Apply code styling and linting rules to the code. Not all linting errors can be fixed automatically. You will need to address each error by hand.</li>
          <li class="Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">build</code>: Transpiles the code into the <code class="Code-In-Text--PACKT-">dist</code> folder.</li>
          <li class="Bullet-Within-Bullet-End--PACKT-"><code class="Code-In-Text--PACKT-">start</code>: Runs the transpiled code in Node.js.</li>
        </ul>
        <div class="packt_tip">
          <p class="Tip-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">prepublishOnly</code> and <code class="Code-In-Text--PACKT-">prepare</code> scripts are only relevant if you're developing an npm package. In that case, you should also implement a <code class="Code-In-Text--PACKT-">.npmignore</code> file, which excludes the <code class="Code-In-Text--PACKT-">src</code> and <code class="Code-In-Text--PACKT-">tests</code> folders.</p>
        </div>
      </li>
      <li class="list"><code class="Code-In-Text--PACKT-">ImportSort</code>: Maintains the order of the <code class="Code-In-Text--PACKT-">import</code> statements:<ul>
          <li class="Bullet-Within-Bullet--PACKT-">Settings are added to <code class="Code-In-Text--PACKT-">package.json</code></li>
          <li class="Bullet-Within-Bullet-End--PACKT-">Supporting npm packages are installed: import-sort, import-sort-cli, import-sort-parser-typescript, and import-sort-style-module</li>
        </ul>
      </li>
      <li class="list">TypeScript with tslint:<ul>
          <li class="Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">tsconfig.json</code>: Common TypeScript settings</li>
          <li class="Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">tsconfig.src.json</code>: Settings that are specific to the source code under the <code class="Code-In-Text--PACKT-">src</code> folder</li>
          <li class="Bullet-Within-Bullet-End--PACKT-"><code class="Code-In-Text--PACKT-">tslint.json</code>: Linting rules</li>
        </ul>
      </li>
      <li class="list">The Prettier plugin, which automatically formats the styling of our code:<ul>
          <li class="Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">.prettierrc</code>: Prettier settings</li>
          <li class="Bullet-Within-Bullet-End--PACKT-"><code class="Code-In-Text--PACKT-">.prettierignore</code>: Files to ignore</li>
        </ul>
      </li>
      <li class="list">Jasmine <a id="_idIndexMarker1136"/>and nyc for <a id="_idIndexMarker1137"/>unit testing and code coverage:<ul>
          <li class="Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">jasmine.json</code>: Testing settings.</li>
          <li class="Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">.nycrc</code>: Code coverage settings.</li>
          <li class="Bullet-Within-Bullet--PACKT-">The <code class="Code-In-Text--PACKT-">tests</code> folder: Contains <code class="Code-In-Text--PACKT-">spec.ts</code> files, which include your tests and <code class="Code-In-Text--PACKT-">tsconfig.spec.json</code>, which configures more relaxed settings that make it easier to write tests quickly.</li>
          <li class="Bullet-Within-Bullet-End--PACKT-">In <code class="Code-In-Text--PACKT-">package.json</code>: Test scripts are created to build your tests using <code class="Code-In-Text--PACKT-">build:test</code> and execute them with <code class="Code-In-Text--PACKT-">npm test</code>. The <code class="Code-In-Text--PACKT-">test:ci</code> command is intended for CI servers and <code class="Code-In-Text--PACKT-">test:nyc</code> provides the code coverage report.</li>
        </ul>
      </li>
      <li class="list"><code class="Code-In-Text--PACKT-">example.env</code>: Used to document required environment variables that would be present in your private <code class="Code-In-Text--PACKT-">.env</code> file<ul>
          <li class="Bullet-Within-Bullet-End--PACKT-"><code class="Code-In-Text--PACKT-">.env</code> is added to <code class="Code-In-Text--PACKT-">.gitignore</code></li>
        </ul>
      </li>
      <li class="list">PR template: A pull request template that requests additional information from developers</li>
      <li class="list">VS Code extensions, settings, and debugging configurations, respectively, in three files:<ul>
          <li class="Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">.vscode/extensions.json</code></li>
          <li class="Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">.vscode/settings.json</code></li>
          <li class="Bullet-Within-Bullet-End--PACKT-"><code class="Code-In-Text--PACKT-">.vscode/launch.json</code></li>
        </ul>
      </li>
    </ul>
    <p class="normal">Once you are comfortable with the changes introduced to your project, verify that your project is in working order.</p>
    <p class="normal">Verify the project by executing the tests: </p>
    <pre class="programlisting"><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm <span class="hljs-built_in">test</span></span>
</code></pre>
    <p class="normal">Before the <code class="Code-In-Text--PACKT-">test</code> command is run, <code class="Code-In-Text--PACKT-">npm run build &amp;&amp; npm run build:test</code> is executed to transpile our TypeScript code to JavaScript. The output is placed in the <code class="Code-In-Text--PACKT-">dist</code> folder, as shown:</p>
    <pre class="programlisting"><code class="hljs axapta"><span class="hljs-keyword">server</span>
│
├───dist
│       <span class="hljs-keyword">index</span>.js
│       <span class="hljs-keyword">index</span>.js.map
</code></pre>
    <div class="packt_tip">
      <p>Note that on your filesystem,<code class="Code-In-Text--PACKT-">.js</code> and <code class="Code-In-Text--PACKT-">.js.map</code> files are created alongside every <code class="Code-In-Text--PACKT-">.ts</code> file. In <code class="Code-In-Text--PACKT-">.vscode/settings.json</code>, we configure the <code class="Code-In-Text--PACKT-">files.exclude</code> property to hide these files in the IDE so that they don't distract developers during development. Additionally, in <code class="Code-In-Text--PACKT-">.gitignore</code>, we also ignore <code class="Code-In-Text--PACKT-">.js</code> and <code class="Code-In-Text--PACKT-">.js.map</code> files, so they don't get checked into our repository.</p>
    </div>
    <p class="normal">Now that <a id="_idIndexMarker1138"/>we have a barebones monorepo, we <a id="_idIndexMarker1139"/>can configure our CI server.</p>
    <h3 class="title" id="_idParaDest-356">CircleCI config</h3>
    <p class="normal">One of the <a id="_idIndexMarker1140"/>benefits of using Git submodules is that we can verify <a id="_idIndexMarker1141"/>that our frontend and backend works in the same pipeline. We will implement two jobs:</p>
    <ol>
      <li class="list" value="1"><code class="Code-In-Text--PACKT-">build_server</code></li>
      <li class="list" value="2"><code class="Code-In-Text--PACKT-">build_webapp</code></li>
    </ol>
    <p class="normal">These jobs will follow the workflow shown here: </p>
    <pre class="programlisting"><code class="hljs yaml"><strong><span class="hljs-string">.circleci/config.yml</span></strong>
<span class="hljs-string">...</span>
<span class="hljs-attr">workflows:</span>
  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span>
  <span class="hljs-attr">build-and-test-compose:</span>
    <span class="hljs-attr">jobs:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">build_server</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">build_webapp</span>
</code></pre>
    <p class="normal">The CI pipeline will build the server and the web app simultaneously, with an option to run the <code class="Code-In-Text--PACKT-">deploy</code> job if the jobs succeed on the master branch. Refer to the <code class="Code-In-Text--PACKT-">config.yml</code> file on GitHub on how to implement the <code class="Code-In-Text--PACKT-">build_webapp</code> job, which is similar to the one you implemented in <em class="italics">Chapter 9</em>, <em class="italics">DevOps Using Docker</em>, but that includes a number of subtle differences to handle working with submodules and the folder structure changes. The pipeline for building the server is not too dissimilar to the web app one, as shown here:</p>
    <pre class="programlisting"><code class="hljs routeros"><strong>.circleci/config.yml</strong>
version: 2.1
orbs:
  coveralls: coveralls/coveralls@1.0.4
jobs:
  build_server:
    docker:
      - image: circleci/node:lts
    working_directory: ~/repo<span class="hljs-built_in">/server
</span>    steps:
      - checkout:
          path: ~/repo
      - restore_cache:
          keys:
            - web-modules-{{ checksum <span class="hljs-string">"package-lock.json"</span> }}
      # check npm dependencies <span class="hljs-keyword">for</span> security risks - <span class="hljs-string">'npm audit'</span> <span class="hljs-keyword">to</span> fix
      - run: npx audit-ci --high --report-type full
      - run: npm ci
      - save_cache:
          key: web-modules-{{ checksum <span class="hljs-string">"package-lock.json"</span> }}
          paths:
            - ~/.npm
      - run: npm <span class="hljs-builtin-name">run</span> style
      - run: npm <span class="hljs-builtin-name">run</span> lint
      # <span class="hljs-builtin-name">run</span> tests <span class="hljs-keyword">and</span> store test results
      - run: npm <span class="hljs-builtin-name">run</span> pretest
      - run: npm <span class="hljs-builtin-name">run</span> test:ci
      - store_test_results:
          path: ./test_results
      # <span class="hljs-builtin-name">run</span> code coverage <span class="hljs-keyword">and</span> store coverage report
      - run: npm <span class="hljs-builtin-name">run</span> test:nyc
      - store_artifacts:
          path: ./coverage
      - coveralls/upload
      - run:
          name: Move compiled app <span class="hljs-keyword">to</span> workspace
          command: |
            <span class="hljs-builtin-name">set</span> -exu
            mkdir -p /tmp/workspace<span class="hljs-built_in">/server
</span>            mv dist /tmp/workspace<span class="hljs-built_in">/server
</span>      - persist_to_workspace:
          root: /tmp/workspace
          paths:
            -<span class="hljs-built_in"> server
</span></code></pre>
    <p class="normal">The pipeline checks <a id="_idIndexMarker1142"/>out the code, verifies the security of the packages we're using with <code class="Code-In-Text--PACKT-">audit-ci</code>, installs dependencies, checks for styling and linting errors, runs tests, and checks for code coverage levels.</p>
    <p class="normal">The test <a id="_idIndexMarker1143"/>commands implicitly build the server code, which is stored under the <code class="Code-In-Text--PACKT-">dist</code> folder. In the final step, we move the <code class="Code-In-Text--PACKT-">dist</code> folder into the workspace so that we can use it at a later stage.</p>
    <p class="normal">Next, let's see how we can bring together all tiers of our app and run it using Docker Compose.</p>
    <h2 class="title" id="_idParaDest-357">Docker Compose</h2>
    <p class="normal">Since we have a three-tiered architecture, we need a convenient way to set up the infrastructure <a id="_idIndexMarker1144"/>for our full-stack application. You can create scripts to start various Docker containers individually, but there's a purpose-built tool that runs multi-container applications called Docker Compose. Compose <a id="_idIndexMarker1145"/>uses a YAML file format, named <code class="Code-In-Text--PACKT-">docker-compose.yml</code>, so you declaratively define the configuration of your application. Compose allows you to adhere to infrastructure-as-code principles. Compose will also allow us to conveniently start a database instance without having to install a permanent and always-on database solution in our development environments.</p>
    <p class="normal">You can use Compose to deploy your application on cloud services, scale the number of container instances you're running, and even run integration tests of your application on your CI server. Later in this section, we go over how you can run Docker Compose on CircleCI.</p>
    <p class="normal">Consider the architecture of the following application with the communication port of each tier:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_10_03.png"/></figure>
    <p class="packt_figref">Figure 10.3: Lemon Mart three-tier architecture</p>
    <p class="normal">Using <a id="_idIndexMarker1146"/>Docker Compose, we are able to describe the <a id="_idIndexMarker1147"/>architecture shown here precisely. You can read more about Compose at <a href="https://docs.docker.com/compose/"><span class="url">https://docs.docker.com/compose/</span></a>.</p>
    <p class="normal">Next, let's implement a more efficient web server for Lemon Mart.</p>
    <h3 class="title" id="_idParaDest-358">Using Nginx as the web server</h3>
    <p class="normal">Our web app is <a id="_idIndexMarker1148"/>already containerized as covered in <em class="italics">Chapter 9</em>, <em class="italics">DevOps Using Docker</em>. For this exercise, we will use the nginx-based container.</p>
    <p class="normal">Add a new Dockerfile named <code class="Code-In-Text--PACKT-">nginx.Dockerfile</code> to the root of your <code class="Code-In-Text--PACKT-">web-app</code>. This image will be smaller than the Node-based one we have, since we're using nginx as the web server:</p>
    <pre class="programlisting"><code class="hljs dockerfile"><strong>web-app/nginx.Dockerfile</strong>
<span class="hljs-keyword">FROM</span> duluca/minimal-nginx-web-server:<span class="hljs-number">1</span>-alpine
<span class="hljs-keyword">COPY</span><span class="bash"> dist/lemon-mart /var/www</span>
<span class="hljs-keyword">CMD</span><span class="bash"> <span class="hljs-string">'nginx'</span></span>
</code></pre>
    <p class="normal">Now, let's containerize our server.</p>
    <h3 class="title" id="_idParaDest-359">Containerizing the server</h3>
    <p class="normal">So far, we have <a id="_idIndexMarker1149"/>been using mostly preconfigured Docker images to deploy our web app. The following is a more detailed implementation of a Node.js-based server:</p>
    <div class="packt_tip">
      <p>If you need it, refer to the <em class="italics">Containerizing the app using Docker</em> section in <em class="italics">Chapter 9</em>, <em class="italics">DevOps Using Docker</em>, as a refresher on Docker.</p>
    </div>
    <ol>
      <li class="list" value="1">Let's begin by defining the <code class="Code-In-Text--PACKT-">Dockerfile</code>:
        <pre class="programlisting"><code class="hljs dockerfile"><strong>server/Dockerfile</strong>
<span class="hljs-keyword">FROM</span> node:lts-alpine
<span class="hljs-keyword">RUN</span><span class="bash"> apk add --update --no-progress make python bash</span>
<span class="hljs-keyword">ENV</span> NPM_CONFIG_LOGLEVEL error
<span class="hljs-keyword">ADD</span><span class="bash"> https://github.com/Yelp/dumb-init/releases/download/v1.2.2/dumb-init_1.2.2_amd64 /usr/<span class="hljs-built_in">local</span>/bin/dumb-init</span>
<span class="hljs-keyword">RUN</span><span class="bash"> chmod +x /usr/<span class="hljs-built_in">local</span>/bin/dumb-init</span>
<span class="hljs-keyword">RUN</span><span class="bash"> mkdir -p /usr/src/app</span>
<span class="hljs-keyword">RUN</span><span class="bash"> chown node: /usr/src/app</span>
<span class="hljs-keyword">USER</span> node
<span class="hljs-keyword">WORKDIR</span><span class="bash"> /usr/src/app</span>
<span class="hljs-keyword">COPY</span><span class="bash"> package*.json ./</span>
<span class="hljs-keyword">RUN</span><span class="bash"> NODE_ENV=production</span>
<span class="hljs-keyword">RUN</span><span class="bash"> npm install --only=production</span>
<span class="hljs-keyword">ENV</span> HOST <span class="hljs-string">"0.0.0.0"</span>
<span class="hljs-keyword">ENV</span> PORT <span class="hljs-number">3000</span>
<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3000</span>
<span class="hljs-keyword">ADD</span><span class="bash"> dist dist</span>
<span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">"dumb-init"</span>, <span class="hljs-string">"--"</span>]</span>
<span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">"node"</span>, <span class="hljs-string">"dist/src/index"</span>]</span>
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Note that we ADD the <code class="Code-In-Text--PACKT-">dist</code> folder to our server and then run it using nodes with CMD.</p>
        <div class="packt_tip">
          <p>You can read more about how our server container is configured by checking out <code class="Code-In-Text--PACKT-">README.md</code> on the <a id="_idIndexMarker1150"/>similarly configured <code class="Code-In-Text--PACKT-">minimal-node-web-server</code> repo at <a href="https://github.com/duluca/minimal-node-web-server"><span class="url">https://github.com/duluca/minimal-node-web-server</span></a>.</p>
        </div>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Now, set up the cross-environment, <strong class="bold">npm scripts for Docker</strong>, which works on Windows 10 and macOS for our server.</p>
      </li>
      <li class="list">Install the npm scripts for the Docker task:
        <pre class="programlisting"><code class="hljs coffeescript">$ <span class="hljs-built_in">npm</span> i -g mrm-task-<span class="hljs-built_in">npm</span>-docker
</code></pre>
      </li>
      <li class="list">Apply the <a id="_idIndexMarker1151"/>npm scripts for Docker configuration, making sure to execute the command in the <code class="Code-In-Text--PACKT-">server</code> folder:
        <pre class="programlisting"><code class="hljs coffeescript">$ npx mrm <span class="hljs-built_in">npm</span>-docker
</code></pre>
      </li>
      <li class="list">Configure your <code class="Code-In-Text--PACKT-">package.json</code> with the configuration parameters:
        <pre class="programlisting"><code class="hljs pgsql"><strong><span class="hljs-keyword">server</span>/package.json</strong>
  "config": {
    "imageRepo": "duluca/lemon-mart-server",
    "imageName": "lemon-mart-server",
    "imagePort": "3000",
    "internalContainerPort": "3000"
  }
</code></pre>
      </li>
    </ol>
    <p class="normal">Be sure to build your app before building your Docker container.</p>
    <h3 class="title" id="_idParaDest-360">Configuring environment variables with DotEnv</h3>
    <p class="normal">DotEnv <a id="_idIndexMarker1152"/>files are widely supported to store secrets conveniently in a <code class="Code-In-Text--PACKT-">.env</code> file that is not checked in to your code repository. Docker and Compose natively support <code class="Code-In-Text--PACKT-">.env</code> files. </p>
    <p class="normal">Let's start by understanding the environment variables at the heart of the monorepo:</p>
    <ol>
      <li class="list" value="1">Refer to the <code class="Code-In-Text--PACKT-">example.env</code> file at the root of the project:
        <pre class="programlisting"><code class="hljs routeros"><strong>example.env</strong>
<span class="hljs-comment"># Root database admin credentials</span>
<span class="hljs-attribute">MONGO_INITDB_ROOT_USERNAME</span>=admin
<span class="hljs-attribute">MONGO_INITDB_ROOT_PASSWORD</span>=anAdminPasswordThatIsNotThis
<span class="hljs-comment"># Your application's database connection information. </span>
<span class="hljs-comment"># Corresponds to MONGO_URI on server-example.env</span>
<span class="hljs-attribute">MONGODB_APPLICATION_DATABASE</span>=lemon-mart
<span class="hljs-attribute">MONGODB_APPLICATION_USER</span>=john.smith
<span class="hljs-attribute">MONGODB_APPLICATION_PASS</span>=g00fy
<span class="hljs-comment"># Needed for AWS deployments</span>
<span class="hljs-attribute">AWS_ACCESS_KEY_ID</span>=xxxxxx
<span class="hljs-attribute">AWS_SECRET_ACCESS_KEY</span>=xxxxxx
<span class="hljs-comment"># See server-example.env for server environment variables</span>
</code></pre>
        <div class="packt_tip">
          <p class="Tip-Within-Bullet--PACKT-">Don't store any real secrets in <code class="Code-In-Text--PACKT-">example.env</code>. Store them in the <code class="Code-In-Text--PACKT-">.env</code> file. <code class="Code-In-Text--PACKT-">example.env</code> is there to document the environment variables that are required for your project. In this case, I've populated my <code class="Code-In-Text--PACKT-">example.env</code> file with sample values so that readers can run the example without having to configure all these parameters.</p>
        </div>
      </li>
      <li class="list">Ensure <a id="_idIndexMarker1153"/>that <code class="Code-In-Text--PACKT-">init-dev-env</code> is installed in the root of the project by executing:
        <pre class="programlisting"><code class="hljs coffeescript">$ <span class="hljs-built_in">npm</span> i -D init-dev-env
</code></pre>
      </li>
      <li class="list">The <code class="Code-In-Text--PACKT-">npm run init:env</code> script generates <code class="Code-In-Text--PACKT-">.env</code> files based on the <code class="Code-In-Text--PACKT-">example.env</code> file using the <code class="Code-In-Text--PACKT-">init-dev-env</code> package:<div class="note">
          <p class="Information-Box--PACKT-">In <strong class="bold">lemon-mart-server</strong> the <code class="Code-In-Text--PACKT-">example.env</code> file for the server exists in two places. First in the root of the project as <code class="Code-In-Text--PACKT-">server-example.env</code> and second under <code class="Code-In-Text--PACKT-">server/example.env</code>. This is done to increase the visibility of the sample configuration settings.</p>
        </div>
        <pre class="programlisting"><code class="hljs verilog">$ npx init-dev-env <span class="hljs-keyword">generate</span>-dot-env example<span class="hljs-variable">.env</span> -f &amp;&amp; 
init-dev-env <span class="hljs-keyword">generate</span>-dot-env server-example<span class="hljs-variable">.env</span> --source=. --target=server -f
</code></pre>
      </li>
      <li class="list" value="4">The second <code class="Code-In-Text--PACKT-">.env</code> file is generated for the server as shown:
        <pre class="programlisting"><code class="hljs routeros"><strong>server/.env</strong>
<span class="hljs-comment"># MongoDB connection string as defined in example.env</span>
<span class="hljs-attribute">MONGO_URI</span>=mongodb://john.smith:g00fy@localhost:27017/lemon-mart
<span class="hljs-comment"># Secret used to generate a secure JWT</span>
<span class="hljs-attribute">JWT_SECRET</span>=aSecureStringThatIsNotThis
<span class="hljs-comment"># DEMO User Login Credentials</span>
<span class="hljs-attribute">DEMO_EMAIL</span>=duluca@gmail.com
<span class="hljs-attribute">DEMO_PASSWORD</span>=l0l1pop!!
<span class="hljs-attribute">DEMO_USERID</span>=5da01751da27cc462d265913
</code></pre>
      </li>
    </ol>
    <div class="packt_tip">
      <p>Note that this file contains the connection string to MongoDB, the secret we will use to encrypt our JWTs, and a seed user so that we can log in to the application. Normally, you wouldn't configure a password or a user ID for your seed users. These are only here to support repeatable demo code. </p>
    </div>
    <p class="normal">Now, we're <a id="_idIndexMarker1154"/>ready to define the YAML file for Compose.</p>
    <h3 class="title" id="_idParaDest-361">Define Docker-Compose YAML</h3>
    <p class="normal">Let's <a id="_idIndexMarker1155"/>define a <code class="Code-In-Text--PACKT-">docker-compose.yml</code> file in the root of the monorepo to reflect our architecture: </p>
    <pre class="programlisting"><code class="hljs routeros"><strong>docker-compose.yml</strong>
version: <span class="hljs-string">'3.7'</span>
services:
  web-app:
    container_name: web
    build:
      context: ./web-app
      dockerfile: nginx.Dockerfile
    ports:
      - <span class="hljs-string">'8080:80'</span>
    links:
      -<span class="hljs-built_in"> server
</span>    depends_on:
      -<span class="hljs-built_in"> server
</span>  server:
    container_name: lemon-mart-server
    build:<span class="hljs-built_in"> server
</span>    env_file: ./server/.env
    environment:
      - <span class="hljs-attribute">MONGO_URI</span>=mongodb://john.smith:g00fy@lemondb:27017/lemon-mart
    ports:
      - <span class="hljs-string">'3000:3000'</span>
    links:
      - database
    depends_on:
      - database
  database:
    container_name: lemondb
    image: duluca/minimal-mongo:4.2.2
    restart: always
    env_file: .env
    ports:
      - <span class="hljs-string">'27017:27017'</span>
    volumes:
      - <span class="hljs-string">'dbdata:/data/db'</span>
volumes:
  dbdata:
</code></pre>
    <p class="normal">At the top, we build the <code class="Code-In-Text--PACKT-">web-app</code> service using the nginx-based container. The <code class="Code-In-Text--PACKT-">build</code> property automatically builds the <code class="Code-In-Text--PACKT-">Dockerfile</code> for us. We are exposing the <code class="Code-In-Text--PACKT-">web-app</code> on port <code class="Code-In-Text--PACKT-">8080</code> and linking it to the <code class="Code-In-Text--PACKT-">server</code> service. The <code class="Code-In-Text--PACKT-">links</code> property creates an isolated Docker <a id="_idIndexMarker1156"/>network to ensure that our containers can communicate with each other. By using the <code class="Code-In-Text--PACKT-">depends_on</code> property, we ensure that the server is started before the <code class="Code-In-Text--PACKT-">web-app</code> is started.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">server</code> also uses the <code class="Code-In-Text--PACKT-">build</code> property for an automatic <code class="Code-In-Text--PACKT-">Dockerfile</code> build. It also uses the <code class="Code-In-Text--PACKT-">env_file</code> property to load environment variables from the <code class="Code-In-Text--PACKT-">.env</code> file under the <code class="Code-In-Text--PACKT-">server</code> folder. Using the <code class="Code-In-Text--PACKT-">environment</code> property, we override the <code class="Code-In-Text--PACKT-">MONGO_URI</code> variable to use the internal Docker network name for the database container. The server both <code class="Code-In-Text--PACKT-">links</code> and <code class="Code-In-Text--PACKT-">depends_on</code> the database, which is named <code class="Code-In-Text--PACKT-">lemondb</code>.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">database</code> service pulls the <code class="Code-In-Text--PACKT-">duluca/minimal-mongo</code> image from Docker Hub. Using the <code class="Code-In-Text--PACKT-">restart</code> property, we ensure that the database will automatically restart if it crashes. We use the setup parameters within the <code class="Code-In-Text--PACKT-">.env</code> file to configure and password-protect the database. Using the <code class="Code-In-Text--PACKT-">volumes</code> property, we mount the database's storage directory to a local directory so that your data can persist across container reboots.</p>
    <div class="packt_tip">
      <p>In a cloud environment, you can mount the volume of your database to your cloud provider's <a id="_idIndexMarker1157"/>persistence solution, including AWS <strong class="bold">Elastic File System</strong> (<strong class="bold">EFS</strong>) or Azure File Storage.</p>
    </div>
    <p class="normal">Additionally, we define a Docker volume named <code class="Code-In-Text--PACKT-">dbdata</code> for data storage.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Occasionally, your database may stop working correctly. This can happen if you upgrade your container, use a different container, or use the same volume in another project. In this instance, you can reset the state of your Docker setup by executing the following command:</p>
      <pre class="programlisting"><code class="hljs elixir">  <span class="hljs-variable">$ </span>docker image prune
  <span class="hljs-variable">$ </span>docker container prune
  <span class="hljs-variable">$ </span>docker volume prune
</code></pre>
      <p class="normal">or</p>
      <pre class="programlisting"><code class="hljs routeros">  $ docker<span class="hljs-built_in"> system </span>prune --volumes <strong>(this will delete everything)</strong>
</code></pre>
    </div>
    <p class="normal">To run your infrastructure, you will be executing the <code class="Code-In-Text--PACKT-">docker-compose up</code> command. You can <a id="_idIndexMarker1158"/>also use the <code class="Code-In-Text--PACKT-">-d</code> option to your infrastructure in detached mode. You stop it with the <code class="Code-In-Text--PACKT-">down</code> command and remove the containers it creates by means of the <code class="Code-In-Text--PACKT-">rm</code> command.</p>
    <p class="normal">Before you can run your infrastructure, you will need to build your application, which is covered in the next section.</p>
    <h3 class="title" id="_idParaDest-362">Orchestrating the Compose launch</h3>
    <p class="normal">Running <code class="Code-In-Text--PACKT-">docker-compose up</code> is a convenient and simple way to start your infrastructure. However, you need your code to be built before building your containers. It is an <a id="_idIndexMarker1159"/>easy step to overlook. Refer to some npm scripts that you can use to orchestrate the launch of your infrastructure:</p>
    <pre class="programlisting"><code class="hljs actionscript"><strong><span class="hljs-class"><span class="hljs-keyword">package</span>.<span class="hljs-title">json</span></span></strong><span class="hljs-class">
<span class="hljs-title">scripts</span>: {</span>
  <span class="hljs-string">"build"</span>: <span class="hljs-string">"npm run build --prefix ./server &amp;&amp; npm run build --prefix ./web-app -- --configuration=lemon-mart-server"</span>,
  <span class="hljs-string">"test"</span>: <span class="hljs-string">"npm test --prefix ./server &amp;&amp; npm test --prefix ./web-app -- --watch=false"</span>,
  <span class="hljs-string">"prestart"</span>: <span class="hljs-string">"npm run build &amp;&amp; docker-compose build"</span>,
  <span class="hljs-string">"start"</span>: <span class="hljs-string">"docker-compose up"</span>,
  <span class="hljs-string">"stop"</span>: <span class="hljs-string">"docker-compose down"</span>,
  <span class="hljs-string">"clean"</span>: <span class="hljs-string">"docker-compose rm"</span>,
  <span class="hljs-string">"clean:all"</span>: <span class="hljs-string">"docker system prune --volumes"</span>,
  <span class="hljs-string">"start:backend"</span>: <span class="hljs-string">"docker-compose -f docker-compose.backend.yml up --build"</span>,
  <span class="hljs-string">"start:database"</span>: <span class="hljs-string">"docker-compose -f docker-compose.database.yml up --build"</span>,
</code></pre>
    <p class="normal">We implemented a <code class="Code-In-Text--PACKT-">build</code> script that runs the <code class="Code-In-Text--PACKT-">build</code> commands for the server and the web app. A <code class="Code-In-Text--PACKT-">test</code> script can do the same for executing tests. We implemented an <code class="Code-In-Text--PACKT-">npm start</code> command that can automatically run the <code class="Code-In-Text--PACKT-">build</code> command and run <code class="Code-In-Text--PACKT-">compose up</code>. As a bonus, we also implemented <code class="Code-In-Text--PACKT-">start:backend</code> and <code class="Code-In-Text--PACKT-">start:database</code> scripts that can run alternate <code class="Code-In-Text--PACKT-">docker-compose</code> files to stand up just the server or the database. You may create these files by removing the unnecessary parts of the master <code class="Code-In-Text--PACKT-">docker-compose.yml</code> file. Refer to the GitHub repo for examples.</p>
    <div class="packt_tip">
      <p>When coding on the server, I normally execute <code class="Code-In-Text--PACKT-">npm run start:database</code> to stand up the database and, in a separate terminal window, I launch the server using <code class="Code-In-Text--PACKT-">npm start</code> from the <code class="Code-In-Text--PACKT-">server</code> folder. This way, I can see logs being generated by both systems side by side.</p>
    </div>
    <p class="normal">Execute <code class="Code-In-Text--PACKT-">npm start</code> to <a id="_idIndexMarker1160"/>verify that your <code class="Code-In-Text--PACKT-">docker-compose</code> configuration is working. Hit <em class="italics">Ctrl</em> + <em class="italics">C</em> to stop the infrastructure.</p>
    <h3 class="title" id="_idParaDest-363">Compose on CircleCI</h3>
    <p class="normal">You can <a id="_idIndexMarker1161"/>execute your Compose infrastructure on CircleCI to verify the correctness of your configuration and run a quick integration test. Refer to the following updated workflow:</p>
    <pre class="programlisting"><code class="hljs yaml"><strong><span class="hljs-string">.circleci/config.yml</span></strong>
<span class="hljs-attr">workflows:</span>
  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span>
  <span class="hljs-attr">build-and-test-compose:</span>
    <span class="hljs-attr">jobs:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">build_server</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">build_webapp</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">test_compose:</span>
          <span class="hljs-attr">requires:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">build_server</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">build_webapp</span>
</code></pre>
    <p class="normal">We ensure that both <code class="Code-In-Text--PACKT-">server</code> and <code class="Code-In-Text--PACKT-">web-app</code> are built before running a new job named <code class="Code-In-Text--PACKT-">test_compose</code>, which checks out the code, initializes the submodule, and copies the <code class="Code-In-Text--PACKT-">dist</code> folders of both builds, as shown here:</p>
    <pre class="programlisting"><code class="hljs dockerfile"><strong>.circleci/config.yml</strong>
  test_compose:
    docker:
      - image: circleci/node:lts-browsers
    working_directory: ~/repo
    steps:
      - setup_remote_docker
      - attach_workspace:
          at: /tmp/workspace
      - checkout:
          path: ~/repo
      - <span class="hljs-keyword">run</span><span class="bash">: npm run modules:init</span>
      - <span class="hljs-keyword">run</span><span class="bash">:</span>
          name: <span class="hljs-keyword">Copy</span><span class="bash"> built server to server/dist folder</span>
          command: cp -avR /tmp/workspace/server/dist/ ./server
      - <span class="hljs-keyword">run</span><span class="bash">:</span>
          name: <span class="hljs-keyword">Copy</span><span class="bash"> built web-app to web-app/dist folder</span>
          command: cp -avR /tmp/workspace/dist/ ./web-app
      - <span class="hljs-keyword">run</span><span class="bash">:</span>
          name: Restore .<span class="hljs-keyword">env</span> files
          command: |
            set +H
            echo -e $PROJECT_DOT_ENV &gt; .<span class="hljs-keyword">env</span>
            echo -e $SERVER_DOT_ENV &gt; server/.<span class="hljs-keyword">env</span>
      - <span class="hljs-keyword">run</span><span class="bash">:</span>
          name: Compose up
          command: |
            set -x
            docker-compose up -d
      - <span class="hljs-keyword">run</span><span class="bash">:</span>
          name: Verify web app
          command: |
            set -x
            docker <span class="hljs-keyword">run</span><span class="bash"> --network container:web jwilder/dockerize -<span class="hljs-built_in">wait</span> http://localhost:80</span>
            docker <span class="hljs-keyword">run</span><span class="bash"> --network container:web appropriate/curl http://localhost:80</span>
      - <span class="hljs-keyword">run</span><span class="bash">:</span>
          name: Verify db login with api
          command: |
            set -x
            docker <span class="hljs-keyword">run</span><span class="bash"> --network container:lemon-mart-server jwilder/dockerize -<span class="hljs-built_in">wait</span> http://localhost:3000</span>
            docker <span class="hljs-keyword">run</span><span class="bash"> --network container:lemon-mart-server appropriate/curl \
              -H <span class="hljs-string">"accept: application/json"</span> -H <span class="hljs-string">"Content-Type: application/json"</span> \
              -d <span class="hljs-string">"<span class="hljs-variable">$LOGIN_JSON</span>"</span> http://localhost:3000/v1/auth/login</span>
</code></pre>
    <p class="normal">After copying the <code class="Code-In-Text--PACKT-">dist</code> files, the job then lays down the <code class="Code-In-Text--PACKT-">.env</code> files from the CircleCI environment variables. Then, we run <code class="Code-In-Text--PACKT-">docker-compose up</code> to stand up our server. Next, we test the <code class="Code-In-Text--PACKT-">web-app</code> by running a <code class="Code-In-Text--PACKT-">curl</code> command to retrieve its <code class="Code-In-Text--PACKT-">index.html</code> file. We <code class="Code-In-Text--PACKT-">run curl</code> after waiting <a id="_idIndexMarker1162"/>for the server to become available using <code class="Code-In-Text--PACKT-">dockerize -wait</code>. Similarly, we test the integration of our API server and the database by logging in using our demo user.</p>
    <p class="normal">Congratulations! Now, you have a pretty good understanding of how our full stack architecture is pieced together at a high level. In the latter half of this chapter, we will go over how the API is implemented, how it integrates with the database, and see how JWT auth works in tandem with the API and database.</p>
    <p class="normal">Let's continue by diving into API design.</p>
    <h1 class="title" id="_idParaDest-364">RESTful APIs</h1>
    <p class="normal">In full stack development, nailing down the API design early on is important. The API design itself is <a id="_idIndexMarker1163"/>closely correlated with how your data contract will look. You may create RESTful endpoints or use the next-gen GraphQL technology. In designing your API, frontend and backend developers should collaborate closely to achieve shared design goals. Some high-level goals are listed as follows:</p>
    <ul>
      <li class="list">Minimize data transmitted between the client and server</li>
      <li class="list">Stick to well-established design patterns (in other words, data pagination)</li>
      <li class="list">Design to reduce business logic present in the client</li>
      <li class="list">Flatten data structures</li>
      <li class="list">Do not expose database keys or relationships </li>
      <li class="list">Version endpoints from the get-go</li>
      <li class="list">Design around major data entities</li>
    </ul>
    <p class="normal">You should aim to implement the business logic in your RESTful API. Ideally, your frontend shouldn't contain anything more than presentation logic. Any <code class="Code-In-Text--PACKT-">if</code> statement implemented by the frontend should also be verified in your backend.</p>
    <p class="normal">As discussed in <em class="italics">Chapter 1</em>, <em class="italics">Introduction to Angular and Its Concepts</em>, it is critical to aim for a stateless design in both the backend and frontend. Every request should utilize non-blocking I/O methods and should not rely on any existing session. This is the key to infinitely scaling your web application using cloud hosting providers.</p>
    <p class="normal">Whenever you're implementing a project, it is important to limit, if not eliminate, experimentation. This is especially true in full stack projects. The downstream effect of missteps in API design can be profound and impossible to correct once your application goes live.</p>
    <p class="normal">Next, let's look into designing an API around major data entities. In this case, we'll review the implementation of an API surrounding users, including authentication. First we'll explore how we can define an endpoint using Swagger, so we can concretely communicate the intent of our design to team members.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Remember that only significant pieces of code that are conceptually significant are covered in this chapter. While you may choose to implement this code from scratch, it is not necessary to get an understanding of how it works. If you choose to implement it from scratch, refer to the complete source code at <a href="https://github.com/duluca/lemon-mart-server"><span class="url">https://github.com/duluca/lemon-mart-server</span></a> to follow along and bridge the gaps in your implementation.</p>
    </div>
    <p class="normal">Later on, Swagger <a id="_idIndexMarker1164"/>will become a documentation tool, reflecting the capability of our APIs.</p>
    <h2 class="title" id="_idParaDest-365">API design with Swagger</h2>
    <p class="normal">Swagger will allow you to design and document your web API. For teams, it can act as a great <a id="_idIndexMarker1165"/>communication tool between <a id="_idIndexMarker1166"/>frontend and backend developers, thereby reducing a lot of friction. Additionally, defining your API surface early on allows implementation <a id="_idIndexMarker1167"/>to begin without worrying about late-stage integration challenges. </p>
    <p class="normal">We will implement a users API as we move on, so as to demonstrate how Swagger works.</p>
    <div class="packt_tip">
      <p>I highly recommend installing the Swagger Viewer VS Code extension, which allows us to preview the YAML file without running any additional tools.</p>
    </div>
    <p class="normal">Let's begin by exploring the <code class="Code-In-Text--PACKT-">swagger.yaml</code> file at the root of the monorepo:</p>
    <ol>
      <li class="list" value="1">Open <code class="Code-In-Text--PACKT-">swagger.yaml</code> in VS Code.</li>
      <li class="list">Install the VS Code extension called Swagger Preview.</li>
      <li class="list">Hit <em class="italics">Ctrl</em> + <em class="italics">Shift</em> + <em class="italics">P</em>, or <img alt="" src="../Images/B14094_10_15.png"/>+<img alt="" src="../Images/B14094_10_16.png"/>+<kbd class="Key--PACKT-">P</kbd>, to bring up the command palette and run <strong class="bold">Preview Swagger</strong>.</li>
      <li class="list" value="4">See the preview, as shown here:<figure class="mediaobject"><img alt="" src="../Images/B14094_10_04.png"/></figure>
        <p class="packt_figref">Figure 10.4: Swagger.yaml preview</p>
      </li>
    </ol>
    <p class="normal">Using the <a id="_idIndexMarker1168"/>Swagger UI view, you are going <a id="_idIndexMarker1169"/>to be able to try out commands and <a id="_idIndexMarker1170"/>execute them against your server environment.</p>
    <h3 class="title" id="_idParaDest-366">Defining a Swagger YAML file</h3>
    <p class="normal">We'll use <a id="_idIndexMarker1171"/>Swagger spec version <code class="Code-In-Text--PACKT-">openapi: 3.0.1</code>, which implements the OpenAPI standard. Let's go over the major components of the <code class="Code-In-Text--PACKT-">swagger.yaml</code> file here:</p>
    <div class="packt_tip">
      <p>For more <a id="_idIndexMarker1172"/>information about how a Swagger file is defined, refer to <a href="https://swagger.io/specification/"><span class="url">https://swagger.io/specification/</span></a>.</p>
    </div>
    <ol>
      <li class="list" value="1">The YAML file starts with general information and target servers:
        <pre class="programlisting"><code class="hljs yaml"><strong><span class="hljs-string">swagger.yaml</span></strong>
<span class="hljs-attr">openapi:</span> <span class="hljs-number">3.0</span><span class="hljs-number">.1</span>
<strong><span class="hljs-attr">info</span></strong><span class="hljs-attr">:</span>
  <span class="hljs-attr">title:</span> <span class="hljs-string">LemonMart</span>
  <span class="hljs-attr">description:</span> <span class="hljs-string">LemonMart</span> <span class="hljs-string">API</span>
  <span class="hljs-attr">version:</span> <span class="hljs-string">"2.0.0"</span>
<strong><span class="hljs-attr">servers</span></strong><span class="hljs-attr">:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">url:</span> <span class="hljs-string">http://localhost:3000</span>
    <span class="hljs-attr">description:</span> <span class="hljs-string">Local</span> <span class="hljs-string">environment</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">url:</span> <span class="hljs-string">https://mystagingserver.com</span>
    <span class="hljs-attr">description:</span> <span class="hljs-string">Staging</span> <span class="hljs-string">environment</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">url:</span> <span class="hljs-string">https://myprodserver.com</span>
    <span class="hljs-attr">description:</span> <span class="hljs-string">Production</span> <span class="hljs-string">environment</span>
</code></pre>
      </li>
      <li class="list">Under <code class="Code-In-Text--PACKT-">components</code>, we define common <code class="Code-In-Text--PACKT-">securitySchemes</code> and responses, which <a id="_idIndexMarker1173"/>define the authentication scheme we intend to implement and how the shape of our error message response will appear:
        <pre class="programlisting"><code class="hljs dts"><strong>swagger.yaml</strong>
...
<strong><span class="hljs-symbol">components:</span></strong>
<strong><span class="hljs-symbol">  securitySchemes:</span></strong>
<span class="hljs-symbol">    bearerAuth:</span>
<span class="hljs-symbol">      type:</span> http
<span class="hljs-symbol">      scheme:</span> bearer
<span class="hljs-symbol">      bearerFormat:</span> JWT
<span class="hljs-symbol">  </span><strong><span class="hljs-symbol">responses:</span></strong>
<span class="hljs-symbol">    UnauthorizedError:</span>
<span class="hljs-symbol">      description:</span> Unauthorized
<span class="hljs-symbol">      content:</span>
        application/json:
<span class="hljs-symbol">          schema:</span>
            $ref: <span class="hljs-string">"#/components/schemas/ServerMessage"</span>
<span class="hljs-symbol">          type:</span> string
</code></pre>
        <div class="note">
          <p>Note the usage of <code class="Code-In-Text--PACKT-">$ref</code> to reuse repeating elements. You can see <code class="Code-In-Text--PACKT-">ServerMessage</code> being defined here.</p>
        </div>
      </li>
      <li class="list">Under <code class="Code-In-Text--PACKT-">components</code>, we define shared data <code class="Code-In-Text--PACKT-">schemas</code>, which declares the data entities that we either take in as input or return to the client:
        <pre class="programlisting"><code class="hljs crystal"><strong>swagger.yaml</strong>
...
<strong>  <span class="hljs-symbol">schemas:</span></strong>
    <span class="hljs-symbol">ServerMessage:</span>
      <span class="hljs-symbol">type:</span> object
      <span class="hljs-symbol">properties:</span>
        <span class="hljs-symbol">message:</span>
          <span class="hljs-symbol">type:</span> string
    <span class="hljs-symbol">Role:</span>
      <span class="hljs-symbol">type:</span> string
      <span class="hljs-class"><span class="hljs-keyword">enum</span>: [<span class="hljs-title">none</span>, <span class="hljs-title">clerk</span>, <span class="hljs-title">cashier</span>, <span class="hljs-title">manager</span>]</span>
    ...
</code></pre>
      </li>
      <li class="list">Under <code class="Code-In-Text--PACKT-">components</code>, we add shared <code class="Code-In-Text--PACKT-">parameters</code>, making it easy to reuse common patterns such as paginated endpoints:
        <pre class="programlisting"><code class="hljs routeros"><strong>swagger.yaml</strong>
<span class="hljs-built_in">..</span>.
  <strong>parameters:</strong>
    filterParam:
      <span class="hljs-keyword">in</span>: query
      name:<span class="hljs-built_in"> filter
</span>      required: <span class="hljs-literal">false</span>
      schema:
        type: string
      description: Search text <span class="hljs-keyword">to</span><span class="hljs-built_in"> filter </span>the result <span class="hljs-builtin-name">set</span> by
<span class="hljs-built_in">..</span>.
</code></pre>
      </li>
      <li class="list">Under <code class="Code-In-Text--PACKT-">paths</code>, we begin <a id="_idIndexMarker1174"/>defining REST endpoints, such as a <code class="Code-In-Text--PACKT-">post</code> endpoint for the <code class="Code-In-Text--PACKT-">/login</code> path:
        <pre class="programlisting"><code class="hljs yaml"><strong><span class="hljs-string">swagger.yaml</span></strong>
<span class="hljs-string">...</span>
<strong><span class="hljs-attr">paths:</span></strong>
  <span class="hljs-string">/v1/login:</span>
    <span class="hljs-attr">post:</span>
      <span class="hljs-attr">description:</span> <span class="hljs-string">|
        Generates a JWT, given correct credentials.
</span>      <span class="hljs-attr">requestBody:</span>
        <span class="hljs-attr">required:</span> <span class="hljs-literal">true</span>
        <span class="hljs-attr">content:</span>
          <span class="hljs-attr">application/json:</span>
            <span class="hljs-attr">schema:</span>
              <span class="hljs-attr">type:</span> <span class="hljs-string">object</span>
              <span class="hljs-attr">properties:</span>
                <span class="hljs-attr">email:</span>
                  <span class="hljs-attr">type:</span> <span class="hljs-string">string</span>
                <span class="hljs-attr">password:</span>
                  <span class="hljs-attr">type:</span> <span class="hljs-string">string</span>
              <span class="hljs-attr">required:</span>
                <span class="hljs-bullet">-</span> <span class="hljs-string">email</span>
                <span class="hljs-bullet">-</span> <span class="hljs-string">password</span>
      <span class="hljs-attr">responses:</span>
        <span class="hljs-attr">'200':</span> <span class="hljs-comment"># Response</span>
          <span class="hljs-attr">description:</span> <span class="hljs-string">OK</span>
          <span class="hljs-attr">content:</span>
            <span class="hljs-attr">application/json:</span>
              <span class="hljs-attr">schema:</span>
                <span class="hljs-attr">type:</span> <span class="hljs-string">object</span>
                <span class="hljs-attr">properties:</span>
                  <span class="hljs-attr">accessToken:</span>
                    <span class="hljs-attr">type:</span> <span class="hljs-string">string</span>
                <span class="hljs-attr">description:</span> <span class="hljs-string">JWT</span> <span class="hljs-string">token</span> <span class="hljs-string">that</span> <span class="hljs-string">contains</span> <span class="hljs-string">userId</span> <span class="hljs-string">as</span> <span class="hljs-string">subject,</span> <span class="hljs-string">email</span> <span class="hljs-string">and</span> <span class="hljs-string">role</span> <span class="hljs-string">as</span> <span class="hljs-string">data</span> <span class="hljs-string">payload.</span>
        <span class="hljs-attr">'401':</span>
          <span class="hljs-string">$ref:</span> <span class="hljs-string">'#/components/responses/UnauthorizedError'</span>
</code></pre>
        <div class="note">
          <p>Note that <code class="Code-In-Text--PACKT-">requestBody</code> defines input variables that are required with a type of <code class="Code-In-Text--PACKT-">string</code>. Under <code class="Code-In-Text--PACKT-">responses</code>, we can define how a successful <code class="Code-In-Text--PACKT-">200</code> response and an unsuccessful <code class="Code-In-Text--PACKT-">401</code> response to a request appear. In the former case, we return an <code class="Code-In-Text--PACKT-">accessToken</code>, while in the latter case, we return an <code class="Code-In-Text--PACKT-">UnauthorizedError</code>, as defined in Step 2.</p>
        </div>
      </li>
      <li class="list">Under <code class="Code-In-Text--PACKT-">paths</code>, we continue <a id="_idIndexMarker1175"/>by adding the following paths:
        <pre class="programlisting"><code class="hljs dts"><strong>swagger.yaml</strong>
...
<strong><span class="hljs-symbol">paths:</span></strong>
  <span class="hljs-meta-keyword">/v1/</span>auth/me:
<span class="hljs-symbol">  get:</span> ...
 <span class="hljs-meta-keyword">/v2/</span>users:
<span class="hljs-symbol">    get:</span> ...
<span class="hljs-symbol">    post:</span> ...
 <span class="hljs-meta-keyword">/v2/</span>users<span class="hljs-class">/{id}:
<span class="hljs-symbol">    get:</span> ...
<span class="hljs-symbol">    put:</span> ...
      
</span></code></pre>
      </li>
    </ol>
    <p class="normal">The OpenAPI spec is powerful, allowing you to define intricate requirements on how users should <a id="_idIndexMarker1176"/>be able to interact with your API. The specification document at <a href="https://swagger.io/docs/specification"><span class="url">https://swagger.io/docs/specification</span></a> is an invaluable resource while developing your own API definition.</p>
    <h3 class="title" id="_idParaDest-367">Preview Swagger file</h3>
    <p class="normal">You can validate <a id="_idIndexMarker1177"/>your Swagger file at <a href="https://swaggerhub.com"><span class="url">https://swaggerhub.com</span></a> for free. After you sign up for a free account, create a new project and <a id="_idIndexMarker1178"/>define your YAML file. SwaggerHub will highlight any errors you made. It will also give you a preview of the web view, which is the same one you get with the Swagger Preview VS Code extension.</p>
    <p class="normal">Refer to the following screenshot to see how a valid Swagger YAML definition looks on SwaggerHub:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_10_05.png"/></figure>
    <p class="packt_figref">Figure 10.5: Valid Swagger YAML definition on SwaggerHub</p>
    <p class="normal">Our goal is to integrate this interactive documentation with our Express.js APIs.</p>
    <p class="normal">Now, let's see how you can implement such an API.</p>
    <h2 class="title" id="_idParaDest-368">Implementing APIs with Express.js</h2>
    <p class="normal">Before we <a id="_idIndexMarker1179"/>begin implementing our APIs, let's review the target file structure of our backend in sections, so we get an understanding <a id="_idIndexMarker1180"/>of how the server is bootstrapped, how routing is configured for API endpoints, how public resources are served, and how services are configured. Minimal MEAN intentionally sticks to the basics, so you can learn more about the underlying technologies. While I have delivered production systems using minimal MEAN, you may not enjoy the barebones development experience as much as I do. In this case, you may consider Nest.js, which is a popular framework for implementing full stack Node.js apps. Nest.js has a rich feature set with an architecture and coding style that closely resemble Angular. I recommend using such a library after you have mastered the basics of the MEAN stack.</p>
    <div class="packt_tip">
      <p>Kudos to Kamil Mysliwiec and Mark Pieszak for creating a great tool and vibrant community around Nest.js. You <a id="_idIndexMarker1181"/>can read more about Nest.js at <a href="https://nestjs.com/"><span class="url">https://nestjs.com/</span></a> and <a id="_idIndexMarker1182"/>solicit consulting services at <a href="https://trilon.io/"><span class="url">https://trilon.io/</span></a>.</p>
    </div>
    <p class="normal">Now, let's review the file structure of our Express server:</p>
    <pre class="programlisting"><code class="hljs vim"><strong>server/src</strong>
│   api.<span class="hljs-keyword">ts</span>
│   app.<span class="hljs-keyword">ts</span>
│   config.<span class="hljs-keyword">ts</span>
│   docs-config.<span class="hljs-keyword">ts</span>
│   <span class="hljs-built_in">index</span>.<span class="hljs-keyword">ts</span>
│   
├───models
│       enums.<span class="hljs-keyword">ts</span>
│       phone.<span class="hljs-keyword">ts</span>
│       user.<span class="hljs-keyword">ts</span>
│       
├───public
│       favicon.ico
│       <span class="hljs-built_in">index</span>.html
│       
├───services
│       authService.<span class="hljs-keyword">ts</span>
│       userService.<span class="hljs-keyword">ts</span>
│       
├───v1
│   │   <span class="hljs-built_in">index</span>.<span class="hljs-keyword">ts</span>
│   │   
│   └───routes
│           authRouter.<span class="hljs-keyword">ts</span>
│           
└───v2
    │   <span class="hljs-built_in">index</span>.<span class="hljs-keyword">ts</span>
    │   
    └───routes
            userRouter.<span class="hljs-keyword">ts</span>
</code></pre>
    <p class="normal">Let's review <a id="_idIndexMarker1183"/>the purpose and the interaction between these files by looking at a component diagram, giving us an overview <a id="_idIndexMarker1184"/>of the architecture and the dependency tree:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_10_06.png"/></figure>
    <p class="packt_figref">Figure 10.6: Express server architecture</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">index.ts</code> contains a <code class="Code-In-Text--PACKT-">start</code> function, which bootstraps the application leveraging three major helpers:</p>
    <ol>
      <li class="list" value="1"><code class="Code-In-Text--PACKT-">config.ts</code>: Manages environment variables and settings.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">app.ts</code>: Configures Express.js, defines all API paths, and then routers implement the paths and leverage services that contain the business logic. Services use models, such as <code class="Code-In-Text--PACKT-">user.ts</code>, to access the database.</li>
      <li class="list" value="3"><code class="Code-In-Text--PACKT-">document-ts</code>: Establishes a connection to the database and configures it, and leverages <code class="Code-In-Text--PACKT-">user.ts</code> to configure a seed user during startup.</li>
    </ol>
    <p class="normal">You can <a id="_idIndexMarker1185"/>see that the components at the top of the diagram are responsible for start up and configuration chores, including <a id="_idIndexMarker1186"/>configuring API paths, which <a id="_idIndexMarker1187"/>represent the <strong class="bold">API</strong> layer. The <strong class="bold">Services</strong> layer <a id="_idIndexMarker1188"/>should contain most <a id="_idIndexMarker1189"/>of the business logic for the app, while persistence is handled in the <strong class="bold">Models</strong> layer.</p>
    <p class="normal">Refer to the following implementation of <code class="Code-In-Text--PACKT-">index.ts</code> without any database features:</p>
    <pre class="programlisting"><code class="hljs routeros"><strong>server/src/index.ts</strong>
import * as http <span class="hljs-keyword">from</span> <span class="hljs-string">'http'</span>
import app <span class="hljs-keyword">from</span> <span class="hljs-string">'./app'</span>
import * as<span class="hljs-built_in"> config </span><span class="hljs-keyword">from</span> <span class="hljs-string">'./config'</span>
<span class="hljs-builtin-name">export</span> let Instance: http.Server
async function start() {
  console.log(<span class="hljs-string">'Starting server: '</span>)
  console.log(`isProd: <span class="hljs-variable">${config.IsProd}</span>`)
  console.log(`port: <span class="hljs-variable">${config.Port}</span>`)
 <span class="hljs-built_in"> Instance </span>= http.createServer(app)
  Instance.listen(config.Port, async () =&gt; {
    console.log(`Server listening on<span class="hljs-built_in"> port </span><span class="hljs-variable">${config.Port}</span><span class="hljs-built_in">..</span>.`)
  })
}
start()
</code></pre>
    <p class="normal">Note that the last line of code shown, <code class="Code-In-Text--PACKT-">start()</code>, is the function call that triggers the initialization <a id="_idIndexMarker1190"/>of the server.</p>
    <p class="normal">Now, let's look <a id="_idIndexMarker1191"/>into how the Express server is set up.</p>
    <h3 class="title" id="_idParaDest-369">Bootstrapping the server</h3>
    <p class="normal"><code class="Code-In-Text--PACKT-">App.ts</code> configures Express.js, along with serving static assets, routing, and versioning. Express.js <a id="_idIndexMarker1192"/>leverages middleware functions to integrate with libraries or your own code, such as an authenticate method: </p>
    <pre class="programlisting"><code class="hljs pgsql"><strong><span class="hljs-keyword">server</span>/src/app.ts</strong>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-type">path</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> cors <span class="hljs-keyword">from</span> <span class="hljs-string">'cors'</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">'express'</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> logger <span class="hljs-keyword">from</span> <span class="hljs-string">'morgan'</span>
<span class="hljs-keyword">import</span> api <span class="hljs-keyword">from</span> <span class="hljs-string">'./api'</span>
const app = express()
app.use(cors())
app.use(express.json())
app.use(express.urlencoded({ extended: <span class="hljs-keyword">true</span> }))
app.use(logger(<span class="hljs-string">'dev'</span>))
app.use(<span class="hljs-string">'/'</span>, express.static(<span class="hljs-type">path</span>.<span class="hljs-keyword">join</span>(__dirname, <span class="hljs-string">'../public'</span>), { redirect: <span class="hljs-keyword">false</span> }))
app.use(api)
export <span class="hljs-keyword">default</span> app
</code></pre>
    <p class="normal">In the preceding code, note that configuring Express is straightforward with the <code class="Code-In-Text--PACKT-">use()</code> method. First, we configure <code class="Code-In-Text--PACKT-">cors</code>, and then express parsers and <code class="Code-In-Text--PACKT-">logger</code>.</p>
    <p class="normal">Next, using the <code class="Code-In-Text--PACKT-">express.static</code> function, we serve the <code class="Code-In-Text--PACKT-">public</code> folder at the root's route, <code class="Code-In-Text--PACKT-">/</code>, so we can display some useful information about our server, as shown:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_10_07.png"/></figure>
    <p class="packt_figref">Figure 10.7: LemonMart server landing page</p>
    <p class="normal">We will cover <a id="_idIndexMarker1193"/>how to configure the <code class="Code-In-Text--PACKT-">/api-docs</code> endpoint, which is referenced above, in the next section.</p>
    <p class="normal">Finally, we configure the router, which is defined in <code class="Code-In-Text--PACKT-">api.ts</code>.</p>
    <h3 class="title" id="_idParaDest-370">Routes and versioning</h3>
    <p class="normal"><code class="Code-In-Text--PACKT-">Api.ts</code> configures <a id="_idIndexMarker1194"/>the Express router. Refer to the following implementation:</p>
    <pre class="programlisting"><code class="hljs javascript"><strong>server/src/api.ts</strong>
<span class="hljs-keyword">import</span> { Router } <span class="hljs-keyword">from</span> <span class="hljs-string">'express'</span>
<span class="hljs-keyword">import</span> api_v1 <span class="hljs-keyword">from</span> <span class="hljs-string">'./v1'</span>
<span class="hljs-keyword">import</span> api_v2 <span class="hljs-keyword">from</span> <span class="hljs-string">'./v2'</span>
<span class="hljs-keyword">const</span> api = Router()
<span class="hljs-comment">// Configure all routes here</span>
api.use(<span class="hljs-string">'/v1'</span>, api_v1)
api.use(<span class="hljs-string">'/v2'</span>, api_v2)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> api
</code></pre>
    <p class="normal">In this case, we have two child routes for <code class="Code-In-Text--PACKT-">v1</code> and <code class="Code-In-Text--PACKT-">v2</code>. It is critical to always version the APIs you implement. Once an API becomes public, it can be very tricky, even impossible sometimes, to simply phase out an API for a newer version. Even minor code changes or slight differences in the API can cause clients to break. You must pay careful attention to only making backward-compatible changes to your API.</p>
    <p class="normal">At some point, you will have a need to completely rewrite the endpoint to meet new requirements, performance, and business needs, at which point you can simply implement a <code class="Code-In-Text--PACKT-">v2</code> version of your endpoint, while leaving the <code class="Code-In-Text--PACKT-">v1</code> implementation unchanged. This allows you to innovate at the pace you need to, while keeping legacy consumers of your app functional.</p>
    <p class="normal">In short, you should <a id="_idIndexMarker1195"/>version every API you create. By doing this, you force your consumers to version their HTTP calls to your API. As time goes on, you may transition, duplicate, and retire APIs under different versions. Consumers then have a choice to call whichever version of the API works for them.</p>
    <p class="normal">Configuring a route is trivial. Let's see the configuration for <code class="Code-In-Text--PACKT-">v2</code>, as shown:</p>
    <pre class="programlisting"><code class="hljs javascript"><strong>server/src/v2/index.ts</strong>
<span class="hljs-keyword">import</span> { Router } <span class="hljs-keyword">from</span> <span class="hljs-string">'express'</span>
<span class="hljs-keyword">import</span> userRouter <span class="hljs-keyword">from</span> <span class="hljs-string">'./routes/userRouter'</span>
<span class="hljs-keyword">const</span> router = Router()
<span class="hljs-comment">// Configure all v2 routers here</span>
router.use(<span class="hljs-string">'/users?'</span>, userRouter)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router
</code></pre>
    <div class="packt_tip">
      <p>The question mark at the end of <code class="Code-In-Text--PACKT-">/users?</code> means that both <code class="Code-In-Text--PACKT-">/user</code> and <code class="Code-In-Text--PACKT-">/users</code> will work against operations implemented in <code class="Code-In-Text--PACKT-">userRouter</code>. This is a great way to avoid typos, while allowing the developer to choose the plurality that makes sense for the operation.</p>
    </div>
    <p class="normal">In <code class="Code-In-Text--PACKT-">userRouter</code>, you can then implement GET, POST, PUT, and DELETE operations. Refer to the following implementation:</p>
    <pre class="programlisting"><code class="hljs routeros"><strong>server/src/v2/routes/userRouter.ts</strong>
const router = Router()
router.<span class="hljs-builtin-name">get</span>(<span class="hljs-string">'/'</span>, async (req: Request, res: Response) =&gt; {
})
router.post(<span class="hljs-string">'/'</span>, async (req: Request, res: Response) =&gt; {
})
router.<span class="hljs-builtin-name">get</span>(<span class="hljs-string">'/:userId'</span>, async (req: Request, res: Response) =&gt; {
})
router.put(<span class="hljs-string">'/:userId'</span>, async (req: Request, res: Response) =&gt; {
})
<span class="hljs-builtin-name">export</span><span class="hljs-built_in"> default </span>router
</code></pre>
    <p class="normal">In the <a id="_idIndexMarker1196"/>preceding code, you can observe the use of route parameters. You can consume route parameters through a request object, such as <code class="Code-In-Text--PACKT-">req.params.userId</code>.</p>
    <div class="packt_tip">
      <p>Note that all routes in the sample code are tagged as <code class="Code-In-Text--PACKT-">async</code> because they will all be making a database call, which we are going to <code class="Code-In-Text--PACKT-">await</code>. If your route is synchronous, then you don't require the <code class="Code-In-Text--PACKT-">async</code> keyword.</p>
    </div>
    <p class="normal">Next, let's look into services.</p>
    <h3 class="title" id="_idParaDest-371">Services</h3>
    <p class="normal">We don't want <a id="_idIndexMarker1197"/>to implement our business logic in the router files, which represents our API layer. The API layer should largely consist of transforming data and making calls to the business logic layer.</p>
    <p class="normal">You can implement services using Node.js and TypeScript features. No fancy dependency injection is necessary. The sample application implements two services – <code class="Code-In-Text--PACKT-">authService</code> and <code class="Code-In-Text--PACKT-">userService</code>.</p>
    <p class="normal">For example, in <code class="Code-In-Text--PACKT-">userService.ts</code>, you can implement a function called <code class="Code-In-Text--PACKT-">createNewUser</code>:</p>
    <pre class="programlisting"><code class="hljs pgsql"><strong><span class="hljs-keyword">server</span>/src/services/userService.ts</strong>
<span class="hljs-keyword">import</span> { IUser, <span class="hljs-keyword">User</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../models/user'</span>
export async <span class="hljs-keyword">function</span> createNewUser(userData: IUser): Promise&lt;<span class="hljs-keyword">User</span> | <span class="hljs-type">boolean</span>&gt; {
  // <span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span>
}
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">createNewUser</code> accepts <code class="Code-In-Text--PACKT-">userData</code> in the shape of <code class="Code-In-Text--PACKT-">IUser</code> and, when it is done creating the user, it returns an instance of <code class="Code-In-Text--PACKT-">User</code>. We can then use this function in our router as follows:</p>
    <pre class="programlisting"><code class="hljs groovy"><strong>server<span class="hljs-regexp">/src/</span>v2<span class="hljs-regexp">/routes/</span>userRouter.ts</strong>
<span class="hljs-keyword">import</span> { createNewUser } from <span class="hljs-string">'../../services/userService'</span>
router.post(<span class="hljs-string">'/'</span>, async (<span class="hljs-string">req:</span> Request, <span class="hljs-string">res:</span> Response) =&gt; {
  const userData = req.body <span class="hljs-keyword">as</span> IUser
  const success = await createNewUser(userData)
  <span class="hljs-keyword">if</span> (success <span class="hljs-keyword">instanceof</span> User) {
    res.send(success)
  } <span class="hljs-keyword">else</span> {
    res.status(<span class="hljs-number">400</span>).send({ <span class="hljs-string">message:</span> <span class="hljs-string">'Failed to create user.'</span> })
  }
})
</code></pre>
    <p class="normal">We can <a id="_idIndexMarker1198"/>await the result of <code class="Code-In-Text--PACKT-">createNewUser</code> and, if successful, return the created object as a response to the POST request.</p>
    <div class="packt_tip">
      <p>Note that even though we are casting <code class="Code-In-Text--PACKT-">req.body</code> as <code class="Code-In-Text--PACKT-">IUser</code>, this is only a development time comfort feature. At runtime, the consumer may pass any number of properties to the body. Careless handling of request parameters is one of the primary ways in which your code can be maliciously exploited.</p>
    </div>
    <p class="normal">Now that we have an understanding of the skeleton of our Express server, let's see how you can configure Swagger so that you can use it as a guide to implementation and create living documentation for your API.</p>
    <h2 class="title" id="_idParaDest-372">Configuring Swagger with Express</h2>
    <p class="normal">Configuring Swagger <a id="_idIndexMarker1199"/>with Express is a manual process. Forcing yourself to manually document the endpoints has a great side effect. By <a id="_idIndexMarker1200"/>slowing down, you will get the opportunity to consider your implementation from the consumer's perspective as well as the implementor's perspective. This perspective will help you to resolve potential issues with your endpoints during development, thereby avoiding costly reworking.</p>
    <p class="normal">The major benefit of integrating Swagger with your server is that you will get the same interactive Swagger UI that was covered earlier in this chapter, so your testers and developers can discover or test your API directly from a web interface.</p>
    <p class="normal">We are going to use two helper libraries to help us integrate Swagger into our server:</p>
    <ul>
      <li class="list"><code class="Code-In-Text--PACKT-">swagger-jsdoc</code>: This allows you to implement OpenAPI specs right on top of the relevant code by using the <code class="Code-In-Text--PACKT-">@swagger</code> identifier in a <code class="Code-In-Text--PACKT-">JSDoc</code> comment block, generating a <code class="Code-In-Text--PACKT-">swagger.json</code> file as output.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">swagger-ui-express</code>: This consumes the <code class="Code-In-Text--PACKT-">swagger.json</code> file to display the interactive Swagger UI web interface.</li>
    </ul>
    <p class="normal">Let's go <a id="_idIndexMarker1201"/>over how Swagger is configured to work with Express.js:</p>
    <ol>
      <li class="list" value="1">The dependencies and type information for TypeScript are shown here:
        <pre class="programlisting"><code class="hljs coffeescript">$ <span class="hljs-built_in">npm</span> i swagger-jsdoc swagger-ui-express
$ <span class="hljs-built_in">npm</span> i -D @types/swagger-jsdoc @types/swagger-ui-express
</code></pre>
      </li>
      <li class="list">Let's go <a id="_idIndexMarker1202"/>over the <code class="Code-In-Text--PACKT-">docs-config.ts</code> file, which configures the base OpenAPI definition:
        <pre class="programlisting"><code class="hljs pgsql"><strong><span class="hljs-keyword">server</span>/src/docs-config.ts</strong>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> swaggerJsdoc <span class="hljs-keyword">from</span> <span class="hljs-string">'swagger-jsdoc'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-keyword">Options</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'swagger-jsdoc'</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> packageJson <span class="hljs-keyword">from</span> <span class="hljs-string">'../package.json'</span>
const <span class="hljs-keyword">options</span>: <span class="hljs-keyword">Options</span> = {
  swaggerDefinition: {
    openapi: <span class="hljs-string">'3.0.1'</span>,
    components: {},
    <span class="hljs-keyword">info</span>: {
      title: packageJson.name,
      <span class="hljs-keyword">version</span>: packageJson.<span class="hljs-keyword">version</span>,
      description: packageJson.description,
    },
    servers: [
      {
        url: <span class="hljs-string">'http://localhost:3000'</span>,
        description: <span class="hljs-string">'Local environment'</span>,
      },
      {
        url: <span class="hljs-string">'https://mystagingserver.com'</span>,
        description: <span class="hljs-string">'Staging environment'</span>,
      },
      {
        url: <span class="hljs-string">'https://myprodserver.com'</span>,
        description: <span class="hljs-string">'Production environment'</span>,
      },
    ],
  },
  apis: [
    <span class="hljs-string">'**/models/*.js'</span>, 
    <span class="hljs-string">'**/v1/routes/*.js'</span>, 
    <span class="hljs-string">'**/v2/routes/*. js'</span>
  ],
}
export const specs = swaggerJsdoc(<span class="hljs-keyword">options</span>)
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Modify the <code class="Code-In-Text--PACKT-">servers</code> property to include the location of your testing, staging, or production environments. This allows consumers of your API to test the API using the web interface without additional tooling. Note that the <code class="Code-In-Text--PACKT-">apis</code> property informs the code files that <code class="Code-In-Text--PACKT-">swaggerJsdoc</code> should parse when constructing the <code class="Code-In-Text--PACKT-">swagger.json</code> file. This routine runs during the bootstrapping of the server, which is why we reference the transpiled <code class="Code-In-Text--PACKT-">.js</code> files instead of <code class="Code-In-Text--PACKT-">.ts</code> files.</p>
      </li>
      <li class="list" value="3">Bootstrap <a id="_idIndexMarker1203"/>the swagger config in <code class="Code-In-Text--PACKT-">app.ts</code>:
        <pre class="programlisting"><code class="hljs routeros"><strong>server/src/app.ts</strong>
import * as swaggerUi <span class="hljs-keyword">from</span> <span class="hljs-string">'swagger-ui-express'</span>
import { specs } <span class="hljs-keyword">from</span> <span class="hljs-string">'./docs-config'</span>
const app = express()
app.use(cors())
<span class="hljs-built_in">..</span>.
<strong>app.use(<span class="hljs-string">'/api-docs'</span>, swaggerUi.serve, swaggerUi.setup(specs))</strong>
<span class="hljs-built_in">..</span>.
<span class="hljs-builtin-name">export</span><span class="hljs-built_in"> default </span>app
</code></pre>
      </li>
    </ol>
    <p class="normal">Specs contain <a id="_idIndexMarker1204"/>the content of the <code class="Code-In-Text--PACKT-">swagger.json</code> file, which is then passed to <code class="Code-In-Text--PACKT-">swaggerUi</code>. Then, using the server middleware, we can configure <code class="Code-In-Text--PACKT-">swaggerUi</code> to host the web interface at <code class="Code-In-Text--PACKT-">/api-docs</code>.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">You already have the OpenAPI definitions that need to be used to complete the implementation of the application from the beginning of this chapter. Refer to the complete source code at <a href="https://github.com/duluca/lemon-mart-server"><span class="url">https://github.com/duluca/lemon-mart-server</span></a> for additional help.</p>
    </div>
    <p class="normal">Congratulations! Now you have a good understanding of how our Express server works. Next, let's look at how to connect to MongoDB.</p>
    <h1 class="title" id="_idParaDest-373">MongoDB ODM with DocumentTS</h1>
    <p class="normal">DocumentTS acts as an ODM, implementing a layer of models to enable rich and customizable <a id="_idIndexMarker1205"/>interaction with database objects. ODM is the document-based database equivalent of an <strong class="bold">Object Relational Mapper</strong> (<strong class="bold">ORM</strong>) in <a id="_idIndexMarker1206"/>relational databases. Think Hibernate or Entity Framework. If you're not familiar with these concepts, I recommend that you do further research before moving on.</p>
    <p class="normal">At its <a id="_idIndexMarker1207"/>core, DocumentTS leverages the Node.js driver for MongoDB. This driver is implemented by the makers of MongoDB. It guarantees to offer the best performance and feature parity with new MongoDB releases, whereas third-party libraries often lag in supporting new features. Using the <code class="Code-In-Text--PACKT-">database.getDbInstance</code> method, you can get access to the native driver directly. Otherwise, you will be accessing Mongo through models that you implement. Refer to the following diagram for an overview:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_10_08.png"/></figure>
    <p class="packt_figref">Figure 10.8: DocumentTS overview</p>
    <div class="packt_tip">
      <p>You can <a id="_idIndexMarker1208"/>read more about MongoDB's Node.js driver at <a href="https://mongodb.github.io/node-mongodb-native/"><span class="url">https://mongodb.github.io/node-mongodb-native/</span></a>.</p>
    </div>
    <h2 class="title" id="_idParaDest-374">About DocumentTS</h2>
    <p class="normal">DocumentTS <a id="_idIndexMarker1209"/>provides <a id="_idIndexMarker1210"/>three major features:</p>
    <ul>
      <li class="list"><code class="Code-In-Text--PACKT-">connect()</code>: A MongoDB async connection harness </li>
      <li class="list"><code class="Code-In-Text--PACKT-">Document</code> and <code class="Code-In-Text--PACKT-">IDocument</code>: A base class and interface to help define your own models</li>
      <li class="list"><code class="Code-In-Text--PACKT-">CollectionFactory</code>: Defines collections, organizes indexes, and aggregates queries alongside collection implementations</li>
    </ul>
    <p class="normal">Here are the convenience features that a DocumentTS collection provides:</p>
    <ul>
      <li class="list"><code class="Code-In-Text--PACKT-">get collection</code> returns the native MongoDB collection, so you can operate on it directly:
        <pre class="programlisting"><code class="hljs routeros"><span class="hljs-builtin-name">get</span> collection(): ICollectionProvider&lt;TDocument&gt;
</code></pre>
      </li>
      <li class="list"><code class="Code-In-Text--PACKT-">aggregate</code> allows you to run a MongoDB aggregation pipeline:
        <pre class="programlisting"><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">aggregate</span><span class="hljs-params">(pipeline: object[])</span></span>: AggregationCursor&lt;TDocument&gt;
</code></pre>
      </li>
      <li class="list"><code class="Code-In-Text--PACKT-">findOne</code> and <code class="Code-In-Text--PACKT-">findOneAndUpdate</code> simplify the operation of commonly used database functionality, automatically hydrating the models returned:
        <pre class="programlisting"><code class="hljs dts">async findOne(
<span class="hljs-symbol">  filter:</span> FilterQuery<span class="hljs-params">&lt;TDocument&gt;</span>, 
  options?: FindOneOptions
): Promise<span class="hljs-params">&lt;TDocument | null&gt;</span> 
async findOneAndUpdate(
<span class="hljs-symbol">  filter:</span> FilterQuery<span class="hljs-params">&lt;TDocument&gt;</span>,
<span class="hljs-symbol">  update:</span> TDocument | UpdateQuery<span class="hljs-params">&lt;TDocument&gt;</span>,
  options?: FindOneAndReplaceOption
 ): Promise<span class="hljs-params">&lt;TDocument | null&gt;</span>
</code></pre>
      </li>
      <li class="list"><code class="Code-In-Text--PACKT-">findWithPagination</code> is by far the best feature of DocumentTS, allowing you to filter, sort, and paginate large collections of data. This function is geared toward use with data tables, so you specify searchable properties, turn off hydration, and use a debug feature to fine-tune your queries:
        <pre class="programlisting"><code class="hljs vbnet"><span class="hljs-keyword">async</span> findWithPagination&lt;TReturnType extends IDbRecord&gt;(
  queryParams: <span class="hljs-keyword">Partial</span>&lt;IQueryParameters&gt; &amp; <span class="hljs-built_in">object</span>,
  aggregationCursorFunc?: Func&lt;AggregationCursor&lt;TReturnType&gt;&gt;,
  query?: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">object</span>,
  searchableProperties?: <span class="hljs-built_in">string</span>[],
  hydrate = <span class="hljs-literal">true</span>,
  debugQuery = <span class="hljs-literal">false</span>
): Promise&lt;IPaginationResult&lt;TReturnType&gt;&gt;
</code></pre>
      </li>
    </ul>
    <p class="normal">DocumentTS aims <a id="_idIndexMarker1211"/>to be reliable, optional, and convenient to use. DocumentTS directly exposes the developer to the native Node.js driver, so you learn how to work with MongoDB instead of some library. Developers can optionally leverage the library's convenience features, including the following:</p>
    <ul>
      <li class="list">Define your own models through simple interfaces.</li>
      <li class="list">Choose fields that you want to automatically hydrate, such as child or related objects.</li>
      <li class="list">Serialize calculated fields with every request.</li>
      <li class="list">Protect certain fields (such as passwords) from serialization so that they aren't accidently sent across the wire.</li>
    </ul>
    <p class="normal">By being optional, DocumentTS allows developers to transition to new features in their own time. If performance becomes a concern, you can easily switch to native MongoDB calls to get the best performance. Using DocumentTS, you will spend more time reading MongoDB documentation than DocumentTS documentation.</p>
    <div class="packt_tip">
      <p>Mongoose is a popular library for interacting with MongoDB. However, it is a wrapper around MongoDB, requiring a full buy-in. Furthermore, the library abstracts away the native driver, so it is very sensitive to changes and updates in the ecosystem. You can <a id="_idIndexMarker1212"/>read more about Mongoose at <a href="https://mongoosejs.com/"><span class="url">https://mongoosejs.com/</span></a>.</p>
    </div>
    <p class="normal">Install MongoDB dependencies and type information for TypeScript with the following commands:</p>
    <pre class="programlisting"><code class="hljs coffeescript">$ <span class="hljs-built_in">npm</span> i mongodb <span class="hljs-built_in">document</span>-ts
$ <span class="hljs-built_in">npm</span> i -D @types/mongodb
</code></pre>
    <p class="normal">Next, let's see how we connect to the database.</p>
    <h2 class="title" id="_idParaDest-375">Connecting to the database</h2>
    <p class="normal">It can be <a id="_idIndexMarker1213"/>a challenge to ensure that database connectivity exists when writing a fully async web application. <code class="Code-In-Text--PACKT-">connect()</code> makes it easy to connect to a MongoDB instance and makes it safe to be called simultaneously from multiple threads starting up at the same time.</p>
    <p class="normal">Let's start by configuring your environment variables:</p>
    <ol>
      <li class="list" value="1">Remember that the <code class="Code-In-Text--PACKT-">MONGO_URI</code> connection string resides in <code class="Code-In-Text--PACKT-">server/.env</code>:
        <pre class="programlisting"><code class="hljs axapta"><strong><span class="hljs-keyword">server</span>/.env</strong>
MONGO_URI=mongodb:<span class="hljs-comment">//john.smith:g00fy@localhost:27017/lemon-mart</span>
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">In order to update the username, password, and database name, you'll need to edit the following variables in the top level <code class="Code-In-Text--PACKT-">.env</code> file:</p>
        <pre class="programlisting"><code class="hljs routeros"><strong>.env</strong>
<span class="hljs-attribute">MONGODB_APPLICATION_DATABASE</span>=lemon-mart
<span class="hljs-attribute">MONGODB_APPLICATION_USER</span>=john.smith
<span class="hljs-attribute">MONGODB_APPLICATION_PASS</span>=g00fy
</code></pre>
        <div class="packt_tip">
          <p class="Tip-Within-Bullet--PACKT-">Remember that <code class="Code-In-Text--PACKT-">.env</code> changes only take effect when you restart your servers.</p>
        </div>
      </li>
      <li class="list" value="2">Let's <a id="_idIndexMarker1214"/>see how <code class="Code-In-Text--PACKT-">document-ts</code> integrates with <code class="Code-In-Text--PACKT-">index.ts</code>:
        <pre class="programlisting"><code class="hljs typescript"><strong>server/src/index.ts</strong>
...
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-built_in">document</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'document-ts'</span>
<span class="hljs-keyword">import</span> { UserCollection } <span class="hljs-keyword">from</span> <span class="hljs-string">'./models/user'</span>
...
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">start</span>(<span class="hljs-params"/>) </span>{
  ...
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`mongoUri: <span class="hljs-subst">${config.MongoUri}</span>`</span>)
  <span class="hljs-keyword">try</span> {
    <strong><span class="hljs-keyword">await</span> <span class="hljs-built_in">document</span>.connect(config.MongoUri, config.IsProd)</strong>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Connected to database!'</span>)
  } <span class="hljs-keyword">catch</span> (ex) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Couldn't connect to a database: <span class="hljs-subst">${ex}</span>`</span>)
  }
...
  Instance.listen(config.Port, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Server listening on port <span class="hljs-subst">${config.Port}</span>...`</span>)
    <strong><span class="hljs-keyword">await</span> createIndexes()</strong>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Done.'</span>)
  })
}
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createIndexes</span>(<span class="hljs-params"/>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Create indexes...'</span>)
  <strong><span class="hljs-keyword">await</span> UserCollection.createIndexes()</strong>
}
start()
</code></pre>
      </li>
    </ol>
    <p class="normal">We attempt to connect to the database using a <code class="Code-In-Text--PACKT-">try/catch</code> block. Once the Express server is <a id="_idIndexMarker1215"/>up and running, we call <code class="Code-In-Text--PACKT-">createIndexes</code>, which, in turn, calls a function with the same name on <code class="Code-In-Text--PACKT-">UserCollection</code>. Beyond performance considerations, MongoDB indexes are necessary to enable fields to become searchable.</p>
    <h2 class="title" id="_idParaDest-376">Models with IDocument</h2>
    <p class="normal">You may <a id="_idIndexMarker1216"/>implement an <code class="Code-In-Text--PACKT-">IUser</code> interface similar <a id="_idIndexMarker1217"/>to the one in LemonMart. However, this one will be extending the <code class="Code-In-Text--PACKT-">IDocument</code> defined in DocumentTS: </p>
    <ol>
      <li class="list" value="1">Here is the <code class="Code-In-Text--PACKT-">IUser</code> interface:
        <pre class="programlisting"><code class="hljs dts"><strong>server<span class="hljs-meta-keyword">/src/</span>models/user.ts</strong>
export interface IUser extends <span class="hljs-class">IDocument </span>{
<span class="hljs-symbol">  email:</span> string
<span class="hljs-symbol">  name:</span> IName
<span class="hljs-symbol">  picture:</span> string
<span class="hljs-symbol">  role:</span> Role
<span class="hljs-symbol">  userStatus:</span> boolean
<span class="hljs-symbol">  dateOfBirth:</span> Date
<span class="hljs-symbol">  level:</span> number
<span class="hljs-symbol">  address:</span> {
<span class="hljs-symbol">    line1:</span> string
    line2?: string
<span class="hljs-symbol">    city:</span> string
<span class="hljs-symbol">    state:</span> string
<span class="hljs-symbol">    zip:</span> string
  }
  phones?: IPhone[]
}
</code></pre>
        <div class="note">
          <p>The interfaces and base classes provided by DocumentTS aim to help you develop your business logic and database queries in a consistent manner. I encourage you to explore the base classes and interfaces by <kbd class="Key--PACKT-">Ctrl</kbd> + clicking on them so that you can see the source code behind them.</p>
        </div>
      </li>
      <li class="list">Now, here <a id="_idIndexMarker1218"/>is the <code class="Code-In-Text--PACKT-">User</code> class extending <code class="Code-In-Text--PACKT-">Document&lt;T&gt;</code> and <a id="_idIndexMarker1219"/>implementing Swagger documentation:
        <pre class="programlisting"><code class="hljs typescript"><strong>server/src/models/user.ts</strong>
<span class="hljs-keyword">import</span> { v4 <span class="hljs-keyword">as</span> uuid } <span class="hljs-keyword">from</span> <span class="hljs-string">'uuid'</span>
<span class="hljs-comment">/**
 * @swagger
 * components:
 *   schemas:
 *     Name:
 *       type: object
 *       …
 *     User:
 *       type: object 
 *       …
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> User <span class="hljs-keyword">extends</span> Document&lt;IUser&gt; <span class="hljs-keyword">implements</span> IUser {
  <span class="hljs-keyword">static</span> collectionName = <span class="hljs-string">'users'</span>
  <span class="hljs-keyword">private</span> password: <span class="hljs-built_in">string</span>
  <span class="hljs-keyword">public</span> email: <span class="hljs-built_in">string</span>
  <span class="hljs-keyword">public</span> name: IName
  <span class="hljs-keyword">public</span> picture: <span class="hljs-built_in">string</span>
  <span class="hljs-keyword">public</span> role: Role
  <span class="hljs-keyword">public</span> dateOfBirth: <span class="hljs-built_in">Date</span>
  <span class="hljs-keyword">public</span> userStatus: <span class="hljs-built_in">boolean</span>
  <span class="hljs-keyword">public</span> level: <span class="hljs-built_in">number</span>
  <span class="hljs-keyword">public</span> address: {
    line1: <span class="hljs-built_in">string</span>
    city: <span class="hljs-built_in">string</span>
    state: <span class="hljs-built_in">string</span>
    zip: <span class="hljs-built_in">string</span>
  }
  <span class="hljs-keyword">public</span> phones?: IPhone[]
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">user?: Partial&lt;IUser&gt;</span>) {
    <span class="hljs-keyword">super</span>(User.collectionName, user)
  }
  fillData(data?: Partial&lt;IUser&gt;) {
    <span class="hljs-keyword">if</span> (data) {
      <span class="hljs-built_in">Object</span>.assign(<span class="hljs-keyword">this</span>, data)
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.phones) {
      <span class="hljs-keyword">this</span>.phones = <span class="hljs-keyword">this</span>.hydrateInterfaceArray(
        Phone, Phone.Build, <span class="hljs-keyword">this</span>.phones
      )
    }
  }
  getCalculatedPropertiesToInclude(): <span class="hljs-built_in">string</span>[] {
    <span class="hljs-keyword">return</span> [<span class="hljs-string">'fullName'</span>]
  }
  getPropertiesToExclude(): <span class="hljs-built_in">string</span>[] {
    <span class="hljs-keyword">return</span> [<span class="hljs-string">'password'</span>]
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">get</span> fullName(): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.name.middle) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.name.first}</span> <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name.middle}</span> <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name.last}</span>`</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.name.first}</span> <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name.last}</span>`</span>
  }
  <span class="hljs-keyword">async</span> create(id?: <span class="hljs-built_in">string</span>, password?: <span class="hljs-built_in">string</span>, upsert = <span class="hljs-literal">false</span>) {
    <span class="hljs-keyword">if</span> (id) {
      <span class="hljs-keyword">this</span>._id = <span class="hljs-keyword">new</span> ObjectID(id)
    }
    <span class="hljs-keyword">if</span> (!password) {
      password = uuid()
    }
    <span class="hljs-keyword">this</span>.password = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.setPassword(password)
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.save({ upsert })
  }
  hasSameId(id: ObjectID): <span class="hljs-built_in">boolean</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._id.toHexString() === id.toHexString()
  }
}
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Note the properties, <code class="Code-In-Text--PACKT-">getCalculatedPropertiesToInclude</code> and <code class="Code-In-Text--PACKT-">getPropertiesToExclude</code>. These define whether a field should be serialized by the client or allowed to be written to the database. </p>
        <div class="packt_tip">
          <p class="Tip-Within-Bullet--PACKT-">Serialization and deserialization of data is the concept of transforming data into a format <a id="_idIndexMarker1220"/>that can be stored or transported. Refer to the <em class="italics">Further reading</em> section for links to articles regarding serialization and the JSON data format.</p>
        </div>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">fullName</code> is a calculated property, so we don't want to write this value to the database. However, <code class="Code-In-Text--PACKT-">fullName</code> is useful for the client. On the other hand, the <code class="Code-In-Text--PACKT-">password</code> property should never be transmitted back to the client, but obviously we need to be able to save it to the database for password comparison and changes. Upon saving, we pass in the <code class="Code-In-Text--PACKT-">{ upsert }</code> object to instruct the database to update records even if partial information is provided.</p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Remember to provide the complete Swagger definition.</p>
      </li>
      <li class="list">And <a id="_idIndexMarker1221"/>finally, let's go over <code class="Code-In-Text--PACKT-">UserCollectionFactory</code>, which implements <code class="Code-In-Text--PACKT-">CollectionFactory&lt;T&gt;</code>:
        <pre class="programlisting"><code class="hljs typescript"><strong>server/src/models/user.ts</strong>
<span class="hljs-keyword">class</span> UserCollectionFactory <span class="hljs-keyword">extends</span> CollectionFactory&lt;User&gt; {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">docType: <span class="hljs-keyword">typeof</span> User</span>) {
    <span class="hljs-keyword">super</span>(User.collectionName, docType, [<span class="hljs-string">'name.first'</span>, <span class="hljs-string">'name.last'</span>, <span class="hljs-string">'email'</span>])
  }
  <span class="hljs-keyword">async</span> createIndexes() {
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.collection().createIndexes([
      {
        key: {
          email: <span class="hljs-number">1</span>,
        },
        unique: <span class="hljs-literal">true</span>,
      },
      {
        key: {
          <span class="hljs-string">'name.first'</span>: <span class="hljs-string">'text'</span>,
          <span class="hljs-string">'name.last'</span>: <span class="hljs-string">'text'</span>,
          email: <span class="hljs-string">'text'</span>,
        },
        weights: {
          <span class="hljs-string">'name.last'</span>: <span class="hljs-number">4</span>,
          <span class="hljs-string">'name.first'</span>: <span class="hljs-number">2</span>,
          email: <span class="hljs-number">1</span>,
        },
        name: <span class="hljs-string">'TextIndex'</span>,
      },
    ])
  }
userSearchQuery(
    searchText: <span class="hljs-built_in">string</span>
  ): AggregationCursor&lt;{ _id: ObjectID; email: <span class="hljs-built_in">string</span> }&gt; {
    <span class="hljs-keyword">const</span> aggregateQuery = [
      {
        $match: {
          $text: { $search: searchText },
        },
      },
      {
        $project: {
          email: <span class="hljs-number">1</span>,
        },
      },
    ]
    <span class="hljs-keyword">if</span> (searchText === <span class="hljs-literal">undefined</span> || searchText === <span class="hljs-string">''</span>) {
      <span class="hljs-keyword">delete</span> (aggregateQuery[<span class="hljs-number">0</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).$match.$text
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.collection().aggregate(aggregateQuery)
  }
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> UserCollection = <span class="hljs-keyword">new</span> UserCollectionFactory(User)
</code></pre>
      </li>
    </ol>
    <p class="normal">Here, we create <a id="_idIndexMarker1222"/>a unique index, so another <a id="_idIndexMarker1223"/>user with the same email won't be able to register. We also create a weighted index, which can assist in writing filter queries. We apply the indexes right after we connect to the database in <code class="Code-In-Text--PACKT-">index.ts</code>.</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">userSearchQuery</code> is a somewhat contrived example to demonstrate aggregate queries in MongoDB. It is possible to execute far more sophisticated and high-performance queries <a id="_idIndexMarker1224"/>using aggregation in MongoDB. You can read more about aggregation in MongoDB at <a href="https://docs.mongodb.com/manual/aggregation"><span class="url">https://docs.mongodb.com/manual/aggregation</span></a>.</p>
    <p class="normal">At the bottom of the file, we instantiate a <code class="Code-In-Text--PACKT-">UserCollection</code> and export it, so it can be referenced from anywhere in the application:</p>
    <pre class="programlisting"><code class="hljs pgsql"><strong><span class="hljs-keyword">server</span>/src/models/<span class="hljs-keyword">user</span>.ts</strong>
<strong>export</strong> let UserCollection = <span class="hljs-built_in">new</span> UserCollectionFactory(<span class="hljs-keyword">User</span>)
</code></pre>
    <div class="packt_tip">
      <p>Note that <code class="Code-In-Text--PACKT-">UserCollectionFactory</code> is not exported, as it is only needed in the <code class="Code-In-Text--PACKT-">user.ts</code> file.</p>
    </div>
    <p class="normal">Let's see how you can fetch data using the new user model.</p>
    <h1 class="title" id="_idParaDest-377">Implementing JWT auth</h1>
    <p class="normal">In <em class="italics">Chapter 8</em>, <em class="italics">Designing Authentication and Authorization</em>, we discussed how to implement <a id="_idIndexMarker1225"/>a JWT-based authentication mechanism. In LemonMart, you implemented a base auth service that can be extended for custom authentication services.</p>
    <p class="normal">We'll leverage three packages for our implementation:</p>
    <ul>
      <li class="list"><code class="Code-In-Text--PACKT-">jsonwebtoken</code>: Used <a id="_idIndexMarker1226"/>to create and encode JWTs</li>
      <li class="list"><code class="Code-In-Text--PACKT-">bcryptjs</code>: Used <a id="_idIndexMarker1227"/>to hash and salt a user's password before saving it in the database, so we never store a user's password in plain text</li>
      <li class="list"><code class="Code-In-Text--PACKT-">uuid</code>: A generated <a id="_idIndexMarker1228"/>universally unique identifier that is useful when resetting a user's password to a random value</li>
    </ul>
    <div class="packt_tip">
      <p>A hash function is a consistently repeatable, one-way encryption method, which means you get the same output every time you provide the same input, but even if you have access to the hashed value, you cannot readily figure out what information it stores. We can, however, compare whether the user has entered the correct password by hashing the user's input and comparing the hash of their input to that of the stored hash of their password.</p>
    </div>
    <ol>
      <li class="list" value="1">Let's see the JWT auth-related dependencies and type information for TypeScript:
        <pre class="programlisting"><code class="hljs coffeescript">$ <span class="hljs-built_in">npm</span> i bcryptjs jsonwebtoken uuid
$ <span class="hljs-built_in">npm</span> i -D @types/bcryptjs @types/jsonwebtoken @types/uuid
</code></pre>
      </li>
      <li class="list">Observe <a id="_idIndexMarker1229"/>the <code class="Code-In-Text--PACKT-">User</code> model with password hashing functionality:
        <pre class="programlisting"><code class="hljs typescript"><strong>server/src/models/user.ts</strong>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> bcrypt <span class="hljs-keyword">from</span> <span class="hljs-string">'bcryptjs'</span>
  <span class="hljs-keyword">async</span> create(id?: <span class="hljs-built_in">string</span>, password?: <span class="hljs-built_in">string</span>, upsert = <span class="hljs-literal">false</span>) {
      ...
      <span class="hljs-keyword">this</span>.password = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.setPassword(password)
      <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.save({ upsert })
    }
  <span class="hljs-keyword">async</span> resetPassword(newPassword: <span class="hljs-built_in">string</span>) {
    <span class="hljs-keyword">this</span>.password = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.setPassword(newPassword)
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.save()
  }
  <span class="hljs-keyword">private</span> setPassword(newPassword: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;<span class="hljs-function">(<span class="hljs-params">(<span class="hljs-params">resolve, reject</span>) =&gt; {
      bcrypt.genSalt(<span class="hljs-params">10, (<span class="hljs-params">err, salt</span>) =&gt; {
        <span class="hljs-keyword">if</span> (<span class="hljs-params">err</span>) {
          <span class="hljs-keyword">return</span> reject(<span class="hljs-params">err</span>)
        }
        bcrypt.hash(<span class="hljs-params">newPassword, salt, (<span class="hljs-params">hashError, hash</span>) =&gt; {
          <span class="hljs-keyword">if</span> (<span class="hljs-params">hashError</span>) {
            <span class="hljs-keyword">return</span> reject(<span class="hljs-params">hashError</span>)
          }
          resolve(<span class="hljs-params">hash</span>)
        }</span>)
      }</span>)
    }</span>)
  }
  <span class="hljs-params">comparePassword</span>(<span class="hljs-params">password: <span class="hljs-built_in">string</span></span>): <span class="hljs-params">Promise</span>&lt;<span class="hljs-params">boolean</span>&gt; {
    <span class="hljs-params">const</span> <span class="hljs-params">user</span> = <span class="hljs-params">this</span>
    <span class="hljs-params">return</span> <span class="hljs-params">new</span> <span class="hljs-params">Promise</span>(<span class="hljs-params">(<span class="hljs-params">resolve, reject</span>) =&gt; {
      bcrypt.compare(<span class="hljs-params">password, user.password, (<span class="hljs-params">err, isMatch</span>) =&gt; {
        <span class="hljs-keyword">if</span> (<span class="hljs-params">err</span>) {
          <span class="hljs-keyword">return</span> reject(<span class="hljs-params">err</span>)
        }
        resolve(<span class="hljs-params">isMatch</span>)
      }</span>)
    }</span>)
  }
</span></code></pre>
      </li>
    </ol>
    <p class="normal">Using the <code class="Code-In-Text--PACKT-">setPassword</code> method, you can hash the user-provided password and safely save it to <a id="_idIndexMarker1230"/>the database. Later, we will use the <code class="Code-In-Text--PACKT-">comparePassword</code> function to compare the user-provided value to the hashed password. We never store the user-provided value, so the system can never reproduce the user's password, making it a safe implementation.</p>
    <h2 class="title" id="_idParaDest-378">Login API</h2>
    <p class="normal">The following <a id="_idIndexMarker1231"/>is the login method implementation in <code class="Code-In-Text--PACKT-">authService</code> for <code class="Code-In-Text--PACKT-">lemon-mart-server</code>:</p>
    <pre class="programlisting"><code class="hljs typescript"><strong>server/src/services/authService.ts</strong>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> jwt <span class="hljs-keyword">from</span> <span class="hljs-string">'jsonwebtoken'</span>
<span class="hljs-keyword">import</span> { JwtSecret } <span class="hljs-keyword">from</span> <span class="hljs-string">'../config'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> IncorrectEmailPasswordMessage = <span class="hljs-string">'Incorrect email and/or password'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> AuthenticationRequiredMessage = <span class="hljs-string">'Request has not been authenticated'</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createJwt</span>(<span class="hljs-params">user: IUser</span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">string</span>&gt; </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;<span class="hljs-function">(<span class="hljs-params">(<span class="hljs-params">resolve, reject</span>) =&gt; {
    <span class="hljs-keyword">const</span> payload = {
      email: user.email,
      role: user.role,
      picture: user.picture,
    }
    jwt.sign(<span class="hljs-params">
      payload,
      JwtSecret(<span class="hljs-params"/>),
      {
        subject: user._id.toHexString(<span class="hljs-params"/>),
        expiresIn: '1d',
      },
      (<span class="hljs-params">err: <span class="hljs-built_in">Error</span>, encoded: <span class="hljs-built_in">string</span></span>) =&gt; {
        <span class="hljs-keyword">if</span> (<span class="hljs-params">err</span>) {
          reject(<span class="hljs-params">err.message</span>)
        }
        resolve(<span class="hljs-params">encoded</span>)
      }
    </span>)
  }</span>)
}
</span></code></pre>
    <p class="normal">The preceding code sample implements a <code class="Code-In-Text--PACKT-">createJwt</code> function to create a JWT per user. We also <a id="_idIndexMarker1232"/>defined canned responses for auth failures. Note the vagueness of the incorrect email/password message, meaning that bad actors cannot fish the system to exploit the authentication system.</p>
    <p class="normal">Let's implement the login API at <code class="Code-In-Text--PACKT-">/v1/auth/login</code>:</p>
    <pre class="programlisting"><code class="hljs dart"><strong>server/src/v1/routes/authRouter.ts</strong>
<span class="hljs-keyword">import</span> { Request, Response, Router } from <span class="hljs-string">'express'</span>
<span class="hljs-keyword">import</span> { UserCollection } from <span class="hljs-string">'../../models/user'</span>
<span class="hljs-keyword">import</span> {
  AuthenticationRequiredMessage,
  IncorrectEmailPasswordMessage,
  authenticate,
  createJwt,
} from <span class="hljs-string">'../../services/authService'</span>
<span class="hljs-keyword">const</span> router = Router()
<span class="hljs-comment"><span class="markdown">/**
<span class="hljs-bullet"> * </span>@swagger
<span class="hljs-bullet"> * </span>/v1/auth/login:
<span class="hljs-bullet"> *   </span>post:
<span class="hljs-bullet"> * </span>…
 */</span></span>
router.post(<span class="hljs-string">'/login'</span>, <span class="hljs-keyword">async</span> (req: Request, res: Response) =&gt; {
  <span class="hljs-keyword">const</span> userEmail = req.body.email?.toLowerCase()
  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> UserCollection.findOne({ email: userEmail })
  <span class="hljs-keyword">if</span> (user &amp;&amp; (<span class="hljs-keyword">await</span> user.comparePassword(req.body.password))) {
    <span class="hljs-keyword">return</span> res.send({ accessToken: <span class="hljs-keyword">await</span> createJwt(user) })
  }
  <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">401</span>).send({
    message: IncorrectEmailPasswordMessage
  })
})
</code></pre>
    <div class="packt_tip">
      <p>Note that when retrieving a user by email, keep in mind that emails are case-insensitive. So, you should always convert the input to lowercase. You can improve this implementation further by validating the email, and stripping any white space, script tags, or even rogue Unicode characters. Consider using libraries such as <code class="Code-In-Text--PACKT-">express-validator</code> or <code class="Code-In-Text--PACKT-">express-sanitizer</code>.</p>
    </div>
    <p class="normal">The <code class="Code-In-Text--PACKT-">login</code> method leverages the <code class="Code-In-Text--PACKT-">user.comparePassword</code> function to confirm the correctness <a id="_idIndexMarker1233"/>of the password provided. The <code class="Code-In-Text--PACKT-">createJwt</code> function then creates the <code class="Code-In-Text--PACKT-">accessToken</code> to be returned to the client.</p>
    <h2 class="title" id="_idParaDest-379">Authenticating middleware</h2>
    <p class="normal">The <code class="Code-In-Text--PACKT-">authenticate</code> function is a middleware that we can use in our API implementations <a id="_idIndexMarker1234"/>to ensure that only authenticated users with appropriate permissions can access an endpoint. Remember that real security is achieved in your backend implementation and this authenticate function is your gate keeper. </p>
    <p class="normal"><code class="Code-In-Text--PACKT-">authenticate</code> takes an optional <code class="Code-In-Text--PACKT-">options</code> object to verify the current user's role with the <code class="Code-In-Text--PACKT-">requiredRole</code> property, so if an API is configured as shown below, only a manager can access that API:</p>
    <pre class="programlisting"><code class="hljs css"><span class="hljs-selector-tag">authenticate</span>(<strong>{ <span class="hljs-attribute">requiredRole</span>: Role.Manager }</strong>)
</code></pre>
    <p class="normal">In certain cases, we want a user to be able to update their own records, but also allow managers to update everyone else's records. In this case, we leverage the <code class="Code-In-Text--PACKT-">permitIfSelf</code> property, as shown:</p>
    <pre class="programlisting"><code class="hljs yaml"><span class="hljs-string">authenticate({</span>
    <span class="hljs-attr">requiredRole:</span> <span class="hljs-string">Role.Manager,</span>
    <strong><span class="hljs-attr">permitIfSelf:</span> <span class="hljs-string">{</span></strong>
<strong>      <span class="hljs-attr">idGetter:</span> <span class="hljs-string">(req:</span> <span class="hljs-string">Request)</span> <span class="hljs-string">=&gt;</span> <span class="hljs-string">req.body._id,</span></strong>
<strong>      <span class="hljs-attr">requiredRoleCanOverride:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span></strong>
<strong>    <span class="hljs-string">},</span></strong>
  <span class="hljs-string">}),</span>
</code></pre>
    <p class="normal">In this case, if the <code class="Code-In-Text--PACKT-">_id</code> of the record being updated matches the current user's <code class="Code-In-Text--PACKT-">_id</code>, then the user can update their own record. Since, <code class="Code-In-Text--PACKT-">requiredRoleCanOverride</code> is set to <code class="Code-In-Text--PACKT-">true</code> a manager can update any record. If it were set to <code class="Code-In-Text--PACKT-">false</code>, this wouldn't be allowed. By mixing and matching these properties you can cover a vast majority of your gate keeping needs. </p>
    <div class="packt_tip">
      <p>Note that <code class="Code-In-Text--PACKT-">idGetter</code> is a function delegate, so that you can specify how the <code class="Code-In-Text--PACKT-">_id</code> property should be accessed, when the <code class="Code-In-Text--PACKT-">authenticate</code> middleware executes.</p>
    </div>
    <p class="normal">See the <a id="_idIndexMarker1235"/>following implementation of <code class="Code-In-Text--PACKT-">authenticate</code> and <code class="Code-In-Text--PACKT-">authenticateHelper</code>: </p>
    <pre class="programlisting"><code class="hljs typescript"><strong>server/src/services/authService.ts</strong>
<span class="hljs-keyword">import</span> { NextFunction, Request, Response } <span class="hljs-keyword">from</span> <span class="hljs-string">'express'</span>
<span class="hljs-keyword">import</span> { ObjectID } <span class="hljs-keyword">from</span> <span class="hljs-string">'mongodb'</span>
<span class="hljs-keyword">import</span> { IUser, UserCollection } <span class="hljs-keyword">from</span> <span class="hljs-string">'../models/user'</span>
<span class="hljs-keyword">interface</span> IJwtPayload {
  email: <span class="hljs-built_in">string</span>
  role: <span class="hljs-built_in">string</span>
  picture: <span class="hljs-built_in">string</span>
  iat: <span class="hljs-built_in">number</span>
  exp: <span class="hljs-built_in">number</span>
  sub: <span class="hljs-built_in">string</span>
}
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">authenticate</span>(<span class="hljs-params">options?: {
  requiredRole?: Role
  permitIfSelf?: {
    idGetter: (req: Request) =&gt; <span class="hljs-built_in">string</span>
    requiredRoleCanOverride: <span class="hljs-built_in">boolean</span>
  }
}</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (req: Request, res: Response, next: NextFunction) =&gt; {
    <span class="hljs-keyword">try</span> {
      res.locals.currentUser =
        <span class="hljs-keyword">await</span> authenticateHelper(
          req.headers.authorization, {
            requiredRole: options?.requiredRole,
            permitIfSelf: options?.permitIfSelf
              ? {
                  id: options?.permitIfSelf.idGetter(req),
                  requiredRoleCanOverride: 
                    options?.permitIfSelf.requiredRoleCanOverride,
                }
             : <span class="hljs-literal">undefined</span>,
          }
        )
      <span class="hljs-keyword">return</span> next()
    } <span class="hljs-keyword">catch</span> (ex) {
      <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">401</span>).send({ message: ex.message })
    }
  }
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">authenticateHelper</span>(<span class="hljs-params">
  authorizationHeader?: <span class="hljs-built_in">string</span>,
  options?: {
    requiredRole?: Role
    permitIfSelf?: {
      id: <span class="hljs-built_in">string</span>
      requiredRoleCanOverride: <span class="hljs-built_in">boolean</span>
    }
  }
</span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">User</span>&gt; </span>{
  <span class="hljs-keyword">if</span> (!authorizationHeader) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Request is missing authorization header'</span>)
  }
  <span class="hljs-keyword">const</span> payload = jwt.verify(
    sanitizeToken(authorizationHeader),
    JwtSecret()
  ) <span class="hljs-keyword">as</span> IJwtPayload
  <span class="hljs-keyword">const</span> currentUser = <span class="hljs-keyword">await</span> UserCollection.findOne({
    _id: <span class="hljs-keyword">new</span> ObjectID(payload?.sub),
  })
  <span class="hljs-keyword">if</span> (!currentUser) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"User doesn't exist"</span>)
  }
  <span class="hljs-keyword">if</span> (
    options?.permitIfSelf &amp;&amp;
    !currentUser._id.equals(options.permitIfSelf.id) &amp;&amp;
    !options.permitIfSelf.requiredRoleCanOverride
  ) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`You can only edit your own records`</span>)
  }
  <span class="hljs-keyword">if</span> (
    options?.requiredRole &amp;&amp; 
    currentUser.role !== options.requiredRole
  ) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`You must have role: <span class="hljs-subst">${options.requiredRole}</span>`</span>)
  }
  <span class="hljs-keyword">return</span> currentUser
} 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sanitizeToken</span>(<span class="hljs-params">authorization: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span></span>) </span>{
  <span class="hljs-keyword">const</span> authString = authorization || <span class="hljs-string">''</span>
  <span class="hljs-keyword">const</span> authParts = authString.split(<span class="hljs-string">' '</span>)
  <span class="hljs-keyword">return</span> authParts.length === <span class="hljs-number">2</span> ? authParts[<span class="hljs-number">1</span>] : authParts[<span class="hljs-number">0</span>]
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">authenticate</code> method is implemented as an Express.js middleware. It can read the request header for an authorization token, verify the validity of the JWT provided, load the current user, and inject it into the response stream, so an authenticated API endpoint <a id="_idIndexMarker1236"/>can conveniently access the current user's information. This will be demonstrated by the <code class="Code-In-Text--PACKT-">me</code> API. If successful, the middleware calls the <code class="Code-In-Text--PACKT-">next()</code> function to yield control back to Express. If unsuccessful, then the API can't be called.</p>
    <div class="packt_tip">
      <p>Note that <code class="Code-In-Text--PACKT-">authenticateHelper</code> returns useful error messages, so users aren't confused if they try to execute an action they're not permitted to execute.</p>
    </div>
    <p class="normal">Consider the implementation of the me API, which returns the currently logged-in user to the client via <code class="Code-In-Text--PACKT-">/v1/auth/me</code>, as shown here:</p>
    <pre class="programlisting"><code class="hljs vim"><strong>server/src/v1/routes/authRouter.<span class="hljs-keyword">ts</span></strong>
/**
 * @swagger
 * /v1/auth/<span class="hljs-keyword">me</span>:
 *   ge<span class="hljs-variable">t:</span>
 *     ...
 */
// tslin<span class="hljs-variable">t:disable</span>-<span class="hljs-keyword">next</span>-<span class="hljs-built_in">line</span>: variable-name
router.<span class="hljs-built_in">get</span>(<span class="hljs-string">'/me'</span>, <strong>authenticate()</strong>,
  async (_req: Request, re<span class="hljs-variable">s:</span> Response) =&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">res</span>.locals.currentUser) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span>.send(<span class="hljs-keyword">res</span>.locals.currentUser)
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span>.status(<span class="hljs-number">401</span>)
      .send({ message: AuthenticationRequiredMessage })
  }
)
</code></pre>
    <p class="normal">Note that the <code class="Code-In-Text--PACKT-">/v1/auth/me</code> method uses the <code class="Code-In-Text--PACKT-">authenticate</code> middleware and simply returns <a id="_idIndexMarker1237"/>the user who was loaded into the response stream.</p>
    <h2 class="title" id="_idParaDest-380">Custom server auth provider</h2>
    <p class="normal">Now that <a id="_idIndexMarker1238"/>we have a functional auth implementation in our server, we can implement a custom auth provider in LemonMart, as covered in <em class="italics">Chapter 8</em>, <em class="italics">Designing Authentication and Authorization</em>:</p>
    <div class="note">
      <p class="Information-Box--PACKT-">You must implement this custom auth provider in your Angular app.</p>
    </div>
    <div class="packt_tip">
      <p>The code sample for this section is in the <code class="Code-In-Text--PACKT-">projects/ch10</code> folder on the <strong class="bold">lemon-mart</strong> repo. Note that the sample is also accessible under the <code class="Code-In-Text--PACKT-">web-app</code> folder.</p>
    </div>
    <ol>
      <li class="list" value="1">In <code class="Code-In-Text--PACKT-">environment.ts</code> and <code class="Code-In-Text--PACKT-">environment.prod.ts</code>, implement a <code class="Code-In-Text--PACKT-">baseUrl</code> variable.</li>
      <li class="list">Also select <code class="Code-In-Text--PACKT-">authMode</code> as <code class="Code-In-Text--PACKT-">AuthMode.CustomServer</code>:
        <pre class="programlisting"><code class="hljs stylus"><strong>web-app/src/environments/environment<span class="hljs-selector-class">.ts</span></strong>
<strong>web-app/src/environments/environment<span class="hljs-selector-class">.prod</span><span class="hljs-selector-class">.ts</span></strong>
export const environment = {
  ...
  baseUrl: <span class="hljs-string">'http://localhost:3000'</span>,
  authMode: AuthMode<span class="hljs-selector-class">.CustomServer</span>,
</code></pre>
      </li>
      <li class="list">Install a helper library to programmatically access TypeScript enum values:
        <pre class="programlisting"><code class="hljs crystal">$ npm i ts-<span class="hljs-class"><span class="hljs-keyword">enum</span>-<span class="hljs-title">util</span></span>
</code></pre>
      </li>
      <li class="list">Implement the custom authentication provider as shown here:
        <pre class="programlisting"><code class="hljs typescript"><strong>web-app/src/app/auth/auth.custom.service.ts</strong>
<span class="hljs-keyword">import</span> { $<span class="hljs-keyword">enum</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'ts-enum-util'</span>
<span class="hljs-keyword">interface</span> IJwtToken {
  email: <span class="hljs-built_in">string</span>
  role: <span class="hljs-built_in">string</span>
  picture: <span class="hljs-built_in">string</span>
  iat: <span class="hljs-built_in">number</span>
  exp: <span class="hljs-built_in">number</span>
  sub: <span class="hljs-built_in">string</span>
}
<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> CustomAuthService <span class="hljs-keyword">extends</span> AuthService {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> httpClient: HttpClient</span>) {
    <span class="hljs-keyword">super</span>()
  }
  <span class="hljs-keyword">protected</span> authProvider(
    email: <span class="hljs-built_in">string</span>,
    password: <span class="hljs-built_in">string</span>
  ): Observable&lt;IServerAuthResponse&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.httpClient.post&lt;IServerAuthResponse&gt;(
      <span class="hljs-string">`<span class="hljs-subst">${environment.baseUrl}</span>/v1/auth/login`</span>,
      {
        email,
        password,
      }
    )
  }
  <span class="hljs-keyword">protected</span> transformJwtToken(token: IJwtToken): IAuthStatus {
    <span class="hljs-keyword">return</span> {
      isAuthenticated: token.email ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>,
      userId: token.sub,
      userRole: $<span class="hljs-keyword">enum</span>(Role)
        .asValueOrDefault(token.role, Role.None),
      userEmail: token.email,
      userPicture: token.picture,
    } <span class="hljs-keyword">as</span> IAuthStatus
  }
  <span class="hljs-keyword">protected</span> getCurrentUser(): Observable&lt;User&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.httpClient
      .get&lt;IUser&gt;(<span class="hljs-string">`<span class="hljs-subst">${environment.baseUrl}</span>/v1/auth/me`</span>)
      .pipe(map(User.Build, catchError(transformError)))
  }
}
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The <code class="Code-In-Text--PACKT-">authProvider</code> method <a id="_idIndexMarker1239"/>calls our <code class="Code-In-Text--PACKT-">/v1/auth/login</code> method and <code class="Code-In-Text--PACKT-">getCurrentUser</code> calls <code class="Code-In-Text--PACKT-">/v1/auth/me</code> to retrieve the current user.</p>
        <div class="packt_tip">
          <p class="Tip-Within-Bullet--PACKT-">Ensure that calls to <code class="Code-In-Text--PACKT-">login</code> methods always happen on HTTPS, otherwise you will be sending user credentials on the open internet. This is ripe for eavesdroppers on public Wi-Fi networks to steal user credentials.</p>
        </div>
      </li>
      <li class="list">Update <code class="Code-In-Text--PACKT-">authFactory</code> to return the new provider for the <code class="Code-In-Text--PACKT-">AuthMode.CustomServer</code> option:
        <pre class="programlisting"><code class="hljs qml"><strong>web-app/src/app/auth/auth.factory.ts</strong>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">authFactory</span>(<span class="hljs-params">
  afAuth: </span></span><strong><span class="hljs-function"><span class="hljs-params">AngularFireAuth,</span></span></strong><span class="hljs-function"><span class="hljs-params">
  </span></span><strong><span class="hljs-function"><span class="hljs-params">httpClient</span></span></strong><span class="hljs-function"><span class="hljs-params">: HttpClient
</span>) </span>{
  ...
  <span class="hljs-keyword">case</span> <span class="hljs-attribute">AuthMode.CustomServer</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CustomAuthService(<strong>httpClient</strong>)
}
</code></pre>
      </li>
      <li class="list">In <code class="Code-In-Text--PACKT-">app.modules.ts</code>, update <a id="_idIndexMarker1240"/>the <code class="Code-In-Text--PACKT-">AuthService</code> provider's <code class="Code-In-Text--PACKT-">deps</code> property to inject <code class="Code-In-Text--PACKT-">HttpClient</code> into <code class="Code-In-Text--PACKT-">authFactory</code>:
        <pre class="programlisting"><code class="hljs dts"><strong>web-app<span class="hljs-meta-keyword">/src/</span>app/app.module.ts</strong>
...
  {
<span class="hljs-symbol">    provide:</span> AuthService,
<span class="hljs-symbol">    useFactory:</span> authFactory,
<span class="hljs-symbol">    deps:</span> [AngularFireAuth, <strong>HttpClient</strong>],
  },
...
</code></pre>
      </li>
      <li class="list" value="7">Start your web app to make sure that things are working.</li>
    </ol>
    <p class="normal">Next, let's implement the get user endpoint, so our auth provider can get the current user.</p>
    <h2 class="title" id="_idParaDest-381">GET User by ID</h2>
    <p class="normal">Let's implement <a id="_idIndexMarker1241"/>the GET User by ID API endpoint, at <code class="Code-In-Text--PACKT-">/v2/users/{id}</code>, in <code class="Code-In-Text--PACKT-">userRouter</code>:</p>
    <pre class="programlisting"><code class="hljs pgsql"><strong><span class="hljs-keyword">server</span>/src/v2/routes/userRouter.ts</strong>
<span class="hljs-keyword">import</span> { ObjectID } <span class="hljs-keyword">from</span> <span class="hljs-string">'mongodb'</span>
<span class="hljs-keyword">import</span> { authenticate } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../services/authService'</span>
<span class="hljs-keyword">import</span> { IUser, <span class="hljs-keyword">User</span>, UserCollection } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../models/user'</span>
<span class="hljs-comment">/**
 * @swagger
 * /v2/users/{id}:
 *   get: …
 */</span>
router.<span class="hljs-keyword">get</span>(
  <span class="hljs-string">'/:userId'</span>,
  authenticate({
    requiredRole: <span class="hljs-keyword">Role</span>.Manager,
    permitIfSelf: {
      idGetter: (req: Request) =&gt; req.body._id,
      requiredRoleCanOverride: <span class="hljs-keyword">true</span>,
    },
  }),
  async (req: Request, res: Response) =&gt; {
    const <span class="hljs-keyword">user</span> = await UserCollection
      .findOne({ _id: <span class="hljs-built_in">new</span> ObjectID(req.params.userId) })
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">user</span>) {
      res.status(<span class="hljs-number">404</span>).send({ message: <span class="hljs-string">'User not found.'</span> })
    } <span class="hljs-keyword">else</span> {
      res.send(<span class="hljs-keyword">user</span>)
    }
  }
)
</code></pre>
    <p class="normal">In the preceding code sample, we query the database by user ID to find the record we're looking for. We import <code class="Code-In-Text--PACKT-">UserCollection</code> and call the <code class="Code-In-Text--PACKT-">findOne</code> method to get a <code class="Code-In-Text--PACKT-">User</code> object back. Note that we are not leveraging the <code class="Code-In-Text--PACKT-">userService</code>. Since we're only retrieving a <a id="_idIndexMarker1242"/>single record and immediately sending the result back, the additional layer of abstraction is cumbersome. However, if you start adding any business logic to the retrieval of a user, then refactor the code to leverage <code class="Code-In-Text--PACKT-">userService</code>.</p>
    <p class="normal">We secure the endpoint using the <code class="Code-In-Text--PACKT-">authenticate</code> middleware, allowing users to retrieve their records and managers to retrieve any record.</p>
    <h1 class="title" id="_idParaDest-382">Generating users with Postman</h1>
    <p class="normal">Earlier in this chapter, we covered how to create a POST method to create a new user in the <em class="italics">Services</em> <a id="_idIndexMarker1243"/>subsection of the <em class="italics">Implementing APIs with </em><em class="italics"><a id="_idIndexMarker1244"/></em><em class="italics">Express.js</em> section. Using this POST endpoint and the Postman API client, we can quickly generate user records for testing purposes. </p>
    <div class="note">
      <p class="Information-Box--PACKT-">You must generate test data in <strong class="bold">lemon-mart-server</strong> following the instructions below, which will be required in later chapters.</p>
    </div>
    <p class="normal">Let's <a id="_idIndexMarker1245"/>install and <a id="_idIndexMarker1246"/>configure Postman.</p>
    <p class="normal">Go to <a href="https://www.getpostman.com"><span class="url">https://www.getpostman.com</span></a> to download <a id="_idIndexMarker1247"/>and install Postman.</p>
    <h2 class="title" id="_idParaDest-383">Configuring Postman for authenticated calls</h2>
    <p class="normal">First, we need <a id="_idIndexMarker1248"/>to configure Postman so that we can access our authenticated endpoints:</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Bring up your server and database using either <code class="Code-In-Text--PACKT-">docker-compose up</code> or <code class="Code-In-Text--PACKT-">npm run start:backend</code>. Remember, make sure that, first and foremost, you're able to execute the sample server provided on GitHub at <a href="https://github.com/duluca/lemon-mart-server"><span class="url">https://github.com/duluca/lemon-mart-server</span></a>. Getting your own version of the server going is a secondary goal.</p>
    </div>
    <ol>
      <li class="list" value="1">Create a new collection named <code class="Code-In-Text--PACKT-">LemonMart</code>.</li>
      <li class="list">Add a POST request with the URL <code class="Code-In-Text--PACKT-">http://localhost:3000/v1/auth/login</code>.</li>
      <li class="list">In the headers, set the key-value pair, Content-Type: <code class="Code-In-Text--PACKT-">application/json</code>.</li>
      <li class="list">In the body section, provide the email and password for the demo user login that we defined in the top-level <code class="Code-In-Text--PACKT-">.env</code> file:
        <pre class="programlisting"><code class="hljs armasm"><span class="hljs-symbol">http</span>://localhost:<span class="hljs-number">3000</span>/<span class="hljs-built_in">v1</span>/auth/login - <span class="hljs-keyword">Body
</span>{
    <span class="hljs-string">"email"</span>: <span class="hljs-string">"duluca@gmail.com"</span>,
    <span class="hljs-string">"password"</span>: <span class="hljs-string">"l0l1pop!!"</span>
}
</code></pre>
      </li>
      <li class="list">Hit <strong class="bold">Send</strong> to log in.</li>
      <li class="list">Copy the <code class="Code-In-Text--PACKT-">accessToken</code>, as shown here:<figure class="mediaobject"><img alt="" src="../Images/B14094_10_09.png"/></figure>
        <p class="packt_figref">Figure 10.9: Setting up Postman</p>
      </li>
      <li class="list">Click on <a id="_idIndexMarker1249"/>the settings icon in the top-right corner to manage environments.</li>
      <li class="list">Add a new environment called LemonMart Server.</li>
      <li class="list">Create a variable named <code class="Code-In-Text--PACKT-">token</code>.</li>
      <li class="list">Paste the <code class="Code-In-Text--PACKT-">accessToken</code> value you have as the current value (no parentheses).</li>
      <li class="list" value="11">Click on <strong class="screen-text">Add</strong>/<strong class="screen-text">Update</strong>.</li>
    </ol>
    <p class="normal">Going forward, when you add a new request in Postman, you must provide the token variable as an authorization header, as shown:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_10_10.png"/></figure>
    <p class="packt_figref">Figure 10.10: Providing a token in Postman</p>
    <div class="note">
      <p>When using Postman, always make sure that the correct environment is selected in the dropdown in the top-right corner.</p>
    </div>
    <ol>
      <li class="list" value="1">Switch over to the <strong class="screen-text">Authorization</strong> tab.</li>
      <li class="list">Select <strong class="screen-text">Bearer Token</strong> as the type.</li>
      <li class="list" value="3">Provide the <a id="_idIndexMarker1250"/>token variable as <code class="Code-In-Text--PACKT-">{{token}}</code>.</li>
    </ol>
    <p class="normal">When you <strong class="screen-text">Send</strong> your request, you should see the results. Be mindful that when your token expires, you will need to repeat this process.</p>
    <h2 class="title" id="_idParaDest-384">Postman automation</h2>
    <p class="normal">Using Postman, we can <a id="_idIndexMarker1251"/>automate the execution of requests. In order to create sample users in our system, we can leverage this functionality:</p>
    <ol>
      <li class="list" value="1">Create a new POST request for <code class="Code-In-Text--PACKT-">http://localhost:3000/v2/user</code> named <strong class="screen-text">Create Users</strong>.</li>
      <li class="list">Set the <code class="Code-In-Text--PACKT-">token</code> in the <strong class="screen-text">Authorization</strong> tab</li>
      <li class="list">In the <strong class="screen-text">Body </strong>tab, provide a templated JSON object, as shown here:
        <pre class="programlisting"><code class="hljs json">{
  <span class="hljs-attr">"email"</span>: <span class="hljs-string">"{{email}}"</span>,
  <span class="hljs-attr">"name"</span>: {
    <span class="hljs-attr">"first"</span>: <span class="hljs-string">"{{first}}"</span>,
    <span class="hljs-attr">"last"</span>: <span class="hljs-string">"{{last}}"</span>
  },
  <span class="hljs-attr">"picture"</span>: <span class="hljs-string">"https://en.wikipedia.org/wiki/Bugs_Bunny#/media/File:Bugs_Bunny.svg"</span>,
  <span class="hljs-attr">"role"</span>: <span class="hljs-string">"clerk"</span>,
  <span class="hljs-attr">"userStatus"</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">"dateOfBirth"</span>: <span class="hljs-string">"1940-07-27"</span>,
  <span class="hljs-attr">"address"</span>: {
    <span class="hljs-attr">"line1"</span>: <span class="hljs-string">"123 Acme St"</span>,
    <span class="hljs-attr">"city"</span>: <span class="hljs-string">"LooneyVille"</span>,
    <span class="hljs-attr">"state"</span>: <span class="hljs-string">"Virginia"</span>,
    <span class="hljs-attr">"zip"</span>: <span class="hljs-string">"22201"</span>
  },
  <span class="hljs-attr">"phones"</span>: [
    {
      <span class="hljs-attr">"type"</span>: <span class="hljs-string">"mobile"</span>,
      <span class="hljs-attr">"digits"</span>: <span class="hljs-string">"5551234567"</span>
    }
  ]
}
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">For the purposes of this example, I'm only templating the email and the first and last name fields. You may template all properties.</p>
      </li>
      <li class="list">Implement a Postman <strong class="screen-text">Pre-request Script</strong>, which executes arbitrary logic before <a id="_idIndexMarker1252"/>sending a request. The script will define an array of people, and one by one set the current environment variable to be the next row as requests are executed:<div class="packt_tip">
          <p class="Tip-Within-Bullet--PACKT-">For more <a id="_idIndexMarker1253"/>information on pre-request scripts, check out <a href="https://learning.postman.com/docs/postman/scripts/pre-request-scripts/"><span class="url">https://learning.postman.com/docs/postman/scripts/pre-request-scripts/</span></a>.</p>
        </div>
      </li>
      <li class="list">Switch to the <strong class="screen-text">Pre-request Script</strong> tab and implement the script:
        <pre class="programlisting"><code class="hljs vim">var people = pm.environment.<span class="hljs-built_in">get</span>(<span class="hljs-string">'people'</span>)
<span class="hljs-keyword">if</span> (!people) {
  people = [
    {emai<span class="hljs-variable">l:</span> <span class="hljs-string">'efg@gmail.com'</span>, firs<span class="hljs-variable">t:</span> <span class="hljs-string">'Ali'</span>, las<span class="hljs-variable">t:</span> <span class="hljs-string">'Smith'</span>},
    {emai<span class="hljs-variable">l:</span> <span class="hljs-string">'veli@gmail.com'</span>, firs<span class="hljs-variable">t:</span> <span class="hljs-string">'Veli'</span>, las<span class="hljs-variable">t:</span> <span class="hljs-string">'Tepeli'</span>},
    {emai<span class="hljs-variable">l:</span> <span class="hljs-string">'thunderdome@hotmail.com'</span>, firs<span class="hljs-variable">t:</span> <span class="hljs-string">'Justin'</span>, las<span class="hljs-variable">t:</span> <span class="hljs-string">'Thunderclaps'</span>},
    {emai<span class="hljs-variable">l:</span> <span class="hljs-string">'jt23@hotmail.com'</span>, firs<span class="hljs-variable">t:</span> <span class="hljs-string">'Tim'</span>, las<span class="hljs-variable">t:</span> <span class="hljs-string">'John'</span>},
    {emai<span class="hljs-variable">l:</span> <span class="hljs-string">'apple@smith.com'</span>, firs<span class="hljs-variable">t:</span> <span class="hljs-string">'Obladi'</span>, las<span class="hljs-variable">t:</span> <span class="hljs-string">'Oblada'</span>},
    {emai<span class="hljs-variable">l:</span> <span class="hljs-string">'jones.smith@icloud.com'</span>, firs<span class="hljs-variable">t:</span> <span class="hljs-string">'Smith'</span>, las<span class="hljs-variable">t:</span> <span class="hljs-string">'Jones'</span>},
    {emai<span class="hljs-variable">l:</span> <span class="hljs-string">'bugs@bunnylove.com'</span>, firs<span class="hljs-variable">t:</span> <span class="hljs-string">'Bugs'</span>, las<span class="hljs-variable">t:</span> <span class="hljs-string">'Bunny'</span>},
  ]
}
var person = people.shift()
pm.environment.<span class="hljs-keyword">set</span>(<span class="hljs-string">'email'</span>, person.email)
pm.environment.<span class="hljs-keyword">set</span>(<span class="hljs-string">'first'</span>, person.<span class="hljs-keyword">first</span>)
pm.environment.<span class="hljs-keyword">set</span>(<span class="hljs-string">'last'</span>, person.<span class="hljs-keyword">last</span>)
pm.environment.<span class="hljs-keyword">set</span>(<span class="hljs-string">'people'</span>, people)
</code></pre>
        <div class="packt_tip">
          <p class="Tip-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">pm</code> is a global variable that stands for <strong class="bold">P</strong>ost<strong class="bold">M</strong>an.</p>
        </div>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">In the first line, we get the <code class="Code-In-Text--PACKT-">people</code> array from the environment. During the first request, this won't exist, which allows us to initialize the array with our test data. Next, we shift to the next record, and set the individual variables we used in our templated request body. Then, we save the current state of the array back to the environment, so, during the next execution, we can shift to the next record, until such time as we run out of records.</p>
      </li>
      <li class="list">Implement <a id="_idIndexMarker1254"/>a <code class="Code-In-Text--PACKT-">test</code> script in the <strong class="screen-text">Tests</strong> tab:
        <pre class="programlisting"><code class="hljs cs"><span class="hljs-keyword">var</span> people = pm.environment.<span class="hljs-keyword">get</span>(<span class="hljs-string">'people'</span>)
<span class="hljs-keyword">if</span> (people &amp;&amp; people.length &gt; <span class="hljs-number">0</span>) {
  postman.setNextRequest(<span class="hljs-string">'Create Users'</span>)
} <span class="hljs-keyword">else</span> {
  postman.setNextRequest(<span class="hljs-literal">null</span>)
}
</code></pre>
      </li>
      <li class="list">Make sure to save your request.<p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Here, we define a <code class="Code-In-Text--PACKT-">test</code> script, which will continue to execute until <code class="Code-In-Text--PACKT-">people.length</code> reaches zero. With each iteration, we call the <strong class="screen-text">Create Users</strong> request. When there are no people left, we call <code class="Code-In-Text--PACKT-">null</code> to terminate the test.</p>
        <div class="packt_tip">
          <p class="Tip-Within-Bullet--PACKT-">As you may imagine, you can combine multiple requests and multiple environment variables to execute sophisticated tests.</p>
        </div>
      </li>
      <li class="list">Now, execute <a id="_idIndexMarker1255"/>the script using <strong class="screen-text">Runner</strong>, located in the top-left corner of the screen:<figure class="mediaobject"><img alt="" src="../Images/B14094_10_11.png"/></figure>
        <p class="packt_figref">Figure 10.11: Runner button in the top-left corner of the Postman UI</p>
      </li>
      <li class="list">Update your <code class="Code-In-Text--PACKT-">login</code> token before moving on.</li>
      <li class="list">Configure the runner as shown:<figure class="mediaobject"><img alt="" src="../Images/B14094_10_12.png"/></figure>
        <p class="packt_figref">Figure 10.12: Collection Runner configuration</p>
      </li>
      <li class="list">Select the <strong class="screen-text">LemonMart</strong> collection.<p class="list">Select the <strong class="screen-text">LemonMart Server</strong> environment, which contains the <code class="Code-In-Text--PACKT-">token</code> variable.</p>
        <p class="list">Only <a id="_idIndexMarker1256"/>select the <strong class="screen-text">Create Users</strong> request.</p>
        <p class="list">Click on <strong class="screen-text">Run LemonMart</strong> to execute.</p>
      </li>
    </ol>
    <p class="normal">If your run succeeded, you should see the following output:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_10_13.png"/></figure>
    <p class="packt_figref">Figure 10.13: Collection Runner results</p>
    <p class="normal">If you use <a id="_idIndexMarker1257"/>Studio 3T as a MongoDB explorer, you can observe that all records have been created or you can check them out with Postman, when we implement the <code class="Code-In-Text--PACKT-">/v2/users</code> endpoint.</p>
    <div class="packt_tip">
      <p>Note that since we have a unique email index, your run partially succeeds on the next run. POST requests for already created records will return a <code class="Code-In-Text--PACKT-">400 Bad Request</code>.</p>
    </div>
    <p class="normal">You can read <a id="_idIndexMarker1258"/>more about Studio 3T at <a href="https://studio3t.com/"><span class="url">https://studio3t.com/</span></a>.</p>
    <h2 class="title" id="_idParaDest-385">Put User</h2>
    <p class="normal">We have <a id="_idIndexMarker1259"/>already covered how to create a POST request in the <em class="italics">Services</em> section <a id="_idIndexMarker1260"/>earlier in the chapter. Now, let's see how you can update an existing user record:</p>
    <pre class="programlisting"><code class="hljs dart"><strong>server/src/v2/routes/userRouter.ts</strong>
<span class="hljs-comment"><span class="markdown">/**
<span class="hljs-bullet"> * </span>@swagger
<span class="hljs-bullet"> * </span>/v2/users/{id}:
<span class="hljs-bullet"> *   </span>put:
 */</span></span>
router.put(
  <span class="hljs-string">'/:userId'</span>,
  authenticate({
    requiredRole: Role.Manager,
    permitIfSelf: {
      idGetter: (req: Request) =&gt; req.body._id,
      requiredRoleCanOverride: <span class="hljs-keyword">true</span>,
    },
  }),
  <span class="hljs-keyword">async</span> (req: Request, res: Response) =&gt; {
    <span class="hljs-keyword">const</span> userData = req.body <span class="hljs-keyword">as</span> User
    delete userData._id
    <span class="hljs-keyword">await</span> UserCollection.findOneAndUpdate(
      { _id: <span class="hljs-keyword">new</span> ObjectID(req.params.userId) },
      {
        $<span class="hljs-keyword">set</span>: userData,
      }
    )
    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> UserCollection
      .findOne({ _id: <span class="hljs-keyword">new</span> ObjectID(req.params.userId) })
    <span class="hljs-keyword">if</span> (!user) {
      res.status(<span class="hljs-number">404</span>).send({ message: <span class="hljs-string">'User not found.'</span> })
    } <span class="hljs-keyword">else</span> {
      res.send(user)
    }
  }
)
</code></pre>
    <p class="normal">We set <code class="Code-In-Text--PACKT-">userData</code> from the request body. We then <code class="Code-In-Text--PACKT-">delete</code> the <code class="Code-In-Text--PACKT-">_id</code> property that's in the body, since the URL <a id="_idIndexMarker1261"/>parameter is the authoritative source of information. Additionally, this prevents a user's ID from being accidentally changed to a different value.</p>
    <p class="normal">We then <a id="_idIndexMarker1262"/>leverage the <code class="Code-In-Text--PACKT-">findOneAndUpdate</code> method to locate and update the record. We query for the record using the ID. We update the record by using MongoDB's <code class="Code-In-Text--PACKT-">$set</code> operator.</p>
    <p class="normal">Finally, we load the saved record from the database and return it back to the client.</p>
    <div class="packt_tip">
      <p>POST and PUT methods should always respond with the updated state of the record.</p>
    </div>
    <p class="normal">For our last <a id="_idIndexMarker1263"/>piece of implementation, let's review API endpoints <a id="_idIndexMarker1264"/>that can support paginated data tables.</p>
    <h2 class="title" id="_idParaDest-386">Pagination and filtering with DocumentTS</h2>
    <p class="normal">By far the <a id="_idIndexMarker1265"/>most useful functionality of DocumentTS is <code class="Code-In-Text--PACKT-">findWithPagination</code>, as mentioned in the <em class="italics">About DocumentTS</em> section. Let's <a id="_idIndexMarker1266"/>leverage <code class="Code-In-Text--PACKT-">findWithPagination</code> to implement the <code class="Code-In-Text--PACKT-">/v2/users</code> endpoint, which can return all users:</p>
    <pre class="programlisting"><code class="hljs dart"><strong>server/src/v2/routes/userRouter.ts</strong>
<span class="hljs-comment"><span class="markdown">/**
<span class="hljs-bullet"> * </span>@swagger
<span class="hljs-bullet"> * </span>components:
<span class="hljs-bullet"> *   </span>parameters:
<span class="hljs-bullet"> *     </span>filterParam: …
<span class="hljs-bullet"> *     </span>skipParam: …
<span class="hljs-bullet"> *     </span>limitParam: …
<span class="hljs-bullet"> *     </span>sortKeyParam: …
 */</span></span>
<span class="hljs-comment"><span class="markdown">/**
<span class="hljs-bullet"> * </span>@swagger
<span class="hljs-bullet"> * </span>/v2/users:
<span class="hljs-bullet"> *   </span>get:
 */</span></span>
router.<span class="hljs-keyword">get</span>(
  <span class="hljs-string">'/'</span>,
  authenticate({ requiredRole: Role.Manager }),
  <span class="hljs-keyword">async</span> (req: Request, res: Response) =&gt; {
    <span class="hljs-keyword">const</span> query: Partial&lt;IQueryParameters&gt; = {
      filter: req.query.filter,
      limit: req.query.limit,
      skip: req.query.skip,
      sortKeyOrList: req.query.sortKey,
      projectionKeyOrList: [<span class="hljs-string">'email'</span>, <span class="hljs-string">'role'</span>, <span class="hljs-string">'_id'</span>, <span class="hljs-string">'name'</span>],
    }
    <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> UserCollection.findWithPagination&lt;User&gt;(query)
    res.send(users)
  }
)
</code></pre>
    <p class="normal">We copy all the parameters from the URL using the <code class="Code-In-Text--PACKT-">req.query</code> object as local variables. We define an additional property named <code class="Code-In-Text--PACKT-">projectionKeyOrList</code> to limit the properties of a record <a id="_idIndexMarker1267"/>that can be returned to the client. In this case, only the <code class="Code-In-Text--PACKT-">email</code>, <code class="Code-In-Text--PACKT-">role</code>, <code class="Code-In-Text--PACKT-">_id</code>, and <code class="Code-In-Text--PACKT-">name</code> properties will be returned. This minimizes <a id="_idIndexMarker1268"/>the amount of data that is sent over the wire.</p>
    <p class="normal">Finally, we simply pass the new <code class="Code-In-Text--PACKT-">query</code> object to the <code class="Code-In-Text--PACKT-">findWithPagination</code> function and return the results to the client.</p>
    <p class="normal">You can create a new request in Postman to verify the correct functionality of your new endpoint, as shown in the following screenshot:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_10_14.png"/></figure>
    <p class="packt_figref">Figure 10.14: Calling get users with Postman</p>
    <p class="normal">In <em class="italics">Chapter 12</em>, <em class="italics">Recipes – Master/Detail, Data Tables, and NgRx</em>, we will implement a paginated <a id="_idIndexMarker1269"/>data table that takes advantage of the filtering, sorting, and data limiting features.</p>
    <p class="normal">Congratulations! You now <a id="_idIndexMarker1270"/>have a grasp on how code works across the entire stack of software, from the database to the frontend and back.</p>
    <h1 class="title" id="_idParaDest-387">Summary</h1>
    <p class="normal">In this chapter, we covered full-stack architecture. You learned about building a minimal MEAN stack. You now know how to create a monorepo for a full-stack application and configure a Node.js server with TypeScript. You containerized your Node.js server and declaratively defined your infrastructure with Docker Compose. Using Docker Compose with CircleCI, you verified your infrastructure in a CI environment.</p>
    <p class="normal">You designed a RESTful API using Swagger and the OpenAPI spec, set up an Express.js app and configured it such that you can integrate your Swagger definition as documentation for your APIs. You configured MongoDB with the DocumentTS ODM so you can easily connect and query documents. You defined a user model with password hashing features.</p>
    <p class="normal">You then implemented a JWT-based authentication service. You implemented an <code class="Code-In-Text--PACKT-">authenticate</code> middleware to secure API endpoints and allow role-based access. You learned how to interact with RESTful APIs using Postman. Using Postman's automation features, you generated test data. Finally, you implemented RESTful APIs for authentication functions and CRUD operations for users.</p>
    <p class="normal">In the next two chapters, we will go over Angular recipes to create forms and data tables. You will want your Lemon Mart Server up and running to verify the correct functionality of your forms and tables as you implement them.</p>
    <h1 class="title" id="_idParaDest-388">Exercise</h1>
    <p class="normal">You secured your endpoints using the <code class="Code-In-Text--PACKT-">authenticate</code> middleware. You configured Postman to send a valid token so that you can communicate with your secured endpoints. By way of an exercise, try removing the <code class="Code-In-Text--PACKT-">authenticate</code> middleware and call the same endpoint with and without a valid token. Re-add the middleware and try the same thing again. Observe the different responses you get from the server.</p>
    <h1 class="title" id="_idParaDest-389">Further reading</h1>
    <ul>
      <li class="list"><em class="italics">What is DX? (Developer Experience)</em>, Albert Cavalcante, 2019: <a href="https://medium.com/@albertcavalcante/what-is-dx-developer-experience-401a0e44a9d9 "><span class="url">https://medium.com/@albertcavalcante/what-is-dx-developer-experience-401a0e44a9d9</span></a></li>
      <li class="list"><em class="italics">Overview of Blocking versus Non-Blocking</em>, 2020: <a href="https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/ "><span class="url">https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/</span></a></li>
      <li class="list"><em class="italics">Explain Non-Blocking I/O like I'm Five, Frank Rosner</em>, 2019: <a href="https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/ "><span class="url">https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/</span></a></li>
      <li class="list"><em class="italics">OpenAPI Specification</em>, 2020: <a href="https://swagger.io/docs/specification "><span class="url">https://swagger.io/docs/specification</span></a></li>
      <li class="list"><em class="italics">Serialization</em>, 2020: <a href="https://en.wikipedia.org/wiki/Serialization "><span class="url">https://en.wikipedia.org/wiki/Serialization</span></a></li>
      <li class="list"><em class="italics">JSON</em>, 2020: <a href="https://en.wikipedia.org/wiki/JSON "><span class="url">https://en.wikipedia.org/wiki/JSON</span></a></li>
      <li class="list"><em class="italics">Aggregation in MongoDB</em>, 2020: <a href="https://docs.mongodb.com/manual/aggregation "><span class="url">https://docs.mongodb.com/manual/aggregation</span></a></li>
    </ul>
    <h1 class="title" id="_idParaDest-390">Questions</h1>
    <p class="normal">Answer the following questions as best as you can to ensure that you've understood the key concepts from this chapter without Googling. Do you need help answering the questions? See <em class="italics">Appendix D</em>, <em class="italics">Self-Assessment Answers</em> online at <a href="https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf"><span class="url">https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf</span></a> or visit <a href="https://expertlysimple.io/angular-self-assessment"><span class="url">https://expertlysimple.io/angular-self-assessment</span></a>.</p>
    <ol>
      <li class="list" value="1">What are the main components that make for a great developer experience?</li>
      <li>What is a <code class="Code-In-Text--PACKT-">.env</code> file?</li>
      <li>What is the purpose of the <code class="Code-In-Text--PACKT-">authenticate</code> middleware?</li>
      <li>How does Docker Compose differ from using the <code class="Code-In-Text--PACKT-">Dockerfile</code>?</li>
      <li>What is an ODM? How does it differ from an ORM?</li>
      <li>What is middleware?</li>
      <li>What are the uses of Swagger?</li>
      <li>How would you refactor the code for the <code class="Code-In-Text--PACKT-">/v2/users/{id} PUT</code> endpoint in <code class="Code-In-Text--PACKT-">userRouter.ts</code>, so the code is reusable?</li>
    </ol>
  </div>
</body></html>