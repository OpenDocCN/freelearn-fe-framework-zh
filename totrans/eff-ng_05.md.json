["```js\n@Input({ required: true }) title = '';\n@Input({ required: true }) shown: boolean;\n@Output() shownChange = new EventEmitter<boolean>();\n```", "```js\n<ng-container *ngIf=\"shown\">\n  <div class=»modal-container»>\n  </div>\n  <div class=»backdrop»></div>\n</ng-container>\n```", "```js\n<div class=\"modal-header\">\n  <h1>{{title}}</h1>\n  <span (click)=»shown = false; shownChange.emit()\">X\n  </span>\n</div>\n```", "```js\n<div class=\"modal-content\">\n  <ng-content></ng-content>\n</div>\n```", "```js\n<ng-content></ng-content>\n```", "```js\n<bt-libs-modal [(shown)]=\"addExpenseShown\" [title]=\"'Add expense'\">\n  <bt-libs-ui-add-expense-form (addExpense)=\"addExpense($event)\" />\n</bt-libs-modal>\n```", "```js\n<div class=\"modal-header\">\n  <h1>{{title}}</h1>\n  <ng-content select=»[header-content]»></ng-content>\n  <span (click)=»shown = false; shownChange.emit()\">X</span>\n</div>\n```", "```js\n<bt-libs-modal [shown]=\"addExpenseShown\" [title]=\"'Add expenses'\">\n  <bt-libs-ui-add-expense-form (addExpense)=\"addExpense($event)\" />\n  <div header-content>special header content</div>\n</bt-libs-modal>\n```", "```js\n    <ng-content></ng-content>\n    ```", "```js\n<ng-content header-content attribute from the projected content, and it will still be projected to the header slot because it’s a div HTML tag:\n\n```", "```js\n\n If you change the `select` attribute value to match a span HTML element, our `div` will end up in the fallback `ng-content` slot inside our content area of the modal component. You can also match on multiple values; for example, if you want to match all `div` and `p` tags, you can create a selector like this:\n\n```", "```js\n\n You can also match HTML elements on CSS classes, IDs, or specific attribute values. Here is an example of each:\n\n```", "```js\n\n Using good `select` values for your `ng-content` tags can significantly improve the developer’s experience within your team by preventing you and your teammates from looking up the correct selector for the slots each time they have to project content into the component.\nHaving multiple `ng-content` slots and making good use of the select attribute on `ng-content` tags allows for even more flexible components with more control over the projected content. But even with multiple `ng-content` elements, you might need more flexibility to cover all your component design needs. Sometimes, you need to output your projected content numerous times inside your UI component or conditionally display the content in different places of the HTML template.\nDisplaying projected content multiple times or conditionally\nWhen you need to display the projected content multiple times or conditionally in the HTML template, your first instinct might be to add `ng-content` inside a `div` element and apply the `*ngFor`, `*ngIf`, or `*ngSwitch` directive (or the control flow syntax versions – that is, `@for`, `@if`, and `@switch`) to the `div` tag:\n\n```", "```js\n\n If you try this, you will find that your content will be projected differently than expected. When using `*ngFor`, your content will only be projected once, and when using `*ngIf` or `*ngSwitch` combined with an `ng-content` element, only the first rendered `ng-content` element is displayed. So, the three directives (or control flow syntax) will not work in combination with the `ng-content` tag.\nYou can use control flow or the `*ngFor`, `*ngIf`, and `*ngSwitch` directives inside the parent component where you project the content:\n\n```", "```js\n\n Using these directives or control flow in the parent component is good enough for many scenarios, but sometimes, you must use the directives inside the component where the `ng-content` elements reside. You might need to use the directives inside the component receiving the projected content because of the design needs of the component or to create a better architecture with a good separation of concerns.\nFor scenarios where you need to use the `*ngFor`, `*ngIf`, or `*ngSwitch` directives or control flow in the component that’s receiving the projected content, you don’t use `ng-content` as the projection slot; instead, you need to use the `ng-template` element.\nIn this section, you learned how to project content using the `ng-content` element and where you can run into the limits of what you can do with the projected content when using `ng-content`. You also learned how to effectively use the `select` attribute and project content into multiple slots using `ng-content`.\nIn the next section, we will learn about `ng-template`, template variables, and template references.\nUsing template references and variables\nIn the previous section, we projected content using the `ng-content` element. Yet, we ran into a limitation that didn’t allow you to use control flow or the `*ngFor`, `*ngIf`, or `*ngSwitch` directives in combination with the `ng-content` element. We will start by demonstrating how to resolve this using the `ng-template` element and how you can create and use template variables within HTML templates.\nWe will create a `ng-template` element and use directives on the project content. The `display-scales` component is just a simple example to demonstrate the concept of content projection combined with structural directives such as `*ngFor`.\nStart using the *Nx generator* to create the `display-scales` component next to the `modal` component. The `display-scales` component will receive an array of scale sizes as input and display the projected content in these different scale sizes using a `*``ngFor` directive.\nWhen the `display-scales` component is created, add a `scales-projection.directive.ts` file to the `display-scales` folder. Inside the `scales-projection.directive.ts` file, you can add the following content:\n\n```", "```js\n\n The scales projection directive only injects the `display-scales` component uses the directive to access the projected content. Inside the `display-scales` component class, you need to add the input for receiving the scale sizes and a `@ContentChild()` decorator to access the projected content:\n\n```", "```js\n\n As you can see, we used `ScalesProjectionDirective` as a value for the `@ContentChild` decorator. The `@ContentChild` decorator will get the projected `ng-template` element from the HTML template and hold a reference to the projected content so that we can use the content within the `display-scales` component. Inside the HTML template of the `display-scales` component, you can add this:\n\n```", "```js\n\n Here, we created a `div` element that will be rendered for each size inside the `scaleSizes` array the component receives as input. Inside the `div` element, we declared a `ng-container` element with the **ngTemplateOutlet** directive declared on the element.\nThis `ng-container` with the `ngTemplateOutlet` directive will display the projected content, similar to the `ng-content` element we used in the previous section. The `ngTemplateOutlet` directive needs to receive a `TemplateRef` property; this is why we use the `ng-template` element and the directive that injected `TemplateRef`.\nWe bind the `TemplateRef` property of the `@ContentChild` decorator value to the `ngTemplateOutlet` directive using `content.templateRef`. When using `ng-template` to project your content, you can use `*ngFor` and other structural directives in combination with the projected content. We couldn’t do this when using the `ng-content` element.\nNext, you need to project a `TemplateRef` property into the component using `ScalesProjectionDirective`. By doing so, the `@ContentChild` decorator can access the `TemplateRef` property, and we can assign the projected template reference to the `ngTemplateOutlet` directive.\nYou can project a `TemplateRef` property by using the `ng-template` element. The `ng-template` element is the HTML representation of the `TemplateRef` class. The projected content needs to match the `@ContentChild` decorator, so we need to add the `ScalesProjectionDirective` decorator to the `ng-template` element we are about to project. Don’t forget to import the `display-scales` component and `ScalesProjectionDirective` into the standalone component where you are using the scales component and directive:\n\n```", "```js\n\n After adding the preceding HTML into an HTML template (for example, in the `expenses-overview.component.html` file), you will display the scales component with the `I scale!` content projected.\nWhen you try to project an additional `ng-template` element, you will notice that only one `ng-template` element is projected and used inside the `display-scales` component. Only the first `ng-template` element is used because we use the `@ContentChild` decorator inside the `display-scales` component.\nIf you want to project multiple `ng-template` elements with the same projection directive (in our case, `ScalesProjectionDirective`), you need to use the `@ContentChildren` decorator instead of the `@ContentChild` decorator. The `@ContentChildren` decorator creates a `QueryList` property of template references instead of a single template reference:\n\n```", "```js\n<div *ngFor=\"let item of content.toArray()\">\n  <ng-container [ngTemplateOutlet]=\"item.templateRef\"></ng-container>\n</div>\n```", "```js\n@ContentChild(ScalesProjectionDirective) content!: ScalesProjectionDirective;\n@ContentChild(@ContentChild elements with different ng-container elements, as follows:\n\n```", "```js\n<div #exampleVar is the template variable, and the variable holds a reference to the DOM element it’s placed on; in this example, the DOM element is the div element. You can now use the exampleVar template variable within your HTML template. When you assign the template variable with a DOM element, you can access all properties of the DOM element, similar to when you access it from within your component class:\n\n```", "```js\n\n You can use the template variable with interpolation or anywhere else that you can use component properties inside your template:\n\n```", "```js\n\n If you want to assign a template variable to a component, you can use the same syntax but only on the selector of a custom component:\n\n```", "```js\n\n When you use a template variable on a component, you can access all the public properties and methods of the component. Sometimes, it can be useful to access the properties of the child component in this manner, but you should avoid calling public methods like so.\nIt’s not advised to call methods and potentially mutate the data of child components using template variables as it’s a bit of an anti-pattern. It would be best if you tried to do all parent-child component communication through inputs and outputs unless there is no other way. Yet it’s good to know you can access the properties through template variables so that you can recognize when someone else uses it or when you have a situation where you want or need to use it.\nAnother common and more accepted use case of template variables is assigning a directive to a template variable. We did this in [*Chapter 4*](B21625_04.xhtml#_idTextAnchor072) when we created template-driven forms. The syntax for assigning a directive to a template variable differs slightly from assigning a DOM element or component to a template variable. When assigning a directive to a template variable, we must create the variable as normal and assign the directive using the is sign (`=`):\n\n```", "```js\n\n In the preceding example, we assigned the `ngForm` directive to the `expenseForm` template variable. We can now access the `ngForm` directive and all its properties through the template variable. Using the template variable makes it easy to use all kinds of form values and statuses such as `pristine`, `dirty`, `valid`, and `invalid`. There’s no need to create a variable within your component class; you can handle everything from within your HTML template.\nYou can also use template variables to access `TemplateRef` instances created with `ng-template` elements. Accessing a `TemplateRef` instance through a template variable works similarly to assigning a template variable to a component or DOM element; you just add the template variable to the `ng-template` element:\n\n```", "```js\n<div *ngIf=\"expenses\"> ……… </div>\n<div *ngIf=\"!expenses\">Loading...</div>\n```", "```js\n<div *ngIf=\"expenses else loading\"> ……… </div>\n<ng-template #loading>\n  <div>Loading...</div>\n</ng-template>\n```", "```js\n<div *ngIf=\"!expensesVm$ | async\">Loading...</div>\n```", "```js\n<div *ngIf=\"expensesVm$ | async as expense; else loading\">……</div>\n<ng-template #loading>\n  <div>Loading...</div>\n</ng-template>\n```", "```js\n<ng-container *ngIf=\"expensesVm$ | async; then expenses; else loading\"></ng-container>\n<ng-template #expenses> <div>……</div> </ng-template>\n<ng-template #loading> <div>Loading...</div> </ng-template>\n```", "```js\n<ng-container *ngIf=\"isMobile\" [ngTemplateOutlet]=\"A\"></ng-container>\n<ng-container *ngIf=\"!isMobile\" [ngTemplateOutlet]=\"CD\"></ng-container>\n<div>Block B</div>\n<ng-container *ngIf=\"!isMobile\" [ngTemplateOutlet]=\"A\"></ng-container>\n<ng-container *ngIf=\"isMobile\" [ngTemplateOutlet]=\"CD\"></ng-container>\n<ng-template #A>\n  <div> …… </div>\n</ng-template>\n<ng-template #CD>\n  <div> …… </div>\n</ng-template>\n```", "```js\n<ng-container [ngTemplateOutlet]=\"aboveB\"></ng-container>\n<div>Block B</div>\n<ng-container [ngTemplateOutlet]=\"belowB\"></ng-container>\n```", "```js\n@ViewChild('A') templateA!: TemplateRef<unknown>;\n@ViewChild('CD') templateCD!: TemplateRef<unknown>;\naboveB!: TemplateRef<unknown>;\nbelowB!: TemplateRef<unknown>;\n```", "```js\nthis.aboveB = this.isMobile ? this.templateA : this.templateCD;\nthis.belowB = this.isMobile ? this.templateCD : this.templateA;\n```", "```js\nshowModal = false;\nmodalTitle = '';\nmodalContent!: TemplateRef<unknown>;\nopenModal(title: string, content: TemplateRef<unknown>) {\n  this.modalTitle = title;\n  this.modalContent = content;\n  this.showModal = true;\n}\n```", "```js\n<button (click)=\"openModal('Title A', modalA)\">Open modal A</button>\n<button (click)=\"openModal('Title B', modalB)\">Open modal B</button>\n<bt-libs-modal [(shown)]=\"showModal\" [title]=\"modalTitle\">\n  <ng-container [ngTemplateOutlet]=\"modalContent\"></ng-container>\n</bt-libs-modal>\n<ng-template #modalA>\n  <div>A...</div>\n</ng-template>\n<ng-template #modalB>\n  <div>B...</div>\n</ng-template>\n```", "```js\n@Input({ required: true }) options!: unknown[];\n@Input() optionTemplate?: TemplateRef<unknown>;\n@Input() selectedIndex?: number;\n@Input() labelKey?: string;\n@Output() selectedChange = new EventEmitter<unknown>();\nonOptionChange(index: any) {\n  this.selectedIndex = index.target.value;\n  this.selectedChange.emit(this.options[index.target.value]);\n}\n```", "```js\n<select (change)=\"onOptionChange($event)\">\n  <option [value]=»null» [selected]=»!selectedIndex\">Make selection</option>\n  <ng-container *ngFor=\"let option of options; index as i\">\n    <option [value]=»i\" [selected]=\"i === selectedIndex\">\n      <ng-container [ngTemplateOutlet]=»optionTemplate || defaultTemplate»\n        [ngTemplateOutletContext]=\"{ $implicit: option}\">\n      </ng-container>\n    </option>\n  </ng-container>\n</select>\n<ng-template #defaultTemplate let-option>\n  {{ labelKey ? option[labelKey] : option }}\n</ng-template>\n```", "```js\n<ng-template ngTemplateOutletContext directive. When you have other context properties besides the $implicit property, you must use a slightly different syntax to use the additional property. Let’s say you have a shown property inside the ngTemplateOutletContext directive:\n\n```", "```js\nng-template element; the right-hand side needs to match the property you declared in the ngTemplateOutletContext directive. For example, you can replace let-shown with let-shownValue or anything else you desire, so long as it starts with let-:\n\n```", "```js\n\n Now that you know how to use the context inside `ng-template` elements, let’s test the `select` component and see how we can provide a custom template for the `select` component.\nIf you’re using the `select` component in another standalone component, you must import the `select` component before you can declare it in the HTML template. Once you’ve imported the `select` component, you can use it in the template like this:\n\n```", "```js\n\n In a real-world scenario, you should define the input for the options inside the component class, but I’ve added it directly in the HTML for demonstration purposes. The default `ng-template` element will be used because we didn’t provide a `TemplateRef` element for the `optionTemplate` input of the `select` component.\nNow, let’s create a custom template to provide to the `select` component. Let’s say you have an array of expenses that looks like this:\n\n```", "```js\n\n Now, we can create a template to display the expense and amount inside the `select` component:\n\n```", "```js\n\n When the template is created, you need to assign the template to the `optionTemplate` input of the `select` component, like this:\n\n```", "```js\n\n After providing the custom template to the `optionSelect` input, the select component will use the `expenseSelect` template instead of the default template. The `expenseSelect` template receives the expense object that’s used inside the template through the `ngTemplateOutletContext` directive. By using the `ng-template` element and the `ngTemplateOutletContext` directive, you can display any content you want inside the `select` component and use any array of objects that’s necessary to provide the data for the template, giving you all the flexibility you need for a truly dynamic component.\nWe covered a lot in this section. First, you learned about `TemplateRef` and how to use it inside the component class or HTML. Using the `ng-template` and `ng-content` elements, you learned how to use structural directives combined with projected content. You also learned how to provide context to `ng-template` elements using the `ngTemplateOutletContext` directive to build truly dynamic components. Finally, you learned about template variables and how to use them to access values inside your templates or display content conditionally.\nIn the next and last section of this chapter, you will learn about rendering components dynamically.\nRendering components dynamically\nIn some scenarios, you might want to load and render components dynamically. You might want to load and render components dynamically because you don’t know the layout or exact components of the page upfront or because you have data and resource-intensive components that you only want to load and render if the user needs them in the view.\nHere are some common examples of when dynamically loading components is useful:\n\n*   When building a website builder where customers can build up web pages based on a set of components you provide. With a website builder, you don’t know how the user will create the page’s layout and what components will be used. You want to load components dynamically whenever the user adds them to the page.\n*   When you have a multi-step wizard where the content of the next steps differs based on the users’ choices during each step of the wizard.\n*   Tabs, modals, and popups with resource-intensive components or where different components can be displayed based on the user interaction. You only want to load and render the components if the user requests them.\n*   When you allow users to configure a list of widgets in your application. You don’t know what widgets the user will activate, and in what order they want them displayed, so it would make little sense to load and render them before the user configures them.\n*   An ad banner component with different ads cycling through the ad banner component. When different teams frequently add new ad components for the banner, a static component structure would make little sense.\n\nWhen you need to load and render components dynamically, there are three approaches: the `ngComponentOutlet` directive, the `ViewContainerRef` class, and, since Angular 17, the defer control flow. First, we’ll use `ngComponentOutlet` as this is the most straightforward solution that works for any Angular version. Next, we will show you how to render and load components dynamically with the defer control flow that was introduced in Angular 17.\nRendering components dynamically using ngComponentOutlet\nTo demonstrate dynamic component rendering using the `ngComponentOutlet` directive, we will create a widget component that can render different widgets with their own custom functionality and design. Let’s say the widget container can receive widget data as input and render the widget it receives as input; this way, you can display a different widget for each page if needed.\nStart by generating a `widget-container` component inside the `common-components` library. This `widget-container` component will dynamically render widget components using the `ngComponentOutlet` directive.\nNext, create two more components: a weather widget and a clock widget component. For demonstration purposes, we will leave the weather and clock widget templates as Nx generated them by default.\nNow, in the widget container component, define an `ng-container` element in the template and add the `ngComponentOutlet` directive to the `ng-container` element:\n\n```", "```js\n\n As you can see, we assign the `ngComponentOutlet` directive with `widget.component`. So, let’s create an interface for the widget and add the widget property to the component class:\n\n```", "```js\n\n Make the widget property an input so that the widget container can receive this widget property from the parent where you declare the widget container component:\n\n```", "```js\n\n As a simple example, this is all you need to render a component dynamically. We will extend this example quite a bit, but to showcase the dynamically rendered component, you can now use the widget container by adding the following to the HTML template of one of your components:\n\n```", "```js\n\n In the component class, you need to add the active widget property that’s used for the input of the widget container:\n\n```", "```js\n\n Let’s say we want to alternate between the clock and the weather widget every 5 seconds. We can use `setInterval` for this and assign the `activeWidget` property with the clock or weather widget:\n\n```", "```js\n\n When you open your component in the browser, you will see that after 5 seconds, the weather widget is shown, and the widget will alternate with the clock widget every 5 seconds after that. This is, of course, just a simple example and can be improved upon a lot, but it shows how to render the widgets dynamically quite well.\nLet’s continue and see how we can improve the widget container and add additional flexibility. In some scenarios, your widget components might need data or access to a service to function properly. When the widget needs to do this, you can add an injector to the `ngComponentOutlet` directive.\nUsing an injector with ngComponentOutlet\nYou can provide additional data to your dynamically loaded components using the `injector` property of the `ngComponentOutlet` directive.\nLet’s start by adding the `injector` property to the `ngComponentOutlet` directive inside the HTML template of the widget container component:\n\n```", "```js\nexport interface widget { component: Type<any> | null; injector property, you must adjust the widget and the input the widget container component receives. First, we will adjust the widget. As an example, we will adjust the weather widget so that it can receive a city and a message that we will display in the HTML template.\nCreate a new file called `widget-tokens.ts` and add an interface for the weather widget data and an injection token, like this:\n\n```", "```js\n\n Inside the weather widget component class, you need to inject the `WEATHERWIDGET` injection token:\n\n```", "```js\n\n Now, adjust the HTML template of the weather widget component so that it uses the values of the `WeatherWidgetData` interface:\n\n```", "```js\n\n That is everything you need to do inside the weather widget component itself. So, to reiterate, you created an interface and injection tokens, you injected the injection token, and you will receive the injector from the widget container’s `ngComponentOutlet` injector property. To close the circle and make everything work, you need to provide the correct input to the widget container and include the injector that will provide the city and message data.\nBefore you added the injector, you provided the following as input to the widget container to display the weather widget:\n\n```", "```js\n\n To provide the city and message data for the weather widget, you need to add the `injector` property to the input so that the widget container can include it in the `ngComponentOutlet` directive.\nYou can create the `injector` property by using the `create()` method on the `Injector` class:\n\n```", "```js\n\n Inside this `create` method, there’s a `providers` object. This is similar to the provider objects you added inside the `providers` array to a component, module, or your application configuration object in your `app.config.ts` file:\n\n```", "```js\n\n For the `provide` property, use the injection token you created inside the weather widget component file. For our example, you’ll use the `useValue` property and assign it to the city and message value you want to use. You can create any valid provider object here, so you can also provide services or factory classes instead of the `useValue` property. The entire `Injector.create()` method looks like this:\n\n```", "```js\n\n The entire input object for the widget container looks like this:\n\n```", "```js\n\n Now, when the weather widget is displayed through the widget container, the `injector` property is passed along, and the city and message values are used within the HTML template of the weather widget. Cool stuff!\nUsing the `inject` property of the `ngComponentOutlet` directive allows you to provide any service, factory method, or static data to the dynamically rendered components, making that dynamically rendered component as flexible as any other component.\nSince Angular version 16.2.0-next.4, you can simplify providing (simple) values to dynamic components a bit by using the inputs property on the `ngComponentOutlet` directive instead of the injector property. To use the inputs property on `ngComponentOutlet`, you need to add `@Input()` properties to the widget. In our example, we can add `city` and `message` `@Input()` properties to the weather widget:\n\n```", "```js\n\n Once you’ve added the `@Input()` properties to the widget, you can provide the `@Input()` properties with values through the `ngComponentOutlet` `inputs` property, like this:\n\n```", "```js\nwidgetInputs = {\n  'city': 'Amsterdam',\n  'message': 'Sunny',\n}\n```", "```js\nconst widgetKeys = ['weatherWidget', 'clockWidget'] as const;\ntype WidgetKey = typeof widgetKeys[number];\nexport type WidgetLoader = { [key in WidgetKey]: () => Promise<any> };\nexport const widgetLoaders: WidgetLoader = {\n  weatherWidget: () => import('../weather-widget/weather-widget.component'),\n  clockWidget: () => import('../clock-widget/clock-widget.component'),\n};\nexport type WidgetOption = WidgetLoader[keyof WidgetLoader];\n```", "```js\n@Input() injector!: Injector;\n@Input({ required: true }) widgetLoader!: WidgetOption;\nwidget: widget = { component: null, injector: null };\n```", "```js\nprotected readonly cd = inject(ChangeDetectorRef);\n```", "```js\nasync ngOnChanges(changes: SimpleChanges) {}\n```", "```js\nconst widgetLoader: WidgetOption = changes['widgetLoader'].currentValue;\n```", "```js\nconst widget = await widgetLoader();\nthis.widget = { component: widget[Object.keys(widget)[0]], injector: this.injector };\nthis.cd.detectChanges();\n```", "```js\n<bt-libs-widget-container [widgetLoader]=\"widget\" [injector]=\"injector\"></bt-libs-widget-container>\n```", "```js\nwidget: WidgetOption = widgetLoaders.weatherWidget;\ninjector: Injector | null = Injector.create({ providers: [{ provide: WEATHERWIDGET, useValue: { city: 'Amsterdam', message: 'Sunny' } }] });\nprotected readonly cd = inject(ChangeDetectorRef);\nngOnInit() {\n  setInterval(() => {\n    this.widget = this.widget === widgetLoaders.clockWidget ? widgetLoaders.weatherWidget : widgetLoaders.clockWidget;\n    this.injector = this.widget === widgetLoaders.clockWidget ? null : Injector.create({ providers: [{ provide: WEATHERWIDGET, useValue: { city: 'Amsterdam', message: 'Sunny' } }] });\n    this.cd.detectChanges();\n  }, 5000)\n}\n```", "```js\nexport enum Widgets {\n  Clock,\n  Weather\n}\n```", "```js\n@Input() activeWidget!: Widgets;\n@Input() activeData!: any;\nwidgets = Widgets;\n```", "```js\n@defer (when activeWidget === widgets.Clock) {\n  <bt-libs-clock-widget *ngIf=\"activeWidget === widgets.Clock\" />\n}\n@defer (when activeWidget === widgets.Weather) {\n  <bt-libs-weather-widget *ngIf=\"activeWidget === widgets.Weather\" [widgetData]=\"widgetData\" />\n}\n```", "```js\n// widgetData: WeatherWidgetData = inject(WEATHERWIDGET);\n@Input() widgetData!: WeatherWidgetData | null;\n```", "```js\n<p *ngIf=\"widgetData\">{{widgetData.city}}: {{widgetData.message}}</p>\n```", "```js\n<bt-libs-defer-widget [activeWidget]=\"widget\" [widgetData]=\"widgetData\" />\n```", "```js\nwidget!: Widgets;\nwidgetData: any = null;\n```", "```js\nthis.widget = this.widget === Widgets.Clock ? Widgets.Weather : Widgets.Clock;\nthis.widgetData = this.widget === Widgets.Clock ? null : { city: 'Amsterdam', message: 'Sunny' };\nthis.cd.detectChanges();\n```", "```js\n\n```", "```js\n\n```", "```js\n\n```", "```js\n\n```", "```js\n\n```", "```js\n\n```"]