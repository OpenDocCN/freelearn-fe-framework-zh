- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Forms, Observables, and Subjects
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单、Observables和Subjects
- en: So far, you've been working with putting together the essential elements that
    make up an Angular application, such as modules, components, pipes, services,
    RxJS, unit testing, and environment variables, and even going a step further by
    learning how to deliver your web application using Docker and giving it a polished
    look with Angular Material.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经一直在构建构成Angular应用程序的基本元素，例如模块、组件、管道、服务、RxJS、单元测试和环境变量，甚至更进一步，学习如何使用Docker交付你的网络应用，并用Angular
    Material给它一个光鲜的外观。
- en: 'At this point, our app is not interactive. It can only pull weather information
    for one city. As a result, it is not a very useful app. To build an interactive
    app, we need to be able to handle user input. Enabling user input in your application
    opens up possibilities for creating great user experiences. Consider google.com''s
    landing page:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用还不是交互式的。它只能为单个城市获取天气信息。因此，它不是一个非常有用的应用。为了构建一个交互式应用，我们需要能够处理用户输入。在你的应用程序中启用用户输入可以打开创建出色用户体验的可能性。考虑一下google.com的登录页面：
- en: '![](img/B14094_06_01.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_06_01.png)'
- en: 'Figure 6.1: Google''s landing page'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：谷歌的登录页面
- en: In this context, what is Google Search, apart from a simple input field with
    two buttons? That simple input field unlocks some of the world's most sophisticated
    and advanced software technologies. It is a deceptively simple and an insanely
    powerful way to interact with users. You can augment user input by leveraging
    modern web functionality such as `GeoLocation` and gain new meaning from user
    input. So, when the user types in `Paris` you don't have to guess if they mean
    Paris, France, or Paris, Texas, or whether you should show the current temperature
    in Celsius or Fahrenheit. With `LocalStorage`, you can cache user credentials
    and remember user preferences so that you can enable dark mode in your app.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，除了一个简单的带有两个按钮的输入字段之外，谷歌搜索是什么？那个简单的输入字段解锁了世界上一些最复杂和最先进的软件技术。这是一种欺骗性的简单且疯狂强大的与用户互动的方式。你可以通过利用现代网络功能，如`GeoLocation`来增强用户输入，并从用户输入中获得新的意义。因此，当用户输入`巴黎`时，你不必猜测他们是指法国的巴黎，还是德克萨斯州的巴黎，或者你是否应该显示摄氏度或华氏度的当前温度。使用`LocalStorage`，你可以缓存用户凭据并记住用户偏好，这样你就可以在你的应用中启用暗黑模式。
- en: By the end of this chapter, we won't be implementing Google, GeoLocation, or
    dark mode, but will enable users to search for their cities using a city name
    or postal code (often referred to as "zip codes" in the US). Once you realize
    how complicated it can get implementing something as seemingly simple as a search
    by postal code, you may gain a new appreciation for well-designed web apps.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们不会实现谷歌、地理位置或暗黑模式，而是将允许用户通过城市名称或邮政编码（在美国通常被称为“邮编”）来搜索他们的城市。一旦你意识到实现看似简单的按邮政编码搜索功能可能会多么复杂，你可能会对精心设计的网络应用产生新的敬意。
- en: To build a UX driven by an input field, we need to leverage Angular forms with
    validation messages so that we can create engaging search experiences with search-as-you-type
    functionality. Behind the scenes, RxJS/BehaviorSubject enables us to build decoupled
    components that can communicate with one another and a reactive data stream allows
    us to merge data from multiple web APIs without increasing the complexity of our
    app.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个由输入字段驱动的UX，我们需要利用Angular表单和验证消息，这样我们就可以创建具有搜索即输入功能的引人入胜的搜索体验。在幕后，RxJS/BehaviorSubject使我们能够构建解耦的组件，它们可以相互通信，而响应式数据流允许我们合并来自多个网络API的数据，而不会增加我们应用程序的复杂性。
- en: 'In this chapter, you are going to learn about:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将要学习以下内容：
- en: Template-driven and reactive forms, including two-way binding and input field
    validation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板驱动和响应式表单，包括双向绑定和输入字段验证
- en: Interactions between components
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件之间的交互
- en: Observables and RxJS/BehaviorSubject
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Observables和RxJS/BehaviorSubject
- en: Managing subscriptions, and how to handle memory leaks and unsubscribing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理订阅，以及如何处理内存泄漏和取消订阅
- en: Handling multiple API calls with the async pipe, including chaining multiple
    API calls
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用async pipe处理多个API调用，包括链式多个API调用
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the repository linked as follows. The repository contains the final and completed
    state of the code. You can verify your progress at the end of this chapter by
    looking for the end-of-chapter snapshot of code under the `projects` folder.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书样本代码的最新版本可在GitHub上找到，链接如下。该存储库包含代码的最终和完成状态。你可以在本章末尾通过查找`projects`文件夹下的代码末尾快照来验证你的进度。
- en: 'For *Chapter 6*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**第6章**：
- en: Clone the repo [https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app
    )
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆仓库[https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
- en: Execute `npm install` on the root folder to install dependencies
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录下执行`npm install`以安装依赖项
- en: 'The code sample for this chapter is under the sub-folder:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本章的代码示例位于子文件夹中：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To run the Angular app for this chapter, execute:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的Angular应用，请执行：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To run Angular unit tests for this chapter, execute:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的Angular单元测试，请执行：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To run Angular e2e tests for this chapter, execute:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的Angular端到端测试，请执行：
- en: '[PRE3]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To build a production-ready Angular app for this chapter, execute:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建本章的生产级Angular应用，请执行：
- en: '[PRE4]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that the `dist/ch6` folder at the root of the repository will contain the
    compiled result.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，存储库根目录下的`dist/ch6`文件夹将包含编译结果。
- en: Beware that the source code in the book or on GitHub may not always match the
    code generated by the Angular CLI. There may also be slight differences in implementation
    between the code in the book and what's on GitHub because the ecosystem is ever-evolving.
    It is natural for the sample code to change over time. Also on GitHub, expect
    to find corrections, fixes to support newer versions of libraries, or side-by-side
    implementations of multiple techniques for the reader to observe. The reader is
    only expected to implement the ideal solution recommended in the book. If you
    find errors or have questions, please create an issue or submit a pull request
    on GitHub for the benefit of all readers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，书中或GitHub上的源代码可能并不总是与Angular CLI生成的代码匹配。书中和GitHub上的实现之间也可能存在细微的差异，因为生态系统是不断演变的。随着时间的推移，示例代码发生变化是自然的。在GitHub上，你可能会找到更正、修复以支持库的新版本，或者为读者观察而并排实现多种技术的示例。读者只需实现书中推荐的理想解决方案即可。如果你发现错误或有疑问，请创建一个issue或提交一个pull
    request到GitHub，以供所有读者受益。
- en: 'Next, let''s see how we can implement an input field using forms. Forms are
    the primary mechanism that we need to capture user input. In Angular, there are
    two kinds of forms: reactive and template-driven. We need to cover both techniques,
    so that you''re familiar with how forms work in Angular.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何使用表单实现一个输入字段。表单是我们捕获用户输入的主要机制。在Angular中，有两种类型的表单：响应式和模板驱动。我们需要涵盖这两种技术，以便你熟悉Angular中表单的工作方式。
- en: Reactive forms versus template-driven forms
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式表单与模板驱动表单
- en: Now, we'll implement the search bar on the home screen of the application. The
    next user story states **Display forecast information for current location**,
    which may be taken to imply an inherent GeoLocation functionality. However, as
    you may note, GeoLocation is listed as a separate task. The challenge is that
    with native platform features such as GeoLocation, you are never guaranteed to
    receive the actual location information. This may be due to signal loss issues
    on mobile devices or the user may simply refuse to give permission to share their
    location information.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现在应用程序主屏幕上的搜索栏。下一个用户故事是**显示当前位置的预报信息**，这可能意味着固有的地理位置功能。然而，正如你可能注意到的，地理位置被列为一个单独的任务。挑战在于，使用原生的平台功能，如地理位置，你永远不能保证收到实际的位置信息。这可能是由于移动设备上的信号丢失问题，或者用户可能简单地拒绝分享他们的位置信息。
- en: 'First and foremost, we must deliver a good baseline UX and implement value-added
    functionality such as GeoLocation only afterward. Instead, let''s move **Add city
    search capability ...** to **In progress**, as shown on our Kanban board:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先最重要的是，我们必须提供一个良好的基线用户体验，并在之后仅实现增值功能，如地理位置。相反，让我们将**添加城市搜索功能 ...**移动到**进行中**，如图我们在看板上的所示：
- en: '![](img/B14094_06_02.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_06_02.png)'
- en: 'Figure 6.2: GitHub project Kanban board'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：GitHub项目看板
- en: As part of this story, we are going to implement a search-as-you-type functionality
    while providing feedback to the user if the service is unable to retrieve the
    expected data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个故事的一部分，我们将实现一个边打字边搜索的功能，并在服务无法检索到预期数据时向用户提供反馈。
- en: Initially, it may be intuitive to implement a type-search mechanism; however,
    `OpenWeatherMap` APIs don't provide such an endpoint. Instead, they provide bulk
    data downloads, which are costly and are in the multiples of megabytes range.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，实现一个类型搜索机制可能看起来很直观；然而，`OpenWeatherMap` API没有提供这样的端点。相反，它们提供批量数据下载，这些数据成本高昂，且在兆字节级别。
- en: We will need to implement our application server to expose such an endpoint
    so that our app can effectively query while using minimal amounts of data.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现我们的应用程序服务器以公开这样的端点，这样我们的应用程序就可以在尽可能少的数据使用情况下有效地查询。
- en: The free endpoints for `OpenWeatherMap` do pose an interesting challenge, where
    a two-digit country code may accompany either a city name or zip code for the
    most accurate results. This is an excellent opportunity to implement a feedback
    mechanism to the user if more than one result is returned for a given query.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenWeatherMap` 的免费端点确实提出了一个有趣的挑战，即两位数字的国家代码可能伴随城市名称或邮政编码，以获得最准确的结果。这是实现用户反馈机制的一个绝佳机会，如果针对给定查询返回多个结果。'
- en: We want every iteration of the app to be a potentially releasable increment
    and avoid doing too much at any given time.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望应用程序的每个迭代都成为一个可能发布的增量，并避免在任何给定时间内做太多。
- en: 'Before you begin working on a story, it is a good idea to break the story out
    into technical tasks. The following is the task breakdown for this story:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始处理一个故事之前，将故事分解为技术任务是一个好主意。以下是这个故事的分解任务：
- en: Add Angular form control so that we can capture user input events.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 Angular 表单控件，以便我们可以捕获用户输入事件。
- en: Use Angular Material input as documented at [https://material.angular.io/components/input](https://material.angular.io/components/input)
    to improve the UX of the input field.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用在 [https://material.angular.io/components/input](https://material.angular.io/components/input)
    上记录的 Angular Material 输入来改进输入字段的用户体验。
- en: Create the search bar as a separate component to enforce separation of concerns
    and a decoupled component architecture.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将搜索栏作为一个独立的组件来强制实施关注点分离和松耦合的组件架构。
- en: Extend the existing endpoint to accept a zip code and make the country code
    optional in `weather.service.ts` in order to make it more intuitive for end users
    to interact with our app.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `weather.service.ts` 中扩展现有端点以接受邮政编码，并将国家代码作为可选项，以便使最终用户与我们的应用程序交互更加直观。
- en: Throttle requests so that we don't query the API with every keystroke, but at an
    interval where users still get immediate feedback without having to click on a
    separate button.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 节流请求，这样我们就不需要在每次按键时查询 API，而是在用户仍然能够立即获得反馈而不必点击单独按钮的间隔内进行查询。
- en: Let's tackle these tasks over the next few sections.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的几节中解决这些任务。
- en: Adding Angular reactive forms
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Angular 响应式表单
- en: You may wonder why we're adding Angular forms since we are adding just a single
    input field and not a form with multiple inputs. As a general rule of thumb, any
    time you add an input field, it should be wrapped in a `<form>` tag. The `Forms`
    module contains the `FormControl` that enables you to write the backing code behind
    the input field to respond to user inputs, and provide the appropriate data or
    the validation or message in response.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道为什么我们要添加 Angular 表单，因为我们只添加了一个输入字段，而不是一个包含多个输入字段的表单。作为一个一般规则，每次您添加一个输入字段时，它都应该被
    `<form>` 标签包裹。`Forms` 模块包含 `FormControl`，它使您能够编写输入字段背后的支持代码以响应用户输入，并提供适当的数据或验证或消息作为响应。
- en: 'There are two types of forms in Angular:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 中有两种类型的表单：
- en: '**Template-driven forms**: These forms are similar to what you may be familiar
    with in the case of AngularJS, where the form logic is mostly inside the HTML
    template. I''m personally not a fan of this approach because it is harder to test
    these behaviors, and fat HTML templates become challenging to maintain quickly.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板驱动的表单**：这些表单与您可能在 AngularJS 的情况下所熟悉的内容相似，其中表单逻辑主要在 HTML 模板内部。我个人并不喜欢这种方法，因为它更难测试这些行为，而且庞大的
    HTML 模板难以快速维护。'
- en: '**Reactive forms**: The behavior of reactive forms is driven by TypeScript
    code written in the controller. This means that your validation logic can be unit
    tested and, better yet, reused across your application. Reactive forms are the
    core technology that, in the future, will enable the Angular Material team to
    write automated tools that can autogenerate an input form based on a TypeScript
    interface.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式表单**：响应式表单的行为由控制器中编写的 TypeScript 代码驱动。这意味着您的验证逻辑可以进行单元测试，并且更好的是，可以在您的应用程序中重用。响应式表单是未来将使
    Angular Material 团队能够编写自动化工具的核心技术，这些工具可以根据 TypeScript 接口自动生成输入表单。'
- en: Read more about reactive forms at [https://angular.io/guide/reactive-forms](https://angular.io/guide/reactive-forms).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [https://angular.io/guide/reactive-forms](https://angular.io/guide/reactive-forms)
    上了解更多关于响应式表单的信息。
- en: 'Let''s start by importing `FormsModule` and `ReactiveFormsModule` into our
    app:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先将 `FormsModule` 和 `ReactiveFormsModule` 导入到我们的应用程序中：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that in a pure reactive form implementation, you only need the `ReactiveFormsModule`.
    `FormsModule` supports template-driven forms, and other scenarios, where you may
    only want to declare a `FormControl` without a `FormGroup`. This is how we implement
    the input field for this app. `FormGroup` is defined in the next section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在纯响应式表单实现中，你只需要`ReactiveFormsModule`。`FormsModule`支持模板驱动表单和其他场景，在这些场景中，你可能只想声明一个没有`FormGroup`的`FormControl`。这就是我们实现应用程序输入字段的办法。`FormGroup`将在下一节中定义。
- en: Also, reactive forms allow you to write code in the reactive paradigm, which
    is a net positive. Next, let's add a city search component to our app.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，响应式表单还允许你以响应式范式编写代码，这是一个净正面的结果。接下来，让我们将城市搜索组件添加到我们的应用程序中。
- en: Adding and verifying components
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加和验证组件
- en: 'We will be creating a `citySearch` component using Material form and input
    modules:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Material表单和输入模块创建一个`citySearch`组件：
- en: 'Add `MatFormFieldModule` and `MatInputModule` to `material.module.ts` so that
    it becomes available for use in the app:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MatFormFieldModule`和`MatInputModule`添加到`material.module.ts`中，使其在应用程序中可用：
- en: '[PRE6]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We're adding `MatFormFieldModule` because each input field should be wrapped
    in a `<mat-form-field>` tag to get the most out of Angular Material functionality.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加`MatFormFieldModule`是因为每个输入字段都应该被`<mat-form-field>`标签包裹，以充分利用Angular Material的功能。
- en: At a high level, `<form>` encapsulates numerous default behaviors for keyboard,
    screen-reader, and browser extension users; `<mat-form-field>` enables easy two-way
    data binding, a technique that should be used in moderation, and also allows for
    graceful label, validation, and error message displays.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从高层次来看，`<form>`封装了键盘、屏幕阅读器和浏览器扩展用户的大量默认行为；`<mat-form-field>`使双向数据绑定变得简单，这是一种应该适度使用的技巧，同时也允许优雅地显示标签、验证和错误消息。
- en: 'Create the new `citySearch` component:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新的`citySearch`组件：
- en: '[PRE7]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Since we added the `material.module.ts` file, `ng` can't guess what feature
    module `citySearch` should be added to, resulting in an error such as `More than
    one module matches`. Therefore, we need to provide the module that we want `citySearch`
    to be added to, using the `--module` option. Use the `--skip-import` option to
    skip importing the component into any module.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们添加了`material.module.ts`文件，`ng`无法猜测应该将`citySearch`添加到哪个功能模块中，导致出现“多个模块匹配”等错误。因此，我们需要使用`--module`选项提供我们希望`citySearch`添加到的模块。使用`--skip-import`选项跳过将组件导入任何模块。
- en: 'Create a basic template, replacing the existing content:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基本模板，替换现有内容：
- en: '[PRE8]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Declare a property named `search` and instantiate it as an instance of `FormControl`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`search`的属性，并将其实例化为`FormControl`的一个实例：
- en: '[PRE9]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Reactive forms have three levels of control:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 响应式表单有三个级别的控制：
- en: '`FormControl` is the most basic element that has a one-to-one relationship
    with an input field.'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormControl`是最基本的元素，它与输入字段有一个一对一的关系。'
- en: '`FormArray` represents repetitive input fields that represent a collection
    of objects.'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormArray`表示重复的输入字段，这些字段代表一组对象。'
- en: '`FormGroup` is used to register individual `FormControl` or `FormArray` objects
    as you add more input fields to a form.'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormGroup`用于在添加更多输入字段到表单时注册单个`FormControl`或`FormArray`对象。'
- en: Finally, the `FormBuilder` object is used to orchestrate and maintain the actions
    of a `FormGroup` object more easily. `FormBuilder` and `FormGroup` are first used
    in *Chapter 8*, *Designing Authentication and Authorization*, and all controls,
    including `FormArray`, are covered in depth in *Chapter 11*, *Recipes – Reusability,
    Routing, and Caching*.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，使用`FormBuilder`对象可以更轻松地编排和维护`FormGroup`对象的操作。`FormBuilder`和`FormGroup`首次在*第8章*，*设计身份验证和授权*中介绍，所有控件，包括`FormArray`，在第11章*，*食谱
    - 可重用性、路由和缓存*中都有深入介绍。
- en: 'Add `app-city-search` to `app.component.ts` as a new `div` in between the row
    that contains the tagline of the app and the row that contains `mat-card`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`app-city-search`添加到`app.component.ts`中，作为包含应用程序标语和包含`mat-card`的行的中间新的`div`：
- en: '[PRE10]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Test the integration of components by checking out the app in the browser, as
    shown:![](img/B14094_06_03.png)
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在浏览器中查看应用程序来测试组件的集成，如图所示：![](img/B14094_06_03.png)
- en: 'Figure 6.3: LocalCast Weather app with a search field'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.3：带有搜索字段的LocalCast天气应用程序
- en: If no errors occur, now we can start adding the `FormControl` elements and wire
    them to a search endpoint.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有发生错误，现在我们可以开始添加`FormControl`元素并将它们连接到搜索端点。
- en: Adding a search option to the weather service
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向天气服务添加搜索选项
- en: So far, we have been passing parameters to get the weather for a city using
    its name and country code. By allowing users to enter zip codes, we must make
    our service more flexible in accepting both types of inputs.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直通过使用城市名称和国家代码来传递参数以获取城市的天气。通过允许用户输入邮编，我们必须使我们的服务在接受这两种类型的输入时更加灵活。
- en: 'OpenWeatherMap''s API accepts URI parameters, so we can refactor the existing
    `getCurrentWeather` function (introduced in *Chapter 3*, *Creating a Basic Angular
    App*) using a TypeScript union type and a type guard. That means we can supply
    different parameters, while preserving type checking:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: OpenWeatherMap的API接受URI参数，因此我们可以使用TypeScript联合类型和类型守卫重构现有的`getCurrentWeather`函数（在*第3章*，*创建一个基本的Angular应用*中介绍）。这意味着我们可以提供不同的参数，同时保留类型检查：
- en: 'Refactor the `getCurrentWeather` function in `weather.service.ts` to handle
    both `zip` and `city` inputs:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`weather.service.ts`中的`getCurrentWeather`函数重构以处理`zip`和`city`输入：
- en: '[PRE11]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We renamed the `city` parameter to `search` since it can either be a city name
    or a zip code. We then allowed its type to be either a `string` or a `number`,
    and depending on what the type is at runtime, we will either use `q` or `zip`.
    We also made `country` optional and only append it to the query if it exists.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将`city`参数重命名为`search`，因为它可以是城市名称或邮编。然后我们允许其类型为`string`或`number`，并且根据运行时类型，我们将使用`q`或`zip`。我们还使`country`成为可选的，并且只有在它存在时才将其附加到查询中。
- en: '`getCurrentWeather` now has business logic embedded into it and is thus a good
    target for unit testing. Following the single responsibility principle, from the
    SOLID principles, we will refactor the HTTP call to its own function, called `getCurrentWeatherHelper`.'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`getCurrentWeather`现在具有嵌入的业务逻辑，因此它是单元测试的良好目标。遵循SOLID原则中的单一职责原则，我们将HTTP调用重构为其自己的函数，称为`getCurrentWeatherHelper`。'
- en: Refactor the HTTP call into `getCurrentWeatherHelper`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将HTTP调用重构为`getCurrentWeatherHelper`。
- en: 'In the next sample, note the use of a backtick character, `` ` ``, instead
    of a single-quote character, `''`, which leverages the template literals'' functionality
    that allows embedded expressions in JavaScript:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一个示例中，请注意使用反引号字符`` ` ``而不是单引号字符`'`，这利用了模板字面量的功能，允许在JavaScript中嵌入表达式：
- en: '[PRE12]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As a positive side effect, `getCurrentWeatherHelper` adheres to the open/closed
    principle. After all, it is open to extension by our ability to change the function's
    behavior by supplying different `uriParams` and is closed to modification because
    it won't have to be changed frequently.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为积极的副作用，`getCurrentWeatherHelper`遵循开闭原则。毕竟，它可以通过提供不同的`uriParams`来扩展我们的函数行为，并且由于它不需要经常更改，因此它是封闭的，不会进行修改。
- en: To demonstrate the latter point, let's implement a new function to get the current
    weather by latitude and longitude.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们实现一个新函数，通过纬度和经度获取当前天气。
- en: 'Implement `getCurrentWeatherByCoords`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`getCurrentWeatherByCoords`：
- en: '[PRE13]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, `getCurrentWeatherHelper` can easily be extended without any
    modification.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，`getCurrentWeatherHelper`可以很容易地扩展而无需任何修改。
- en: 'Ensure that you update `IWeatherService` with the changes made earlier:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您更新`IWeatherService`以包含之前所做的更改：
- en: '[PRE14]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As a result of adhering to the SOLID design principles, we make it easier to
    robustly unit test flow-control logic and ultimately end up writing code that
    is more resilient to bugs and is cheaper to maintain.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于坚持SOLID设计原则，我们使得对流程控制逻辑进行健壮的单元测试变得更容易，最终写出的代码对错误的抵抗力更强，且维护成本更低。
- en: Implementing a search
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现搜索
- en: 'Now, let''s connect the new service method to the input field:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将新的服务方法连接到输入字段：
- en: 'Update `citySearch` to inject the `weatherService` and subscribe to input changes:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`citySearch`更新为注入`weatherService`并订阅输入变化：
- en: '[PRE15]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We are treating all input as `string` at this point. The user input can be a
    city, zip code, or a city and country code, or a zip code and country code, separated
    by a comma. While a city or zip code is required, a country code is optional.
    We can use the `String.split` function to parse any potential comma-separated
    input and then trim any whitespace out from the beginning and the end of the string
    with `String.trim`. We then ensure that we trim all parts of the string by iterating
    over them with `Array.map`.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前我们将所有输入视为`string`。用户输入可以是城市、邮编，或者城市和国家的代码，或者邮编和国家的代码，用逗号分隔。虽然城市或邮编是必需的，但国家代码是可选的。我们可以使用`String.split`函数来解析任何潜在的逗号分隔输入，然后使用`String.trim`从字符串的开始和结束处去除任何空白字符。然后，我们通过使用`Array.map`遍历它们来确保去除字符串的所有部分。
- en: We then deal with the optional parameter with the ternary operator `?:`, only
    passing in a value if it exists, otherwise leaving it undefined.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用三元运算符 `?:` 来处理可选参数，只有当它存在时才传递值，否则将其定义为未定义。
- en: 'Implement the search handler:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现搜索处理程序：
- en: '[PRE16]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add a hint for the user, under the input field, informing them about the optional
    country functionality:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入字段下方为用户提供一个提示，告知他们有关可选的国家功能：
- en: '[PRE17]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: At this point, the subscribe handler will make calls to the server and log its
    output to the console.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，订阅处理程序将调用服务器并记录其输出到控制台。
- en: Observe how this works using Chrome DevTools. Note how often the `search` function
    is run and that we are not handling service errors.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Chrome DevTools 观察这是如何工作的。注意 `search` 函数运行的频率，以及我们没有处理服务错误。
- en: Limiting user inputs with throttle/debounce
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 throttle/debounce 限制用户输入
- en: At the moment, we submit a request to the server with every keystroke. This
    is not desirable behavior, because it can lead to a bad user experience and drain
    battery life, resulting in wasted network requests and performance issues both
    on the client and server side. Users make typos; they can change their mind about
    what they are inputting and rarely ever do the first few characters of information
    input result in useful results.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们每次按键都会向服务器提交一个请求。这种行为并不可取，因为它可能导致不良的用户体验和电池寿命的消耗，从而在客户端和服务器端都造成网络请求的浪费和性能问题。用户会犯拼写错误；他们可能会改变他们输入的内容，而且很少会有信息输入的前几个字符就能产生有用的结果。
- en: We can still listen to every keystroke, but we don't have to react to every
    keystroke. By leveraging `throttle`/`debounce`, we can limit the number of events
    generated to a predetermined interval and still maintain the type-as-you-search
    functionality.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以监听每个按键，但不必对每个按键做出反应。通过利用 `throttle`/`debounce`，我们可以将生成的事件数量限制在预定的间隔内，同时仍然保持按搜索输入的功能。
- en: Note that `throttle` and `debounce` are not functional equivalents, and their
    behavior will differ from framework to framework. In addition to throttling, we
    expect to capture the last input that the user has typed. In the `lodash` framework,
    the `throttle` function fulfills this requirement, whereas, in `RxJS`, `debounce`
    fulfills it. Beware that this discrepancy may be fixed in future framework updates.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`throttle` 和 `debounce` 不是功能等效的，它们的行为会因框架而异。除了节流之外，我们还期望捕获用户最后输入的内容。在 `lodash`
    框架中，`throttle` 函数满足这一要求，而在 `RxJS` 中，`debounce` 满足这一要求。请注意，这种差异可能在未来的框架更新中得以解决。
- en: 'It is very easy to inject throttling into the observable stream using `RxJS/debounceTime`.
    Implement `debounceTime` with `pipe`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `RxJS/debounceTime` 非常容易将节流注入可观察流中。使用 `pipe` 实现 `debounceTime`：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`debounceTime` will, at a maximum, run a search every second, but also run
    another search after the user has stopped typing. In comparison, `RxJS/throttleTime`
    will only run a search every second, on the second, and will not necessarily capture
    the last few characters the user may have input.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`debounceTime` 最多每秒运行一次搜索，但用户停止输入后也会运行另一个搜索。相比之下，`RxJS/throttleTime` 只会在每秒的第二秒运行一次搜索，并且不一定能捕获用户可能输入的最后几个字符。'
- en: RxJS also has the `throttle` and `debounce` functions, which you can use to
    implement custom logic to limit input that is not necessarily time-based.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS 还提供了 `throttle` 和 `debounce` 函数，您可以使用这些函数来实现自定义逻辑，以限制非基于时间的输入。
- en: Since this is a time- and event-driven functionality, breakpoint debugging is
    not feasible. You may monitor the network calls within the **Chrome Dev Tools
    | Network** tab, but to get a more real-time feel for how often your search handler
    is actually being invoked, add a `console.log` statement.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个基于时间和事件的功能，因此断点调试不可行。您可以在 **Chrome Dev Tools | Network** 选项卡中监控网络调用，但要更实时地了解您的搜索处理程序实际被调用的频率，请添加一个
    `console.log` 语句。
- en: It is not a good practice to check in code with active `console.log` statements.
    As covered in *Chapter 3*, *Creating a Basic Angular App*, `console.log` is a
    poor man's debugging method. The statements make it difficult to read the actual
    code, which itself bears a high cost of maintainability. So, whether they are
    commented out or not, do not check in code with `console.log` statements.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中检查带有活动 `console.log` 语句的做法并不好。如 *第3章* 中所述，*创建基本的 Angular 应用程序*，`console.log`
    是一种穷人的调试方法。这些语句使得阅读实际代码变得困难，而代码本身具有很高的维护成本。因此，无论是否注释掉，都不要检查带有 `console.log` 语句的代码。
- en: Input validation and error messages
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入验证和错误消息
- en: '`FormControl` is highly customizable. It allows you to set a default initial
    value, add validators, or listen to changes on `blur`, `change`, and `submit`
    events, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormControl` 具有高度的自定义性。它允许您设置默认的初始值，添加验证器，或监听 `blur`、`change` 和 `submit` 事件，如下所示：'
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We won''t be initializing `FormControl` with a value, but we need to implement
    a validator to disallow single character inputs:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会用值初始化 `FormControl`，但我们需要实现一个验证器来禁止单字符输入：
- en: 'Import `Validators` from `@angular/forms`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `@angular/forms` 中导入 `Validators`：
- en: '[PRE20]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Modify `FormControl` to add a minimum length validator:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `FormControl` 以添加最小长度验证器：
- en: '[PRE21]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Modify the template to show a validation error message below the hint text:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改模板以在提示文本下方显示验证错误信息：
- en: '[PRE22]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note the addition of some extra margin to make room for lengthy error messages.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意添加了一些额外的边距，为长错误信息腾出空间。
- en: 'If you are handling different kinds of errors, the `hasError` syntax in the
    template can get repetitive. You may want to implement a more scalable solution
    that can be customized through code, as shown:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您正在处理不同类型的错误，模板中的 `hasError` 语法可能会变得重复。您可能希望实现一个更可扩展的解决方案，可以通过代码进行定制，如下所示：
- en: '[PRE23]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Modify the `search` function to not execute a search with invalid input replacing
    the condition in the existing `if` statement:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `search` 函数，使其在无效输入的情况下不执行搜索，替换现有 `if` 语句中的条件：
- en: '[PRE24]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Instead of doing a simple check to see whether `searchValue` is defined and
    not an empty string, we can tap into the validation engine for a more robust check
    by calling `this.search.invalid`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是简单地检查 `searchValue` 是否已定义且不为空字符串，我们可以通过调用 `this.search.invalid` 来利用验证引擎进行更健壮的检查。
- en: For now, we're done with implementing `search` functionality. Next, let's go
    over a what-if scenario to see how a template-driven implementation of the form
    would appear.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们已经完成了 `search` 功能的实现。接下来，让我们回顾一个假设场景，看看模板驱动的表单实现会是什么样子。
- en: Template-driven forms with two-way binding
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有双向绑定的模板驱动表单
- en: The alternative to reactive forms is template-driven forms. If you're familiar
    with `ng-model` from AngularJS, you'll find that the new `ngModel` directive is
    an API-compatible replacement for it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式表单的替代方案是模板驱动表单。如果您熟悉 AngularJS 中的 `ng-model`，您会发现新的 `ngModel` 指令是它的 API 兼容替代品。
- en: Behind the scenes, `ngModel` implements a `FormControl` that can automatically
    attach itself to a `FormGroup`. `ngModel` can be used at the `<form>` level or
    individual `<input>` level. You can read more about `ngModel` at [https://angular.io/api/forms/NgModel](https://angular.io/api/forms/NgModel).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`ngModel` 实现了一个可以自动附加到 `FormGroup` 的 `FormControl`。`ngModel` 可以在 `<form>`
    级别或单个 `<input>` 级别使用。您可以在 [https://angular.io/api/forms/NgModel](https://angular.io/api/forms/NgModel)
    上了解更多关于 `ngModel` 的信息。
- en: 'In the *Chapter 6* example code of the Local Weather app repository on GitHub,
    I have included a template-driven component in `app.component.ts` named `app-city-search-tpldriven`
    rendered under `<div class="example">`. You can experiment with this component
    to see what the alternate template implementation looks like:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 上 Local Weather 应用程序的存储库的 *第 6 章* 示例代码中，我在 `app.component.ts` 中包含了一个名为
    `app-city-search-tpldriven` 的模板驱动组件，该组件在 `<div class="example">` 下渲染。您可以尝试这个组件，看看替代的模板实现是什么样的：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note the `[()]` "box of bananas" two-way binding syntax in use with `ngModel`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用 `ngModel` 时使用的 `[()]` “香蕉箱”双向绑定语法。
- en: 'The differences in the component are implemented as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 组件中的差异如下实现：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, most of the logic is implemented in the template; as such, you
    are required to maintain an active mental model of the template and the controller.
    Any changes to event handlers and validation logic require you to switch back
    and forth between the two files.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，大部分逻辑都是在模板中实现的；因此，您需要保持对模板和控制器的一个活跃的心理模型。任何对事件处理程序和验证逻辑的更改都需要您在这两个文件之间来回切换。
- en: Furthermore, we have lost input limiting and the ability to prevent service
    calls when the input is in an invalid state. It is still possible to implement
    these features, but they require convoluted solutions and do not neatly fit into
    the new Angular syntax and concepts.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们已经失去了输入限制和防止在输入处于无效状态时调用服务的能力。尽管如此，仍然可以实施这些功能，但它们需要复杂的解决方案，并且无法很好地适应新的
    Angular 语法和概念。
- en: Overall, I do not recommend the use of template-driven forms. There may be a
    few instances where it may be very convenient to use the box of bananas syntax.
    However, this sets a bad precedent for other team members to replicate the same
    pattern around the application.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，我不推荐使用模板驱动的表单。可能有一些情况下使用香蕉盒语法会非常方便。然而，这为其他团队成员复制相同的模式在应用程序周围设定了一个不良的先例。
- en: Component interaction with BehaviorSubject
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`BehaviorSubject`进行组件交互
- en: 'To update the current weather information, we need the `city-search` component
    to interact with the `current-weather` component. There are four main techniques
    to enable component interaction in Angular:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新当前天气信息，我们需要`city-search`组件与`current-weather`组件交互。在Angular中，有四种主要技术可以启用组件交互：
- en: Global events
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局事件
- en: Parent components listening for information bubbling up from children components
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听从子组件向上冒泡信息的父组件
- en: Sibling, parent, or children components within a module that works off of similar
    data streams
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个基于相似数据流工作的模块中，兄弟、父或子组件
- en: Parent components passing information to children components
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父组件向子组件传递信息
- en: Global events
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局事件
- en: This is a technique that's been leveraged since the early days of programming
    in general. In JavaScript, you may have achieved this with global function delegates
    or jQuery's event system. In AngularJS, you may have created a service and stored
    values in it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种从编程早期就一直在使用的技巧。在JavaScript中，你可能通过全局函数委托或jQuery的事件系统实现了这一点。在AngularJS中，你可能创建了一个服务并在其中存储了值。
- en: In Angular, you can still create a root-level service, store values in it, use
    Angular's `EventEmitter` class, which is really meant for directives, or use an
    `rxjs/Subscription` to create a fancy messaging bus for yourself.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，你仍然可以创建一个根级服务，在其中存储值，使用Angular的`EventEmitter`类（它实际上是为指令设计的），或者使用`rxjs/Subscription`为自己创建一个花哨的消息总线。
- en: As a pattern, global events are open to rampant abuse and rather than helping
    to maintain a decoupled application architecture, it leads to a global state over
    time. A global state or even a localized state at the controller level, where
    functions read and write to variables in any given class, is enemy number one
    of writing maintainable and unit testable software.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种模式，全局事件容易受到滥用，而不是帮助维护解耦的应用程序架构，它随着时间的推移会导致全局状态。全局状态或甚至在控制器级别的本地化状态，其中函数在任意给定的类中读取和写入变量，是编写可维护和可单元测试的软件的头号敌人。
- en: Ultimately, if you're storing all your application data or routing all events
    in one service to enable component interaction, you're merely inventing a better
    mousetrap. This is an anti-pattern that should be avoided at all costs. In a later
    section, you will find that, essentially, we will still be using services to enable
    component interaction; however, I want to point out that there's a fine line that
    exists between a flexible architecture that enables decoupling and the global
    or centralized decoupling approach that does not scale well.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，如果你在一个服务中存储所有应用程序数据或路由所有事件以实现组件交互，你只是在发明一个更好的捕鼠器。这是一个应该不惜一切代价避免的反模式。在后面的章节中，你会发现，本质上，我们仍然会使用服务来实现组件交互；然而，我想指出，在允许解耦的灵活架构和全局或集中式解耦方法之间存在着一条细线，后者扩展性不佳。
- en: Child-parent relationships with event emitters
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于事件发射器的亲子关系
- en: Your child component should be completely unaware of its parent. This is key
    to creating reusable components.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你的子组件应该完全不知道它的父组件。这是创建可重用组件的关键。
- en: We can implement the communication between the city search component and the
    current weather component leveraging `AppComponent` as a parent element and let
    the `app` module controller orchestrate the data.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过利用`AppComponent`作为父元素，让`app`模块控制器协调数据来实现城市搜索组件和当前天气组件之间的通信。
- en: Commit your code now! In the next two sections you will be making code changes
    that you will need to discard.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在提交你的代码！在接下来的两个部分中，你将需要丢弃所做的代码更改。
- en: 'Let''s see how this implementation will look:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个实现将如何看起来：
- en: 'The `city-search` component exposes an `EventEmitter` through an `@Output`
    property:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`city-search`组件通过`@Output`属性公开一个`EventEmitter`：'
- en: '[PRE27]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `app` component consumes that and calls the `weatherService`, setting the
    `currentWeather` variable:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`app`组件消费它并调用`weatherService`，设置`currentWeather`变量：'
- en: '[PRE28]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that we are binding to the `searchEvent` with the parenthesis syntax. The
    `$event` variable automatically captures the output from the event and passes
    it into the `doSearch` method.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们使用括号语法将 `searchEvent` 绑定。`$event` 变量会自动捕获事件输出并将其传递给 `doSearch` 方法。
- en: We successfully bubbled the information up to the parent component, but we must
    also be able to pass it down to the `current-weather` component.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功将信息冒泡到父组件，但我们还必须能够将其传递到 `current-weather` 组件。
- en: Parent-child relationships with input binding
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入绑定下的父子关系
- en: 'By definition, your parent component will be aware of what child components
    it is working with. Since the `currentWeather` property is bound to the `current`
    property on the `current-weather` component, the results pass down to be displayed.
    This is achieved by creating an `@Input` property:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，父组件将知道它正在与哪些子组件一起工作。由于 `currentWeather` 属性绑定到 `current-weather` 组件上的 `current`
    属性，结果会向下传递以进行显示。这是通过创建一个 `@Input` 属性来实现的：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that the `ngOnInit` function of `CurrentWeatherComponent` is now superfluous
    and can be removed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`CurrentWeatherComponent` 的 `ngOnInit` 函数现在已不再必要，可以删除。
- en: 'You can then update the `app` component to bind the data to `current` weather:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以更新 `app` 组件以将数据绑定到 `current` 天气：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: At this point, your code should work! Try searching for a city. If the `current-weather`
    component updates, then success!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您的代码应该可以正常工作！尝试搜索一个城市。如果 `current-weather` 组件更新，则表示成功！
- en: 'The event emitter and input binding approach is appropriate in cases where
    you are creating well-coupled components or user controls and no outside data
    is being consumed. A good example might be adding forecast information to the
    `current-weather` component, as shown:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 事件发射器和输入绑定方法适用于创建紧密耦合的组件或用户控件，且没有外部数据被消费的情况。一个很好的例子是将预报信息添加到 `current-weather`
    组件中，如下所示：
- en: '![\\192.168.0.200\All_Books\2020\Working_Titles\14094_Angular 8 for Enterprise-Ready
    Web Applications\BookDrafts\Graphics\Chapter 6\B14094_06_03.png](img/B14094_06_04.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![\\192.168.0.200\All_Books\2020\Working_Titles\14094_Angular 8 for Enterprise-Ready
    Web Applications\BookDrafts\Graphics\Chapter 6\B14094_06_03.png](img/B14094_06_04.png)'
- en: 'Figure 6.4: Weather forecast wireframe'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4：天气预报线框图
- en: 'Each day of the week can be implemented as a component that is repeated using
    `*ngFor`, and it will be perfectly reasonable for `current-weather` to retrieve
    and bind this information to its child component:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 每周每一天都可以实现为一个使用 `*ngFor` 重复的组件，并且对于 `current-weather` 来说，检索和绑定此信息到其子组件是完全合理的：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In general, if you're working with data-driven components, the parent-child
    or child-parent communication pattern results in an inflexible architecture, making
    it very difficult to reuse or rearrange your components. A good example of the
    tight coupling is when we imported the weather service in `app.component.ts`.
    `AppComponent` should have no idea about the weather service; its only job is
    to layout several components. Given the ever-changing business requirements and
    design, this is an important lesson to keep in mind.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果您正在处理数据驱动的组件，父子或子父通信模式会导致架构不够灵活，这使得组件的重用或重新排列变得非常困难。一个紧密耦合的好例子是我们将天气服务导入到
    `app.component.ts` 中。`AppComponent` 应该不知道天气服务；它的唯一任务是布局几个组件。鉴于不断变化的企业需求和设计，这是一个需要记住的重要教训。
- en: Discard the changes you've made in the last two sections before moving on. We
    will instead be implementing an alternate solution.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请丢弃您在前两节中做出的更改。我们将实现一个替代方案。
- en: Next, we cover a better way for two components to interact with each other without
    introducing additional coupling with subjects.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍一种更好的方法，让两个组件在不引入额外的主题耦合的情况下相互交互。
- en: Sibling interactions with subjects
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与主题的兄弟交互
- en: The main reason for components to interact is to send or receive updates to
    data either provided by the user or received from the server. In Angular, your
    services expose `RxJS.Observable` endpoints, which are data streams that your
    components can subscribe to. `RxJS.Observer` complements `RxJS.Observable` as
    a consumer of events emitted by `Observable`. `RxJS.Subject` brings the two sets
    of functionalities together in an easy to work with object.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 组件交互的主要原因是为了发送或接收数据更新，这些数据可能是由用户提供的，也可能是由服务器接收的。在 Angular 中，你的服务公开 `RxJS.Observable`
    端点，这些是组件可以订阅的数据流。`RxJS.Observer` 作为 `RxJS.Observable` 事件发射器的消费者，与 `RxJS.Observable`
    相辅相成。`RxJS.Subject` 将这两组功能结合到一个易于操作的对象中。
- en: 'You can essentially describe a stream that belongs to a particular set of data,
    such as the current weather data that is being displayed, with subjects:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用主题基本上描述属于特定数据集的流，例如正在显示的当前天气数据：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`currentWeather$` is still a data stream and does not simply represent one
    data point. You can subscribe to changes to `currentWeather$` data using `subscribe`,
    or you can publish changes to it using `next` as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`currentWeather$` 仍然是一个数据流，并不简单地代表一个数据点。您可以使用 `subscribe` 订阅 `currentWeather$`
    数据的变化，或者使用 `next` 发布对其的变化，如下所示：'
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note the naming convention for the `currentWeather$` property, which is appended
    by `$`. This is the naming convention for properties that are observable.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `currentWeather$` 属性的命名约定，它以 `$` 结尾。这是可观察属性命名约定。
- en: The default behavior of `Subject` is very much like generic pub/sub mechanisms,
    such as jQuery events. However, in an asynchronous world where components are
    loaded or unloaded in unpredictable ways, using the default `Subject` is not very
    useful.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subject` 的默认行为非常类似于通用的 pub/sub 机制，例如 jQuery 事件。然而，在一个组件以不可预测的方式加载或卸载的异步世界中，使用默认的
    `Subject` 并不是非常有用。'
- en: 'There are three advanced variants of subjects:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 主题有三种高级变体：
- en: '`ReplaySubject` remembers and caches data points that occurred within the data
    stream so that a subscriber can replay old events at any given time.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReplaySubject` 会记住并缓存数据流中发生的数据点，以便订阅者可以在任何给定时间回放旧事件。'
- en: '`BehaviorSubject` remembers only the last data point while continuing to listen
    for new data points.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BehaviorSubject` 只记住最后一个数据点，同时继续监听新的数据点。'
- en: '`AsyncSubject` is for one-time-only events that are not expected to reoccur.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncSubject` 用于一次性事件，这些事件预计不会再次发生。'
- en: '`ReplaySubject` can have severe memory and performance implications on your
    application, so it should be used with care. In the case of `current-weather`,
    we are only interested in displaying the latest weather data received, but through
    user input or other events, we are open to receiving new data so that we can keep
    the `current-weather` component up to date. The `BehaviorSubject` would be the
    appropriate mechanism to meet these needs:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReplaySubject` 可能会对您的应用程序的内存和性能产生严重影响，因此应谨慎使用。在 `current-weather` 的情况下，我们只对显示接收到的最新天气数据感兴趣，但通过用户输入或其他事件，我们愿意接收新数据，以便保持
    `current-weather` 组件的更新。`BehaviorSubject` 将是满足这些需求适当的机制：'
- en: 'Add `currentWeather$` as a read-only property to `IWeatherService`:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `currentWeather$` 作为只读属性添加到 `IWeatherService`：
- en: '[PRE34]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`currentWeather$` is declared as read-only because its `BehaviorSubject` should
    not be reassigned. Any updates to the value should be sent by calling the `.next`
    function on the property.'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`currentWeather$` 被声明为只读，因为其 `BehaviorSubject` 不应重新分配。任何对值的更新都应通过在属性上调用 `.next`
    函数来发送。'
- en: 'Define `BehaviorSubject` in `WeatherService` and set a default value:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `WeatherService` 中定义 `BehaviorSubject` 并设置默认值：
- en: '[PRE35]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add a new function named `updateCurrentWeather`, which will trigger `getCurrentWeather`
    and update the value of `currentWeather$`:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `updateCurrentWeather` 的新函数，它将触发 `getCurrentWeather` 并更新 `currentWeather$`
    的值：
- en: '[PRE36]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Update `IWeatherService` with the new function so that it appears as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新功能更新 `IWeatherService` 以使其如下所示：
- en: '[PRE37]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Update the `current-weather` component to subscribe to the new `BehaviorSubject`:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `current-weather` 组件以订阅新的 `BehaviorSubject`：
- en: '[PRE38]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the `city-search` component, update the `getCurrentWeather` function call
    to utilize the new `updateCurrentWeather` function:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `city-search` 组件中，更新 `getCurrentWeather` 函数调用以利用新的 `updateCurrentWeather`
    函数：
- en: '[PRE39]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Test your app in the browser; it should appear as follows:![](img/B14094_06_05.png)
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中测试您的应用程序；它应该如下所示：![](img/B14094_06_05.png)
- en: 'Figure 6.5: Weather information for Bursa, Turkey'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.5：土耳其布尔萨的天气信息
- en: 'When you type in a new city, the component should update to include the current
    weather information for that city. We can move the **Add city search capability...**
    task to the **Done** column, as shown on our Kanban board:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当您输入一个新城市时，组件应更新以包含该城市的当前天气信息。我们可以将 **添加城市搜索功能...** 任务移动到 **完成** 列，如图所示在我们的看板板上：
- en: '![](img/B14094_06_06.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_06_06.png)'
- en: 'Figure 6.6: GitHub project Kanban board status'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6：GitHub 项目看板板状态
- en: We have a functional app. However, we have introduced a memory leak, so let's
    fix that in the next section.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个功能性的应用程序。然而，我们引入了内存泄漏，所以让我们在下一节中修复它。
- en: Managing subscriptions
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理订阅
- en: Subscriptions are a convenient way to read a value from a data stream to be
    used in your application logic. If unmanaged, they can create memory leaks in
    your application. A leaky application will end up consuming ever-increasing amounts
    of RAM, eventually leading the browser tab to become unresponsive, leading to
    a negative perception of your app and, even worse, potential data loss, which
    can frustrate end users.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅是一种方便的方式，可以从数据流中读取值以用于您的应用程序逻辑。如果未管理，它们可能会在您的应用程序中创建内存泄漏。一个泄漏的应用程序最终会消耗越来越多的RAM，最终导致浏览器标签页无响应，导致对您的应用产生负面印象，甚至更糟，可能导致数据丢失，这可能会让最终用户感到沮丧。
- en: In the `current-weather` component, we inject `weatherSevice` so that we can
    access the `currentWeather$` component of `BehaviorSubject`. In Angular, services
    are singletons, meaning when they are first created in memory, they're kept alive
    as long as the module they're a part of is in memory. From a practical perspective,
    this will mean that most services in your application will live in the memory
    for the lifetime of the application. However, the lifetime of a component may
    be much shorter and there could be multiple instances of the same component created
    over and over again. If we don't manage the interactions between long-lived and
    short-lived objects carefully, we can end up with dangling references between
    objects, leading to memory leaks.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在`current-weather`组件中，我们注入`weatherSevice`以便我们可以访问`BehaviorSubject`的`currentWeather$`组件。在Angular中，服务是单例的，这意味着当它们首次在内存中创建时，只要它们所属的模块在内存中，它们就会被保留。从实际的角度来看，这意味着您应用程序中的大多数服务将存在于应用程序的生命周期内。然而，组件的生命周期可能要短得多，并且可能反复创建相同组件的多个实例。如果我们不仔细管理长生命期和短生命期对象之间的交互，我们可能会在对象之间产生悬挂引用，从而导致内存泄漏。
- en: Exposé of a memory leak
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存泄漏的揭露
- en: When we subscribe to `currentWeather$`, we attach an event handler to it so
    that our component can react to value changes that are pushed to `BehaviorSubject`.
    This presents a problem when the `current-weather` component needs to be destroyed.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们订阅`currentWeather$`时，我们将其附加一个事件处理器，以便我们的组件可以响应推送到`BehaviorSubject`的值变化。当`current-weather`组件需要被销毁时，这会引发问题。
- en: In managed languages such as JavaScript, memory is managed by the garbage collector,
    or GC for short, as opposed to having to allocate and deallocate memory by hand
    in unmanaged languages such as C or C++. At a very high level, the GC works by
    periodically scanning the stack for objects that are not referenced by other objects.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在像JavaScript这样的托管语言中，内存由垃圾回收器管理，简称GC，而不是像在C或C++这样的非托管语言中手动分配和释放内存。在非常高的层面上，GC通过定期扫描栈中未由其他对象引用的对象来工作。
- en: If an object is found to be dereferenced, then the space it takes up in the
    stack can be freed up. However, if an unused object still has a reference to another
    object that is still in use, it can't be garbage collected. The GC is not magical
    and can't read our minds. When an object is unused and can't be deallocated, the
    memory taken up by the object can never be used for another purpose so long as
    your application is running. This is considered a memory leak.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现一个对象被取消引用，那么它占用的栈空间可以被释放。然而，如果一个未使用的对象仍然引用另一个仍在使用的对象，它就不能被垃圾回收。垃圾回收器并不是神奇的，不能读取我们的思想。当一个对象未使用且无法释放时，该对象占用的内存将无法在您的应用程序运行期间用于其他目的，这被认为是内存泄漏。
- en: 'My colleague, Brendon Caulkins, provides a helpful analogy:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我的同事布伦登·考林斯提供了一个有用的类比：
- en: Imagine the memory space of the browser as a parking lot; every time we assign
    a value or create a subscription, we park a car in that lot. If we happen to abandon
    a car, we still leave the parking spot occupied; no one else can use it. If all
    the applications in the browser do this, or we do it repeatedly, you can imagine
    how quickly the parking lot is full, and we never get to run our application.
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 想象浏览器的内存空间就像一个停车场；每次我们分配一个值或创建一个订阅时，我们就在那个停车场停车。如果我们偶然遗弃了一辆车，我们仍然留下停车位被占用；没有人可以使用它。如果浏览器中的所有应用程序都这样做，或者我们反复这样做，你可以想象停车场会很快被填满，我们永远无法运行我们的应用程序。
- en: Next, let's see how we can ensure that we don't abandon our car in the parking
    lot.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何确保我们不把车遗弃在停车场。
- en: Unsubscribing from a subscription
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消订阅
- en: Subscriptions or event handlers create references to other objects, such as
    from a short-lived component to a long-lived service. Granted, in our case, the
    `current-weather` component is also a singleton, but that could change if we added
    more features to the app, navigating from page to page or displaying weather from
    multiple cities at once. If we don't unsubscribe from `currentWeather$`, then
    any instance of `current-weather` would be stuck in memory. We subscribe in `ngOnInit`,
    so we must unsubscribe in `ngOnDestroy`. `ngOnDestroy` is called when Angular
    determines that the framework is no longer using the component.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅或事件处理器会创建对其他对象的引用，例如从短生命周期的组件到长生命周期的服务。诚然，在我们的案例中，`current-weather`组件也是一个单例，但如果我们给应用添加更多功能，比如页面间的导航或同时显示多个城市的天气，这可能会改变。如果我们不取消对`currentWeather$`的订阅，那么任何`current-weather`的实例都会卡在内存中。我们在`ngOnInit`中进行了订阅，所以我们必须在`ngOnDestroy`中取消订阅。`ngOnDestroy`是在Angular确定框架不再使用组件时被调用的。
- en: 'Let''s see an example of how you can unsubscribe from a subscription in the
    sample code in the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例代码中如何取消订阅一个订阅的例子：
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: First, we need to implement the `OnDestroy` interface for the component. Then,
    we update `ngOnInit` to store a reference to the subscription in a property named
    `currentWeatherSubscription`. Finally, in `ngOnDestroy`, we can call the `unsubscribe`
    method.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为组件实现`OnDestroy`接口。然后，我们更新`ngOnInit`以将订阅的引用存储在名为`currentWeatherSubscription`的属性中。最后，在`ngOnDestroy`中，我们可以调用`unsubscribe`方法。
- en: Should our component get destroyed, it will no longer result in a memory leak.
    However, if we have multiple subscriptions in a given component, this can lead
    to tedious amounts of coding.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的组件被销毁，将不会导致内存泄漏。然而，如果给定组件中有多个订阅，这可能会导致大量的编码工作。
- en: Note that in `city-search`, we subscribe to the `valueChanges` event of a `FormControl`
    object. We don't need to manage the subscription to this event, because `FormControl`
    is a child object of our component. When the parent component is dereferenced
    from all objects, all of its children can be safely collected by the GC.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`city-search`中，我们订阅了`FormControl`对象的`valueChanges`事件。我们不需要管理这个事件的订阅，因为`FormControl`是我们组件的一个子对象。当父组件从所有对象中解除引用时，所有子对象都可以安全地被GC（垃圾回收器）收集。
- en: Let's now look at a better way to manage multiple subscriptions.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一种更好地管理多个订阅的方法。
- en: Unsubscribing using SubSink
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SubSink取消订阅
- en: SubSink, published by Ward Bell, is a straightforward library to keep track
    of all subscriptions in a given class, whether it be a component or a service.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由Ward Bell发布的SubSink是一个简单的库，可以跟踪给定类中的所有订阅，无论是组件还是服务。
- en: 'Add the SubSink package to your Angular project:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 将SubSink包添加到你的Angular项目中：
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, update `current-weather` to use SubSink, replacing `currentWeatherSubscription`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新`current-weather`以使用SubSink，替换`currentWeatherSubscription`：
- en: '[PRE42]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code sample, we instantiated a private `subscriptions` object,
    which will serve as the sink to contain all of the subscriptions. Then, in `ngOnInit`,
    we simply add the subscription to `currentWeather$` to the sink. In `ngOnDestroy`,
    we call `unsubscribe` on the sink rather than an individual subscription.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们实例化了一个私有的`subscriptions`对象，它将作为汇入点来包含所有的订阅。然后，在`ngOnInit`中，我们简单地将`currentWeather$`的订阅添加到汇入点。在`ngOnDestroy`中，我们调用汇入点的`unsubscribe`方法，而不是单个订阅。
- en: This is a scalable approach, as the amount of boilerplate code we must write
    remains consistent, as you can add many subscriptions to the sink without additional
    coding.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可扩展的方法，因为我们必须编写的样板代码量保持一致，你可以在不额外编码的情况下向汇入点添加许多订阅。
- en: Subscribing to values in data streams itself can be considered an anti-pattern
    because you switch your programming model from reactive to imperative. In addition,
    you could avoid having to manage subscriptions in the first place. We will cover
    this topic in the next section.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅数据流中的值本身可以被认为是一种反模式，因为它将你的编程模型从响应式切换到命令式。此外，你还可以避免一开始就需要管理订阅。我们将在下一节中讨论这个话题。
- en: Implementing the reactive style
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现响应式风格
- en: As covered in *Chapter 1*, *Introduction to Angular and Its Concepts*, we should
    only subscribe to an observable stream to activate it. If we treat a `subscribe`
    function as an event handler, then we're implementing our code imperatively.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在*第一章*，*Angular及其概念简介*中所述，我们应当只为激活它而订阅一个可观察的流。如果我们把`subscribe`函数当作一个事件处理器，那么我们就是在命令式地实现代码。
- en: Seeing anything other than an empty `.subscribe()` call in your code base should
    be considered a sign of ditching reactive programming.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码库中看到除空 `.subscribe()` 调用之外的内容，应被视为放弃响应式编程的迹象。
- en: In reactive programming, when you subscribe to an event in a reactive stream,
    then you're shifting your coding paradigm from reactive programming to imperative
    programming. There are two places in our application where we subscribe, once
    in `current-weather`, and the other in the `city-search` component.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式编程中，当你在一个响应式流中订阅一个事件时，你就是在将你的编程范式从响应式编程切换到命令式编程。在我们的应用程序中有两个地方我们进行了订阅，一次在
    `current-weather` 中，另一次在 `city-search` 组件中。
- en: Let's start by fixing `current-weather`, so that we don't drop back into imperative
    programming.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从修复 `current-weather` 开始，这样我们就不会回到命令式编程。
- en: Binding to an observable with an async pipe
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用异步管道绑定到可观察对象
- en: Angular has been designed to be an asynchronous framework from the ground up.
    You can get the most out of Angular by staying in the reactive programming realm.
    It can feel unnatural to do so at first, but Angular provides all the tools you
    need to reflect the current state of your application to the user without having
    to shift to imperative programming.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，Angular 就被设计成一个异步框架。通过保持在响应式编程领域，你可以最大限度地发挥 Angular 的作用。这样做可能一开始感觉不自然，但
    Angular 提供了你需要的所有工具，以便将应用程序的当前状态反映给用户，而无需切换到命令式编程。
- en: 'You may leverage the `async` pipe in your templates to reflect the current
    value of an observable. Let''s update the `current-weather` component to use the
    `async` pipe:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在模板中使用 `async` 管道来反映可观察对象当前值。让我们更新 `current-weather` 组件以使用 `async` 管道：
- en: 'Start by replacing `current: ICurrentWeather` with an observable property:
    `current$: Observable<ICurrentWeather>`.'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '首先，将 `current: ICurrentWeather` 替换为可观察属性：`current$: Observable<ICurrentWeather>`。'
- en: In the constructor, assign `weatherService.currentWeather$` to `current$:`
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，将 `weatherService.currentWeather$` 赋值给 `current$:`
- en: '[PRE43]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Remove all code related to `SubSink`, `ngOnInit`, and `ngOnDestroy`.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除所有与 `SubSink`、`ngOnInit` 和 `ngOnDestroy` 相关的代码。
- en: 'Update the template to so you can bind to `current$`:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新模板，以便你可以绑定到 `current$`：
- en: '[PRE44]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `async` pipe automatically subscribes to the current value of `current$`
    and makes it available to the template to be used in an imperative manner as the
    variable `current`. The beauty of this approach is that the `async` pipe implicitly
    manages the subscription, so you don't have to worry about unsubscribing.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`async` 管道自动订阅 `current$` 的当前值，并将其作为变量 `current` 以命令式方式提供给模板使用。这种方法的美妙之处在于，`async`
    管道隐式管理订阅，因此你不必担心取消订阅。'
- en: Remove `<div *ngIf="!current">`. This is no longer needed, because the `BehaviorSubject`
    is always initialized.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除 `<div *ngIf="!current">`。这不再需要，因为 `BehaviorSubject` 总是初始化的。
- en: So far, the reactive style allowed us to streamline and clean up our code.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，响应式风格使我们能够简化并清理我们的代码。
- en: 'The async pipe allows you to also implement `if-else` logic. If you wanted
    to display a loading message while your observable is resolved, you can do by
    using the following technique:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 异步管道允许你实现 `if-else` 逻辑。如果你想在你的可观察对象解析时显示一个加载消息，你可以通过以下技术来实现：
- en: '[PRE45]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Next, let's further improve our code.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们进一步改进我们的代码。
- en: Tapping into an observable stream
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获可观察流
- en: The `city-search` component implements a callback within a `subscribe` statement
    when firing the `search` function. This leads to an imperative style of coding
    and mindset. The danger with switching programming paradigms is that you can introduce
    unintentional side effects to your code, making it easier to introduce errors or
    state into your application.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`city-search` 组件在触发 `search` 函数时，在 `subscribe` 语句中实现了一个回调。这导致了一种命令式编程风格和思维模式。切换编程范式的一个危险是，你可能会无意中在你的代码中引入副作用，这使得引入错误或状态到你的应用程序中变得更加容易。'
- en: 'Let''s refactor `city-search.component.ts` to be in the reactive functional
    programming style, as shown in the following example:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 `city-search.component.ts` 重构为响应式函数式编程风格，如下例所示：
- en: '[PRE46]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the preceding code, we removed the `OnInit` implementation and implemented
    our filtering logic reactively. The `tap` operator will only get triggered if
    `this.search` is valid. In addition, `doSearch` is called in a functional context,
    making it very difficult to reference any other class property within the function.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们移除了 `OnInit` 实现，并实现了我们的过滤逻辑响应式。`tap` 操作符只有在 `this.search` 有效时才会被触发。此外，`doSearch`
    在函数式上下文中被调用，这使得在函数内部引用任何其他类属性变得非常困难。
- en: This reduces the chances of the state of the class impacting the outcome of
    our function. As a result, `doSearch` is a composable and unit testable function,
    whereas in the previous implementation, it would have been very challenging to
    unit test `ngOnInit` in a straightforward manner.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这减少了类的状态影响我们函数结果的可能性。因此，`doSearch`是一个可组合的、可单元测试的函数，而在之前的实现中，以简单的方式单元测试`ngOnInit`将非常具有挑战性。
- en: Note that `.subscribe()` must be called on `valueChanges` to activate the observable
    data stream, otherwise no event will fire.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，必须在对`valueChanges`调用`.subscribe()`来激活可观察的数据流，否则不会触发任何事件。
- en: The fact that we don't implement `ngOnInit` reflects the truly asynchronous
    nature of our code, which is independent of the life cycle or state of the application.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有实现`ngOnInit`的事实反映了我们代码的真实异步性，它与应用程序的生命周期或状态无关。
- en: With our refactoring complete, the app should function the same as before, but
    with less boilerplate code. Now, let's look into enhancing our app so that it
    can handle postal codes from any country.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的重构完成后，应用应该与之前一样运行，但具有更少的样板代码。现在，让我们看看如何增强我们的应用，使其能够处理来自任何国家的邮政编码。
- en: Multiple API calls
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多次API调用
- en: Currently, our app can only handle 5-digit numerical postal or zip codes from
    the US. A postal code such as `22201` is easy to differentiate from a city name
    with a simplistic conditional such as `typeof search === 'string'`. However, postal
    codes can vary widely from country to country, Great Britain being a great example
    with postal codes such as `EC2R 6AB`. Even if we had a perfect understanding of
    how postal codes are formatted for every country on earth, we still couldn't ensure
    that the user didn't fat-finger a slightly incorrect postal code. Today's sophisticated
    users expect web applications to be resilient toward such mistakes.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用只能处理来自美国的5位数字邮政编码。例如，邮政编码`22201`可以通过简单的条件`typeof search === 'string'`与城市名称区分开来。然而，邮政编码在不同国家之间差异很大，英国就是一个很好的例子，其邮政编码如`EC2R
    6AB`。即使我们对地球上每个国家的邮政编码格式有完美的理解，我们仍然不能确保用户没有输入一个轻微错误的邮政编码。今天的用户期望网络应用对这类错误具有弹性。
- en: After the first edition of this book was published, I received some passionate
    reader feedback on their disappointment that the sample app can only support US
    zip codes. I've decided to implement this feature because it demonstrates the
    degree to which such seemingly simple requests can introduce unplanned complexity
    to your apps. As a bonus, the app now works worldwide ![](img/B14094_06_001.png)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一版出版后，我收到了一些热情的读者反馈，他们对示例应用只能支持美国邮政编码表示失望。我决定实现这个功能，因为它展示了看似简单的请求如何给您的应用引入未计划的复杂性。作为额外的好处，应用现在可以在全球范围内工作！[](img/B14094_06_001.png)
- en: 'Let''s add a new item, **Support international zip codes**, to the backlog
    and move it to **In progress**:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在待办事项中添加一个新的项目，**支持国际邮政编码**，并将其移动到**进行中**：
- en: '![](img/B14094_06_07.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_06_07.png)'
- en: 'Figure 6.7: Adding an international zip codes story'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：添加国际邮政编码故事
- en: Implementing a postal code service
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现邮政编码服务
- en: To properly understand if the user inputs a valid postal code versus the name
    of a city, we must rely on a third-party API call provided by [geonames.org](http://geonames.org).
    Let's see how we can inject a secondary API call into the search logic of our
    app.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确理解用户输入的是有效的邮政编码还是城市名称，我们必须依赖由[geonames.org](http://geonames.org)提供的第三方API调用。让我们看看如何将一个次要的API调用注入到我们应用的搜索逻辑中。
- en: You need to sign up for a free account on [geonames.org](http://geonames.org).
    Afterward, store your `username` as a new parameter in `environment.ts` and `environment.prod.ts`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在[geonames.org](http://geonames.org)上注册一个免费账户。之后，将您的`username`作为新参数存储在`environment.ts`和`environment.prod.ts`中。
- en: 'You may experiment with a postal code API on this page: [https://www.geonames.org/postal-codes](https://www.geonames.org/postal-codes).'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本页面上尝试邮政编码API：[https://www.geonames.org/postal-codes](https://www.geonames.org/postal-codes)。
- en: 'Start by implementing a `PostalCodeService`, as shown in the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，实现一个`PostalCodeService`，如下所示：
- en: You may generate the service by executing `npx ng generate service postalCode
    --project=local-weather-app --no-flat --lintFix`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过执行`npx ng generate service postalCode --project=local-weather-app --no-flat
    --lintFix`来生成服务。
- en: '[PRE47]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note the new environment variable, `environment.geonamesApi`. In `environment.ts`,
    set this value to `api` and, in `environment.prod.ts`, to `secure`, so calls over
    https work correctly to avoid the mixed-content error, as covered in *Chapter
    4*, *Automated Testing, CI, and Release to Production*.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 注意新的环境变量`environment.geonamesApi`。在`environment.ts`中将其值设置为`api`，在`environment.prod.ts`中设置为`secure`，这样https调用就可以正确工作，避免混合内容错误，如第4章中所述的*自动化测试、持续集成和发布到生产*。
- en: In the preceding code segment, we implement a `resolvePostalCode` function that
    makes a call to an API, which is configured to receive the first viable result
    the API returns. The results are then flattened and piped out to the subscriber.
    With `defaultIfEmpty`, we ensure that a null value will be provided if we don't
    receive a result from the API. If the call is successful, we will get back all
    the information defined in `IPostalCode`, making it possible to leverage `getCurrentWeatherByCoords`
    using coordinates.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码段中，我们实现了一个`resolvePostalCode`函数，该函数调用一个API，该API配置为接收API返回的第一个有效结果。然后，结果会被展平并通过管道输出给订阅者。使用`defaultIfEmpty`，我们确保如果没有从API收到结果，将提供一个null值。如果调用成功，我们将得到在`IPostalCode`中定义的所有信息，这使得使用坐标调用`getCurrentWeatherByCoords`成为可能。
- en: Chaining API calls
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接API调用
- en: 'Let''s update the weather service so that it can call the `postalCode` service
    to determine whether the user input was a valid postal code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新天气服务，使其能够调用`postalCode`服务以确定用户输入是否为有效的邮政编码：
- en: 'Start by updating the interface, so we only deal with a string:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先更新接口，这样我们只处理字符串：
- en: '[PRE48]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Inject `PostalCodeService` to the weather service as a private property:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`PostalCodeService`注入到天气服务作为私有属性：
- en: '[PRE49]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Update the method signature for `updateCurrentWeather`
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`updateCurrentWeather`的方法签名
- en: 'Update `getCurrentWeather` to try and resolve `searchText` as a postal code:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`getCurrentWeather`以尝试将`searchText`解析为邮政编码：
- en: '[PRE50]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If you run into TypeScript issues when passing the latitude and longitude into
    `getCurrentWeatherByCoords`, then you may have to cast the object using the `as`
    operator. So, your code would look like:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将经纬度传递到`getCurrentWeatherByCoords`时遇到TypeScript问题，那么你可能必须使用`as`运算符来强制转换对象。因此，你的代码看起来可能如下所示：
- en: '[PRE51]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the preceding code segment, our first call is to the `postalCode` service.
    We then react to postal codes that are posted on the data stream using `switchMap`.
    Inside `switchMap`, we can observe whether `postalCode` is null and make the appropriate
    follow-up call to either get the current weather by coordinates or by city name.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码段中，我们的第一次调用是到`postalCode`服务。然后我们使用`switchMap`对数据流上发布的邮政编码做出反应。在`switchMap`内部，我们可以观察`postalCode`是否为null，并做出适当的后续调用，要么通过坐标获取当前天气，要么通过城市名称获取。
- en: 'Now, LocalCast weather should work with global postal codes, as shown in the
    following screenshot:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，LocalCast天气应该可以与全球邮政编码一起工作，如下面的截图所示：
- en: '![](img/B14094_06_08.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_06_08.png)'
- en: 'Figure 6.8: LocalCast Weather with global postal codes'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8：带有全球邮政编码的LocalCast天气
- en: 'We are done with implementing international zip code support. Move it to the
    **Done** column on your Kanban board:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了国际邮政编码支持的实施。将其移动到你的看板上的**完成**列：
- en: '![](img/B14094_06_09.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_06_09.png)'
- en: 'Figure 6.9: International zip code support done'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：国际邮政编码支持完成
- en: As we complete our implementation of LocalCast Weather, there's still room for
    improvement. Initially, the app looks broken when it first loads, because of the
    dashes and empty fields that are shown. There are at least two different ways
    to handle this. The first is to hide the entire component, at the `app` component
    level, if there's no data to display. For this to work, we will have to inject
    `weatherService` into the `app` component, ultimately leading to a less flexible
    solution. Another way is to enhance the `current-weather` component so that it
    is better able to handle missing data.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们完成LocalCast天气的实现，仍有改进的空间。最初，当应用首次加载时看起来是损坏的，因为显示了破折号和空字段。至少有两种不同的方法来处理这个问题。第一种是在没有数据显示时，在`app`组件级别隐藏整个组件。为了使这可行，我们必须将`weatherService`注入到`app`组件中，这最终导致了一个更不灵活的解决方案。另一种方法是通过增强`current-weather`组件，使其能够更好地处理缺失的数据。
- en: You improve the app further by implementing geolocation to get the weather for
    the user's current location upon launching the app. You can also leverage `window.localStorage`
    to store the city that was last displayed or the last location that was retrieved
    from `window.geolocation` upon initial launch.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过实现地理位置功能来进一步改进应用，在应用启动时获取用户的当前位置天气。您还可以利用 `window.localStorage` 来存储上次显示的城市或初始启动时从
    `window.geolocation` 获取的最后位置。
- en: We are done with the Local Weather app until *Chapter 12*, *Recipes — Master/Detail,
    Data Tables, and NgRx*, where I demonstrate how NgRx compares to using RxJS/BehaviorSubject.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了本地天气应用的开发，直到**第12章**，**食谱 — 主/详情，数据表和 NgRx**，在那里我展示了 NgRx 与使用 RxJS/BehaviorSubject
    的比较。
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to create a search-as-you-type functionality
    using `MatInput`, validators, reactive forms, and data stream-driven handlers.
    You became aware of two-way binding and template-driven forms. You also learned
    about different strategies to enable inter-component interactions and data sharing.
    You dove into understanding how memory leaks can be created and the importance
    of managing your subscriptions.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用 `MatInput`、验证器、响应式表单和数据流驱动的处理程序创建搜索即输入的功能。您意识到了双向绑定和模板驱动表单。您还了解了不同的策略来启用组件间的交互和数据共享。您深入了解了内存泄漏是如何产生的，以及管理您的订阅的重要性。
- en: You are now better able to differentiate between imperative and reactive programming
    styles and the importance of sticking with reactive programming where possible.
    Finally, you learned how you can implement sophisticated functionality by chaining
    multiple API calls together.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在能够更好地区分命令式和响应式编程风格，以及在可能的情况下坚持使用响应式编程的重要性。最后，您学习了如何通过链式调用多个 API 调用来实现复杂的功能。
- en: LocalCast Weather is a straightforward application that we used to cover the
    basic concepts of Angular. As you saw, Angular is great for building such small
    and dynamic applications, while delivering a minimal amount of framework code
    to the end user. You should consider leveraging Angular for even quick and dirty
    projects, which is also a great practice when building larger applications. In
    the next chapter, you will be creating a far more complicated **line-of-business**
    (**LOB**) application, using a router-first approach to designing and architecting
    scalable Angular applications with first-class authentication and authorization,
    user experience, and numerous recipes that cover a vast majority of requirements
    that you may find in LOB applications.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: LocalCast Weather 是一个简单的应用，我们用它来介绍 Angular 的基本概念。正如您所看到的，Angular 构建这样的小型和动态应用非常出色，同时向最终用户交付的框架代码量最少。您应该考虑在快速和简单的项目中使用
    Angular，这在构建大型应用时也是一个很好的实践。在下一章中，您将创建一个更复杂的**业务线**（**LOB**）应用，使用以路由为首要方法的架构和设计可扩展的
    Angular 应用，包括一流的认证和授权、用户体验以及覆盖大多数您可能在 LOB 应用中找到的需求的众多食谱。
- en: Exercises
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: After completing the **Support international zip codes** feature, did we switch
    coding paradigms here? Is our implementation above imperative, reactive, or a
    combination of both? If our implementation is not entirely reactive, how would
    you implement this function reactively? I leave this as an exercise for the reader.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成**支持国际邮政编码**的功能后，我们是否在这里切换了编程范式？我们的实现是命令式、响应式，还是两者的结合？如果我们的实现不是完全响应式的，您会如何实现这个功能以响应式的方式？我将这个问题留作读者的练习。
- en: Don't forget to execute `npm test`, `npm run e2e`, and `npm run test:a11y` before
    moving on. It is left as an exercise for the reader to fix the unit and end-to-end
    tests.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，不要忘记执行 `npm test`、`npm run e2e` 和 `npm run test:a11y`。修复单元测试和端到端测试的问题留作读者的练习。
- en: Visit GitHub to see the unit tests that I implemented for this chapter at [https://github.com/duluca/local-weather-app/tree/master/projects/ch6](https://github.com/duluca/local-weather-app/tree/master/projects/ch6).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 GitHub 查看我为本章实现的单元测试，链接为 [https://github.com/duluca/local-weather-app/tree/master/projects/ch6](https://github.com/duluca/local-weather-app/tree/master/projects/ch6)。
- en: Questions
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Answer the following questions as best as you can to ensure that you've understood
    the key concepts from this chapter without Googling. Do you need help answering
    the questions? See *Appendix D*, *Self-Assessment Answers* online at [https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf)
    or visit [https://expertlysimple.io/angular-self-assessment](https://expertlysimple.io/angular-self-assessment).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地回答以下问题，以确保你已理解本章的关键概念，无需使用Google。你需要帮助回答这些问题吗？请参阅*附录D*，*自我评估答案*，可在[https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf)在线查看，或访问[https://expertlysimple.io/angular-self-assessment](https://expertlysimple.io/angular-self-assessment)。
- en: What is the `async` pipe?
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`async`管道是什么？'
- en: Explain how reactive and imperative programming is different and which technique
    we should prefer?
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释反应式和命令式编程有何不同，我们应该优先选择哪种技术？
- en: What is the benefit of a BehaviorSubject, and what is it used for?
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BehaviorSubject的好处是什么，它用于什么？
- en: What are memory leaks and why should they be avoided?
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内存泄漏是什么，为什么应该避免它们？
