<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer023">
<h1 class="chapter-number" id="_idParaDest-66"><a id="_idTextAnchor065"/>4</h1>
<h1 id="_idParaDest-67"><a id="_idTextAnchor066"/>Building and Configuring Pages</h1>
<p>In the previous chapters, we have configured the base of our application, including the setup of the application, and shared UI components that will serve as the foundation of <span class="No-Break">our UI.</span></p>
<p>In this chapter, we can proceed by creating our application pages. We will learn how routing in Next.js works and what rendering methods we can use to get the most out of Next.js. Then, we will learn about configuring per-page layouts, making our application look and feel like a <span class="No-Break">single-page application.</span></p>
<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li><span class="No-Break">Next.js routing</span></li>
<li>Next.js <span class="No-Break">rendering strategies</span></li>
<li><span class="No-Break">Next.js SEO</span></li>
<li><span class="No-Break">Layouts</span></li>
<li>Building <span class="No-Break">the pages</span></li>
</ul>
<p>By the end of this chapter, we will learn how to create pages in Next.js and get a better understanding of selecting different rendering strategies depending on the needs of <span class="No-Break">the application.</span></p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/>Technical requirements</h1>
<p>Before we get started, we need to set up the project. To be able to develop the project, you will need the following things installed on <span class="No-Break">your computer:</span></p>
<ul>
<li><strong class="bold">Node.js</strong> version 16 or above and <strong class="bold">npm</strong> version 8 <span class="No-Break">or above.</span></li>
</ul>
<p>There are multiple ways to install Node.js and npm. Here is a great article that goes into <span class="No-Break">more detail:</span></p>
<p><a href="https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js"><span class="No-Break">https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js</span></a></p>
<ul>
<li><strong class="bold">VSCode</strong> (optional) is currently the most popular editor/IDE for JavaScript/TypeScript, so we will be using it. It is open source, has great integration with TypeScript, and you can extend its features via extensions. It can be downloaded <span class="No-Break">from </span><a href="https://code.visualstudio.com/"><span class="No-Break">https://code.visualstudio.com/</span></a><span class="No-Break">.</span></li>
</ul>
<p>The code files for this chapter can be found <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/React-Application-Architecture-for-Production"><span class="No-Break">https://github.com/PacktPublishing/React-Application-Architecture-for-Production</span></a></p>
<p>The repository can be cloned locally with the <span class="No-Break">following command:</span></p>
<pre class="console">
git clone https://github.com/PacktPublishing/React-Application-Architecture-for-Production.git</pre>
<p>Once the repository is cloned, we need to install the <span class="No-Break">application’s dependencies:</span></p>
<pre class="console">
npm install</pre>
<p>We also need to provide the <span class="No-Break">environment variables:</span></p>
<pre class="console">
cp .env.example .env</pre>
<p>Once the dependencies have been installed, we need to select the right stage of the code base that matches this chapter. We can do that by executing the <span class="No-Break">following command:</span></p>
<pre class="console">
npm run stage:switch</pre>
<p>This command will prompt us with a list of stages for <span class="No-Break">each chapter:</span></p>
<pre class="console">
? What stage do you want to switch to? (Use arrow
 keys)
❯ chapter-02
  chapter-03
  chapter-03-start
  chapter-04
  chapter-04-start
  chapter-05
  chapter-05-start
(Move up and down to reveal more choices)</pre>
<p>This is the fourth chapter, so you can select <strong class="source-inline">chapter-04-start</strong> if you want to follow along, or <strong class="source-inline">chapter-04</strong> to see the final results of the chapter. Once the chapter has been selected, all files required to follow along with the chapter <span class="No-Break">will appear.</span></p>
<p>To follow along with this chapter, you don’t need to make any changes to the code. You can use it as a reference to help get a better overview of the <span class="No-Break">code base.</span></p>
<p>For more information about the setup details, check out the <span class="No-Break"><strong class="source-inline">README.md</strong></span><span class="No-Break"> file.</span></p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor068"/>Next.js routing</h1>
<p>Next.js has a <a id="_idIndexMarker176"/>filesystem-based router where every page file represents a page. The pages <a id="_idIndexMarker177"/>are special files that exist in the <strong class="source-inline">pages</strong> folder, and they have the<a id="_idIndexMarker178"/> <span class="No-Break">following structure:</span></p>
<pre class="source-code">
const Page = () =&gt; {
     return &lt;div&gt;Welcome to the page!&lt;/div&gt;
}
export default Page;</pre>
<p>As you can see, only exporting the <strong class="source-inline">page</strong> component as a default export is required; this is the minimum requirement for a page to be defined. We will see what else can be exported from a page in a <span class="No-Break">few moments.</span></p>
<p>Since the routing is filesystem-based, routes are determined by how the page files are named. For example, the page pointing to the root route should be defined in the <strong class="source-inline">src/pages/index.tsx</strong> file. If we want the about page, we can define it <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">src/pages/about.tsx</strong></span><span class="No-Break">.</span></p>
<p>For any complex application with dynamic data, it is not enough to only create predefined pages. For example, let’s say we have a social network application where we can visit user profiles. The profiles should be loaded by the user’s ID. Since it would be too repetitive to create a page file for every user, we need to make the page dynamic <span class="No-Break">as follows:</span></p>
<pre class="source-code">
// pages/users/[userId].tsx
import { useRouter } from 'next/router';
const UserProfile = () =&gt; {
     const router = useRouter();
     const userId = router.query.userId;
     return &lt;div&gt;User: {userId}&lt;/div&gt;;
}
export default UserProfile</pre>
<p>To get the ID <a id="_idIndexMarker179"/>and load the data dynamically, we can define a generic user profile<a id="_idIndexMarker180"/> page in <strong class="source-inline">pages/users/[userId].tsx</strong>, where <strong class="source-inline">userId</strong> will be injected into the page dynamically. For example, going to <strong class="source-inline">/users/123</strong> will show the user profile page and pass the value of <strong class="source-inline">123</strong> as <strong class="source-inline">userId</strong> via the <strong class="source-inline">query</strong> property of <span class="No-Break">the router.</span></p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/>Next.js rendering strategies</h1>
<p>Next.js <a id="_idIndexMarker181"/>supports four different <span class="No-Break">rendering strategies:</span></p>
<ul>
<li><strong class="bold">Client-side rendering</strong>: Where<a id="_idIndexMarker182"/> we can load the initial content on the server and then fetch additional<a id="_idIndexMarker183"/> data from <span class="No-Break">the client.</span></li>
<li><strong class="bold">Server-side rendering</strong>: Where<a id="_idIndexMarker184"/> we can fetch the<a id="_idIndexMarker185"/> data on the server, inject it on the page, and return the page to the client with the <span class="No-Break">provided data.</span></li>
<li><strong class="bold">Static site generation</strong>: Where<a id="_idIndexMarker186"/> static data is <a id="_idIndexMarker187"/>injected on the page and returned in the markup to <span class="No-Break">the client.</span></li>
<li><strong class="bold">Incremental static regeneration</strong>: The<a id="_idIndexMarker188"/> middle ground between server-side rendering and static<a id="_idIndexMarker189"/> site generation. We can generate <em class="italic">x</em> number of pages statically, and then if a page that hasn’t been rendered and cached yet is requested, Next.js can<a id="_idIndexMarker190"/> render it on the server and cache it for <span class="No-Break">future requests.</span></li>
</ul>
<p>For our application, we will mainly focus on the first two methods, so let’s see how they work in the <span class="No-Break">following examples.</span></p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>Client-side rendering</h2>
<p>Considering the <a id="_idIndexMarker191"/>user profile page example, we can <a id="_idIndexMarker192"/>perform client-side rendering by writing the pages <span class="No-Break">as follows:</span></p>
<pre class="source-code">
// pages/users/[userId].tsx
import { useRouter } from 'next/router';
import { useUser } from './api';
const UserProfile = () =&gt; {
     const router = useRouter();
     const userId = router.query.userId;
     const { user, isLoading } = useUser(userId);
     if(!user &amp;&amp; isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
     if(!user) return &lt;div&gt;User not found!&lt;/div&gt;;
     return &lt;div&gt;User: {user.name}&lt;/div&gt;;
}</pre>
<p>As we can see, we are using <strong class="source-inline">userId</strong> to fetch the user data. In this example, we are doing this on the client side, which means that the server will initially render the <span class="No-Break">following markup:</span></p>
<pre class="source-code">
&lt;div&gt;Loading...&lt;/div&gt;</pre>
<p>Only after the data is fetched on the client will the user data <span class="No-Break">be displayed:</span></p>
<pre class="source-code">
&lt;div&gt;User: {user.name}&lt;/div&gt;</pre>
<p>This is fine unless we care about SEO and the performance of the initial page load. Here we have to wait for the initial page to load and then for the user data to be fetched. This approach is perfectly valid for data that is not supposed to be public, such as <span class="No-Break">admin dashboards.</span></p>
<p>However, for <a id="_idIndexMarker193"/>public pages, it is a good idea to enable<a id="_idIndexMarker194"/> the server to return the actual markup to the client to make it easier for search engines to crawl and index our pages. We can do that by server-side rendering <span class="No-Break">the pages.</span></p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>Server-side rendering</h2>
<p>Let’s revisit the user<a id="_idIndexMarker195"/> profile page example, this <a id="_idIndexMarker196"/>time by rendering it on <span class="No-Break">the server:</span></p>
<pre class="source-code">
// pages/users/[userId].tsx
import { useRouter } from 'next/router';
import { getUser } from './api';
const UserProfile = ({ user }) =&gt; {
     const router = userRouter();
     const userId = router.query;
     const { user } = useUser(userId);
     if(!user) return &lt;div&gt;User not found!&lt;/div&gt;;
     return &lt;div&gt;User: {user.name}&lt;/div&gt;;
}
export const getServerSideProps = async ({ params }) =&gt; {
     const userId = params.userId;
     const user = await getUser(userId);
     return {
          props: {
               user
          }
     }
}</pre>
<p>As we can see here, besides the page component, the <strong class="source-inline">page</strong> file exports the <strong class="source-inline">getServerSideProps</strong> function, which is executed on the server. Its return value can contain <strong class="source-inline">props</strong>, which is passed to the <span class="No-Break">component’s props.</span></p>
<p>The server will render the <span class="No-Break">following markup:</span></p>
<pre class="source-code">
&lt;div&gt;User: {user.name}&lt;/div&gt;</pre>
<p>The complete markup with the user data will be available on the <span class="No-Break">initial render.</span></p>
<p>Let’s keep in <a id="_idIndexMarker197"/>mind that there is no perfect rendering <a id="_idIndexMarker198"/>strategy for all use cases; therefore, we must balance the pros and cons and choose which one to use based on our needs. The great thing with Next.js is that it allows us to use different rendering strategies per page so we can combine them to fit the application’s needs in the <span class="No-Break">best way.</span></p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor072"/>Next.js SEO</h1>
<p>To improve the <a id="_idIndexMarker199"/>SEO of our pages, we should add some meta tags and the title of the page and inject them into the page. This can be done via the <strong class="source-inline">Head</strong> component provided <span class="No-Break">by Next.js.</span></p>
<p>For the application, we want to have a dedicated component where we can add the title of the pages. Let’s open the <strong class="source-inline">src/components/seo/seo.tsx</strong> file and add <span class="No-Break">the following:</span></p>
<pre class="source-code">
import Head from 'next/head';
export type SeoProps = {
  title: string;
};
export const Seo = ({ title }: SeoProps) =&gt; {
  return (
    &lt;Head&gt;
      &lt;title&gt;{title}&lt;/title&gt;
    &lt;/Head&gt;
  );
};</pre>
<p>The <strong class="source-inline">Head</strong> component will inject its content into the <strong class="source-inline">head</strong> of the page. For now, the title will suffice, but it can be extended to add different meta tags <span class="No-Break">if needed.</span></p>
<p>Let’s add the <strong class="source-inline">Seo</strong> component to our landing page <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">src/pages/index.tsx</strong></span><span class="No-Break">.</span></p>
<p>First, let’s import <span class="No-Break">the component:</span></p>
<pre class="source-code">
import { Seo } from '@/components/seo';</pre>
<p>And then, we can add it at the top of <span class="No-Break">the component:</span></p>
<pre class="source-code">
const LandingPage = () =&gt; {
  return (
    &lt;&gt;
      <strong class="bold">&lt;Seo title="Jobs App" /&gt;</strong>
<strong class="bold">      &lt;Center&gt;</strong>
      {/* rest of the component */}
      &lt;/Center&gt;
    &lt;/&gt;
  );
};
export default LandingPage</pre>
<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Layouts</h1>
<p>When developing an application with <a id="_idIndexMarker200"/>multiple views or pages, we need to consider <span class="No-Break">layout reusability.</span></p>
<p>Consider the <span class="No-Break">following example:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<img alt="Figure 4.1 – Layouts example " height="372" src="image/B17297_04_01.jpg" width="1196"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Layouts example</p>
<p>We can see that the navbar and the footer are the same on both pages and the main content comes between, so it is a good idea to make <span class="No-Break">it reusable.</span></p>
<p>There are two ways to add<a id="_idIndexMarker201"/> the <strong class="source-inline">layout</strong> component <span class="No-Break">to pages:</span></p>
<ul>
<li>Wrap the returned JSX of every page with the <span class="No-Break">layout component</span></li>
<li>Attach the layout to the page component and use it to wrap the <span class="No-Break">entire component</span></li>
</ul>
<h2 id="_idParaDest-75"><a id="_idTextAnchor074"/>Wrapping JSX of every page with the layout component</h2>
<p>Let’s say we <a id="_idIndexMarker202"/>have a layout component that can wrap the content of <span class="No-Break">each page:</span></p>
<pre class="source-code">
const Layout = ({ children }) =&gt; {
     return (
          &lt;div&gt;
               &lt;Header /&gt;
               {children}
               &lt;Footer /&gt;
          &lt;/div&gt;
     )
}</pre>
<p>We can add the <strong class="source-inline">Layout</strong> component to the page <span class="No-Break">like this:</span></p>
<pre class="source-code">
const Page1 = () =&gt; {
     const user = useUser();
     if (!user) {
          return (
               &lt;Layout&gt;
                    &lt;div&gt;Unauthenticated!&lt;/div&gt;
               &lt;/Layout
          )
     }
     return (
          &lt;Layout&gt;
               &lt;h1&gt;Page 1&lt;/h1&gt;
          &lt;/Layout
     )
}</pre>
<p>This way of handling layouts in Next.js applications is OK for some simple cases. However, it comes with some drawbacks, as described in the <span class="No-Break">following list:</span></p>
<ul>
<li>If the <strong class="source-inline">Layout</strong> component tracks some internal state, it will lose it when the <span class="No-Break">page changes</span></li>
<li>The page will lose its <span class="No-Break">scroll position</span></li>
<li>Anything we want to <a id="_idIndexMarker203"/>return before the final return, we also need to wrap <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">Layout</strong></span></li>
</ul>
<p>For our application, we will use a better way to handle per-page layouts by attaching them to the page component. Let’s see it in action in the <span class="No-Break">following section.</span></p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>Attaching the layout to the page component and using it to wrap the entire component</h2>
<p>To make this work, we need to first update the <span class="No-Break"><strong class="source-inline">src/pages/_app.tsx</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
import { NextPage } from 'next';
import type { AppProps } from 'next/app';
import { ReactElement, ReactNode } from 'react';
import { AppProvider } from '@/providers/app';
type NextPageWithLayout = NextPage &amp; {
  getLayout?: (page: ReactElement) =&gt; ReactNode;
};
type AppPropsWithLayout = AppProps &amp; {
  Component: NextPageWithLayout;
};
const App = ({
  Component,
  pageProps,
}: AppPropsWithLayout) =&gt; {
  const getLayout =
    Component.getLayout ?? ((page) =&gt; page);
  const pageContent = getLayout(
    &lt;Component {...pageProps} /&gt;
  );
  return &lt;AppProvider&gt;{pageContent}&lt;/AppProvider&gt;;
};
export default App;</pre>
<p>The page component expects the <strong class="source-inline">getLayout</strong> static property to be attached, which will be used to wrap the entire component when it is rendered in <strong class="source-inline">_app.tsx</strong>. Thanks to the reconciliation in <a id="_idIndexMarker204"/>React, all of the layout component states will persist when navigating between pages with the <span class="No-Break">same layout.</span></p>
<p>We already have the layout components built and will just add them to <span class="No-Break">our pages.</span></p>
<p>Now that we have everything prepared, let’s build out <span class="No-Break">our pages.</span></p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor076"/>Building the pages</h1>
<p>Now that we are acquainted with<a id="_idIndexMarker205"/> how Next.js pages work and have prepared the <strong class="source-inline">Seo</strong> component and the layout setup, let’s implement the pages for the application. We will be implementing the <span class="No-Break">following pages:</span></p>
<ul>
<li>The public organization <span class="No-Break">details page</span></li>
<li>The public job <span class="No-Break">details page</span></li>
<li>The jobs page in <span class="No-Break">the dashboard</span></li>
<li>The job details page in <span class="No-Break">the dashboard</span></li>
<li>The create <span class="No-Break">job page</span></li>
<li><span class="No-Break">404 page</span></li>
</ul>
<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/>The public organization details page</h2>
<p>The <a id="_idIndexMarker206"/>public organization details page is the page where any user can see <a id="_idIndexMarker207"/>all details about a given organization and a list of its jobs. Since it is a public page, we want to render it on the server for <span class="No-Break">better SEO.</span></p>
<p>To <a id="_idIndexMarker208"/>create the page, let’s create the <strong class="source-inline">src/pages/organizations/[organizationId]/index.tsx</strong> file, where <strong class="source-inline">organizationId</strong> refers to the dynamic ID of the organization, which will be used to retrieve the <span class="No-Break">given organization.</span></p>
<p>Then, let’s import <span class="No-Break">all dependencies:</span></p>
<pre class="source-code">
import { Heading, Stack } from '@chakra-ui/react';
import {
  GetServerSidePropsContext,
  InferGetServerSidePropsType,
} from 'next';
import { ReactElement } from 'react';
import { NotFound } from '@/components/not-found';
import { Seo } from '@/components/seo';
import { JobsList, Job } from '@/features/jobs';
import { OrganizationInfo } from '@/features/
  organizations';
import { PublicLayout } from '@/layouts/public-layout';
import {
  getJobs,
  getOrganization,
} from '@/testing/test-data';</pre>
<p>Now, let’s <a id="_idIndexMarker209"/>implement<a id="_idIndexMarker210"/> the <span class="No-Break">page component:</span></p>
<pre class="source-code">
type PublicOrganizationPageProps =
  InferGetServerSidePropsType&lt;typeof getServerSideProps&gt;;
const PublicOrganizationPage = ({
  organization,
  jobs,
}: PublicOrganizationPageProps) =&gt; {
  if (!organization) return &lt;NotFound /&gt;;
  return (
    &lt;&gt;
      &lt;Seo title={organization.name} /&gt;
      &lt;Stack
        spacing="4"
        w="full"
        maxW="container.lg"
        mx="auto"
        mt="12"
        p="4"
      &gt;
        &lt;OrganizationInfo organization={organization} /&gt;
        &lt;Heading size="md" my="6"&gt;
          Open Jobs
        &lt;/Heading&gt;
        &lt;JobsList
          jobs={jobs}
          organizationId={organization.id}
          type="public"
        /&gt;
      &lt;/Stack&gt;
    &lt;/&gt;
  );
};</pre>
<p>The <a id="_idIndexMarker211"/>page component accepts <strong class="source-inline">organization</strong> and <strong class="source-inline">jobs</strong> as props. The <a id="_idIndexMarker212"/>props are passed to the page automatically by Next.js. What gets passed as props to a page component is determined by the return value of the <strong class="source-inline">getServerSideProps</strong> function, which is executed on the server and enables server-side rendering. We will see the implementation of it in a moment, but for now, let’s wire up <span class="No-Break">the layout:</span></p>
<pre class="source-code">
PublicOrganizationPage.getLayout = function getLayout(
  page: ReactElement
) {
  return &lt;PublicLayout&gt;{page}&lt;/PublicLayout&gt;;
};</pre>
<p>This is how we will use layouts for our pages based on the setup we just configured. The <strong class="source-inline">getLayout</strong> function will wrap the page component, and the layouts will be applied. We can also nest multiple layouts if required, so this approach is <span class="No-Break">very flexible.</span></p>
<p>Now, let’s export our page, which must be exported <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">default</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
export default PublicOrganizationPage;</pre>
<p>And then, let’s<a id="_idIndexMarker213"/> implement <a id="_idIndexMarker214"/>the <span class="No-Break"><strong class="source-inline">getServerSideProps</strong></span><span class="No-Break"> function:</span></p>
<pre class="source-code">
export const getServerSideProps = async ({
  params,
}: GetServerSidePropsContext) =&gt; {
  const organizationId = params?.organizationId as string;
  const [organization, jobs] = await Promise.all([
    getOrganization(organizationId).catch(() =&gt; null),
    getJobs(organizationId).catch(() =&gt; [] as Job[]),
  ]);
  return {
    props: {
      organization,
      jobs,
    },
  };
};</pre>
<p>We are extracting the organization’s ID from <strong class="source-inline">params</strong> and using this to fetch the organization and its jobs, and then we return it as props, which will be passed to the page component. The <strong class="source-inline">getServerSideProps</strong> function must be exported as a <span class="No-Break">named export.</span></p>
<p>One more <a id="_idIndexMarker215"/>thing to note is that currently, we are loading <a id="_idIndexMarker216"/>data using the utility functions that load our testing data since we don’t have our API ready. In the following chapters, we will see how to create an actual API integration, but for now, this will allow us to build most of the UI for <span class="No-Break">our pages.</span></p>
<p>Let’s now <span class="No-Break">open </span><span class="No-Break"><strong class="source-inline">http://localhost:3000/organizations/amYXmIyT9mD9GyO6CCr</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<img alt="Figure 4.2 – The public organization details page " height="820" src="image/B17297_04_02.jpg" width="992"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The public organization details page</p>
<p>And there is our organization details page! Organizations can use this link to share info about their organizations and the list of their <span class="No-Break">job postings.</span></p>
<p>The page is rendered on the server, meaning the page’s content will be immediately available to <span class="No-Break">the user.</span></p>
<p>To verify that, disable<a id="_idIndexMarker217"/> JavaScript in your browser and refresh <span class="No-Break">the </span><span class="No-Break"><a id="_idIndexMarker218"/></span><span class="No-Break">page.</span></p>
<p>You will notice that there is no difference. All the content is available even if JavaScript is disabled because all the markup is generated on the server and returned to <span class="No-Break">the client.</span></p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor078"/>The public job details page</h2>
<p>The<a id="_idIndexMarker219"/> public job details page <a id="_idIndexMarker220"/>is the page that shows all details about a given job and allows users to apply for it. It should also be available to all users, so we want to make it search-engine friendly. Therefore, we want to render its content on the server, just as we did with the <span class="No-Break">organization page.</span></p>
<p>Let’s start by<a id="_idIndexMarker221"/> creating <strong class="source-inline">src/pages/organizations/[organizationId]/jobs/[jobId].tsx</strong>, where <strong class="source-inline">jobId</strong> refers to the ID of <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker222"/></span><span class="No-Break"> job.</span></p>
<p>Then, let’s import all <span class="No-Break">required dependencies:</span></p>
<pre class="source-code">
import { Stack, Button } from '@chakra-ui/react';
import {
  GetServerSidePropsContext,
  InferGetServerSidePropsType,
} from 'next';
import { ReactElement } from 'react';
import { NotFound } from '@/components/not-found';
import { Seo } from '@/components/seo';
import { PublicJobInfo } from '@/features/jobs';
import { PublicLayout } from '@/layouts/public-layout';
import {
  getJob,
  getOrganization,
} from '@/testing/test-data';</pre>
<p>Then, let’s <a id="_idIndexMarker223"/>define our job <span class="No-Break">page component:</span></p>
<pre class="source-code">
type PublicJobPageProps = InferGetServerSidePropsType&lt;
  typeof getServerSideProps
&gt;;
export const PublicJobPage = ({
  job,
  organization,
}: PublicJobPageProps) =&gt; {
  const isInvalid =
    !job ||
    !organization ||
    organization.id !== job.organizationId;
  if (isInvalid) {
    return &lt;NotFound /&gt;;
  }
  return (
    &lt;&gt;
      &lt;Seo title={`${job.position} | ${job.location}`} /&gt;
      &lt;Stack w="full"&gt;
        &lt;PublicJobInfo job={job} /&gt;
        &lt;Button
          bg="primary"
          color="primaryAccent"
          _hover={{
            opacity: '0.9',
          }}
          as="a"
          href={`mailto:${organization?.email}?subject=
            Application for ${job.position} position`}
          target="_blank"
        &gt;
          Apply
        &lt;/Button&gt;
      &lt;/Stack&gt;
    &lt;/&gt;
  );
};</pre>
<p>As we did with the <a id="_idIndexMarker224"/>organization page, we are loading the job and the<a id="_idIndexMarker225"/> organization via <strong class="source-inline">getServerSideProps</strong> and rendering the content on <span class="No-Break">the server.</span></p>
<p>Next, we can attach the layout of the page and <span class="No-Break">export it:</span></p>
<pre class="source-code">
PublicJobPage.getLayout = function getLayout(
  page: ReactElement
) {
  return &lt;PublicLayout&gt;{page}&lt;/PublicLayout&gt;;
};
export default PublicJobPage;</pre>
<p>And finally, let’s<a id="_idIndexMarker226"/> create the <strong class="source-inline">getServerSideProps</strong> function and <span class="No-Break">export it:</span></p>
<pre class="source-code">
export const getServerSideProps = async ({
  params,
}: GetServerSidePropsContext) =&gt; {
  const organizationId = params?.organizationId as string;
  const jobId = params?.jobId as string;
  const [organization, job] = await Promise.all([
    getOrganization(organizationId).catch(() =&gt; null),
    getJob(jobId).catch(() =&gt; null),
  ]);
  return {
    props: {
      job,
      organization,
    },
  };
};</pre>
<p>We are fetching the job and organization data, and we pass that as props to the page. The content is rendered on<a id="_idIndexMarker227"/> the server, so it will be available to the client immediately, just as it was on the <a id="_idIndexMarker228"/>organization <span class="No-Break">details page.</span></p>
<p>To verify that everything works, let’s <span class="No-Break">open </span><span class="No-Break"><strong class="source-inline">http://localhost:3000/organizations/amYXmIyT9mD9GyO6CCr/jobs/2LJ_sgmy_880G9WivH5Hf</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer018">
<img alt="Figure 4.3 – The public job details page " height="939" src="image/B17297_04_03.jpg" width="1210"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – The public job details page</p>
<p>It’s nice to have the <a id="_idIndexMarker229"/>content immediately available on the client, so why <a id="_idIndexMarker230"/>wouldn’t we render everything on <span class="No-Break">the server?</span></p>
<p>Server-side rendering has a couple <span class="No-Break">of drawbacks:</span></p>
<ul>
<li>More computing power for the server is <a id="_idIndexMarker231"/>required, which can affect <span class="No-Break">server cost</span></li>
<li>Long <strong class="source-inline">getServerSideProps</strong> execution time can block the <span class="No-Break">entire application</span></li>
</ul>
<p>That’s why we want to use it only where it makes sense, such as public pages that should be search-engine friendly, and where their content might change <span class="No-Break">more frequently.</span></p>
<p>For the dashboard pages, we will render the initial loading state on the server and then load and render data on <span class="No-Break">the client.</span></p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>The jobs page in the dashboard</h2>
<p>Let’s <a id="_idIndexMarker232"/>create<a id="_idIndexMarker233"/> the <span class="No-Break"><strong class="source-inline">src/pages/dashboard/jobs/index.tsx</strong></span><span class="No-Break"> file.</span></p>
<p>Then, we can import all <span class="No-Break">required dependencies:</span></p>
<pre class="source-code">
import { PlusSquareIcon } from '@chakra-ui/icons';
import { Heading, HStack } from '@chakra-ui/react';
import { ReactElement } from 'react';
import { Link } from '@/components/link';
import { Loading } from '@/components/loading';
import { Seo } from '@/components/seo';
import { JobsList } from '@/features/jobs';
import { DashboardLayout } from '@/layouts/dashboard-layout';
import { useJobs, useUser } from '@/testing/test-data';</pre>
<p>Next, we can<a id="_idIndexMarker234"/> define and export the <span class="No-Break">page component:</span></p>
<pre class="source-code">
const DashboardJobsPage = () =&gt; {
  const user = useUser();
  const jobs = useJobs(user.data?.organizationId ?? '');
  if (jobs.isLoading) return &lt;Loading /&gt;;
  if (!user.data) return null;
  return (
    &lt;&gt;
      &lt;Seo title="Jobs" /&gt;
      &lt;HStack
        mb="8"
        align="center"
        justify="space-between"
      &gt;
        &lt;Heading&gt;Jobs&lt;/Heading&gt;
        &lt;Link
          icon={&lt;PlusSquareIcon /&gt;}
          variant="solid"
          href="/dashboard/jobs/create"
        &gt;
          Create Job
        &lt;/Link&gt;
      &lt;/HStack&gt;
      &lt;JobsList
        jobs={jobs.data || []}
        isLoading={jobs.isLoading}
        organizationId={user.data.organizationId}
        type="dashboard"
      /&gt;
    &lt;/&gt;
  );
};
DashboardJobsPage.getLayout = function getLayout(
  page: ReactElement
) {
  return &lt;DashboardLayout&gt;{page}&lt;/DashboardLayout&gt;;
};
export default DashboardJobsPage;</pre>
<p>Notice how <a id="_idIndexMarker235"/>all data <a id="_idIndexMarker236"/>fetching happens in the component because we are doing it on <span class="No-Break">the client.</span></p>
<p>To verify that everything works as expected, let’s <span class="No-Break">open </span><span class="No-Break"><strong class="source-inline">http://localhost:3000/dashboard/jobs</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer019">
<img alt="Figure 4.4 – The dashboard jobs page " height="983" src="image/B17297_04_04.jpg" width="1211"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – The dashboard jobs page</p>
<p>And there it is! This<a id="_idIndexMarker237"/> page allows organization admins to have an overview<a id="_idIndexMarker238"/> of their <span class="No-Break">organization’s jobs.</span></p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/>The job details page in the dashboard</h2>
<p>The dashboard job details page<a id="_idIndexMarker239"/> will show all details about a given job in<a id="_idIndexMarker240"/> <span class="No-Break">the dashboard.</span></p>
<p>To get started, let’s <a id="_idIndexMarker241"/>create <strong class="source-inline">src/pages/dashboard/jobs/[jobId].tsx</strong>, where <strong class="source-inline">jobId</strong> refers to the dynamic ID of <span class="No-Break">the job.</span></p>
<p>Then we can import <span class="No-Break">all dependencies:</span></p>
<pre class="source-code">
import { useRouter } from 'next/router';
import { ReactElement } from 'react';
import { Loading } from '@/components/loading';
import { NotFound } from '@/components/not-found';
import { Seo } from '@/components/seo';
import { DashboardJobInfo } from '@/features/jobs';
import { DashboardLayout } from '@/layouts/
  dashboard-layout';
import { useJob } from '@/testing/test-data';</pre>
<p>Then let’s <a id="_idIndexMarker242"/>define <a id="_idIndexMarker243"/>and export our <span class="No-Break">page component:</span></p>
<pre class="source-code">
const DashboardJobPage = () =&gt; {
  const router = useRouter();
  const jobId = router.query.jobId as string;
  const job = useJob(jobId);
  if (job.isLoading) {
    return &lt;Loading /&gt;;
  }
  if (!job.data) {
    return &lt;NotFound /&gt;;
  }
  return (
    &lt;&gt;
      &lt;Seo
        title={`${job.data.position} | ${job.data.
          location}`}
      /&gt;
      &lt;DashboardJobInfo job={job.data} /&gt;
    &lt;/&gt;
  );
};
DashboardJobPage.getLayout = function getLayout(
  page: ReactElement
) {
  return &lt;DashboardLayout&gt;{page}&lt;/DashboardLayout&gt;;
};
export default DashboardJobPage;</pre>
<p>To verify that<a id="_idIndexMarker244"/> everything <a id="_idIndexMarker245"/>works as expected, let’s <span class="No-Break">open </span><span class="No-Break"><strong class="source-inline">http://localhost:3000/dashboard/jobs/wS6UeppUQoiXGTzAI6XrM</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<img alt="Figure 4.5 – The dashboard job details page " height="928" src="image/B17297_04_05.jpg" width="1209"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – The dashboard job details page</p>
<p>And this is our<a id="_idIndexMarker246"/> dashboard <a id="_idIndexMarker247"/>job details page. We can see basic details about a given <span class="No-Break">job here.</span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>The create job page</h2>
<p>The <a id="_idIndexMarker248"/>create job page<a id="_idIndexMarker249"/> is the page where we will render the form for <span class="No-Break">creating jobs.</span></p>
<p>To get started, let’s <a id="_idIndexMarker250"/><span class="No-Break">create </span><span class="No-Break"><strong class="source-inline">src/pages/dashboard/jobs/create.tsx</strong></span><span class="No-Break">.</span></p>
<p>Then, let’s import the <span class="No-Break">required dependencies:</span></p>
<pre class="source-code">
import { Heading } from '@chakra-ui/react';
import { useRouter } from 'next/router';
import { ReactElement } from 'react';
import { Seo } from '@/components/seo';
import { CreateJobForm } from '@/features/jobs';
import { DashboardLayout } from '@/layouts/
  dashboard-layout';</pre>
<p>Then, we can<a id="_idIndexMarker251"/> create and <a id="_idIndexMarker252"/>export the <span class="No-Break">page component:</span></p>
<pre class="source-code">
const DashboardCreateJobPage = () =&gt; {
  const router = useRouter();
  const onSuccess = () =&gt; {
    router.push(`/dashboard/jobs`);
  };
  return (
    &lt;&gt;
      &lt;Seo title="Create Job" /&gt;
      &lt;Heading mb="8"&gt;Create Job&lt;/Heading&gt;
      &lt;CreateJobForm onSuccess={onSuccess} /&gt;
    &lt;/&gt;
  );
};
DashboardCreateJobPage.getLayout = function getLayout(
  page: ReactElement
) {
  return &lt;DashboardLayout&gt;{page}&lt;/DashboardLayout&gt;;
};
export default DashboardCreateJobPage;</pre>
<p>To verify <a id="_idIndexMarker253"/>that everything <a id="_idIndexMarker254"/>works as expected, let’s <span class="No-Break">open </span><span class="No-Break"><strong class="source-inline">http://localhost:3000/dashboard/jobs/create</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<img alt="Figure 4.6 – The dashboard create job page " height="1019" src="image/B17297_04_06.jpg" width="1210"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – The dashboard create job page</p>
<p>And there it is! For this chapter, we have just created the pages and will handle the data submission in the <span class="No-Break">upcoming chapters.</span></p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor082"/>404 page</h2>
<p>If you tried to visit a page before we implemented it, you might have noticed a blank page. To let users know when<a id="_idIndexMarker255"/> they visit a non-existent page, we should create a custom<a id="_idIndexMarker256"/> <span class="No-Break">404 page.</span></p>
<p>Let’s start by creating <strong class="source-inline">src/pages/404.tsx</strong> and add <span class="No-Break">the following:</span></p>
<pre class="source-code">
import { Center } from '@chakra-ui/react';
import { Link } from '@/components/link';
import { NotFound } from '@/components/not-found';
const NotFoundPage = () =&gt; {
  return (
    &lt;&gt;
      &lt;NotFound /&gt;
      &lt;Center&gt;
        &lt;Link href="/"&gt;Home&lt;/Link&gt;
      &lt;/Center&gt;
    &lt;/&gt;
  );
};
export default NotFoundPage;</pre>
<p>The <strong class="source-inline">404.tsx</strong> file in the <strong class="source-inline">pages</strong> folder is a special page that will be displayed whenever a user visits an <span class="No-Break">unknown page.</span></p>
<p>To verify that everything <a id="_idIndexMarker257"/>works as <a id="_idIndexMarker258"/>expected, let’s <span class="No-Break">visit </span><span class="No-Break"><strong class="source-inline">http://localhost:3000/non-existing-page</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<img alt="Figure 4.7 – 404 page " height="579" src="image/B17297_04_07.jpg" width="1234"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – 404 page</p>
<p>And there it is! We have a nice interface to return to the application if we end up on a <span class="No-Break">missing page.</span></p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>Summary</h1>
<p>In this chapter, our focus has been on building the pages of <span class="No-Break">our application.</span></p>
<p>We started by looking at how routing works in Next.js. Then we covered the rendering strategies we will be using. After that, we built the SEO component, which injects content into the head of <span class="No-Break">the page.</span></p>
<p>We then configured the layout system for our pages. At the end of the chapter, we built the pages for our application. To build the content for our pages, we used test data that was predefined. We used test data to render content on the pages, but we still need to make real <span class="No-Break">API calls.</span></p>
<p>In the next chapter, we will learn how to mock the API endpoints, which we can use during development to make HTTP requests and fetch data as if we were consuming the <span class="No-Break">real API.</span></p>
</div>
</div></body></html>