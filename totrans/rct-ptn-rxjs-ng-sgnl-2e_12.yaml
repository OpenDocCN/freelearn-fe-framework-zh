- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Processing Real-Time Updates
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理实时更新
- en: '**Real time** refers to the capability of an application to handle and respond
    to data or events immediately as they happen, without any noticeable delay or
    latency. This is a very hot topic nowadays, with the demand for real-time features
    growing in web applications, particularly in areas such as live financial trading,
    live tracking systems, and live monitoring, analytics, and healthcare. Ultimately,
    the quicker you get the data, the sooner you can react and make decisions, increasing
    the chances of higher profits.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**实时**指的是应用程序能够立即处理和响应数据或事件的能力，没有任何明显的延迟或延迟。这在当今是一个非常热门的话题，因为对实时功能的需求在 Web
    应用程序中不断增长，尤其是在实时金融交易、实时跟踪系统、实时监控、分析和医疗保健等领域。最终，你获取数据越快，你就能越快做出反应和决策，从而提高获得更高利润的机会。'
- en: So, how can you process real-time messages in the frontend and update the displayed
    data automatically in the UI? This is what we will cover in this chapter. We will
    start by explaining the real-time requirement, and then we will walk you through
    the different steps to implement the reactive pattern for consuming real-time
    updates. Finally, we will learn the reactive pattern for handling reconnection.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你如何在前端处理实时消息并自动更新 UI 中显示的数据？这正是本章将要涵盖的内容。我们将首先解释实时要求，然后我们将向您介绍实现消费实时更新的反应式模式的各个步骤。最后，我们将学习用于处理重连的反应式模式。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Defining the requirements of real time
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义实时要求
- en: Learning the reactive pattern for consuming real-time messages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习用于消费实时消息的反应式模式
- en: Learning the reactive pattern for handling reconnection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习用于处理重连的反应式模式
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you have a basic understanding of RxJS.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您对 RxJS 有基本的了解。
- en: 'We used the `ws` library, which is a WebSocket Node.js library, in order to
    support WS in our backend. For more details, check out this link: [https://github.com/websockets/ws](https://github.com/websockets/ws).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `ws` 库，这是一个 WebSocket Node.js 库，以便在我们的后端支持 WS。更多详情，请查看此链接：[https://github.com/websockets/ws](https://github.com/websockets/ws)。
- en: The source code of this chapter is available at [https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-for-Angular-16-2nd-Edition/tree/main/Chap12](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-for-Angular-16-2nd-Edition/tree/main/Chap12).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在[https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-for-Angular-16-2nd-Edition/tree/main/Chap12](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-for-Angular-16-2nd-Edition/tree/main/Chap12)找到。
- en: Defining the requirements of real time
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义实时要求
- en: 'There are two techniques available for publishing real-time data on the web:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上发布实时数据有两种技术可用：
- en: '**Pull technique**: This is where the client raises a request to get the latest
    version of data. **HTTP polling** and **HTTP long polling** are two examples of
    implementations of this pull technique.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拉取技术**：这是客户端发起请求以获取最新数据版本的地方。**HTTP 轮询**和**HTTP 长轮询**是这种拉取技术实现的两个例子。'
- en: '**Push technique**: This is where the server pushes updates to the client.
    **WebSockets** and **server-sent events** are two implementations of this push
    technique.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推送技术**：这是服务器将更新推送到客户端的地方。**WebSocket** 和 **服务器发送事件**是这种推送技术的两种实现。'
- en: We are not going to discuss or compare these techniques in detail, as it is
    not the goal of this chapter; however, in general, push techniques have a lower
    latency compared to pull ones. For this reason, we will use the push technique
    and WebSocket as the implementation for our requirements.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细讨论或比较这些技术，因为这不是本章的目标；然而，一般来说，推送技术相比拉取技术具有更低的延迟。因此，我们将使用推送技术和 WebSocket
    作为我们需求的实现。
- en: In short, the WebSocket protocol is a stateful communication protocol that establishes
    a low-latency bi-directional communication channel between a client and a server.
    In this way, messages can be sent back and forth between the server and the client.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，WebSocket 协议是一种有状态的通信协议，它在一个客户端和服务器之间建立了一个低延迟的双向通信通道。这样，消息可以在服务器和客户端之间来回发送。
- en: 'The following diagram illustrates the WebSocket communication flow:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了 WebSocket 通信流程：
- en: '![Figure 12.1 – WebSocket communication](img/B21180_12_1.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – WebSocket 通信](img/B21180_12_1.jpg)'
- en: Figure 12.1 – WebSocket communication
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – WebSocket 通信
- en: 'As illustrated, there are three steps in WebSocket communication:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，WebSocket 通信有三个步骤：
- en: '**Opening the connection**: In this step, the client issues an HTTP request
    to tell the server that a protocol upgrade will occur (from HTTP to WebSocket).
    If the server supports WebSockets, then the protocol switch will be accepted.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**打开连接**：在这个步骤中，客户端发出一个 HTTP 请求来告诉服务器将发生协议升级（从 HTTP 到 WebSocket）。如果服务器支持 WebSocket，则协议切换将被接受。'
- en: '**Establishing the communication channel**: Once the protocol upgrade is done,
    then a bi-directional communication channel will be created, and messages start
    to be sent back and forth between the server and the client.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**建立通信通道**：一旦完成协议升级，将创建一个双向通信通道，服务器和客户端之间开始发送和接收消息。'
- en: '**Closing the connection**: When the communication is over, a request will
    be issued to close the connection.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**关闭连接**：当通信结束时，将发出一个请求来关闭连接。'
- en: At this level, that is all that you need to know about WebSockets. Now, let’s
    quickly review what we’ll be doing in our app.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个层面，这就是你需要了解的所有关于 WebSocket 的内容。现在，让我们快速回顾一下我们将在应用中做什么。
- en: In our recipe app, `RecipesListComponent` is responsible for displaying the
    list of recipes. We will simulate the addition of a new recipe (a recipe for chilli
    chicken) after a delay of 5 seconds following the rendering of `RecipesListComponent`.
    The UI should then be updated instantly to include this new recipe by rendering
    it in the `RecipesList` page.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的食谱应用中，`RecipesListComponent` 负责显示食谱列表。我们将在 `RecipesListComponent` 渲染后延迟
    5 秒模拟添加一个新的食谱（辣子鸡的食谱）。然后，UI 应立即更新，通过在 `RecipesList` 页面上渲染来包括这个新食谱。
- en: You will find a ready-to-use WebSocket backend under the `recipes-book-api`
    folder; this is what pushes the new recipe to the frontend 5 seconds after establishing
    the connection. We will also use a timer in the backend to simulate the arrival
    of a new recipe. `RecipesListComponent` should then consume the message coming
    from the WebSocket server and push the newly received recipe in the already displayed
    list of recipes. The UI should be updated automatically without having to trigger
    any **Refresh** button to get the updates.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 `recipes-book-api` 文件夹下找到一个现成的 WebSocket 后端；这是在建立连接 5 秒后向前端推送新食谱的。我们还将使用后端中的计时器来模拟新食谱的到达。然后
    `RecipesListComponent` 应该消费来自 WebSocket 服务器的消息，并将新接收到的食谱推送到已显示的食谱列表中。UI 应自动更新，无需触发任何
    **刷新** 按钮来获取更新。
- en: So, without further ado, in the next section, let’s see how we can implement
    all of this using RxJS’s `WebSocketSubject`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无需多言，在下一节中，让我们看看如何使用 RxJS 的 `WebSocketSubject` 来实现所有这些。
- en: Learning the reactive pattern for consuming real-time messages
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习用于消费实时消息的反应式模式
- en: RxJS has a special type of subject called `WebSocketSubject`; this is nothing
    but a wrapper around the W3C WebSocket object, which is available in the browser.
    It allows you to communicate with a WebSocket server, both sending and consuming
    data through a WebSocket connection.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS 有一种特殊类型的主题称为 `WebSocketSubject`；这实际上是对 W3C WebSocket 对象的包装，它在浏览器中可用。它允许你通过
    WebSocket 连接与 WebSocket 服务器进行通信，发送和消费数据。
- en: Let’s explore the capabilities of `WebSocketSubject` and learn how to use it
    to consume real-time messages in our project.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索 `WebSocketSubject` 的功能，并学习如何在我们项目中使用它来消费实时消息。
- en: Creating and using WebSocketSubject
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用 WebSocketSubject
- en: 'In order to use `WebSocketSubject`, you have to call the `webSocket` factory
    function that produces this special type of subject and takes the endpoint of
    your WebSocket server as input. The following is the function signature:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 `WebSocketSubject`，你必须调用 `webSocket` 工厂函数，它产生这种特殊类型的主题，并接受你的 WebSocket
    服务器端点作为输入。以下是其函数签名：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It accepts two types of arguments, either of the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受两种类型的参数，以下两种之一：
- en: A string representing the URL of your WebSocket server endpoint
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示你的 WebSocket 服务器端点 URL 的字符串
- en: A special object of the `WebSocketSubjectConfig` type that contains the URL
    of your endpoint, along with other properties (we will explore `WebSocketSubjectConfig`
    in detail in the *Learning the reactive pattern for handling* *reconnection* section)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含你的端点 URL 以及其他属性的 `WebSocketSubjectConfig` 类型的特殊对象（我们将在 *学习用于处理* *重连* 的反应式模式部分详细探讨
    `WebSocketSubjectConfig`）
- en: 'The following code is an example of calling the `webSocket` factory function
    with the first type of argument:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是调用 `webSocket` 工厂函数并使用第一种类型参数的示例：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next piece of code is an example of calling the `webSocket` factory function
    using the second type of argument:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下一段代码是使用第二种类型的参数调用 `webSocket` 工厂函数的示例：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our case, the URL of our endpoint is `ws://localhost:8081`. You can use `wss`
    for a secure WebSocket connection (which is the same as HTTPS for a secure HTTP
    connection).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这个例子中，我们端点的URL是 `ws://localhost:8081`。你可以使用 `wss` 来进行安全的WebSocket连接（这和安全的HTTP连接中的HTTPS相同）。
- en: We will be using both types of arguments in this chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用这两种类型的参数。
- en: Let’s now see how we can establish the connection to the WebSocket in the following
    section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下如何在下一节中建立WebSocket的连接。
- en: Opening the connection
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打开连接
- en: 'Now that you have a reference for `WebSocketSubject`, you should subscribe
    to it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了 `WebSocketSubject` 的参考，你应该订阅它：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will establish the connection with your `ws` endpoint and allow you to
    start receiving and sending data. Of course, if you don’t subscribe, the connection
    will not be created.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将建立与你的 `ws` 端点的连接，并允许你开始接收和发送数据。当然，如果你不订阅，连接将不会创建。
- en: Listening to incoming messages from the server
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监听来自服务器的传入消息
- en: '`WebSocketSubject` is nothing but a regular RxJS subject, whereby you can register
    callbacks to listen and process the incoming messages from the WebSocket server.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebSocketSubject` 仅仅是一个常规的RxJS主题，你可以注册回调来监听和处理来自WebSocket服务器的传入消息。'
- en: 'In order to listen to messages, you should subscribe to the produced `WebSocketSubject`
    from the `webSocket` factory function and register a callback, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了监听消息，你应该从 `webSocket` 工厂函数订阅生成的 `WebSocketSubject` 并注册一个回调，如下所示：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we’re simply subscribing to the WebSocket subject to initiate a connection
    with the WebSocket server and then logging any received messages to the console.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是订阅WebSocket主题以与WebSocket服务器建立连接，并将接收到的任何消息记录到控制台。
- en: Pushing messages to the server
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向服务器推送消息
- en: 'To send messages to the server, we just use the `next` method available in
    the `subject` type:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要向服务器发送消息，我们只需使用 `subject` 类型中可用的 `next` 方法：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Handling errors
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理错误
- en: 'You can also catch errors coming from the server using `catchError` as usual
    and push errors to the server by calling the `error` method. Here’s an example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以像往常一样使用 `catchError` 来捕获来自服务器的错误，并通过调用 `error` 方法将错误推送到服务器。以下是一个示例：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, bear in mind that when you send an error, the server will get notified
    about this error, and then the connection will be closed. So, nothing will get
    emitted thereafter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，当你发送错误时，服务器将收到这个错误的通知，然后连接将被关闭。因此，之后将不会发出任何内容。
- en: Closing the connection
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关闭连接
- en: 'You can use `unsubscribe` or `complete` to close the connection:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `unsubscribe` 或 `complete` 来关闭连接：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So, to wrap up what we’ve been discussing, only the creation of `WebSocketSubject`
    is specific to this special kind of subject. However, all the other APIs used
    (`subscribe`, `unsubscribe`, `complete`, `catchError`, `next`, and so on) are
    the same as those used for regular subjects. The following figure illustrates
    this whole process:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了总结我们讨论的内容，只有 `WebSocketSubject` 的创建是特定于这种特殊类型的主题。然而，所有其他使用的API（`subscribe`、`unsubscribe`、`complete`、`catchError`、`next`
    等）与常规主题使用的相同。以下图示展示了整个过程：
- en: '![Figure 12.2 – WebSocketSubject possible events](img/B21180_12_2.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – WebSocketSubject可能的事件](img/B21180_12_2.jpg)'
- en: Figure 12.2 – WebSocketSubject possible events
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – WebSocketSubject可能的事件
- en: Now that we’ve covered various WebSocket manipulations, from creating and establishing
    connections to sending messages, handling errors, and consuming incoming messages,
    let’s explore a common pitfall you should keep in mind.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了各种WebSocket操作，从创建和建立连接到发送消息、处理错误以及消费传入的消息，让我们来探讨一个你应该注意的常见陷阱。
- en: Connection management
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接管理
- en: At this point, there is a particular behavior you should be aware of. If the
    same instance of `WebSocketSubject` has many subscribers, then they will share
    the same connection to save resources. However, if we have two different instances
    of `WebSocketSubject`, it will establish two distinct connections, even if they
    are referencing the same endpoint.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你应该注意一个特定的行为。如果同一个 `WebSocketSubject` 实例有多个订阅者，那么它们将共享相同的连接以节省资源。然而，如果我们有两个不同的
    `WebSocketSubject` 实例，即使它们引用的是同一个端点，它们也会建立两个不同的连接。
- en: 'The following code explains the connection management for both use cases:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码解释了两种用例的连接管理：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let’s explain what’s happening in this code. First, we create two instances
    of `WebSocketSubject` called `firstSubject$` and `secondSubject$`, respectively,
    which both reference the same `ws` endpoint.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下这段代码中发生的事情。首先，我们创建了两个名为`firstSubject$`和`secondSubject$`的`WebSocketSubject`实例，它们都引用了同一个`ws`端点。
- en: Then, we create a subscription to `firstSubject$`; this first subscription will
    open the WebSocket connection. Then, we create a second subscription to the same
    Observable, `firstSubject$`; this second subscription will use the already opened
    WebSocket connection.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个订阅`firstSubject$`；这个第一个订阅将打开WebSocket连接。接着，我们为同一个Observable，即`firstSubject$`，创建了一个第二个订阅；这个第二个订阅将使用已经打开的WebSocket连接。
- en: However, the subscription to `secondSubject$` will open a new WebSocket connection.
    Why? Because it is a new reference to the WebSocket subject, even though it references
    the same `ws` endpoint as `firstSubject$`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对`secondSubject$`的订阅将打开一个新的WebSocket连接。为什么？因为它是对WebSocket主题的新引用，尽管它引用了与`firstSubject$`相同的`ws`端点。
- en: 'Now, if we have many subscribers sharing the same connection and one of those
    subscribers decides to complete, then the connection will be released unless there
    are no more subscribers listening, as described in the following code block:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们有多个共享相同连接的订阅者，并且其中一个订阅者决定完成，那么除非没有更多的订阅者监听，否则连接将被释放，正如以下代码块中描述的那样：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is all that you need to know to make a basic scenario work. Simple, right?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要知道的所有内容，以便使基本场景工作。简单，对吧？
- en: Now, let’s see the recommended pattern for putting our recipe app in place.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看将我们的食谱应用部署到位的推荐模式。
- en: WebSocketSubject in action
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocketSubject在行动
- en: Now that we know how to create a connection to our `ws` endpoint, it is time
    to explore the different steps to consume real-time messages in our `RecipesApp`.
    In particular, we will establish a connection to the WebSocket server, and once
    the new recipe is sent to the frontend, we will update it in the UI. Let’s delve
    into the various steps necessary to fulfill this requirement.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了如何创建到`ws`端点的连接，那么现在是时候探索在`RecipesApp`中消费实时消息的不同步骤了。特别是，我们将建立与WebSocket服务器的连接，一旦新的食谱被发送到前端，我们将在UI中更新它。让我们深入了解满足这一要求所需的各个步骤。
- en: Step one – create a real-time service
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一步 - 创建实时服务
- en: 'The first step is to isolate all the interactions with `WebSocketSubject` in
    a separate Angular service. To do this, we will create an Angular service called
    `RealTimeService` under the `src/app/core/services` path. `RealTimeService` will
    look like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将与`WebSocketSubject`的所有交互隔离到一个单独的Angular服务中。为此，我们将在`src/app/core/services`路径下创建一个名为`RealTimeService`的Angular服务。`RealTimeService`将如下所示：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s break down what’s happening at the level of this code in the service
    that we defined:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下在定义的服务中，代码层面的具体操作：
- en: We have a private property, `socket$`, of type `WebSocketSubject<Recipe[]>|undefined`,
    as we will receive an array containing one or more recipes from the backend. `socket$`
    contains the reference to the WebSocket subject that we will create using the
    `getNewWebSocket()` method.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个私有属性`socket$`，其类型为`WebSocketSubject<Recipe[]>|undefined`，因为我们将从后端接收包含一个或多个食谱的数组。`socket$`包含我们将使用`getNewWebSocket()`方法创建的WebSocket主题的引用。
- en: We have a private `BehaviorSubject` named `messagesSubject$`, which is responsible
    for transmitting the latest incoming messages from the WebSocket server to new
    subscribers. We’ve provided the type `Observable<Recipe[]>` for `messagesSubject$`,
    as it will emit an Observable containing an array of recipe objects. Initially,
    we’ve set it to `EMPTY`, which is an Observable that immediately completes without
    emitting any values.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个名为`messagesSubject$`的私有`BehaviorSubject`，它负责将WebSocket服务器发送的最新消息传输给新的订阅者。我们为`messagesSubject$`提供了类型`Observable<Recipe[]>`，因为它将发出包含一系列食谱对象的Observable。最初，我们将其设置为`EMPTY`，这是一个立即完成而不发出任何值的Observable。
- en: We have a private method, `getNewWebSocket()`, that calls the `webSocket` factory
    function, passing a constant named `WS_ENDPOINT` as input, and this returns `WebSocketSubject`.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个名为`getNewWebSocket()`的私有方法，它调用`webSocket`工厂函数，传入一个名为`WS_ENDPOINT`的常量作为输入，并返回`WebSocketSubject`。
- en: '`WS_ENDPOINT` represents the endpoint of the WebSocket server defined in the
    `src/environments/environment.ts` file as `wsEndpoint`. Note that URLs are environment-specific
    configurations, which means they can change from one environment to another (e.g.,
    development, staging, and production). Defining endpoint URLs in the `environment.ts`
    file is a common practice in Angular applications because it provides a centralized
    location to handle environment-specific configuration settings, so you can easily
    switch between environments without modifying your application code.'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`WS_ENDPOINT` 代表在 `src/environments/environment.ts` 文件中定义的 WebSocket 服务器端点，作为
    `wsEndpoint`。请注意，URL 是特定于环境的配置，这意味着它们可以从一个环境更改为另一个环境（例如，开发、测试和生产）。在 `environment.ts`
    文件中定义端点 URL 是 Angular 应用程序中的常见做法，因为它提供了一个集中位置来处理特定于环境的配置设置，因此您可以轻松地在环境之间切换，而无需修改应用程序代码。'
- en: We have a public method, `sendMessage()`, that sends a message that is given
    as input to the socket, which will forward the message to the server.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个公共方法 `sendMessage()`，它将作为输入发送的消息发送到套接字，该套接字将消息转发到服务器。
- en: Finally, we have a public method, `close()`, that closes the connection by completing
    the subject.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有一个公共方法 `close()`，它通过完成主题来关闭连接。
- en: 'Then, we will add the `connect()` method, which will listen to the incoming
    messages in a reactive way and emit messages to the subscribers as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加 `connect()` 方法，该方法将以响应式的方式监听传入的消息，并将消息作为如下所示发送给订阅者：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let’s break down what is going on in this method. If `socket$` is undefined
    (not yet created) or closed, then `socket$` will be populated by the newly produced
    `WebSocketSubject` from the `getNewWebSocket` method.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个方法中正在发生的事情。如果 `socket$` 未定义（尚未创建）或已关闭，则 `socket$` 将由 `getNewWebSocket`
    方法产生的新 `WebSocketSubject` 填充。
- en: Then, we will combine the `tap` and `catchError` operators; the `tap` operator
    is used to log a message when an error occurs or when the connection closes, and
    the `catchError` operator handles errors and returns an empty Observable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将组合 `tap` 和 `catchError` 操作符；`tap` 操作符用于在发生错误或连接关闭时记录消息，而 `catchError`
    操作符处理错误并返回一个空的可观察对象。
- en: 'The returned Observable from the pipe operation will be stored in a constant
    called `messages`. The `messagesSubject$` Observable will emit the messages’ Observable
    (so, it is an Observable of Observables):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 管道操作返回的可观察对象将被存储在一个名为 `messages` 的常量中。`messagesSubject$` 可观察对象将发出消息的可观察对象（因此，它是一个可观察对象的可观察对象）：
- en: 'After that, we will provide a read-only copy from the `messagesSubject$` Observable
    through the `messages$` public Observable defined in `RealTimeService` as follows:
    :'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将通过在 `RealTimeService` 中定义的 `messages$` 公共可观察对象提供 `messagesSubject$` 可观察对象的只读副本，如下所示：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We used the `SwitchAll` operator to flatten the Observable of an Observable,
    and we will be subscribing to `messages$` in every component that needs to consume
    real-time updates. Why do we do this? The idea is to protect `Subject$` and the
    incoming messages from any external update and expose the messages to the consumers
    as read only. In this way, any component interested in consuming the real-time
    messages has to subscribe to `messages$`, and all the logic related to the socket
    will be handled privately in this service.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `SwitchAll` 操作符来展平可观察对象的可观察对象，我们将订阅 `messages$` 在每个需要消费实时更新的组件中。我们为什么要这样做？想法是保护
    `Subject$` 和传入的消息免受任何外部更新的影响，并将消息作为只读形式暴露给消费者。这样，任何对消费实时消息感兴趣的组件都必须订阅 `messages$`，而与套接字相关的所有逻辑都将在这个服务中私下处理。
- en: Step two – trigger the connection
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二步 – 触发连接
- en: 'After putting the service in place, we should call the `connect` method. As
    we want the `connect` method to be triggered just once, we will call it from the
    root component, `src/app/app.component.ts`, after injecting `RealTimeService`.
    Here’s the code to be added:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置服务之后，我们应该调用 `connect` 方法。由于我们希望 `connect` 方法只触发一次，我们将在注入 `RealTimeService`
    之后从根组件 `src/app/app.component.ts` 中调用它。以下是需要添加的代码：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Step three – define the Observable emitting live updates
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三步 – 定义发出实时更新的可观察对象
- en: Next, we should call the `messages$` Observable in the adequate Angular component.
    As we want to update the list of recipes with the newest ones, we should define
    the Observable in `RecipesListComponent`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该在适当的 Angular 组件中调用 `messages$` 可观察对象。由于我们希望用最新的食谱更新列表，我们应该在 `RecipesListComponent`
    中定义可观察对象。
- en: 'But wait! We already have an Observable in `RecipesListComponent` named `recipes$`
    that fetches the list of recipes from `RecipesService`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等！我们已经在 `RecipesListComponent` 中有一个名为 `recipes$` 的 Observable，它从 `RecipesService`
    获取食谱列表：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Could we use this existing Observable instead of creating a new one? Absolutely!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否使用这个现有的 Observable 而不是创建一个新的？当然可以！
- en: Our goal is to initially display the list of recipes emitted by `recipes$` and
    then seamlessly incorporate any newly added recipes emitted by `messages$`. We
    can achieve this using the `combineLatest` operator from RxJS.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是首先显示 `recipes$` 发射的食谱列表，然后无缝地结合 `messages$` 发射的任何新添加的食谱。我们可以使用 RxJS 中的
    `combineLatest` 操作符来实现这一点。
- en: 'The `combineLatest` operator merges the latest values from multiple Observables
    into an array and emits a new array whenever any of the source Observables emits
    a value. By leveraging this operator, we can combine `recipes$` and `messages$`
    as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`combineLatest` 操作符将多个 Observables 的最新值合并到一个数组中，并在任何源 Observable 发射值时发射一个新的数组。通过利用这个操作符，我们可以将
    `recipes$` 和 `messages$` 结合如下：'
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the code, we combined `recipes$` and `messages$` and then used the `map`
    operator to extract the latest values emitted by each. We then merge these values
    into a single array, which is then returned. This ensures that `recipes$` consistently
    emits a unified array containing all recipes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们结合了 `recipes$` 和 `messages$`，然后使用 `map` 操作符提取每个发射的最新值。然后我们将这些值合并到一个数组中，然后返回。这确保了
    `recipes$` 一致地发射包含所有食谱的统一数组。
- en: Preventing data loss with the scan operator
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 `scan` 操作符防止数据丢失
- en: Now, let’s quickly consider a scenario where a recipe with an ID of 12 is initially
    pushed and added to the recipes list. If another recipe with, for example, an
    ID of 14 is pushed afterward from the server, then the newest pushed recipe (ID
    14) will override the previous one (ID 12). Therefore, the ID 12 recipe will be
    lost. To prevent this data loss, we can use the `scan` operator.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速考虑一个场景，即一个 ID 为 12 的食谱最初被推送到并添加到食谱列表中。如果之后从服务器推送另一个 ID 为 14 的食谱，那么最新的推送食谱（ID
    14）将覆盖之前的（ID 12）。因此，ID 12 的食谱将会丢失。为了防止这种数据丢失，我们可以使用 `scan` 操作符。
- en: The `scan` operator in RxJS is similar to the reduce function in JavaScript.
    It applies an accumulator function over an Observable sequence and returns each
    intermediate result, emitting the accumulated value each time a new value is emitted
    by the source Observable. In simpler terms, it continuously applies a function
    to each value emitted by the source Observable, accumulating these values over
    time and emitting the intermediate results. This operator is useful for maintaining
    the state, accumulating values, or performing any kind of stateful transformation
    on Observable streams.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS 中的 `scan` 操作符类似于 JavaScript 中的 `reduce` 函数。它对 Observable 序列应用一个累加函数，并返回每个中间结果，每次源
    Observable 发射新值时都会发射累加的值。用更简单的术语来说，它持续地对源 Observable 发射的每个值应用一个函数，随着时间的推移积累这些值，并发射中间结果。这个操作符对于维护状态、累加值或对
    Observable 流执行任何类型的带状态转换非常有用。
- en: 'So, in our case, we can use the `scan` operator as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的情况下，我们可以如下使用 `scan` 操作符：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this context, `scan` ensures that all emitted recipes, including both the
    initial recipes fetched from the `this.service.recipes$` stream and any subsequent
    updates received from `this.realTimeService.messages$`, are accumulated into a
    single array. This prevents the loss of data that could occur if a simple mapping
    operation were used. As a result, the `recipes$` Observable stream contains a
    comprehensive and up-to-date list of recipes, reflecting all changes from both
    sources throughout its lifetime.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`scan` 确保所有发射的食谱，包括从 `this.service.recipes$` 流中获取的初始食谱和从 `this.realTimeService.messages$`
    收到的任何后续更新，都被累积到一个数组中。这防止了如果使用简单的映射操作可能发生的数据丢失。因此，`recipes$` Observable 流包含了一个全面且最新的食谱列表，反映了其整个生命周期中从两个来源的所有变化。
- en: Step four – subscribe to the Observable emitting live updates
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第四步 - 订阅发射实时更新的 Observable
- en: 'Finally, we just have to subscribe to the `recipes$` Observable in our component’s
    template using the async pipe, which is already carried out in `recipes-list.component.html`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需在我们的组件模板中使用异步管道订阅 `recipes$` Observable，这在 `recipes-list.component.html`
    中已经完成：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, we have one more tweak to consider! Since we’ve established that `messages$`
    emits after a 5-second delay following the emission of `recipes$`, there’s a slight
    problem: `combineLatest` only emits once both Observables have emitted values.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还有一个需要考虑的调整！既然我们已经确定`messages$`在`recipes$`发出后的5秒延迟后发出，就有一个小问题：`combineLatest`只在两个Observables都发出值时才发出。
- en: 'To circumvent this brief latency while waiting for `messages$` to emit, in
    `RealTimeService`, we can use the `startWith()` operator on the `messages$` subject
    to supply an initial value of an empty array as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在等待`messages$`发出时绕过这段短暂的延迟，在`RealTimeService`中，我们可以在`messages$`主题上使用`startWith()`运算符来提供一个空数组的初始值，如下所示：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After executing this code, you will notice that 5 seconds after displaying 11
    recipes, the recipe with an ID of `12` (chili chicken) will be added to the list
    on the second page of our cards list. If another recipe is pushed afterward, it
    will be accumulated to the current list of recipes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码后，您会注意到在显示11个菜谱后的5秒内，ID为`12`的菜谱（辣子鸡）将被添加到我们卡片列表的第二页上。如果之后推送另一个菜谱，它将被累积到当前的菜谱列表中。
- en: 'Note that in the case of frequent updates in the UI, it is highly recommended
    to set the change detection strategy to `onPush` in order to optimize the performance,
    like so:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在UI频繁更新的情况下，强烈建议将更改检测策略设置为`onPush`以优化性能，如下所示：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: And that’s it! You will be able to consume live updates in a reactive way using
    this pattern.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！您将能够使用这种模式以响应式的方式消费实时更新。
- en: At this point, you may be wondering how to handle reconnection. When the server
    is restarted or the connection crashes for whatever reason, does this subject
    restore the lost connection under the hood?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能想知道如何处理重新连接。当服务器重启或连接因任何原因崩溃时，这个主题会在幕后恢复丢失的连接吗？
- en: The answer is `WebSocketSubject`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是`WebSocketSubject`。
- en: However, you can implement this easily in your web application using RxJS. Let’s
    learn how you can do this in the next section.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可以使用RxJS轻松地在您的Web应用程序中实现这一点。让我们在下一节中学习您如何做到这一点。
- en: Learning the reactive pattern for handling reconnection
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习处理重新连接的响应式模式
- en: When the connection to the WebSocket server is lost, the channel will be closed,
    and `WebSocketSubjet` will no longer emit values. This is not the expected behavior
    in the world of real time. The reconnection capability is a must in most cases.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当WebSocket服务器的连接丢失时，通道将被关闭，`WebSocketSubjet`将不再发出值。在实时世界的预期行为中，这不是预期的行为。在大多数情况下，重新连接功能是必需的。
- en: Therefore, let’s imagine, for example, that after a disconnection, a system
    tries to reconnect after every 3 seconds. The solution, in this case, is intercepting
    the closure of the socket and retrying the connection. How can we intercept the
    closure of the connection?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们假设，例如，在断开连接后，系统每3秒尝试重新连接一次。在这种情况下，解决方案是拦截socket的关闭并重试连接。我们如何拦截连接的关闭？
- en: 'This is possible thanks to `WebSocketSubjectConfig`, which is responsible for
    customizing some behavior in the socket life cycle. The `WebSocketSubjectConfig`
    interface in RxJS provides several properties that you can use to configure a
    WebSocketSubject. These properties allow you to customize various aspects of WebSocket
    communication:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都要归功于`WebSocketSubjectConfig`，它负责自定义socket生命周期中的某些行为。RxJS中的`WebSocketSubjectConfig`接口提供了几个属性，您可以使用这些属性来配置WebSocketSubject。这些属性允许您自定义WebSocket通信的各个方面：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s explain the different properties available in `WebSocketSubjectConfig`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释`WebSocketSubjectConfig`中可用的不同属性：
- en: '`url`: This property specifies the URL of the WebSocket endpoint to connect
    to (we’ve already explained and and used this in this chapter).'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`：此属性指定要连接的WebSocket端点的URL（我们已经在本章中解释并使用了这个属性）。'
- en: '`protocol`: This property specifies the subprotocol to use during the WebSocket
    handshake (refer to *Figure 12**.1*). It can be a single string or an array of
    strings representing the subprotocols.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protocol`：此属性指定WebSocket握手期间要使用的子协议（参见图12**.1**）。它可以是单个字符串或表示子协议的字符串数组。'
- en: '`resultSelector`: This property specifies a function that takes the WebSocket
    event as input and returns the value to be emitted by `WebSocketSubject`. It’s
    commonly used to extract specific data from WebSocket events; however, it is deprecated
    and will be removed in version 8 of RxJS.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resultSelector`：此属性指定一个函数，该函数接受WebSocket事件作为输入，并返回由`WebSocketSubject`发出的值。它通常用于从WebSocket事件中提取特定数据；然而，它已被弃用，将在RxJS的版本8中删除。'
- en: '`closeObserver`: This property specifies an observer object that listens for
    the WebSocket connection closing. It can be used to handle cleanup tasks or perform
    actions when the connection is closed.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`closeObserver`: 这个属性指定了一个监听WebSocket连接关闭的观察者对象。它可以用来处理清理任务或在连接关闭时执行操作。'
- en: '`openObserver`: This property specifies an observer object that listens for
    the WebSocket connection opening. It can be used to perform actions when the connection
    is successfully established.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openObserver`: 这个属性指定了一个监听WebSocket连接打开的观察者对象。它可以用来在连接成功建立时执行操作。'
- en: '`binaryType`: This property specifies the binary type of WebSocket messages.
    It can be either of the JavaScript types `blob` or `arraybuffer`. By default,
    it’s set to `blob`.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binaryType`: 这个属性指定了WebSocket消息的二进制类型。它可以是JavaScript类型`blob`或`arraybuffer`之一。默认情况下，它设置为`blob`。'
- en: '`serializer`: This property specifies a function used to serialize outgoing
    messages before sending them over the WebSocket connection. It’s commonly used
    to convert objects or complex data structures into strings.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serializer`: 这个属性指定了一个用于在通过WebSocket连接发送之前序列化输出消息的函数。它通常用于将对象或复杂的数据结构转换为字符串。'
- en: '`deserializer`: This property specifies a function used to deserialize incoming
    messages received over the WebSocket connection. It’s commonly used to parse received
    strings back into objects or other data types.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deserializer`: 这个属性指定了一个用于在WebSocket连接上接收到的消息进行反序列化的函数。它通常用于将接收到的字符串解析回对象或其他数据类型。'
- en: These properties provide flexibility and control over WebSocket communication
    in RxJS. You can customize them according to your specific requirements to optimize
    WebSocket interactions in your application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性提供了对RxJS中WebSocket通信的灵活性和控制力。您可以根据具体需求自定义它们，以优化应用程序中的WebSocket交互。
- en: Note
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The full description of each property is available in the official documentation
    link: [http://bit.ly/RxJS-WebSocket](http://bit.ly/RxJS-WebSocket).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 每个属性的完整描述都可以在官方文档链接中找到：[http://bit.ly/RxJS-WebSocket](http://bit.ly/RxJS-WebSocket)。
- en: 'In order to benefit from `WebSocketSubjectConfig`, you should call the `webSocket`
    factory function, which takes the second type of parameter. The following code
    creates `WebSocketSubject` using `WebSocketSubjectConfig` and simply intercepts
    the closure event to display a custom message:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从`WebSocketSubjectConfig`中受益，你应该调用`webSocket`工厂函数，它接受第二种类型的参数。以下代码使用`WebSocketSubjectConfig`创建`WebSocketSubject`，并简单地拦截关闭事件以显示自定义消息：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we know how to intercept the closure of the connection, let’s learn
    how to retry the reconnection. We can combine the `retryWhen` operator that conditionally
    resubscribes to an Observable after it completes using the `delayWhen` operator
    that sets the delay between two consecutive connections.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何拦截连接的关闭，让我们学习如何重试重新连接。我们可以使用`retryWhen`操作符结合`delayWhen`操作符来设置两次连续连接之间的延迟，以在`Observable`完成之后有条件地重新订阅。
- en: 'So, let’s create a function that will retry to connect to a given Observable
    for every configurable `RECONNECT_INTERVAL`; we will log into the browser’s console
    on every attempt at reconnection:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们创建一个函数，该函数将尝试为每个可配置的`RECONNECT_INTERVAL`重新连接到给定的可观察对象；我们将在每次重新连接尝试时在浏览器控制台记录日志：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This `reconnect` function will be used as an RxJS custom operator to handle
    the reconnection after the socket’s closure in the `connect()` method of our `RealTimeService`,
    as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`reconnect`函数将被用作RxJS自定义操作符，在`RealTimeService`的`connect()`方法中处理套接字关闭后的重新连接，如下所示：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, a new Boolean `reconnect` parameter is added to the `connect`
    function to differentiate between the reconnection and the first connection. This
    optimizes the code and avoids adding an additional function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`connect`函数中添加了一个新的布尔参数`reconnect`，用于区分重新连接和第一次连接。这优化了代码，避免了添加额外的函数。
- en: 'Then, all you have to do is call the `connect` function with `reconnect: true`
    when intercepting the connection closure:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，您只需在拦截连接关闭时调用`connect`函数并传递`reconnect: true`即可：'
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this way, after the connection closure, you will see many outgoing requests
    from the client trying to reach the server every 3 seconds.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，在连接关闭后，您将看到客户端每3秒尝试连接服务器的许多输出请求。
- en: The reconnection capability is a must in the world of real time. This is how
    we handled it using RxJS in a few lines of code. Many developers don’t know that
    RxJS offers this feature, which enables you to consume real-time messages coming
    from WebSocket and add many third-party libraries to handle this requirement,
    and it is also available out of the box. So, choosing RxJS, in this case, is one
    less dependency!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在实时世界的世界中，重连能力是必不可少的。这就是我们如何使用RxJS在几行代码中处理它的。许多开发者不知道RxJS提供了这个功能，它使你能够消费来自WebSocket的实时消息，并添加许多第三方库来处理这个需求，而且它也是现成的。因此，在这种情况下选择RxJS，就少了一个依赖！
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into a practical demonstration of consuming real-time
    messages from a WebSocket server in a reactive manner. We first outlined the requirements
    and provided context for the implementation. Subsequently, we explored the capabilities
    of WebSocketSubject and described the step-by-step process, from establishing
    a connection to handling incoming messages from the socket.Next. We applied these
    concepts to a real-world scenario within the recipe app, gaining insights into
    best practices for implementing real-time functionality and ensuring robust connection
    control.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了以响应式方式从WebSocket服务器消费实时消息的实践演示。我们首先概述了需求并提供了实现背景。随后，我们探讨了WebSocketSubject的功能，并详细描述了从建立连接到处理来自套接字的传入消息的逐步过程。接下来，我们将这些概念应用于食谱应用中的实际场景，从而获得了实现实时功能并确保稳健连接控制的最佳实践见解。
- en: Finally, we expanded our understanding by incorporating a reconnection mechanism
    in a reactive way, leveraging the WebSocketSubjectConfig and RxJS operators to
    achieve seamless connection management.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过在响应式方式中引入重连机制，利用WebSocketSubjectConfig和RxJS运算符实现了无缝的连接管理，从而扩展了我们的理解。
- en: Now, as we approach the final chapter of this book, let’s switch gears and focus
    on testing Observables.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着我们接近本书的最后一章，让我们转换思路，专注于测试可观察对象。
- en: 'Part 5: Final Touches'
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5部分：最终润色
- en: In this part, you’ll discover the different strategies to test reactive streams.
    We’ll explore their benefits and when to use each one, reinforcing your learning
    with practical examples.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，你将了解测试响应式流的多种策略。我们将探讨它们的优点以及何时使用每种策略，并通过实际示例巩固你的学习。
- en: 'This part includes the following chapter:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 13*](B21180_13.xhtml#_idTextAnchor191), *Testing RxJS Observables*'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B21180_13.xhtml#_idTextAnchor191)，*测试RxJS可观察对象*'
