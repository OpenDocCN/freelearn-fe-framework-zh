- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Anti-Patterns to Be Avoided
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, you’ve learned how to apply best practices when writing a React
    application. In the first few chapters, we revisited the basic concepts to build
    a solid understanding, and then we took a leap into more advanced techniques in
    the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be able to build reusable components, make components communicate
    with each other, and optimize an application tree to get the best performance.
    However, developers make mistakes, and this chapter is all about the common anti-patterns
    we should avoid when using React.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at common errors will help you to avoid them and will aid your understanding
    of how React works and how to build applications in the React way. For each problem,
    we will see an example that shows how to reproduce and solve it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the state using properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using indexes as a key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spreading properties on DOM elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js 19+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter in the book’s GitHub repository: [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter07).'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the state using properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how initializing the state using properties received
    from the parent is usually an anti-pattern. I have used the word *usually* because,
    as we will see, once we have it clear in our mind what the problems with this
    approach are, we might still decide to use it.
  prefs: []
  type: TYPE_NORMAL
- en: One of the best ways to learn something is by looking at the code, so we will
    start by creating a simple component with a + button to increment a counter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a functional component named `Counter`, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s set our `count` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the click handler is straightforward – we just add `1`
    to the current `count` value and store the resulting value back in the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we render and describe the output, which is composed of the current
    value of the `count` state and the button to increment it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s render this component, passing `1` as the `count` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It works as expected – each click on the `+` button increments the current value.
    So, what’s the problem?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main errors, which are outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We have a duplicated source of truth.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `count` property passed to the component changes, the state does not
    get updated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we inspect the `Counter` element using the React DevTools, we notice that
    `Props` and `State` hold a similar value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This makes it unclear which is the current and trustworthy value to use inside
    the component and to display to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even worse, clicking `+` once makes the values diverge. An example of this
    divergence is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we can assume that the second value represents the current count,
    but this is not explicit and can lead to unexpected behaviors or wrong values
    down in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: The second problem centers on how the class is created and instantiated by React.
    The `useState` function of the component gets called only once when the component
    is created.
  prefs: []
  type: TYPE_NORMAL
- en: In our `Counter` component, we read the value of the `count` property and we
    store it in the state. If the value of that property changes during the life cycle
    of the application (let’s say it becomes 10), the `Counter` component will never
    use the new value because it has already been initialized. This puts the component
    in an inconsistent state, which is not optimal and hard to debug.
  prefs: []
  type: TYPE_NORMAL
- en: What if we really want to use the prop’s value to initialize the component,
    and we know for sure that the value does not change in the future?
  prefs: []
  type: TYPE_NORMAL
- en: 'In that case, it’s best practice to make it explicit and give the property
    a name that makes your intentions clear, such as `initialCount`. For example,
    let’s say we change the prop declaration of the `Counter` component in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This usage makes it clear that the parent can only initialize the counter,
    and any subsequent values of the `initialCount` property will be disregarded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we are going to delve into the concept of keys.
  prefs: []
  type: TYPE_NORMAL
- en: Using indexes as a key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 15*, *Improving the Performance of Your Applications*, which talks
    about performance and the reconciler, we saw how we can help React figure out
    the shortest path to update the DOM by using the `key` prop.
  prefs: []
  type: TYPE_NORMAL
- en: The `key` property uniquely identifies an element in the DOM and React uses
    it to check whether the element is new or whether it must be updated when the
    component properties or state change.
  prefs: []
  type: TYPE_NORMAL
- en: Using keys is always a good idea and if you don’t do it, React gives a warning
    in the console (in development mode). However, it is not simply a matter of using
    a key; sometimes, the value that we decide to use as a key can make a difference.
    In fact, using the wrong key can give us unexpected behaviors in some instances.
    In this section, we will see one of those instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s again create a `List` component, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we define our state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the click handler is slightly different from the previous
    one because, in this case, we need to insert a new item at the top of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the render, we show the list and the `+` button to add the `baz`
    item at the top of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you run the component inside the browser, you will not see any problems;
    clicking the `+` button inserts a new item at the top of the list. But let’s do
    an experiment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change the render in the following way, adding an input field near each
    item. We then use an input field because we can edit its content, making it easier
    to figure out the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If we run this component again in the browser, copy the values of the items
    in the input fields, and then click *+*, we will get unexpected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following screenshot, the items shift down while the input
    elements remain in the same position in such a way that their value does not match
    the value of the items anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B18414_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Using indexes as a key'
  prefs: []
  type: TYPE_NORMAL
- en: Running the component, clicking **+**, and checking the console should give
    us all the answers we need.
  prefs: []
  type: TYPE_NORMAL
- en: What we can see is that instead of inserting the new element at the top, React
    swaps the text of the two existing elements, and inserts the last item at the
    bottom as if it was new. The reason it does that is that we are using the index
    of the map function as the key.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the index always starts from `0`, even if we push a new item to the
    top of the list, so React thinks that we changed the values of the existing two
    and added a new element at index `2`. The behavior is the same as it would have
    been without using the `key` property at all.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very common pattern because we may think that providing any key is
    always the best solution, but it is not like that at all. The key must be unique
    and stable, identifying one, and only one, item.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, we can, for example, use the value of the item if we
    expect it not to be repeated within the list, or create a unique identifier, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have understood the importance of unique and stable keys in React
    and explored practical solutions to address this common issue, let’s shift our
    attention to another prevalent practice in React development. The upcoming section
    will focus on the spreading of properties on DOM elements, a technique that has
    recently been labeled as an anti-pattern by Dan Abramov.
  prefs: []
  type: TYPE_NORMAL
- en: Spreading properties on DOM elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a common practice that has recently been described as an anti-pattern
    by Dan Abramov; it also triggers a warning in the console when you do it in your
    React application.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a technique that is widely used in the community, and I have personally
    seen it multiple times in real-world projects. We usually spread the properties
    to the elements to avoid writing every single one manually, which is shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This works very well, and it gets transpiled into the following code by Babel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: However, when we spread properties into a DOM element, we run the risk of adding
    unknown HTML attributes, which is bad practice.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is not related only to the `Spread` operator; passing non-standard
    properties one by one leads to the same issues and warnings. Since the `Spread`
    operator hides the single properties we are spreading, it is even harder to figure
    out what we are passing to the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the warning in the console, a basic operation we can do is render the
    following component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The message we get looks like the following because the `foo` property is not
    valid for a `div` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, as we said, it is easy to figure out which attribute we are passing
    and remove it, but if we use the `Spread` operator, as in the following example,
    we cannot control which properties are passed from the parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use the component in the following way, there are no issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This, however, is not the case if we do something such as the following. React
    complains because we are applying a non-standard attribute to the DOM element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: One solution we can use to solve this problem is to create a property called
    `domProps` that we can spread safely to the component because we are explicitly
    saying that it contains valid DOM properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can change the `Spread` component in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As we have seen many times with React, it’s always good practice to be explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowing all the best practices is always a good thing, but sometimes, being
    aware of anti-patterns helps us avoid taking the wrong path. Most importantly,
    learning the reasons why some techniques are considered bad practice helps us
    understand how React works, and how we can use it effectively.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered four different ways of using components that can
    harm the performance and behavior of our web applications.
  prefs: []
  type: TYPE_NORMAL
- en: For each one of those, we used an example to reproduce the problem and supplied
    the changes to apply in order to fix the issue.
  prefs: []
  type: TYPE_NORMAL
- en: We learned why using properties to initialize the state can result in inconsistencies
    between the state and the properties. We also saw how using the wrong `key` attribute
    can produce bad effects on the reconciliation algorithm. Finally, we learned why
    spreading non-standard properties to DOM elements is considered an anti-pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look into the new React Hooks.
  prefs: []
  type: TYPE_NORMAL
