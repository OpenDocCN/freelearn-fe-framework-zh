- en: Ready, Set, Go!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备，设置，出发！
- en: In this chapter, we will start building our task management application. We'll
    jump right into the core of the application and create the initial components
    required to manage a simple task list.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始构建我们的任务管理应用程序。我们将直接进入应用程序的核心，并创建管理简单任务列表所需的初始组件。
- en: 'In the process of going through this chapter, you''ll learn about the following
    topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章的过程中，你将了解以下主题：
- en: Introduction to `NgModule`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NgModule` 简介'
- en: Bootstrapping an Angular application using a main module
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用主模块引导 Angular 应用程序
- en: Component input and output
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件输入和输出
- en: Host property binding
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主属性绑定
- en: Styling and view encapsulation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式和视图封装
- en: Using `EventEmitter` to emit custom events
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `EventEmitter` 发射自定义事件
- en: Component life cycle
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件生命周期
- en: Managing tasks
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理任务
- en: After picking up the basics from the previous chapter, we will now go on and
    create a task management application together in the upcoming chapters. You'll
    learn about some concepts during these chapters and then use them with practical
    examples. You'll also learn how to structure an application using components.
    This begins with the folder structure and ends with setting up the interaction
    between components.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在从上一章掌握基础知识之后，我们现在将继续在接下来的章节中一起创建一个任务管理应用程序。在这些章节中，你将学习一些概念，然后通过实际示例来使用它们。你还将学习如何使用组件来构建应用程序。这从文件夹结构开始，以设置组件之间的交互结束。
- en: Vision
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视觉
- en: 'The task management application, which we''re going to create during the course
    of this book, should enable users to manage tasks easily and help them organize
    small projects. Usability is the central aspect of any application; therefore,
    you''ll need to design a modern and flexible user interface that will support
    the users managing their tasks:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们将要创建的任务管理应用程序应使用户能够轻松地管理任务，并帮助他们组织小型项目。可用性是任何应用程序的核心方面；因此，你需要设计一个现代且灵活的用户界面，以支持用户管理他们的任务：
- en: '![](img/bfbc15e1-5f86-4f48-9c80-2ccf9f0c5e12.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bfbc15e1-5f86-4f48-9c80-2ccf9f0c5e12.png)'
- en: A preview of the task management application we are going to build
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的任务管理应用程序预览
- en: 'Our task management application will consist of components that will allow
    us to design a platform, providing a great user experience for the purpose of
    managing tasks. Let''s define the core features of our application:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务管理应用程序将包含组件，使我们能够设计一个平台，为管理任务提供良好的用户体验。让我们定义我们应用程序的核心功能：
- en: Managing tasks within multiple projects and providing a project overview
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个项目中管理任务并提供项目概览
- en: Simple scheduling as well as a time-and-effort-tracking mechanism
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的排程以及时间和努力跟踪机制
- en: Overviewing the DASHBOARD using graphical charts
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图形图表概述 DASHBOARD
- en: Tracking activities and providing a visual audit log
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪活动并提供可视审计日志
- en: A simple commenting system that will work across different components
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将在不同组件间工作的简单评论系统
- en: The task management application is the main example in this book. Therefore,
    the building blocks within this book should only contain the code that is relevant
    to the theme of this book. Of course, other than components, an application needs
    other functionalities, such as visual design, data, session management, and other
    important parts, to work. While the required code for each chapter can be downloaded
    online, we'll only discuss the code that is relevant to the topics that we will
    be learning about in this book.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 任务管理应用程序是本书的主要示例。因此，本书中的构建块应仅包含与本书主题相关的代码。当然，除了组件之外，应用程序还需要其他功能，如视觉设计、数据、会话管理和其他重要部分，才能运行。虽然每章所需的代码都可以在线下载，但我们只讨论与本书将要学习的话题相关的代码。
- en: Starting from scratch
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从零开始
- en: 'Let''s start out by creating a new Angular project using the Angular CLI. We''ll
    name it `mastering-angular-components`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用 Angular CLI 创建一个新的 Angular 项目开始。我们将将其命名为 `mastering-angular-components`：
- en: 'Open a console window and navigate to a proper workspace for our project. Let''s
    use the Angular CLI to create our initial project structure:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台窗口并导航到我们的项目适当的工作空间。让我们使用 Angular CLI 来创建我们的初始项目结构：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After the project has been successfully created, let''s move into the project
    folder and start serving using the `ng serve` command:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目成功创建后，让我们进入项目文件夹，并使用 `ng serve` 命令开始提供服务：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After following the preceding steps, you should be able to open up your browser
    and point it to `http://localhost:4200`. You should be able to see the generated
    application app with a welcome message saying Welcome to mac!.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成前面的步骤后，您应该能够打开浏览器并将它指向 `http://localhost:4200`。您应该能够看到生成的应用程序 app，并显示欢迎信息：欢迎使用
    mac!。
- en: It's recommended that you leave the serving mode of the CLI running all the
    time while in development. Since the underlying webpack will use caching when
    recompiling the output bundles, it will speed up your development process quite
    a lot. I recommend that you always have a second command-line window open and
    start Angular CLI in serve mode there.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 开发过程中，建议您始终运行 CLI 的服务模式。由于底层 webpack 在重新编译输出包时会使用缓存，这将大大加快您的开发过程。我建议您始终打开一个第二个命令行窗口，并在其中启动
    Angular CLI 的服务模式。
- en: 'Let''s examine what the Angular CLI tool has created for us so far. Along with
    a lot of files that we''ll cover in later chapters, the Angular CLI tool has created
    the core files that are needed in order to assemble a simple Angular application.
    The following directory listing shows all the critical files, which you''ll also
    find within your generated project folder:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 Angular CLI 工具为我们创建的内容。除了将在后续章节中介绍的大量文件外，Angular CLI 工具还创建了组装简单 Angular
    应用程序所需的核心文件。以下目录列表显示了所有关键文件，您也将在生成的项目文件夹中找到这些文件：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s take a quick look at these dependencies, development dependencies, and
    their purpose:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看这些依赖项、开发依赖项及其用途：
- en: '| **File(s)** | **Description** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **文件** | **描述** |'
- en: '| `package.json` `node_modules` | Since the Angular CLI uses Node.js for tooling,
    our project contains a `package.json` to store all required dependencies and their
    versions. Node dependencies get installed within the `node_modules` folder.If
    you want to check which version of Angular has been installed along with your
    project, you can check the dependencies within the `package.json` file. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `package.json` `node_modules` | 由于 Angular CLI 使用 Node.js 作为工具，因此我们的项目包含一个
    `package.json` 文件来存储所有必需的依赖项及其版本。Node 依赖项安装在 `node_modules` 文件夹中。如果您想检查与您的项目一起安装的
    Angular 版本，可以检查 `package.json` 文件中的依赖项。 |'
- en: '| `src/index.html` | The main HTML file of your project. Within this file,
    you''ll find the host element of your root component. This is the place where
    you root or main component will be rendered. Just open the file and you''ll notice
    an element called `<mac-root>`. Since we''ve specified the prefix `mac` when creating
    our project using the Angular CLI, all our components and therefore all our component
    host elements contain this prefix. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `src/index.html` | 这是您项目的主体 HTML 文件。在此文件中，您将找到根组件的主元素。这是您根或主要组件将被渲染的地方。只需打开文件，您就会注意到一个名为
    `<mac-root>` 的元素。由于我们使用 Angular CLI 创建项目时指定了前缀 `mac`，因此我们所有的组件以及所有组件的主元素都包含此前缀。
    |'
- en: '| `src/main.ts` | This is the main entry file of our TypeScript project code.
    It contains all the necessary code to start Angular and bootstrap our main application
    module. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `src/main.ts` | 这是我们的 TypeScript 项目代码的主要入口文件。它包含启动 Angular 和引导主应用程序模块所需的所有必要代码。
    |'
- en: '| `src/styles.css` | Any global CSS styles we''d like to apply to our application
    website go here. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `src/styles.css` | 我们希望应用到我们的应用程序网站上的任何全局 CSS 样式都放在这里。 |'
- en: '| `src/app/app.module.ts` | The main `NgModule` of your Angular project. This
    module is bootstrapped when your application is starting up. It contains references
    to your project components and specifies your main entry component, which should
    be rendered at startup. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `src/app/app.module.ts` | 这是您的 Angular 项目的主体 `NgModule`。当您的应用程序启动时，会引导此模块。它包含对您的项目组件的引用，并指定了启动时应渲染的主要入口组件。
    |'
- en: '| `src/app/app.component.ts` `src/app/app.component.html` `src/app/app.component.css`  |
    The main component of your Angular application. This component represents the
    outermost component, sometimes just called app or root component. The TypeScript,
    HTML, and CSS code is separated into different files by default. This can also
    be changed so that everything is embedded within the TypeScript file. However,
    following a good separation practice, it makes absolute sense to have all concerns
    about the component in individual files. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `src/app/app.component.ts` `src/app/app.component.html` `src/app/app.component.css`  |
    这是您的 Angular 应用程序的主要组件。该组件代表最外层的组件，有时也称为 app 或根组件。TypeScript、HTML 和 CSS 代码默认被分隔到不同的文件中。这也可以更改，以便所有内容都嵌入到
    TypeScript 文件中。然而，遵循良好的分离实践，将所有关于组件的关注点放在单独的文件中是完全有意义的。 |'
- en: Main application component
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要应用程序组件
- en: Let's take a look at our main application component. You can think of it as
    the outermost component of your application. It's called the main component because
    it represents your whole application. This is where your component tree has its
    roots and therefore it's sometimes also called the root component.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的主要应用程序组件。你可以将其视为应用程序的最外层组件。它被称为主要组件，因为它代表了整个应用程序。这是组件树的根本所在，因此有时也被称为根组件。
- en: 'First, let''s look at the component TypeScript file located in `src/app/app.component.ts`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看位于 `src/app/app.component.ts` 的组件 TypeScript 文件：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There's nothing different here from what we already know about structuring a
    component, something that we learned in the previous chapter. However, there are
    two main differences here compared to how we created the components before. Instead
    of using the `template` property to write our HTML template inline, we're using
    the `templateUrl` property to tell Angular to load the HTML from the specified
    file. The second thing which we've not covered yet is how to load CSS for your
    component. The `styleUrls` property allows us to specify an array of URLs which
    get resolved to assemble the styles of our component. Similar to the HTML template
    mechanism, we could also use a property called `styles` to write our styles inline
    within the component TypeScript file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里与我们之前在上一章中学到的组件结构化方法没有太大区别。然而，与之前创建组件的方式相比，这里有两个主要的不同点。我们不再使用 `template` 属性来内联编写我们的
    HTML 模板，而是使用 `templateUrl` 属性告诉 Angular 从指定的文件加载 HTML。第二件事是我们还没有涉及到的，那就是如何为组件加载
    CSS。`styleUrls` 属性允许我们指定一个 URL 数组，这些 URL 被解析以组装组件的样式。类似于 HTML 模板机制，我们也可以使用一个名为
    `styles` 的属性，在组件 TypeScript 文件内内联编写我们的样式。
- en: For our application, we'd like to change the behaviour slightly on how we handle
    styling. The default way of organizing styles when creating components is that
    each component contains its own encapsulated styles. However, for our project,
    we want to use the global `styles.css` file to add all our component styles. This
    will make it much easier to work with the books source repository and eliminates
    the need to include CSS code excerpts within this book.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们希望稍微改变我们处理样式的行为。创建组件时组织样式的默认方式是每个组件包含其自己的封装样式。然而，对于我们的项目，我们希望使用全局的
    `styles.css` 文件来添加所有组件的样式。这将使与书籍源代码库一起工作变得更加容易，并消除了在本书中包含 CSS 代码片段的需要。
- en: By default, Angular uses a Shadow DOM emulation on our components, which is
    preventing styles within a component to leak outside and influence other components.
    However, this behaviour can be changed easily by configuring the view encapsulation
    on components.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Angular 在我们的组件上使用阴影 DOM 模拟，这阻止了组件内的样式泄漏到外部并影响其他组件。然而，这种行为可以通过配置组件的视图封装来轻松更改。
- en: 'Angular has three ways to handle view encapsulation and each way has its own
    pros and cons. Let''s look at the different settings:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 有三种处理视图封装的方法，每种方法都有其优缺点。让我们看看不同的设置：
- en: '| **Encapsulation type** | **Description** |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **封装类型** | **描述** |'
- en: '| `ViewEncapsulation.Emulated` | If a component is set to emulated view encapsulation,
    it will emulate style encapsulation by attaching the generated attributes to the
    component element and modifying CSS selectors to include these attribute selectors.
    This will enable certain forms of encapsulation, although the outer styles can
    still leak into the component if there are other global styles.This view encapsulation
    mode is the default mode, if not specified otherwise. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `ViewEncapsulation.Emulated` | 如果组件设置为模拟视图封装，它将通过将生成的属性附加到组件元素并修改 CSS 选择器以包含这些属性选择器来模拟样式封装。这将启用某些形式的封装，尽管如果存在其他全局样式，外部样式仍然可能泄漏到组件中。这种视图封装模式是默认模式，除非有其他指定。
    |'
- en: '| `ViewEncapsulation.Native` | Native view encapsulation is supposed to be
    the ultimate goal of the view encapsulation concept within Angular. It makes use
    of Shadow DOM, as described in the previous chapter, to create an isolated DOM
    for the whole component. This mode depends on the browser to support Shadow DOM
    natively, and therefore, can''t always be used. It''s also important to note that
    global styles will no longer be respected and local styles need to be placed within
    the component in inline style tags (or use the `styles` property on the component
    annotation). |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `ViewEncapsulation.Native` | 原生视图封装应该是 Angular 中视图封装概念的最终目标。它使用上一章中描述的 Shadow
    DOM 来为整个组件创建一个隔离的 DOM。此模式依赖于浏览器原生支持 Shadow DOM，因此并不总是可以使用。还重要的是要注意，全局样式将不再被尊重，并且局部样式需要放置在组件的行内样式标签中（或使用组件注解上的
    `styles` 属性）。|'
- en: '| `ViewEncapsulation.None` | This mode tells Angular not to provide any template
    or style encapsulation. Within our application, we rely on styles coming from
    a global CSS; therefore, we use this mode for most of the components. Neither
    Shadow DOM, nor attributes will be used to create style encapsulation; we can
    simply use the classes specified within our global CSS file. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `ViewEncapsulation.None` | 此模式告诉 Angular 不提供任何模板或样式封装。在我们的应用程序中，我们依赖于来自全局
    CSS 的样式；因此，我们为大多数组件使用此模式。既不使用 Shadow DOM，也不使用属性来创建样式封装；我们只需简单地使用全局 CSS 文件中指定的类即可。|'
- en: 'Let''s change the view encapsulation of our main component to use the `ViewEncapsulation.None`
    mode. Since we''re going to put all our styles in the global `src/styles.css`
    file, we can also remove the `styleUrls` property from our component configuration
    completely:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改主组件的视图封装模式，使用 `ViewEncapsulation.None` 模式。由于我们将所有样式放入全局的 `src/styles.css`
    文件中，我们也可以完全从组件配置中移除 `styleUrls` 属性：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Resource download
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源下载
- en: The goal of the first few chapters of this book is to build our application
    from scratch. There's some code which is necessary to build an application, which
    does not exactly meet the topic of this book, to master the creation of a solid
    component architecture. One of those things is CSS styling. Although an integral
    part of everything built with web technology, it's definitely not something to
    be bothered too much by in this book.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 本书前几章的目标是从零开始构建我们的应用程序。有一些构建应用程序所需的代码，这些代码并不完全符合本书的主题，但为了掌握创建稳固的组件架构，它们是必要的。其中之一就是
    CSS 样式。尽管它是使用网络技术构建的一切的组成部分，但在这本书中，它绝对不是需要过多关注的东西。
- en: For this purpose, I've prepared all the CSS styling which is used within the
    components created throughout this book. Before you continue working on your application,
    you should download these styles and apply them to your project. Please find the
    exact download link in the download section of Chapter 11, *Task Management Application
    Source Code*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我已经准备了本书中创建的所有组件所使用的所有 CSS 样式。在你继续工作于你的应用程序之前，你应该下载这些样式并将它们应用到你的项目中。请在第
    11 章 *任务管理应用程序源代码* 的下载部分找到确切的下载链接。
- en: Place the downloaded StyleSheet into the `src` folder of your project where
    it will replace the existing `styles.css` file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将下载的 StyleSheet 放入项目的 `src` 文件夹中，它将替换现有的 `styles.css` 文件。
- en: Main application NgModule
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要应用 NgModule
- en: 'Let''s also take a look at the main `NgModule` generated by the Angular CLI.
    You can find it in the path `src/app/app.module.ts`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看由 Angular CLI 生成的主 `NgModule`。你可以在路径 `src/app/app.module.ts` 中找到它：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you've been following the section *Angular NgModule*, about `NgModule` within
    the first chapter of this book, there should not be any surprises when looking
    at our generated main application module.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在关注本书第一章中关于 *Angular NgModule* 的部分，那么在查看我们生成的主应用程序模块时，不应该有任何惊喜。
- en: Our application currently only consists of one component, the `AppComponent`,
    which we're declaring within our `AppModule`. We also specify that this component
    should be bootstrapped when this module is being bootstrapped.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用目前仅包含一个组件，即 `AppComponent`，我们在 `AppModule` 中声明了这个组件。我们还指定当此模块正在启动时，应该启动此组件。
- en: Bootstrapping
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动
- en: The starting point of our project is located within the `src/main.ts` file.
    This file is responsible for bootstrapping the Angular framework and starting
    our applications main module.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的起点位于 `src/main.ts` 文件中。此文件负责启动 Angular 框架并启动我们的应用程序主模块。
- en: We can go ahead and bootstrap our Angular application by providing our main
    application module, `AppModule`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续启动我们的 Angular 应用程序，提供我们的主应用程序模块 `AppModule`。
- en: 'In order to bootstrap an Angular module, we first need to create a platform.
    There are many ways for different platforms and environments to create a platform.
    If you''d like to create a browser platform, which is the default platform for
    browser environments, we need to import the platform factory function `platformBrowserDynamic`
    from the `@angular/platform-browser-dynamic` module. Simply by calling the platform
    factory function, we will receive an instance of the newly created platform. On
    the platform instance, we can then call the `bootstrapModule` function, passing
    our main application module as a parameter:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动一个 Angular 模块，我们首先需要创建一个平台。对于不同的平台和环境，有许多创建平台的方法。如果你想要创建一个浏览器平台，这是浏览器环境的默认平台，我们需要从
    `@angular/platform-browser-dynamic` 模块导入平台工厂函数 `platformBrowserDynamic`。只需调用平台工厂函数，我们就会收到一个新创建的平台实例。在平台实例上，我们可以调用
    `bootstrapModule` 函数，将我们的主应用程序模块作为参数传递：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s take a closer look at the steps involved in the bootstrapping mechanism
    of Angular. We should try to understand how our root component is getting rendered
    in the right place by calling the `bootstrapModule` function on the platform instance:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看 Angular 启动机制中涉及的步骤。我们应该尝试理解通过在平台实例上调用 `bootstrapModule` 函数，我们的根组件是如何被渲染到正确位置的：
- en: First, we call the `bootstrapModule` function on our platform instance, passing
    our main application module as a parameter
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在我们的平台实例上调用 `bootstrapModule` 函数，将我们的主应用程序模块作为参数传递
- en: Angular will examine our main application module metadata and find the `AppComponent`
    listed in the `bootstrap` property of the `NgModule` configuration
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Angular 将检查我们的主应用程序模块元数据，并在 `NgModule` 配置的 `bootstrap` 属性中找到列出的 `AppComponent`
- en: By evaluating the metadata on the `AppComponent`, looking at the `selector`
    property, Angular will know where to render our root component
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过评估 `AppComponent` 上的元数据，查看 `selector` 属性，Angular 将知道在哪里渲染我们的根组件
- en: The `AppComponent` is rendered as our root component into the host element found
    within the `index.html` file matching the CSS selector in the `selector` property
    on the component metadata
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AppComponent` 被渲染为我们的根组件，位于 `index.html` 文件中，与组件元数据中 `selector` 属性匹配的宿主元素'
- en: Running the application
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'To make sure our modifications to the main component, `AppComponent`, are working
    as expected and we didn''t break anything, let''s start our application using
    the Angular CLI. Open a command line and point it to your project directory. Then,
    start the CLI in serve mode:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们对主组件 `AppComponent` 的修改按预期工作，并且我们没有破坏任何东西，让我们使用 Angular CLI 启动我们的应用程序。打开命令行，将其指向你的项目目录。然后，以服务模式启动
    CLI：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If everything goes well, you will have an open web browser that shows Welcome
    to mac!.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你将拥有一个显示“欢迎使用mac!”的打开网页浏览器。
- en: Recap
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾
- en: 'Let''s recap what we have done so far:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下到目前为止我们已经做了什么：
- en: We initialized a new project using Angular CLI
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 Angular CLI 初始化了一个新项目
- en: We modified our main application component in `src/app/app.component.ts` to
    include `ViewEncapsulation.None` for enabling global styles
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们修改了 `src/app/app.component.ts` 中的主应用程序组件，以包含 `ViewEncapsulation.None` 以启用全局样式
- en: We've looked at the generated `MainModule` as well as the bootstrapping happening
    within our main entry file `src/main.ts`
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经查看了生成的 `MainModule` 以及我们主入口文件 `src/main.ts` 中的启动过程
- en: Finally, we used the Angular CLI to start our application
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用 Angular CLI 启动了我们的应用程序
- en: Creating a task list
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建任务列表
- en: Now that we have our main application component set up, we can go on and start
    fleshing out our task management application. The second component that we're
    going to create will be responsible for listing tasks. Following the concept of
    composition, we'll create a task list component as a subcomponent of our main
    application component.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了主应用程序组件，我们可以继续完善我们的任务管理应用程序。我们将要创建的第二个组件将负责列出任务。遵循组合的概念，我们将创建一个任务列表组件作为主应用程序组件的子组件。
- en: 'Let''s create a new component for our task list by using the Angular CLI generator
    functionality. We already want to structure our application by area, where we
    put all task-relevant components into a `tasks` subfolder:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Angular CLI 生成器功能创建一个新的任务列表组件。我们希望按区域结构化我们的应用程序，将所有与任务相关的组件放入一个 `tasks`
    子文件夹中：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using the `--spec false` option while generating our component, we can skip
    creating test specifications. Since we're going to cover testing in a later chapter,
    we're skipping this process for the moment. Also, by using the `-ve none` parameter,
    we can tell Angular to create the component using `ViewEncapsulation.None` as
    a default encapsulation setting.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成我们的组件时使用`--spec false`选项，我们可以跳过创建测试规范。由于我们将在后面的章节中介绍测试，所以我们目前跳过这个步骤。此外，通过使用`-ve
    none`参数，我们可以告诉Angular使用`ViewEncapsulation.None`作为默认的封装设置来创建组件。
- en: If you're using the Angular CLI tool to generate components, they will be automatically
    added to your main module. This is really handy and offloads a lot of boilerplate
    work on your side. If you're creating a component manually, you should never forget
    to include the newly created component within your `NgModule` declarations.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Angular CLI工具来生成组件，它们将自动添加到你的主模块中。这非常方便，可以为你节省大量的样板工作。如果你是手动创建组件，你永远不应该忘记在你的`NgModule`声明中包含新创建的组件。
- en: 'Let''s open the generated file `src/app/tasks/task-list.ts` and do some modifications
    to it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开生成的文件`src/app/tasks/task-list.ts`并对其进行一些修改：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We've created a very simple task list component that has a list of tasks stored
    internally. This component will be attached to HTML elements that match the CSS
    element selector `mac-task-list`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个非常简单的任务列表组件，它内部存储了一个任务列表。这个组件将被附加到匹配CSS元素选择器`mac-task-list`的HTML元素上。
- en: Now, let's create a view template for this component to display the tasks. As
    you can see from the `templateUrl` property within the component metadata, we
    are looking for a file called `task-list.component.html`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为这个组件创建一个视图模板来显示任务。如你所见，从组件元数据中的`templateUrl`属性，我们正在寻找一个名为`task-list.component.html`的文件。
- en: 'Let''s change the content of this file to match the following excerpt:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改这个文件的内容，以匹配以下摘录：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We use the `NgFor` directive to repeat the outermost DIV element for as many
    tasks as we have on the task list of our component. The `NgFor` directive in Angular
    will create a template element from its underlying content and instantiate as
    many elements from the template as the expression evaluates to. We currently have
    two tasks in our task list component, so this will create two instances of our
    template.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`NgFor`指令重复最外层的DIV元素，以匹配我们组件任务列表中的任务数量。Angular中的`NgFor`指令将从其底层内容创建一个模板元素，并根据表达式评估的结果实例化模板中的元素。我们目前在任务列表组件中有两个任务，所以这将创建我们模板的两个实例。
- en: 'All that''s left to do in order to make our task list work is include the task
    list component within the main application component. We can go ahead and modify
    our `src/app/app.component.html` file and change its content to match the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的任务列表工作，我们剩下的工作就是在主应用程序组件中包含任务列表组件。我们可以继续修改我们的`src/app/app.component.html`文件，并将其内容更改为以下内容：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This was the last change we needed to make in order to make our task list component
    work. To view your changes, you can start the serving mode of Angular CLI, if
    you don't have it running already.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们为了让任务列表组件工作而需要做的最后一个更改。要查看你的更改，你可以启动Angular CLI的服务模式，如果你还没有运行它的话。
- en: Recap
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'Let''s look at what we did in the previous building block. We achieved a simple
    listing of tasks within an encapsulated component by following these steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在之前的构建块中我们做了什么。通过遵循以下步骤，我们实现了在封装组件内对任务的简单列表：
- en: We created the component TypeScript file that contains the logic of our component
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了包含组件逻辑的组件TypeScript文件
- en: We created the component's view within a separate HTML file
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在单独的HTML文件中创建了组件的视图
- en: We included the component HTML element within our main application view template
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将组件的HTML元素包含在我们的主应用程序视图模板中
- en: The right size of components
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件的正确大小
- en: Our task list is displayed correctly and the code we used to achieve this looks
    quite okay. However, if we want to follow a better approach for composition, we
    should rethink the design of our task list component. If we draw a line at enlisting
    the task list's responsibilities, we would come up with things such as listing
    tasks, adding new tasks to the list, sorting or filtering the task list; however,
    operations are not performed on an individual task itself. Also, rendering the
    task itself falls outside of the responsibilities of the task list. The task list
    component should only serve as a container for tasks.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务列表显示正确，我们用来实现这一点的代码看起来相当不错。然而，如果我们想遵循更好的组合方法，我们应该重新思考任务列表组件的设计。如果我们划一条线来列举任务列表的责任，我们会得到诸如列出任务、向列表添加新任务、对任务列表进行排序或过滤等事情；然而，操作并不是在单个任务本身上执行的。此外，渲染任务本身超出了任务列表的责任范围。任务列表组件应该只作为任务的容器。
- en: If we look at our code again, we will see that we're violating the single responsibility
    principle and rendered the whole task body within our task list component. Let's
    take a look at how we can fix this by increasing the granularity of our components.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次查看我们的代码，我们会发现我们违反了单一职责原则，在任务列表组件中渲染了整个任务体。让我们看看我们如何通过增加组件的粒度来修复这个问题。
- en: The goal now is to do a code refactoring exercise, also known as extraction.
    We are pulling our task's relevant template out of the task list template and
    creating a new component that encapsulates the tasks.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 目前的目标是进行代码重构练习，也称为提取。我们将任务的相关模板从任务列表模板中提取出来，并创建一个新的组件来封装任务。
- en: 'Let''s use the Angular CLI to create a new task component. Open a command line
    and enter the root folder of our application. Execute the necessary code to create
    the task component:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Angular CLI创建一个新的任务组件。打开命令行并进入我们应用程序的根目录。执行必要的代码来创建任务组件：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will generate a new folder which includes all the code for our new task
    component. Now, let''s open the HTML template on the path `src/app/tasks/task/task.component.html`
    and change the content to represent a single task:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个新的文件夹，其中包含我们新任务组件的所有代码。现在，让我们打开位于路径`src/app/tasks/task/task.component.html`的HTML模板，并将其内容更改为表示单个任务：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The content of our new `task.component.html` file is pretty much the same as
    what we already have within our task list component. However, within the newly
    created task component, we're only concerned about what a task looks like and
    not about the whole list of tasks.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的`task.component.html`文件的内容基本上与我们任务列表组件中已有的内容相同。然而，在新建的任务组件中，我们只关心任务的外观，而不是整个任务列表。
- en: 'Let''s change the task component TypeScript file located on the path `src/app/tasks/task/task.component.ts`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改位于路径`src/app/tasks/task/task.component.ts`的任务组件TypeScript文件：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the previous chapter of this book, we spoke about encapsulation and the preconditions
    to establish a clean encapsulation for UI components. One of these preconditions
    is the possibility to design proper interfaces in and out of the component. Such
    input and output methods are necessary to make the component work within compositions.
    That's how a component will receive and publish information.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前一章中，我们讨论了封装和为UI组件建立干净封装的先决条件。这些先决条件之一是能够在组件内外设计适当的接口。这些输入和输出方法是使组件在组合中工作所必需的。这就是组件如何接收和发布信息的方式。
- en: As you can see from our task component implementation, we are now building such
    an interface using the `@Input` decorator on a class instance property. In order
    to use this decorator, we will first need to import it from the angular core module.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从我们的任务组件实现中看到的，我们现在正在使用类实例属性上的`@Input`装饰器来构建这样的接口。为了使用这个装饰器，我们首先需要从angular核心模块中导入它。
- en: Input properties in Angular allow us to bind expressions in our templates to
    class instance properties on our components. This way, we can pass data from the
    outside of the component to the component inside, using the component's template.
    This can be thought of as an example of one-way binding, from the view of a parent
    component to the child component instance.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Angular中的输入属性允许我们将模板中的表达式绑定到组件的类实例属性上。这样，我们可以通过组件的模板从组件外部传递数据到组件内部。这可以被视为单向绑定的一个例子，即从父组件视图到子组件实例的绑定。
- en: 'If we''re using property binding on a regular DOM property, Angular will create
    a binding of the expression directly to the element''s DOM property. We''re using
    such a type of binding to bind the task completed flag to the `checked` property
    of the checkbox''s `input` element:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在常规DOM属性上使用属性绑定，Angular会直接将表达式绑定到元素的DOM属性上。我们使用这种类型的绑定将任务完成标志绑定到复选框的`input`元素的`checked`属性：
- en: '| **Usage** | **Description** |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **用法** | **描述** |'
- en: '| `@Input() inputProp;` | This allows us to bind the `inputProp` attribute
    to the component element within the parent component.Angular assumes that the
    attribute on the host element has the same name as that of the `input` property.
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `@Input() inputProp;` | 这允许我们将`inputProp`属性绑定到父组件内的组件元素。Angular假设宿主元素上的属性与`input`属性的名称相同。|'
- en: '| `@Input(''inp'') inputProp;` | You can also override the name of the attribute
    that should be mapped to this input. Here, the `inp` attribute of the component''s
    host element is mapped to the component''s input property, `inputProp`. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `@Input(''inp'') inputProp;` | 你也可以覆盖应映射到此输入的属性名称。在这里，组件宿主元素的`inp`属性被映射到组件的输入属性`inputProp`。|'
- en: The last missing piece so that we can use our newly created task component is
    the modification of the existing template of the task list.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用我们新创建的任务组件，最后缺失的部分是修改任务列表的现有模板。
- en: 'We include the task component within our task list template by using a `<mac-task>`
    element, as specified in the selector within our task component. Also, we need
    to create an input binding on the task component to pass the `task` object from
    the current `NgFor` iteration to the `task` input of the `task` component. We
    need to replace all the existing content in the `src/app/tasks/task-list/task-list.component.html`
    file with the following lines of code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用在任务组件中指定的选择器内的`<mac-task>`元素，将任务组件包含在我们的任务列表模板中。此外，我们还需要在任务组件上创建一个输入绑定，将当前`NgFor`迭代中的`task`对象传递到`task`组件的`task`输入。我们需要将`src/app/tasks/task-list/task-list.component.html`文件中所有现有的内容替换为以下代码行：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Congratulations! You've successfully refactored your task list by extracting
    the task into its own component and established a clean composition, encapsulation,
    and single responsibility. Also, we can now say that our task list is a composition
    of tasks.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经通过将任务提取到其自己的组件中并建立了干净的组合、封装和单一职责成功地重构了你的任务列表。此外，我们现在可以说我们的任务列表是由任务组成的。
- en: If you think about maintainability and re-usability, this was actually a very
    important step in the process of building our application. You should constantly
    look out for such composition opportunities, and if you feel something could be
    arranged into multiple subcomponents, you should probably go for it. Of course,
    you can also overdo this. There's simply no golden rule to determine what granularity
    of composition is the right one.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑可维护性和可重用性，这实际上是我们构建应用程序过程中的一个非常重要的步骤。你应该不断寻找这样的组合机会，如果你觉得某件事可以被组织成多个子组件，你可能会选择这样做。当然，你也可以做得太过分。实际上没有金科玉律来确定组合的粒度应该是多少。
- en: The right granularity of composition and encapsulation for a component architecture
    always depends on the context. My personal tip here is to use known principles
    from OOP, such as single responsibility, to lay the groundwork for a good design
    of your component tree. Always make sure your components are only doing things
    that they are supposed to do as their names suggest. A task list has the responsibility
    of listing tasks and providing some filters or other controls for the list. The
    responsibility of operating on individual task data and rendering the necessary
    view clearly belongs to a task component and not the task list.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 组件架构的组件组合和封装的正确粒度始终取决于上下文。我个人的建议是使用OOP中的已知原则，如单一职责，为你的组件树的良好设计打下基础。始终确保你的组件只做它们应该做的事情，正如它们的名称所暗示的那样。任务列表有列出任务和为列表提供一些过滤器或其他控件的责任。操作单个任务数据并渲染必要视图的明确责任属于任务组件，而不是任务列表。
- en: Recap
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾
- en: 'In this building block, we cleaned up our component tree and established clean
    encapsulation using subcomponents. Then, we set up the interfaces provided by
    Angular using input bindings. We performed these actions by following the ensuing
    steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个构建块中，我们清理了组件树并使用子组件建立了干净的封装。然后，我们使用输入绑定设置了Angular提供的接口。我们通过以下步骤执行了这些操作：
- en: We created a task subcomponent
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个任务子组件
- en: We used the task subcomponent with the task list component
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用了任务子组件与任务列表组件。
- en: We used input bindings and DOM element property bindings to establish one-way
    data binding in the task component
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在任务组件中使用了输入绑定和DOM元素属性绑定来建立单向数据绑定。
- en: Adding tasks
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加任务
- en: Our task list looks nice already, but it would be quite useless if the user
    is unable to add new tasks to the list. Let's create a component for entering
    new tasks together. Let's create a new component with the responsibilities of
    handling all the UI logic necessary for entering a new task to our list.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务列表看起来已经很不错了，但如果用户无法向列表中添加新任务，那将毫无用处。让我们一起创建一个用于输入新任务的组件。让我们创建一个新的组件，该组件负责处理将新任务添加到列表中所需的所有UI逻辑。
- en: 'Let''s use the Angular CLI tool to create a new component stub:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Angular CLI工具创建一个新的组件占位符：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Open up the template of the newly created component located at `src/app/tasks/enter-task/enter-task.component.html`
    and apply the following changes:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于 `src/app/tasks/enter-task/enter-task.component.html` 的新创建的组件模板，并应用以下更改：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This template consists of an input field as well as a button to enter a new
    task. If you take a closer look at the input field, you can see that we've added
    a special attribute called `#titleInput`. This is called a local view reference
    and we can use this reference within the current component view, or query for
    the element within our component code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板包含一个输入字段以及一个用于输入新任务的按钮。如果你仔细观察输入字段，你会发现我们添加了一个名为 `#titleInput` 的特殊属性。这被称为局部视图引用，我们可以在当前组件视图中使用此引用，或者在我们的组件代码中查询该元素。
- en: In this case, we are actually using the local view reference to pass the input
    field DOM element to the `enterTask` function that we call on a click event on
    the `Add Task` button. All local view references are available as variables within
    expressions in the view of a component.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们实际上使用局部视图引用将输入字段DOM元素传递给我们在“添加任务”按钮的点击事件上调用的 `enterTask` 函数。所有局部视图引用都作为变量在组件视图的表达式中可用。
- en: 'Let''s take a look at the implementation of our component class for entering
    a new task. For this, we need to replace the generated code in the `src/app/tasks/enter-task/enter-task.component.ts`
    file with the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们组件类的实现，用于输入新任务。为此，我们需要将 `src/app/tasks/enter-task/enter-task.component.ts`
    文件中生成的代码替换为以下代码：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For this component, we've chosen a design approach where we use a loose relation
    to our task list where the actual task will be created. Although this component
    is closely related to the task list, it's better to keep the components as loosely
    coupled as possible.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此组件，我们选择了一种设计方法，其中我们使用与任务列表的松散关系，实际的任务将在其中创建。尽管此组件与任务列表密切相关，但最好尽可能保持组件之间的松散耦合。
- en: 'One of the simplest forms of inversion of control, a callback function or event
    listener is a great principle to establish loose coupling. In this component,
    we are using the `@Output` decorator to create an event emitter. The output properties
    need to be instance properties that hold an event emitter within the component.
    On the component''s host element, we can then use event bindings to capture any
    events emitted. This gives us a great flexibility that we can use to create a
    clean application design, where we glue components together through the binding
    within the view:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 控制反转的最简单形式之一是回调函数或事件监听器，这是一个建立松散耦合的绝佳原则。在这个组件中，我们使用 `@Output` 装饰器创建一个事件发射器。输出属性需要是实例属性，在组件中持有事件发射器。然后，在组件的主元素上，我们可以使用事件绑定来捕获任何发射的事件。这为我们提供了极大的灵活性，我们可以利用它创建一个干净的应用程序设计，通过视图中的绑定将组件粘合在一起：
- en: Most of the time, your output names will clash with your component instance
    methods names. For this purpose, it's advised that you stick to some naming conventions
    when naming your outputs and methods which will trigger the outputs. Within this
    book, we are sticking to the naming convention of prefixing all output names with
    the prefix "out". This way, we can avoid name clashes and still keep names similar.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你的输出名称将与你的组件实例方法名称冲突。为此，建议你在命名输出和触发输出的方法时遵循一些命名约定。在本书中，我们遵循了在所有输出名称前缀为“out”的命名约定。这样，我们可以避免名称冲突，同时保持名称相似。
- en: '| **Usage** | **Description** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **用法** | **描述** |'
- en: '| `@Output() outputProp = new EventEmitter()`; | When `outputProp.emit()` is
    called, a custom event with the name `outputProp` will be emitted on the component.
    Angular will look for event bindings on the component''s HTML element (where the
    component is used) and execute them:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '| `@Output() outputProp = new EventEmitter();` | 当调用 `outputProp.emit()` 时，组件上会发出一个名为
    `outputProp` 的自定义事件。Angular将在组件的HTML元素（组件使用的地方）上查找事件绑定并执行它们：'
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Within the expressions in event bindings, you will always have access to a synthetic
    variable called `$event`. This variable is a reference to the data emitted by
    the event emitter. |
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件绑定表达式中的表达式，你将始终可以访问一个名为 `$event` 的合成变量。这个变量是对事件发射器发出的数据的引用。|
- en: '| `@Output(''out'') outputProp = new EventEmitter();` | Use this way of declaring
    your output properties if you''d want to name your events differently from what
    your property name is. In this example, a custom event with the name `out` will
    be fired when `outputProp.emit()` is called:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '| `@Output(''out'') outputProp = new EventEmitter();` | 使用这种方式声明你的输出属性，如果你想将事件名称与属性名称区分开来。在这个例子中，当调用
    `outputProp.emit()` 时，将触发一个名为 `out` 的自定义事件：'
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Okay, let''s use our newly created component to add new tasks to our task list
    component. First, let''s modify the existing template of the task list component.
    Open the task list template file, `src/app/tasks/task-list/task-list.component.html`.
    We need to add the `enter-task` component to the template and also handle the
    custom event that we''re going to emit, once a new task is entered:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们使用我们新创建的组件向我们的任务列表组件添加新任务。首先，让我们修改任务列表组件的现有模板。打开任务列表模板文件，`src/app/tasks/task-list/task-list.component.html`。我们需要将
    `enter-task` 组件添加到模板中，并处理我们将要触发的自定义事件，一旦输入了新任务：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Since the output property within the enter task component is called `outEnterTask`,
    we can bind it with the event binding attribute `(outEnterTask)=""` on the host
    element of the component.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于进入任务组件中的输出属性名为 `outEnterTask`，我们可以将其与组件宿主元素上的事件绑定属性 `(outEnterTask)=""` 绑定。
- en: Within the event binding expression, we then call a function on our task list
    component called `addTask`. We also use the synthetic variable `$event`, which
    contains the task title emitted from the enter task component. Now, whenever we
    push the button in our enter task component and an event gets emitted from the
    component, we catch the event in our event binding and handle it within the task
    list component.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件绑定表达式中，我们调用任务列表组件上的 `addTask` 函数。我们还使用了合成变量 `$event`，它包含来自进入任务组件的任务标题。现在，每次我们在进入任务组件中按下按钮并从组件中发出事件时，我们都会在事件绑定中捕获该事件，并在任务列表组件中处理它。
- en: 'We also need to make some minor changes to the task list component''s TypeScript
    file. We need to implement the `addTask` function, which gets called within the
    template of the task list component. Let''s open `src/app/tasks/task-list/task-list.component.ts`
    and modify it with the following changes:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要对任务列表组件的TypeScript文件做一些小的修改。我们需要实现 `addTask` 函数，该函数在任务列表组件的模板中被调用。让我们打开
    `src/app/tasks/task-list/task-list.component.ts` 并进行以下修改：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have created a function, `addTask`, which will add a new task to our task
    list with a title that is passed to the function. Now, the loop is closed and
    our event from the enter task component is forwarded to this function within the
    view of the task list component.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `addTask` 的函数，该函数将使用传递给函数的标题将新任务添加到我们的任务列表中。现在，循环已关闭，并且来自进入任务组件的事件已转发到任务列表组件的视图中。
- en: Now is a good time to preview your changes if you haven't already. Try adding
    new tasks to the list and relate the behaviour to the changes you've applied to
    the code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有预览你的更改，现在是时候了。尝试向列表中添加新任务，并将行为与你对代码所做的更改联系起来。
- en: Recap
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾
- en: 'We have added a new enter task component which is responsible for providing
    the UI logic to add new tasks. We have covered the following topics:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新的进入任务组件，该组件负责提供添加新任务的UI逻辑。我们涵盖了以下主题：
- en: We created a child component that is loosely coupled using output properties
    and event emitters
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个使用输出属性和事件发射器松散耦合的子组件
- en: We learned about the `@Output` decorator and how to use it to create output
    properties
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了 `@Output` 装饰器及其如何用于创建输出属性
- en: We used event bindings to react on component output and execute actions
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用事件绑定来响应组件输出并执行操作
- en: Custom UI elements
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义UI元素
- en: The standard UI elements in the browser are great, but sometimes, modern web
    applications require smarter and more complex input elements than the ones available
    within the browser.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中的标准UI元素很棒，但有时，现代Web应用程序需要比浏览器内可用的更智能和更复杂的输入元素。
- en: 'We''ll now create two specific custom UI elements that we''ll use within our
    application going forward in order to provide a nice user experience:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建两个特定的自定义UI元素，我们将从现在开始在应用程序中使用它们，以提供良好的用户体验：
- en: '**Checkbox**: There''s already a native checkbox input in the browser, but
    sometimes, it''s hard to fit it into the visual design of an application. Native
    checkboxes are limited in their styling possibilities, and therefore, it''s hard
    to make them look great. Sometimes, it''s those minor details that make an application
    look appealing.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复选框**：浏览器中已经有一个原生的复选框输入，但有时很难将其融入应用程序的视觉设计中。原生复选框在样式方面有限，因此很难使它们看起来很棒。有时，正是那些细微之处让应用程序看起来吸引人。'
- en: '**Toggle buttons**: This is a list of toggle buttons, where only one button
    can be toggled within the list. They can also be represented with a native radio
    button list. However, like with native checkboxes, radio buttons are sometimes
    not really the nicest visual solution to the problem. A list of toggle buttons
    that also represent a select-one-user input element is much more modern and provides
    the visual aspect that we are looking for. Besides, who doesn''t like to push
    buttons?'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切换按钮**：这是一个切换按钮列表，列表中只有一个按钮可以被切换。它们也可以用原生的单选按钮列表表示。然而，就像原生复选框一样，单选按钮有时并不是解决这个问题的最佳视觉解决方案。一个既代表单选用户输入元素又表示切换按钮列表的列表更加现代，并提供了我们所需的视觉方面。此外，谁不喜欢按按钮呢？'
- en: 'Let''s create our custom checkbox UI element first. As we''ll probably come
    up with a few custom UI elements, we will introduce a new top-level UI folder.
    By calling the Angular CLI generator with the right parameter, we can create the
    stub for our checkbox component in the right folder:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建我们的自定义复选框UI元素。由于我们可能会想出几个自定义UI元素，我们将引入一个新的顶级UI文件夹。通过使用正确的参数调用Angular
    CLI生成器，我们可以在正确的文件夹中创建复选框组件的占位符：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s start with the template of our new component and change the content
    of `src/app/ui/checkbox/checkbox.component.html`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们新组件的模板开始，并更改`src/app/ui/checkbox/checkbox.component.html`的内容：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: On the checkbox input, we have two bindings. First, we have a property binding
    for the `checked` property on the DOM element. We are binding the DOM property
    to the `checked` member field on our component, which we are going to create in
    a moment.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在复选框输入上，我们有两个绑定。首先，我们在DOM元素上有一个`checked`属性的属性绑定。我们将DOM属性绑定到我们将要创建的组件的`checked`成员字段上。
- en: Also, we have an event binding on the input element where we listen for the
    checkbox change DOM event and call the method `check` on our component instance.
    We use the synthetic variable `$event` to pass the `checked` property of the checkbox
    DOM element where the change event originated.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在输入元素上有一个事件绑定，我们监听复选框变化的DOM事件，并在我们的组件实例上调用`check`方法。我们使用合成变量`$event`传递复选框DOM元素的`checked`属性，其中变化事件发生。
- en: 'Moving on to our component class implementation, let''s edit the TypeScript
    file on the path `src/app/ui/checkbox/checkbox.component.ts`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编辑组件类实现，修改路径`src/app/ui/checkbox/checkbox.component.ts`上的TypeScript文件：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There's nothing special about this component class. It uses an input property
    to set the checked state from the outside, and it also has an output property
    with an event emitter that allows us to notify the outer component about the changes
    of the checked state.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件类并没有什么特别之处。它使用一个输入属性从外部设置选中状态，并且它还有一个带有事件发射器的输出属性，允许我们通知外部组件关于选中状态的变化。
- en: 'Let''s integrate our checkbox in the task component to replace the native checkbox
    input we''re currently using there. For this purpose, we need to modify the `src/app/tasks/task/task.component.html`
    file by replacing its previous content with the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们的复选框集成到任务组件中，以替换我们目前在那里使用的原生复选框输入。为此，我们需要修改`src/app/tasks/task/task.component.html`文件，用以下代码替换其之前的内容：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should now already be able to see the changes in your browser and our nice
    custom checkbox component in action. As a next step, we''d like to apply some
    styling changes when a task is marked as done. This gives us better visual feedback
    than just the tick of the checkbox. For this, we''re looking at a new concept
    to manipulate the host element of a component. Let''s open the task component
    class on the path `src/app/tasks/task/task.component.ts` and add the following
    code to the body of the `TaskComponent` class:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该已经能够在浏览器中看到变化，并看到我们漂亮的自定义复选框组件在行动。作为下一步，我们希望当任务被标记为完成时应用一些样式更改。这比仅仅勾选复选框提供了更好的视觉反馈。为此，我们正在考虑一个新的概念来操作组件的主元素。让我们打开路径`src/app/tasks/task/task.component.ts`上的任务组件类，并将以下代码添加到`TaskComponent`类的主体中：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using the `@HostBinding` decorator, we can create property bindings on the component
    host element based on the members of our component. Let's use this decorator in
    order to create a binding that will conditionally set a class with the name `done`
    on the component's HTML element. This is used to make some visual distinctions
    of finished tasks within our styles.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@HostBinding`装饰器，我们可以在组件的主元素上根据我们组件的成员创建属性绑定。让我们使用这个装饰器来创建一个条件性地在组件的HTML元素上设置名为`done`的类的绑定。这用于在我们的样式中对完成的任务进行一些视觉区分。
- en: 'This is a good time to check your result and play around with these large new
    checkboxes in the task list. Isn''t that much more fun to do than activating regular
    checkboxes? Don''t underestimate the effect of a user interface that is pleasing
    to use. This can have a very positive impact on the usage of your product:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是检查你的结果并在任务列表中尝试这些新的大复选框的好时机。这难道不是比激活常规复选框更有趣吗？不要低估一个令人愉悦的用户界面对产品使用的影响。这可能会对你的产品使用产生非常积极的影响：
- en: '![](img/0d491a9c-a40a-4b89-8537-f3fd766160dd.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0d491a9c-a40a-4b89-8537-f3fd766160dd.png)'
- en: Our task list after adding our custom checkbox component
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 添加我们的自定义复选框组件后的任务列表
- en: Recap
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this section, you learned how to build custom UI components that are generic
    and loosely coupled so that they can be used in other components as subcomponents.
    We also completed the following tasks:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何构建通用且松耦合的自定义UI组件，以便它们可以作为子组件在其他组件中使用。我们还完成了以下任务：
- en: We created a subcomponent that is loosely coupled using output properties and
    event emitters
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个子组件，该组件通过输出属性和事件发射器进行松耦合
- en: We learned what the `@Output` decorator is and how to use it to create output
    properties
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了`@Output`装饰器的含义以及如何使用它来创建输出属性
- en: We used event bindings to link the behaviour together from the view of a component
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用事件绑定从组件的视图中将行为链接在一起
- en: Task data service
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务数据服务
- en: We have already learned a lot about building basic components and how to compose
    them together in order to form larger components. In the previous building block,
    we created a reusable checkbox UI component, which we've used to enhance the usability
    of our task list.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学到了很多关于构建基本组件以及如何将它们组合在一起以形成更大组件的知识。在上一个构建块中，我们创建了一个可重用的复选框UI组件，我们用它来增强任务列表的可用性。
- en: In this topic, we will use the toggle button component to create a filter for
    our task list. But before we start to introduce more complexity into our application,
    we're going to refactor our application by introducing data services. As our application
    gets larger, it's crucial to centralize our data manipulation and streamline our
    data flow. Services come in very handy since they allow us to store state which
    is accessible in all our components using Angular's dependency injection.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们将使用切换按钮组件来为我们的任务列表创建一个过滤器。但在我们开始向应用程序引入更多复杂性之前，我们将通过引入数据服务来重构我们的应用程序。随着应用程序的扩大，集中我们的数据操作和简化我们的数据流变得至关重要。服务非常有用，因为它们允许我们存储状态，这些状态可以通过Angular的依赖注入在所有组件中访问。
- en: Going forward, we'll deal with quite a lot of data within our application. TypeScript
    supports us very well when it comes to building type-safe data structures. So
    far, we've treated our task data as object literals, and TypeScript was extracting
    type information from there. However, as we start to use our data in different
    areas of our application, it makes sense to model our data in a central location.
    For this purpose, we're going to create our first TypeScript interface for representing
    our task data. In TypeScript, we can not only use interfaces for implementing
    classes and polymorphism, we can also use it to solely add type safety to our
    object literals and operations on objects. This is considered a very useful practice
    and will save us from a lot of potential bugs in the future.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将在应用程序中处理大量的数据。在构建类型安全的数据结构方面，TypeScript 为我们提供了非常好的支持。到目前为止，我们一直将任务数据作为对象字面量处理，TypeScript
    从那里提取类型信息。然而，当我们开始在应用程序的不同区域使用我们的数据时，在中央位置对数据进行建模是有意义的。为此，我们将创建我们的第一个 TypeScript
    接口来表示我们的任务数据。在 TypeScript 中，我们不仅可以使用接口来实现类和多态，我们还可以仅使用它来为对象字面量和对象操作添加类型安全。这被认为是一种非常有用的实践，并将帮助我们避免未来许多潜在的错误。
- en: 'Let''s create a new TypeScript file on the path `src/app/model.ts` and add
    the following content to the file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在路径 `src/app/model.ts` 上创建一个新的 TypeScript 文件，并将以下内容添加到该文件中：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: So far, we have stored our task list data directly within the task list component,
    but let's change that here and use a service that will provide task data for us.
    It's generally never a good idea to store data directly within a component. Refactoring
    our data into services is only the first step toward a clean component architecture,
    and we will learn about different methods about how to store our state and data
    in later chapters of this book.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在任务列表组件中直接存储任务列表数据，但在这里让我们改变这一点，并使用一个为我们提供任务数据的服务。通常，将数据直接存储在组件中并不是一个好主意。将我们的数据重构到服务中只是迈向清晰组件架构的第一步，我们将在本书的后续章节中学习如何存储我们的状态和数据的不同方法。
- en: 'In order to use the service we''re about to create, we''re going to make use
    of Angular''s dependency injection for the first time. The Angular CLI comes in
    handy here, too. We can use it to generate a stub service for us:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用我们即将创建的服务，我们将首次使用 Angular 的依赖注入。Angular CLI 在这里也很有用。我们可以使用它为我们生成一个服务占位符：
- en: '[PRE29]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will generate a file for us located on the path `src/app/tasks/task.service.ts`.
    Let''s open this file in an editor and edit it with the following changes:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在路径 `src/app/tasks/task.service.ts` 上为我们生成一个文件。让我们在编辑器中打开这个文件，并使用以下更改进行编辑：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We've moved all our task data into the newly created service. In order to make
    our service class injectable, we need to decorate it with the `@Injectable` decorator.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将所有任务数据移动到了新创建的服务中。为了使我们的服务类可注入，我们需要用 `@Injectable` 装饰器对其进行装饰。
- en: We're also using the `Task` interface for our tasks so that we have better type
    safety when working with task objects. In order to keep our data encapsulated
    and safe, we're going to create a clone of the internal tasks list when we're
    exposing it to any consumers. In JavaScript, we can simply call `Array.prototype.slice`
    in order to create a copy of an existing array.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用 `Task` 接口来处理我们的任务，以便在处理任务对象时具有更好的类型安全。为了保持我们的数据封装和安全，当我们将其暴露给任何消费者时，我们将创建内部任务列表的副本。在
    JavaScript 中，我们可以简单地调用 `Array.prototype.slice` 来创建现有数组的副本。
- en: 'Before we can use our task service within components, we need to provide it
    as a dependency. Dependencies are typically provided on the application level.
    In order to provide a dependency on the application level, we need to do some
    modifications to our main application module located on the path `src/app/app.module.ts`.
    The changes to the module are highlighted in the following code excerpt. The ellipsis
    character indicates that there''s more code in the existing file, which is irrelevant
    for the changes we are applying:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以在组件中使用任务服务之前，我们需要将其作为依赖项提供。依赖项通常在应用程序级别提供。为了在应用程序级别提供依赖项，我们需要对我们的主应用程序模块（位于路径
    `src/app/app.module.ts`）进行一些修改。模块的更改在以下代码摘录中突出显示。省略号字符表示现有文件中还有更多代码，但这些代码对我们应用更改不相关：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Since we've provided our task service to the main module as a dependency, it
    will now be available for injection from the application injector.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将任务服务作为依赖项提供给主模块，因此它现在将可用于应用程序注入器中的注入。
- en: Now, we can go ahead and modify our task list component to consume our task
    service. All our tasks are now stored in the task service and we need to remove
    the data which we previously embedded into the task list component.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续修改我们的任务列表组件以消费我们的任务服务。所有任务现在都存储在任务服务中，我们需要从任务列表组件中移除之前嵌入的数据。
- en: 'Let''s apply the changes to our task list component and modify the `src/app/tasks/task-list/task-list.component.ts`
    file. The following excerpt contains the whole code for the task list component.
    The changed and new sections are highlighted:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将更改应用到我们的任务列表组件，并修改`src/app/tasks/task-list/task-list.component.ts`文件。以下摘录包含了任务列表组件的全部代码。更改和新部分被突出显示：
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Instead of storing all our tasks within the task list component, we're now just
    declaring the `tasks` member. On the constructor of our component, we're using
    dependency injection to inject our newly created task service. Within the constructor
    body, we're retrieving task data by calling the `getTasks` method on our service.
    The resulting list is then stored within the `tasks` member of our component.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不再在任务列表组件中存储所有任务，而是只声明`tasks`成员。在我们的组件构造函数中，我们使用依赖注入来注入我们新创建的任务服务。在构造函数体中，我们通过在服务上调用`getTasks`方法来检索任务数据。然后，这个结果列表被存储在我们的组件的`tasks`成员中。
- en: Within the `addTask` method, we're no longer directly modifying our task list.
    Instead, we're using the service to add a new task. After that, we need to get
    the updated list from the service by calling `getTasks` again.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在`addTask`方法中，我们不再直接修改我们的任务列表。相反，我们正在使用服务来添加一个新任务。之后，我们需要通过再次调用`getTasks`来从服务中获取更新后的列表。
- en: We've also created a method called `updateTask` to update our tasks using our
    task service. Until now, we have updated the task data directly within our task
    component. The output binding on our checkbox was modifying the task's state on
    updates directly from within the view. While we're shaping our application, it
    becomes critical that we modify the state of our application in a more controlled
    manner. Imagine that you have dozens of components within your application, where
    each of them is modifying the state of your application. This would be a true
    maintenance hell.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个名为`updateTask`的方法来使用我们的任务服务更新任务。到目前为止，我们一直在任务组件内部直接更新任务数据。我们的复选框上的输出绑定直接从视图中更新任务的状态。在我们塑造应用程序的过程中，以更受控的方式修改应用程序的状态变得至关重要。想象一下，在你的应用程序中有数十个组件，每个组件都在修改应用程序的状态。这将是一场真正的维护噩梦。
- en: 'So, how should we best approach this problem? The answer is delegation. We
    will delegate state manipulation to our parent components until we reach a component
    which is supposed to handle the manipulation. Component output is perfect for
    this use-case. We can tell our parent component about a change by emitting an
    output value. In our case, this means the following flow should occur:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们应该如何最好地解决这个问题呢？答案是委托。我们将状态操作委托给父组件，直到我们达到应该处理操作的组件。组件输出非常适合这个用例。我们可以通过发出输出值来告诉父组件发生了变化。在我们的情况下，这意味着以下流程应该发生：
- en: The checkbox component will tell the task component that the checkbox was ticked
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复选框组件将告诉任务组件复选框已被勾选
- en: The task component will tell the task list component that the task should be
    updated
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任务组件将告诉任务列表组件任务应该被更新
- en: The task list component will call the service to update the task data
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任务列表组件将调用服务来更新任务数据
- en: 'First, we''re going to fix the state manipulation which is happening within
    the task component. Open up the task component template located at `src/app/tasks/task/task.component.html`
    and perform the following changes:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将修复在任务组件中发生的状态操作。打开位于`src/app/tasks/task/task.component.html`的任务组件模板，并执行以下更改：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we''re adding a new output to our task component and implementing the
    `updateTask` method in `src/app/tasks/task/task.component.ts`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在任务组件中添加了一个新的输出，并在`src/app/tasks/task/task.component.ts`中实现了`updateTask`方法：
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Great! All whats left to do now is to catch the `outUpdateTask` output in the
    task list component template and call the `updateTask` method, which we''ve already
    added to the component class. Let''s edit the file `src/app/tasks/task-list/task-list.component.html`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们唯一要做的就是捕获任务列表组件模板中的`outUpdateTask`输出并调用我们已添加到组件类中的`updateTask`方法。让我们编辑文件`src/app/tasks/task-list/task-list.component.html`：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now is a good time to preview your changes in the browser. Our task list should
    be fully functional again. Try adding new tasks and marking tasks as done. Our
    task list component is already much cleaner since we're not storing any data within
    the component. Instead, we're using a service which can also be used in other
    components.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是预览您更改的好时机。我们的任务列表应该又能完全正常工作了。尝试添加新任务和标记任务为完成。由于我们不在组件内部存储任何数据，我们的任务列表组件已经变得更加简洁。相反，我们使用了一个服务，这个服务也可以在其他组件中使用。
- en: Recap
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'Within this section, we''ve not created anything new in the user interface
    of our application. However, it was still one of the more important sections of
    this chapter. We''ve learned about clean data flow, data and state best practices,
    and have created and integrated our first Angular service:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们并没有在应用程序的用户界面中创建任何新内容。然而，这仍然是本章中较为重要的部分之一。我们学习了关于清洁数据流、数据和状态的最佳实践，并创建并集成了我们的第一个Angular服务：
- en: We have created a task service to store and manipulate our task data
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个任务服务来存储和处理我们的任务数据
- en: We've delegated state manipulation from our task component to the task list
    component which was then interacting with our service
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将状态操作从任务组件委托给了任务列表组件，然后该组件与我们的服务进行交互
- en: We have learned about `@Injectable` and how to provide dependencies at the application
    level
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们了解了`@Injectable`及其如何在应用级别提供依赖项
- en: We've injected our task service in the constructor of our task list component
    where we use it to obtain data
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在任务列表组件的构造函数中注入了我们的任务服务，在那里我们使用它来获取数据
- en: Filtering tasks
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤任务
- en: 'In this section, we''re going to implement some filter functionality for our
    task list. In order to control the active filter criteria, we are first building
    a toggle button list component. Let''s go ahead and create a new component using
    the Angular CLI:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为我们的任务列表实现一些过滤功能。为了控制活动过滤标准，我们首先构建了一个切换按钮列表组件。让我们继续使用Angular CLI创建一个新的组件：
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After running the Angular CLI generator command on your console, let''s edit
    the HTML template of the newly created component in `src/app/ui/toggle/toggle.component.html`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的控制台运行Angular CLI生成器命令后，让我们编辑新创建组件的HTML模板`src/app/ui/toggle/toggle.component.html`：
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Nothing special here, really! We repeat a button by iterating over an instance
    field called `buttonList` using the `NgFor` directive. This button list will contain
    the labels of our toggle buttons. Conditionally, we set a class called `active`
    using a property binding and check it against our current button within the iteration
    against an instance field called `selectedButton`. When the button is clicked,
    we call a method, `activate`, on our component instance and pass the current button
    label from the iteration.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上这里没有什么特别的！我们通过迭代一个名为`buttonList`的实例字段来重复一个按钮，使用`NgFor`指令。这个按钮列表将包含我们的切换按钮的标签。条件性地，我们使用属性绑定设置一个名为`active`的类，并检查它是否与迭代中的当前按钮匹配一个名为`selectedButton`的实例字段。当按钮被点击时，我们在组件实例上调用一个名为`activate`的方法，并传递迭代中的当前按钮标签。
- en: 'Now, let''s change the code of our component class on the path `src/app/ui/toggle/toggle.component.ts`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更改组件类路径`src/app/ui/toggle/toggle.component.ts`的代码：
- en: '[PRE38]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Within our toggle component, we rely on the `buttonList` input to be an array
    of button label strings. We are using this array within our template on a `NgFor`
    directive.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的切换组件中，我们依赖于`buttonList`输入是一个按钮标签字符串数组。我们在模板中使用这个数组，通过`NgFor`指令。
- en: The `activeButton` input is expected to be set to the button label string which
    is currently active within the toggle list. We also create an output named `outActivate`
    to notify the outside world about state changes of the active toggle button.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的`activeButton`输入应设置为当前在切换列表中激活的按钮标签字符串。我们还创建了一个名为`outActivate`的输出，以通知外界关于活动切换按钮状态的变化。
- en: Within the `activate` function, we are only emitting the `outActivate` output.
    From the binding outside of the component, we then expect the `activeButton` input
    to be updated accordingly. It's important to understand that our toggle component
    is only communicating to the parent component about a button that got activated.
    It's not updating any state, really. We're expecting that the parent component
    which uses our toggle component will then update the `activeButton` input accordingly.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `activate` 函数中，我们只发出 `outActivate` 输出。从组件外部的绑定，我们期望 `activeButton` 输入相应地更新。重要的是要理解，我们的切换组件仅与父组件通信有关被激活的按钮。实际上并没有更新任何状态。我们期望使用我们的切换组件的父组件相应地更新
    `activeButton` 输入。
- en: The `ngOnInit` method is called by Angular automatically within the life cycle
    of directives and components. This is also the reason why our toggle component
    class is implementing the life cycle hook interface `OnInit`. In the case where
    the `activeButton` input property was not specified, we'll add a check and select
    the first button from the available button list. Since `activeButton`, as well
    as `buttonList`, are input properties, we need to wait for them to be initialized
    in order to execute this logic. It's important not to perform this initialization
    within the component constructor. Only within the life cycle hook `OnInit` do
    we have the guarantee that our input properties have been set already. It is invoked
    only once for each component which is created.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngOnInit` 方法由 Angular 在指令和组件的生命周期中自动调用。这也是我们的切换组件类实现生命周期钩子接口 `OnInit` 的原因。在
    `activeButton` 输入属性未指定的情况下，我们将添加一个检查并从可用的按钮列表中选择第一个按钮。由于 `activeButton` 以及 `buttonList`
    都是输入属性，我们需要等待它们被初始化才能执行此逻辑。重要的是不要在组件构造函数中执行此初始化。只有在生命周期钩子 `OnInit` 中，我们才能保证我们的输入属性已经被设置。它只为每个创建的组件调用一次。'
- en: Angular will call any life cycle hooks that have been implemented in your component
    automatically. The interfaces which are available for each life cycle hook are
    only helpful in the sense that they ensure you have implemented all desired callbacks
    for the individual life cycle hooks.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 会自动调用你在组件中实现的任何生命周期钩子。每个生命周期钩子可用的接口仅有助于确保你已经为每个生命周期钩子实现了所有所需的回调。
- en: The following diagram illustrates the life cycle of an Angular component. Upon
    component construction, all the life cycle hooks will be called as per the order
    which is shown in the diagram, except the `OnDestroy` hook, which will be called
    upon component destruction.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了 Angular 组件的生命周期。在组件构建过程中，所有生命周期钩子将按照图中的顺序被调用，除了 `OnDestroy` 钩子，它将在组件销毁时被调用。
- en: 'Change detection will also start a subset of life cycle hooks, where some of
    the hooks which are called during creation are skipped:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 变更检测也会启动生命周期钩子的一部分，其中在创建过程中调用的某些钩子将被跳过：
- en: '`doCheck`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doCheck`'
- en: '`afterContentChecked`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterContentChecked`'
- en: '`afterViewChecked`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterViewChecked`'
- en: '`onChanges (if any changes are detected)`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onChanges (如果有任何更改被检测到)`'
- en: 'A detailed description of the life cycle hooks and their purposes is available
    on the Angular documentation website at [https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有关生命周期钩子和它们的目的的详细描述，可在 Angular 文档网站上找到：[https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks)
- en: '![](img/db407698-3cc5-4c75-a878-4e7ff8fc780a.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/db407698-3cc5-4c75-a878-4e7ff8fc780a.png)'
- en: An illustration of the life cycle of an Angular component
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 组件生命周期的示意图
- en: Alright! We have created a new UI component to render a toggle button list.
    Now, it's time to move on with our main goal within this chapter, implementing
    a filtering system in our task list component.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！我们已经创建了一个新的 UI 组件来渲染切换按钮列表。现在，是时候继续本章的主要目标，在我们的任务列表组件中实现一个过滤系统。
- en: 'First, we should think about the model for our filter. We''d want to include
    three states, all, open, and done, which should each result in a different view
    of our task list. Let''s open up our model file located at `src/app/model.ts`
    and add the following changes:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该考虑过滤器的模型。我们希望包含三种状态：全部、打开和完成，每种状态都应导致任务列表的不同视图。让我们打开位于 `src/app/model.ts`
    的模型文件，并添加以下更改：
- en: '[PRE39]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We're defining a type alias, which represents a list of valid filter types.
    TypeScript type aliases are really helpful in order to make certain things more
    type safe. Especially when you're dealing with string types, you can use type
    aliases to create string literal types. By creating a type alias `TaskListFilterType`,
    and later using it in the context of the filter, we can specify which strings
    are valid while filtering. This will prevent any typos when dealing with task
    filter type strings within our application.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个类型别名，它代表一个有效过滤器类型的列表。TypeScript类型别名对于使某些事情更加类型安全非常有帮助。特别是当你处理字符串类型时，你可以使用类型别名来创建字符串字面量类型。通过创建一个类型别名`TaskListFilterType`，并在过滤的上下文中使用它，我们可以在过滤时指定哪些字符串是有效的。这将防止在我们应用程序中处理任务过滤器类型字符串时出现任何错误。
- en: 'Now, it''s time to implement our filter functionality. Let''s open the task
    list component file located at `src/app/tasks/task-list/task-list.component.ts`
    and apply some code changes. Again, changed parts of the code are highlighted,
    to make it easier for you to see the effective changes:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候实现我们的过滤功能了。让我们打开位于`src/app/tasks/task-list/task-list.component.ts`的任务列表组件文件，并应用一些代码更改。同样，更改的部分代码被突出显示，以便您更容易看到有效的更改：
- en: '[PRE40]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Within the component, we want to store a list of types the task filter can have.
    This list will serve as input for our toggle button list. If you recall the input
    properties on our toggle button, we have a `buttonList` input that accepts a list
    of button labels. To store the currently selected filter type, we use an instance
    field called `activeTaskFilterType`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件内部，我们希望存储一个任务过滤器可能拥有的类型列表。这个列表将作为我们切换按钮列表的输入。如果你还记得我们的切换按钮的输入属性，我们有一个接受按钮标签列表的`buttonList`输入。为了存储当前选中的过滤器类型，我们使用一个名为`activeTaskFilterType`的实例字段。
- en: The last piece that we need to add to our task list component is the actual
    filtering of tasks. For this, we're introducing a new member called `filteredTasks`,
    which will always be updated with the currently filtered subset of tasks. Within
    the `filterTasks` method, we are computing the subset of filtered tasks by evaluating
    the active filter criteria stored in `activeTaskFilterType`. The result of the
    filtering will be stored in our `filteredTasks` member.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加到任务列表组件中的最后一部分是实际的任务过滤。为此，我们引入了一个名为`filteredTasks`的新成员，它将始终更新为当前过滤的任务子集。在`filterTasks`方法中，我们通过评估存储在`activeTaskFilterType`中的活动过滤器标准来计算过滤任务的子集。过滤的结果将存储在我们的`filteredTasks`成员中。
- en: We've also created a method, `activateFilterType`, which we can call to switch
    the active filter criteria. This method will then call the `filterTasks` method
    to update our filtered subset of tasks.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个名为`activateFilterType`的方法，我们可以调用它来切换活动过滤器标准。然后，这个方法将调用`filterTasks`方法来更新我们的过滤任务子集。
- en: 'Okay, that''s all we are going to change in our component class. We still need
    to change our view template, though. We need to render our toggle component and
    execute our filtering on filter criteria changes. Since we want to render the
    filtered subset of tasks instead of the whole task list, we also need to change
    the source for the `NgFor`, which repeats our tasks in the view. Let''s open the
    template file `src/app/tasks/task-list/task-list.html` and modify it with the
    following changes:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这就是我们将在组件类中进行的所有更改。尽管如此，我们仍然需要更改我们的视图模板。我们需要在过滤器标准更改时渲染我们的切换组件并执行过滤。由于我们想要渲染过滤后的任务子集而不是整个任务列表，我们还需要更改`NgFor`的源，它在视图中重复我们的任务。让我们打开模板文件`src/app/tasks/task-list/task-list.html`，并按照以下更改进行修改：
- en: '[PRE41]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Let's discuss the changes quickly. First, we are binding the `taskFilterTypes`
    property where we store a list of possible filter types within the task list component
    class, to the toggle component `buttonList` input property. This will make the
    toggle component render all filter types as toggle buttons.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速讨论一下这些更改。首先，我们将存储在任务列表组件类中可能过滤类型列表的`taskFilterTypes`属性绑定到切换组件的`buttonList`输入属性。这将使切换组件渲染所有过滤类型作为切换按钮。
- en: We also bind the `activeTaskFilterType` instance field of the task list to the
    `activeButton` input property of the toggle component. This way, changes to the
    `activeTaskFilterType` property will be reflected in the toggle component. At
    the same time, when a user changes the active toggle button inside the toggle
    component, we capture the `outActivate` output of the toggle component and call
    the `activateFilterType` method on the task list component.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将任务列表的 `activeTaskFilterType` 实例字段绑定到切换组件的 `activeButton` 输入属性。这样，`activeTaskFilterType`
    属性的更改将在切换组件中反映出来。同时，当用户在切换组件内部更改活动切换按钮时，我们捕获切换组件的 `outActivate` 输出，并在任务列表组件上调用
    `activateFilterType` 方法。
- en: 'That''s it, congratulations! You''ve successfully added a filtering mechanism
    to your task list by using our newly created toggle component. Preview the changes
    in your browser; you should see a fully functional task list where you can mark
    tasks as done, add new tasks, and filter the list by activating our nice toggle
    buttons:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，恭喜！你已经成功通过使用我们新创建的切换组件添加了过滤机制到你的任务列表中。在你的浏览器中预览更改；你应该看到一个功能齐全的任务列表，你可以标记任务为完成，添加新任务，并通过激活我们漂亮的切换按钮来过滤列表：
- en: '![](img/a36edc80-1201-4813-9f14-65d3daa984a1.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a36edc80-1201-4813-9f14-65d3daa984a1.png)'
- en: Screenshot of the task list with the newly added toggle button component for
    filtering the task state
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 新增切换按钮组件的过滤任务状态的截图
- en: Recap
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习
- en: 'In this section, we''ve built a filtering system into our task list component.
    We have also created an additional UI component to render toggle buttons, which
    we''re presenting to the user for selecting the filter criteria:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经在任务列表组件中构建了一个过滤系统。我们还创建了一个额外的 UI 组件来渲染切换按钮，我们将这些按钮展示给用户以选择过滤标准：
- en: We created a new toggle component to render a set of toggle buttons
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个新的切换组件来渲染一组切换按钮。
- en: We used the `@HostBinding` decorator to create property bindings declaratively
    from within our component class
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `@HostBinding` 装饰器从我们的组件类内部声明性地创建属性绑定。
- en: We learned about the Angular component life cycle and how we can use the `OnInit`
    life cycle hook to initialize the component after the input has been processed
    for the first time
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解了 Angular 组件生命周期以及我们如何使用 `OnInit` 生命周期钩子在第一次处理输入后初始化组件。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned a lot of new concepts on building UI component-based
    applications with Angular. We also built the core component of our task management
    application, which is the task list itself. You learned about the concept of input
    and output properties and how to use them to establish proper component communication.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了使用 Angular 构建基于 UI 组件的应用程序的新概念。我们还构建了我们任务管理应用程序的核心组件，即任务列表本身。你了解了输入和输出属性的概念以及如何使用它们来建立适当的组件通信。
- en: We also covered the basics of the Angular component life cycle and how to use
    life cycle hooks to execute post-initialization steps within the `OnInit` hook.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还涵盖了 Angular 组件生命周期的基本知识以及如何在 `OnInit` 钩子中通过生命周期钩子执行初始化后的步骤。
- en: As the last step, we integrated a toggle button list component within our task
    list to filter the task states. We refactored our task list component to use a
    service in order to obtain task data. For this, we used Angular's dependency injection.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们在任务列表中集成了切换按钮列表组件以过滤任务状态。我们将任务列表组件重构为使用服务来获取任务数据。为此，我们使用了 Angular 的依赖注入。
- en: Within the next chapter, we're going to look at ways how to improve our handling
    of data and state. There are plenty of ways how to deal with application state
    and we're going to learn how to best tackle this issue.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何改进我们对数据和状态的处理方式。处理应用程序状态的方法有很多，我们将学习如何最好地解决这个问题。
