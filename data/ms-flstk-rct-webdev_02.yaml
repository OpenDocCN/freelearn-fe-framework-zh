- en: Full-Stack Login and Registration for Our Publishing App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们发布应用程序的全栈登录和注册
- en: '**JSON Web Token** (**JWT**) is a security tokens format, which is relatively
    new, but works very well. It''s an open standard (RFC 7519) that improves oAuth2
    and OpenID connection when dealing with the problem of passing claims between
    parties in a web application environment.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON Web Token**（**JWT**）是一种安全令牌格式，相对较新，但效果很好。它是一个开放标准（RFC 7519），在处理在Web应用程序环境中传递声明的问题时，它改进了OAuth2和OpenID连接。'
- en: 'In practice, the flow is as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，流程如下：
- en: The server assigns an encoded JSON object
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器分配一个编码的JSON对象
- en: After client has been alerted, it sends that encoded token with every request
    to the server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端被提醒后，它将编码的令牌与每个请求一起发送到服务器
- en: Based on that token, the server knows who is sending a request
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据该令牌，服务器知道谁在发送请求
- en: 'It''s worth visiting the [http://jwt.io/](http://jwt.io/) website and playing
    with it before you start working with it:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用它之前，值得访问[http://jwt.io/](http://jwt.io/)网站并尝试一下：
- en: '![](img/00020.jpeg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00020.jpeg)'
- en: 'After successful login, the JWT''s solution provides an object to our frontend
    application that tells us about a current user''s authorization:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 登录成功后，JWT解决方案为我们前端应用程序提供一个对象，告诉我们当前用户的授权情况：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `iss` is an issuer property--in our case it will be our publishing app''s
    backend application. The name of the logged user is obvious--`John Doe` has logged
    in successfully. The `admin` property is just saying that an identified user (logged
    into our backend''s app with the correct login and password) is an admin `(''admin'':
    true flag)`. You will learn how to use it in this chapter.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`iss`是一个发行者属性——在我们的案例中，它将是我们的发布应用程序的后端应用程序。已登录用户的名称很明显——`John Doe`已成功登录。`admin`属性只是说明一个已识别的用户（使用正确的登录名和密码登录到我们的后端应用程序）是一个管理员（`''admin'':
    true`标志）。您将在本章中学习如何使用它。'
- en: Besides what has been said in the preceding example, the JWT's response also
    contains information about subjects/claims, a signed SHA256's generated token,
    and an expiration date. The important rule here is that you must be sure about
    the issuer of your token. You need to trust the content provided along with the
    response. It may sound complicated, but it is very simple in real-life applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面例子中提到的内容外，JWT的响应还包含有关主题/声明的信息、生成的签名SHA256令牌和过期日期。这里的重要规则是您必须确信您的令牌发行者。您需要信任随响应提供的内
    容。这可能听起来很复杂，但在实际应用中非常简单。
- en: The important thing is that you need to keep the token generated by JWT protected---this
    will be elaborated upon later in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，您需要保护由JWT生成的令牌——这一点将在本章后面详细说明。
- en: 'The flow is as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 流程如下：
- en: Our client's publishing app requests a token from our express's server.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的客户端发布应用程序从我们的express服务器请求令牌。
- en: The publishing backed app issues a token to the frontend Redux's app.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布后端应用程序向前端Redux应用程序发行令牌。
- en: After that, each time we fetch data from the backend, we check if a user has
    access to the requested resources on the backend--the resource consumes the token.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，每次我们从后端获取数据时，我们都会检查用户是否有权访问后端请求的资源——资源消耗令牌。
- en: In our case, the resource is a falcor-router's route, which has a close relationship
    with the backend, but this may work as well in more distributed platforms.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，资源是一个falcor-router的路由，它与后端有密切的关系，但这在更分散的平台上也同样适用。
- en: Remember that the JWT tokens are similar to private keys--you must keep them
    secure!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 记住JWT令牌类似于私钥——您必须确保它们的安全！
- en: Structure of JWT token
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JWT令牌的结构
- en: 'The header has information that is required on the backend for recognizing
    what cryptographic operation to do based on that information (metadata, the algorithms,
    and keys being used):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 头部包含后端需要的信息，以便根据该信息识别要执行的加密操作（元数据、使用的算法和密钥）：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In general, that part is done 100 percent out of the box for us, so we don't
    have to care about headers while implementing it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这部分对我们来说是100%自动完成的，所以我们实现时不需要关心头信息。
- en: 'The second part consists of claims provided in the JSON format, such as:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分由JSON格式提供的声明组成，例如：
- en: '**Issuer**: This lets us know who has issued the token'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发行者**：这让我们知道谁发行了令牌'
- en: '**Audience**: This lets us know that this token has to be consumed by our application'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受众**：这让我们知道这个令牌必须被我们的应用程序消耗'
- en: '**Issue date**: This lets us know when the token has been created'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发行日期**：这让我们知道令牌是在何时创建的'
- en: '**Expiration date**: This lets us know when the token is expiring so we have
    to generate a new one'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过期日期**：这让我们知道令牌何时过期，因此我们需要生成一个新的令牌'
- en: '**Subject**: This lets us know which part of the app can use the token (useful
    in bigger applications)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题**：这让我们知道应用中的哪个部分可以使用令牌（在更大的应用中很有用）'
- en: 'Besides these claims, we can create custom claims that are specifically defined
    by the app''s creator:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些声明之外，我们还可以创建由应用创建者特别定义的自定义声明：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: New MongoDB users collection
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的 MongoDB 用户集合
- en: 'We need to create a users'' collection in our database. The users will have
    privileges allowing them to:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在数据库中创建一个用户集合。用户将拥有以下权限：
- en: Add new articles in our publishing application
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的发布应用中添加新文章
- en: Edit existing articles in our publishing application
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的发布应用中编辑现有文章
- en: Delete articles in our publishing application
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除我们发布应用中的文章
- en: The first step is that we need to create a collection. You can do this from
    the GUI in Robomongo (introduced at the beginning of the book), but we will use
    the command line.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是我们需要创建一个集合。你可以从 Robomongo 的 GUI 中这样做（本书开头介绍），但我们将使用命令行。
- en: 'First of all we need to create a file called `initPubUsers.js`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个名为 `initPubUsers.js` 的文件：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then add the following content to `initPubUsers.js`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将以下内容添加到 `initPubUsers.js` 文件中：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Explanation
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 说明
- en: The SHA256 string, `c5a0df4e293953d6048e78bd9849ec0ddce811f0b29f72564714e474615a7852`,
    is the equivalent of a password, 123456, with a salt's string equal to `pubApp`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: SHA256 字符串，`c5a0df4e293953d6048e78bd9849ec0ddce811f0b29f72564714e474615a7852`，相当于一个密码，123456，其盐字符串等于
    `pubApp`。
- en: 'If you want to generate this salted password hash yourself, then go to [http://www.xorbin.com/tools/sha256-hash-calculator](http://www.xorbin.com/tools/sha256-hash-calculator)
    and type `123456pubApp` on their website. You will get the following screen:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要自己生成这个加盐密码散列，那么请访问 [http://www.xorbin.com/tools/sha256-hash-calculator](http://www.xorbin.com/tools/sha256-hash-calculator)
    并在他们的网站上输入 `123456pubApp`。你将得到以下屏幕：
- en: '![](img/00021.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00021.jpeg)'
- en: These steps are required only at the beginning. Later we need to program a registration
    form that is salting the password for our own.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤仅在开始时需要。之后我们需要编写一个注册表单，为我们的应用加盐密码。
- en: Importing the initPubUsers.js file into MongoDB
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 initPubUsers.js 文件导入 MongoDB
- en: 'After we have the correct content in our `initPubUsers.js` file, we can run
    a command line as follows in order to import the new `pubUsers` collection to
    our database:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `initPubUsers.js` 文件中正确的内容后，我们可以运行以下命令行来将新的 `pubUsers` 集合导入到数据库中：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You will get the same terminal output as what we we got after importing the
    article in [Chapter 1](part0021.html#K0RQ0-7870c13caa1244daa9bd53ca5c1e1a42),
    *Configuring Full-Stack with Node.js, Express.js, MongoDB, Mongoose, Falcor, and
    Redux*, looking similar to this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到与我们在 [第1章](part0021.html#K0RQ0-7870c13caa1244daa9bd53ca5c1e1a42) 中导入文章后相同的终端输出，*配置
    Node.js、Express.js、MongoDB、Mongoose、Falcor 和 Redux 全栈*，看起来像这样：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Working on the login's falcor-route
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在登录的 falcor-route 上工作
- en: Now we need to start working with the falcor-router in order to create a new
    endpoint that will use the JWT library to provide a unique token for the client-side
    app.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要开始使用 falcor-router 来创建一个新的端点，该端点将使用 JWT 库为客户端应用提供唯一的令牌。
- en: The first thing that we need to do is to provide `secret` on the backend.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是在后端提供 `secret`。
- en: 'Let''s create that `secret` endpoint''s config file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建那个 `secret` 端点的配置文件：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we need to put in the content of this `secret`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将此 `secret` 的内容放入其中：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In future, we will use environment variables on the production server, so the
    notation `process.env.JWT_SECRET || 'devSecretGoesHere'` means that the environment
    variable of `JWT_SECRET` doesn't exist so use default `secret` endpoint's `string,devSecretGoesHere`.
    At this point we don't need any development environment variables.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，我们将在生产服务器上使用环境变量，所以表示法 `process.env.JWT_SECRET || 'devSecretGoesHere'` 意味着
    `JWT_SECRET` 环境变量不存在，因此使用默认的 `secret` 端点的 `string,devSecretGoesHere`。在此阶段我们不需要任何开发环境变量。
- en: Creating a falcor-router's login (backend)
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 falcor-router 的登录（后端）
- en: In order to make our codebase more organized, instead of adding one more route
    to our `server/routes.js` file, we will make a new file called `routesSession.js`
    and in that file we will keep all the endpoints related to the current logged
    user's session.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的代码库更有组织性，我们不会在 `server/routes.js` 文件中添加更多路由，而是将创建一个名为 `routesSession.js`
    的新文件，并在该文件中保存所有与当前登录用户会话相关的端点。
- en: 'Make sure you are in the `server` directory:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你处于 `server` 目录：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'First open the `server.js` file in order to add one line of code that will
    allow you to post usernames and passwords to the backend. Add this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先打开 `server.js` 文件，添加一行代码，这将允许你将用户名和密码发送到后端。添加以下内容：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This has to be added under `app.use(bodyParser.json({extended: false}));` so
    you will end up with `server.js` code that begins as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '这需要在 `app.use(bodyParser.json({extended: false}));` 之下添加，这样你最终得到的 `server.js`
    代码将如下所示：'
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The last line is a new line that has to be added in order to make it work.
    Then create a new file in the same directory with:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要添加一行新行，以便使其正常工作。然后在同一目录下创建一个新文件，使用以下命令：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And put this initial content into the `routesSession.js` file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 并将以下初始内容放入 `routesSession.js` 文件中：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How the call routes work
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用路由的工作原理
- en: 'We have just created an initial call login route in the `routesSession.js`
    file. Instead of using a GET method, we are going to use a `''call''(**call: async
    (callPath, args) => **)`. That is the equivalent to POST in the old RESTful approach.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '我们刚刚在 `routesSession.js` 文件中创建了一个初始的调用登录路由。我们不是使用 GET 方法，而是使用 `''call''(**call:
    async (callPath, args) => **)`。这在旧的 RESTful 方法中相当于 POST。'
- en: 'The difference between the call and get methods in Falcor''s routes is that
    we can provide arguments with `args`. That allows us to get from the client-side
    the username and the password:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Falcor 路由中，调用方法和 get 方法之间的区别在于我们可以通过 `args` 提供参数。这允许我们从客户端获取用户名和密码：
- en: 'The plan is that after we receive credentials with this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 计划是在我们收到以下凭据后：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then we will check them against our database with one user admin. A user will
    need to know that the real plaintext password is `123456` in order to get a correct
    login JWTtoken:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将它们与我们的数据库中的一个用户 admin 进行比较。用户需要知道真实的明文密码是 `123456`，才能获取正确的登录 JWT 令牌：
- en: 'We also have prepared in this step a `userStatementQuery`---this will be used
    later when querying a database:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，我们还准备了一个 `userStatementQuery`——这将在稍后查询数据库时使用：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Separating the DB configs - configMongoose.js
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离数据库配置 - configMongoose.js
- en: 'We need to separate DB configs from `routes.js`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将数据库配置从 `routes.js` 中分离出来：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And its new content:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以及其新内容：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Explanation
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 说明
- en: 'We have just introduced the following new `env` variables: `MONGO_HOSTNAME`,
    `MONGO_PORT`, and `MONGO_ENV`. We will use them when preparing a production environment.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚引入了以下新的 `env` 变量：`MONGO_HOSTNAME`、`MONGO_PORT` 和 `MONGO_ENV`。当准备生产环境时，我们将使用它们。
- en: The `mongodb://${conf.hostname}:${conf.port}/${conf.env}` expression is using
    a templating feature available since EcmaScript6.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`mongodb://${conf.hostname}:${conf.port}/${conf.env}` 表达式正在使用自 EcmaScript6
    以来可用的模板功能。'
- en: The rest of `configMongoose.jsconfig` will be known to you, as we have introduced
    it in [Chapter 1](part0021.html#K0RQ0-7870c13caa1244daa9bd53ca5c1e1a42), *Configuring
    Full-Stack with Node.js, Express.js, MongoDB, Mongoose, Falcor, and Redux*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`configMongoose.jsconfig` 的其余部分你应该已经了解，因为我们已经在 [第 1 章](part0021.html#K0RQ0-7870c13caa1244daa9bd53ca5c1e1a42)
    中介绍了它，*使用 Node.js、Express.js、MongoDB、Mongoose、Falcor 和 Redux 配置全栈*。'
- en: Improving the routes.js file
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进 `routes.js` 文件
- en: After we have created two new files, `configMongoose.js` and `routesSession.js`,
    we have to improve our `server/routes.js` file in order to make everything work
    together.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建了两个新文件 `configMongoose.js` 和 `routesSession.js` 之后，我们必须改进我们的 `server/routes.js`
    文件，以便使所有内容协同工作。
- en: 'The first step is to delete from `routes.js` the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是从 `routes.js` 中删除以下代码：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Replace it with the following new code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下新代码替换它：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Also, we need to spread `sessionRoutes` into our current `PublishingAppRoutes`
    as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要按照以下方式将 `sessionRoutes` 展开到当前的 `PublishingAppRoutes` 中：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: At the beginning of `PublishingAppRoutes` you need to spread `...sessionRoutes`,
    `routes`, so the login route will be available to use across the Falcor's routes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PublishingAppRoutes` 的开始处，你需要展开 `...sessionRoutes` 和 `routes`，这样登录路由就可以在整个
    Falcor 路由中使用。
- en: Explanation
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 说明
- en: We got rid of the old code that was helping us to run the first Mongoose query
    that was fetching the articles, and we moved everything to `configMongoose` so
    that we can use it in different files around our project. We have also imported
    the session routes and later spread them with the `...` spread operation into
    the array called `PublishingAppRoutes`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经移除了帮助我们运行第一个 Mongoose 查询的旧代码，该查询用于获取文章，并将所有内容移动到 `configMongoose` 中，以便我们可以在项目的不同文件中使用它。我们还导入了会话路由，并在之后使用
    `...` 展开操作将它们扩展到名为 `PublishingAppRoutes` 的数组中。
- en: Checking to see if the app works before implementing JWT
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在实现 JWT 之前检查应用是否工作
- en: 'At this point, when doing `npm start`, the app should be working and showing
    the list of articles:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，当执行 `npm start` 时，应用程序应该正在运行并显示文章列表：
- en: '![](img/00022.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00022.jpeg)'
- en: 'When running with `npm start` you should get the following information, validating
    that everything works correctly:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `npm start` 运行时，你应该得到以下信息，以验证一切是否正常工作：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Creating a Mongoose users' model
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Mongoose 用户模型
- en: 'In the file `configMongoose.js` we need to create and export a `User` model.
    Add the following code to that file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `configMongoose.js` 中，我们需要创建并导出一个 `User` 模型。向该文件添加以下代码：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Explanation
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 说明
- en: The `userSchema` describes our user's JSON model. The user is our Mongoose's
    model that is pointing to the `pubUsers` collection in our MongoDB. At the end,
    we are exporting the `User` model by adding it to the export default's object.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`userSchema` 描述了我们的用户 JSON 模型。用户是我们指向 MongoDB 中 `pubUsers` 集合的 Mongoose 模型。最后，我们通过将其添加到
    `export default` 对象中导出 `User` 模型。'
- en: Implementing JWT in the routesSession.js file
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 `routesSession.js` 文件中实现 JWT
- en: 'The first step is to export our `User` model into `routesSession` scope by
    adding at the top of that file an `import` statement:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将我们的 `User` 模型导出到 `routesSession` 范围内，通过在该文件顶部添加一个 `import` 语句：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Install `jsonwebtoken` and `crypto` (for SHA256):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '安装 `jsonwebtoken` 和 `crypto` (用于 SHA256):'
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After you have installed `jsonwebtoken`, we need to import it to `routesSession.js`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 `jsonwebtoken` 后，我们需要将其导入到 `routesSession.js`：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After you have imported everything in the `routesSession`, continue on working
    with the `route: [''login'']`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '在 `routesSession` 中导入所有内容后，继续使用 `route: [''login'']`。'
- en: 'You need to improve `userStatementQuery`, so it will have the `saltedPassword`
    instead of plain text:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要改进 `userStatementQuery`，使其包含 `saltedPassword` 而不是纯文本：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So instead of plain text, we will query a salted SHA256 password.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不会查询纯文本，而是查询盐化的 SHA256 密码。
- en: 'Under this `userStatementQuery`, return Promise, with the following details:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `userStatementQuery` 下，返回 Promise，以下为详细信息：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Explanation
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 说明
- en: 'The `User.find` is a Promise that comes from Mongoose user''s model (that we
    created in `configMongoose.js`)--this is a standard method. Then as a first argument
    we provide `userStatementQuery` which is that filter''s object with the username
    and password in it: `(*{ username, password } = args[0];)`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`User.find` 是来自 Mongoose 用户模型的 Promise（我们在 `configMongoose.js` 中创建的）--这是一个标准方法。然后我们作为第一个参数提供
    `userStatementQuery`，这是一个包含用户名和密码的过滤器对象：`(*{ username, password } = args[0];)`.'
- en: 'Next, we provide a function that is a callback when the query is done: `(function(err,
    user) {)`. We count the amount of results with `if(result.length) {`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们提供一个函数，它是查询完成后调用的回调函数：`(function(err, user) {)`. 我们使用 `if(result.length)
    {}` 计算结果的数量。
- en: 'If `result.length=== 0` then we have mocked `return` statement, and we are
    getting the `else` code running with the following return:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `result.length=== 0`，那么我们模拟了 `return` 语句，并且正在执行以下 `else` 代码的返回：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you will learn later, we will ask for that token's path on the frontend, `['login',
    'token']`. In this case, we haven't found the correct username and the password
    provided so we return the `"INVALID"` string, instead of a JWT token. The path
    `['login', 'error']` is describing the error's type in more detail so that message
    can be shown to a user that has provided the invalid login credentials.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如你稍后所学，我们将在前端请求该令牌的路径，`['login', 'token']`。在这种情况下，我们没有找到正确的用户名和提供的密码，所以我们返回
    `"INVALID"` 字符串，而不是 JWT 令牌。路径 `['login', 'error']` 更详细地描述了错误类型，以便将消息显示给提供无效登录凭据的用户。
- en: Successful login on falcor-route
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 falcor-route 上成功登录
- en: 'We need to improve the successful login path. We have a case for handling an
    invalid login; we need to make a case that will handle a successful login, so
    replace this code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要改进成功的登录路径。我们有一个处理无效登录的情况；我们需要创建一个处理成功登录的情况，所以替换以下代码：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With this code that is returning the successful login''s details:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码返回成功登录的详细信息：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Explanation
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 说明
- en: As you can see, the only thing that we fetch from DB right now is the role `value
    === result[0].role`. We need to add this to hash, because we don't want our app
    to be vulnerable so a normal user can get an admin role with some hacking. The
    value of the token is calculated based on `userDetailsToHash = username+role`---that's
    enough for now.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们现在从数据库中获取的唯一东西是角色 `value === result[0].role`。我们需要将其添加到哈希中，因为我们不希望我们的应用程序容易受到攻击，以至于普通用户可以通过一些黑客手段获得管理员角色。令牌的值基于
    `userDetailsToHash = username+role` 计算---现在就足够了。
- en: 'After we are fine with this, the only thing that needs to be done on the backend
    is returning the paths with values:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对此满意之后，后端需要做的唯一一件事就是返回带有值的路径：
- en: The login token with `['login', 'token']`
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录令牌`['login', 'token']`
- en: The username with `['login', 'username']`
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名`['login', 'username']`
- en: The logged user's role with `['login', 'role']`
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录用户的角色`['login', 'role']`
- en: Information that there were no errors at all with `['login', 'error']`
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有错误发生的`['login', 'error']`信息
- en: The next step is to use this route on the frontend. Run the app and if everything
    is working fine, we can start coding on the frontend side.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在前端使用这个路由。运行应用，如果一切正常，我们就可以开始在前端进行编码了。
- en: Frontend side and Falcor
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端和Falcor
- en: 'Let''s create a new route for the login in our Redux application. In order
    to do that, we need to introduce the `react-router`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Redux应用中创建一个新的登录路由。为了做到这一点，我们需要引入`react-router`：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It's important to use the correct NPM's version otherwise things get broke!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要使用正确的NPM版本，否则事情会出错！
- en: 'After we have installed them, we need to add routes in `src`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 安装它们之后，我们需要在`src`中添加路由：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then make the content of this `index.js` file as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将此`index.js`文件的内容设置为以下内容：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: At this point, we are missing two components for our app called `CoreLayout`
    and `LoginView` (we will implement them in a minute).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们缺少两个应用组件，称为`CoreLayout`和`LoginView`（我们将在下一分钟实现它们）。
- en: The CoreLayout component
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心布局组件
- en: 'The `CoreLayout` component is the wrapper for our whole application. Create
    it by executing the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoreLayout`组件是我们整个应用的包装器。通过执行以下操作来创建它：'
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, populate it with the following content:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，用以下内容填充它：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you probably know, all the content of a current route will go into the `{this.props.children}`
    target (that is a `basicReact.JS` concept that you must know beforehand). We also
    created two links to our routes as a header.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，当前路由的所有内容都将进入`{this.props.children}`目标（这是一个你必须事先了解的`basicReact.JS`概念）。我们还创建了两个链接到我们的路由作为标题。
- en: The LoginView component
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录视图组件
- en: 'For the time being, we will create a mocked `LoginView` component. Let''s create
    the `views` directory:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将创建一个模拟的`LoginView`组件。让我们创建`views`目录：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The content of the `LoginView.js` file is shown in the following code with
    the `FORM GOES HERE` placeholder:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了`LoginView.js`文件的内容，其中包含`FORM GOES HERE`占位符：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We are done with all the missing pieces for the `routes/index.js`, but there
    is some other outstanding stuff to do before our app with the routing will start
    working.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了`routes/index.js`中所有缺失的部分，但在我们的路由应用开始工作之前，还有一些其他待办事项。
- en: A root's container for our app
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们应用的根容器
- en: 'Because our app is getting more complicated, we need to create a container
    that it will live in. In order to do that, let''s do the following in the `src`
    location:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的应用变得越来越复杂，我们需要创建一个容器，它将生活在这个容器中。为了做到这一点，让我们在`src`位置执行以下操作：
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `Root.js` is going to be our main root file. The content of this file is
    as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Root.js`将成为我们的主要根文件。此文件的内容如下：'
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: For now it's only a simple container, but later we will implement into it more
    features for debugging, hot reloading, and so on. The `noQueryKeyHistory` is saying
    to the router, that we don't want to have any random strings in our URL so our
    routes will be looking nicer (not a big deal, you can change the false flag to
    true, to see what I am talking about).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 目前它只是一个简单的容器，但稍后我们将实现更多功能，如调试、热重载等。`noQueryKeyHistory`告诉路由器，我们不希望在URL中包含任何随机字符串，因此我们的路由将看起来更美观（这不是什么大问题，你可以将false标志更改为true，看看我在说什么）。
- en: Remaining configuration for configureStore and rootReducer
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: configureStore和rootReducer的剩余配置
- en: 'Let''s create `rootReducer` first. Why do we need it? Because in bigger applications
    you always end up with many different reducers; for example, in our app we will
    have reducers such as:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建`rootReducer`。为什么我们需要它？因为在更大的应用中，你总是会遇到许多不同的还原器；例如，在我们的应用中，我们将有如下的还原器：
- en: '**Article''s reducer**: Which keeps stuff related to articles (`RETURN_ALL_ARTICLES`
    and so on)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文章还原器**：它保留与文章相关的信息（`RETURN_ALL_ARTICLES`等）'
- en: '**Session''s reducer**: Which will be related to our users'' sessions (`LOGIN`,
    `REGISTER`, and so on)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话还原器**：这将与我们的用户会话（`LOGIN`、`REGISTER`等）相关'
- en: '**Editor''s reducer**: Which will be related to the editor''s actions (`EDIT_ARTICLE`,
    `DELETE_ARTICLE`, `ADD_NEW_ARTICLE`, and so on)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑器还原器**：它将与编辑器的操作（`EDIT_ARTICLE`、`DELETE_ARTICLE`、`ADD_NEW_ARTICLE`等）相关'
- en: '**Routing''s reducer**: This will manage the state of our routes (out-of-the-box,
    because it is managed by the redux-simple-router''s external lib)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由的 reducer**：这将管理我们路由的状态（开箱即用，因为它由 redux-simple-router 的外部库管理）'
- en: 'Let''s create an `index.js` file in our `reducers` directory:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `reducers` 目录中创建一个 `index.js` 文件：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The content for the `index.js` is as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.js` 文件的内容如下：'
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The new thing here is that we are introducing a `combineReducers` function from
    Redux. This is exactly what I've written before. We will have more than one reducer---in
    our case, we have also introduced the `routeReducer` from a redux-simple-router's
    library.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里新引入的是来自 Redux 的 `combineReducers` 函数。这正是我之前写过的。我们将有多个 reducer——在我们的例子中，我们还从
    `redux-simple-router` 库中引入了 `routeReducer`。
- en: 'The next step is to create the `configureStore` that will be managing our stores
    and also in order to implement a server rendering later in this book:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建 `configureStore`，它将管理我们的存储，并在本书后面实现服务器端渲染：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The content for the `configureStore.js` file is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`configureStore.js` 文件的内容如下：'
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding code, we are importing the `rootReducer` that we've created
    recently. We also import the `redux-thunk` lib which is very useful for server-side
    rendering (described later in the book).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在导入我们最近创建的 `rootReducer`。我们还导入了 `redux-thunk` 库，这个库对于服务器端渲染非常有用（本书后面将描述）。
- en: At the end, we export a store which is composed of many different reducers (currently
    routing and the article's reducer that you can find in `reducer/index.js`) and
    is able to handle the server-rendering initial state.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们导出一个由许多不同的 reducer 组成的 store（目前是路由和您可以在 `reducer/index.js` 中找到的文章的 reducer），并且能够处理服务器端渲染的初始状态。
- en: Last tweaks in layouts/PublishingApp.js before running the app
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用前在 layouts/PublishingApp.js 中的最后微调
- en: The last thing that changed in our app is that we have out-of-date code in our
    publishing app.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用中最后更改的是，我们的发布应用中有过时的代码。
- en: 'Why is it outdated? Because we have introduced `rootReducer` and `combineReducers`.
    So if you check your code in the rendering of `PublishingApp` here, it won''t
    work:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它会过时？因为我们引入了 `rootReducer` 和 `combineReducers`。所以如果您检查 `PublishingApp` 的渲染代码，它将不会工作：
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You need to change it to this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将其更改为以下内容：
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Do you see the difference? The old `for(let articleKey in this.props)` has
    changed into `for(let articleKey in this.props.article)` and `this.props[articleKey]`
    has changed to `this.props.article[articleKey]`. Why? I will recall again: now
    every new reducer will be available in our app via its name created in `routes/index.js`.
    We have named our reducer article, so we now had to add this into `this.props.article`
    to make this stuff work together.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您看到区别了吗？旧的 `for(let articleKey in this.props)` 已更改为 `for(let articleKey in this.props.article)`，而
    `this.props[articleKey]` 已更改为 `this.props.article[articleKey]`。为什么？我会再次提醒：现在每个新的
    reducer 都将通过在 `routes/index.js` 中创建的名称在我们的应用中可用。我们命名了我们的 reducer 为 article，所以我们现在必须将其添加到
    `this.props.article` 中以使这些功能协同工作。
- en: Last changes in src/app.js before running the app
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用前 src/app.js 的最后更改
- en: 'The last thing is to improve the `src/app.js` so it will use the root''s container.
    We need to change the old code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事情是改进 `src/app.js`，使其使用根容器。我们需要更改旧代码：
- en: '[PRE46]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We need to change the preceding code to the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将前面的代码更改为以下内容：
- en: '[PRE47]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We start using the `Root` instead of the `Provider` directly, and we need to
    send the store and history's props to the `Root` component. The `***export const
    store = configureStore(window.__INITIAL_STATE__)***` part is here for the server-side
    rendering which we will add in one of the following chapters. We also use the
    history's library to manage the browser's history with the JavaScript.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始直接使用 `Root` 而不是 `Provider`，并且我们需要将 store 和 history 的属性发送到 `Root` 组件。`***export
    const store = configureStore(window.__INITIAL_STATE__)***` 这部分是为了服务器端渲染，我们将在接下来的章节中添加。我们还使用
    history 库用 JavaScript 管理浏览器的历史记录。
- en: Screenshots of our running app
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们运行应用的截图
- en: Currently when you do `npm start` then you will see the following two routes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 目前当您执行 `npm start` 时，您将看到以下两个路由。
- en: Home page
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首页
- en: '![](img/00023.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00023.jpeg)'
- en: Login view
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录视图
- en: '![](img/00024.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00024.jpeg)'
- en: Working on the login form that will call the backend in order to authenticate
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正在处理登录表单，该表单将调用后端以进行身份验证
- en: Okay, so we have done a lot of preparation in terms of having an extensible
    project structure (`routes`, `rootReducer`, `configStores`, and so on).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们在项目结构可扩展性方面做了很多准备工作（`routes`、`rootReducer`、`configStores` 等）。
- en: 'In order to make our app nicer from a user perspective, we will start using
    Material Design CSS. For making our work easier with forms, we will start using
    a `formsy-react` library. Let''s install it:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从用户的角度使我们的应用看起来更美观，我们将开始使用Material Design CSS。为了使我们的表单工作更轻松，我们将开始使用`formsy-react`库。让我们来安装它：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: At the time of writing this book, the version .20.14.4 of Material UI is the
    best choice; I used this version because the ecosystem is changing so quickly
    that it's better to mark the used version in here so you won't have any surprises
    when following the instructions in this book.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Material UI的版本.20.14.4是最好的选择；我使用这个版本是因为生态系统变化非常快，所以最好在这里标记所使用的版本，这样你在遵循本书中的说明时就不会有任何惊喜。
- en: The `formsy-react` library is a very handy library which will help us to validate
    our forms in the publishing app. We will use it on pages like login and registration
    as you will see on the next pages.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`formsy-react`库是一个非常实用的库，它将帮助我们验证发布应用中的表单。我们将在登录和注册等页面上使用它，正如你将在下一页看到的那样。'
- en: Working on LoginForm and DefaultInput components
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`LoginForm`和`DefaultInput`组件上工作
- en: 'After we are done with installing our new dependencies, let''s create a folder
    that will keep files related to dumb components (the components that don''t have
    access to any stores; they communicate with the other parts of our application
    with the help of callbacks---you will learn more about this later):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成安装新的依赖项后，让我们创建一个文件夹，用于保存与无状态组件（没有访问任何存储的组件；它们通过回调与我们的应用的其他部分进行通信---你将在稍后了解更多关于这个的信息）相关的文件：
- en: '[PRE49]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then make the content of this file as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使这个文件的内容如下：
- en: '[PRE50]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Explanation
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 说明
- en: The `{HOC}` from `formsy-react` is another way of decorating the component (aka
    `mixin` in React's ECMAScript5) with export default `HOC(DefaultInput)`--you can
    find more information about this at [https://github.com/christianalfoni/formsy-react/blob/master/API.md#formsyhoc](https://github.com/christianalfoni/formsy-react/blob/master/API.md#formsyhoc).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`formsy-react`中的`{HOC}`是装饰组件（在React的ECMAScript5中称为`mixin`）的另一种方式，导出默认的`HOC(DefaultInput)`--你可以在[https://github.com/christianalfoni/formsy-react/blob/master/API.md#formsyhoc](https://github.com/christianalfoni/formsy-react/blob/master/API.md#formsyhoc)找到更多关于这个的信息。'
- en: 'We are also using the `TextField` from the `material-ui`; then it takes different
    properties. The following are the properties:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在使用来自`material-ui`的`TextField`；它具有不同的属性。以下是一些属性：
- en: '`ref`: We want `ref` for each input with its name (username and e-mail).'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ref`: 我们希望为每个输入项都提供一个带有其名称（用户名和电子邮件）的`ref`。'
- en: '`floatingLabelText`: This is a nice looking floating text (known as label).'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`floatingLabelText`: 这是一个看起来很不错的浮动文本（也称为标签）。'
- en: '`onChange`: This tells the function''s name that has to be called when someone
    is typing into the TextField.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onChange`: 这告诉函数的名称，当有人正在TextField中输入时必须调用该函数。'
- en: '`required`: This helps us to manage the required inputs in our form.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`required`: 这有助于我们管理表单中的必填输入项。'
- en: '`value`: This is, of course, the current value of our TextField.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`: 当然，这是我们的TextField的当前值。'
- en: '`defaultValue`: This is a value that is initial. It is very important to remember
    that it''s called just once when a component is calling a constructor of the component.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultValue`: 这是一个初始值。非常重要的一点是，当组件调用组件的构造函数时，它只被调用一次。'
- en: The current text (`this.state.currentText`) is the value of the `DefaultInput`
    component---it changes with the new value on every `changeValue` event called
    by the callback given in the `TextFieldonChange` prop.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的文本(`this.state.currentText`)是`DefaultInput`组件的值---它会在每次由`TextFieldonChange`属性中提供的回调函数触发的`changeValue`事件上改变。
- en: LoginForm and making it work with LoginView
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建`LoginForm`并使其与`LoginView`一起工作
- en: 'The next step is to create `LoginForm`. This will use the `DefaultInput` component
    with the following commands:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建`LoginForm`。这将使用`DefaultInput`组件，以下是一些命令：
- en: '[PRE51]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then the content of our `src/components/LoginForm.js` file is as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的`src/components/LoginForm.js`文件的内容如下：
- en: '[PRE52]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the preceding code, we have our `LoginForm` component that is using the `DefaultInput`'s
    component. It's a simple `React.js` form that after being submit calls the `this.props.onSubmit`--this
    `onSubmit` function will be defined in `src/views/LoginView.js` smart component
    in a moment. I won't talk too much about attached styles on the component because
    it's up to you how you will style it--you will see a screenshot of applied styles
    of our app in a moment.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有使用`DefaultInput`组件的`LoginForm`组件。这是一个简单的`React.js`表单，在提交后调用`this.props.onSubmit`--这个`onSubmit`函数将在稍后的`src/views/LoginView.js`智能组件中定义。我不会过多地谈论组件上的附加样式，因为这取决于您如何进行样式设计--您将很快看到我们应用所应用的样式的截图。
- en: Improving the src/views/LoginView.js
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进`src/views/LoginView.js`
- en: The last part at our development at this stage before running our application
    is to improve the `LoginView` component.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行应用程序之前，当前开发阶段的最后一部分是改进`LoginView`组件。
- en: 'In `src/views/LoginView.js` make the following changes. Import our new `LoginForm`
    component:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/views/LoginView.js`中做出以下更改。导入我们新的`LoginForm`组件：
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then after you are done with imports and constructors, you need a new function
    called `login`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在您完成导入和构造函数之后，您需要一个名为`login`的新函数：
- en: '[PRE54]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: At this point, the `login` function only prints our new JWT token to the console--it's
    enough for now; later we will build more on top of it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，`login`函数只将我们的新JWT令牌打印到控制台--现在足够了；稍后我们将在此基础上构建更多功能。
- en: 'The last step here is to improve our `render` function from:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的最后一步是改进我们的`render`函数：
- en: '[PRE55]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To the new one, as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对新的方法，如下所示：
- en: '[PRE56]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Great! Now we are done! The following is what you will see after running `npm
    start` and running it in your browser:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们已经完成了！以下是在运行`npm start`并在浏览器中运行它后您将看到的内容：
- en: '![](img/00025.jpeg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00025.jpeg)'
- en: 'As you can see in the browser''s console, we can see the submitted credential''s
    object `(credentials Object {username: "admin", password: "123456"})` and also
    a token that has been fetched from the backend `(tokenRes eyJhbGciOiJIUzI1NiJ9.YWRtaW5hZG1pbg.NKmrphxbqNcL_jFLBdTWGM6Y_Q78xks5E2TxBZRyjDA)`.
    All this tells us that we are on track in order to implement the login''s mechanism
    in our publishing application.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '如您在浏览器控制台中所见，我们可以看到提交的凭据对象`(credentials Object {username: "admin", password:
    "123456"})`以及从后端获取的令牌`(tokenRes eyJhbGciOiJIUzI1NiJ9.YWRtaW5hZG1pbg.NKmrphxbqNcL_jFLBdTWGM6Y_Q78xks5E2TxBZRyjDA)`。所有这些都告诉我们，我们在实现发布应用程序的登录机制方面正在按计划进行。'
- en: Important
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: If you get an error, then make sure that you have used the `123456` password
    while creating the hash. Otherwise, type in the custom password that is valid
    to your case.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到错误，请确保在创建哈希时使用了`123456`密码。否则，输入适用于您情况的自定义密码。
- en: Making DashboardView's component
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作DashboardView组件
- en: 'At this point, we have a login feature that is not finished, but before continuing
    the work on it, let''s create a simple `src/views/DashboardView.js` component
    that will be shown after a successful login:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个未完成的登录功能，但在继续工作之前，让我们创建一个简单的`src/views/DashboardView.js`组件，该组件将在成功登录后显示：
- en: '[PRE57]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Add some simple content as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下简单内容：
- en: '[PRE58]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is a simple component, which is static at this point. Later, we will build
    more features into it.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的组件，目前是静态的。稍后，我们将将其构建得更加完善。
- en: 'The last thing regarding the dashboards that we need to create is a new route
    in the `src/routes/index.js` file:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 关于仪表板，我们需要在`src/routes/index.js`文件中创建的最后一件事情是添加一个新的路由：
- en: '[PRE59]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We've just added second route using the react-router's config. It uses `DashboardView`
    component located in `../views/DashboardView` file.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用react-router的配置添加了第二个路由。它使用位于`../views/DashboardView`文件的`DashboardView`组件。
- en: Finishing the login's mechanism
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成登录机制
- en: 'The last improvements for login at this point of our publishing app remain
    at the `src/views/LoginView.js` location:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们发布应用程序的这个阶段，对登录的最后改进仍然位于`src/views/LoginView.js`位置：
- en: 'First of all, let''s add handling an invalid login:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加处理无效登录的方法：
- en: '[PRE60]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We have added this `if(tokenRes === ''INVALID'')` in order to update the error
    state with `this.setState({error: errorRes})`.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '我们添加了`if(tokenRes === ''INVALID'')`这个条件，以便用`this.setState({error: errorRes})`更新错误状态。'
- en: 'The next step is to add into the `render` function `Snackbar` that will show
    to the user a type of error. At the top of the `LoginView` component add this
    import:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将`Snackbar`添加到`render`函数中，以便向用户显示错误类型。在`LoginView`组件的顶部添加以下导入：
- en: '[PRE61]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then you need to update the `render` function as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您需要更新`render`函数如下：
- en: '[PRE62]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'So after adding it, the `render` function will look like this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在添加之后，`render`函数将看起来像这样：
- en: '[PRE63]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `SnackBar onRequestClose` is required here otherwise you will get a warning
    in the developer's console from the Material UI. Okay, so we are handling login's
    error, now let's work on successful logins.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`SnackBar onRequestClose`在这里是必需的，否则你将在开发者的控制台中收到警告。好的，所以我们正在处理登录错误，现在让我们来处理成功的登录。'
- en: Handling successful logins in the LoginView's component
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在LoginView组件中处理成功的登录
- en: 'For handling a successful token''s backend responses add the login function:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理成功的令牌的后端响应，添加登录函数：
- en: '[PRE64]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'A new code for handling correct responses, as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 处理正确响应的新代码，如下所示：
- en: '[PRE65]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Explanation
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 说明
- en: 'After we know that the `tokenRes` is not `INVALID` and it''s not undefined
    (otherwise shows a fatal error to the user), then we follow certain steps:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们知道`tokenRes`不是`INVALID`并且它不是未定义的（否则向用户显示致命错误）之后，我们遵循以下步骤：
- en: 'We are fetching the username from the Falcor''s model `(await falcorModel.getValue(''login.username''))`.
    We are fetching the user''s role `(await falcorModel.getValue(''login.role''))`.
    Then we save all the known variables from the backend into `localStoragewith`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从Falcor的模型中获取用户名`(await falcorModel.getValue('login.username'))`。我们获取用户的角色`(await
    falcorModel.getValue('login.role'))`。然后我们将所有已知的变量从后端保存到`localStoragewith`：
- en: '[PRE66]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: At the same end we are sending our user to the `/dashboard` route with the use
    of `this.props.history.pushState(null, '/dashboard')`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一端，我们使用`this.props.history.pushState(null, '/dashboard')`将用户发送到`/dashboard`路由。
- en: A few important notes about DashboardView and security
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于DashboardView和安全的几个重要注意事项
- en: At this point, we won't secure `DashboardView` as there isn't any important
    stuff to secure---we will do it later when we put more assets/features into this
    route, which at the end of our book will be an editor's dashboard that will give
    control over all articles in the system.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们不会对`DashboardView`进行安全设置，因为没有需要保护的重要内容——我们将在将更多资产/功能放入这个路由时进行，到本书的结尾，这个路由将是一个编辑仪表板，将控制系统中所有文章。
- en: The only remaining step for us is to make it a `RegistrationView` component.
    This route will also be available for everyone at this point. Later in the book,
    we will make a mechanism so that only the main admin will be able to add new editors
    into the system (and manage them).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们剩下的唯一一步是将它变成一个`RegistrationView`组件。到这个时候，这个路由也将对每个人开放。在本书的后面部分，我们将创建一个机制，使得只有主管理员才能将新编辑添加到系统中（并管理他们）。
- en: Starting work on the new editor's registration
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始新的编辑注册工作
- en: 'In order to wrap up the registration, let''s first make some changes in our
    user''s scheme from Mongoose''s config file at the location `server/configMongoose.js`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成注册，让我们首先在我们的用户方案中做一些更改，这些更改位于Mongoose的配置文件`server/configMongoose.js`的位置：
- en: '[PRE67]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To the new scheme as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下新方案：
- en: '[PRE68]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As you can see, we have added unique indexes to the `username` and the `email`
    fields. Also, we have added a default value for a role, as any next user in our
    collection will be an editor (not an admin).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们已经在`username`和`email`字段上添加了唯一索引。我们还为角色添加了一个默认值，因为在我们集合中的下一个用户将是一个编辑（而不是管理员）。
- en: Adding register's falcor-route
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加注册的falcor-route
- en: 'In the file located at `server/routesSession.js`, you need to add a new route
    (next to the login''s route):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在位于`server/routesSession.js`的文件中，你需要添加一个新的路由（在登录路由旁边）：
- en: '[PRE69]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: What this code is actually doing is simply receiving the new user's object from
    the frontend via `const newUserObj = args[0]`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码实际上只是通过`const newUserObj = args[0]`从前端接收新用户的对象。
- en: 'Then we are salting the password that we will store in our database:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们对将要存储在我们数据库中的密码进行加盐处理：
- en: '[PRE70]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then we are creating a new user model from Mongoose via `const newUser = new
    User(newUserObj)`, because the `newUser` variable is a new model (not saved yet)
    of the user. Next we need to save it with this code:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过`const newUser = new User(newUserObj)`从Mongoose创建一个新的用户模型，因为`newUser`变量是用户的新模型（尚未保存）。接下来我们需要用以下代码保存它：
- en: '[PRE71]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: After it's saved into the db and the Promise has been resolved, we are managing
    an invalid entry to the db first by making the Mongoose result's object into a
    simple JSON structure with `const newUserDetail = newRes.toObject();`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在它被保存到数据库并且Promise被解决之后，我们首先通过将Mongoose结果的对象转换成一个简单的JSON结构`const newUserDetail
    = newRes.toObject();`来管理数据库中的无效条目。
- en: 'And after we are done with it, then we are returning an `INVALID` information
    to the Falcor''s model:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 完成之后，我们将向Falcor的模型返回一个`INVALID`信息：
- en: '[PRE72]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'So, we are done with handling an invalid user registration from Falcor. The
    next step is to replace this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经处理了来自Falcor的无效用户注册。下一步是替换以下内容：
- en: '[PRE73]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Explanation
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 说明
- en: We need to cast our new user's ID into the string, `newUserId = newUserDetail._id.toString()`
    (otherwise it will break the code).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将新用户的ID转换为字符串，`newUserId = newUserDetail._id.toString()`（否则代码会出错）。
- en: As you can see, we have a standard return statement that complements the model
    in Falcor.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们有一个标准的返回语句，它补充了Falcor中的模型。
- en: 'To quickly recall, after it returns correctly on the backend, we will be able
    to request this value on the frontend as follows: `const newUserId = await falcorModel.getValue([''register'',
    ''newUserId'']);` (this is just an example of how to fetch this new `UserId` on
    the client-side--don''t write it into your code, we will do it in a minute).'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速回顾，在它正确返回后端之后，我们将在前端以如下方式请求此值：`const newUserId = await falcorModel.getValue(['register',
    'newUserId']);`（这只是一个如何在客户端获取这个新的`UserId`的示例——不要将其写入你的代码中，我们将在一会儿做这个操作）。
- en: You will get used to it after few more examples.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个更多示例之后，你会习惯它的。
- en: Frontend implementation (RegisterView and RegisterForm)
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端实现（注册视图和注册表单）
- en: 'Let''s first create a component that will manage on the frontend, the register''s
    form with the following actions:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个组件，它将在前端管理注册表单，以下是一些操作：
- en: '[PRE74]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The content of that file will be:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件的内容将是：
- en: '[PRE75]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The preceding registration component is creating a form exactly the same way
    as on `LoginForm`. After a user clicks the `Register` button, it sends a callback
    to the `src/views/RegisterView.js` component (we will create this in a moment).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的注册组件创建了一个与`LoginForm`中完全相同的表单。当用户点击`注册`按钮时，它向`src/views/RegisterView.js`组件发送一个回调（我们将在一会儿创建这个组件）。
- en: Remember that in the components' directory we keep only DUMB components so all
    the communication with the rest of the app must to be done via callbacks like
    in this example.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在组件目录中我们只保留简单的组件，所以与整个应用的其余部分的通信必须通过回调函数来完成，就像这个例子一样。
- en: RegisterView
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册视图
- en: 'Let''s create a `RegisterView` file:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`RegisterView`文件：
- en: '[PRE76]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Its content is:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 其内容如下：
- en: '[PRE77]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: These are standard things that we use in our smart components (we need `falcorModel`
    in order to communicate with the backend and `mapStateToProps` and `mapDispatchToProps`
    in order to communicate with our Redux's store/reducer).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们智能组件中使用的标准事物（我们需要`falcorModel`来与后端通信，以及`mapStateToProps`和`mapDispatchToProps`来与我们的Redux的store/reducer通信）。
- en: 'Okay, that''s not all for the register view; next let''s add a component:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，注册视图的内容还不止这些；接下来让我们添加一个组件：
- en: '[PRE78]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'As you can see, the `async register (newUserModel)` function is asynchronous
    and friendly to the awaits. Next we are just logging into the console what a user
    has submitted with `console.info("newUserModel", newUserModel)`. After that, we
    query the falcor-router with a call:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`async register (newUserModel)`函数是异步的，并且对`await`友好。接下来，我们只是在控制台中使用`console.info("newUserModel",
    newUserModel)`记录用户提交的内容。之后，我们通过调用查询falcor-router：
- en: '[PRE80]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'After we have called the router, we fetch the response with:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用路由器之后，我们使用以下方式获取响应：
- en: '[PRE81]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Depending on the response from the backend, we do the following:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 根据后端的响应，我们执行以下操作：
- en: 'For `INVALID` we are fetching and setting error message into the component''s
    state (`this.setState({error: errorRes}))`'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '对于`INVALID`，我们在组件的状态中获取并设置错误信息（`this.setState({error: errorRes})`）。'
- en: If the user has registered correctly, then we have their new ID and we are asking
    the user to login with the history's push state `(this.props.history.pushState(null,
    '/login');)`
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户注册正确，那么我们就有了他们的新ID，并且我们要求用户使用历史记录的push状态`(this.props.history.pushState(null,
    '/login');)`进行登录。
- en: 'We didn''t create a route inside `routes/index.js` for `RegisterView` and there
    is no link in `CoreLayout` so our user is unable to use it. Add new imports in
    `routes/index.js`:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`routes/index.js`中没有为`RegisterView`创建路由，并且在`CoreLayout`中也没有链接，所以我们的用户无法使用它。在`routes/index.js`中添加新的导入：
- en: '[PRE82]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Then add a route, so the export default from `routes/index.js` will look like
    this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加一个路由，所以`routes/index.js`中的导出默认值将看起来像这样：
- en: '[PRE83]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'And finally, add a link inside the `src/layoutsCoreLayout.js` file''s `render`
    method:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`src/layoutsCoreLayout.js`文件中的`render`方法内添加一个链接：
- en: '[PRE84]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'At this point ,we should be able to register with this form:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该能够使用此表单进行注册：
- en: '![](img/00026.jpeg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00026.jpeg)'
- en: Summary
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In the next chapter, we will start working on the server-side rendering of our
    app. This means that on each request to our Express's server, we will generate
    the HTML markup based on the request from the client side. That feature is very
    useful for apps like ours where the speed of web loading is very important for
    such users as ours.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始着手我们应用的服务器端渲染。这意味着在每次向我们的Express服务器发送请求时，我们将根据客户端的请求生成HTML标记。这个特性对我们这样的应用非常有用，因为我们这类用户对网页加载速度的要求非常高。
- en: You can imagine that most of the news sites are for entertainment and that means
    a short attention span from our potential users. The speed of loading is important.
    There are also some opinions that the server-side rendering also helps for search
    engine optimization reasons.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象，大多数新闻网站都是为了娱乐，这意味着我们潜在用户的注意力集中时间较短。加载速度很重要。还有一些观点认为，服务器端渲染也有助于搜索引擎优化的原因。
- en: The crawlers have easier ways to *read* the text from our article as they don't
    need to execute the JavaScript in order to fetch it from the server (in comparison
    to non-server-side rendering single-page apps).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 爬虫有更简单的方式来*读取*我们文章中的文本，因为它们不需要执行服务器端的JavaScript来从服务器获取它（与不使用服务器端渲染的单页应用相比）。
- en: 'At least one thing is certain: if you have a server-side rendering on your
    articles'' publishing app then Google may see that you care about the fast loading
    of your app and so it will probably give you some disadvantage over full single-page
    websites that don''t care about server-side rendering.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有一点是确定的：如果你在你的文章发布应用中实现了服务器端渲染，那么谷歌可能会认为你关心你应用的快速加载，因此它可能会给你带来一些优势，相对于那些不关心服务器端渲染的完整单页网站。
