- en: Chapter 2. The Building Blocks of an Angular 2 Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。Angular 2应用程序的构建模块
- en: In the previous chapter, we looked at the drivers for the design decisions behind
    Angular 2\. We described the main reasons that led to the development of a brand
    new framework; Angular 2 takes advantage of web standards while keeping the past
    lessons in mind. Although we are familiar with the main drivers, we still haven't
    described the core Angular 2 concepts. The last major release of the framework
    took a different path from AngularJS 1.x and introduced a lot of changes in the
    fundamental building blocks used for the development of single-page applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看了Angular 2设计决策背后的驱动因素。我们描述了导致开发全新框架的主要原因；Angular 2利用了Web标准，同时牢记过去的经验教训。尽管我们熟悉主要的驱动因素，但我们仍未描述核心Angular
    2概念。框架的上一个主要版本与AngularJS 1.x走了不同的道路，并在用于开发单页面应用程序的基本构建模块中引入了许多变化。
- en: In this chapter, we'll look at the framework's core and make a brief introduction
    to the main components of Angular 2\. Another important purpose of this chapter
    is to take an overview of how these concepts can be put together to help us build
    professional user interfaces for our web applications. The following sections
    will give us an overview of everything that we are going to take a look at in
    more detail later in the book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究框架的核心，并简要介绍Angular 2的主要组件。本章的另一个重要目的是概述这些概念如何组合在一起，以帮助我们为Web应用程序构建专业的用户界面。接下来的几节将概述我们将在本书后面更详细地研究的所有内容。
- en: 'In this chapter, we''re going to look at:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到：
- en: A conceptual overview of the framework, showing how different concepts relate
    to each other.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个框架的概念概述，展示不同概念之间的关系。
- en: How we can build a user interface as a composition of components.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何将用户界面构建为组件的组合。
- en: What path the directives took in Angular 2, and how their interface changed
    compared to the previous major version of the framework.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 2中指令的路径以及它们与框架先前主要版本相比的接口发生了怎样的变化。
- en: The reasons for the enforced separation of concerns, which led to the decomposition
    of the directives into two different components. In order to get better sense
    of these two concepts, we're going to demonstrate basic syntax for their definition.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导致指令分解为两个不同组件的关注点分离的原因。为了更好地理解这两个概念，我们将演示它们定义的基本语法。
- en: An overview of the improved change detection, and how it involves the context
    that directives provide.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进的变化检测概述，以及它如何涉及指令提供的上下文。
- en: What zones are, and why they can make our daily development process easier.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是zone，以及为什么它们可以使我们的日常开发过程更容易。
- en: What pipes are, and how are they related to the AngularJS 1.x filters.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道是什么，以及它们与AngularJS 1.x的过滤器有什么关系。
- en: The brand-new **dependency injection** (**DI**) mechanism in Angular 2 and how
    it is related to the service component.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 2中全新的**依赖注入**（**DI**）机制以及它与服务组件的关系。
- en: A conceptual overview of Angular 2
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 2的概念概述
- en: 'Before we dive into different parts of Angular 2, let''s get a conceptual overview
    of how everything fits together. Let''s have a look at the following diagram:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究Angular 2的不同部分之前，让我们先概述一下它们如何相互配合。让我们看一下下面的图表：
- en: '![A conceptual overview of Angular 2](../images/00003.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![Angular 2的概念概述](../images/00003.jpeg)'
- en: Fig. 1
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图1
- en: '*Fig. 1* to *Fig. 4* shows the main Angular 2 concepts and the connections
    between them. The main purpose of these diagrams is to illustrate the core blocks
    for building single-page applications with Angular 2, and their relations.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1*至*图4*显示了主要的Angular 2概念及它们之间的连接。这些图表的主要目的是说明使用Angular 2构建单页面应用程序的核心模块及其关系。'
- en: The **Component** is the main building block we're going to use to create the
    user interface of our applications with Angular 2\. The Component is a direct
    successor of the Directive, which is the primitive for attaching behavior to the
    DOM. Components extend **Directives** by providing further features, such as a
    view with an attached template, which can be used for rendering composition of
    directives. Inside the template of the view can reside different expressions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件**是我们将用来使用Angular 2创建应用程序用户界面的主要构建块。组件是指令的直接后继，指令是将行为附加到DOM的原始方法。组件通过提供进一步的功能（例如附加模板的视图）来扩展**指令**，该模板可用于呈现指令的组合。视图模板中可以包含不同的表达式。'
- en: '![A conceptual overview of Angular 2](../images/00004.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Angular 2的概念概述](../images/00004.jpeg)'
- en: Fig. 2
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图2
- en: The preceding diagram illustrates conceptually the **Change Detection** mechanism
    of Angular 2\. It runs the `digest` loop, which evaluates the registered expressions
    in the context of specific UI components. Since the concept of scope has been
    removed from Angular 2, the execution context of the expressions are the controllers
    of the components associated with them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表概念上说明了Angular 2的**变更检测**机制。它运行`digest`循环，评估特定UI组件上下文中注册的表达式。由于Angular 2中已经移除了作用域的概念，表达式的执行上下文是与其关联的组件的控制器。
- en: The **Change Detection** mechanism can be enhanced using **Differs**; that's
    why there's a direct relation between these two elements on the diagram.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**变更检测**机制可以通过**Differs**进行增强；这就是为什么在图表中这两个元素之间有直接关系的原因。'
- en: '**Pipes** are another component of Angular 2\. We can think of the Pipes as
    the filters from AngularJS 1.x. Pipes can be used together with components. We
    can include them in the expressions, which are defined in the context of any component:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**管道**是Angular 2的另一个组件。我们可以将管道视为AngularJS 1.x中的过滤器。管道可以与组件一起使用。我们可以将它们包含在在任何组件上下文中定义的表达式中：'
- en: '![A conceptual overview of Angular 2](../images/00005.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![Angular 2的概念概述](../images/00005.jpeg)'
- en: Fig. 3
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图3
- en: Now let's take a look at the preceding diagram. **Directives** and **Components**
    delegate the business logic to **Services**. This enforces better separation of
    concerns, maintainability, and reusability of code. **Directives** receive references
    to instances of specific services declared as dependencies using the **DI** mechanism
    of the framework, and delegate the execution of the business related logic to
    them. Both **Directives** and **Components** may use the **DI** mechanism, not
    only to inject services, but also to inject DOM elements and/or other **Components**
    or **Directives**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下上述图表。**指令**和**组件**将业务逻辑委托给**服务**。这强化了关注点的分离、可维护性和代码的可重用性。**指令**使用框架的**DI**机制接收特定服务实例的引用，并将与它们相关的业务逻辑执行委托给它们。**指令**和**组件**都可以使用**DI**机制，不仅可以注入服务，还可以注入DOM元素和/或其他**组件**或**指令**。
- en: '![A conceptual overview of Angular 2](../images/00006.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![Angular 2的概念概述](../images/00006.jpeg)'
- en: Fig. 4
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图4
- en: Lastly, the component-based router is used for defining the routes in our application.
    Since **Directives** do not own a template, only the **Components** can be rendered
    by the router, representing the different views in our application. The router
    also uses the predefined directives, which allow us to define hyperlinks between
    the different views and the container where they should be rendered.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，基于组件的路由器用于定义应用程序中的路由。由于**指令**没有自己的模板，因此只有**组件**可以由路由器呈现，代表应用程序中的不同视图。路由器还使用预定义的指令，允许我们在不同视图和应该呈现它们的容器之间定义超链接。
- en: Now we're going to look more closely at these concepts, see how they work together
    to make Angular 2 applications, and how they've changed from their AngularJS 1.x
    predecessors.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更仔细地看看这些概念，看看它们如何共同工作以创建Angular 2应用程序，以及它们与其AngularJS 1.x前身有何不同。
- en: Changing directives
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改指令
- en: AngularJS 1.x introduced the concept of directives in the development of single-page
    applications. The purpose of directives is to encapsulate the DOM-related logic,
    and allow us to build user interfaces as compositions of such components by extending
    the syntax and the semantics of HTML. Initially, like most innovative concepts,
    directives were viewed controversially because they predispose us to write invalid
    HTML when using custom elements or attributes without the `data-` prefix. However,
    over time, this concept has gradually been accepted, and has proved that it is
    here to stay.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 1.x在单页应用程序开发中引入了指令的概念。指令的目的是封装与DOM相关的逻辑，并允许我们通过扩展HTML的语法和语义来构建用户界面的组合。最初，像大多数创新概念一样，指令被认为是有争议的，因为当使用自定义元素或属性而没有`data-`前缀时，它们会使我们倾向于编写无效的HTML。然而，随着时间的推移，这个概念逐渐被接受，并证明它是值得留下的。
- en: Another drawback of the implementation of directives in AngularJS 1.x are the
    different ways we can use them. This requires understanding of the attribute values,
    which can be literals, expressions, callbacks, or microsyntax. This makes tooling
    essentially impossible.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 1.x中指令实现的另一个缺点是我们可以使用它们的不同方式。这需要理解属性值，它可以是文字，表达式，回调或微语法。这使得工具基本上不可能。
- en: Angular 2 keeps the concept of directives, but takes the best parts from AngularJS
    1.x and adds some new ideas and syntax. The main purpose of Angular 2's directives
    is to attach behavior to the DOM by extending it with custom logic defined in
    an ES2015 class. We can think of these classes as controllers associated to the
    directives, and think of their constructors as similar to the linking function
    of the directives from AngularJS 1.x. However, the new directives have limited
    configurability. They do not allow for the definition of a template, which makes
    most of the already known properties for defining directives unnecessary. The
    simplicity of the directives API does not limit their behavior, but only enforces
    stronger separation of concerns. To complement this more simple directive API,
    Angular 2 has introduced a richer interface for the definition of UI elements,
    called components. Components extend the functionality of directives by allowing
    them to own a template, through the `Component` metadata. We're going to take
    a further look at components later.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2保留了指令的概念，但从AngularJS 1.x中吸取了精华，并增加了一些新的想法和语法。Angular 2指令的主要目的是通过在ES2015类中定义自定义逻辑来将行为附加到DOM。我们可以将这些类视为与指令关联的控制器，并将它们的构造函数视为类似于AngularJS
    1.x中指令的链接函数。然而，新的指令具有有限的可配置性。它们不允许定义模板，这使得大多数用于定义指令的已知属性变得不必要。指令API的简单性并不限制它们的行为，而只是强化了更强的关注点分离。为了补充这种更简单的指令API，Angular
    2引入了一个更丰富的界面来定义UI元素，称为组件。组件通过`Component`元数据扩展了指令的功能，允许它们拥有模板。我们稍后会更深入地研究组件。
- en: 'The syntax used for Angular 2 directives involves ES2016 decorators. However,
    we can also use TypeScript, ES2015, or even **ECMAScript** 5 (**ES5**) in order
    to achieve the same result with a little bit more typing. The following code defines
    a simple directive, written in TypeScript:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2指令的语法涉及ES2016装饰器。然而，我们也可以使用TypeScript、ES2015甚至**ECMAScript** 5 (**ES5**)来实现相同的结果，只是需要多打一些字。以下代码定义了一个简单的指令，使用TypeScript编写：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The directive can be used with the following markup in our template:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 指令可以在我们的模板中使用以下标记：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once the user points over the the label, `Tell me the answer!`, Angular will
    invoke the method, defined under the `@HostListener` decorator in the directive's
    definition. In the end, the open method of the overlay manager will be executed.
    Since we can have multiple directives on a single element, the best practices
    state that we should use an attribute as a selector.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户指向标签“告诉我答案！”，Angular将调用指令定义中的`@HostListener`装饰器下定义的方法。最终，将执行覆盖管理器的open方法。由于我们可以在单个元素上有多个指令，最佳实践规定我们应该使用属性作为选择器。
- en: 'An alternative ECMAScript 5 syntax for the definition of this directive is:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 用于定义此指令的替代ECMAScript 5语法是：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding ES5 syntax demonstrates the internal JavaScript **Domain Specific
    Language** (**DSL**) that Angular 2 provides in order to allow us to write our
    code without the syntax, which is not yet supported by modern browsers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的ES5语法演示了Angular 2提供的内部JavaScript**领域特定语言**（**DSL**），以便让我们编写代码而不需要语法，这些语法尚未得到现代浏览器的支持。
- en: We can summarize that Angular 2 has kept the concept of directives by maintaining
    the idea of attaching behavior to the DOM. The core differences between 1.x and
    2 are the new syntax, and the further separation of concerns introduced by bringing
    the components. In [Chapter 4](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 4. Getting Started with Angular 2 Components and Directives"), *Getting
    Started with Angular 2 Components and Directives*, we will take a further look
    at directives' API. We'll also compare the directives' definition syntax using
    ES2016 and ES5\. Now let's have a look at the big change to Angular 2 components.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以总结说，Angular 2通过保持将行为附加到DOM的概念来保留了指令的概念。1.x和2之间的核心区别是新的语法，以及通过引入组件引入的进一步关注点分离。在[第4章](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "第4章。了解Angular 2组件和指令的基础")中，*了解Angular 2组件和指令的基础*，我们将进一步查看指令的API。我们还将比较使用ES2016和ES5定义语法的指令。现在让我们来看一下Angular
    2组件的重大变化。
- en: Getting to know Angular 2 components
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Angular 2组件
- en: '**Model View Controller** (**MVC**) is a micro-architectural pattern initially
    introduced for the implementation of user interfaces. As AngularJS developers,
    we use different variations of this pattern on a daily basis, most often **Model
    View ViewModel** (**MVVM**). In MVC, we have the model, which encapsulates the
    business logic of our application, and the view, which is responsible for rendering
    the user interface, accepting user input, as well as delegating the user interaction
    logic to the controller. The view is represented as the composition of components,
    which is formally known as the **composite design pattern**.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型视图控制器**（**MVC**）是最初用于实现用户界面的微架构模式。作为AngularJS开发人员，我们每天都在使用此模式的不同变体，最常见的是**模型视图视图模型**（**MVVM**）。在MVC中，我们有模型，它封装了我们应用程序的业务逻辑，以及视图，它负责呈现用户界面，接受用户输入，并将用户交互逻辑委托给控制器。视图被表示为组件的组合，这正式称为**组合设计模式**。'
- en: 'Let''s take a look at the following structural diagram, which shows the composite
    design pattern:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下面的结构图，它展示了组合设计模式：
- en: '![Getting to know Angular 2 components](../images/00007.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![了解Angular 2组件](../images/00007.jpeg)'
- en: Fig. 5
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图5
- en: 'Here we have three classes:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三个类：
- en: An abstract class called `Component`.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`Component`的抽象类。
- en: Two concrete classes called `Leaf` and `Composite`. The `Leaf` class is a simple
    terminal component in the component tree that we're going to build soon.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个具体的类称为`Leaf`和`Composite`。`Leaf`类是我们即将构建的组件树中的简单终端组件。
- en: The `Component` class defines an abstract operation called `operation`. Both
    `Leaf` and `Composite` inherit from the `Component` class. However, the `Composite`
    class also owns references to it. We can take this even further and allow `Composite`
    to own a list of references to `Component` instances, as shown in the diagram.
    The components list inside `Composite` can hold references to different `Composite`
    or `Leaf` instances, or instances of other classes, which extend the `Component`
    class or any of its successors. In the implementation of the method, `operation`,
    inside `Composite`, the invoked operation of the different instances inside the
    loop can behave differently. This is because of the late binding mechanism used
    for the implementation of the polymorphism in object-oriented programming languages.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Component`类定义了一个名为`operation`的抽象操作。`Leaf`和`Composite`都继承自`Component`类。然而，`Composite`类还拥有对它的引用。我们甚至可以进一步允许`Composite`拥有对`Component`实例的引用列表，就像图示中所示。`Composite`内部的组件列表可以持有对不同`Composite`或`Leaf`实例的引用，或者持有对扩展了`Component`类或其任何后继类的其他类的实例的引用。在`Composite`内部的`operation`方法的实现中，循环中不同实例的调用操作可能会有不同的行为。这是因为面向对象编程语言中多态性实现的后期绑定机制。'
- en: Components in action
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件的作用
- en: 'Enough of theory! Let''s build a component tree based on the class hierarchy
    illustrated in the diagram. This way, we''re going to demonstrate how we can take
    advantage of the composite pattern for building, user interface by using simplified
    syntax. We''re going to take a look at a similar example in the context of Angular
    2 in [Chapter 4](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 4. Getting Started with Angular 2 Components and Directives"), *Getting
    Started with Angular 2 Components and Directives*:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 够了理论！让我们基于图示的类层次结构构建一个组件树。这样，我们将演示如何利用组合模式来使用简化的语法构建用户界面。我们将在[第4章](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "第4章。开始使用Angular 2组件和指令")中看到一个类似的例子，*开始使用Angular 2组件和指令*：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding pseudo-code creates three instances of the `Composite` class
    and three instances of the `Leaf` class. The instance, `c1`, holds references
    to `c2` and `c3` inside the components list. The instance, `c2`, holds references
    to `l1` and `l2`, and `c3` holds reference to `l3`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的伪代码创建了三个`Composite`类的实例和三个`Leaf`类的实例。实例`c1`在组件列表中持有对`c2`和`c3`的引用。实例`c2`持有对`l1`和`l2`的引用，`c3`持有对`l3`的引用：
- en: '![Components in action](../images/00008.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![组件的作用](../images/00008.jpeg)'
- en: Fig. 6
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图6
- en: The preceding diagram is a graphical representation of the component tree we
    built in the snippet. This is a quite simplified version of what the view in the
    modern JavaScript frameworks looks similar to. However, it illustrates the very
    basics of how we can compose directives and components. For instance, in the context
    of Angular 2 we can think of directives as instances of the preceding `Leaf` class
    (since they don't own view and thus cannot compose other directives and components),
    and components as instances of the `Composite` class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图示是我们在片段中构建的组件树的图形表示。这是现代JavaScript框架中视图的一个相当简化的版本。然而，它说明了我们如何组合指令和组件的基本原理。例如，在Angular
    2的上下文中，我们可以将指令视为上面`Leaf`类的实例（因为它们不拥有视图，因此不能组合其他指令和组件），将组件视为`Composite`类的实例。
- en: If we think more abstractly for the user interface in AngularJS 1.x, we can
    notice that we use quite a similar approach. The templates of our views are composing
    different directives together in order to deliver fully a functional user interface
    to the end user of our application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更抽象地思考AngularJS 1.x中的用户界面，我们会注意到我们使用了相似的方法。我们的视图模板将不同的指令组合在一起，以便向我们应用程序的最终用户提供完全功能的用户界面。
- en: Components in Angular 2
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 2中的组件
- en: 'Angular 2 took this approach by introducing new building blocks called **components**.
    Components extend the directive concept we described in the previous section,
    and provide broader functionality. Here is the definition of a basic `hello-world`
    component:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2采用了这种方法，引入了称为**组件**的新构建块。组件扩展了我们在上一节中描述的指令概念，并提供了更广泛的功能。这是一个基本的`hello-world`组件的定义：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can use it by inserting the following markup in our view:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在视图中插入以下标记来使用它：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: According to the best practices, we should use an element as a selector for
    our components since we may have only a single component per DOM element.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 根据最佳实践，我们应该使用一个元素作为组件的选择器，因为我们可能每个DOM元素只有一个组件。
- en: 'The alternative ES5 syntax using the DSL Angular provides is:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Angular提供的DSL的替代ES5语法是：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We will take a look at the preceding syntax in more detail later in the book.
    However, let's briefly describe the functionality, which this component provides.
    Once the Angular 2 application has been bootstrapped, it will look at all the
    elements of our DOM tree and process them. Once it finds the element called `hello-world`,
    it will invoke the logic associated with its definition, which means that the
    template of the component will be rendered and the expression between the curly
    brackets will be evaluated. This will result to the markup, `<h1>Hello, world!</h1>`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面更详细地看一下前面的语法。然而，让我们简要描述一下这个组件提供的功能。一旦Angular 2应用程序已经启动，它将查看我们DOM树中的所有元素并处理它们。一旦找到名为`hello-world`的元素，它将调用与其定义相关联的逻辑，这意味着组件的模板将被呈现，并且花括号之间的表达式将被评估。这将导致标记`<h1>Hello,
    world!</h1>`。
- en: So to summarize, the Angular core team separated out the directives from AngularJS
    1.x into two different parts—**Components** and **Directives**. Directives provide
    an easy way to attach behavior to DOM elements without defining a view. Components
    in Angular 2 provide a powerful, and yet simple-to-learn API, which makes it easier
    to define the user interface of our applications. Angular 2 Components allow us
    to do the same amazing things as AngularJS 1.x directives, but with less typing
    and fewer things to learn. Components extend the Angular 2 directive concept by
    adding a view to it. We can think of the relation between Angular 2 components
    and directives the same way as the relation between `Composite` and `Leaf` from
    the diagram we saw in *Fig. 5*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Angular核心团队将AngularJS 1.x中的指令分成了两个不同的部分——**组件**和**指令**。指令提供了一种简单的方法来将行为附加到DOM元素而不定义视图。Angular
    2中的组件提供了一个强大而简单易学的API，使我们更容易定义应用程序的用户界面。Angular 2组件允许我们做与AngularJS 1.x指令相同的惊人的事情，但输入更少，学习更少。组件通过向其添加视图来扩展Angular
    2指令概念。我们可以将Angular 2组件和指令之间的关系看作是我们在*图5*中看到的`Composite`和`Leaf`之间的关系。
- en: If we start illustrating the conceptual model of the building blocks Angular
    2 provides, we can present the relation between Directive and Component as inheritance.
    [Chapter 4](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582 "Chapter 4. Getting
    Started with Angular 2 Components and Directives"), *Getting Started with Angular
    2 Components and Directives* describes these two concepts in further details.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们开始阐述Angular 2提供的构建块的概念模型，我们可以将指令和组件之间的关系呈现为继承。[第4章](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "第4章。开始使用Angular 2组件和指令")*开始使用Angular 2组件和指令*更详细地描述了这两个概念。
- en: Pipes
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道
- en: In business applications, we often need to have different visual representations
    of the same piece of data. For example, if we have the number 100,000 and we want
    to format it as currency, most likely we won't want to display it as plain data;
    more likely, we'll want something like $100,000.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在业务应用中，我们经常需要对相同的数据进行不同的可视化表示。例如，如果我们有数字100,000，并且想要将其格式化为货币，很可能我们不想将其显示为普通数据；更可能的是，我们想要类似$100,000这样的东西。
- en: The responsibility for formatting data in AngularJS 1.x was assigned to filters.
    Another example for a data formatting requirement is when we use collections of
    items. For instance, if we have a list of items, we may want to filter it based
    on a predicate (a boolean function); in a list of numbers, we may want to display
    only prime numbers. AngularJS 1.x has a filter called `filter`, which allows us
    to do this. However, the duplication of the names often leads to confusion. That's
    another reason the core team renamed the filter component to **pipe**.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在AngularJS 1.x中，格式化数据的责任被分配给了过滤器。另一个数据格式化需求的例子是当我们使用项目集合时。例如，如果我们有一个项目列表，我们可能想要根据谓词（布尔函数）对其进行过滤；在数字列表中，我们可能只想显示素数。AngularJS
    1.x有一个名为`filter`的过滤器，允许我们这样做。然而，名称的重复经常导致混淆。这也是核心团队将过滤器组件重命名为**管道**的另一个原因。
- en: 'The motivation behind the new name is the syntax used for pipes and filters:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 新名称背后的动机是管道和过滤器所使用的语法：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, we apply the pipes, `decimal` and `currency`, to the
    value returned by `expression`. The entire expression between the curly braces
    looks like Unix pipe syntax.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将管道`decimal`和`currency`应用到`expression`返回的值上。花括号之间的整个表达式看起来像Unix管道语法。
- en: Defining pipes
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义管道
- en: The syntax for defining pipes is similar to the one used for the definition
    of directives and components. In order to create a new pipe, we can use the ES2015
    decorator, `@Pipe`. It allows us to add metadata to a class, declaring it as a
    pipe. All we need to do is to provide a name for the pipe and define the data
    formatting logic. There's also an alternative ES5 syntax, which can be used if
    we want to skip the process of transpilation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 定义管道的语法类似于指令和组件的定义所使用的语法。为了创建一个新的管道，我们可以使用ES2015装饰器`@Pipe`。它允许我们向类添加元数据，声明它为管道。我们所需要做的就是为管道提供一个名称并定义数据格式化逻辑。还有一种替代的ES5语法，如果我们想跳过转译的过程，可以使用它。
- en: During runtime, once the Angular 2 expression interpreter finds out that a given
    expression includes a call of a pipe, it will retrieve it out of the pipes collection
    allocated within the component and invoke it with the appropriate arguments.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，一旦Angular 2表达式解释器发现给定表达式包含对管道的调用，它将从组件内分配的管道集合中检索出它，并使用适当的参数调用它。
- en: 'The following example illustrates how we can define a simple pipe called `lowercase1`,
    which transforms the given string, passed as argument to its lowercase representation:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子说明了我们如何定义一个简单的管道叫做`lowercase1`，它将传递给它的字符串转换为小写表示：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In order to be consistent, let''s show the ECMAScript 5 syntax for defining
    pipes:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持一致，让我们展示定义管道的ECMAScript 5语法：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the TypeScript syntax, we implement the `PipeTransform` interface and define
    the `transform` method declared inside it. However, in ECMAScript 5, we do not
    have support for interfaces, but we still need to implement the `transform` method
    in order to define a valid Angular 2 pipe. We are going to explain the TypeScript
    interfaces in the next chapter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript语法中，我们实现了`PipeTransform`接口，并定义了其中声明的`transform`方法。然而，在ECMAScript
    5中，我们不支持接口，但我们仍然需要实现`transform`方法以定义一个有效的Angular 2管道。我们将在下一章中解释TypeScript接口。
- en: 'Now let''s demonstrate how we can use the `lowercase1` pipe inside a component:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们演示如何在组件中使用`lowercase1`管道：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And, the alternative ECMAScript 5 syntax for this is:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，这个的ECMAScript 5的替代语法是：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can use the `App` component with the following markup:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下标记来使用`App`组件：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The result we are going to see on the screen is the text sample within an `h1`
    element.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在屏幕上看到的结果是`h1`元素中的文本示例。
- en: By keeping the data formatting logic as a separate component, Angular 2 keeps
    the strong separation of concerns that can be seen throughout. We will take a
    look at how we can define stateful and stateless pipes for our application in
    [Chapter 7](part0069_split_000.html#21PMQ2-a118c4c18dd64e8ab73e171b466b6582 "Chapter 7. Explaining
    Pipes and Communicating with RESTful Services"), *Building a real-life application
    while exploring pipes and http*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将数据格式化逻辑保持为一个独立的组件，Angular 2保持了强大的关注点分离。我们将在[第7章](part0069_split_000.html#21PMQ2-a118c4c18dd64e8ab73e171b466b6582
    "第7章。解释管道和与RESTful服务通信")中看看如何为我们的应用程序定义有状态和无状态管道，*在探索管道和http的同时构建一个真实的应用程序*。
- en: Change detection
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改检测
- en: As we saw earlier, the view in MVC updates itself, based on change events it
    receives from the model. A number of **Model View Whatever** (**MVW**) frameworks
    took this approach, and embedded the observer pattern in the core of their change
    detection mechanism.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，MVC中的视图会根据从模型接收到的更改事件进行更新。许多**Model View Whatever**（**MVW**）框架采用了这种方法，并将观察者模式嵌入到了它们的更改检测机制的核心中。
- en: Classical change detection
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经典的更改检测
- en: 'Let''s take a look at a simple example, which doesn''t use any framework. Suppose
    we have a model called `User`, which has a property called `name`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子，不使用任何框架。假设我们有一个名为`User`的模型，它有一个名为`name`的属性：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding snippet uses TypeScript. Do not worry if the syntax does not look
    familiar to you, we're going to make an introduction to the language in the next
    chapter.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段使用了TypeScript。如果语法对你来说不太熟悉，不用担心，我们将在下一章中对这种语言进行介绍。
- en: The `user` class extends the class, `EventEmitter`. This provides primitives
    for emitting and subscribing to events.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`user`类扩展了`EventEmitter`类。这提供了发出和订阅事件的基本功能。'
- en: 'Now let''s define a view, which displays the name of an instance of the `User`
    class, passed as an argument to its `constructor`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义一个视图，显示作为其`constructor`参数传递的`User`类实例的名称：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can initialize the view element by:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式初始化视图元素：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As the end result, the user will see a label with the content, `foo`. However,
    changes in user will not be reflected by the view. In order to update the view
    when the name of the user changes, we need to subscribe to the change event and
    then update the content of the DOM element. We need to update the `View` definition
    in the following way:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是，用户将看到一个带有内容`foo`的标签。但是，用户的更改不会反映在视图中。为了在用户更改名称时更新视图，我们需要订阅更改事件，然后更新DOM元素的内容。我们需要以以下方式更新`View`定义：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is how most frameworks used to implement their change detection before
    the era of AngularJS 1.x.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是大多数框架在AngularJS 1.x时代实现它们的更改检测的方式。
- en: AngularJS 1.x change detection
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AngularJS 1.x更改检测
- en: 'Most beginners are fascinated by the data-binding mechanism in AngularJS 1.x.
    The basic Hello World example looks similar to this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数初学者都对AngularJS 1.x中的数据绑定机制着迷。基本的Hello World示例看起来类似于这样：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you run this, `Hello world!` magically appears onto the screen. However,
    that is not even the most impressive thing! If we add a text input and we bind
    it to the `label` property of the scope, each change will reflect the content
    displayed by the interpolation directive:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个，`Hello world!`神奇地出现在屏幕上。然而，这甚至不是最令人印象深刻的事情！如果我们添加一个文本输入，并将它绑定到作用域的`label`属性，每次更改都会反映出插值指令显示的内容：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How awesome is that! This is one of the main selling points of AngularJS 1.x—the
    extreme ease of achieving data-binding. We add two (four if we count `ng-controller`
    and `ng-app`) attributes in our markup, add property to a mystical object called
    `$scope`, which is magically passed to a custom function we define, and everything
    simply works!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是AngularJS 1.x的主要卖点之一——极其容易实现数据绑定。我们在标记中添加了两个（如果计算`ng-controller`和`ng-app`则为四个）属性，将属性添加到一个名为`$scope`的神秘对象中，这个对象被神奇地传递给我们定义的自定义函数，一切都很简单！
- en: However, the more experienced Angular developer has a better understanding of
    what is actually going on behind the scene. In the preceding example, inside the
    directives, `ng-model` and `ng-bind` (in our case, the interpolation directive,
    `{{}}`), Angular adds watchers with different behavior associated to the same
    expression—`label`. These watchers are quite similar to the observers in the classical
    MVC pattern. On some specific events (in our case, change of the content of the
    text input), AngularJS will loop over all such watchers, evaluate the expressions
    associated to them in the context of a given scope, and store their results. This
    loop is known as the `digest` loop.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更有经验的Angular开发人员更好地理解了幕后实际发生的事情。在前面的例子中，在指令`ng-model`和`ng-bind`（在我们的例子中，插值指令`{{}}`）内部，Angular添加了具有不同行为的观察者，关联到相同的表达式`label`。这些观察者与经典MVC模式中的观察者非常相似。在某些特定事件（在我们的例子中，文本输入内容的更改）上，AngularJS将循环遍历所有这样的观察者，评估它们关联的表达式在给定作用域的上下文中的结果，并存储它们的结果。这个循环被称为`digest`循环。
- en: In the preceding examples, the evaluation of the expression, label, in the context
    of the scope will return the text, `Hello world!`. On each iteration, AngularJS
    will compare the current result of the evaluation with the previous result, and
    will invoke the associated callback in case the values differ. For instance, the
    callback added by the interpolation directive will set the content of the element
    to be the new result of the expression's evaluation. This is an example of the
    dependency between the callbacks of the watchers of two directives. The callback
    of the watcher added by `ng-model` modifies the result of the expression associated
    to the watcher added by the interpolation directive.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，表达式`label`在作用域的上下文中的评估将返回文本`Hello world!`。在每次迭代中，AngularJS将当前评估结果与先前结果进行比较，并在值不同时调用关联的回调。例如，插值指令添加的回调将设置元素的内容为表达式评估的新结果。这是两个指令的观察者的回调之间的依赖关系的一个例子。`ng-model`添加的观察者的回调修改了插值指令添加的观察者关联的表达式的结果。
- en: However, this approach has its own drawbacks. We said that the `digest` loop
    will be invoked on some specific events, but what if these events happen outside
    the framework, for example? What if we use `setTimeout` and inside the callback,
    passed as the first argument, we change properties attached to the scope that
    we're watching? AngularJS will be unaware of the change and won't invoke the `digest`
    loop, so we need to do that explicitly using `$scope.$apply`. But what if the
    framework knew about all the asynchronous events happening in the browser, such
    as user events, `XMLHttpRequest` events, `WebSockets` related events, and others?
    In such a case, AngularJS would be able to intercept the event's handling and
    could invoke the digest loop without forcing us to do so!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法也有其自身的缺点。我们说`digest`循环将在一些特定事件上被调用，但如果这些事件发生在框架之外呢？例如，如果我们使用`setTimeout`，并且在作为第一个参数传递的回调函数内部更改了我们正在监视的作用域附加的属性，那会怎么样？AngularJS将不知道这个变化，并且不会调用`digest`循环，所以我们需要使用`$scope.$apply`来显式地做这件事。但是，如果框架知道浏览器中发生的所有异步事件，比如用户事件、`XMLHttpRequest`事件、`WebSockets`相关事件等，会怎样呢？在这种情况下，AngularJS将能够拦截事件处理，并且可以在不强制我们这样做的情况下调用`digest`循环！
- en: In the zone.js
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在zone.js中
- en: That's exactly the case in Angular 2\. This functionality is implemented with
    zones using `zone.js`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular 2中，情况确实如此。这种功能是通过使用`zone.js`来实现的。
- en: At ng-conf in 2014, Brian Ford gave a talk about zones. Brian presented zones
    as meta-monkey patching of browser APIs. Recently Miško Hevery proposed to TC39
    more mature zones API for standardization. `Zone.js` is a library developed by
    the Angular team, which implements zones in JavaScript. They represent an execution
    context, which allow us to intercept asynchronous browser calls. Basically, by
    using zones, we are able to invoke a piece of logic just after the given `XMLHttpRequest`
    completes or when we receive a new `WebSocket` event. Angular 2 took advantage
    of `zone.js` by intercepting asynchronous browser events and invoking the `digest`
    loop just at the right time. This totally eliminates the need of explicit calls
    of the `digest` loop by the developer using Angular.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在2014年的ng-conf上，Brian Ford谈到了zone。Brian将zone呈现为浏览器API的元猴补丁。最近，Miško Hevery向TC39提出了更成熟的zone
    API以供标准化。`Zone.js`是由Angular团队开发的一个库，它在JavaScript中实现了zone。它们代表了一个执行上下文，允许我们拦截异步浏览器调用。基本上，通过使用zone，我们能够在给定的`XMLHttpRequest`完成后或者当我们接收到新的`WebSocket`事件时立即调用一段逻辑。Angular
    2利用了`zone.js`，通过拦截异步浏览器事件，并在合适的时机调用`digest`循环。这完全消除了使用Angular的开发人员需要显式调用`digest`循环的需要。
- en: Simplified data flow
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化的数据流
- en: The cross-watcher dependencies may create a tangled data flow in our application,
    which is hard to follow. This may lead to unpredictable behavior and bugs, which
    are hard to find. Although Angular 2 kept the dirty checking as a way for achieving
    change detection, it enforced unidirectional data flow. This happened by disallowing
    dependencies between the different watchers, which allows the `digest` loop to
    be run only once. This strategy increases the performance of our applications
    dramatically, and reduces the complexity of the data flow. Angular 2 also made
    improvements to memory efficiency and the performance of the `digest` loop. Further
    details on Angular 2's change detection and the different strategies used for
    its implementation can be found in [Chapter 4](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 4. Getting Started with Angular 2 Components and Directives"), *Getting
    Started with Angular 2 Components and Directives*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉观察者依赖关系可能在我们的应用程序中创建纠缠不清的数据流，难以跟踪。这可能导致不可预测的行为和难以发现的错误。尽管Angular 2保留了脏检查作为实现变更检测的一种方式，但它强制了单向数据流。这是通过不允许不同观察者之间的依赖关系，从而使`digest`循环只运行一次。这种策略极大地提高了我们应用程序的性能，并减少了数据流的复杂性。Angular
    2还改进了内存效率和`digest`循环的性能。有关Angular 2的变更检测和其实现所使用的不同策略的更多详细信息，可以在[第4章](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 4. Getting Started with Angular 2 Components and Directives")中找到，《开始使用Angular
    2组件和指令》。
- en: Enhancing AngularJS 1.x's change detection
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强AngularJS 1.x的变更检测
- en: Now let's take a step back and again think about the change detection mechanism
    of the framework.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们退一步，再次思考一下框架的变更检测机制。
- en: We said that inside the `digest` loop, Angular evaluates registered expressions
    and compares the evaluated values with the values associated with the same expressions
    in the previous iteration of the loop.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说在`digest`循环内，Angular评估注册的表达式，并将评估的值与上一次循环中与相同表达式关联的值进行比较。
- en: The most optimal algorithm used for the comparison may differ depending on the
    type of the value returned from the expression's evaluation. For instance, if
    we get a mutable list of items, we need to loop over the entire collection and
    compare the items in the collections one by one in order to verify that there
    is a change or not. However, if we have an immutable list, we can perform a check
    with a constant complexity, only by comparing references. This is the case because
    the instances of immutable data structures cannot change. Instead of applying
    an operation, which intends to modify such instances, we'll get a new reference
    with the modification applied.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 比较所使用的最优算法可能取决于表达式评估返回的值的类型。例如，如果我们得到一个可变的项目列表，我们需要循环遍历整个集合，并逐个比较集合中的项目，以验证是否有更改。然而，如果我们有一个不可变的列表，我们可以通过比较引用来执行具有恒定复杂度的检查。这是因为不可变数据结构的实例不能改变。我们不会应用意图修改这些实例的操作，而是会得到一个应用了修改的新引用。
- en: 'In AngularJS 1.x, we can add watchers using a few methods. Two of them are
    `$watch(exp, fn, deep)` or `$watchCollection(exp, fn)`. These methods give us
    some level of control over the way the change detection will perform the equality
    check. For example, adding a watcher by using `$watch` and passing a `false` value
    as a third argument will make AngularJS perform a reference check (that is compare
    the current value with the previous one using `===`). However, if we pass a truthy
    (any `true` value), the check will be deep (that is using `angular.equals`). This
    way, depending on the expected type of the returned by the expression value, we
    can add listeners in the most appropriate way in order to allow the framework
    to perform equality checks with the most optimal algorithm available. This API
    has two limitations:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在AngularJS 1.x中，我们可以使用几种方法添加监视器。其中两种是`$watch(exp, fn, deep)`或`$watchCollection(exp,
    fn)`。这些方法让我们在改变检测的执行上有一定程度的控制。例如，使用`$watch`添加一个监视器，并将`false`值作为第三个参数传递将使AngularJS执行引用检查（即使用`===`比较当前值与先前值）。然而，如果我们传递一个真值（任何`true`值），检查将是深层的（即使用`angular.equals`）。这样，根据表达式值的预期类型，我们可以以最合适的方式添加监听器，以便允许框架使用最优化的算法执行相等性检查。这个API有两个限制：
- en: It does not allow you to choose the most appropriate equality check algorithm
    at runtime.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不允许您在运行时选择最合适的相等性检查算法。
- en: It does not allow you to extend the change detection to third-parties for their
    specific data structures.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不允许您将改变检测扩展到第三方以适应其特定的数据结构。
- en: 'The Angular core team assigned this responsibility to differs, allowing them
    to extend the change detection mechanism and optimize it, based on the data we
    use in our applications. Angular 2 defines two base classes, which we can extend
    in order to define custom algorithms:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Angular核心团队将这一责任分配给了差异，使它们能够扩展改变检测机制并根据我们在应用程序中使用的数据进行优化。Angular 2定义了两个基类，我们可以扩展以定义自定义算法：
- en: '`KeyValueDiffer`: This allows us to perform advanced diffing over key-value-based
    data structures.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KeyValueDiffer`：这允许我们在基于键值的数据结构上执行高级差异。'
- en: '`IterableDiffer`: This allows us to perform advanced diffing over list-like
    data structures.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IterableDiffer`：这允许我们在类似列表的数据结构上执行高级差异。'
- en: Angular 2 allows us to take full control over the change detection mechanism
    by extending it with custom algorithms, which wasn't possible in the previous
    version of the framework. We'll take a further look into the change detection
    and how we can configure it in [Chapter 4](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 4. Getting Started with Angular 2 Components and Directives"), *Getting
    Started with Angular 2 Components and Directives*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2允许我们通过扩展自定义算法来完全控制改变检测机制，而在框架的先前版本中是不可能的。我们将进一步研究改变检测以及如何在[第4章](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "第4章。开始使用Angular 2组件和指令")中配置它，*开始使用Angular 2组件和指令*。
- en: Understanding services
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解服务
- en: 'Services are the building blocks that Angular provides for the definition of
    the business logic of our applications. In AngularJS 1.x, we had three different
    ways for defining services:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是Angular为定义应用程序的业务逻辑提供的构建块。在AngularJS 1.x中，我们有三种不同的方式来定义服务：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Although the first two syntactical variations provide similar functionality,
    they differ in the way the registered directive will be instantiated. The third
    syntax allows further configuration of the registered provider during configuration
    time.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前两种语法变体提供了类似的功能，但它们在注册指令实例化的方式上有所不同。第三种语法允许在配置时间进一步配置注册的提供者。
- en: 'Having three different methods for defining services is quite confusing for
    the AngularJS 1.x beginners. Let''s think for a second what necessitated the introduction
    of these methods for registering services. Why can''t we simply use JavaScript
    constructor functions, object literals, or ES2015 classes instead, which Angular
    will not be aware of? We could encapsulate our business logic inside a custom
    JavaScript constructor function like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于AngularJS 1.x的初学者来说，有三种不同的定义服务的方法是相当令人困惑的。让我们想一想是什么促使引入这些注册服务方法。为什么我们不能简单地使用JavaScript构造函数、对象文字或ES2015类，而Angular不会意识到呢？我们可以像这样在自定义JavaScript构造函数中封装我们的业务逻辑：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This code is completely valid. However, it doesn''t take advantage of one of
    the key features that AngularJS 1.x provides—the DI mechanism. The `MainCtrl`
    function uses the constructor function, `UserTransaction`, which is visible in
    its body. The preceding code has two main pitfalls:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是完全有效的。然而，它没有利用AngularJS 1.x提供的一个关键特性——DI机制。`MainCtrl`函数使用了构造函数`UserTransaction`，它在其主体中可见。上述代码有两个主要缺点：
- en: We're coupled with the logic used for the service's instantiation.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们与服务实例化的逻辑耦合在一起。
- en: The code is not testable. In order to mock `UserTransactions`, we need to monkey
    patch it.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码无法进行测试。为了模拟`UserTransactions`，我们需要对其进行monkey patch。
- en: How does AngularJS deal with these two things? When a given service is required,
    through the DI mechanism of the framework, AngularJS resolves all of its dependencies
    and instantiates it by passing them to the `factory` function, which encapsulates
    the logic for its creation. The `factory` function is passed as the second argument
    to the `factory` and `service` methods. The `provider` method allows definition
    of a service on lower level; the `factory` method there is the one under the `$get`
    property of the provider.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS如何处理这两个问题？当需要一个特定的服务时，通过框架的DI机制，AngularJS解析所有的依赖关系，并通过将它们传递给`factory`函数来实例化它。`factory`函数作为`factory`和`service`方法的第二个参数传递。`provider`方法允许在更低级别定义服务；在那里，`factory`方法是提供者的`$get`属性下的方法。
- en: 'Just like AngularJS 1.x, Angular 2 tolerates this separation of concerns as
    well, so the core team kept the services. In contrast to AngularJS 1.x, the last
    major version of the framework provides a much simpler interface for the definition
    of services by allowing us to use plain ES2015 classes or ES5 constructor functions.
    We cannot escape from the fact that we need to explicitly state which services
    should be available for injection and somehow specify instructions for their instantiation.
    However, Angular 2 uses the ES2016 decorator''s syntax for this purpose instead
    of the methods familiar to us from AngularJS 1.x. This allows us to define the
    services in our applications as simple as ES2015 classes, with decorators for
    configuration of the DI:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 就像AngularJS 1.x一样，Angular 2也容忍这种关注点的分离，所以核心团队保留了服务。与AngularJS 1.x相比，这个框架的最新主要版本通过允许我们使用纯粹的ES2015类或ES5构造函数来定义服务，提供了一个更简单的接口。我们无法逃避这样一个事实，即我们需要明确声明哪些服务应该可用于注入，并以某种方式指定它们的实例化指令。然而，Angular
    2使用ES2016装饰器的语法来实现这一目的，而不是我们从AngularJS 1.x熟悉的方法。这使我们能够像ES2015类一样简单地在我们的应用程序中定义服务，并使用装饰器来配置DI：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The alternative ECMAScript 5 syntax is:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 5的替代语法是：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Services are related to the components and the directives described in the previous
    sections. For developing highly coherent and reusable UI components, we need to
    move all the business-related logic to inside our services. And, in order to develop
    testable components, we need to take advantage of the DI mechanism for resolving
    all their dependencies.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 服务与前面章节中描述的组件和指令相关联。为了开发高度一致和可重用的UI组件，我们需要将所有与业务相关的逻辑移动到我们的服务中。为了开发可测试的组件，我们需要利用DI机制来解决它们的所有依赖关系。
- en: A core difference between the services in Angular 2 and AngularJS 1.x is the
    way their dependencies are being resolved and represented internally. AngularJS
    1.x is using strings for identifying the different services and the associated
    factories used for their instantiation. However, Angular 2 uses keys instead.
    Usually the keys are the types of the distinct services. Another core difference
    in the instantiation is the hierarchical structure of injectors, which encapsulate
    different dependency providers with different visibility.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2和AngularJS 1.x中服务之间的一个核心区别是它们的依赖项是如何被解析和内部表示的。AngularJS 1.x使用字符串来标识不同的服务和用于实例化它们的相关工厂。然而，Angular
    2使用键。通常，这些键是不同服务的类型。在实例化中的另一个核心区别是注入器的分层结构，它封装了具有不同可见性的不同依赖项提供者。
- en: Another distinction between the services in the last two major versions of the
    framework is the simplified syntax. Although Angular 2 uses ES2015 classes for
    the definition of our business logic, you can use ECMAScript 5 `constructor` functions
    as well or use the DSL provided by the framework. The DI in Angular 2 has a completely
    different syntax and has improved behavior by providing a consistent way of injecting
    dependencies. The syntax used in the preceding example uses ES2016 decorators,
    and in [Chapter 5](part0056_split_000.html#1LCVG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 5. Dependency Injection in Angular 2"), *Dependency Injection in Angular
    2*, we'll take a look at alternative syntax, which uses ECMAScript 5\. You can
    also find more detailed explanation of Angular 2 services and DI in [Chapter 5](part0056_split_000.html#1LCVG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 5. Dependency Injection in Angular 2"), *Dependency Injection in Angular
    2*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2和框架的最后两个主要版本之间的另一个区别是简化的语法。虽然Angular 2使用ES2015类来定义业务逻辑，但您也可以使用ECMAScript
    5的`constructor`函数，或者使用框架提供的DSL。Angular 2中的DI具有完全不同的语法，并通过提供一种一致的方式来注入依赖项来改进行为。前面示例中使用的语法使用了ES2016装饰器，在[第5章](part0056_split_000.html#1LCVG1-a118c4c18dd64e8ab73e171b466b6582
    "第5章。Angular 2中的依赖注入")中，我们将看一下使用ECMAScript 5的替代语法。您还可以在[第5章](part0056_split_000.html#1LCVG1-a118c4c18dd64e8ab73e171b466b6582
    "第5章。Angular 2中的依赖注入")中找到有关Angular 2服务和DI的更详细解释，*Angular 2中的依赖注入*。
- en: Understanding the new component-based router
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解基于组件的新路由器
- en: In traditional web applications, all the page changes are associated with a
    full-page reload, which fetches all of the referenced resources and data and renders
    the entire page onto the screen. However, requirements for web applications have
    evolved over time.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的Web应用程序中，所有页面更改都与完整页面重新加载相关，这会获取所有引用的资源和数据，并将整个页面呈现到屏幕上。然而，随着时间的推移，Web应用程序的要求已经发生了变化。
- en: '**Single-page applications** (**SPAs**) that we build with Angular simulate
    desktop user experiences. This often involve incremental loading of the resources
    and data required by the application, and no full-page reloads after the initial
    page load. Often the different pages or views in SPAs are represented by different
    templates, which are loaded asynchronously and rendered on a specific position
    on the screen. Later, when the template with all the required resources is loaded
    and the route is changed, the logic attached to the selected page is invoked and
    populates the template with data. If the user presses the refresh button after
    the given page in our SPA is loaded, the same page needs to be re-rendered after
    the refresh of the view completes. This involves similar behavior—finding the
    requested view, fetching the required template with all referenced resources,
    and invoking the logic associated with that view.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Angular构建的**单页应用程序**（**SPA**）模拟桌面用户体验。这经常涉及按需加载应用程序所需的资源和数据，并且在初始页面加载后不进行完整的页面重新加载。通常，SPA中的不同页面或视图由不同的模板表示，这些模板是异步加载并在屏幕上的特定位置呈现。稍后，当加载了所有所需资源的模板并且路由已更改时，将调用附加到所选页面的逻辑，并使用数据填充模板。如果用户在加载了我们的SPA中的给定页面后按下刷新按钮，则在视图完成刷新后需要重新呈现相同的页面。这涉及类似的行为——查找请求的视图，获取所有引用资源的所需模板，并调用与该视图相关的逻辑。
- en: What template needs to be fetched, and the logic which should be invoked after
    the page reloads successfully, depends on the selected view before the user pressed
    the refresh button. The framework determines this by parsing the page URL, which
    contains the identifier of the currently selected page, represented in the hierarchical
    structure.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 需要获取哪个模板，以及在页面成功重新加载后应调用的逻辑，取决于用户在按下刷新按钮之前选择的视图。框架通过解析页面URL来确定这一点，该URL包含当前选定页面的标识符，以分层结构表示。
- en: All the responsibilities related to the navigation, changing the URL, loading
    the appropriate template, and invoking specific logic when the view is loaded
    are assigned to the router component. These are some quite challenging tasks,
    and support for different navigation APIs required for cross-browser compatibility
    makes the implementation of routing in modern SPAs a non-trivial problem.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与导航、更改URL、加载适当模板和在视图加载时调用特定逻辑相关的所有责任都分配给了路由器组件。这些都是相当具有挑战性的任务，为了跨浏览器兼容性而需要支持不同的导航API，使得在现代SPA中实现路由成为一个非平凡的问题。
- en: AngularJS 1.x introduced the router in its core, which was later externalized
    into the `ngRoute` component. It allows a declarative way for defining the different
    views in our SPA, by providing a template for each page and a piece of logic that
    needs to be invoked when a page is selected. However, the functionality of the
    router is limited. It does not support essential features such as nested view
    routing. That's one of the reasons most developers preferred to use `ui-router`,
    developed by the community. Both AngularJS 1.x's router, and `ui-router`, route-definitions
    include a route configuration object, which defines a template and a controller
    associated with the page.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 1.x在其核心中引入了路由器，后来将其外部化为`ngRoute`组件。它允许以声明方式定义SPA中的不同视图，为每个页面提供模板和需要在选择页面时调用的逻辑。然而，路由器的功能有限。它不支持诸如嵌套视图路由之类的基本功能。这是大多数开发人员更喜欢使用由社区开发的`ui-router`的原因之一。AngularJS
    1.x的路由器和`ui-router`的路由定义都包括路由配置对象，该对象定义了与页面关联的模板和控制器。
- en: As described in the previous sections, Angular 2 changed the building blocks
    it provides for the development of SPAs. Angular 2 removes the floating controllers,
    and instead represents views as a composition of components. This necessitates
    the development of a brand new router, which empowers these new concepts.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几节所述，Angular 2改变了它为开发单页应用程序提供的构建模块。Angular 2移除了浮动控制器，而是将视图表示为组件的组合。这需要开发一个全新的路由器，以赋予这些新概念力量。
- en: 'The core differences between the AngularJS 1.x router and the Angular 2 router
    are:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 1.x路由器和Angular 2路由器之间的核心区别是：
- en: The Angular 2 router is component based, `ngRoute` is not.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 2路由器是基于组件的，而`ngRoute`不是。
- en: There is now support for nested views.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在支持嵌套视图。
- en: Different syntax empowered by ES2016 decorators.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES2016装饰器赋予了不同的语法。
- en: Angular 2 route definition syntax
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 2路由定义语法
- en: 'Let''s take a brief look at the new syntax used by the Angular 2 router to
    define routes in our applications:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地看一下Angular 2路由器在我们应用程序中定义路由时使用的新语法：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We won't go into too much detail here since [Chapter 6](part0062_split_000.html#1R42S1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 6. Working with the Angular 2 Router and Forms"), *Angular 2 forms and
    the new component-based router* and [Chapter 7](part0069_split_000.html#21PMQ2-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 7. Explaining Pipes and Communicating with RESTful Services"), *Building
    a real-life application while exploring pipes and http*, are dedicated to the
    new router, but let's mention the main points in the preceding code snippet.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里详细介绍，因为[第6章](part0062_split_000.html#1R42S1-a118c4c18dd64e8ab73e171b466b6582
    "第6章。使用Angular 2路由器和表单")、*Angular 2表单和基于组件的新路由器*和[第7章](part0069_split_000.html#21PMQ2-a118c4c18dd64e8ab73e171b466b6582
    "第7章。解释管道和与RESTful服务通信")、*在探索管道和http的同时构建一个真实的应用程序*专门讨论了新路由器，但让我们提到前面代码片段中的主要要点。
- en: The router lives in the module, `angular2/router`. There, we can find the directives
    it defines, the decorator used for the configuration of the routes and `ROUTER_PROVIDERS`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器位于模块`angular2/router`中。在那里，我们可以找到它定义的指令，用于配置路由的装饰器和`ROUTER_PROVIDERS`。
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We'll take a further look at `ROUTER_PROVIDERS` in [Chapter 7](part0069_split_000.html#21PMQ2-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 7. Explaining Pipes and Communicating with RESTful Services"), *Building
    a real-life application while exploring pipes and http*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第7章](part0069_split_000.html#21PMQ2-a118c4c18dd64e8ab73e171b466b6582 "第7章。解释管道和与RESTful服务通信")中进一步了解`ROUTER_PROVIDERS`，*在探索管道和http的同时构建一个真实的应用程序*。
- en: The parameter passed to the `@RouteConfig` decorator shows how we define the
    routes in our application. We use an array with objects, which defines the mappings
    between routes and the components associated with them. Inside the `Component`
    decorator, we explicitly state that we want to use the directives contained within
    `ROUTER_DIRECTIVES`, which are related to the router's usage inside the templates.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`@RouteConfig`装饰器传递的参数显示了我们如何在应用程序中定义路由。我们使用一个包含对象的数组，它定义了路由和与其关联的组件之间的映射关系。在`Component`装饰器内部，我们明确说明我们要使用`ROUTER_DIRECTIVES`中包含的指令，这些指令与模板中的路由器使用相关。'
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a quick overview of the main building blocks for developing
    SPAs provided by Angular 2\. We pointed out the core differences between these
    components in AngularJS 1.x and Angular 2.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们快速概述了Angular 2提供的开发单页应用程序的主要构建模块。我们指出了AngularJS 1.x和Angular 2中这些组件之间的核心区别。
- en: Although we can use ES2015, or even ES5, for building Angular 2 applications,
    the recommendation from Google is to take advantage of the language used for the
    development of the framework—TypeScript.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以使用ES2015，甚至ES5来构建Angular 2应用程序，但Google的建议是利用用于开发框架的语言—TypeScript。
- en: In the next chapter, we'll take a look at TypeScript and how we can start using
    it in your next application. We will also explain how we can take advantage of
    the static typing in the JavaScript libraries and frameworks written in vanilla
    JavaScript, with ambient type annotations.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下TypeScript以及如何在您的下一个应用程序中开始使用它。我们还将解释如何利用JavaScript库和框架中的静态类型，这些库和框架是用原生JavaScript编写的，带有环境类型注释。
