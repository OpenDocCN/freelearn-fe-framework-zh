<html><head></head><body>
<section epub:type="frontmatter chapter" role="doc-chapter">
<h1 class="chapter-number" id="_idParaDest-86"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-87"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.2.1">Exploring Common Refactoring Techniques</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Welcome to the fascinating world of refactoring! </span><span class="koboSpan" id="kobo.3.2">In this chapter, we’re going to explore the basics of this fundamental practice, essential to every developer in maintaining and improving a code base. </span><span class="koboSpan" id="kobo.3.3">We aim to introduce you to the most common refactoring techniques, providing a solid foundation for understanding and employing these valuable tools. </span><span class="koboSpan" id="kobo.3.4">Remember, our objective is not to provide an exhaustive guide, but rather to familiarize you with the essentials that you’ll use time and time again in your programming journey.</span></p>
<p><span class="koboSpan" id="kobo.4.1">Refactoring doesn’t discriminate among languages or frameworks – it’s a universal concept applicable anywhere you write code. </span><span class="koboSpan" id="kobo.4.2">The techniques we’ll discuss include renaming variables, changing function declarations, extracting functions, moving fields, and more. </span><span class="koboSpan" id="kobo.4.3">These techniques might appear simple at first glance, but they are incredibly powerful tools for crafting clean, understandable, and maintainable code.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Also remember that refactoring is not a one-time task, but rather an ongoing process of small, iterative changes that gradually enhance the structure and quality of your code. </span><span class="koboSpan" id="kobo.5.2">It is these frequent, incremental improvements that keep a code base healthy, robust, and easier to work with. </span><span class="koboSpan" id="kobo.5.3">By introducing you to the basics, we hope to equip you with the essential tools and techniques that will be a stepping stone toward more advanced refactoring methods.</span></p>
<p><span class="koboSpan" id="kobo.6.1">While we’ll delve into more complex refactoring techniques in later chapters, the practices you’ll learn here will serve as a valuable starting point. </span><span class="koboSpan" id="kobo.6.2">By the end of this chapter, you’ll have a toolkit of common refactoring practices and a newfound understanding of their importance in enhancing code quality. </span><span class="koboSpan" id="kobo.6.3">Ultimately, the refactoring skills you begin to develop here will empower you to write cleaner, more efficient code, and set you on the path to becoming a more proficient developer. </span><span class="koboSpan" id="kobo.6.4">Let’s dive in!</span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will cover the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.8.1">Understanding refactoring</span></li>
<li><span class="koboSpan" id="kobo.9.1">Adding tests before refactoring</span></li>
<li><span class="koboSpan" id="kobo.10.1">Using Rename Variable</span></li>
<li><span class="koboSpan" id="kobo.11.1">Using Extract Variable</span></li>
<li><span class="koboSpan" id="kobo.12.1">Using Replace Loop with Pipeline</span></li>
<li><span class="koboSpan" id="kobo.13.1">Using Extract Function</span></li>
<li><span class="koboSpan" id="kobo.14.1">Using Introduce Parameter Object</span></li>
<li><span class="koboSpan" id="kobo.15.1">Using Decompose Conditional</span></li>
<li><span class="koboSpan" id="kobo.16.1">Using Move Function</span></li>
</ul>
<h1 id="_idParaDest-88"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.17.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.18.1">A GitHub repository has been created to host all the code we discuss in the book. </span><span class="koboSpan" id="kobo.18.2">For this chapter, you can find the recommended structure at </span><a href="https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch6"><span class="koboSpan" id="kobo.19.1">https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch6</span></a><span class="koboSpan" id="kobo.20.1">.</span></p>
<p><span class="koboSpan" id="kobo.21.1">Before we dive into the refactorings, let’s align with some tooling that would help us to make changes easily. </span><span class="koboSpan" id="kobo.21.2">When it comes to refactoring tools, there are many </span><strong class="bold"><span class="koboSpan" id="kobo.22.1">integrated development environments</span></strong><span class="koboSpan" id="kobo.23.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.24.1">IDEs</span></strong><span class="koboSpan" id="kobo.25.1">) and source code editors available in the frontend world – WebStorm and Visual Studio Code (VS Code) are the most popular ones that offer an impressive range of features, including robust refactoring capabilities.</span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.26.1">WebStorm</span></strong><span class="koboSpan" id="kobo.27.1">, developed by JetBrains, is a powerful and feature-rich IDE specifically designed for JavaScript and its related technologies such as TypeScript, HTML, and CSS. </span><span class="koboSpan" id="kobo.27.2">One of its most notable features is its advanced automated refactoring, but it also offers an extensive list of refactoring options such as rename, extract, inline, move, and copy, which can be applied to variables, classes, functions, and other elements. </span><span class="koboSpan" id="kobo.27.3">It also has a smart duplication detection feature, helping you to locate and resolve repetitive blocks of code.</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer037">
<span class="koboSpan" id="kobo.28.1"><img alt="Figure 6.1: The WebStorm IDE" src="image/B31103_06_01.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.29.1">Figure 6.1: The WebStorm IDE</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.30.1">WebStorm’s IntelliSense, auto-complete, and code navigation are quite robust, giving you a lot of help when writing and exploring the code. </span><span class="koboSpan" id="kobo.30.2">However, WebStorm is a commercial product, and while it does offer a trial period, you will need to purchase a license for continued use.</span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.31.1">Visual Studio Code</span></strong><span class="koboSpan" id="kobo.32.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.33.1">VS Code</span></strong><span class="koboSpan" id="kobo.34.1">), on the other hand, is a free, open source IDE developed by Microsoft. </span><span class="koboSpan" id="kobo.34.2">It’s lightweight compared to WebStorm and is known for its speed and flexibility. </span><span class="koboSpan" id="kobo.34.3">VS Code also supports a wide range of languages beyond JavaScript, thanks to its extension marketplace. </span><span class="koboSpan" id="kobo.34.4">Refactoring capabilities in VS Code are strong as well, with support for common operations such as renaming, extracting functions or variables, and changing function signatures. </span><span class="koboSpan" id="kobo.34.5">VS Code’s refactoring capabilities can be further enhanced by installing extensions, and its customizability is one of its key strengths.</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer038">
<span class="koboSpan" id="kobo.35.1"><img alt="Figure 6.2: VS Code" src="image/B31103_06_02.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.36.1">Figure 6.2: VS Code</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.37.1">While VS Code may not have as many automated refactoring features as WebStorm out of the box, it can be tailored to match and sometimes exceed WebStorm’s capabilities through these extensions.</span></p>
<p><span class="koboSpan" id="kobo.38.1">Choosing between the two often boils down to personal preference and the specific needs of your project. </span><span class="koboSpan" id="kobo.38.2">If you value a highly automated, feature-rich environment and don’t mind paying for it, WebStorm might be your best bet. </span><span class="koboSpan" id="kobo.38.3">However, if you prioritize speed, flexibility, and customization and are comfortable setting up your environment through extensions, VS Code could be the better choice.</span></p>
<p><span class="koboSpan" id="kobo.39.1">I prefer WebStorm as my IDE at work – part of the reason is I am already very familiar with the keymaps, and I love the built-in auto-refactoring capability. </span><span class="koboSpan" id="kobo.39.2">However, I still use VS Code for casual projects.</span></p>
<h1 id="_idParaDest-89"><span class="koboSpan" id="kobo.40.1">Un</span><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.41.1">derstanding refactoring</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.42.1">Refactoring</span></strong><span class="koboSpan" id="kobo.43.1"> is a disciplined, systematic process of improving the design of an existing code base without changing its external behavior. </span><span class="koboSpan" id="kobo.43.2">It’s a fundamental aspect of everyday coding, a practice integral to the iterative and incremental nature of software development. </span><span class="koboSpan" id="kobo.43.3">The concept is</span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.44.1"> universally applicable, and not bound to any specific programming language, framework, or paradigm. </span><span class="koboSpan" id="kobo.44.2">Whether you’re writing in JavaScript, Python, or any other language, and whether you’re using React, Angular, or a homegrown framework, refactoring is crucial to maintaining a healthy code base.</span></p>
<p><span class="koboSpan" id="kobo.45.1">The term “refactoring” was first introduced by William Opdyke and Ralph Johnson in a 1990 paper titled </span><i class="italic"><span class="koboSpan" id="kobo.46.1">Refactoring: An Aid in Designing Application Frameworks and Evolving Object-Oriented Systems</span></i><span class="koboSpan" id="kobo.47.1">; however, the concept and practice of refactoring have roots in earlier practices in software engineering. </span><span class="koboSpan" id="kobo.47.2">The art of refactoring gained significant prominence with Martin Fowler’s book </span><i class="italic"><span class="koboSpan" id="kobo.48.1">Refactoring: Improving the Design of Existing Code</span></i><span class="koboSpan" id="kobo.49.1">, published in 1999. </span><span class="koboSpan" id="kobo.49.2">In this book, Fowler describes refactoring as “a controlled technique for improving the design of an existing code base,” emphasizing its role in mitigating the buildup of technical debt, which makes the code easier to understand, maintain, and extend.</span></p>
<p><span class="koboSpan" id="kobo.50.1">Refactoring isn’t about making one grand, sweeping change to perfect the code base. </span><span class="koboSpan" id="kobo.50.2">Instead, it’s about making small, incremental improvements consistently over time. </span><span class="koboSpan" id="kobo.50.3">Each individual change might not dramatically alter the quality of the code, but collectively, over time, these small changes can significantly enhance the structure, readability, and maintainability of the code base.</span></p>
<p><span class="koboSpan" id="kobo.51.1">Although refactoring doesn’t add new functionality, it directly influences the team’s ability to deliver new features more quickly, with fewer bugs, and to respond more flexibly to changing requirements. </span><span class="koboSpan" id="kobo.51.2">By continuously refactoring, we keep our code clean and easy to work with and set the stage for long-term, sustainable development.</span></p>
<p><span class="koboSpan" id="kobo.52.1">In conclusion, refactoring is a critical tool in a developer’s toolkit, irrespective of the technology stack or the size and scope of the project. </span><span class="koboSpan" id="kobo.52.2">It’s a long-term investment in the code base and the team, and ultimately, it’s an investment in the quality of the software that is delivered.</span></p>
<h2 id="_idParaDest-90"><span class="koboSpan" id="kobo.53.1">T</span><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.54.1">he common mistakes of refactoring</span></h2>
<p><span class="koboSpan" id="kobo.55.1">The biggest mistake people</span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.56.1"> make in refactoring is that they restructure code rather than refactoring it. </span><span class="koboSpan" id="kobo.56.2">The terms “refactoring” and “restructuring” are often used interchangeably, but they have distinct meanings in software development.</span></p>
<p><i class="italic"><span class="koboSpan" id="kobo.57.1">Refactoring</span></i><span class="koboSpan" id="kobo.58.1"> is a disciplined technique for improving the design of an existing code base, making it cleaner and easier to understand</span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.59.1"> and work with. </span><span class="koboSpan" id="kobo.59.2">It involves changing the internal structure of the software without modifying its external behavior. </span><span class="koboSpan" id="kobo.59.3">This is generally done in small steps, and each refactoring step is expected to maintain the software’s functionality. </span><span class="koboSpan" id="kobo.59.4">It doesn’t add new features; instead, it makes the code more readable, maintainable, and prepared for future changes.</span></p>
<p><span class="koboSpan" id="kobo.60.1">For example, in a React application, refactoring could involve breaking down a large component into smaller, more manageable components, or replacing complex conditional logic with a strategy pattern.</span></p>
<p><i class="italic"><span class="koboSpan" id="kobo.61.1">Restructuring</span></i><span class="koboSpan" id="kobo.62.1">, on the other hand, can be seen as a broader and more drastic process. </span><span class="koboSpan" id="kobo.62.2">It often involves large-scale changes that</span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.63.1"> not only impact the internal structure of the software but can also affect its external behavior. </span><span class="koboSpan" id="kobo.63.2">Restructuring can encompass changes to the software’s architecture, data models, interfaces, and more. </span><span class="koboSpan" id="kobo.63.3">It is often driven by the need to introduce major changes or additions to the software’s features or capabilities, to improve performance, or to address significant technical debt.</span></p>
<p><span class="koboSpan" id="kobo.64.1">In the context of a React application, restructuring might involve changing the state management solution (such as moving from Redux to the React Context API), updating the routing mechanism, or transitioning from a monolithic architecture to a microfrontend architecture.</span></p>
<p><span class="koboSpan" id="kobo.65.1">While both refactoring and restructuring aim to improve the quality of the code base, refactoring is typically smaller in scope, involves no change in functionality, and is part of the regular development process. </span><span class="koboSpan" id="kobo.65.2">In contrast, restructuring is generally larger in scope, can change functionality, and is often part of a larger project or initiative to address more significant challenges or changes in requirements.</span></p>
<p><span class="koboSpan" id="kobo.66.1">As well as a misunderstanding between refactoring and restructuring, another mistake people tend to make is that they don’t test as often – sometimes this is because they don’t have many tests, while at other times they think it’s safe to make these “small” changes without testing. </span><span class="koboSpan" id="kobo.66.2">Let’s look at testing in the next section</span><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.67.1">.</span></p>
<h1 id="_idParaDest-91"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.68.1">Adding tests before refactoring</span></h1>
<p><span class="koboSpan" id="kobo.69.1">Because we don’t want to make any observable behavior changes during refactoring, we need to inspect the code to make</span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.70.1"> sure we have enough tests to cover the current behavior. </span><span class="koboSpan" id="kobo.70.2">It’s easy to mess up without the right tests in place, and that’s not only risky but also less efficient, as we need to check the changed code manually and repeatedly.</span></p>
<p><span class="koboSpan" id="kobo.71.1">Let’s say we have some TypeScript code from an online shopping application – the code works fine, but there aren’t any tests associated with it. </span><span class="koboSpan" id="kobo.71.2">To improve the code so that it’s easier to understand and extend, we need to refactor it:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.72.1">
interface Item {
  id: string;
  price: number;
  quantity: number;
}
class ShoppingCart {
  cartItems: Item[] = [];
  addItemToCart(id: string, price: number, quantity: number) {
    this.cartItems.push({ id, price, quantity });
  }
  calculateTotal() {
    let total = 0;
    for (let i = 0; i &lt; this.cartItems.length; i++) {
      let item = this.cartItems[i];
      let subTotal = item.price * item.quantity;
      if (item.quantity &gt; 10) {
        subTotal *= 0.9;
      }
      total += subTotal;
    }
    return total;
  }
}
export { ShoppingCart };</span></pre> <p><span class="koboSpan" id="kobo.73.1">So, this code defines a shopping cart model. </span><span class="koboSpan" id="kobo.73.2">Firstly, it defines an </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">Item</span></strong><span class="koboSpan" id="kobo.75.1"> interface, which represents an item to be added to</span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.76.1"> the cart. </span><span class="koboSpan" id="kobo.76.2">An </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">Item</span></strong><span class="koboSpan" id="kobo.78.1"> component consists of an ID, a price, and a quantity. </span><span class="koboSpan" id="kobo.78.2">Then, it defines a </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.80.1"> class with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">cartItems</span></strong><span class="koboSpan" id="kobo.82.1"> property, which is an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">Item</span></strong><span class="koboSpan" id="kobo.84.1"> objects, initially empty.</span></p>
<p><span class="koboSpan" id="kobo.85.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.87.1"> class has two methods:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.88.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">addItemToCart</span></strong><span class="koboSpan" id="kobo.90.1"> method accepts an ID, price, and quantity, and then creates an item using these parameters. </span><span class="koboSpan" id="kobo.90.2">This item is then added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">cartItems</span></strong><span class="koboSpan" id="kobo.92.1"> array.</span></li>
<li><span class="koboSpan" id="kobo.93.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">calculateTotal</span></strong><span class="koboSpan" id="kobo.95.1"> method calculates the total price of the items in the cart. </span><span class="koboSpan" id="kobo.95.2">For each item, it multiplies the item’s price by its quantity to get a subtotal. </span><span class="koboSpan" id="kobo.95.3">If the quantity of the item is more than 10, a 10% discount is applied to the subtotal. </span><span class="koboSpan" id="kobo.95.4">The subtotal of each item is then added together to get the total. </span><span class="koboSpan" id="kobo.95.5">The total is then returned by the method.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.96.1">There are two important calculations here: compute the total price (price by quantity) and apply the discount when eligible. </span><span class="koboSpan" id="kobo.96.2">We normally should pay more attention to the logic regarding these calculations.</span></p>
<p><span class="koboSpan" id="kobo.97.1">For example, we need to verify both sides of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">if-else</span></strong><span class="koboSpan" id="kobo.99.1"> statement. </span><span class="koboSpan" id="kobo.99.2">As we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">if-else</span></strong><span class="koboSpan" id="kobo.101.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">for</span></strong><span class="koboSpan" id="kobo.103.1"> loop, we will at least need to add two test cases before making changes. </span><span class="koboSpan" id="kobo.103.2">Let’s add the following</span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.104.1"> Jest tests to describe both calculations – with and without a discount:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.105.1">
import { ShoppingCart } from "../ShoppingCart";
describe("ShoppingCart", () =&gt; {
  it("calculates item prices", () =&gt; {
    const shoppingCart = new ShoppingCart();
    shoppingCart.addItemToCart("apple", 2.0, 2);
    shoppingCart.addItemToCart("orange", 3.5, 1);
    const price = shoppingCart.calculateTotal();
    expect(price).toEqual(7.5);
  });
  it('applies discount when applicable', () =&gt; {
    const shoppingCart = new ShoppingCart();
    shoppingCart.addItemToCart("apple", 2.0, 11);
    const price = shoppingCart.calculateTotal();
    expect(price).toEqual(19.8);
  })
});</span></pre> <p><span class="koboSpan" id="kobo.106.1">The first test, </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">calculates item prices</span></strong><span class="koboSpan" id="kobo.108.1">, is verifying that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">calculateTotal</span></strong><span class="koboSpan" id="kobo.110.1"> method works as expected when no discounts are applied. </span><span class="koboSpan" id="kobo.110.2">Here, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.112.1"> object is instantiated, and two items (</span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">apple</span></strong><span class="koboSpan" id="kobo.114.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">orange</span></strong><span class="koboSpan" id="kobo.116.1">) are added to the cart. </span><span class="koboSpan" id="kobo.116.2">The total price of these items is calculated and expected to be 7.5, as there are two apples at $2 each and one orange at $3.5.</span></p>
<p><span class="koboSpan" id="kobo.117.1">The second test, </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">applies discount when applicable</span></strong><span class="koboSpan" id="kobo.119.1">, is checking that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">calculateTotal</span></strong><span class="koboSpan" id="kobo.121.1"> method correctly applies a 10% discount when the quantity of an item is more than 10. </span><span class="koboSpan" id="kobo.121.2">In this case, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.123.1"> object is instantiated, and one type of item (</span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">apple</span></strong><span class="koboSpan" id="kobo.125.1">) is added to the cart with quantity 11. </span><span class="koboSpan" id="kobo.125.2">The total price of this item should be $19.8 after applying the 10% discount on the subtotal of $22 (11 apples at $2 each). </span><span class="koboSpan" id="kobo.125.3">The calculated total price is then checked against this expected value.</span></p>
<p><span class="koboSpan" id="kobo.126.1">Once we have test cases to</span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.127.1"> cover the important logic, we can safely make changes. </span><span class="koboSpan" id="kobo.127.2">During refactoring, we’ll need to run these tests regularly.</span></p>
<p><span class="koboSpan" id="kobo.128.1">Refactorings are small steps that can improve the code. </span><span class="koboSpan" id="kobo.128.2">Let’s have a look at our very first and maybe the simplest refactoring technique: </span><strong class="bold"><span class="koboSpan" id="kobo.129.1">Rename Varia</span><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.130.1">ble</span></strong><span class="koboSpan" id="kobo.131.1">.</span></p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.132.1">Using Rename Variable</span></h2>
<p><span class="koboSpan" id="kobo.133.1">Let’s start with a simple refactoring technique</span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.134.1"> called Rename Variable. </span><span class="koboSpan" id="kobo.134.2">Rename Variable is a very straightforward yet effective method to improve the readability and maintainability of the code. </span><span class="koboSpan" id="kobo.134.3">It involves changing the name of a variable to better reflect its purpose and the data it holds, or to follow a certain naming convention or standard.</span></p>
<p><span class="koboSpan" id="kobo.135.1">Sometimes, during the initial phases of coding, developers might choose names for variables that make sense at that time, but as the code evolves, the purpose of the variable might change or become clearer. </span><span class="koboSpan" id="kobo.135.2">The variable name, however, often remains the same. </span><span class="koboSpan" id="kobo.135.3">This can cause confusion and make the code harder to understand and maintain. </span><span class="koboSpan" id="kobo.135.4">Renaming variables to describe their purposes more accurately can reduce the cognitive load for future readers of the code, including the future self of the current coder.</span></p>
<p><span class="koboSpan" id="kobo.136.1">Let’s return to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.138.1"> example. </span><span class="koboSpan" id="kobo.138.2">The variable name </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">cartItems</span></strong><span class="koboSpan" id="kobo.140.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.142.1"> class is a little redundant; however, we can rename it to simply </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">items</span></strong><span class="koboSpan" id="kobo.144.1"> to be more concise and clean:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.145.1">
class ShoppingCart {
  items: Item[] = [];
  addItemToCart(id: string, price: number, quantity: number) {
    this.items.push({ id, price, quantity });
  }
  calculateTotal() {
    let total = 0;
    for (let i = 0; i &lt; this.items.length; i++) {
      let item = this.items[i];
      let subTotal = item.price * item.quantity;
      if (item.quantity &gt; 10) {
        subTotal *= 0.9;
      }
      total += subTotal;
    }
    return total;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.146.1">After the change, make sure to run the tests again to see whether we accidentally made any mistakes.</span></p>
<p><span class="koboSpan" id="kobo.147.1">It’s important to establish a</span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.148.1"> habit of running tests regularly after making some changes, and whenever the tests fail, we need to stop and examine what is wrong. </span><span class="koboSpan" id="kobo.148.2">Once all the tests are back to passing, we can then p</span><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.149.1">roceed.</span></p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.150.1">Using Extract Variable</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.151.1">Extract Variable</span></strong><span class="koboSpan" id="kobo.152.1"> is a common refactoring technique that is used to improve the readability and maintainability of code. </span><span class="koboSpan" id="kobo.152.2">The </span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.153.1">process involves taking a section of code that calculates a value, replacing it with a new variable, and assigning the result of the original expression to this new variable. </span><span class="koboSpan" id="kobo.153.2">There is a similar refactoring called </span><strong class="bold"><span class="koboSpan" id="kobo.154.1">Extract Constant</span></strong><span class="koboSpan" id="kobo.155.1"> that can be </span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.156.1">used to extract a value that doesn’t change at runtime.</span></p>
<p><span class="koboSpan" id="kobo.157.1">This refactoring technique is particularly useful when you have a complex expression or a duplicated calculation; by extracting parts of the expression to variables with meaningful names, the code becomes more understandable and easier to manage.</span></p>
<p><span class="koboSpan" id="kobo.158.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.160.1"> example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">0.9</span></strong><span class="koboSpan" id="kobo.162.1"> discount rate deserves its own name; we can extract a variable and reference it at the point where the function is called. </span><span class="koboSpan" id="kobo.162.2">As the value of the variable isn’t going to change at runtime, we can call it </span><strong class="bold"><span class="koboSpan" id="kobo.163.1">Extract Constant</span></strong><span class="koboSpan" id="kobo.164.1"> in this case:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.165.1">
const DISCOUNT_RATE = 0.9;
class ShoppingCart {
  //...
</span><span class="koboSpan" id="kobo.165.2">  calculateTotal() {
    let total = 0;
    for (let i = 0; i &lt; this.items.length; i++) {
      let item = this.items[i];
      let subTotal = item.price * item.quantity;
      if (item.quantity &gt; 10) {
        subTotal *= DISCOUNT_RATE;
      }
      total += subTotal;
    }
    return total;
  }
  //...
</span><span class="koboSpan" id="kobo.165.3">}</span></pre> <p><span class="koboSpan" id="kobo.166.1">For the sake of clarity, portions of the code that aren’t relevant to this particular change have been left out of the discussion; however, the important thing to note is that in this instance, we’ve created a constant named </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">DISCOUNT_RATE</span></strong><span class="koboSpan" id="kobo.168.1"> and used it in place of the previous hard-coded value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">0.9</span></strong><span class="koboSpan" id="kobo.170.1"> where it’s utilized in the code. </span><span class="koboSpan" id="kobo.170.2">At times, we may wish to assign a name to an expression other than a hard-coded value, so we can create a variable to stand in for the expression</span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.171.1"> and then refer to that variable.</span></p>
<p><span class="koboSpan" id="kobo.172.1">It’s a tiny step, but it improves the code slightly. </span><span class="koboSpan" id="kobo.172.2">If we need to change the discount rate in the future, the constant name is much easier to search and understand than the hard-coded value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">0.9</span></strong><span class="koboSpan" id="kobo.174.1">.</span></p>
<p><span class="koboSpan" id="kobo.175.1">Now we can investigate another refactoring technique to make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">for</span></strong><span class="koboSpan" id="kobo.177.1"> loop a bi</span><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.178.1">t simpler.</span></p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.179.1">Using Replace Loop with Pipeline</span></h1>
<p><span class="koboSpan" id="kobo.180.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.181.1">Replace Loop with Pipeline</span></strong><span class="koboSpan" id="kobo.182.1"> refactoring technique, as the name implies, is about replacing a loop structure with a pipeline of transformations, commonly achieved by using higher-order functions </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.183.1">or methods such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">map</span></strong><span class="koboSpan" id="kobo.185.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">filter</span></strong><span class="koboSpan" id="kobo.187.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">reduce</span></strong><span class="koboSpan" id="kobo.189.1"> in functional programming languages such as JavaScript.</span></p>
<p><span class="koboSpan" id="kobo.190.1">In the case of JavaScript, the Array prototype has methods such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">map</span></strong><span class="koboSpan" id="kobo.192.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">filter</span></strong><span class="koboSpan" id="kobo.194.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">reduce</span></strong><span class="koboSpan" id="kobo.196.1"> that can be chained together to form a pipeline. </span><span class="koboSpan" id="kobo.196.2">Each of these methods receives a function as an argument and applies this function to each element in the array, effectively transforming the array in some manner.</span></p>
<p><span class="koboSpan" id="kobo.197.1">However, keep in mind that while replacing loops with pipelines can make the code cleaner and more readable, it might not always be the most efficient option, especially when dealing with very large datasets. </span><span class="koboSpan" id="kobo.197.2">So, as with all refactorings, you need to balance readability and maintainability with performance requirements in cases when you need to iterate through a large dataset multiple times.</span></p>
<p><span class="koboSpan" id="kobo.198.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">for</span></strong><span class="koboSpan" id="kobo.200.1"> loop in the previous section can be replaced by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">reduce</span></strong><span class="koboSpan" id="kobo.202.1"> function (and we don’t have to explicitly define an index variable or save the boilerplate code):</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.203.1">
class ShoppingCart {
  //...
</span><span class="koboSpan" id="kobo.203.2">  calculateTotal() {
    return this.items.reduce((total, item) =&gt; {
      let subTotal = item.price * item.quantity;
      return total + (item.quantity &gt; 10 ? </span><span class="koboSpan" id="kobo.203.3">subTotal * DISCOUNT_RATE : 
       subTotal);
    }, 0);
  }
  //...
</span><span class="koboSpan" id="kobo.203.4">}</span></pre> <p><span class="koboSpan" id="kobo.204.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">calculateTotal()</span></strong><span class="koboSpan" id="kobo.206.1"> method is using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">reduce()</span></strong><span class="koboSpan" id="kobo.208.1"> function to calculate the total price of the items in the shopping cart. </span><span class="koboSpan" id="kobo.208.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">reduce()</span></strong><span class="koboSpan" id="kobo.210.1"> function is a higher-order function that applies a function against an accumulator and each element in the array (from left to right) to reduce it to a single output value.</span></p>
<p><span class="koboSpan" id="kobo.211.1">The total starts at 0 and</span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.212.1"> then for each item in the shopping cart, it adds the </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">subTotal</span></strong><span class="koboSpan" id="kobo.214.1"> variable of that item to the total. </span><span class="koboSpan" id="kobo.214.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">subTotal</span></strong><span class="koboSpan" id="kobo.216.1"> variable is calculated by multiplying the price and quantity of each item.</span></p>
<p><span class="koboSpan" id="kobo.217.1">Next, we need to re-run all the tests to check whether everything goes well. </span><span class="koboSpan" id="kobo.217.2">As our tests are still passing, let’s see how we can make the code even better by extracting lines into a smaller fun</span><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.218.1">ction.</span></p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.219.1">Using Extract Function</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.220.1">Extract Function</span></strong><span class="koboSpan" id="kobo.221.1"> is a refactoring</span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.222.1"> technique that helps to improve code readability and maintainability by breaking down a large or complex function into smaller, more manageable parts.</span></p>
<p><span class="koboSpan" id="kobo.223.1">Let’s say you come across a function that’s performing multiple tasks. </span><span class="koboSpan" id="kobo.223.2">Maybe it’s doing some data validation, then some computations, and finally logging the result or updating some state. </span><span class="koboSpan" id="kobo.223.3">The function is long and complex, making it hard to understand at a glance what it’s doing. </span><span class="koboSpan" id="kobo.223.4">Extract Function refactoring is all about identifying those distinct pieces of functionality, pulling them out into their own separate functions, and then calling those new functions from the original one.</span></p>
<p><span class="koboSpan" id="kobo.224.1">One key benefit is that it </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.225.1">makes the code more self-documenting. </span><span class="koboSpan" id="kobo.225.2">If you extract a part of your function to a new function and give it a meaningful name, it can often make the code much easier to understand since the function name can describe what the code is doing. </span><span class="koboSpan" id="kobo.225.3">It also improves the reusability of the code, since these smaller functions can be reused elsewhere if needed.</span></p>
<p><span class="koboSpan" id="kobo.226.1">The logic of how to calculate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">subTotal</span></strong><span class="koboSpan" id="kobo.228.1"> variable can be extracted from </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">calculateTotal</span></strong><span class="koboSpan" id="kobo.230.1"> as a separate unit:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.231.1">
function applyDiscountIfEligible(item: Item, subTotal: number) {
  return item.quantity &gt; 10 ? </span><span class="koboSpan" id="kobo.231.2">subTotal * DISCOUNT_RATE : subTotal;
}
class ShoppingCart {
  //...
</span><span class="koboSpan" id="kobo.231.3">  calculateTotal() {
    return this.items.reduce((total, item) =&gt; {
      let subTotal = item.price * item.quantity;
      return total + applyDiscountIfEligible(item, subTotal);
    }, 0);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.232.1">In this code snippet, we see the result of an Extract Function refactoring. </span><span class="koboSpan" id="kobo.232.2">The logic to apply a discount if the item quantity is greater than 10 has been extracted into its own function named </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">applyDiscountIfEligible</span></strong><span class="koboSpan" id="kobo.234.1">.</span></p>
<p><span class="koboSpan" id="kobo.235.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.237.1"> class, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">calculateTotal</span></strong><span class="koboSpan" id="kobo.239.1"> method calculates the total price of the items in the cart using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">reduce</span></strong><span class="koboSpan" id="kobo.241.1"> function. </span><span class="koboSpan" id="kobo.241.2">For each item, it computes the subtotal as the product of the item’s price and quantity, then adds this subtotal (after applying any eligible discount) to the total.</span></p>
<p><span class="koboSpan" id="kobo.242.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">applyDiscountIfEligible</span></strong><span class="koboSpan" id="kobo.244.1"> function takes an item and its quantity as arguments. </span><span class="koboSpan" id="kobo.244.2">If the quantity of the</span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.245.1"> item is more than 10, it applies a discount rate (represented by </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">DISCOUNT_RATE</span></strong><span class="koboSpan" id="kobo.247.1">) to the argument </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">subTotal</span></strong><span class="koboSpan" id="kobo.249.1">; otherwise, it simply returns the argument </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">subTotal</span></strong><span class="koboSpan" id="kobo.251.1"> as it is.</span></p>
<p><span class="koboSpan" id="kobo.252.1">This refactoring makes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">calculateTotal</span></strong><span class="koboSpan" id="kobo.254.1"> method more concise and easier to read, by abstracting away the details of how discounts are applied into a separate, appropriately named function.</span></p>
<p><span class="koboSpan" id="kobo.255.1">Let’s look at another refactoring method that could make the passed-in parameter </span><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.256.1">easy to modify.</span></p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.257.1">Using Introduce Parameter Object</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.258.1">Introduce Parameter Object</span></strong><span class="koboSpan" id="kobo.259.1"> is a refactoring technique used when a function has a large number of parameters, or when multiple functions share the same parameters. </span><span class="koboSpan" id="kobo.259.2">In this technique, you group related </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.260.1">parameters into a single object and pass that object to the function instead.</span></p>
<p><span class="koboSpan" id="kobo.261.1">A large number of parameters in a function can be confusing and difficult to manage. </span><span class="koboSpan" id="kobo.261.2">Grouping related parameters together into an object can increase code readability and make it easier to understand what the function does. </span><span class="koboSpan" id="kobo.261.3">It also makes the function call simpler and cleaner. </span><span class="koboSpan" id="kobo.261.4">Furthermore, if the same group of parameters is used in multiple function calls, this technique reduces the chances of passing parameters in the wrong order.</span></p>
<p><span class="koboSpan" id="kobo.262.1">For example, consider a </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">calculateTotalPrice(quantity, price, discount)</span></strong><span class="koboSpan" id="kobo.264.1"> function. </span><span class="koboSpan" id="kobo.264.2">We could refactor this using the Introduce Parameter Object technique to become </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">calculateTotalPrice({ quantity, price, discount })</span></strong><span class="koboSpan" id="kobo.266.1">. </span><span class="koboSpan" id="kobo.266.2">Now, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">quantity</span></strong><span class="koboSpan" id="kobo.268.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">price</span></strong><span class="koboSpan" id="kobo.270.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">discount</span></strong><span class="koboSpan" id="kobo.272.1"> parameters are grouped together into an object (with type </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">Item</span></strong><span class="koboSpan" id="kobo.274.1">), like so:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.275.1">
class ShoppingCart {
  items: Item[] = [];
  addItemToCart({id, price, quantity}: Item) {
    this.items.push({ id, price, quantity });
  }
  //...
</span><span class="koboSpan" id="kobo.275.2">}</span></pre> <p><span class="koboSpan" id="kobo.276.1">On top of these benefits, Introduce Parameter Object refactoring can often reveal or inspire domain concepts that</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.277.1"> were previously hidden and implicit in your code. </span><span class="koboSpan" id="kobo.277.2">The parameter object might become a class of its own, with its own behavior and data manipulation methods. </span><span class="koboSpan" id="kobo.277.3">This can lead to more object-oriented and encapsulated code.</span></p>
<p><span class="koboSpan" id="kobo.278.1">Next, let’s explore another refactoring technique designed to streamline your </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">if-else</span></strong><span class="koboSpan" id="kobo.280.1"> statements and enhance </span><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.281.1">code readability.</span></p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.282.1">Using Decompose Conditional</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.283.1">Decompose Conditional</span></strong><span class="koboSpan" id="kobo.284.1"> is a refactoring technique where the logic within a conditional statement (</span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">if-else</span></strong><span class="koboSpan" id="kobo.286.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">switch</span></strong><span class="koboSpan" id="kobo.288.1">) is </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.289.1">extracted into separate functions. </span><span class="koboSpan" id="kobo.289.2">This technique helps to improve the readability of the code, making it more understandable.</span></p>
<p><span class="koboSpan" id="kobo.290.1">The condition, </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">if</span></strong><span class="koboSpan" id="kobo.292.1"> clause, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">else</span></strong><span class="koboSpan" id="kobo.294.1"> clause (if it exists) all get their own function. </span><span class="koboSpan" id="kobo.294.2">These functions are then named according to what they do or what they are checking for. </span><span class="koboSpan" id="kobo.294.3">This refactoring is beneficial because it replaces code that might need comments to understand with well-named functions, making the code self-explanatory.</span></p>
<p><span class="koboSpan" id="kobo.295.1">For example, the logic in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">applyDiscountIfEligible</span></strong><span class="koboSpan" id="kobo.297.1"> function can actually be simplified by this refactoring; we can extract a small function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">isDiscountEligible</span></strong><span class="koboSpan" id="kobo.299.1"> to replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">item.quantity &gt; 10</span></strong><span class="koboSpan" id="kobo.301.1"> check, like in the following:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.302.1">
function isDiscountEligible(item: Item) {
  return item.quantity &gt; 10;
}
function applyDiscountIfEligible(item: Item, subTotal: number) {
  return isDiscountEligible(item) ? </span><span class="koboSpan" id="kobo.302.2">subTotal * DISCOUNT_RATE : subTotal;
}</span></pre> <p><span class="koboSpan" id="kobo.303.1">In this code snippet, the extraction of logic into a separate function might appear superfluous because it adds </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.304.1">an additional function call. </span><span class="koboSpan" id="kobo.304.2">However, it enhances readability and reusability:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.305.1">
function isDiscountEligible(item: Item) {
  return item.quantity &gt; 10;
}
function applyDiscountIfEligible(item: Item, subTotal: number) {
  return isDiscountEligible(item) ? </span><span class="koboSpan" id="kobo.305.2">subTotal * DISCOUNT_RATE : 
   subTotal;
}</span></pre> <p><span class="koboSpan" id="kobo.306.1">In this code snippet, we’ve separated the logic that determines whether an item is eligible for a discount into a standalone </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">isDiscountEligible</span></strong><span class="koboSpan" id="kobo.308.1"> function. </span><span class="koboSpan" id="kobo.308.2">This extraction makes our </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">applyDiscountIfEligible</span></strong><span class="koboSpan" id="kobo.310.1"> function cleaner and its intention more evident. </span><span class="koboSpan" id="kobo.310.2">Additionally, it allows for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">isDiscountEligible</span></strong><span class="koboSpan" id="kobo.312.1"> logic to be updated independently if needed in the future, improving maintainability.</span></p>
<p><span class="koboSpan" id="kobo.313.1">After extracting these smaller functions, they don’t have to reside in the current file. </span><span class="koboSpan" id="kobo.313.2">We can relocate them to a separate module and import them as needed; this not only shortens the length of the</span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.314.1"> current module but also improves its readability. </span><span class="koboSpan" id="kobo.314.2">Let’</span><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.315.1">s look at that next.</span></p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.316.1">Using Move Function</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.317.1">Move Function</span></strong><span class="koboSpan" id="kobo.318.1"> is a refactoring method that involves changing the location of a function to a more suitable or appropriate place. </span><span class="koboSpan" id="kobo.318.2">This could be within the same class, to a different class, or even to a </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.319.1">separate module. </span><span class="koboSpan" id="kobo.319.2">The objective of this method is to enhance the readability, maintainability, and structure of the code by ensuring that functions are placed where they logically fit best.</span></p>
<p><span class="koboSpan" id="kobo.320.1">This kind of refactoring becomes necessary when the responsibilities of your classes evolve over time. </span><span class="koboSpan" id="kobo.320.2">You might find that a function makes more sense in a different class, or perhaps you have a group of functions within a class that work together and would be better suited in their own class or module.</span></p>
<p><span class="koboSpan" id="kobo.321.1">Move Function refactoring can help reduce the complexity of the class by moving functions to the places where their functionality is most relevant or required. </span><span class="koboSpan" id="kobo.321.2">This promotes the principle of cohesion where related code is kept together. </span><span class="koboSpan" id="kobo.321.3">It also aids in achieving loose coupling by minimizing unnecessary dependencies between different parts of the code.</span></p>
<p><span class="koboSpan" id="kobo.322.1">In our </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.324.1"> component, we can move the type definition into a new file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">types.ts</span></strong><span class="koboSpan" id="kobo.326.1">. </span><span class="koboSpan" id="kobo.326.2">We can also move </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">DISCOUNT_RATE</span></strong><span class="koboSpan" id="kobo.328.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">isDiscountEligible</span></strong><span class="koboSpan" id="kobo.330.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">applyDiscountIfEligible</span></strong><span class="koboSpan" id="kobo.332.1"> into a separate file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">utils.ts</span></strong><span class="koboSpan" id="kobo.334.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.335.1">
import { Item } from "./types";
const DISCOUNT_RATE = 0.9;
function isDiscountEligible(item: Item) {
  return item.quantity &gt; 10;
}
export function applyDiscountIfEligible(item: Item, subTotal: number) {
  return isDiscountEligible(item) ? </span><span class="koboSpan" id="kobo.335.2">subTotal * DISCOUNT_RATE : 
   subTotal;
}</span></pre> <p><span class="koboSpan" id="kobo.336.1">Note that in the code, only </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">applyDiscountIfEligible</span></strong><span class="koboSpan" id="kobo.338.1"> is a public function and can be accessed outside of </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.339.1">the file. </span><span class="koboSpan" id="kobo.339.2">This refactoring also improves the encapsulation of the code.</span></p>
<p><span class="koboSpan" id="kobo.340.1">After Move Function is used, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.342.1"> component is simplified significantly and only has the necessary parts:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.343.1">
import { Item } from "./types";
import { applyDiscountIfEligible } from "./utils";
class ShoppingCart {
  items: Item[] = [];
  addItemToCart({ id, price, quantity }: Item) {
    this.items.push({ id, price, quantity });
  }
  calculateTotal() {
    return this.items.reduce((total, item) =&gt; {
      let subTotal = item.price * item.quantity;
      return total + applyDiscountIfEligible(item, subTotal);
    }, 0);
  }
}
export { ShoppingCart };</span></pre> <p><span class="koboSpan" id="kobo.344.1">As with all refactoring, care should be taken when moving functions to ensure that the overall behavior of the </span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.345.1">system is not altered. </span><span class="koboSpan" id="kobo.345.2">Tests should be in place to verify that the functionality remains the </span><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.346.1">same after refactoring.</span></p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.347.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.348.1">This chapter focused on a variety of code refactoring techniques that are essential to maintaining and improving the structure, readability, and maintainability of your code base.</span></p>
<p><span class="koboSpan" id="kobo.349.1">The refactoring techniques introduced include Rename Variable, which enhances code clarity by using more descriptive variable names, Extract Variable, which simplifies complex expressions by breaking them into smaller, more manageable parts, and Replace Loop with Pipeline, which transforms traditional </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">for</span></strong><span class="koboSpan" id="kobo.351.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">while</span></strong><span class="koboSpan" id="kobo.353.1"> loops into more concise, declarative higher-order functions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">map</span></strong><span class="koboSpan" id="kobo.355.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">filter</span></strong><span class="koboSpan" id="kobo.357.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">reduce</span></strong><span class="koboSpan" id="kobo.359.1">.</span></p>
<p><span class="koboSpan" id="kobo.360.1">As well as this, Extract Function encourages code modularity and reusability by breaking down large functions into smaller ones, each with a single, well-defined responsibility, while Introduce Parameter Object groups related parameters into a single object, thereby reducing the complexity of function signatures. </span><span class="koboSpan" id="kobo.360.2">Plus, Decompose Conditional breaks down complex conditional logic into separate functions, enhancing readability, and Move Function ensures that functions are placed in the most logical and appropriate location in your code base, promoting high cohesion and loose coupling.</span></p>
<p><span class="koboSpan" id="kobo.361.1">Throughout all these techniques, we emphasized the importance of maintaining the same overall system behavior and relying on tests to ensure that functionality remains consistent despite refactoring. </span><span class="koboSpan" id="kobo.361.2">These methods, when properly applied, can lead to a more understandable, easier to maintain, and more robust code base.</span></p>
<p><span class="koboSpan" id="kobo.362.1">In the next chapter, we will explore an exceptional approach to enhancing the quality of our code – the method known as test-driven development.</span></p>
</section>
</body></html>