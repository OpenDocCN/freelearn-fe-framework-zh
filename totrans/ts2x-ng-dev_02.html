<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Getting Started with TypeScript</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we discussed the challenges we may encounter because of the loose-type nature of the JavaScript language. We also saw various attempts of mitigating these challenges, none of which felt natural at all. We also introduced TypeScript as a tool that could help; how TypeScript can help is what we will discuss in this chapter.</p>
<p>The building blocks of TypeScript and its core concepts are matters of the heart, and we need to treat them as such. Therefore, backed with hands-on examples, we will discuss these building blocks, how they work together, and how you can integrate them into your workflow as a JavaScript developer. But first, we need to learn how to set up TypeScript.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Creating a TypeScript environment</li>
<li>Building working examples with TypeScript</li>
<li>Type Annotation</li>
<li>ES6 and TypeScript</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up TypeScript</h1>
                </header>
            
            <article>
                
<p>The TypeScript setup depends on the context where it will be used. This is because you can integrate it in any JavaScript tools, libraries, and frameworks as long as it's properly configured for the environment. For now, we will focus on the simplest and the most basic setup.</p>
<p>A basic knowledge of Node and its package manager npm is required to get going with TypeScript. It's also required that you install both from the Node website (<a href="https://nodejs.org/en/">https://nodejs.org/en/</a>). </p>
<p>With Node and npm installed, you can install TypeScript globally using <kbd>npm</kbd> via the command line tool:</p>
<pre><strong>npm install -g typescript</strong></pre>
<p>If you get a permission warning while trying to install, you can use the <kbd>sudo</kbd> command:</p>
<pre><strong>sudo npm install -g typescript</strong></pre>
<p>You will see the following output if the installation goes well:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-514 image-border" height="164" src="assets/b6a24256-5cc2-4a09-802d-3fe013419191.png" width="458"/></div>
<p>To confirm whether the TypeScript installation was successful, you can check the installed version. If a version is shown, then you have a successful installation:</p>
<pre><strong>tsc -v</strong></pre>
<p><span>Therefore, a TypeScript instance on your machine </span>will work as shown ahead:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-515 image-border" height="175" src="assets/6be1f19f-0633-4e2e-8ba6-65321d3488d9.png" width="488"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hello World</h1>
                </header>
            
            <article>
                
<p>TypeScript files have a <kbd>.ts</kbd> extension. The extension supports both JavaScript and TypeScript. This means that it is correct to write JavaScript code in a <kbd>.ts</kbd> file without TypeScript. Let's see an example.</p>
<p>First, make an <kbd>index.html</kbd> file with the following minimal bootstrap markup:</p>
<pre>&lt;!-- Code 2.1.html --&gt;<br/>&lt;html&gt;<br/> &lt;head&gt;<br/>   &lt;title&gt;Example 2.1: Hello World&lt;/title&gt;<br/>   &lt;!-- Include Bootstrap and custom style --&gt;<br/>   &lt;link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"&gt;<br/>   &lt;link rel="stylesheet" href="2.1.css"&gt;<br/> &lt;/head&gt;<br/> &lt;body&gt;<br/>   &lt;div class="container"&gt;<br/>     &lt;div class="col-md-4 col-md-offset-4 main"&gt;<br/>       &lt;h3 class="messenger"&gt;&lt;/h3&gt;<br/>     &lt;/div&gt;<br/>     &lt;div class="col-md-4 col-md-offset-4 main"&gt;<br/>       &lt;input type="text" class="form-control"&gt;<br/>       &lt;button class="button"&gt;Greet&lt;/button&gt;<br/>     &lt;/div&gt;<br/>   &lt;/div&gt;<br/>   &lt;!-- Include JavaScript file --&gt;<br/>   &lt;script src="2.1.js"&gt;&lt;/script&gt;<br/> &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>Notice that the JavaScript file added before the closing tag is <em>not</em> a <kbd>.ts</kbd> file; rather, it's a familiar JavaScript file with a <kbd>.js</kbd> extension. This doesn't mean that our logic will be written in JavaScript; in fact, it's a TypeScript file named <kbd>2.1.ts</kbd>:</p>
<pre>// Code 2.1.ts<br/>(function() {<br/> var button = document.querySelector('.button');<br/> var input = document.querySelector('.form-control');<br/> var messenger = document.querySelector('.messenger');<br/> <br/> button.addEventListener('click', handleButtonClick);<br/><br/> function handleButtonClick() {<br/>   if(input.value.length === 0) {<br/>     alert('Please enter your name');<br/>     return;<br/>   }<br/>   // Update messanger <br/>   messenger.innerHTML = 'Hello, ' + input.value;<br/> }<br/>})();</pre>
<p>Does anything look weird? No, I don't think so. We're still talking pure JavaScript but just that it lives in a TypeScript file. This shows how TypeScript supports pure JavaScript.</p>
<p>Remember that we are importing <kbd>2.1.js</kbd> in the <kbd>index.html</kbd> file and not <kbd>2.1.ts</kbd>. Therefore, it's time to generate an output that the browser can understand. This is where the TypeScript compiler that we installed via <kbd>npm</kbd> comes in handy. To compile, enter <kbd>cd</kbd> into your working directory and run the following command in your command line:</p>
<pre><strong>tsc 2.1.ts</strong></pre>
<p><em>Ignore the warning about the value property. We will fix that soon.</em></p>
<p>This will generate a compiled <kbd>2.1.js</kbd> file. As you may have guessed, looking at both shows no syntax difference:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-285 image-border" height="335" src="assets/77a5c5c6-a454-4377-9a43-630acc14f68c.png" width="594"/></div>
<p>You can then serve your web page with the generated assets using a web server. There are lots of options to help you complete this, but <kbd>serve</kbd> is quite popular and stable (<a href="https://github.com/zeit/serve">https://github.com/zeit/serve</a>). To install <kbd>serve</kbd>, run the following command:</p>
<pre><strong>npm install -g serve</strong></pre>
<p>Now you can serve directly hosting your <kbd>index</kbd> file with the following:</p>
<pre><strong>serve --port 5000</strong></pre>
<p>With <kbd>npm</kbd> scripts, you can run both the commands concurrently. First, initialize <kbd>package.json</kbd>:</p>
<pre><strong>npm init -y</strong></pre>
<p>Now, add the following scripts to the JSON:</p>
<pre><strong>"scripts": {</strong><strong>"start": "tsc 2.1.ts -w &amp; serve --port 5000"</strong><strong>},</strong></pre>
<p>We passed in the watched option (<kbd>-w</kbd>), so TypeScript can recompile whenever a change is detected in the <kbd>.ts</kbd> file.</p>
<p>This is what our example looks like:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-286 image-border" height="311" src="assets/b6fd864a-d2cc-4cce-8012-66d931cb0814.png" width="442"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type annotation in TypeScript</h1>
                </header>
            
            <article>
                
<p>It's worth mentioning again that nothing looks different in the <kbd>Hello World</kbd> example we just saw. Let's employ some TypeScript specific features, one of which is Types. Types are the reason TypeScript exists, and every other feature apart from Types is just syntactic sugar.</p>
<p>We are not going into details with Types because <a href="fb2f2b0b-b55a-42c6-b7bc-6c1a275f064a.xhtml">Chapter 3</a>, <em>Typescript Native Types and Accessors</em>, covers that. What we can discuss is Type annotation, which is a mechanism that TypeScript uses to apply strict types to a member. Annotation is achieved by following the member initialization with a colon (<kbd>:</kbd>) and the type (for example, <kbd>string</kbd>) as follows:</p>
<pre><strong>var firstName: string;</strong></pre>
<p>Let's have a look at some annotated examples:</p>
<pre>var name: string = 'John';<br/>console.log(name); // John<br/><br/>var age: number = 18;<br/>console.log(age); // 18<br/><br/>var siblings: string[] = ['Lisa', 'Anna', 'Wili'];<br/>console.log(siblings); // ['Lisa', 'Anna', 'Wili']<br/><br/>// OR<br/><br/>var siblings: Array&lt;string&gt; = ['Lisa', 'Anna', 'Wili'];<br/>console.log(siblings); // ['Lisa', 'Anna', 'Wili']<br/><br/>// any type supports all other types<br/>// and useful for objects when we are lazy<br/>// to make types with interfaces/class for them<br/><br/>var attributes: any = {legs: 2, hands: 2, happy: true}</pre>
<p>Not just primitives but objects, arrays, and functions can be typed as well. We will see how shortly.</p>
<p>What we can do is rewrite our previous <kbd>Hello World</kbd> example in order to annotate the variables and functions with types.</p>
<p>Take a look at this image again:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-287 image-border" height="1011" src="assets/ce477b33-7933-4a1b-b184-65e3607fc256.png" width="1800"/></div>
<p>On the TypeScript section (right),  <kbd>value</kbd> seems not to be identified by the editor as a property of the DOM and, hence, the error line. But wait, it is the same old JavaScript you have been writing your entire life. What's wrong here?</p>
<p>TypeScript comes with defined types for the DOM. This means that it will throw an error when we try to access a property that is not defined in the respective DOM interface (more on interfaces later). By nature, the DOM query method, <kbd>querySelector</kbd>, alongside the other query methods return an <kbd>Element</kbd> type (which is inferred if not annotated). The <kbd>Element</kbd> type is basic and is comprised of generic information about the DOM, which means that properties and methods specific to what is derived from <kbd>Element</kbd> will not be seen.</p>
<p>This makes sense not just in TypeScript but also in other OOP languages:</p>
<pre>class Base {<br/>  name: string = 'John'<br/>}<br/><br/>class Derived extends Base {<br/>  gender: string = 'male'<br/>}<br/><br/>(new Base()).name // John<br/>(new Base()).gender // throws an error</pre>
<p>Back to our example, let's see how we can use annotation and casting to fix this:</p>
<pre>// Code 2.2.ts<br/>(function() {<br/>   // 1. Button type is Element<br/>   var button: Element = document.querySelector('.button');<br/>   // 2. Input type is HTMLInputElement and we cast accordingly<br/>   var input: HTMLInputElement = &lt;HTMLInputElement&gt;document.querySelector('.form-control');<br/>   // 3. Messanger is HTMLElement and we cast accordingly<br/>   var messenger: HTMLElement = document.querySelector('.messenger') as HTMLElement;<br/>   <br/>   // 4. The handler now takes a function and returns another function (callback)<br/>   button.addEventListener('click', handleButtonClick('Hello,', 'Please enter your name'));<br/><br/>   function handleButtonClick(prefix, noNameErrMsg) {<br/>     // Logic here<br/>     // Should return a function <br/>   }<br/>})()</pre>
<p>There are no behavioral changes, just productivity improvements. Let's discuss what's going on:</p>
<ol>
<li>The button element is of type <kbd>Element</kbd>. Nothing special here because TypeScript already infers that internally.</li>
<li>The input element is of the <kbd>HTMLInputElement</kbd> type. Because TypeScript infers the returned value as <kbd>Element</kbd>, we had to cast to the correct type, that is, <span><kbd>HTMLInputElement</kbd>. This is done by prefixing the returned value with <kbd>&lt;&gt;</kbd> and passing the interface that we want to cast it to.</span></li>
<li>The messenger element is of the <kbd>HTMLElement</kbd> type. We still had to cast here using the same reason as seen in <em>Step 2</em> but with a different supported syntax (<kbd>as</kbd>). <kbd>HTMLElement</kbd> is a subtype for <kbd>Element</kbd> and includes more specific DOM properties/methods (such as <kbd>innerText</kbd>).</li>
<li>Rather than passing the callback, we wrap it in a function, so we can receive parameters.</li>
</ol>
<p>Let's take a look at the method passed to <kbd>addEventListener</kbd>:</p>
<pre>// Code 2.2.ts<br/>function handleButtonClick(prefix, noNameErrMsg) {<br/>   return function() {<br/>     if(input.value.length === 0) {<br/>       if(typeof noNameErrMsg !== 'string') {<br/>         alert('Something went wrong, and no valid error msg was provided')<br/>         return;<br/>       }<br/>       alert(noNameErrMsg);<br/>       return;<br/>   }<br/><br/>   if(typeof prefix !== 'string') {<br/>     alert('Improper types for prefix or error msg')<br/>   }<br/> <br/>   messenger.innerHTML = prefix + input.value;<br/> <br/> }</pre>
<p>We added a lot of validation logic just to make sure that we are getting the right type from the parameters. We can simplify this by using TypeScript annotation:</p>
<pre>// Code 2.3.ts<br/>function handleButtonClick(prefix: string, noNameErrMsg: string) {<br/>  return function(e: MouseEvent) {<br/>    if(input.value.length === 0) {<br/>      alert(noNameErrMsg);<br/>      return;<br/>    }<br/><br/>    messenger.innerHTML = prefix + input.value;<br/><br/>  }<br/>}</pre>
<p>This is much better, right? The unnecessary checks are taken care of with Types. In fact, before this gets to the browser, if your editor (for example, VS Code) supports TypeScript, you will get syntax errors when the method is called with invalid types.</p>
<p>Type annotation helps us write less verbose, more comprehensible, and bug-free applications. TypeScript makes annotation flexible; hence, you do not have to strictly provide types for every member in your logic. You're free to annotate what you feel is necessary, ranging from nothing to all; just keep in mind that the more strict your annotations are, the less debugging you will have to do in the browser.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ES6 and beyond</h1>
                </header>
            
            <article>
                
<p>In addition to Type annotation, TypeScript supports EcamaScript 6 (ES6/ES2015) alongside other helpful features, such as e<span>nums, d</span><span>ecorators, a</span><span>ccessibility level (private, public, and protected), i</span><span>nterfaces, g</span><span>enerics</span><span>, and so on</span></p>
<p>We will take a deep look into a few of the features in the next chapter. Before that, let's get our feet wet and our hands a little bit dirty by trying another example, which comprises some of these ES6 and TypeScript-specific features. We will build a counter app. This is just an attempt to get you excited about these features, and you get to see how TypeScript brings the features you always wished existed in JavaScript.</p>
<p>Let's get started with a basic HTML template:</p>
<pre>&lt;!-- Code 2.4.html --&gt;<br/>&lt;div class="container"&gt;<br/>  &lt;div class="col-md-6 col-md-offset-3 main"&gt;<br/>    &lt;div class="row"&gt;<br/>      &lt;div class="col-md-4"&gt;<br/>        &lt;button id="decBtn"&gt;Decrement--&lt;/button&gt;<br/>      &lt;/div&gt;<br/>      &lt;div class="col-md-4 text-center" id="counter"&gt;0&lt;/div&gt;<br/>      &lt;div class="col-md-4"&gt;<br/>        &lt;button id="incBtn"&gt;Inccrement++&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/> &lt;/div&gt;<br/>&lt;/div&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">User story</h1>
                </header>
            
            <article>
                
<p><em>The user is expected to increment or decrement a counter from the click of a button,</em> basically, <span>a counter that's initialized to</span> <kbd>0</kbd>, <span>an increment button to increment by</span> <kbd>1</kbd>, and <span>a decrement button to decrement by</span> <kbd>1</kbd>.</p>
<p>Rather than littering our code with DOM manipulations and event logic, we can organize them into classes. After all, that's why classes exist:</p>
<pre>// Code 2.4.ts<br/>class DOM {<br/>  private _incBtn: HTMLElement;<br/>  private _decBtn: HTMLElement;<br/>  private _counter: HTMLElement;<br/><br/>  constructor() {<br/>    this._incBtn = this._getDOMElement('#incBtn');<br/>    this._decBtn = this._getDOMElement('#decBtn');<br/>    this._counter = this._getDOMElement('#counter');<br/>  }<br/> <br/> <br/>  public _getDOMElement (selector: string) : HTMLElement {<br/>    return document.querySelector(selector) as HTMLElement;<br/>  }<br/><br/>  get incBtn(): HTMLElement {<br/>    return this._incBtn;<br/>  }<br/><br/>  get decBtn(): HTMLElement {<br/>    return this._decBtn;<br/>  }<br/><br/>  get counter(): number {<br/>    return parseInt(this._counter.innerText);<br/>  }<br/><br/>  set counter(value: number) {<br/>    this._counter.innerText = value.toString();<br/>  }<br/>}</pre>
<p>This is JavaScript looking like a structured language. Let's take some time to explain what is going on:</p>
<ul>
<li>First, we create a class and declare some private properties to hold the temporary state of the HTML DOM elements. Visibility features such as <kbd>private</kbd> are specific to TypeScript only but classes have been around in ES6.</li>
<li>The constructor uses this <kbd>_getDOMElement</kbd> private utility method to query the DOM and initialize the values of the private properties.</li>
<li>The <kbd>incBtn</kbd> and <kbd>decBtn</kbd> getters are used to make the values of these private properties public. This is a common pattern in OOP. Getters are categorized under accessors and available in ES6.</li>
<li>The counter accessors are used to set and retrieve the values of the counter text by converting them to integer and string, respectively.</li>
</ul>
<p>Your first attempt to run this should throw an error, as shown in the following image:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-288 image-border" height="538" src="assets/96f14b4a-7ccc-4e40-a464-f13f7b922968.png" width="1764"/></div>
<p>This is expected because TypeScript compiles to ES3 by default, but getters and setters (accessors) are not available in ES3. To get rid of this error, you can tell the TypeScript compiler that you prefer ES5 rather than ES3:</p>
<pre><strong>"start": "tsc 2.4.ts -w -t es5 &amp; serve --port 5000"</strong></pre>
<p>The <kbd>-t</kbd> flag, alias for <kbd>--target</kbd>, tells TypeScript which version to compile to.</p>
<p>The <kbd>DOMEvent</kbd> class is a lot simpler--just a single method to register all kinds of events when called:</p>
<pre>// Code 2.4.ts<br/>class DOMEvents {<br/>  private register(htmlElement: HTMLElement, type:string, callback: (e: Event) =&gt; void): void {<br/>    htmlElement.addEventListener(type, callback)<br/>  }<br/>}</pre>
<p>The method takes the following:</p>
<ul>
<li>An element to listen for events on</li>
<li>The type of event (for example, <kbd>click</kbd>, <kbd>mouseover</kbd>, and <kbd>dblclick</kbd>) as string</li>
<li>A callback method that returns nothing (<kbd>void</kbd>) but is passed to the event payload</li>
</ul>
<p>The method then uses <kbd>addEventListener</kbd> to register the event.</p>
<p>Finally, we need an entry point for the example. This will be in the form of a class as well and the class will depend on an instance of <kbd>DOM</kbd> and <kbd>DOMEvent</kbd> classes:</p>
<pre>// Code 2.4.ts<br/>class App {<br/>  constructor(public dom:DOM, public domEvents: DOMEvents) {<br/>    this.setupEvents()<br/>  }<br/>  private setupEvents() {<br/>    const buttons = [this.dom.incBtn, this.dom.decBtn];<br/>    buttons.forEach(button =&gt; {<br/>      this.domEvents.register(button, 'click', this.handleClicks.bind(this))<br/>    })<br/>  }<br/>  private handleClicks(e: MouseEvent): void {<br/>    const {id} = &lt;HTMLElement&gt;e.target;<br/>    if(id === 'incBtn') {<br/>      this.incrementCounter();<br/>    } else {<br/>      this.decrementCounter();<br/>    }<br/>  }<br/><br/>  private incrementCounter() {<br/>    this.dom.counter++<br/>  }<br/><br/>  private decrementCounter () {<br/>    this.dom.counter--<br/>  }<br/>}</pre>
<p>Let's discuss how the preceding snippet works:</p>
<ul>
<li>The constructor, which is called when the class is initialized, attempts to set up events using the <kbd>setupEvents</kbd> method.</li>
<li>The <kbd>setupEvents</kbd> method iterates over the list of buttons that we have on the DOM and calls the <kbd>DOMEvents register</kbd> method on each of them</li>
<li>The register method is passed to the button as <kbd>HTMLElement</kbd>, <kbd>click</kbd> as the type of event, and <kbd>handleClicks</kbd> as the event handler. The handler is bound with the right contextual <kbd>this</kbd>. This is always a confusion in JavaScript; Yehuda Katz has explained how it works in a simple manner at <a href="http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/">http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/</a>.</li>
<li>The callback method invokes <kbd>incrementCounter</kbd> or <kbd>decrementCounter</kbd> depending on the ID of the button that is clicked. These methods add or subtract <kbd>1</kbd> from the counter, respectively.</li>
</ul>
<p>You can initialize the app by creating an instance of <kbd>App</kbd>:</p>
<pre>// Code 2.4.ts<br/>(new App(new DOM, new DOMEvents))</pre>
<p>The image shows our newly built slick counter app:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-289 image-border" height="1111" src="assets/e90ced32-94ab-4ba2-885a-f55901e53335.png" width="1800"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Final notes</h1>
                </header>
            
            <article>
                
<p>It's important to point out the cool features we used in these examples once more:</p>
<ul>
<li>Classes</li>
<li>Accessors</li>
<li>Visibility</li>
<li>Arrow functions (callbacks):</li>
</ul>
<pre style="padding-left: 60px">var fooFunc = (arg1) =&gt; {<br/>    return arg1<br/>}</pre>
<ul>
<li>The <kbd>const</kbd> keyword for variable declarations instead of <kbd>var</kbd></li>
<li>Destructuring :</li>
</ul>
<pre style="padding-left: 60px">const {id} = &lt;HTMLElement&gt;e.target;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Some of these features are available natively in the JavaScript environment; TypeScript builds on them to give you a better experience as a developer. This is why it is called a JavaScript superset.</p>
<p>In the next chapter, we will sit back to review and describe these features with more examples to make you get used to the workflow.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>