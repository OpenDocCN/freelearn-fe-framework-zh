- en: Chapter 8. Tooling and Development Experience
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 工具和开发经验
- en: We are already familiar with all the core concepts of Angular. We know how to
    develop a component-based user interface, taking advantage of all the building
    blocks that the framework provides – directives, components, dependency injections,
    pipes, forms, and the brand new router.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了Angular的所有核心概念。我们知道如何开发基于组件的用户界面，利用框架提供的所有构建块——指令、组件、依赖注入、管道、表单以及全新的路由器。
- en: 'For the final step, we''ll look at where to begin when we want to build a **single-page
    application** (**SPA**) from scratch. This chapter describes how to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，我们将探讨当我们想要从头开始构建**单页应用程序**（SPA）时应该从哪里开始。本章描述了以下内容：
- en: Use Web Workers for performance-sensitive applications.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Web Workers来提高性能敏感型应用程序。
- en: Build SEO-friendly applications with server-side rendering.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务器端渲染构建SEO友好的应用程序。
- en: Bootstrap a project as quickly as possible.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽快地启动项目。
- en: Enhance our experience as developers.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升我们的开发者体验。
- en: What is **Ahead-of-Time** (**AoT**) compilation and how to use it.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是**即时编译**（AoT）以及如何使用它。
- en: So, let's begin!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Running an application in a Web Worker
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Web Worker中运行应用程序
- en: When talking about performance in the context of frontend Web development, we
    can either mean network, computational, or rendering performance. In this section,
    we'll concentrate on rendering and computational performance, which are very tightly
    related.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论前端Web开发中的性能时，我们可能指的是网络、计算或渲染性能。在本节中，我们将专注于渲染和计算性能，它们非常紧密相关。
- en: First, let's draw parallels between a Web application and a video file, and
    between a browser and a video player. The biggest difference between the Web application
    running in the browser and the video file playing in the video player is that
    the web page needs to be generated dynamically, in contrast to the video which
    has been recorded, encoded, and distributed. However, in both cases, the user
    of the application sees a sequence of frames; the core difference is in how these
    frames are generated. In the world of video processing, when we play a video,
    we have it already recorded; it is the responsibility of the video decoder to
    extract the individual frames based on the compression algorithm. In contrast
    to this, on the Web, JavaScript, HTML, and CSS are in charge of producing frames
    that are rendered later by the browser's rendering engine.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将Web应用程序与视频文件以及浏览器与视频播放器之间的平行关系进行比较。在浏览器中运行的Web应用程序与在视频播放器中播放的视频文件之间最大的区别是，网页需要动态生成，而视频已经被录制、编码和分发。然而，在这两种情况下，应用程序的用户都会看到一系列的帧；核心区别在于这些帧是如何生成的。在视频处理的世界中，当我们播放视频时，我们已经记录了它；视频解码器的责任是根据压缩算法提取单个帧。相比之下，在Web上，JavaScript、HTML和CSS负责生成随后由浏览器渲染引擎渲染的帧。
- en: In the context of the browser, we can think of each frame as a snapshot of the
    web page at a given moment. The different frames are rendered fast, one after
    the other; so, in theory, the end user of the application should see them smoothly
    incorporated together, just like a video played in a video player.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器环境中，我们可以将每一帧视为给定时刻网页的快照。不同的帧快速渲染，一个接一个；因此，从理论上讲，应用程序的最终用户应该看到它们平滑地结合在一起，就像在视频播放器中播放的视频一样。
- en: On the Web, we try to reach 60 fps (frames per second), which means that each
    frame has about 16 milliseconds to be computed and rendered on the screen. This
    duration includes the time required by the browser to make all the necessary calculations
    for the layout and the rendering of the page (the browser's internal computations),
    and the time that our JavaScript needs to execute.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web上，我们试图达到60 fps（每秒帧数），这意味着每一帧大约有16毫秒的时间来在屏幕上进行计算和渲染。这个持续时间包括浏览器进行布局和页面渲染（浏览器的内部计算）所需的时间，以及我们的JavaScript执行所需的时间。
- en: In the end, we have less than 16 milliseconds (because of the browser's internal
    computations) for our JavaScript to finish its execution. If it doesn't fit in
    this duration, the frame rate will drop by half. Since JavaScript is a single-threaded
    language, all the calculations need to happen in the main UI thread, which can
    lead to a very poor user experience because of the frame drop.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的JavaScript执行时间少于16毫秒（由于浏览器的内部计算），如果它不能在这个时间段内完成，帧率将减半。由于JavaScript是一种单线程语言，所有的计算都需要在主UI线程中发生，这可能导致由于帧率下降而导致的非常差的用户体验。
- en: HTML5 introduced an API called **Web Workers**, which allows the execution of
    client-side code into multiple threads. For the sake of simplicity, the standard
    doesn't allow shared memory between individual threads, but instead allows communication
    with message passing. The messages exchanged between Web Workers and the main
    UI thread must be strings, which often require the serialization and deserialization
    of JSON strings.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5引入了一个名为**Web Workers**的API，它允许客户端代码在多个线程中执行。为了简化，标准不允许各个线程之间共享内存，而是允许通过消息传递进行通信。Web
    Workers和主UI线程之间交换的消息必须是字符串，这通常需要JSON字符串的序列化和反序列化。
- en: 'The lack of shared memory between the individual workers, and the workers and
    the main UI thread brings a couple of limitations, some of which are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于各个工作者之间以及工作者和主UI线程之间缺乏共享内存，这带来了一些限制，以下是一些例子：
- en: Disabled access to the DOM by the worker threads.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁止工作者线程访问DOM。
- en: Global variables cannot be shared among the individual computational units (that
    is, worker threads and main UI threads and vice versa).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局变量不能在各个计算单元（即工作者线程和主UI线程以及反之亦然）之间共享。
- en: Web Workers and Angular
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web Workers和Angular
- en: On account of the platform agnostic design of Angular, the core team decided
    to take advantage of this API; during the summer of 2015, Google embedded Web
    Workers support into the framework. This feature allows most of the Angular applications
    to be run on a separate thread, making the main UI thread responsible only for
    rendering. This helps us achieve the goal of 60 fps much more easily than running
    the entire application in a single thread.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Angular的平台无关设计，核心团队决定利用这个API；在2015年夏天，Google将Web Workers支持嵌入到框架中。这个特性允许大多数Angular应用程序在单独的线程上运行，使得主UI线程只负责渲染。这比在单个线程中运行整个应用程序更容易实现60fps的目标。
- en: Web Workers support is not enabled by default. When enabling it, we need to
    keep something in mind-in a Web Worker-ready application, the components will
    not be run in the main UI thread, which does not allow us to directly manipulate
    the DOM. In this case, we need to use APIs on a higher-level of abstraction, provided
    by Angular, for establishing data binding or manipulating the elements' properties.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Web Workers的支持默认是禁用的。当启用它时，我们需要记住一些事情——在一个为Web Worker准备的应用程序中，组件不会在主UI线程中运行，这不允许我们直接操作DOM。在这种情况下，我们需要使用Angular提供的更高层次的抽象API来建立数据绑定或操作元素的属性。
- en: Bootstrapping an application running in a Web Worker
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Web Worker中启动应用程序
- en: Let's make the to-do application that we developed in [Chapter 4](ch04.html
    "Chapter 4. Getting Started with Angular Components and Directives"), *Getting
    Started with Angular Components and Directives* work in a Web Worker. You can
    find the example that we'll explore at `ch8/ts/todo_webworkers/`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在[第4章](ch04.html "第4章。开始使用Angular组件和指令")中开发的待办事项应用程序*开始使用Angular组件和指令*在Web
    Worker中运行。您可以在`ch8/ts/todo_webworkers/`找到我们将要探索的示例。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the Web Worker module is not finalized yet, so its API may change
    in future versions of Angular. On the other hand, the conceptual idea and the
    architecture are mature enough, so most likely there will not be any fundamental
    differences.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Web Worker模块尚未最终确定，因此其API可能在Angular的未来版本中发生变化。另一方面，其概念理念和架构已经足够成熟，所以很可能不会有任何根本性的差异。
- en: First of all, let's discuss the changes that we will need to make. Take a look
    at `ch4/ts/inputs-outputs/app.ts`. Note that, inside `app.ts`, we include the
    `platformBrowserDynamic` function from the `@angular/platform-browser-dynamic`
    module. This is the first thing we need to modify. The bootstrap process of an
    application running in a background process is different.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论我们需要做出的更改。查看`ch4/ts/inputs-outputs/app.ts`。注意，在`app.ts`内部，我们包含了来自`@angular/platform-browser-dynamic`模块的`platformBrowserDynamic`函数。这是我们首先需要修改的内容。在后台进程中运行的应用程序的引导过程是不同的。
- en: 'Before refactoring our code, let''s take a look at a diagram that illustrates
    the bootstrap process of a typical Angular application running in Web Workers:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在重构我们的代码之前，让我们看一下一个说明典型Angular应用程序在Web Workers中运行时引导过程的图示：
- en: '![Bootstrapping an application running in a Web Worker](img/web-workers.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![在Web Worker中引导应用程序](img/web-workers.jpg)'
- en: Figure 1
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图1
- en: 'This diagram has two parts: **UI** and **WebWorker**. **UI** shows the actions
    performed during initialization in the main UI thread; the **WebWorker** part
    of the diagram shows how the application is bootstrapped in the background thread.
    Now, let''s explain the bootstrap process step-by-step.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 该图分为两部分：**UI**和**WebWorker**。**UI**展示了在主UI线程初始化期间执行的操作；图示的**WebWorker**部分展示了应用程序如何在后台线程中进行引导。现在，让我们一步一步地解释引导过程。
- en: 'First, the user opens the `index.html` page, which triggers the download of
    the following two files:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，用户打开`index.html`页面，这会触发以下两个文件的下载：
- en: The UI bundle of Angular used for applications running in Web Worker.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular用于在Web Worker中运行的应用程序的UI包。
- en: The `system.js` bundle (we talked about the global object `System` in [Chapter
    3](ch03.html "Chapter 3. TypeScript Crash Course"), *TypeScript Crash Course*.
    We can think of the `system.js` bundle as a polyfill for the module loader).
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system.js`包（我们在[第3章](ch03.html "第3章。TypeScript快速入门")中讨论了全局对象`System`，*TypeScript快速入门*。我们可以将`system.js`包视为模块加载器的polyfill）。'
- en: Using `system.js`, we download the script used for the initialization of the
    part of the application running in the main UI thread (`bootstrap.js`). This script
    starts `loader.js` in Web Worker. This is the first script that runs in a background
    thread. Once the worker is started, `loader.js` will download `system.js` and
    the bundle of Angular, which is meant to be run in the background thread. The
    first request will usually hit the cache because `system.js` is already requested
    by the main thread. Using the module loader, we download the script that is responsible
    for bootstrapping the background app `background_bootstrap.js`, which will finally
    start the functionality of our application, in Web Worker.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`system.js`，我们下载用于初始化在主UI线程运行的应用程序部分的脚本（`bootstrap.js`）。此脚本在Web Worker中启动`loader.js`。这是在后台线程中运行的第一个脚本。一旦启动了工作线程，`loader.js`将下载`system.js`和Angular的包，这些包旨在在后台线程中运行。第一次请求通常会命中缓存，因为`system.js`已经被主线程请求。使用模块加载器，我们下载负责引导后台应用程序的脚本`background_bootstrap.js`，它最终将在Web
    Worker中启动我们的应用程序功能。
- en: From now on, the entire application that we built will be run in Web Worker
    and will exchange messages with the main UI thread to respond to user events and
    render instructions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，我们构建的整个应用程序将在Web Worker中运行，并与主UI线程交换消息以响应用户事件和渲染指令。
- en: Now that we are aware of the basic flow of events during initialization when
    using workers, let's refactor our to-do application to take advantage of them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了使用工作线程时初始化期间的基本事件流，让我们重构我们的待办事项应用程序以利用它们。
- en: Migrating an application to Web Worker
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将应用程序迁移到Web Worker
- en: Let's show how we can make an application compatible with Web Workers. This
    way, we can reduce the frame drop in computationally intensive apps, since we'll free
    the main UI thread and let it be responsible only for rendering.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们展示如何使应用程序与Web Workers兼容。这样，我们可以在计算密集型应用程序中减少帧率下降，因为我们将释放主UI线程，让它只负责渲染。
- en: 'Inside `index.html`, we will need to add the following scripts:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.html`内部，我们需要添加以下脚本：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding snippet, we've included references to `system.js`, `zone.js`,
    and `reflect-metadata`. `zone.js` is a polyfill for the zones that Angular exclusively
    uses, that we mentioned earlier in the book. `reflect-metadata` contains another
    polyfill for the Metadata Reflection API, which at the moment of writing is not
    yet available in browsers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们包含了 `system.js`、`zone.js` 和 `reflect-metadata` 的引用。`zone.js` 是 Angular
    独家使用的 zones 的 polyfill，我们在本书中之前提到过。`reflect-metadata` 包含了 Metadata Reflection
    API 的另一个 polyfill，在撰写本文时，该 API 在浏览器中尚不可用。
- en: For the next step, we will explicitly import the `bootstrap.js` file, which
    contains the logic used to start the `loader.js` script in Web Worker.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一步，我们将显式导入 `bootstrap.js` 文件，该文件包含用于在 Web Worker 中启动 `loader.js` 脚本的逻辑。
- en: 'Let''s explore `bootstrap.ts`, which is the original TypeScript version of
    the transpiled `bootstrap.js`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索 `bootstrap.ts`，这是编译后的 `bootstrap.js` 的原始 TypeScript 版本：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We pass `'loader.js'` to the invocation of `bootstrapWorkerUi`. This way, Angular
    knows that `loader.js` will run in a background thread. The script is located
    in the application's root.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `'loader.js'` 传递给 `bootstrapWorkerUi` 的调用。这样，Angular 就知道 `loader.js` 将在后台线程中运行。该脚本位于应用程序的根目录。
- en: 'Now, we can move to the right-hand side of the diagram shown in the *Bootstrapping
    an application running in a Web Worker* section. The logic in `loader.ts` (the
    original TypeScript version of `loader.js`) is quite simple:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以转向 *在 Web Worker 中启动应用程序* 部分所示的图表的右侧。`loader.ts`（`loader.js` 的原始 TypeScript
    版本）中的逻辑非常简单：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As the first step, we import `SystemJS`, `ReflectMetadata` polyfils, `zone.js`,
    and the configuration for `SystemJS`. As this script is already run in Web Workers,
    we have the `importScripts` function, which allows us to load the listed files
    synchronously. As the last step, with `System`, we import the script that contains
    our application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们导入 `SystemJS`、`ReflectMetadata` polyfills、`zone.js` 以及 `SystemJS` 的配置。由于此脚本已经在
    Web Workers 中运行，我们拥有 `importScripts` 函数，它允许我们同步加载列出的文件。作为最后一步，使用 `System`，我们导入包含我们应用程序的脚本。
- en: 'Now, let''s explore how we bootstrap the application inside of the Web Worker:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索如何在 Web Worker 内部启动应用程序：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding process is quite similar to what we used to do when bootstrapping
    an Angular application running in the main UI thread. We import the `platformWorkerAppDynamic` function
    and invoke it with the root module of the application as its first argument.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的过程与我们过去在主 UI 线程中启动 Angular 应用程序时所做的操作非常相似。我们导入 `platformWorkerAppDynamic`
    函数，并使用应用程序的根模块作为其第一个参数来调用它。
- en: Making an application compatible with Web Workers
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使应用程序与 Web Workers 兼容
- en: As we said, the code that runs in the context of Web Worker does not have access
    to the DOM. Let's see what changes we need to make in order to address this limitation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，在 Web Worker 上下文中运行的代码无法访问 DOM。让我们看看我们需要做出哪些更改来解决这个问题。
- en: 'This is the original implementation of the `InputBox` component:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `InputBox` 组件的原始实现：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that, inside the template, we reference the input element with the identifier `todoInput`
    and use the reference within the expression set as the handler of the click event.
    This code will not be able to run in Web Worker, since we directly access a DOM
    element inside the template. In order to take care of this, we will need to refactor
    the snippet, so it uses Angular data binding instead of directly touching any
    element. We can either use inputs when a single direction binding makes sense
    or `NgModel` to achieve two-way data binding, which is a bit more computationally
    intensive.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在模板内部，我们通过标识符 `todoInput` 引用输入元素，并使用引用在表达式集中作为点击事件的处理器。由于我们在模板中直接访问 DOM 元素，这段代码将无法在
    Web Worker 中运行。为了解决这个问题，我们需要重构代码片段，使其使用 Angular 数据绑定而不是直接触摸任何元素。我们可以使用输入来处理单方向绑定，或者使用
    `NgModel` 来实现双向数据绑定，这会稍微消耗更多的计算资源。
- en: 'Let''s use `NgModel`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `NgModel`：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this version of the `InputBox` component, we create a two-way data binding
    between the input element and the `input` property of the `InputBox` component.
    Once the user clicks on the button, the `emitText` method will be invoked, which
    will trigger a new event emitted by `inputText` `EventEmitter`. In order to reset
    the value of the input element, we take advantage of the two-way data binding
    mechanism of Angular and set the value of the `input` property to the empty string;
    this will automatically update the UI.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的 `InputBox` 组件中，我们在输入元素和 `InputBox` 组件的 `input` 属性之间创建了一个双向数据绑定。一旦用户点击按钮，`emitText`
    方法将被调用，这将触发由 `inputText` `EventEmitter` 发射的新事件。为了重置输入元素的值，我们利用 Angular 的双向数据绑定机制，将
    `input` 属性的值设置为空字符串；这将自动更新 UI。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Moving the entire logic from the templates of the components to their controllers
    brings a lot of benefits, such as improved testability, maintainability, code
    reuse, and clarity.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将整个逻辑从组件的模板移动到它们的控制器中，带来了许多好处，例如提高了可测试性、可维护性、代码重用性和清晰度。
- en: The preceding code is compatible with the Web Worker environment, as the `NgModel`
    directive is based on an abstraction that does not manipulate the DOM directly. Instead,
    it delegates this responsibility to another abstraction called `Renderer`, which
    when running in a Web Worker exchanges messages asynchronously with the main UI
    thread.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与 Web Worker 环境兼容，因为 `NgModel` 指令基于一个不直接操作 DOM 的抽象。相反，它将这项责任委托给另一个名为 `Renderer`
    的抽象，当在 Web Worker 中运行时，它与主 UI 线程异步交换消息。
- en: 'To recap, we can say that, while running applications in the context of Web
    Workers, we need to keep the following two things in mind:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，我们可以这样说，在 Web Workers 的上下文中运行应用程序时，我们需要牢记以下两点：
- en: We need to use a different bootstrap process.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要使用不同的引导过程。
- en: We should not access the DOM directly.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不应该直接访问 DOM。
- en: 'Typical scenarios that violate the second point are as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 违反第二点的典型场景如下：
- en: Changing the DOM of the page by selecting an element and manipulating it directly
    with the browser's native APIs or with a third-party library.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过选择一个元素并直接使用浏览器的原生 API 或第三方库来操作它，改变页面的 DOM。
- en: Accessing native elements injected using `ElementRef`.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `ElementRef` 注入的本地元素访问。
- en: Creating a reference to an element in the template and passing it as an argument
    to methods.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板中创建一个元素的引用，并将其作为参数传递给方法。
- en: Directly manipulating an element referenced within the template.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接操作模板中引用的元素。
- en: In all these scenarios, we would need to use the higher-level APIs provided
    by Angular. If we build our applications according to this practice, we will benefit
    not only from being able to run them in Web Workers, but also from increasing
    the code reuse in case we want to use them across different platforms.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些场景中，我们都需要使用 Angular 提供的高级 API。如果我们根据这种做法构建我们的应用程序，我们不仅能从中受益于能够在 Web Workers
    中运行它们，还能在想要在不同平台间使用它们时，增加代码的重用性。
- en: Keeping this in mind and following best practices will also allow us to take
    advantage of server-side rendering.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一点并遵循最佳实践，也将使我们能够利用服务器端渲染的优势。
- en: Initial load of a SPA
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单页应用程序的初始加载
- en: In this section, we will explore what a server-side rendering is, why we need
    it in our applications, and how we can use it with Angular.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨服务器端渲染是什么，为什么我们需要在我们的应用程序中使用它，以及我们如何使用 Angular 来实现它。
- en: 'For our purpose, we''ll explain the typical flow of events when a user opens
    a SPA implemented in Angular. First, we''ll trace the events with the server-side
    rendering disabled, and after that, we''ll see how we can benefit from this feature
    by enabling it. Our example will be illustrated in the context of HTTP 1.1:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的目的，我们将解释当用户打开一个使用 Angular 实现的单页应用程序时，典型的事件流。首先，我们将追踪服务器端渲染禁用时的事件，然后我们将看到如何通过启用此功能来从中受益。我们的示例将在
    HTTP 1.1 的上下文中进行说明：
- en: '![Initial load of a SPA](img/2-3.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![单页应用程序的初始加载](img/2-3.jpg)'
- en: Figure 2
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2
- en: '*Figure 2* shows the first request by the browser and the corresponding server''s
    response when loading a typical SPA. The result that the client will see initially
    is the content of the HTML page without any rendered components.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2* 显示了浏览器在加载典型单页应用程序时的第一个请求以及相应的服务器响应。客户端最初将看到的是 HTML 页面的内容，没有任何渲染的组件。'
- en: Let's suppose that we deploy the to-do application we built in [Chapter 4](ch04.html
    "Chapter 4. Getting Started with Angular Components and Directives"), *Getting
    Started with Angular Components and Directives*, to a web server that has the
    `example.com` domain associated with it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将我们在 [第 4 章](ch04.html "第 4 章。使用 Angular 组件和指令入门") 中构建的待办事项应用程序 *使用 Angular
    组件和指令入门* 部署到一个具有 `example.com` 域名的 Web 服务器上。
- en: 'Once the user navigates to `https://example.com/`, the browser will open a
    new HTTP GET request, fetching the root resource (`/`). When the server receives
    the request, it will respond with an HTML file that, in our case, will look something
    like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户导航到 `https://example.com/` 时，浏览器将打开一个新的 HTTP GET 请求，获取根资源（`/`）。当服务器收到请求时，它将响应一个
    HTML 文件，在我们的例子中，它看起来可能像这样：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The browser will receive this content as the body of the response. When the
    markup is rendered onto the screen, all that the user will see is the **Loading...**
    label.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器将接收这些内容作为响应的主体。当标记渲染到屏幕上时，用户将看到的只是 **加载中...** 标签。
- en: In the next step, the browser will find all the references in the HTML file's
    external resources, such as styles and scripts, and start to download them. In
    our case, some of them are `bootstrap.css`, `es6-shim.min.js`, `Reflect.js`, `system.src.js`,
    and `angular-polyfills.js`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，浏览器将找到 HTML 文件外部资源中的所有引用，例如样式和脚本，并开始下载它们。在我们的例子中，其中一些是 `bootstrap.css`、`es6-shim.min.js`、`Reflect.js`、`system.src.js`
    和 `angular-polyfills.js`。
- en: Once all the referenced resources are available, there still won't be any significant
    visual progress for the user (except if the styles from the downloaded CSS file
    are applied to the page). This won't change until the JavaScript virtual machine
    processes all the referenced scripts related to the application's implementation.
    At this point, Angular will know which component needs to be rendered based on
    the current URL and configuration.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有引用的资源都可用，用户仍然不会看到任何显著的视觉进度（除非下载的 CSS 文件中的样式应用到页面上）。这不会改变，直到 JavaScript 虚拟机处理完与应用程序实现相关的所有引用脚本。此时，Angular
    将根据当前 URL 和配置知道需要渲染哪个组件。
- en: If the component associated with the page is defined in a separate file outside
    of our main application bundle, the framework will need to download it together
    with its entire dependency graph.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与页面关联的组件定义在我们主应用程序包之外的一个单独的文件中，框架需要下载它以及它的整个依赖图。
- en: If we're using JiT compilation, in case the template and the styles of the component
    are externalized, Angular will need to download them as well before it is able
    to render the requested page. Right after this, the framework will be able to
    compile the template associated with the target component and render the page.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用即时编译（JiT compilation），在组件的模板和样式被外部化时，Angular 需要下载它们才能渲染请求的页面。在此之后，框架将能够编译与目标组件关联的模板并渲染页面。
- en: 'In this scenario, these are the two main pitfalls:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，有两个主要的陷阱：
- en: In case of large applications and/or poor Internet connection, the user experience
    will be poor.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大型应用程序和/或网络连接不佳的情况下，用户体验将会很差。
- en: Search engines are not that good at indexing dynamic content generated by JavaScript;
    this means that the **SEO** (**Search Engine Optimization**) of our SPA will suffer.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索引擎在索引由 JavaScript 生成的动态内容方面并不擅长；这意味着我们的 SPA 的 SEO 将会受到影响。
- en: In the past, we solved the SEO issue in the applications built with AngularJS
    with different workarounds, such as using a headless browser for rendering the
    requested page, caching it onto the disk, and later providing it to search engines.
    However, there's a more elegant solution.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，我们通过不同的解决方案解决了使用 AngularJS 构建的应用程序中的 SEO 问题，例如使用无头浏览器渲染请求的页面，将其缓存到磁盘上，然后提供给搜索引擎。然而，有一个更优雅的解决方案。
- en: Initial load of a SPA with server-side rendering
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端渲染的 SPA 的初始加载
- en: A couple of years ago, libraries such as *Rendr*, *Derby*, *Meteor*, and the
    others introduced the concept of **isomorphic** JavaScript applications, which
    were later renamed **universal**. In essence, universal applications could be
    run both on the client and on the server. Such portability is only possible in
    the case of low coupling between the SPA and the browser's APIs. The greatest
    benefit of this paradigm is that the application can be rendered on the server
    and sent to the client.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，像*Rendr*、*Derby*、*Meteor*等库引入了**同构**JavaScript应用程序的概念，后来将其更名为**通用**。本质上，通用应用程序可以在客户端和服务器上运行。这种可移植性只有在SPA和浏览器API之间耦合度低的情况下才可能实现。这种范式最大的好处是应用程序可以在服务器上渲染并发送到客户端。
- en: Universal applications are not framework specific; we can take advantage of
    them in any framework that can be run outside of the environment of the browser.
    Conceptually, the practice of server-side rendering is very similar across platforms
    and libraries; only its implementation details may differ. For instance, the Angular
    Universal module, which implements server-side rendering, supports node.js as
    well as ASP.NET.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通用应用程序不是框架特定的；我们可以在任何可以在浏览器环境之外运行的环境中利用它们。从概念上讲，服务器端渲染的实践在平台和库之间非常相似；只有其实施细节可能不同。例如，实现服务器端渲染的Angular
    Universal模块支持node.js以及ASP.NET。
- en: '![Initial load of a SPA with server-side rendering](img/3-3.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![使用服务器端渲染的SPA的初始加载](img/3-3.jpg)'
- en: Figure 3
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图3
- en: '*Figure 3* shows the response by the server to the initial browser GET request.
    This time, in contrast to the typical scenario of loading a SPA, the browser will
    receive the HTML of the rendered page.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3* 展示了服务器对初始浏览器GET请求的响应。这次，与加载SPA的典型场景不同，浏览器将接收到渲染页面的HTML。'
- en: Let's trace the flow of the events in the same application with the server-side
    rendering feature enabled. In this case, once the server receives the HTTP GET
    request by the browser, it will run the SPA on the server in the environment of
    node.js. All the DOM calls will be redirected to a server-side DOM implementation
    and executed in the context of the used platform. Similarly, all the AJAX calls
    with the Angular HTTP module will be handled by the server-side implementation
    of the module. This way, the application will not make any difference, whether
    it is running in the context of the browser or the server.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跟踪启用服务器端渲染功能的应用程序中的事件流。在这种情况下，一旦服务器接收到浏览器发出的HTTP GET请求，它将在node.js环境中运行SPA。所有的DOM调用都将被重定向到服务器端DOM实现并在使用平台的上下文中执行。同样，所有使用Angular
    HTTP模块的AJAX调用都将由模块的服务器端实现处理。这样，应用程序在浏览器或服务器上下文中运行时不会有任何区别。
- en: Once the rendered version of the SPA is available, it can be serialized to HTML
    and sent to the browser. This time, during the application's initialization, instead
    of the **Loading...** label, the user will see the page they requested right away.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦SPA的渲染版本可用，它可以被序列化为HTML并发送到浏览器。这次，在应用程序初始化期间，用户将立即看到他们请求的页面，而不是**加载中...**标签。
- en: Note that, at this point, the client will have the rendered version of the application,
    but all the referenced external resources, such as scripts and styles, still need
    to be available. This means that, initially, none of the CSS styles declared in
    the external files will be applied and the application will not be responsive
    to any user-related interactions, such as the mouse and keyboard events.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此时，客户端将拥有应用程序的渲染版本，但所有引用的外部资源，如脚本和样式，仍然需要可用。这意味着，最初，外部文件中声明的所有CSS样式都不会应用，并且应用程序不会响应用户相关的交互，如鼠标和键盘事件。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that in case the scripts are inlined on the server-side rendered page,
    the application will be responsive to user events. However, inlining big chunks
    of JavaScript is generally considered a bad practice, as it will increase the
    page's size dramatically and prevent the scripts from caching; both will influence
    the network performance.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果脚本在服务器端渲染的页面上内联，应用程序将响应用户事件。然而，通常认为内联大量JavaScript是一种不良做法，因为它会极大地增加页面大小并阻止脚本缓存；这两者都会影响网络性能。
- en: When the JavaScript virtual machine processes the JavaScript associated with
    the page, our SPA will be ready to use.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当JavaScript虚拟机处理页面相关的JavaScript时，我们的SPA将准备好使用。
- en: Server-side rendering with Angular
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Angular进行服务器端渲染
- en: During the first half of 2015, Patrick Stapleton and Jeff Whelpley announced
    that they had started the development of the module, **Universal**. Universal
    is a library that allows us to build universal (also called isomorphic) JavaScript
    applications with Angular; in other words, it provides server-side rendering support.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在2015年的前半段，帕特里克·斯塔普尔顿和杰夫·惠普利宣布他们已经开始开发模块**Universal**。Universal是一个库，允许我们使用Angular构建通用（也称为同构）JavaScript应用程序；换句话说，它提供了服务器端渲染支持。
- en: Applications using Angular Universal and rendered on the server will not be
    responsive to user interaction until all the JavaScript belonging to the requested
    page has been processed. This is a drawback that we already mentioned, which is
    valid for all server-side rendered applications. To handle this problem, Patrick
    and Jeff introduced **preboot.js**, which is a lightweight library that will be
    inlined on the page rendered by the server and available after the initial client
    request.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Angular Universal并在服务器上渲染的应用程序，在请求页面的所有JavaScript被处理之前，不会响应用户交互。这是我们之前提到的一个缺点，适用于所有服务器端渲染的应用程序。为了处理这个问题，帕特里克和杰夫引入了**preboot.js**，这是一个轻量级的库，它将被内联在服务器渲染的页面上，并在初始客户端请求之后可用。
- en: 'Preboot.js has several strategies for the management of the received client
    events before the application is completely initialized; they are as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Preboot.js在应用程序完全初始化之前对收到的客户端事件有几种管理策略；它们如下：
- en: Recording and playing back events.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录和回放事件。
- en: Responding immediately to events.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即对事件做出响应。
- en: Maintaining focus when a page is re-rendered.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在页面重新渲染时保持专注。
- en: Buffering client-side re-rendering for smoother transition.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存客户端重新渲染以实现更平滑的过渡。
- en: Freezing a page until the bootstrap is complete if a user clicks on a button.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户点击按钮，则冻结页面直到引导程序完成。
- en: At the time of writing this book, the Universal module was still being actively
    developed. You can give it a try using the Angular universal starter at [https://github.com/angular/universal-starter](https://github.com/angular/universal-starter)
    .
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，通用模块仍在积极开发中。您可以使用Angular通用启动器尝试它，链接为[https://github.com/angular/universal-starter](https://github.com/angular/universal-starter)。
- en: Enhancing our development experience
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升我们的开发体验
- en: Our experience as developers can be enhanced in terms of productivity or by
    allowing us to have more fun while working on our projects. This can be achieved
    with all the tools, IDEs, text editors, and more, which we use on a daily basis.
    In this section, we'll take a brief look at popular IDEs and text editors that
    take advantage of the statically analyzable syntax that Angular provides. We'll
    also mention the language service that the Angular team developed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们作为开发者的经验可以通过提高生产力或在工作项目上工作时让我们更有趣来增强。这可以通过我们每天使用的所有工具、IDE、文本编辑器等来实现。在本节中，我们将简要介绍一些流行的IDE和文本编辑器，它们利用Angular提供的可静态分析的语法。我们还将提到Angular团队开发的语言服务。
- en: Text editors and IDEs
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本编辑器和IDE
- en: 'As we have already said at the beginning of the book, the core team put a lot
    of effort into enhancing the tooling support in Angular. First of all, the framework
    is built with TypeScript, which naturally allows us to use static typing during
    our development process. Some of the text editors and IDEs that have great TypeScript
    support are as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在本书开头所说，核心团队在Angular中投入了大量精力来增强工具支持。首先，该框架是用TypeScript构建的，这自然允许我们在开发过程中使用静态类型。以下是一些具有出色TypeScript支持的文本编辑器和IDE：
- en: '**IntelliJ Idea**: A general-purpose IDE by JetBrains.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IntelliJ Idea**：由JetBrains提供的一个通用IDE。'
- en: '**WebStorm**: An IDE specialized for Web development by JetBrains.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebStorm**：由JetBrains专门为Web开发定制的IDE。'
- en: '**VSCode**: A cross-platform text editor written in TypeScript and developed
    by Microsoft.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VSCode**：由微软开发的一个基于TypeScript的跨平台文本编辑器。'
- en: '**Sublime Text**: A cross-platform text editor.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sublime Text**：一个跨平台文本编辑器。'
- en: '**Atom**: A cross-platform text editor written in JavaScript, based on Electron.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Atom**：一个基于Electron的跨平台文本编辑器，用JavaScript编写。'
- en: Recently, JetBrains announced advanced Angular support in IntelliJ Idea and
    WebStorm, which supports autocompletion for components and bindings.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，JetBrains宣布在IntelliJ Idea和WebStorm中提供高级Angular支持，支持组件和绑定的自动完成。
- en: Although not all the mentioned IDEs and text editors have Angular-specific features at
    the time of writing this book, the framework comes with tooling in mind. It allows
    us to perform advanced static code analysis on the application's code base for
    the development of sophisticated refactoring and productivity tools in the near
    future.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在撰写本书时，并非所有提到的 IDE 和文本编辑器都具有 Angular 特定功能，但该框架旨在提供工具。它允许我们对应用程序的代码库进行高级静态代码分析，以便在不久的将来开发复杂的重构和生产率工具。
- en: Angular language service
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 语言服务
- en: Taking advantage of the analyzable nature of Angular, Google developed a **language
    service** for the framework. We can think of this service as a server, which indexes
    our project and provides autocompletion suggestions, type checking in templates,
    based on requests from a client. This client can be a plugin of our text editor
    or IDE.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 Angular 的可分析性，Google 为该框架开发了一个 **语言服务**。我们可以将此服务视为一个服务器，它索引我们的项目并提供基于客户端请求的自动完成建议、模板中的类型检查。此客户端可以是我们的文本编辑器或
    IDE 的插件。
- en: The language service can keep track of the context of the given component that
    is in focus in your text editor and provide context-specific suggestions. For
    instance, it can provide autocompletion suggestions for directive selectors based
    on the available set of directives at the given part of the component tree.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 语言服务可以跟踪您文本编辑器中当前聚焦的组件的上下文，并提供上下文特定的建议。例如，它可以基于组件树中给定部分的可用指令集提供指令选择器的自动完成建议。
- en: The best thing about the language service is that it is not coupled to any specific
    text editor or IDE, which means that, with a thin plugin, it can be reused in
    any development environment.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 语言服务的最好之处在于它不与任何特定的文本编辑器或 IDE 绑定，这意味着，通过一个轻量级的插件，它可以在任何开发环境中重用。
- en: Bootstrapping a project with angular-cli
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 angular-cli 启动项目
- en: During AngularConnect 2015, Brad Green and Igor Minar, part of the Angular team,
    announced `angular-cli`-a **CLI** (**command-line interface**) tool to ease starting
    and managing Angular applications. For those who have used Ruby on Rails, the
    idea behind the CLI tool might be familiar. The basic purpose of the tool is to
    allow the quick setup of new projects and scaffolding of new directives, components,
    pipes, and services.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2015 年的 AngularConnect 大会上，Angular 团队成员 Brad Green 和 Igor Minar 宣布了 `angular-cli`——一个
    **CLI**（**命令行界面**）工具，旨在简化 Angular 应用程序的启动和管理。对于那些使用过 Ruby on Rails 的人来说，CLI 工具背后的理念可能很熟悉。该工具的基本目的是允许快速设置新项目和构建新的指令、组件、管道和服务。
- en: At the time of writing, the tool is based on webpack and is in the early stages
    of development, so we'll demonstrate only its basic usage.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，该工具基于 webpack，处于开发初期阶段，因此我们只演示其基本用法。
- en: Using angular-cli
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 angular-cli
- en: 'In order to install the CLI tool, run the following command on your terminal:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装 CLI 工具，请在您的终端运行以下命令：
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Right after this, the `ng` command will appear as global executable in your
    system. For creating a new Angular project, use the following commands:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，`ng` 命令将出现在您的系统中作为全局可执行命令。要创建一个新的 Angular 项目，请使用以下命令：
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding commands will perform the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将执行以下操作：
- en: Create a new Angular project and install all of its node.js dependencies.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的 Angular 项目并安装其所有的 node.js 依赖。
- en: Enter your project's directory.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入您项目的目录。
- en: Start a development web server that will let you open the application you have
    just created in your web browser.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动一个开发 Web 服务器，这将允许您在 Web 浏览器中打开您刚刚创建的应用程序。
- en: For further reading, take a look at the project's repository, located at [https://github.com/angular/angular-cli](https://github.com/angular/angular-cli)
    .
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步了解，请查看位于 [https://github.com/angular/angular-cli](https://github.com/angular/angular-cli)
    的项目仓库。
- en: Angular quick starters
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 快速入门
- en: If you prefer to not get coupled with the CLI tool, there are a lot of starter
    projects developed by the community that can provide a great starting point for
    your next Angular project.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想与 CLI 工具绑定，社区已经开发了大量的入门项目，这些项目可以为您的下一个 Angular 项目提供一个很好的起点。
- en: Angular Seed
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular Seed
- en: If you enjoy static typing, you can give the **angular-seed** project a try.
    It is hosted on GitHub at  [https://github.com/mgechev/angular-seed](https://github.com/mgechev/angular-seed)
    .
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢静态类型，您可以尝试 **angular-seed** 项目。该项目托管在 GitHub 上，地址为 [https://github.com/mgechev/angular-seed](https://github.com/mgechev/angular-seed)。
- en: 'The Angular Seed provides the following key features:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Seed 提供以下关键特性：
- en: Easy for extend, modular, and statically typed build systems.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于扩展、模块化和静态类型构建系统。
- en: AoT compilation support.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持AoT编译。
- en: Supports multiple Angular applications with a shared code base in a single instance
    of the seed.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持在单个种子实例中运行多个具有共享代码库的Angular应用程序。
- en: Production and development builds.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产环境和开发环境的构建。
- en: Sample unit tests with Jasmine and Karma.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jasmine和Karma的示例单元测试。
- en: End-to-end tests with Protractor.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Protractor进行端到端测试。
- en: A development server with LiveReload.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有LiveReload的开发服务器。
- en: Uses codelyzer for static code analysis, which verifies that your project follows
    the Angular style guide to some extent.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用codelyzer进行静态代码分析，这将在一定程度上验证您的项目是否遵循Angular风格指南。
- en: Follows the best practices for your applications' and files' organization.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循应用程序和文件组织的最佳实践。
- en: Manager for the TypeScript-related type definitions.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript相关类型定义的管理器。
- en: Provides full Docker support for both development and production environment.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为开发和生产环境提供完整的Docker支持。
- en: The code distributed with the book is based on this seed project.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 书中提供的代码基于此种子项目。
- en: 'For `angular-seed`, you will need to have node.js, npm, and git installed and
    will need to run the following list of commands:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`angular-seed`，您需要安装node.js、npm和git，并运行以下命令列表：
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After you have run the preceding commands, your browser will automatically open
    the home page of the seed. Upon the change of any of the files in your project,
    the application will be automatically rebuilt, and your browser will be refreshed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行上述命令之后，您的浏览器将自动打开种子项目的首页。当您的项目中的任何文件发生变化时，应用程序将自动重新构建，并且您的浏览器将被刷新。
- en: By default, the production build produces a single bundle that contains a minified
    version of the application and all the referenced libraries. Angular Seed also
    supports AoT compilation and extensible build systems.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，生产构建会生成一个包含应用程序和所有引用库的压缩版本的单一包。Angular Seed也支持AoT编译和可扩展的构建系统。
- en: Angular 2 Webpack starter
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 2 Webpack启动器
- en: If you prefer Webpack, you can use *angular2-webpack-starter*. It is a starter
    project developed by *AngularClass* and hosted on GitHub. You can find it at 
    [https://github.com/AngularClass/angular2-webpack-starter](https://github.com/AngularClass/angular2-webpack-starter)
    .
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢Webpack，可以使用*angular2-webpack-starter*。这是一个由*AngularClass*开发的启动项目，托管在GitHub上。您可以在[https://github.com/AngularClass/angular2-webpack-starter](https://github.com/AngularClass/angular2-webpack-starter)找到它。
- en: 'This starter provides the following features:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此启动器提供了以下功能：
- en: The best practices in file and application organization for Angular.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular文件和应用程序组织的最佳实践。
- en: Ready-to-go build system using Webpack for working with TypeScript.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Webpack构建系统即可快速上手，适用于TypeScript。
- en: Testing Angular code with Jasmine and Karma.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jasmine和Karma测试Angular代码。
- en: Coverage with Istanbul and Karma.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Istanbul和Karma进行覆盖率分析。
- en: End-to-end Angular code using Protractor.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Protractor进行端到端Angular代码测试。
- en: Type manager with Typings.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Typings的类型管理器。
- en: 'In order to give it a try, you will need to have node.js, npm, and git installed
    and run the following commands:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试它，您需要安装node.js、npm和git，并运行以下命令：
- en: '[PRE10]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: AoT compilation in Angular
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular中的AoT编译
- en: In this section, we'll briefly explain what AoT compilation is in the context
    of Angular and what implication it may have on our projects, without going into
    deep technical details.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要解释在Angular的上下文中AoT编译是什么，以及它可能对我们项目产生的影响，而不深入技术细节。
- en: The key focus in Angular is it's extremely fast change detection mechanism.
    After exploring different options for performing change detection, the Angular
    team discovered that the change detection mechanism used in AngularJS can be improved
    dramatically using **code generation**. It turns out that generating code, which
    performs change detection and rendering and on top of that is very well optimized
    for the JavaScript virtual machine, runs much faster compared to the traditional
    (also known as dynamic) change detection mechanism.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，其关键焦点是它极其快速的变更检测机制。在探索执行变更检测的不同选项后，Angular团队发现，AngularJS中使用的变更检测机制可以通过**代码生成**进行显著改进。结果是，执行变更检测和渲染的代码，并且在此基础上对JavaScript虚拟机进行了非常好的优化，其运行速度比传统的（也称为动态的）变更检测机制快得多。
- en: How code generation works
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码生成的工作原理
- en: The Angular code generator is known as the Angular compiler. What it does is
    compile the templates of the Angular components to JavaScript or TypeScript (depending
    on the use case). When we compile the templates to TypeScript, we allow the TypeScript
    compiler to perform type checking, not only within the imperative logic of our
    components, directives, services and pipes, but also in the components' templates!
    Performing type checking in the templates helps us find even more potential issues
    in our application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 代码生成器也被称为 Angular 编译器。它所做的就是将 Angular 组件的模板编译成 JavaScript 或 TypeScript（取决于使用情况）。当我们把模板编译成
    TypeScript 时，我们允许 TypeScript 编译器执行类型检查，不仅在我们的组件、指令、服务和管道的命令式逻辑中，而且在组件的模板中！在模板中执行类型检查有助于我们在应用程序中找到更多潜在的问题。
- en: On top of code generation for templates, the Angular compiler also generates
    code for the injectors in our application. This improves the performance of the
    dependency injection mechanism even further.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为模板生成代码之外，Angular 编译器还会为我们的应用程序中的注入器生成代码。这进一步提高了依赖注入机制的效率。
- en: Based on the static analysis of the bindings in the templates, the generated
    code for the templates performs the most efficient change detection and most optimal
    update of the DOM tree, depending on the changed values. On top of that, the produced
    code takes advantage of the inline caching mechanism of JavaScript virtual machines,
    which brings an additional performance boost.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 基于对模板中绑定的静态分析，生成的模板代码执行最有效的变更检测和最优化更新 DOM 树的操作，这取决于变化值。除此之外，生成的代码还利用了 JavaScript
    虚拟机的内联缓存机制，从而带来额外的性能提升。
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For further reading about inline caching, take a look at the article *Explaining
    JavaScript VMs in JavaScript - Inline Caches* located at [http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html](http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于内联缓存的信息，请查看位于 [http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html](http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html)
    的文章《在 JavaScript 中解释 JavaScript 虚拟机 - 内联缓存》。
- en: The code generation could be either performed at runtime, known as **Just-in-Time**
    (**JiT**) compilation or build time, known as **Ahead-of-Time** (**AoT**) compilation.
    Since the JiT compilation involves the evaluation of code at runtime, it is recommended
    that you use AoT in environments with strict **CSP** (**Content-Security-Policy**),
    where `eval` is not available.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生成可以是运行时执行，称为 **即时编译**（**JiT**）或构建时执行，称为 **提前编译**（**AoT**）。由于 JiT 编译涉及在运行时评估代码，因此建议在
    `eval` 不可用的严格 **CSP**（**内容安全策略**）环境中使用 AoT。
- en: Introducing AoT compilation
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 AoT 编译
- en: From AoT, we get a couple of improvements. Firstly, if we compile our Angular
    application as part of the build process, we don't need to compile it at runtime.
    This has two implications. Firstly, we don't have the runtime performance hit
    that we get when using JiT. This way, AoT offers faster initial rendering of the
    application because Angular has to do less work during initialization.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 从 AoT（Ahead-of-Time）编译中，我们可以获得一些改进。首先，如果我们将 Angular 应用程序作为构建过程的一部分进行编译，我们就不需要在运行时进行编译。这有两个影响。首先，我们避免了使用
    JiT（Just-in-Time）时遇到的运行时性能损失。这样，AoT 提供了更快的应用程序初始渲染速度，因为 Angular 在初始化期间需要做的工作更少。
- en: On top of that, since we don't have to perform compilation at runtime anymore, we
    can drop the entire `@angular/compiler` module out of the final application bundle
    and decrease the bundle size.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们不再需要在运行时执行编译，我们可以将整个 `@angular/compiler` 模块从最终的应用程序包中删除，从而减小包的大小。
- en: Finally, we can perform much more efficient dead code elimination in terms of
    **tree-shaking**. Tree-shaking means dropping unused exports, which is one of
    the great properties of the static nature of the ES2015 modules. When relaying
    on JiT compilation, we can reference different components by their selectors inside
    the templates. However, the templates are in HTML-like format, which the modern
    minifiers (such as uglifyjs, Google Closure Compiler, and so on) don't understand.
    This means that they cannot eliminate all the unused exports (for instance, unused
    components), since they are not sure what exactly is used within the templates.
    Once at build time, the Angular compiler translates the templates to TypeScript
    or JavaScript, with static ES2015 imports, bundlers can apply traditional dead-code
    elimination techniques, and so reduce the bundle size even further!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过 **tree-shaking** 来执行更有效的死代码消除。Tree-shaking 意味着删除未使用的导出，这是 ES2015 模块的静态性质的一个优点。当依赖于
    JiT 编译时，我们可以在模板内部通过选择器引用不同的组件。然而，模板是类似 HTML 的格式，现代的压缩器（如 uglifyjs、Google Closure
    Compiler 等）无法理解。这意味着它们不能消除所有未使用的导出（例如，未使用的组件），因为它们不确定模板中确切使用了什么。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're interested in further reading, you can take a look at the article
    *Ahead-of-Time Compilation in Angular* at [https://goo.gl/eXieJl](https://goo.gl/eXieJl).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣，可以查看关于 Angular 的 AoT 编译的文章 *Angular 中的即时编译* [https://goo.gl/eXieJl](https://goo.gl/eXieJl)。
- en: Constraints of the AoT compilation
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AoT 编译的限制
- en: Keep in mind that the Angular compiler needs type metadata in order to perform
    the process of compilation. This means that you cannot perform AoT compilation
    if you're not using TypeScript.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Angular 编译器需要类型元数据才能执行编译过程。这意味着如果你不使用 TypeScript，你将无法执行 AoT 编译。
- en: AoT compilation is performed without any data collected at runtime. This means
    that, in some cases, your code may work with JiT but may not work in AoT in case
    you have dynamic constructs, which cannot be resolved at build time.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: AoT 编译是在运行时没有收集任何数据的情况下进行的。这意味着在某些情况下，如果你的代码在 JiT 下可以工作，但在 AoT 下由于动态结构（这些结构在构建时无法解析）可能无法工作。
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For further details, take a look at this repository at   [https://goo.gl/F7cV1s](https://goo.gl/F7cV1s).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更详细的信息，请查看这个存储库[https://goo.gl/F7cV1s](https://goo.gl/F7cV1s)。
- en: Finally, the generated code for the templates is not part of the components'
    controllers themselves. This means that we cannot bind to non-public fields because,
    during compilation, TypeScript will throw an error.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，模板生成的代码本身不是组件控制器的一部分。这意味着我们不能绑定到非公共字段，因为在编译过程中，TypeScript 会抛出一个错误。
- en: How to use the AoT compilation of Angular
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用 Angular 的 AoT 编译
- en: The Angular's AoT compilation is already supported in the most popular starters
    and the CLI.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的 AoT 编译已经在最受欢迎的启动器和 CLI 中得到支持。
- en: 'At the time of writing, Angular CLI does not perform an AoT compilation by
    default. You can enable it using the `--aot` flag:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Angular CLI 默认不执行 AoT 编译。你可以使用 `--aot` 标志来启用它：
- en: '[PRE11]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Angular Seed introduced AoT compilation when Angular 2.0.0-rc.5 was released.
    With the seed, you can take advantage of all the benefits that come with it by
    performing:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Angular 2.0.0-rc.5 发布时，Angular Seed 引入了 AoT 编译。有了这个种子，你可以通过执行以下操作来利用它带来的所有好处：
- en: '[PRE12]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By running the commands above, you'll get a well-optimized production build
    of your application.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行上述命令，你将获得一个优化良好的应用程序生产构建。
- en: Note
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since web tooling changes quite frequently, we didn't go into details of how
    Angular Seed or Angular CLI produce the production build. If you're interested
    in further reading on what is going on under the hood, you can take a look at
    an article at [https://goo.gl/kAiJUJ](https://goo.gl/kAiJUJ).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网络工具频繁变化，我们没有深入探讨 Angular Seed 或 Angular CLI 如何生成生产构建的细节。如果你对底层发生的事情感兴趣，可以查看这篇文章[https://goo.gl/kAiJUJ](https://goo.gl/kAiJUJ)。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started our journey by introducing the reasons behind the rewrite of Angular,
    which was followed by a conceptual overview that gave us a general idea about
    the building blocks that the framework provides. In the next step, we went through
    a TypeScript crash course that prepared us for [Chapter 4](ch04.html "Chapter 4. Getting
    Started with Angular Components and Directives"), *Getting Started with Angular
    Components and Directives*, where we went deep into Angular's directives, components,
    and change detection.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过介绍Angular重写的背后原因开始了我们的旅程，随后是一个概念概述，它给了我们关于框架提供的构建块的一般想法。在下一步，我们进行了一次TypeScript速成课程，为我们准备[第4章](ch04.html
    "第4章。Angular组件和指令入门")，*Angular组件和指令入门*，在那里我们深入探讨了Angular的指令、组件和变更检测。
- en: In [Chapter 5](ch05.html "Chapter 5. Dependency Injection in Angular"), *Dependency
    Injection in Angular*,we explained the dependency injection mechanism and saw
    how it's related to the component hierarchy. In the next chapters, we saw how
    we can build forms and pipes and take advantage of Angular's router.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。Angular中的依赖注入")，*Angular中的依赖注入*中，我们解释了依赖注入机制，并看到了它与组件层次结构的关系。在接下来的章节中，我们看到了如何构建表单和管道，并利用Angular的路由器。
- en: By completing this chapter, we have finished our journey into the framework.
    At the time of writing, the design decisions and the ideas behind Angular's core
    are solid and finalized. Although the framework is still brand new, in the past
    couple of months, its ecosystem reached a level where we can develop production-ready,
    high-performance, SEO-friendly applications, and on top of this, have a great
    development experience with static typing and IDE support.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成本章，我们完成了对框架的探索之旅。在撰写本文时，Angular核心的设计决策和背后的理念已经稳固并最终确定。尽管框架仍然非常新，但在过去的几个月里，其生态系统已经达到了一个水平，我们可以开发出生产就绪、高性能、SEO友好的应用程序，并且在此基础上，通过静态类型和IDE支持拥有出色的开发体验。
