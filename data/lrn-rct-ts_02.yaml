- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Introducing TypeScript
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 TypeScript
- en: In this chapter, we will start by understanding what TypeScript is and how it
    provides a much richer type system on top of JavaScript. We will learn about the
    basic types in TypeScript, such as numbers and strings, and then learn how to
    create our own types to represent objects and arrays using different TypeScript
    features. Finally, we will finish the chapter by understanding the TypeScript
    compiler and its key options in a React app.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先了解 TypeScript 是什么，以及它是如何在 JavaScript 之上提供更丰富的类型系统的。我们将学习 TypeScript
    中的基本类型，如数字和字符串，然后学习如何使用不同的 TypeScript 功能创建自己的类型来表示对象和数组。最后，我们将通过理解 TypeScript
    编译器及其在 React 应用程序中的关键选项来结束本章。
- en: By the end of the chapter, you’ll be ready to learn how to use TypeScript to
    build frontends with React.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将准备好学习如何使用 TypeScript 来构建带有 React 的前端。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the benefits of TypeScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 TypeScript 的好处
- en: Understanding JavaScript types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 JavaScript 类型
- en: Using basic TypeScript types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基本的 TypeScript 类型
- en: Creating TypeScript types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 TypeScript 类型
- en: Using the TypeScript compiler
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TypeScript 编译器
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will use the following technologies in this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下技术：
- en: '**Browser**: A modern browser such as Google Chrome.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浏览器**：一个现代浏览器，如 Google Chrome。'
- en: '**TypeScript Playground**: This is a website at https://www.typescriptlang.org/play/
    that allows you to play around with and understand the features of TypeScript
    without installing it.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TypeScript Playground**：这是一个位于 https://www.typescriptlang.org/play/ 的网站，允许您在不安装
    TypeScript 的情况下探索其功能和理解其特性。'
- en: '**CodeSandbox**: We’ll briefly use this online tool to explore JavaScript’s
    type system. This can be found at [https://codesandbox.io/](https://codesandbox.io/).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CodeSandbox**：我们将简要使用这个在线工具来探索 JavaScript 的类型系统。这个工具可以在 [https://codesandbox.io/](https://codesandbox.io/)
    找到。'
- en: '**Visual Studio Code**: We’ll need an editor to experience TypeScript’s benefits
    and explore the TypeScript compiler. This one can be installed from [https://code.visualstudio.com/](https://code.visualstudio.com/).
    Other editors that could be used can be found at [https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**：我们需要一个编辑器来体验 TypeScript 的好处并探索 TypeScript 编译器。这个编辑器可以从
    [https://code.visualstudio.com/](https://code.visualstudio.com/) 安装。其他可用的编辑器可以在
    [https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support)
    找到。'
- en: '**Node.js** and **npm**: TypeScript is dependent on these pieces of software.
    You can install them from [https://nodejs.org/en/download/](https://nodejs.org/en/download/).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js** 和 **npm**：TypeScript 依赖于这些软件组件。您可以从 [https://nodejs.org/en/download/](https://nodejs.org/en/download/)
    安装它们。'
- en: All the code snippets in this chapter can be found online at [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter2](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter2).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码片段都可以在以下网址找到：[https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter2](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter2)。
- en: Understanding the benefits of TypeScript
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 TypeScript 的好处
- en: In this section, we will start by understanding what TypeScript is, how it relates
    to JavaScript, and how TypeScript enables teams to be more productive.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先了解 TypeScript 是什么，它与 JavaScript 的关系，以及 TypeScript 如何使团队更高效。
- en: Understanding TypeScript
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 TypeScript
- en: TypeScript was first released in 2012 and is still being developed, with new
    releases happening every few months. But what is TypeScript, and what are its
    benefits?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 首次于 2012 年发布，并且仍在开发中，每隔几个月就会发布新版本。但 TypeScript 是什么，它有哪些好处？
- en: TypeScript is often referred to as a superset or extension of JavaScript because
    any feature in JavaScript is available in TypeScript. Unlike JavaScript, TypeScript
    can’t be executed directly in a browser – it must be transpiled into JavaScript
    first.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 通常被称为 JavaScript 的超集或扩展，因为 JavaScript 中的任何功能在 TypeScript 中都是可用的。与
    JavaScript 不同，TypeScript 不能直接在浏览器中执行 - 它必须首先转换为 JavaScript。
- en: Note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'It is worth being aware that a proposal is being considered that *would* allow
    TypeScript to be executed directly in a browser without transpilation. See the
    following link for more information: [https://github.com/tc39/proposal-type-annotations](https://github.com/tc39/proposal-type-annotations).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，有一个提案正在考虑中，该提案将允许 TypeScript 在不进行转换的情况下直接在浏览器中执行。有关更多信息，请参阅以下链接：[https://github.com/tc39/proposal-type-annotations](https://github.com/tc39/proposal-type-annotations)。
- en: TypeScript adds a rich type system to JavaScript. It is generally used with
    frontend frameworks such as Angular, Vue, and React. TypeScript can also be used
    to build a backend with Node.js. This demonstrates how flexible TypeScript’s type
    system is.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 为 JavaScript 添加了一个丰富的类型系统。它通常与 Angular、Vue 和 React 等前端框架一起使用。TypeScript
    还可用于使用 Node.js 构建后端。这展示了 TypeScript 类型系统的灵活性。
- en: When a JavaScript codebase grows, it can become hard to read and maintain. TypeScript’s
    type system solves this problem. TypeScript uses the type system to allow code
    editors to catch type errors as developers write problematic code. Code editors
    also use the type system to provide productivity features such as robust code
    navigation and code refactoring.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当 JavaScript 代码库增长时，它可能变得难以阅读和维护。TypeScript 的类型系统解决了这个问题。TypeScript 使用类型系统允许代码编辑器在开发者编写有问题的代码时捕获类型错误。代码编辑器还使用类型系统提供生产力功能，如强大的代码导航和代码重构。
- en: Next, we will step through an example of how TypeScript catches an error that
    JavaScript can’t.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过一个示例来了解 TypeScript 如何捕获 JavaScript 无法捕获的错误。
- en: Catching type errors early
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提前捕获类型错误
- en: 'The type information helps the TypeScript compiler catch type errors. In code
    editors such as Visual Studio Code, a type error is underlined in red immediately
    after the developer has made a type mistake. Carry out the following steps to
    experience an example of TypeScript catching a type error:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 类型信息帮助 TypeScript 编译器捕获类型错误。在 Visual Studio Code 等代码编辑器中，类型错误在开发者犯下类型错误后立即用红色下划线标出。执行以下步骤以体验
    TypeScript 捕获类型错误的示例：
- en: Open Visual Studio Code in a folder of your choice.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您选择的文件夹中打开 Visual Studio Code。
- en: Create a new file called `calculateTotalPrice.js` by choosing the **New File**
    option in the **EXPLORER** panel.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 **EXPLORER** 面板中选择 **新建文件** 选项创建一个名为 `calculateTotalPrice.js` 的新文件。
- en: '![Figure 2.1 – Creating a new file in Visual Studio Code](img/B19051_02_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 在 Visual Studio Code 中创建新文件](img/B19051_02_01.jpg)'
- en: Figure 2.1 – Creating a new file in Visual Studio Code
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 在 Visual Studio Code 中创建新文件
- en: 'Enter the following code into the file:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码输入到文件中：
- en: '[PRE0]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Remember that the code snippets are available online to copy. The link to the
    previous snippet can be found at [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section1-Understanding-TypeScript/calculateTotalPrice.js](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section1-Understanding-TypeScript/calculateTotalPrice.js).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，代码片段可在网上找到以供复制。上一个代码片段的链接可在 [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section1-Understanding-TypeScript/calculateTotalPrice.js](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section1-Understanding-TypeScript/calculateTotalPrice.js)
    找到。
- en: There is a bug in the code that might be difficult to spot, and the error won’t
    be highlighted by Visual Studio Code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中可能存在一个难以发现的错误，并且 Visual Studio Code 不会突出显示该错误。
- en: Now create a copy of the file but with a `.ts` extension instead of `.js`. A
    file can be copied by right-clicking on the file in the **EXPLORER** panel and
    selecting the **Copy** option. Then right-click the **EXPLORER** panel again and
    select the **Paste** option to create the copied file.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个文件的副本，但使用 `.ts` 扩展名而不是 `.js`。可以通过在 **EXPLORER** 面板中右键单击文件并选择 **复制** 选项来复制文件。然后再次右键单击
    **EXPLORER** 面板并选择 **粘贴** 选项以创建复制的文件。
- en: Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A `.ts` file extension denotes a TypeScript file. This means a TypeScript compiler
    will perform type checking on this file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`.ts` 文件扩展名表示 TypeScript 文件。这意味着 TypeScript 编译器将对这个文件执行类型检查。'
- en: 'In the `calculateTotalPrice.ts` file, remove the `JS` from the end of the function
    name and make the following highlighted updates to the code:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `calculateTotalPrice.ts` 文件中，从函数名称的末尾移除 `JS` 并对代码进行以下突出显示的更新：
- en: '[PRE5]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we have added TypeScript `function` parameters. We will learn about type
    annotations in detail in the next section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了 TypeScript `function` 参数。我们将在下一节中详细介绍类型注解。
- en: 'The key point is that the type error is now highlighted by a red squiggly underline:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点是类型错误现在用红色波浪线突出显示：
- en: '![Figure 2.2 – Highlighted type error](img/B19051_02_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 高亮显示的类型错误](img/B19051_02_02.jpg)'
- en: Figure 2.2 – Highlighted type error
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 高亮显示的类型错误
- en: The bug is that the function references a `price` property in the product object
    that doesn’t exist. The property that should be referenced is `unitPrice`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 错误在于函数引用了产品对象中不存在的`price`属性。应该引用的属性是`unitPrice`。
- en: Catching these problems early in the development process increases the team’s
    throughput and is one less thing for quality assurance to catch. It could be worse
    – the bug could have gotten into the live app and given users a bad experience.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中早期捕捉这些问题可以提高团队的生产率，并且是质量保证需要捕捉的更少的一件事。情况可能会更糟——错误可能会进入实时应用程序，给用户带来不良体验。
- en: Keep these files open in Visual Studio Code because we will run through an example
    of TypeScript improving the developer experience next.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请保持这些文件在Visual Studio Code中打开，因为我们将在下一个示例中运行TypeScript如何提高开发体验的示例。
- en: Improving developer experience and productivity with IntelliSense
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用IntelliSense提高开发体验和生产力
- en: '**IntelliSense** is a feature in code editors that gives useful information
    about elements of code and allows code to be quickly completed. For example, IntelliSense
    can provide the list of properties available in an object.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**IntelliSense**是代码编辑器中的一个功能，它提供了关于代码元素的有用信息，并允许快速完成代码。例如，IntelliSense可以提供对象中可用的属性列表。'
- en: 'Carry out the following steps to experience how TypeScript works better with
    IntelliSense than JavaScript and how this positively impacts productivity. As
    part of this exercise, we will fix the price bug from the previous section:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以体验TypeScript与IntelliSense相比JavaScript如何工作得更好，以及这对生产力的积极影响。作为这项练习的一部分，我们将修复上一节中的价格错误：
- en: 'Open `calculateTotalPrice.js` and on line 2, where `product.price` is referenced,
    remove `price`. Then, with the cursor after the dot (`.`), click *Ctrl* + spacebar.
    This opens Visual Studio Code’s IntelliSense:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`calculateTotalPrice.js`文件，在第2行，即`product.price`被引用的地方，移除`price`。然后，将光标放在点(`.`)之后，点击*Ctrl*
    + 空格键。这会打开Visual Studio Code的IntelliSense：
- en: '![Figure 2.3 – IntelliSense in a JavaScript file](img/B19051_02_03.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – JavaScript文件中的IntelliSense](img/B19051_02_03.jpg)'
- en: Figure 2.3 – IntelliSense in a JavaScript file
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – JavaScript文件中的IntelliSense
- en: Visual Studio Code can only guess the potential property name, so it lists variable
    names and function names it has seen in the file. Unfortunately, IntelliSense
    doesn’t help in this case because the correct property name, `unitPrice`, is not
    listed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code只能猜测潜在的属性名称，因此它列出了它在文件中看到的变量名称和函数名称。不幸的是，在这种情况下，IntelliSense无法提供帮助，因为正确的属性名称`unitPrice`并未列出。
- en: 'Now open `calculateTotalPrice.ts`, remove `price` from `product.price`, and
    press *Ctrl* + spacebar to open IntelliSense again:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`calculateTotalPrice.ts`文件，从`product.price`中移除`price`，然后按*Ctrl* + 空格键再次打开IntelliSense：
- en: '![Figure 2.4 – IntelliSense in a TypeScript file](img/B19051_02_04.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – TypeScript文件中的IntelliSense](img/B19051_02_04.jpg)'
- en: Figure 2.4 – IntelliSense in a TypeScript file
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – TypeScript文件中的IntelliSense
- en: This time, Visual Studio Code lists the correct properties.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，Visual Studio Code列出了正确的属性。
- en: Select **unitPrice** from IntelliSense to resolve the type error.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从IntelliSense中选择**unitPrice**以解决类型错误。
- en: IntelliSense is just one tool that TypeScript provides. It can also provide
    robust refactoring features, such as renaming React components, and helps with
    accurate code navigation, such as going to a function definition.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliSense只是TypeScript提供的一个工具。它还可以提供强大的重构功能，例如重命名React组件，并帮助进行准确的代码导航，例如跳转到函数定义。
- en: 'To recap what we learned in this section:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾我们在本节中学到的内容：
- en: TypeScript’s type-checking feature helps catch problems earlier in the development
    process
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript的类型检查功能有助于在开发过程中早期捕捉问题
- en: TypeScript enables code editors to offer productivity features such as IntelliSense
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript使代码编辑器能够提供诸如IntelliSense之类的生产力功能
- en: These advantages provide significant benefits when working in larger codebases
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些优势在处理大型代码库时提供了显著的好处
- en: Next, we will learn about the type system in JavaScript. This will further underline
    the need for TypeScript in a large codebase.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习JavaScript中的类型系统。这将进一步强调在大型代码库中使用TypeScript的必要性。
- en: Understanding JavaScript types
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解JavaScript类型
- en: 'Before understanding the type system in TypeScript, let’s briefly explore the
    type system in JavaScript. To do this, open the CodeSandbox at [https://codesandbox.io/](https://codesandbox.io/)
    and carry out the following steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解TypeScript中的类型系统之前，让我们简要地探索JavaScript中的类型系统。为此，打开CodeSandbox，访问[https://codesandbox.io/](https://codesandbox.io/)，并按照以下步骤操作：
- en: Create a new plain JavaScript project by choosing the **Vanilla** option.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**Vanilla**选项创建一个新的纯JavaScript项目。
- en: 'Open `index.js`, remove its content, and replace it with the following code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`index.js`，删除其内容，并用以下代码替换：
- en: '[PRE14]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code assigns three variables to various values. The code also outputs the
    variable values to the console, along with their JavaScript type.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将三个变量赋值为不同的值。代码还将变量值及其JavaScript类型输出到控制台。
- en: 'Here’s the console output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是控制台输出：
- en: '![Figure 2.5 – Some JavaScript types](img/B19051_02_05.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 一些JavaScript类型](img/B19051_02_05.jpg)'
- en: Figure 2.5 – Some JavaScript types
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 一些JavaScript类型
- en: It isn’t surprising that `firstName` is a string and `score` is a number. However,
    it is a little surprising that `date` is an object rather than something more
    specific such as a date.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`firstName`是字符串，`score`是数字，这并不奇怪。然而，`date`是一个对象而不是更具体的日期类型，这有点令人惊讶。'
- en: 'Let’s add another couple of lines of code after the existing code:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在现有代码之后添加几行代码：
- en: '[PRE20]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Again, the console output is a little surprising:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，控制台输出有点令人惊讶：
- en: '![Figure 2.6 – Variable changing type](img/B19051_02_06.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 变量类型变化](img/B19051_02_06.jpg)'
- en: Figure 2.6 – Variable changing type
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 变量类型变化
- en: The `score` variable has changed from a `number` type to a `string` type! This
    is because JavaScript is loosely typed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`score`变量已从`number`类型更改为`string`类型！这是因为JavaScript是松散类型的。'
- en: A key point is that JavaScript only has a minimal set of types, such as `string`,
    `number`, and `boolean`. It is worth noting that all of the JavaScript types are
    available in TypeScript because Typescript is a superset of Javascript.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键点是JavaScript只有一组最小的类型，如`string`、`number`和`boolean`。值得注意的是，所有的JavaScript类型都在TypeScript中可用，因为TypeScript是JavaScript的超集。
- en: Also, JavaScript allows a variable to change its type – meaning that the JavaScript
    engine won’t throw an error if a variable is changed to a completely different
    type. This loose typing makes it impossible for code editors to catch type errors.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JavaScript允许变量改变其类型——这意味着如果变量被更改为完全不同的类型，JavaScript引擎不会抛出错误。这种松散的类型使得代码编辑器无法捕获类型错误。
- en: Note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on JavaScript types, see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JavaScript类型的更多信息，请参阅[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures)。
- en: Now that we understand the limitations of the type system in JavaScript, we
    will learn about TypeScript’s type system, starting with basic types.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了JavaScript类型系统的局限性，我们将学习TypeScript的类型系统，从基本类型开始。
- en: Using basic TypeScript types
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基本TypeScript类型
- en: In this section, we’ll start by understanding how TypeScript types can be declared
    and how they are inferred from assigned values. We will then learn the basic types
    commonly used in TypeScript that aren’t available in JavaScript and understand
    helpful use cases.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先了解TypeScript类型如何声明以及它们如何从赋值中推断出来。然后我们将学习TypeScript中常用的基本类型，这些类型在JavaScript中不可用，并了解它们的有用用例。
- en: Using type annotations
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类型注解
- en: TypeScript type annotations enable variables to be declared with specific types.
    These allow the TypeScript compiler to check that the code adheres to these types.
    In short, type annotations allow TypeScript to catch bugs where our code uses
    the wrong type much earlier than we would if we were writing our code in JavaScript.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript类型注解允许变量以特定类型声明。这允许TypeScript编译器检查代码是否遵循这些类型。简而言之，类型注解允许TypeScript在代码使用错误类型的情况下比在JavaScript中更早地捕获错误。
- en: 'Open the TypeScript Playground at [https://www.typescriptlang.org/play](https://www.typescriptlang.org/play)
    and carry out the following steps to explore type annotations:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 打开TypeScript Playground，访问[https://www.typescriptlang.org/play](https://www.typescriptlang.org/play)，并按照以下步骤进行操作以探索类型注解：
- en: 'Remove any existing code in the left-hand pane and enter the following variable
    declaration:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除左侧面板中的任何现有代码，并输入以下变量声明：
- en: '[PRE22]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The type annotation comes after the variable declaration. It starts with a colon
    followed by the type we want to assign to the variable. In this case, `unitPrice`
    is going to be a `number` type. Remember that `number` is a type in JavaScript,
    which means that it is available for us to use in TypeScript too.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 类型注解位于变量声明之后。它以冒号开头，后跟我们要分配给变量的类型。在这种情况下，`unitPrice`将被指定为`number`类型。请记住，`number`是JavaScript中的一个类型，这意味着它也适用于TypeScript。
- en: 'The transpiled JavaScript appears on the right-hand side as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 转译后的JavaScript如下所示：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: However, notice that the type annotation has disappeared. This is because type
    annotations don’t exist in JavaScript.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意类型注解已经消失。这是因为JavaScript中没有类型注解。
- en: Note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may also see `"use strict";` at the top of the transpiled JavaScript. This
    means that the JavaScript will be executed in JavaScript strict mode, which will
    pick up more coding mistakes. For more information on JavaScript strict mode,
    see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可能在转译后的JavaScript顶部看到`"use strict";`。这意味着JavaScript将在JavaScript严格模式下执行，这将捕获更多的编码错误。有关JavaScript严格模式的更多信息，请参阅[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)。
- en: 'Add a second line to the program:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序中添加第二行：
- en: '[PRE24]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Notice that a red line appears under `unitPrice` on this line. If you hover
    over the underlined `unitPrice`, a type error is described:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这一行下方的`unitPrice`处出现了一条红色横线。如果您将鼠标悬停在下划线的`unitPrice`上，会描述一个类型错误：
- en: '![Figure 2.7 – A type error being caught](img/B19051_02_07.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 捕获到的类型错误](img/B19051_02_07.jpg)'
- en: Figure 2.7 – A type error being caught
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 捕获到的类型错误
- en: 'You can also add type annotations to function parameters and a function’s return
    value using the same syntax as annotating a variable. As an example, enter the
    following function in the TypeScript Playground:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以使用与变量注解相同的语法为函数参数和函数的返回值添加类型注解。例如，在TypeScript Playground中输入以下函数：
- en: '[PRE25]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We’ve declared the `unitPrice`, `quantity`, and `discount` parameters, all with
    a `number` type. The return type annotation comes after the function’s parentheses,
    which is also a `number` type in the preceding example.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经声明了`unitPrice`、`quantity`和`discount`参数，它们都是`number`类型。函数的返回类型注解位于函数括号之后，在先前的例子中这也是一个`number`类型。
- en: Note
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We have used both `const` and `let` to declare variables in different examples.
    `let` allows the variable to change the value after the declaration, whereas `const`
    variables can’t change. In the preceding function, `priceWithoutDiscount` and
    `discountAmount` never change the value after the initial assignment, so we have
    used `const`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在多个例子中使用了`const`和`let`来声明变量。`let`允许变量在声明后更改值，而`const`变量则不能更改。在先前的函数中，`priceWithoutDiscount`和`discountAmount`在初始赋值后永远不会更改值，所以我们使用了`const`。
- en: 'Add another line of code to call `getTotal` with an incorrect type for `quantity`.
    Assign the result of the call to `getTotal` to a variable with an incorrect type:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中添加另一行以调用`getTotal`函数，并使用错误的`quantity`类型。将`getTotal`函数的调用结果赋值给一个具有错误类型的变量：
- en: '[PRE34]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Both errors are immediately detected and highlighted:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 两个错误都会立即被检测并突出显示：
- en: '![Figure 2.8 – Both type errors being caught](img/B19051_02_08.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – 捕获到的两个类型错误](img/B19051_02_08.jpg)'
- en: Figure 2.8 – Both type errors being caught
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 捕获到的两个类型错误
- en: This strong type checking is something that we don’t get in JavaScript, and
    it is very useful in large codebases because it helps us immediately detect type
    errors.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这种强类型检查是我们从JavaScript中得不到的，它在大型代码库中非常有用，因为它可以帮助我们立即检测类型错误。
- en: Next, we will learn how TypeScript doesn’t always need type annotations in order
    to type-check code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习TypeScript在类型检查代码时不总是需要类型注解。
- en: Using type inference
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类型推断
- en: Type annotations are really valuable, but they require additional code to be
    written. This extra code takes time to write. Luckily, TypeScript’s powerful **type
    inference** system means type annotations don’t need to be specified all the time.
    TypeScript infers the type of a variable when it is assigned a value from that
    value.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 类型注解非常有价值，但它们需要编写额外的代码。这些额外的代码需要花费时间来编写。幸运的是，TypeScript强大的**类型推断**系统意味着类型注解并不总是需要指定。当变量被赋予一个值时，TypeScript会推断该变量的类型。
- en: 'Explore type inference by carrying out the following steps in the TypeScript
    Playground:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript Playground中执行以下步骤以探索类型推断：
- en: 'First, remove any previous code and then add the following line:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，删除任何之前的代码，然后添加以下行：
- en: '[PRE35]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Hover over the `flag` variable. A tooltip will appear showing the type that
    `flag` has been inferred to:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 悬停在`flag`变量上。会出现一个工具提示，显示`flag`被推断出的类型：
- en: '![Figure 2.9 – Hovering over a variable reveals its type](img/B19051_02_09.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – 悬停在变量上显示其类型](img/B19051_02_09.jpg)'
- en: Figure 2.9 – Hovering over a variable reveals its type
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – 悬停在变量上显示其类型
- en: 'Add another line beneath this to incorrectly set `flag` to an invalid value:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此行下方添加另一行，错误地将`flag`设置为无效值：
- en: '[PRE36]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: A type error is immediately caught, just like when we used a type annotation
    to assign a type to a variable.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 类型错误会立即被捕获，就像我们使用类型注解为变量分配类型时一样。
- en: Type inference is an excellent feature of TypeScript and prevents code bloat
    that lots of type annotations would bring. Therefore, it is common practice to
    use type inference and only revert to using type annotations where inference isn’t
    possible.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断是TypeScript的一个优秀特性，它可以防止大量类型注解带来的代码膨胀。因此，使用类型推断并仅在推断不可行时回退到使用类型注解是一种常见的做法。
- en: Next, we will look at the `Date` type in TypeScript.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看TypeScript中的`Date`类型。
- en: Using the Date type
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Date类型
- en: We are already aware that a `Date` type doesn’t exist in JavaScript, but luckily,
    a `Date` type does exist in TypeScript. The TypeScript `Date` type is a representation
    of the JavaScript `Date` object.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道JavaScript中不存在`Date`类型，但幸运的是，TypeScript中存在`Date`类型。TypeScript的`Date`类型是对JavaScript
    `Date`对象的表示。
- en: Note
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'See the following link for more information on the JavaScript `Date` object:
    [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有关JavaScript `Date`对象的更多信息，请参阅以下链接：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date)。
- en: 'To explore the TypeScript `Date` type, carry out the following steps in the
    TypeScript Playground:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索TypeScript的`Date`类型，请在TypeScript Playground中执行以下步骤：
- en: 'First, remove any previous code and then add the following lines:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，删除任何之前的代码，然后添加以下行：
- en: '[PRE37]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: A `today` variable is declared that is assigned a `Date` type and set to today’s
    date.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 声明了一个名为`today`的变量，它被分配了`Date`类型并设置为今天的日期。
- en: 'Refactor these two lines into the following single line that uses type inference
    rather than a type annotation:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这两行重构为以下使用类型推断而不是类型注解的单行：
- en: '[PRE39]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Check that `today` has been assigned the `Date` type by hovering over it and
    checking the tooltip:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`today`是否已被分配为`Date`类型，通过悬停在它上面并检查工具提示来完成：
- en: '![Figure 2.10 – Confirmation that today has inferred the Date type](img/B19051_02_10.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10 – 确认today已推断出Date类型](img/B19051_02_10.jpg)'
- en: Figure 2.10 – Confirmation that today has inferred the Date type
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – 确认today已推断出Date类型
- en: 'Now, check IntelliSense is working by adding `today.` on a new line:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过在新的行上添加`today.`来检查IntelliSense是否正常工作：
- en: '![Figure 2.11 – IntelliSense working nicely on a date](img/B19051_02_11.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11 – IntelliSense在日期上工作得很好](img/B19051_02_11.jpg)'
- en: Figure 2.11 – IntelliSense working nicely on a date
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – IntelliSense在日期上工作得很好
- en: 'Remove this line and add a slightly different line of code:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除此行并添加一条略微不同的代码行：
- en: '[PRE40]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'An `addMonths` function doesn’t exist in the `Date` object, so a type error
    is raised:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date`对象中不存在`addMonths`函数，因此会引发类型错误：'
- en: '![Figure 2.12 – Type error caught on a date](img/B19051_02_12.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图2.12 – 在日期上捕获到的类型错误](img/B19051_02_12.jpg)'
- en: Figure 2.12 – Type error caught on a date
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 – 在日期上捕获到的类型错误
- en: In summary, the `Date` type has all the features we expect – inference, IntelliSense,
    and type checking – which are really useful when working with dates.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`Date`类型具有我们期望的所有功能——推断、IntelliSense和类型检查——这对于处理日期来说非常有用。
- en: Next, we will learn about an escape hatch in TypeScript’s type system.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将了解TypeScript类型系统中的一个逃生口。
- en: Using the any type
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用any类型
- en: 'What if we declare a variable with no type annotation and no value? What will
    TypeScript infer as the type? Let’s find out by entering the following code in
    the TypeScript Playground:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们声明一个没有类型注解和值的变量，TypeScript会推断出什么类型？让我们通过在TypeScript Playground中输入以下代码来找出答案：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, hover the mouse over `flag`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将鼠标悬停在`flag`上：
- en: '![Figure 2.13 – Variable given the any type](img/B19051_02_13.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图2.13 – 被赋予any类型的变量](img/B19051_02_13.jpg)'
- en: Figure 2.13 – Variable given the any type
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 – 被赋予any类型的变量
- en: So, TypeScript gives a variable with no type annotation and no immediately assigned
    value the `any` type. It is a way of opting out of performing type checking on
    a particular variable and is commonly used for dynamic content or values from
    third-party libraries. However, TypeScript’s increasingly powerful type system
    means that we need to use `any` less often these days.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，TypeScript给没有类型注解且没有立即赋值的变量赋予`any`类型。这是一种选择不执行特定变量的类型检查的方法，通常用于动态内容或第三方库中的值。然而，TypeScript日益强大的类型系统意味着我们今天需要更少地使用`any`。
- en: 'Instead, there is a better alternative: the `unknown` type.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，有一个更好的选择：`unknown`类型。
- en: Using the unknown type
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`unknown`类型
- en: '`unknown` is a type we can use when we are unsure of the type but want to interact
    with it in a strongly-typed manner. Carry out the following steps to explore how
    this is a better alternative to the `any` type:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不确定类型但想以强类型方式与之交互时，我们可以使用`unknown`类型。执行以下步骤以探索这如何是`any`类型的更好替代方案：
- en: 'In the TypeScript Playground, remove any previous code, and enter the following:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在TypeScript Playground中，删除任何之前的代码，并输入以下内容：
- en: '[PRE42]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The code fetches a Star Wars character from a web API. No type errors are raised,
    so the code appears okay.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从网络API中获取一个《星球大战》角色。没有抛出类型错误，所以代码看起来是正常的。
- en: 'Now click on the **Run** option to execute the code:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击**运行**选项来执行代码：
- en: '![Figure 2.14 – firstName property has an undefined value](img/B19051_02_14.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图2.14 – firstName属性具有未定义的值](img/B19051_02_14.jpg)'
- en: Figure 2.14 – firstName property has an undefined value
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 – firstName属性具有未定义的值
- en: The `firstName` property doesn’t appear to be in the fetched data because it
    is `undefined` when it is output to the console.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`firstName`属性似乎不在获取的数据中，因为它在输出到控制台时是`undefined`。'
- en: Why wasn’t a type error raised on line 4 where `firstName` was referenced? Well,
    `data` is of the type `any`, which means no type checking will occur on it. You
    can hover over `data` to confirm that it has been given the `any` type.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在引用`firstName`的第四行没有抛出类型错误？嗯，`data`的类型是`any`，这意味着不会对其执行类型检查。你可以悬停在`data`上以确认它已被赋予`any`类型。
- en: 'Give `data` the `unknown` type annotation:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给`data`添加`unknown`类型注解：
- en: '[PRE47]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'A type error is now raised where `firstName` is referenced:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`firstName`处引用时，现在会抛出一个类型错误：
- en: '![Figure 2.15 – Type error on unknown data parameter](img/B19051_02_15.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图2.15 – 在未知数据参数上发生类型错误](img/B19051_02_15.jpg)'
- en: Figure 2.15 – Type error on unknown data parameter
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15 – 在未知数据参数上发生类型错误
- en: The `unknown` type is the opposite of the `any` type, as it contains nothing
    within its type. A type that doesn’t contain anything may seem useless. However,
    a variable’s type can be widened if cheks are made to allow TypeScript to widen
    it.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`unknown`类型是`any`类型的对立面，因为它在其类型中不包含任何内容。一个不包含任何内容的类型可能看起来没有用。然而，如果进行了检查以允许TypeScript扩展它，变量的类型可以被扩展。'
- en: 'Before we give TypeScript information to widen `data`, change the property
    referenced within it from `firstName` to `name`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们给TypeScript提供信息以扩展`data`之前，将其引用的属性从`firstName`更改为`name`：
- en: '[PRE52]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`name` is a valid property, but a type error is still occurring. This is because
    `data` is still `unknown`.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`是一个有效的属性，但仍然发生类型错误。这是因为`data`仍然是`unknown`。'
- en: 'Now make the highlighted changes to the code to widen the `data` type:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将代码中的高亮部分更改以扩展`data`类型：
- en: '[PRE57]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The code snippet can be copied from [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section2-Basic-types/Using-the-unknown-type/code.ts](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section2-Basic-types/Using-the-unknown-type/code.ts).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从[https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section2-Basic-types/Using-the-unknown-type/code.ts](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section2-Basic-types/Using-the-unknown-type/code.ts)复制代码片段。
- en: The `if` statement uses a function called `isCharacter` to verify that a `name`
    property is contained within the object. The result of this call is `true` in
    this example, so the logic will flow into the `if` branch.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句使用一个名为`isCharacter`的函数来验证对象中是否包含`name`属性。在这个例子中，这个调用的结果是`true`，所以逻辑将流入`if`分支。'
- en: 'Notice the return type of `isCharacter`, which is:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`isCharacter`的返回类型，它是：
- en: '[PRE69]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This is a `character` to `{ name: string }` if the function returns `true`.
    The type predicate is `true` in this example, so `character` is widened to an
    object with a `name` string property.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '如果函数返回`true`，则这是一个`character`到`{ name: string }`的类型。在这个例子中，类型谓词是`true`，所以`character`被扩展为一个具有`name`字符串属性的对象。'
- en: 'Hover over the `data` variable on each line where it is referenced. `data`
    starts off with the `unknown` type where it is assigned with a type annotation.
    Then, it is widened to `{name: string}` inside the `if` branch:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在引用`data`变量的每一行上悬停。`data`最初具有`unknown`类型，其中它被赋予了一个类型注解。然后，在`if`分支内部，它被扩展到`{name:
    string}`：'
- en: '![Figure 2.16 – Widened type given to data](img/B19051_02_16.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.16 – 分配给数据的扩展类型](img/B19051_02_16.jpg)'
- en: Figure 2.16 – Widened type given to data
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 – 分配给数据的扩展类型
- en: Notice that the type error has also disappeared. Nice!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到类型错误也已经消失了。太好了！
- en: Next, run the code. You will see `Luke Skywalker` output to the console.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行代码。你将在控制台看到`Luke Skywalker`输出。
- en: In summary, the `unknown` type is an excellent choice for data whose type you
    are unsure about. However, you can’t interact with `unknown` variables – the variable
    must be widened to a different type before any interaction.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`unknown`类型是对于不确定数据类型的优秀选择。然而，你不能与`unknown`变量交互——变量必须在任何交互之前被扩展到其他类型。
- en: Next, we will learn about a type used for a function not returning a value.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习一个用于函数不返回值的类型。
- en: Using the void type
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 void 类型
- en: The `void` type is used to represent a function’s return type where the function
    doesn’t return a value.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`void`类型用于表示函数的返回类型，在这种情况下，函数不返回任何值。'
- en: 'As an example, enter the following function in the TypeScript Playground:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 TypeScript Playground 中输入以下函数：
- en: '[PRE70]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Hovering over the function name confirms that the function return type is given
    a `void` type.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 悬停在函数名上可以确认函数的返回类型被赋予了一个`void`类型。
- en: '![Figure 2.17 – Return type confirmed as void](img/B19051_02_17.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.17 – 返回类型已确认为准 void](img/B19051_02_17.jpg)'
- en: Figure 2.17 – Return type confirmed as void
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17 – 返回类型已确认为准 void
- en: 'You may think that you could use `undefined` as the return type for the preceding
    example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为你可以使用`undefined`作为前面示例的返回类型：
- en: '[PRE71]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: However, this raises a type error because a return type of `undefined` means
    that the function is expected to return a value (of type `undefined`). The example
    function doesn’t return any value, so the return type is `void`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这引发了一个类型错误，因为`undefined`类型的返回类型意味着函数预期会返回一个值（类型为`undefined`）。示例函数没有返回任何值，所以返回类型是`void`。
- en: In summary, `void` is a special type for a function’s return type where the
    function doesn’t have a return statement.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`void`是一个特殊类型，用于函数的返回类型，在这种情况下，函数没有返回语句。
- en: Next, we will learn about the `never` type.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习`never`类型。
- en: Using the never type
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 never 类型
- en: 'The `never` type represents something that will never occur and is typically
    used to specify unreachable code areas. Let’s explore an example in the TypeScript
    Playground:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`never`类型表示永远不会发生的事情，通常用于指定不可达的代码区域。让我们在 TypeScript Playground 中探索一个例子：'
- en: 'Remove any existing code and enter the following code:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除任何现有代码并输入以下代码：
- en: '[PRE72]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The function invokes an infinite loop, meaning the function is never exited.
    So, we have given the function a return type annotation of `never` because we
    don’t expect the function to be exited. This is different from `void` because
    `void` means it *will* exit, but with no value.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用了一个无限循环，这意味着函数永远不会退出。因此，我们给函数赋予了一个`never`类型的返回类型注解，因为我们不期望函数会退出。这与`void`不同，因为`void`意味着它*将会*退出，但没有返回值。
- en: Note
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'We used a JavaScript template literal to construct the string to output to
    the console in the preceding example. Template literals are enclosed by backticks
    (`` ` ` ``) and can include a JavaScript expression in curly braces prefixed with
    a dollar sign (`${expression}`). Template literals are great when we need to merge
    static text with variables. See this link for more information on template literals:
    [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals).'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用 JavaScript 模板字符串来构建输出到控制台的字符串。模板字符串由反引号（`` ` ` ``）包围，并可以包含以美元符号（`$${expression}`）为前缀的花括号中的
    JavaScript 表达式。当需要将静态文本与变量合并时，模板字符串非常出色。有关模板字符串的更多信息，请参阅此链接：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)。
- en: 'Change the `foreverTask` function to break out of the loop:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`foreverTask`函数更改为跳出循环：
- en: '[PRE77]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'TypeScript quite rightly complains:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 正确地抱怨：
- en: '![Figure 2.18 – Type error on the never return type](img/B19051_02_18.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.18 – never 返回类型上的类型错误](img/B19051_02_18.jpg)'
- en: Figure 2.18 – Type error on the never return type
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18 – never 返回类型上的类型错误
- en: 'Remove the `break` statement and remove the `never` return type annotation:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `break` 语句并删除 `never` 返回类型注解：
- en: '[PRE83]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Hover over the `foreverTask` function name with your mouse. We can see that
    TypeScript has inferred the return type as `void`:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在 `foreverTask` 函数名称上。我们可以看到 TypeScript 推断的返回类型为 `void`：
- en: '![Figure 2.19 – Return type inferred as void](img/B19051_02_19.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.19 – 返回类型推断为 void](img/B19051_02_19.jpg)'
- en: Figure 2.19 – Return type inferred as void
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.19 – 返回类型推断为 void
- en: So, TypeScript is unable to infer the `never` type in this case. Instead, it
    infers the return type as `void`, which means the function will exit with no value,
    which isn’t the case in this example. This is a reminder to always check the inferred
    type and resort to using a type annotation where appropriate.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，TypeScript 在这种情况下无法推断出 `never` 类型。相反，它推断出返回类型为 `void`，这意味着函数将不带任何值退出，但这在本例中并不适用。这是一个提醒，始终要检查推断的类型，并在适当的地方使用类型注解。
- en: In summary, the `never` type is used in places where code never reaches.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`never` 类型用于代码永远不会到达的地方。
- en: Next up, let’s cover arrays.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来介绍数组。
- en: Using arrays
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数组
- en: Arrays are structures that TypeScript inherits from JavaScript. We add type
    annotations to arrays as usual, but with square brackets `[]` at the end to denote
    that this is an array type.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是 TypeScript 从 JavaScript 继承的结构。我们像往常一样向数组添加类型注解，但在末尾使用方括号 `[]` 来表示这是一个数组类型。
- en: 'Let’s explore an example in the TypeScript Playground:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 TypeScript Playground 中探索一个示例：
- en: 'Remove any existing code, and enter the following:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除任何现有代码，并输入以下内容：
- en: '[PRE88]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Alternatively, the `Array` generic type syntax can be used:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用 `Array` 泛型类型语法：
- en: '[PRE89]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We will learn about generics in TypeScript in [*Chapter 11*](B19051_11.xhtml#_idTextAnchor273),
    *Reusable Components*.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第 11 章*](B19051_11.xhtml#_idTextAnchor273) *可重用组件* 中学习 TypeScript 中的泛型。
- en: 'Add `1` to the array by using the array’s `push` function:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用数组的 `push` 函数向数组中添加 `1`：
- en: '[PRE90]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now add a string to the array:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在向数组中添加一个字符串：
- en: '[PRE91]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'A type error is raised as we would expect:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预期的那样，会抛出一个类型错误：
- en: '![Figure 2.20 – Type error when adding a string type to a number array](img/B19051_02_20.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.20 – 向数字数组添加字符串类型时的类型错误](img/B19051_02_20.jpg)'
- en: Figure 2.20 – Type error when adding a string type to a number array
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.20 – 向数字数组添加字符串类型时的类型错误
- en: 'Now replace all the code with the following:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将所有代码替换为以下内容：
- en: '[PRE92]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Hover over `numbers` to verify that TypeScript has inferred its type to be `number[]`.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在 `numbers` 上以验证 TypeScript 已经推断出它的类型为 `number[]`。
- en: '![Figure 2.21 – Array type inference](img/B19051_02_21.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.21 – 数组类型推断](img/B19051_02_21.jpg)'
- en: Figure 2.21 – Array type inference
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.21 – 数组类型推断
- en: Excellent – we can see that TypeScript’s type inference works with arrays!
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 极好 – 我们可以看到 TypeScript 的类型推断在数组上是如何工作的！
- en: Arrays are one of the most common types used to structure data. In the preceding
    examples, we’ve only used an array with elements having a `number` type, but any
    type can be used for elements, including objects, which have their own properties.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是用于结构化数据最常用的类型之一。在前面的示例中，我们只使用了一个具有 `number` 类型元素的数组，但可以使用任何类型作为元素，包括具有自己属性的对象。
- en: 'Here’s a recap of all the basic types we have learned in this section:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了所有基本类型：
- en: TypeScript adds many useful types to JavaScripts types, such as `Date`, and
    is capable of representing arrays.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 向 JavaScript 类型添加了许多有用的类型，例如 `Date`，并且能够表示数组。
- en: TypeScript can infer a variable’s type from its assigned value. A type annotation
    can be used where type inference doesn’t give the desired type.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 可以从其分配的值推断出变量的类型。当类型推断无法给出所需类型时，可以使用类型注解。
- en: No type checking occurs on variables with the `any` type, so this type should
    be avoided.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有类型 `any` 的变量不会进行类型检查，因此应避免使用此类型。
- en: The `unknown` type is a strongly-typed alternative to `any`, but `unknown` variables
    must be widened to be interacted with.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unknown` 类型是 `any` 的强类型替代品，但 `unknown` 变量必须进行类型提升才能进行交互。'
- en: '`void` is a return type for a function that doesn’t return a value.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void` 是一个不返回值的函数的返回类型。'
- en: The `never` type can be used to mark unreachable areas of code.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`never` 类型可以用来标记代码中无法到达的区域。'
- en: Array types can be defined using square brackets after the array item type.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在数组项目类型之后使用方括号来定义数组类型。
- en: In the next section, we will learn how to create our own types.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何创建自己的类型。
- en: Creating TypeScript types
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 TypeScript 类型
- en: The last section showed that TypeScript has a great set of standard types. In
    this section, we will learn how to create our own types. We will start by learning
    three different methods for creating object types. We will then learn about strongly-typing
    JavaScript classes. Lastly, we will learn two different methods for creating types
    for variables that hold a range of values.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节展示了 TypeScript 拥有一套非常出色的标准类型。在本节中，我们将学习如何创建我们自己的类型。我们将从学习创建对象类型的三个不同方法开始。然后，我们将学习关于强类型
    JavaScript 类的内容。最后，我们将学习两种创建用于存储一系列值变量的类型的方法。
- en: Using object types
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用对象类型
- en: 'Objects are very common in JavaScript programs, so learning how to represent
    them in TypeScript is really important. In fact, we have already used an object
    type earlier in this chapter for the `product` parameter in the `calculateTotalPrice`
    function. Here is a reminder of the `product` parameter’s type annotation:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 对象在 JavaScript 程序中非常常见，因此学习如何在 TypeScript 中表示它们非常重要。实际上，我们已经在本章前面使用对象类型为`calculateTotalPrice`函数中的`product`参数创建了一个对象类型。以下是`product`参数类型注解的提醒：
- en: '[PRE93]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: An object type in TypeScript is represented a bit like a JavaScript object literal.
    However, instead of property values, property types are specified instead. Properties
    in the object definitions can be separated by semicolons or commas, but using
    a semicolon is common practice.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 中的对象类型表示得有点像 JavaScript 对象字面量。然而，与属性值不同，属性类型被指定。对象定义中的属性可以用分号或逗号分隔，但使用分号是常见做法。
- en: 'Clear any existing code in the TypeScript Playground and follow this example
    to explore object types:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 清除 TypeScript Playground 中的任何现有代码，并按照以下示例来探索对象类型：
- en: 'Enter the following variable assignment to an object:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下变量赋值给一个对象：
- en: '[PRE94]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'If you hover over the `table` variable, you’ll see it is inferred to be the
    following type:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将鼠标悬停在`table`变量上，你会看到它被推断为以下类型：
- en: '[PRE95]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: So, type inference works nicely for objects.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，类型推断在对象中工作得很好。
- en: 'Now, on the next line, try to set a `discount` property to `10`:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在下一行，尝试将`discount`属性设置为`10`：
- en: '[PRE96]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: A `discount` property doesn’t exist in the type, though – only the `name` and
    `unitPrice` properties exist. So, a type error occurs.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管类型中不存在`discount`属性，但只有`name`和`unitPrice`属性存在。因此，发生类型错误。
- en: 'Let’s say we want to represent a `product` object containing the `name` and
    `unitPrice` properties, but we want `unitPrice` to be optional. Remove the existing
    code and replace it with the following:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们想要表示一个包含`name`和`unitPrice`属性的`product`对象，但希望`unitPrice`是可选的。删除现有代码，并用以下代码替换：
- en: '[PRE97]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This raises a type error because `unitPrice` is a required property in the
    type annotation. We can use a `?` symbol as follows to make this optional rather
    than required:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这会引发类型错误，因为`unitPrice`在类型注解中是一个必需的属性。我们可以使用以下`?`符号来使其可选而不是必需：
- en: '[PRE100]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The type error disappears.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 类型错误消失了。
- en: Note
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `?` symbol can be used in functions for optional parameters. For example,
    `myFunction(requiredParam: string,` `optionalParam``: string)`.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '在函数中可以使用`?`符号表示可选参数。例如，`myFunction(requiredParam: string, optionalParam: string)`。'
- en: Now, let’s learn a way to streamline object type definitions.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习一种简化对象类型定义的方法。
- en: Creating type aliases
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建类型别名
- en: 'The type annotation we used in the last example was quite lengthy and would
    be longer for more complex object structures. Also, having to write the same object
    structure to assign to different variables is a little frustrating:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个示例中使用的类型注解相当长，对于更复杂的对象结构会更长。此外，必须为不同的变量写入相同的对象结构会有些令人沮丧：
- en: '[PRE103]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '**Type aliases** solve these problems. As the name suggests, a type alias refers
    to another type, and the syntax is as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型别名**解决了这些问题。正如其名所示，类型别名指的是另一个类型，其语法如下：'
- en: '[PRE104]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Open the TypeScript Playground and follow along to explore type aliases:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 TypeScript Playground 并跟随示例来探索类型别名：
- en: 'Start by creating a type alias for the product object structure we used in
    the last example:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为我们在上一个示例中使用的商品对象结构创建一个类型别名：
- en: '[PRE105]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Now assign two variables to this `Product` type:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将两个变量分配给这个`Product`类型：
- en: '[PRE106]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: That’s much cleaner!
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就干净多了！
- en: 'A type alias can extend another object using the `&` symbol. Create a second
    type for a discounted product by adding the following type alias:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型别名可以使用`&`符号扩展另一个对象。通过添加以下类型别名创建一个折扣产品的第二个类型：
- en: '[PRE108]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '`DiscountedProduct` represents an object containing `name`, `unitPrice` (optional),
    and `discount` properties.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`DiscountedProduct`表示一个包含`name`、`unitPrice`（可选）和`discount`属性的对象。'
- en: Note
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A type that extends another using the `&` symbol is referred to as an **intersection
    type**.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`&`符号扩展另一个类型的类型被称为**交集类型**。
- en: 'Add the following variable with the `DiscountedProduct` type as follows:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式添加以下变量，使用`DiscountedProduct`类型：
- en: '[PRE109]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'A type alias can also be used to represent a function. Add the following type
    alias to represent a function:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型别名也可以用来表示函数。添加以下类型别名来表示一个函数：
- en: '[PRE114]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The preceding type represents a function containing a `number` parameter and
    doesn’t return anything.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类型表示一个包含`number`参数的函数，并且不返回任何内容。
- en: 'Use the `Purchase` type to create a `purchase` function property in the `Product`
    type as follows:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Purchase`类型在`Product`类型中创建`purchase`函数属性，如下所示：
- en: '[PRE115]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Type errors will be raised on the `table`, `chair`, and `chairOnSale` variable
    declarations because the `purchase` function property is required.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 因为需要`purchase`函数属性，`table`、`chair`和`chairOnSale`变量声明将引发类型错误。
- en: 'Add a `purchase` function property to the `table` variable declarations as
    follows:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式向`table`变量声明中添加`purchase`函数属性：
- en: '[PRE121]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The type error is resolved on the `table` variable declaration.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`table`变量声明上的类型错误已解决。'
- en: A purchase property could be added in a similar way to the `chair` and `chairOnSale`
    variable declarations to resolve their type errors. However, ignore these type
    errors for this exploration and move on to the next step.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以以类似`chair`和`chairOnSale`变量声明的方式添加`purchase`属性来解决这个问题。然而，在这个探索中忽略这些类型错误，继续到下一步。
- en: Click the **Run** option to run the code that purchases four tables. **“Purchased
    4 tables”** is output to the console.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行**选项来运行购买四张桌子的代码。**“已购买4张桌子”**输出到控制台。
- en: In summary, type aliases allow existing types to be composed together and improve
    the readability and reusability of types. We will use type aliases extensively
    in this book.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，类型别名允许将现有类型组合在一起，并提高类型的可读性和可重用性。我们将在本书中广泛使用类型别名。
- en: Next, we will explore an alternative method of creating types. Leave the TypeScript
    Playground open with the code intact – we’ll use this in the next section.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索创建类型的另一种方法。保持TypeScript Playground打开，代码保持不变——我们将在下一节中使用它。
- en: Creating interfaces
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建接口
- en: 'As we created in the last example with type aliases, object types can be created
    using TypeScript’s `interface` keyword, followed by its name, followed by the
    bits that make up the `interface` in curly brackets:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一个示例中使用类型别名创建的那样，可以使用TypeScript的`interface`关键字创建对象类型，后跟其名称，然后是括号中组成`interface`的部分：
- en: '[PRE127]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Go to the TypeScript Playground that contains the code from the type alias
    exploration, and follow along to explore interfaces:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 前往包含类型别名探索中代码的TypeScript Playground，并跟随操作来探索接口：
- en: 'Start by replacing the `Product` type alias with a `Product` interface as follows:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将`Product`类型别名替换为以下`Product`接口：
- en: '[PRE128]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The `table` variable assignment has a type error because the `purchase` property
    doesn’t exist yet – we’ll add this in *step 4*. However, the `chair` variable
    assignment compiles without error.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`table`变量赋值出现类型错误，因为`purchase`属性尚未存在——我们将在*第4步*中添加它。然而，`chair`变量赋值编译时没有错误。'
- en: 'An interface can extend another interface using the `extends` keyword. Replace
    the `DiscountedProduct` type alias with the following interface:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口可以使用`extends`关键字扩展另一个接口。将`DiscountedProduct`类型别名替换为以下接口：
- en: '[PRE132]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Notice that the `chairOnSale` variable assignment compiles without error.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`chairOnSale`变量赋值编译时没有错误。
- en: 'An interface can also be used to represent a function. Add the following interface
    to represent a function, replacing the type alias version:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口也可以用来表示函数。添加以下接口来表示一个函数，替换类型别名版本：
- en: '[PRE135]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The interface syntax for creating functions isn’t as intuitive as using a type
    alias.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 创建函数的接口语法不如使用类型别名直观。
- en: 'Add the `Purchase` interface to the `Product` interface as follows:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式将`Purchase`接口添加到`Product`接口中：
- en: '[PRE136]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: The type error on the `table` variable declarations is resolved now, but type
    errors are raised on the `chair` and `chairOnSale` variable declarations.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`table`变量声明上的类型错误已解决，但现在在`chair`和`chairOnSale`变量声明上引发了类型错误。'
- en: Click the **Run** option to run the code that purchases four tables. **“Purchased
    4 tables”** is output to the console.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行**选项来运行购买四张桌子的代码。**“已购买4张桌子”**输出到控制台。
- en: In the preceding steps, we carried out the same tasks using an interface as
    we did using a type alias. So, the obvious question is, *when should I use a type
    alias instead of an interface and vice versa?* The capabilities of type aliases
    and interfaces for creating object types are very similar – so the simple answer
    is that it is down to preference for object types. Type aliases can create types
    that interfaces can’t, though, such as union types, which we shall cover later
    in this chapter.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤中，我们使用接口和使用类型别名执行了相同的任务。因此，显而易见的问题是，*我应该何时使用类型别名而不是接口，反之亦然？* 类型别名和接口在创建对象类型方面的功能非常相似——所以简单的答案是，这取决于对对象类型的偏好。然而，类型别名可以创建接口无法创建的类型，例如联合类型，我们将在本章后面介绍。
- en: Note
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'See the following link for more information on the differences between type
    aliases and interfaces: [https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces).'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 有关类型别名和接口之间差异的更多信息，请参阅以下链接：[https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces)。
- en: The rest of this book uses type aliases rather than interfaces to define types.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 本书其余部分使用类型别名而不是接口来定义类型。
- en: Next, we will learn how to use TypeScript with classes.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何使用 TypeScript 与类一起使用。
- en: Creating classes
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建类
- en: A **class** is a standard JavaScript feature that acts as a template for creating
    an object. Properties and methods defined in the class are automatically included
    in objects created from the class.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**是标准的 JavaScript 功能，它作为创建对象的模板。在类中定义的属性和方法将自动包含在从该类创建的对象中。'
- en: 'Open the TypeScript Playground, remove any existing code, and carry out the
    following steps to explore classes in TypeScript:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 TypeScript Playground，删除任何现有代码，并按照以下步骤执行以探索 TypeScript 中的类：
- en: 'Add the following code to create a class to represent a product with properties
    for the name and unit price:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码以创建一个表示产品并具有名称和单价属性的类的示例：
- en: '[PRE141]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: If you hover over the `name` and `unitPrice` properties, you’ll see that they
    have the `any` type. As we know, that means no type checking will occur on them.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你悬停在 `name` 和 `unitPrice` 属性上，你会看到它们具有 `any` 类型。正如我们所知，这意味着不会对它们进行类型检查。
- en: 'Add the following type annotations to the properties:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下类型注解添加到属性中：
- en: '[PRE145]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Unfortunately, TypeScript raises the following error:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，TypeScript 抛出了以下错误：
- en: '![Figure 2.22 – Type errors on the class properties](img/B19051_02_22.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.22 – 类属性上的类型错误](img/B19051_02_22.jpg)'
- en: Figure 2.22 – Type errors on the class properties
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.22 – 类属性上的类型错误
- en: The error is because when an instance of the class is created, those property
    values would be `undefined`, which isn’t within the `string` or `number` types.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是因为当创建类的实例时，这些属性值将是 `undefined`，这不在 `string` 或 `number` 类型中。
- en: 'A solution would be to make the properties optional so that they can accept
    `undefined` as a value. Try this solution by adding a `?` symbol at the start
    of the type annotations:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种解决方案是使属性可选，以便它们可以接受 `undefined` 作为值。通过在类型注解的开始处添加 `?` 符号来尝试此解决方案：
- en: '[PRE149]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'If we don’t want the values to initially be `undefined`, we can assign initial
    values like so:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们不希望值最初是 `undefined`，我们可以像这样分配初始值：
- en: '[PRE153]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: If you hover over the properties now, you will see that `name` has been inferred
    to be a `string` type, and `unitPrice` has been inferred to be a `number` type.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在悬停在属性上，你会看到 `name` 已推断为 `string` 类型，而 `unitPrice` 已推断为 `number` 类型。
- en: 'Another method of adding types to class properties is in a constructor. Remove
    the values assigned to the properties and add a constructor to the class as follows:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向类属性添加类型的另一种方法是在构造函数中。移除分配给属性的值，并将构造函数添加到类中，如下所示：
- en: '[PRE157]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: If you hover over the properties, you’ll see that the correct types have been
    inferred.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你悬停在属性上，你会看到已推断出正确的类型。
- en: In fact, the properties don’t need to be defined if the constructor parameters
    are marked as `public`.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际上，如果构造函数参数被标记为 `public`，则不需要定义属性。
- en: '[PRE165]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: TypeScript will automatically create properties for constructor parameters that
    are marked as `public`.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 会自动为标记为 `public` 的构造函数参数创建属性。
- en: 'Type annotations can be added to method parameters and return values, just
    like we have previously done for functions:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以像我们之前为函数所做的那样，将类型注解添加到方法参数和返回值中：
- en: '[PRE171]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Now create an instance of the class and output its discounted price to the
    console:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建类的实例并将它的折扣价格输出到控制台：
- en: '[PRE180]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: If you run the code, **40** is output to the console.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行代码，**40**会被输出到控制台。
- en: In summary, class properties can be given a type in a constructor or by assigning
    a default value. Class methods can be strongly-typed just like regular JavaScript
    functions.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，类属性可以在构造函数中或通过分配默认值来指定类型。类方法可以像常规JavaScript函数一样强类型化。
- en: Note
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on classes, see the following link: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes).'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于类的信息，请参阅以下链接：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)。
- en: Next, we will learn how to create a type to represent a range of values.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何创建一个表示一系列值的类型。
- en: Creating enumerations
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建枚举
- en: '`enum` keyword, followed by the name we want to give to it, and then its possible
    values in curly braces.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`关键字，后面跟着我们想要给它的名字，然后是其可能的值，用大括号括起来。'
- en: 'Let’s explore an example in the TypeScript Playground:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在TypeScript Playground中探索一个例子：
- en: 'Start by creating the enumeration for `Level` containing `Low`, `Medium`, and
    `High` values:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建包含`Low`、`Medium`和`High`值的`Level`枚举：
- en: '[PRE182]'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Now, create a `level` variable and assign it to the values `Low` and then `High`
    from the `Level` enumeration. Also, output the `level` values to the console:'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个`level`变量，并将其赋值为`Level`枚举中的`Low`和`High`值。也将`level`值输出到控制台：
- en: '[PRE187]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Notice that you get IntelliSense as you reference the enumeration.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你引用枚举时，你会得到智能感知。
- en: 'Click the **Run** option to execute the code and observe the enumeration values:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行**选项来执行代码并观察枚举值：
- en: '![Figure 2.23 – Output of enumeration values](img/B19051_02_23.jpg)'
  id: totrans-507
  prefs: []
  type: TYPE_IMG
  zh: '![图2.23 – 枚举值的输出](img/B19051_02_23.jpg)'
- en: Figure 2.23 – Output of enumeration values
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23 – 枚举值的输出
- en: By default, enumerations are zero-based numbers (this means that the first enumeration
    value is 0, the next is 1, the next is 2, and so on). In the preceding example,
    `Level.Low` is `0`, `Level.Medium` is `1`, and `Level.High` is `2`.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，枚举是零基数字（这意味着第一个枚举值是0，下一个是1，再下一个是2，依此类推）。在先前的例子中，`Level.Low`是`0`，`Level.Medium`是`1`，`Level.High`是`2`。
- en: 'Instead of the default values, custom values can be explicitly defined against
    each enumeration item after the equals (`=`) symbol. Explicitly set the values
    to be between `1` and `3`:'
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 而不是使用默认值，我们可以在等于（`=`）符号之后显式地为每个枚举项定义自定义值。显式地将值设置为`1`到`3`之间：
- en: '[PRE191]'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: You can rerun the code to verify this works.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以重新运行代码来验证这一点。
- en: 'Now, let’s do something interesting. Assign `level` to a number greater than
    3:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们做一些有趣的事情。将`level`赋值为大于3的数字：
- en: '[PRE196]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Notice that a type error *doesn’t* occur. This is a little surprising – number-based
    enumerations aren’t as type-safe as we would like.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里没有发生类型错误。这有点令人惊讶——基于数字的枚举并不像我们希望的那样类型安全。
- en: 'Instead of using number enumeration values, let’s try strings. Replace all
    of the current code with the following:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 而不是使用数字枚举值，让我们尝试使用字符串。将所有当前代码替换为以下内容：
- en: '[PRE197]'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: If this code is run, we see **L** and **H** output to the console as expected.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行此代码，我们会看到预期的**L**和**H**输出到控制台。
- en: 'Add another line that assigns `level` to the following strings:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一行代码，将`level`赋值为以下字符串：
- en: '[PRE206]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'We immediately see type errors raised on these assignments:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 我们立即在这些赋值上看到类型错误被抛出：
- en: '![Figure 2.24 – Confirmation that string enumerations are type-safe](img/B19051_02_24.jpg)'
  id: totrans-535
  prefs: []
  type: TYPE_IMG
  zh: '![图2.24 – 确认字符串枚举是类型安全的](img/B19051_02_24.jpg)'
- en: Figure 2.24 – Confirmation that string enumerations are type-safe
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.24 – 确认字符串枚举是类型安全的
- en: In summary, enumerations are a way of representing a range of values with user-friendly
    names. They are zero-based numbers by default and not as type-safe as we would
    like. However, we can make enumerations string-based, which is more type-safe.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，枚举是一种用用户友好的名称表示一系列值的方法。默认情况下，它们是零基数字，并不像我们希望的那样类型安全。然而，我们可以将枚举基于字符串，这更类型安全。
- en: Next, we will learn about union types in TypeScript.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习TypeScript中的联合类型。
- en: Creating union types
  id: totrans-539
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建联合类型
- en: A **union type** is the mathematical union of multiple other types to create
    a new type. Like enumerations, union types can represent a range of values. As
    mentioned earlier, type aliases can be used to create union types.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '**联合类型**是多个其他类型的数学并集，用于创建一个新类型。与枚举类似，联合类型可以表示一系列值。如前所述，可以使用类型别名来创建联合类型。'
- en: 'An example of a union type is as follows:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 联合类型的一个例子如下：
- en: '[PRE208]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: This `Level` type is similar to the enumeration version of the `Level` type
    we created earlier. The difference is that the union type only contains values
    (`"H"`, `"M"`, `"L"`) rather than a name (`"High"`, `"Medium"`, `"Large"`) and
    a value.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `Level` 类型与我们之前创建的 `Level` 类型的枚举版本类似。区别在于，联合类型只包含值（`"H"`，`"M"`，`"L"`）而不是名称（`"High"`，`"Medium"`，`"Large"`）和值。
- en: 'Clear any existing code in the TypeScript Playground, and let’s have a play
    with union types:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 清除 TypeScript Playground 中的任何现有代码，让我们来玩一玩联合类型：
- en: 'Start by creating a type to represent `"red"`, `"green"`, or `"blue"`:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个表示 `"red"`，`"green"` 或 `"blue"` 的类型：
- en: '[PRE209]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: Note that this type is a union of strings, but a union type can consist of any
    types – even mixed types!
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个类型是字符串的联合，但联合类型可以由任何类型组成——甚至可以是混合类型！
- en: 'Create a variable with the `RGB` type and assign a valid value:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有 `RGB` 类型的变量并分配一个有效值：
- en: '[PRE210]'
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'Now try assigning a value outside the type:'
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试分配一个类型外的值：
- en: '[PRE211]'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'A type error occurs, as expected:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，发生类型错误：
- en: '![Figure 2.25 – Type error on the union type](img/B19051_02_25.jpg)'
  id: totrans-553
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.25 – 联合类型上的类型错误](img/B19051_02_25.jpg)'
- en: Figure 2.25 – Type error on the union type
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.25 – 联合类型上的类型错误
- en: Union types consisting of strings are great when a type can only hold a specific
    set of strings, as in the preceding example.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类型只能持有特定的一组字符串时，如前例所示，由字符串组成的联合类型非常出色。
- en: 'Here’s a recap of what we have learned about creating types:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对我们关于创建类型的了解的回顾：
- en: Objects and functions can be represented using type aliases or interfaces. They
    have very similar capabilities, but the type alias syntax is a little more intuitive
    for representing functions.
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象和函数可以使用类型别名或接口来表示。它们具有非常相似的功能，但类型别名语法在表示函数时更为直观。
- en: The `?` symbol can specify that an object property or function parameter is
    optional.
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?` 符号可以指定对象属性或函数参数是可选的。'
- en: Type annotations can be added to class properties and constructor and method
    parameters to make them type-safe.
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将类型注解添加到类属性、构造函数和方法参数中，以使它们具有类型安全性。
- en: Like string-based union types, string-based enumerations are great for a specific
    set of strings. A string union type is the simplest approach if the strings are
    meaningful. If the strings aren’t meaningful, then a string enumeration can be
    used to make them readable.
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与基于字符串的联合类型类似，基于字符串的枚举非常适合一组特定的字符串。如果字符串具有意义，那么字符串联合类型是最简单的方法。如果字符串没有意义，则可以使用字符串枚举来使它们可读。
- en: Now that we have covered types, next, we will learn about the TypeScript compiler.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了类型，接下来，我们将学习 TypeScript 编译器。
- en: Using the TypeScript compiler
  id: totrans-562
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TypeScript 编译器
- en: In this section, we will learn how to use the TypeScript compiler to type check
    code and transpile it into JavaScript. First, we will use Visual Studio Code and
    create a simple TypeScript project containing code we have written in a previous
    section. We will then use the terminal within Visual Studio Code to interact with
    the TypeScript compiler.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用 TypeScript 编译器进行代码类型检查并将其转换为 JavaScript。首先，我们将使用 Visual Studio
    Code 创建一个包含我们在上一节中编写的代码的简单 TypeScript 项目。然后，我们将使用 Visual Studio Code 内部的终端与 TypeScript
    编译器进行交互。
- en: 'Open Visual Studio Code in a blank folder of your choice, and carry out the
    following steps:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 在您选择的空白文件夹中打开 Visual Studio Code，并执行以下步骤：
- en: 'In the `package.json` containing the following content:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包含以下内容的 `package.json` 中：
- en: '[PRE212]'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE220]'
- en: The file defines a project name of `tsc-play` and sets TypeScript as the only
    dependency. The file also defines an npm script called `build` that will invoke
    the TypeScript compiler (`tsc`), passing it to the `product.ts` file in the `src`
    folder. Don’t worry that `product.ts` doesn’t exist – we will create it in *step
    3*.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件定义了一个项目名称为 `tsc-play`，并将 TypeScript 设置为唯一的依赖项。该文件还定义了一个名为 `build` 的 npm 脚本，它将调用
    TypeScript 编译器（`tsc`），并将 `src` 文件夹中的 `product.ts` 文件传递给它。不要担心 `product.ts` 文件不存在——我们将在
    *步骤 3* 中创建它。
- en: 'Now open the Visual Studio Code terminal by selecting **New Terminal** from
    the **Terminal** menu, then enter the following command:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过从 **终端** 菜单中选择 **New Terminal** 来打开 Visual Studio Code 终端，然后输入以下命令：
- en: '[PRE221]'
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: This will install all the libraries listed in the `dependencies` section of
    `package.json`. So, this will install TypeScript.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装 `package.json` 的 `dependencies` 部分中列出的所有库。因此，这将安装 TypeScript。
- en: Create a folder called `src` and then create a file called `product.ts` within
    it.
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `src` 的文件夹，然后在其中创建一个名为 `product.ts` 的文件。
- en: 'Open `product.ts` and add the following content:'
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product.ts` 并添加以下内容：
- en: '[PRE222]'
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-588
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE232]'
- en: This code will be familiar from the section on using classes. The code can be
    copied from [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section4-Using-the-compiler/src/product.ts](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section4-Using-the-compiler/src/product.ts).
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以在使用类的部分中找到。您可以从[https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section4-Using-the-compiler/src/product.ts](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section4-Using-the-compiler/src/product.ts)复制此代码。
- en: 'Enter the following command in the terminal:'
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中输入以下命令：
- en: '[PRE233]'
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE233]'
- en: This will run the npm `build` script we defined in the first step.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行我们在第一步中定义的npm `build` 脚本。
- en: After the command finishes, notice that a `product.js` file appears next to
    `product.ts` in the `src` folder.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 命令完成后，注意在`src`文件夹中`product.ts`旁边会出现一个`product.js`文件。
- en: 'Open the transpiled `product.js` file and read the content. It will look as
    follows:'
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开转换后的`product.js`文件并阅读内容。它看起来如下所示：
- en: '[PRE234]'
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-600
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-605
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-611
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE247]'
- en: Notice that the type annotations have been removed because they aren’t valid
    JavaScript. Notice also that it has been transpiled to JavaScript, capable of
    running in very old browsers.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到类型注解已被删除，因为它们不是有效的JavaScript。同时注意，它已被转换为JavaScript，能够在非常旧的浏览器中运行。
- en: The default configuration that the TypeScript compiler uses isn’t ideal. For
    example, we probably want the transpiled JavaScript in a completely separate folder,
    and are likely to want to target newer browsers.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器使用的默认配置并不理想。例如，我们可能希望将转换后的JavaScript放在一个完全独立的文件夹中，并且可能希望针对更新的浏览器。
- en: 'The TypeScript compiler can be configured using a file called `tsconfig.json`.
    Add a `tsconfig.json` file at the root of the project, containing the following
    code:'
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用名为`tsconfig.json`的文件来配置TypeScript编译器。在项目的根目录中添加一个`tsconfig.json`文件，包含以下代码：
- en: '[PRE248]'
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-621
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-625
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-627
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE261]'
- en: This code can be copied from [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section4-Using-the-compiler/tsconfig.json](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section4-Using-the-compiler/tsconfig.json).
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section4-Using-the-compiler/tsconfig.json](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section4-Using-the-compiler/tsconfig.json)复制此代码。
- en: 'Here’s an explanation of each setting in the `compilerOptions` field:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`compilerOptions`字段中每个设置的说明：
- en: '`outDir`: This is the folder that the transpiled JavaScript is placed in.'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`outDir`：这是放置转换后的JavaScript的文件夹。'
- en: '`target`: This is the version of JavaScript we want to transpile to. The `esnext`
    target means the next version.'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target`：这是我们想要转换到的JavaScript版本。`esnext`目标意味着下一个版本。'
- en: '`Module`: This is the type of module used within the code. The `esnext` module
    means standard JavaScript modules.'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Module`：这是代码中使用的模块类型。`esnext`模块意味着标准JavaScript模块。'
- en: '`Lib`: Gives the standard library types included in the type checking process.
    `DOM` gives the browser DOM API types, and `esnext` are types for APIs in the
    next version of JavaScript.'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lib`：在类型检查过程中包含的标准库类型。`DOM`提供浏览器DOM API类型，而`esnext`是JavaScript下一个版本API的类型。'
- en: '`Strict`: When set to `true`, means the strictest level of type checking.'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Strict`：当设置为`true`时，表示最严格的类型检查级别。'
- en: '`Jsx`: When set to `React`, allows the compiler to transpile React’s JSX.'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Jsx`：当设置为`React`时，允许编译器转换React的JSX。'
- en: '`moduleResolution`: This is how dependencies are found. We want TypeScript
    to look in the `node_modules` folder, so we have chosen `node`.'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`moduleResolution`：这是查找依赖项的方式。我们希望TypeScript在`node_modules`文件夹中查找，因此我们选择了`node`。'
- en: '`noEmitOnError`: When set to `true`, means the transpilation won’t happen if
    a type error is found.'
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`noEmitOnError`：当设置为`true`时，表示如果发现类型错误，则不会发生转换。'
- en: The `include` field specifies the TypeScript files to compile, and the `exclude`
    field specifies the files to exclude.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '`include`字段指定要编译的TypeScript文件，而`exclude`字段指定要排除的文件。'
- en: Note
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on the TypeScript compiler options, see the following
    link: [https://www.typescriptlang.org/tsconfig](https://www.typescriptlang.org/tsconfig).'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 关于TypeScript编译器选项的更多信息，请参阅以下链接：[https://www.typescriptlang.org/tsconfig](https://www.typescriptlang.org/tsconfig)。
- en: 'The TypeScript compiler configuration now specifies all files in the `src`
    folder to be compiled. So, remove the file path on the `build` script in `package.json`:'
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TypeScript编译器配置现在指定了`src`文件夹中的所有文件都要进行编译。因此，从`package.json`中的`build`脚本中删除文件路径：
- en: '[PRE262]'
  id: totrans-643
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-644
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-645
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-646
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-647
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-648
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE267]'
- en: Delete the previous transpiled `product.js` in the `src` folder.
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`src`文件夹中之前的转换后的`product.js`文件。
- en: 'Rerun the `build` command in the terminal:'
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中重新运行 `build` 命令：
- en: '[PRE268]'
  id: totrans-651
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE268]'
- en: This time the transpiled file is placed in a `build` folder. You will also notice
    that the transpiled JavaScript now uses classes that are supported in modern browsers.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 这次转换的文件被放置在 `build` 文件夹中。您还会注意到，现在转换的 JavaScript 使用了现代浏览器支持的类。
- en: 'The final thing we are going to try is a type error. Open `product.ts` and
    update the constructor to reference an incorrect property name:'
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要尝试的最后一件事是类型错误。打开 `product.ts` 并更新构造函数以引用错误的属性名：
- en: '[PRE269]'
  id: totrans-654
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-655
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-656
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-657
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-658
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-659
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-660
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE275]'
- en: Delete the `build` folder to remove the previously transpiled JavaScript file.
  id: totrans-661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `build` 文件夹以移除之前转换的 JavaScript 文件。
- en: 'Rerun the `build` command in the terminal:'
  id: totrans-662
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中重新运行 `build` 命令：
- en: '[PRE276]'
  id: totrans-663
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE276]'
- en: The type error is reported in the terminal. Notice that the JavaScript file
    is not transpiled.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 类型错误在终端中报告。注意，JavaScript 文件没有被转换。
- en: In summary, TypeScript has a compiler, called `tsc`, that we can use to carry
    out type checking and transpilation as part of a continuous integration process.
    The compiler is very flexible and can be configured using a file called `tsconfig.json`.
    It is worth noting that Babel is often used to transpile TypeScript (as well as
    React), leaving TypeScript to focus on type checking.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，TypeScript 有一个名为 `tsc` 的编译器，我们可以使用它来执行类型检查和转换，作为持续集成过程的一部分。编译器非常灵活，可以使用名为
    `tsconfig.json` 的文件进行配置。值得注意的是，Babel 通常用于转换 TypeScript（以及 React），让 TypeScript
    专注于类型检查。
- en: Next, we will recap what we have learned in this chapter.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回顾本章所学的内容。
- en: Summary
  id: totrans-667
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: TypeScript complements JavaScript with a rich type system, and in this chapter,
    we experienced catching errors early using TypeScript’s type checking.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 通过丰富的类型系统补充了 JavaScript，在本章中，我们通过使用 TypeScript 的类型检查来早期捕获错误。
- en: We also learned that JavaScript types, such as `number` and `string`, can be
    used in TypeScript, as well as types that only exist in TypeScript, such as `Date`
    and `unknown`.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到，JavaScript 类型，如 `number` 和 `string`，可以在 TypeScript 中使用，以及仅存在于 TypeScript
    中的类型，如 `Date` 和 `unknown`。
- en: We explored union types and learned that these are great for representing a
    specific set of strings. We now understand that string enumerations are an alternative
    to string union types if the string values aren’t very meaningful.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了联合类型，并了解到这些类型非常适合表示一组特定的字符串。我们现在明白，如果字符串值不是非常有意义，字符串枚举是字符串联合类型的替代方案。
- en: New types can be created using type aliases. We learned that type aliases could
    be based on objects, functions, or even union types. We now know that the `?`
    symbol in a type annotation makes an object property or function parameter optional.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用类型别名创建新类型。我们了解到类型别名可以基于对象、函数，甚至是联合类型。我们现在知道，类型注解中的 `?` 符号使对象属性或函数参数成为可选的。
- en: We also learned a fair bit about the TypeScript compiler and how it can work
    well in different use cases because it is very configurable. This will be important
    when we start to use TypeScript with React in the next chapter. There, we will
    learn different ways of setting up React and TypeScript projects before learning
    to strongly-type React props and state.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解了很多关于 TypeScript 编译器及其如何在不同用例中良好工作的信息，因为它非常可配置。当我们开始在下一章中使用 TypeScript
    与 React 一起工作时，这将是重要的。在那里，我们将在学习如何为 React 和 TypeScript 项目设置不同的方式之前，学习如何为 React
    props 和 state 设置强类型。
- en: Questions
  id: totrans-673
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to check what you have learned about TypeScript:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以检查您对 TypeScript 的了解：
- en: What would the inferred type be for the `flag` variable in the following code?
  id: totrans-675
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，`flag` 变量的推断类型会是什么？
- en: '[PRE277]'
  id: totrans-676
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE277]'
- en: What is the return type in the following function?
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数的返回类型是什么？
- en: '[PRE278]'
  id: totrans-678
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-679
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-680
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE280]'
- en: What is the type annotation for an array of dates?
  id: totrans-681
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 日期数组的类型注解是什么？
- en: Will a type error occur in the following code?
  id: totrans-682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中会发生类型错误吗？
- en: '[PRE281]'
  id: totrans-683
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-684
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE282]'
- en: Use a type alias to create a number that can only hold integer values between
    and including 1 and 3.
  id: totrans-685
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用类型别名创建一个只能持有介于1和3之间（包括1和3）的整数值的数字。
- en: What TypeScript compiler option can be used to prevent the transpilation process
    when a type error is found?
  id: totrans-686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当发现类型错误时，可以使用哪个 TypeScript 编译器选项来防止转换过程？
- en: 'The following code raises a type error because `lastSale` can’t accept `null`
    values:'
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码会引发类型错误，因为 `lastSale` 不能接受 `null` 值：
- en: '[PRE283]'
  id: totrans-688
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-689
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-690
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-691
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-692
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE287]'
- en: How can the `Product` type be changed to allow `lastSale` to accept `null` values?
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 如何更改 `Product` 类型以允许 `lastSale` 接受 `null` 值？
- en: Answers
  id: totrans-694
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The `flag` variable would be inferred to be a `boolean` type.
  id: totrans-695
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`flag` 变量会被推断为 `boolean` 类型。'
- en: The return type in the function is `void`.
  id: totrans-696
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数中的返回类型是 `void`。
- en: An array of dates can be represented as `Date[]` or `Array<Date>`.
  id: totrans-697
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 日期数组可以表示为`Date[]`或`Array<Date>`。
- en: A type error will not be raised on the `point` variable. It doesn’t need to
    include the `z` property because it is optional.
  id: totrans-698
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`point`变量上不会引发类型错误。因为它可选，所以不需要包含`z`属性。
- en: 'A type for numbers 1-3 can be created as follows:'
  id: totrans-699
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以创建一个用于数字1-3的类型，如下所示：
- en: '[PRE288]'
  id: totrans-700
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE288]'
- en: The `noEmitOnError` compiler option (set to `true`) can be used to prevent the
    transpilation process when a type error is found.
  id: totrans-701
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当发现类型错误时，可以使用`noEmitOnError`编译器选项（设置为`true`）来防止编译过程。
- en: 'A union type can be used for the `lastSale` property to allow it to accept
    `null` values:'
  id: totrans-702
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 联合类型可用于`lastSale`属性，以便它接受`null`值：
- en: '[PRE289]'
  id: totrans-703
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-704
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-705
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-706
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-707
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE293]'
