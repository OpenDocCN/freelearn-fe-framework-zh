- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: DevOps Using Docker
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker进行DevOps
- en: By the end of *Chapter 8*, *Designing Authentication and Authorization*, we
    had a fairly sophisticated app. In *Chapter 4*, *Automated Testing, CI, and Release
    to Production*, I emphasized the need to ensure that every code push we create
    has passing tests, adheres to the coding standards, and is an executable artifact
    that team members can run tests against as we develop our application. By the
    end of *Chapter 7*, *Creating a Router-First Line-of-Business App*, you should
    have replicated the same CircleCI setup we implemented for the Local Weather app
    for LemonMart. If not, before we start building more complicated features for
    our **Line-of-Business** (**LOB**) app, go ahead and do this.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到**第8章**结束，即**设计身份验证和授权**，我们已经拥有了一个相当复杂的应用程序。在**第4章**，即**自动化测试、持续集成和发布到生产环境**，我强调了确保我们创建的每个代码推送都通过测试、遵循编码标准，并且是一个团队成员可以运行测试的可执行工件的重要性。到**第7章**结束，即**创建以路由器为第一线的业务应用程序**，你应该已经复制了我们为LemonMart的本地天气应用程序实现的相同CircleCI设置。如果没有，在我们开始为我们的**业务线应用程序**（**LOB**）构建更复杂的功能之前，请先完成这项工作。
- en: We live in an era of moving fast and breaking things. However, the latter part
    of that statement rarely works in an enterprise. You can choose to live on the
    edge and adopt the YOLO lifestyle, but this doesn't make good business sense.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活在一个快速行动并打破事物的时代。然而，这个陈述的后半部分在企业中很少适用。你可以选择生活在边缘并采用YOLO生活方式，但这并不符合商业逻辑。
- en: '![](img/B14094_09_01.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_09_01.png)'
- en: 'Figure 9.1: A creative CLI option for a tool'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：一个工具的创意命令行界面选项
- en: '**Continuous Integration** (**CI**) is critical to ensuring a quality deliverable
    by building and executing tests on every code push. Setting up a CI environment
    can be time-consuming and requires specialized knowledge of the tool being used.
    In *Chapter 4*, *Automated Testing, CI, and Release to Production*, we implemented
    GitHub flow with CircleCI integration. However, we manually deployed our app.
    To move fast without breaking things, we need to implement **Continuous Deployment**
    (**CD**) using DevOps best practices such as **Infrastructure-as-Code** (**IaC**),
    so we can verify the correctness of our running code more often.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）对于确保通过在每次代码推送时构建和执行测试来交付高质量的产品至关重要。设置CI环境可能耗时且需要使用工具的专业知识。在**第4章**，即**自动化测试、持续集成和发布到生产环境**，我们实现了GitHub流程与CircleCI的集成。然而，我们手动部署了我们的应用程序。为了快速行动而不破坏事物，我们需要使用DevOps最佳实践，如**基础设施即代码**（**IaC**）来实现**持续部署**（**CD**），这样我们就可以更频繁地验证我们运行中的代码的正确性。'
- en: In this chapter, we will go over a Docker-based approach to implement IaC that
    can be run on most CI services and cloud providers, allowing you to achieve repeatable
    builds and deployments from any CI environment to any cloud provider. Working
    with flexible tools, you will avoid overspecializing in one service and keep your
    configuration management skills relevant across different CI services.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一种基于Docker的方法来实现IaC，它可以在大多数CI服务和云服务提供商上运行，允许你从任何CI环境到任何云服务提供商实现可重复的构建和部署。使用灵活的工具，你将避免在单一服务上过度专业化，并保持你的配置管理技能在不同CI服务中相关。
- en: This book leverages CircleCI as the CI server. Other notable CI servers are
    Jenkins, Azure DevOps, and the built-in mechanisms within GitLab and GitHub.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本书利用CircleCI作为持续集成服务器。其他值得注意的持续集成服务器包括Jenkins、Azure DevOps以及GitLab和GitHub内置的机制。
- en: 'In this chapter, you will learn the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: DevOps and IaC
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DevOps和IaC
- en: Containerizing web apps using Docker
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker容器化Web应用程序
- en: Deploying containerized apps using Google Cloud Run
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Google Cloud Run部署容器化应用程序
- en: CD to multiple cloud providers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码部署到多个云服务提供商
- en: Advanced CI
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级持续集成
- en: Code coverage reports
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码覆盖率报告
- en: 'The following software is required to follow along with this chapter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循本章内容所需的软件包括：
- en: Docker Desktop Community version 2+
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Desktop Community版本2+
- en: Docker Engine CE version 18+
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Engine CE版本18+
- en: A Google Cloud Engine account
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Google Cloud Engine账户
- en: A Coveralls account
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Coveralls账户
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the repository linked in the following list. The repository contains the final
    and completed version of the code. Each section contains information boxes to
    help direct you to the correct filename or branch on GitHub so that you can use
    them to verify your progress.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 书中示例代码的最新版本可在GitHub上找到，链接如下列表中的存储库。该存储库包含代码的最终和完成版本。每个部分都包含信息框，以帮助您找到GitHub上的正确文件名或分支，以便您可以使用它们来验证您的进度。
- en: 'For the *Chapter 9* examples based on **local-weather-app**, do the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于 **local-weather-app** 的 *第 9 章* 示例，请执行以下操作：
- en: Clone the repo at [https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 [https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
    处克隆仓库。
- en: Execute `npm install` on the root folder to install dependencies.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录下执行 `npm install` 以安装依赖项。
- en: Use `.circleci/config.ch9.yml` to verify your `config.yml` implementation.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `.circleci/config.ch9.yml` 来验证您的 `config.yml` 实现。
- en: To run the CircleCI Vercel Now configuration, execute
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行 CircleCI Vercel Now 配置，请执行
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Refer to the pull request at [https://github.com/duluca/local-weather-app/pull/50](https://github.com/duluca/local-weather-app/pull/50).
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请参阅 [https://github.com/duluca/local-weather-app/pull/50](https://github.com/duluca/local-weather-app/pull/50)
    的拉取请求。
- en: To run the CircleCI GCloud configuration, execute
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行 CircleCI GCloud 配置，请执行
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Refer to the pull request at [https://github.com/duluca/local-weather-app/pull/51](https://github.com/duluca/local-weather-app/pull/51).
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请参阅 [https://github.com/duluca/local-weather-app/pull/51](https://github.com/duluca/local-weather-app/pull/51)
    的拉取请求。
- en: Note that both branches leverage modified code to use the `projects/ch6` code
    from the **local-weather-app** repo.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两个分支都利用修改后的代码来使用来自 **local-weather-app** 仓库的 `projects/ch6` 代码。
- en: 'For the *Chapter 9* examples based on **lemon-mart**, do the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于 **lemon-mart** 的 *第 9 章* 示例，请执行以下操作：
- en: Clone the repo at [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
    处克隆仓库。
- en: Use `.circleci/config.ch9.yml` and `config.docker-integration.yml` to verify
    your `config.yml` implementation.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `.circleci/config.ch9.yml` 和 `config.docker-integration.yml` 来验证您的 `config.yml`
    实现。
- en: Execute `npm install` on the root folder to install dependencies.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录下执行 `npm install` 以安装依赖项。
- en: To run the CircleCI Docker integration configuration, execute
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行 CircleCI Docker 集成配置，请执行
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Refer to the pull request at [https://github.com/duluca/lemon-mart/pull/25](https://github.com/duluca/lemon-mart/pull/25).
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请参阅 [https://github.com/duluca/lemon-mart/pull/25](https://github.com/duluca/lemon-mart/pull/25)
    的拉取请求。
- en: Note that the `docker-integration` branch is slightly modified to use code from
    the `projects/ch8` folder on the **lemon-mart** repo.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`docker-integration` 分支略有修改，以使用来自 **lemon-mart** 仓库的 `projects/ch8` 文件夹中的代码。
- en: Beware that there may be slight differences in implementation between the code
    in the book and what's on GitHub because the ecosystem is ever-evolving. It is
    natural for the sample code to change over time. Also, on GitHub, expect to find
    corrections, fixes to support newer versions of libraries, or side-by-side implementations
    of multiple techniques for the reader to observe. The reader is only expected
    to implement the ideal solution recommended in the book. If you find errors or
    have questions, please create an issue or submit a pull request on GitHub for
    the benefit of all readers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于生态系统不断演变，书中代码与 GitHub 上的代码之间可能存在细微的差异。随着时间的推移，示例代码发生变化是自然的。在 GitHub 上，您可能会找到更正、修复以支持库的新版本，或者为读者观察而并排实现多种技术的示例。读者只需实现书中推荐的理想解决方案即可。如果您发现错误或有疑问，请创建问题或提交
    GitHub 上的拉取请求，以惠及所有读者。
- en: You can read more about updating Angular in *Appendix C*, *Keeping Angular and
    Tools Evergreen*. You can find this appendix online from [https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.)
    or at [https://expertlysimple.io/stay-evergreen](https://expertlysimple.io/stay-evergreen).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 *附录 C* 中了解更多关于更新 Angular 的信息，即 *保持 Angular 和工具始终如一*。您可以从 [https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.)
    或 [https://expertlysimple.io/stay-evergreen](https://expertlysimple.io/stay-evergreen)
    在线找到此附录。
- en: Let's start by understanding what DevOps is.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来了解一下 DevOps 是什么。
- en: DevOps
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DevOps
- en: DevOps is the marriage of development and operations. In development, it is
    well established that code repositories like Git track every code change. In operations,
    there has long been a wide variety of techniques to track changes to environments,
    including scripts and various tools that aim to automate the provisioning of operating
    systems and servers.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 是开发和运维的结合。在开发中，代码仓库如 Git 跟踪每个代码更改是众所周知的事实。在运维中，长期以来一直存在各种技术来跟踪环境更改，包括脚本和各种旨在自动化操作系统和服务器配置的自动化工具。
- en: Still, how many times have you heard the saying, "it works on my machine"? Developers
    often use that line as a joke. Still, it is often the case that software that
    works perfectly well on a test server ends up running into issues on a production
    server due to minor differences in configuration.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你听过多少次“在我的机器上它工作得很好”的说法？开发者经常用这句话作为玩笑。尽管如此，软件在测试服务器上运行得很好，但由于配置的细微差异，最终在生产服务器上遇到问题的情形也经常发生。
- en: 'In *Chapter 4*, *Automated Testing, CI, and Release to Production*, we discussed
    how GitHub flow can enable us to create a value delivery stream. We always branch
    from the master before making a change. Enforce that change to go through our
    CI pipeline, and once we''re reasonably sure that our code works, we can merge
    back to the master branch. See the following diagram:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4章*，*自动化测试、持续集成和发布到生产*中，我们讨论了GitHub流程如何使我们能够创建一个价值交付流。我们在做出任何更改之前总是从主分支分叉。强制更改通过我们的CI管道，一旦我们合理确信我们的代码可以工作，我们就可以合并回主分支。请参见以下图表：
- en: '![](img/B14094_09_02.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_09_02.png)'
- en: 'Figure 9.2: Branching and merging'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：分叉和合并
- en: Remember, your master branch should always be deployable, and you should frequently
    merge your work to the master branch.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你的主分支应该始终是可部署的，你应该经常将你的工作合并到主分支。
- en: Docker allows us to define the software and the specific configuration parameters
    that our code depends on in a declarative manner using a special file named a
    `Dockerfile`. Similarly, CircleCI allows us to define the configuration of our
    CI environment in a `config.yml` file. By storing our configuration in files,
    we are able to check the files in alongside our code. We can track changes using
    Git and enforce them to be verified by our CI pipeline. By storing the definition
    of our infrastructure in code, we achieve IaC. With IaC, we also achieve repeatable
    integration, so no matter what environment we run our infrastructure in, we should
    be able to stand up our full-stack app with a one-line command.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Docker允许我们通过一个名为`Dockerfile`的特殊文件以声明方式定义我们的代码所依赖的软件和特定的配置参数。同样，CircleCI允许我们通过一个名为`config.yml`的文件定义我们的CI环境配置。通过将配置存储在文件中，我们能够与代码一起检查这些文件。我们可以使用Git跟踪更改，并强制它们通过我们的CI管道进行验证。通过将基础设施的定义存储在代码中，我们实现了基础设施即代码（IaC）。通过IaC，我们还实现了可重复的集成，因此无论我们在什么环境中运行我们的基础设施，我们都应该能够通过一条命令启动我们的全栈应用。
- en: 'You may remember that in *Chapter 1*, *Introduction to Angular and Its Concepts*,
    we covered how TypeScript covers the JavaScript Feature Gap. Similar to TypeSript,
    Docker covers the configuration gap, as demonstrated in the following diagram:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，在*第1章*，*Angular介绍及其概念*中，我们介绍了TypeScript如何覆盖JavaScript功能差距。与TypeScript类似，Docker覆盖了配置差距，如下所示：
- en: '![](img/B14094_09_03.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_09_03.png)'
- en: 'Figure 9.3: Covering the configuration gap'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：覆盖配置差距
- en: By using Docker, we can be reasonably sure that our code, which worked on our
    machine during testing, will work exactly the same way when we ship it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Docker，我们可以合理确信，在测试期间在我们机器上工作的代码，在发布时将以完全相同的方式运行。
- en: In summary, with DevOps, we bring operations closer to development, where it
    is cheaper to make changes and resolve issues. So, DevOps is primarily a developer's
    responsibility, but it is also a way of thinking that the operations team must
    be willing to support. Let's dive deeper into Docker.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，通过DevOps，我们将运维与开发更紧密地结合在一起，在开发中更改和解决问题成本更低。因此，DevOps主要是开发者的责任，但它也是一种思维方式，运维团队必须愿意支持。让我们更深入地了解Docker。
- en: Containerizing web apps using Docker
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker容器化Web应用
- en: Docker, which can be found at [https://docker.io](https://docker.io), is an
    open platform for developing, shipping, and running applications. Docker combines
    a lightweight container virtualization platform with workflows and tooling that
    help manage and deploy applications. The most obvious difference between **Virtual
    Machines** (**VMs**) and Docker containers is that VMs are usually dozens of gigabytes
    in size and require gigabytes of memory, whereas containers take up megabytes
    in terms of disk and memory size requirements. Furthermore, the Docker platform
    abstracts away host **operating system** (**OS**) - level configuration settings,
    so every piece of configuration that is needed to successfully run an application
    is encoded within a human-readable format.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Docker，可在 [https://docker.io](https://docker.io) 找到，是一个用于开发、运输和运行应用程序的开源平台。Docker
    结合了一个轻量级的容器虚拟化平台以及帮助管理和部署应用程序的工作流程和工具。**虚拟机**（**VMs**）和 Docker 容器之间最明显的区别是，VMs
    通常大小为数十个吉字节，需要数吉字节内存，而容器在磁盘和内存大小需求方面仅占用兆字节。此外，Docker 平台抽象化了主机 **操作系统**（**OS**）级别的配置设置，因此成功运行应用程序所需的所有配置都编码在可读格式中。
- en: Anatomy of a Dockerfile
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dockerfile 的结构
- en: 'A `Dockerfile` consists of four main parts:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Dockerfile` 由四个主要部分组成：
- en: '**FROM** – where we can inherit from Docker''s minimal "scratch" image or a
    pre-existing image'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FROM** – 我们可以继承 Docker 的最小 "scratch" 镜像或现有的镜像'
- en: '**SETUP** – where we configure software dependencies to our requirements'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SETUP** – 我们根据需求配置软件依赖的地方'
- en: '**COPY** – where we copy our built code into the operating environment'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**COPY** – 我们将构建的代码复制到操作环境中的地方'
- en: '**CMD** – where we specify the commands that will bootstrap the operating environment'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CMD** – 我们指定启动操作环境的命令的地方'
- en: Bootstrap refers to a set of initial instructions that describe how a program
    loads or starts up.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 引导程序指的是一组初始指令，描述了程序如何加载或启动。
- en: 'Consider the following visualization of the anatomy of a `Dockerfile`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 `Dockerfile` 结构的可视化：
- en: '![](img/B14094_09_04.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_09_04.png)'
- en: 'Figure 9.4: Anatomy of a Dockerfile'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4：Dockerfile 的结构
- en: 'A concrete representation of a `Dockerfile` is demonstrated in the following
    code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了 `Dockerfile` 的具体表示：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can map the `FROM`, `COPY`, and `CMD` parts of the script to the visualization.
    We inherit from the `duluca/minimal-nginx-web-server` image using the `FROM` command.
    Then, we copy the compiled result of our app from our development machine or build
    environment into the image using the `COPY` (or, alternatively, the `ADD`) command.
    Finally, we instruct the container to execute the nginx web server using the `CMD`
    (or, alternatively, the `ENTRYPOINT`) command.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将脚本中的 `FROM`, `COPY`, 和 `CMD` 部分映射到可视化中。我们使用 `FROM` 命令从 `duluca/minimal-nginx-web-server`
    镜像继承。然后，我们使用 `COPY`（或，作为替代，`ADD`）命令将我们的应用程序的编译结果从我们的开发机器或构建环境复制到镜像中。最后，我们指示容器使用
    `CMD`（或，作为替代，`ENTRYPOINT`）命令执行 nginx 网络服务器。
- en: Note that the preceding `Dockerfile` doesn't have a distinct `SETUP` part. `SETUP`
    doesn't map to an actual `Dockerfile` command but represents a collection of commands
    you can execute to set up your container. In this case, all the necessary setup
    was done by the base image, so there are no additional commands to run.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的 `Dockerfile` 没有独立的 `SETUP` 部分。`SETUP` 不对应实际的 `Dockerfile` 命令，但代表了一组你可以执行的命令来设置你的容器。在这种情况下，所有必要的设置都由基础镜像完成，因此没有额外的命令要运行。
- en: Common `Dockerfile` commands are `FROM`, `COPY`, `ADD`, `RUN`, `CMD`, `ENTRYPOINT`,
    `ENV`, and `EXPOSE`. For the full `Dockerfile` reference, refer to [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的 `Dockerfile` 命令有 `FROM`, `COPY`, `ADD`, `RUN`, `CMD`, `ENTRYPOINT`, `ENV`,
    和 `EXPOSE`。对于完整的 `Dockerfile` 参考，请参阅 [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)。
- en: 'The `Dockerfile` describes a new container that inherits from a container named
    `duluca/minimal-nginx-web-server`. This is a container that I published on Docker
    Hub, which inherits from the `nginx:alpine` image, which itself inherits from
    the `alpine` image. The `alpine` image is a minimal Linux operating environment
    that is only 5 MB in size. The `alpine` image itself inherits from `scratch`,
    which is an empty image. See the inheritance hierarchy demonstrated in the following
    diagram:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`描述了一个从名为`duluca/minimal-nginx-web-server`的容器继承的新容器。这是一个我在Docker
    Hub上发布的容器，它从`nginx:alpine`镜像继承，该镜像本身又从`alpine`镜像继承。`alpine`镜像是一个最小的Linux操作系统环境，大小仅为5MB。`alpine`镜像本身从`scratch`继承，`scratch`是一个空镜像。请参见以下图表中展示的继承层次结构：'
- en: '![](img/B14094_09_05.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_09_05.png)'
- en: 'Figure 9.5: Docker inheritance'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：Docker继承
- en: 'The `Dockerfile` then copies the contents of the `dist` folder from your development
    environment into the container''s `www` folder, as shown in the following diagram:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`Dockerfile`将开发环境中的`dist`文件夹内容复制到容器的`www`文件夹中，如下所示：
- en: '![](img/B14094_09_06.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_09_06.png)'
- en: 'Figure 9.6: Copying code into a containerized web server'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：将代码复制到容器化的Web服务器中
- en: 'In this case, the parent image is configured with an nginx server to act as
    a web server to serve the content inside the `www` folder. At this point, our
    source code is accessible from the internet but lives inside layers of secure
    environments. Even if our app has a vulnerability of some kind, it would be tough
    for an attacker to harm the systems we are operating on. The following diagram
    demonstrates the layers of security that Docker provides:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，父镜像配置了nginx服务器作为Web服务器来服务`www`文件夹内的内容。此时，我们的源代码可以从互联网上访问，但生活在多层安全环境中。即使我们的应用程序存在某种漏洞，攻击者也很难伤害我们正在运行的系统。以下图表展示了Docker提供的多层安全：
- en: '![](img/B14094_09_07.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_09_07.png)'
- en: 'Figure 9.7: Docker security'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：Docker安全
- en: In summary, at the base layer we have our host OS, such as Windows or macOS,
    that runs the Docker runtime, which will be installed in the next section. The
    Docker runtime is capable of running self-contained Docker images, which are defined
    by the aforementioned `Dockerfile`. `duluca/minimal-nginx-web-server` is based
    on the lightweight Linux operating system, Alpine. Alpine is a completely pared-down
    version of Linux that doesn't come with any GUI, drivers, or even most of the
    sCLI tools you may expect from a Linux system. As a result, the OS is around only
    ~5 MB in size. We then inherit from the nginx image, which installs the web server,
    which itself is around a few megabytes in size. Finally, our custom nginx configuration
    is layered over the default image, resulting in a tiny ~7 MB image. The nginx
    server is configured to serve the contents of the `/var/www` folder. In the `Dockerfile`,
    we merely copy the contents of the `/dist` folder in our development environment
    and place it into the `/var/www` folder. We will later build and execute this
    image, which will run our Nginx web server containing the output of our `dist`
    folder. I have published a similar image named `duluca/minimal-node-web-server`,
    which clocks in at ~15 MB.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在基础层，我们有运行Docker运行时的宿主操作系统，例如Windows或macOS，它将在下一节中安装。Docker运行时能够运行自包含的Docker镜像，这些镜像由上述`Dockerfile`定义。`duluca/minimal-nginx-web-server`基于轻量级的Linux操作系统Alpine。Alpine是Linux的一个完全精简版本，不带任何GUI、驱动程序，甚至没有大多数Linux系统可能期望的sCLI工具。因此，该操作系统的大小仅为约5MB。然后我们从nginx镜像继承，该镜像安装了Web服务器，其自身大小约为几MB。最后，我们的自定义nginx配置覆盖在默认镜像之上，结果是一个小巧的约7MB镜像。nginx服务器配置为服务`/var/www`文件夹的内容。在`Dockerfile`中，我们仅复制开发环境中`/dist`文件夹的内容并将其放置到`/var/www`文件夹中。我们稍后将构建并执行此镜像，该镜像将运行包含我们`dist`文件夹输出的Nginx
    Web服务器。我已经发布了一个类似的镜像，名为`duluca/minimal-node-web-server`，大小约为15MB。
- en: '`duluca/minimal-node-web-server` can be more straightforward to work with,
    especially if you''re not familiar with Nginx. It relies on an `Express.js` server
    to serve static content. Most cloud providers provide concrete examples using
    Node and Express, which can help you narrow down any errors. In addition, `duluca/minimal-node-web-server`
    has HTTPS redirection support baked into it. You can spend a lot of time trying
    to set up a nginx proxy to do the same thing, when all you need to do is set the
    environment variable `ENFORCE_HTTPS` in your `Dockerfile`. See the following sample
    Dockerfile:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`duluca/minimal-node-web-server` 可以更直接地工作，特别是如果你不熟悉 Nginx。它依赖于一个 `Express.js`
    服务器来提供静态内容。大多数云服务提供商都提供了使用 Node 和 Express 的具体示例，这可以帮助你缩小任何错误的范围。此外，`duluca/minimal-node-web-server`
    内置了 HTTPS 重定向支持。你可以花很多时间尝试设置一个 nginx 代理来做同样的事情，而你只需要在 `Dockerfile` 中设置环境变量 `ENFORCE_HTTPS`。请参阅以下示例
    Dockerfile：'
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can read more about the options `minimal-node-web-server` provides at [https://github.com/duluca/minimal-node-web-server](https://github.com/duluca/minimal-node-web-server).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/duluca/minimal-node-web-server](https://github.com/duluca/minimal-node-web-server)
    上了解更多关于 `minimal-node-web-server` 提供的选项。
- en: As we've now seen, the beauty of Docker is that you can navigate to [https://hub.docker.com](https://hub.docker.com),
    search for `duluca/minimal-nginx-web-server` or `duluca/minimal-node-web-server`,
    read its `Dockerfile`, and trace its origins all the way back to the original
    base image that is the foundation of the web server. I encourage you to vet every
    Docker image you use in this manner to understand what exactly it brings to the
    table for your needs. You may find it either overkill, or that it has features
    you never knew about that can make your life a lot easier.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们现在所看到的，Docker 的美妙之处在于你可以导航到 [https://hub.docker.com](https://hub.docker.com)，搜索
    `duluca/minimal-nginx-web-server` 或 `duluca/minimal-node-web-server`，阅读其 `Dockerfile`，并追踪其起源，直到原始的基础镜像，这是网络服务器的基础。我鼓励你以这种方式检查你使用的每个
    Docker 镜像，以了解它为你带来的确切价值。你可能发现它要么是过度设计，要么是具有你从未意识到的功能，这些功能可以使你的生活变得更加容易。
- en: Note that the parent images should pull a specific tag of `duluca/minimal-nginx-web-server`,
    which is `1-alpine`. Similarly, `duluca/minimal-node-web-server` pulls from `lts-alpine`.
    These are evergreen base packages that always contain the latest release of version
    1 of Nginx and Alpine or an LTS release of Node. I have pipelines set up to automatically
    update both images when a new base image is published. So, whenever you pull these
    images, you will get the latest bug fixes and security patches.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，父镜像应该拉取 `duluca/minimal-nginx-web-server` 的特定标签，即 `1-alpine`。同样，`duluca/minimal-node-web-server`
    从 `lts-alpine` 拉取。这些都是常绿的基础包，始终包含 Nginx 和 Alpine 或 Node 的 LTS 版本的最新发布版本。我已经设置了管道，当发布新的基础镜像时，会自动更新这两个镜像。所以，无论何时你拉取这些镜像，你都会得到最新的错误修复和安全补丁。
- en: Having an evergreen dependency tree removes the burden on you as the developer
    to go hunting down the latest available version of a Docker image. Alternatively,
    if you specify a version number, your images will not be subject to any potential
    breaking changes. However, it is better to remember to test your images after
    a new build, than never update your image and potentially deploy compromised software.
    After all, the web is ever-changing and will not slow down for you to keep your
    images up to date.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个常绿依赖树可以减轻你作为开发者寻找最新 Docker 镜像版本的负担。或者，如果你指定了版本号，你的镜像将不会受到任何潜在的重大更改的影响。然而，记住在新构建后测试你的镜像，比永远不更新你的镜像并可能部署受损害的软件要好。毕竟，网络是不断变化的，不会因为你更新镜像而减速。
- en: Just like npm packages, Docker can bring great convenience and value, but you
    must take care to understand the tools you are working with.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 npm 包一样，Docker 可以带来极大的便利和价值，但你必须小心，理解你正在使用的工具。
- en: In *Chapter 13*, *Highly Available Cloud Infrastructure on AWS*, we are going
    to leverage the lower-footprint Docker image based on Nginx, `duluca/minimal-nginx-web-server`.
    If you're comfortable configuring nginx, this is the ideal choice.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 13 章*，*AWS 上的高可用云基础设施* 中，我们将利用基于 Nginx 的低内存占用 Docker 镜像 `duluca/minimal-nginx-web-server`。如果你熟悉配置
    nginx，这是理想的选择。
- en: Installing Docker
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Docker
- en: In order to be able to build and run containers, you must first install the
    Docker execution environment on your computer. Refer back to *Chapter 2*, *Setting
    Up Your Development Environment*, for instructions on installing Docker.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够构建和运行容器，你必须在你的电脑上首先安装 Docker 执行环境。请参考 *第 2 章*，*设置你的开发环境*，了解安装 Docker 的说明。
- en: Setting up npm scripts for Docker
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 npm scripts for Docker
- en: 'Now, let''s configure some Docker scripts for your Angular apps that you can
    use to automate the building, testing, and publishing of your container. I have
    developed a set of scripts called **npm scripts for Docker** that work on Windows
    10 and macOS. You can get the latest version of these scripts and automatically
    configure them in your project by executing the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置一些 Docker 脚本，您可以使用这些脚本来自动化 Angular 应用程序的构建、测试和发布。我开发了一套名为 **npm scripts
    for Docker** 的脚本，这些脚本在 Windows 10 和 macOS 上运行。您可以通过执行以下代码获取这些脚本的最新版本，并在项目中自动配置它们：
- en: Run the following commands on both the **local-weather-app** and **lemon-mart**
    projects now!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 **local-weather-app** 和 **lemon-mart** 项目上运行以下命令！
- en: 'Install the npm scripts for Docker task:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Docker 任务的 npm 脚本：
- en: '[PRE5]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Apply the npm scripts for Docker configuration:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用 Docker 配置的 npm 脚本：
- en: '[PRE6]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After you execute the `mrm` scripts, we're ready to take a deep dive into the
    configuration settings using the Local Weather app as an example.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `mrm` 脚本后，我们就可以使用 Local Weather 应用程序作为示例，深入查看配置设置。
- en: Build and publish an image to Docker Hub
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建并发布镜像到 Docker Hub
- en: 'Next, let''s make sure that your project is configured correctly so we can
    containerize it, build an executable image, and publish it to Docker Hub, thereby
    allowing us to access it from any build environment. We will be using the Local
    Weather app for this section that we last updated in *Chapter 6*, *Forms, Observables,
    and Subjects*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们确保您的项目配置正确，这样我们就可以将其容器化，构建可执行镜像，并将其发布到 Docker Hub，从而允许我们从任何构建环境中访问它。我们将使用我们在
    *第 6 章*，*表单、Observables 和 Subjects* 中最后更新的 Local Weather 应用程序来完成本节：
- en: This section uses the **local-weather-app** repo.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本节使用 **local-weather-app** 仓库。
- en: Sign up for a Docker Hub account on [https://hub.docker.com/](https://hub.docker.com/).
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 [https://hub.docker.com/](https://hub.docker.com/) 上注册 Docker Hub 账户。
- en: Create a public (free) repository for your application.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的应用程序创建一个公共（免费）仓库。
- en: Later in this chapter, we use Google Cloud's container registry as a private
    repository. Additionally, in *Chapter 13*, *Highly Available Cloud Infrastructure
    on AWS*, I cover how to set up a private container repository using **AWS Elastic
    Container Service** (**AWS ECS**).
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们使用 Google Cloud 的容器注册库作为私有仓库。此外，在 *第 13 章*，*AWS 上的高可用云基础设施* 中，我介绍了如何使用
    **AWS Elastic Container Service** （**AWS ECS**）设置私有容器仓库。
- en: 'In `package.json`, add or update the `config` property with the following configuration
    properties:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `package.json` 中，添加或更新 `config` 属性，包含以下配置属性：
- en: '[PRE7]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `namespace` will be your Docker Hub username. You will define what your
    repository will be called during creation. An example image `repository` variable
    should look like `duluca/localcast-weather`. The image name is for easy identification
    of your container while using Docker commands such as `docker ps`. I will just
    call mine `localcast-weather`. The `imagePort` property will define which port
    should be used to expose your application from inside the container. Since we
    use port `5000` for development, pick a different one, like `8080`. The `internalContainerPort`
    defines the port that your web server is mapped to. For Node servers, this will
    mostly be port `3000`, and for Nginx servers, `80`. Refer to the documentation
    of the base container you're using.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`namespace` 将是您的 Docker Hub 用户名。您将在创建时定义您的仓库名称。一个示例的 `repository` 变量应看起来像 `duluca/localcast-weather`。镜像名称用于在使用
    Docker 命令（如 `docker ps`）时轻松识别您的容器。我将我的命名为 `localcast-weather`。`imagePort` 属性将定义应使用哪个端口从容器内部公开您的应用程序。由于我们使用端口
    `5000` 进行开发，请选择不同的端口，例如 `8080`。`internalContainerPort` 定义了您的 Web 服务器映射到的端口。对于
    Node 服务器，这通常是端口 `3000`，而对于 Nginx 服务器，则是 `80`。请参阅您所使用的基容器的文档。'
- en: Let's review the Docker scripts that were added to `package.json` by the `mrm`
    task from earlier. The following snippet is an annotated version of the scripts
    that explains each function.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回顾一下之前由 `mrm` 任务添加到 `package.json` 中的 Docker 脚本。以下是一个注释版本的脚本，解释了每个功能。
- en: Note that with npm scripts, the `pre` and `post` keywords are used to execute
    helper scripts, respectively, before or after the execution of a given script.
    Scripts are intentionally broken into smaller pieces to make it easier to read and
    maintain them.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，使用 npm 脚本时，`pre` 和 `post` 关键字分别用于在执行给定脚本之前或之后执行辅助脚本。脚本被有意拆分成更小的部分，以便更容易阅读和维护。
- en: 'The `build` script is as follows:'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`build` 脚本如下：'
- en: Note that the following `cross-conf-env` command ensures that the script executes
    equally well in macOS, Linux, and Windows environments.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意以下 `cross-conf-env` 命令确保脚本在 macOS、Linux 和 Windows 环境中都能同样良好地执行。
- en: '[PRE8]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`npm run docker:build` will build your Angular application in the `pre` script,
    then build the Docker image using the `docker image build` command, and tag the
    image with a version number in the `post` script:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`npm run docker:build` 将在 `pre` 脚本中构建你的 Angular 应用程序，然后使用 `docker image build`
    命令构建 Docker 镜像，并在 `post` 脚本中使用版本号标记镜像：'
- en: In my project, the `pre` command builds my Angular application in prod mode
    and also runs a test to make sure that I have an optimized build with no failing
    tests.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我的项目中，`pre` 命令以生产模式构建我的 Angular 应用程序，并运行测试以确保我有一个优化后的构建，没有失败的测试。
- en: 'My pre command looks like:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我的预命令看起来像：
- en: '`"predocker:build":` `"npm run build:prod && npm test -- --watch=false"`'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`"predocker:build":` `"npm run build:prod && npm test -- --watch=false"`'
- en: 'The `tag` script is as follows:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`tag` 脚本如下：'
- en: '[PRE9]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`npm run docker:tag` will tag an already built Docker image using the version
    number from the `version` property in `package.json` and the latest tag.'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`npm run docker:tag` 将使用 `package.json` 中 `version` 属性的版本号和最新标签标记已构建的 Docker
    镜像。'
- en: 'The `stop` script is as follows:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`stop` 脚本如下：'
- en: '[PRE10]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`npm run docker:stop` will stop the image if it''s currently running, so the
    `run` script can execute without errors.'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`npm run docker:stop` 如果镜像正在运行，将停止它，这样 `run` 脚本就可以无错误地执行。'
- en: 'The `run` script is as follows:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`run` 脚本如下：'
- en: Note that the `run-s` and `run-p` commands ship with the `npm-run-all` package
    to synchronize or parallelize the execution of npm scripts.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `run-s` 和 `run-p` 命令是 `npm-run-all` 包的一部分，用于同步或并行化 npm 脚本的执行。
- en: '[PRE11]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`npm run docker:run` will stop if the image is already running, and then run
    the newly built version of the image using the `docker run` command. Note that
    the `imagePort` property is used as the external port of the Docker image, which
    is mapped to the internal port of the image that the Node.js server listens to,
    port `3000`.'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`npm run docker:run` 如果镜像已经在运行，将停止它，然后使用 `docker run` 命令运行新构建的镜像版本。注意，`imagePort`
    属性用作 Docker 镜像的外部端口，映射到 Node.js 服务器监听的内部端口 `3000`。'
- en: 'The `publish` script is as follows:'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`publish` 脚本如下：'
- en: '[PRE12]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`npm run docker:publish` will publish a built image to the configured repository,
    in this case, Docker Hub, using the `docker image push` command.'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`npm run docker:publish` 将使用 `docker image push` 命令将构建好的镜像发布到配置的仓库，在这个例子中是
    Docker Hub。'
- en: 'First, the versioned image is published, followed by one tagged with `latest`
    in post. The `taillogs` script is as follows:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，发布带有版本号的镜像，然后是带有 `latest` 标签的镜像。`taillogs` 脚本如下：
- en: '[PRE13]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`npm run docker:taillogs` will display the internal console logs of a running
    Docker instance using the `docker log -f` command, a very useful tool when debugging
    your Docker instance.'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`npm run docker:taillogs` 将使用 `docker log -f` 命令显示正在运行的 Docker 实例的内部控制台日志，这是一个在调试
    Docker 实例时非常有用的工具。'
- en: 'The `open` script is as follows:'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`open` 脚本如下：'
- en: '[PRE14]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`npm run docker:open` will wait for 2 seconds and then launch the browser with
    the correct URL for your application using the `imagePort` property.'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`npm run docker:open` 将等待 2 秒，然后使用 `imagePort` 属性启动浏览器，显示你应用程序的正确 URL。'
- en: 'The `debug` script is as follows:'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`debug` 脚本如下：'
- en: '[PRE15]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`npm run docker:debug` will build your image and run an instance of it in `pre`,
    open the browser, and then start displaying the internal logs of the container.'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`npm run docker:debug` 将构建你的镜像并在 `pre` 阶段运行一个实例，打开浏览器，然后开始显示容器的内部日志。'
- en: 'Customize the pre-build script to build your angular app in production mode
    and execute unit tests before building the image:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义预构建脚本以在生产模式下构建你的 Angular 应用程序，并在构建镜像之前执行单元测试：
- en: '[PRE16]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note that `ng build` is provided with the `--prod` argument, which achieves
    two things: the size of the app is optimized to be significantly smaller with
    **Ahead-of-Time** (**AOT**) compilation to increase runtime performance, and the
    configuration items defined in `src/environments/environment.prod.ts` are used.'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `ng build` 使用了 `--prod` 参数，这实现了两个目的：通过 **Ahead-of-Time** （**AOT**） 编译将应用程序的大小优化得显著更小，从而提高运行时性能，并且使用
    `src/environments/environment.prod.ts` 中定义的配置项。
- en: 'Update `src/environments/environment.prod.ts` to look like you''re using your
    own `appId` from `OpenWeather`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `src/environments/environment.prod.ts` 以看起来你正在使用自己的 `appId` 从 `OpenWeather`：
- en: '[PRE17]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We are modifying how `npm test` is executed, so the tests are run only once
    and the tool stops executing. The `--watch=false` option is provided to achieve
    this behavior, as opposed to the development-friendly default continuous execution
    behavior.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在修改 `npm test` 的执行方式，因此测试只运行一次，工具停止执行。提供 `--watch=false` 选项来实现此行为，而不是开发友好的默认连续执行行为。
- en: Create a new file named `Dockerfile` with no file extensions in the project
    root.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目根目录下创建一个名为 `Dockerfile` 的新文件，不要添加文件扩展名。
- en: 'Implement or replace the contents of the `Dockerfile`, as shown here:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现或替换 `Dockerfile` 的内容，如下所示：
- en: '[PRE18]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Be sure to inspect the contents of your `dist` folder to ensure you're copying
    the correct folder, which contains the `index.html` file at its root.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一定要检查你的 `dist` 文件夹的内容，以确保你正在复制正确的文件夹，该文件夹在其根目录下包含 `index.html` 文件。
- en: Execute `npm run predocker:build` and make sure it runs without errors in the
    Terminal to ensure that your application changes have been successful.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `npm run predocker:build` 并确保它在终端中无错误运行，以确保你的应用程序更改已成功。
- en: Execute `npm run docker:build` and make sure it runs without errors in the Terminal
    to ensure that your image builds successfully.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `npm run docker:build` 并确保它在终端中无错误运行，以确保镜像构建成功。
- en: 'While you can run any of the provided scripts individually, you really only
    need to remember two of them going forward:'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然你可以单独运行提供的任何脚本，但向前看，你实际上只需要记住其中两个：
- en: '`npm run docker:debug` will test, build, tag, run, tail, and launch your containerized
    app in a new browser window for testing.'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm run docker:debug` 将会测试、构建、标记、运行、跟踪并在新浏览器窗口中启动你的容器化应用进行测试。'
- en: '`npm run docker:publish` will publish the image you just built and test to
    the online Docker repository.'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm run docker:publish` 将将你刚刚构建和测试的镜像发布到在线 Docker 仓库。'
- en: 'Execute `docker:debug` in your Terminal:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的终端中执行 `docker:debug`。
- en: '[PRE19]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A successful `docker:debug` run should result in a new in-focus browser window
    with your application and the server logs being tailed in the Terminal, as follows:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 成功的 `docker:debug` 运行应该导致一个新的聚焦浏览器窗口，其中包含你的应用程序和终端中的服务器日志跟踪，如下所示：
- en: '[PRE20]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You should always run `docker ps` to check whether your image is running, when
    it was last updated, and whether it is clashing with any existing images claiming
    the same port.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该始终运行 `docker ps` 来检查你的镜像是否正在运行，它上次更新是什么时候，以及它是否与任何声称相同端口的现有镜像冲突。
- en: 'Execute `docker:publish` in your Terminal:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的终端中执行 `docker:publish`。
- en: '[PRE21]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You should observe a successful run in the Terminal window like this:'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该在终端窗口中观察到一次成功的运行，如下所示：
- en: '[PRE22]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Over time, your local Docker cache may grow to a significant size; for example,
    on my laptop, it's reached roughly 40 GB over two years. You can use the `docker
    image prune` and `docker container prune` commands to reduce the size of your
    cache. For more detailed information, refer to the documentation at [https://docs.docker.com/config/pruning](https://docs.docker.com/config/pruning).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，你的本地 Docker 缓存可能会增长到相当大的大小；例如，在我的笔记本电脑上，两年内已经达到了大约 40 GB。你可以使用 `docker
    image prune` 和 `docker container prune` 命令来减小缓存的大小。有关更详细的信息，请参阅[https://docs.docker.com/config/pruning](https://docs.docker.com/config/pruning)文档。
- en: By defining a `Dockerfile` and scripting our use of it, we created living documentation
    in our code base. We have achieved DevOps and closed the configuration gap.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义 `Dockerfile` 并编写使用它的脚本，我们在代码库中创建了活生生的文档。我们已经实现了 DevOps 并关闭了配置差距。
- en: Make sure to containerize **lemon-mart** in the same way you've done with **local-weather-app**
    and verify your work by executing `npm run docker:debug`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 确保以与 **local-weather-app** 相同的方式将 **lemon-mart** 容器化，并通过执行 `npm run docker:debug`
    验证你的工作。
- en: You may find it confusing to interact with npm scripts in general through the
    CLI. Let's look at VS Code's npm script support next.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现通过 CLI 交互 npm 脚本有些令人困惑。接下来，让我们看看 VS Code 的 npm 脚本支持。
- en: NPM scripts in VS Code
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VS Code 中的 NPM 脚本
- en: 'VS Code provides support for npm scripts out of the box. In order to enable
    npm script explorer, open VS Code settings and ensure that the `"npm.enableScriptExplorer":
    true` property is present. Once you do, you will see an expandable title named
    **NPM SCRIPTS** in the **Explorer** pane, as highlighted with an arrow in the
    following screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 'VS Code 默认提供对 npm 脚本的支持。为了启用 npm 脚本探索器，打开 VS Code 设置并确保存在 `"npm.enableScriptExplorer":
    true` 属性。一旦这样做，你将在 **探索器** 面板中看到一个可展开的标题名为 **NPM SCRIPTS**，如下面的截图所示，箭头已突出显示：'
- en: '![](img/B14094_09_08.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![img/B14094_09_08.png](img/B14094_09_08.png)'
- en: 'Figure 9.8: NPM scripts in VS Code'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8：VS Code 中的 NPM 脚本
- en: You can click on any script to launch the line that contains the script in `package.json`
    or right-click and select **Run** to execute the script.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以单击任何脚本以启动`package.json`中包含脚本的行，或者右键单击并选择**运行**来执行脚本。
- en: Let's look at an easier way to interact with Docker next.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看与Docker交互的一种更简单的方法。
- en: Docker extensions in VS Code
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VS Code中的Docker扩展
- en: 'Another way to interact with Docker images and containers is through VS Code.
    If you have installed the `ms-azuretools.vscode-docker` Docker extension from
    Microsoft, as suggested in *Chapter 2*, *Setting Up Your Development Environment*,
    you can identify the extension by the Docker logo on the left-hand navigation
    menu VS Code, as circled in white in the following screenshot:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与Docker镜像和容器交互的另一种方式是通过VS Code。如果您已按照*第2章*，*设置开发环境*中建议的，安装了来自Microsoft的`ms-azuretools.vscode-docker`
    Docker扩展，您可以通过VS Code左侧导航菜单上的Docker标志识别该扩展，如下面的截图所示，用白色圆圈标出：
- en: '![](img/B14094_09_09.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_09_09.png)'
- en: 'Figure 9.9: Docker extension in VS Code'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：VS Code中的Docker扩展
- en: 'Let''s go through some of the functionality provided by the extension. Refer
    to the preceding screenshot and the numbered steps in the following list for a
    quick explanation:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看扩展提供的功能之一。参考前面的截图和以下列表中的编号步骤，以获得快速解释：
- en: '**Images** contain a list of all the container snapshots that exist on your
    system.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**镜像**包含您系统上所有容器快照的列表。'
- en: Right-clicking on a Docker image brings up a context menu to run various operations
    on it, like **Run**, **Push**, and **Tag****.**
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击Docker镜像会弹出一个上下文菜单，可以运行各种操作，如**运行**、**推送**和**标记****。**
- en: '**Containers** list all executable Docker containers that exist on your system,
    which you can start, stop, or attach to.'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**容器**列出了您系统上所有可执行的Docker容器，您可以启动、停止或附加到它们。'
- en: '**Registries** display the registries that you''re configured to connect to,
    such as Docker Hub or **AWS Elastic Container Registry** (**AWS ECR**).'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**注册表**显示了您配置连接到的注册表，例如Docker Hub或**AWS弹性容器注册表**（**AWS ECR**）。'
- en: While the extension makes it easier to interact with Docker, the **npm scripts
    for Docker** (which you configured using the `mrm` task) automate a lot of the
    chores related to building, tagging, and testing an image. They are both cross-platform
    and will work equally well in a CI environment.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然扩展使与Docker的交互变得更容易，但**Docker的npm脚本**（您使用`mrm`任务配置的）自动化了大量与构建、标记和测试镜像相关的任务。它们都是跨平台的，在CI环境中也能同样良好地工作。
- en: The `npm run docker:debug` script automates a lot of chores to verify that you
    have a good image build!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm run docker:debug`脚本自动化了大量任务，以验证您有一个良好的镜像构建！'
- en: Now let's see how we can deploy our containers to the cloud and later achieve
    CD.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何将我们的容器部署到云，并随后实现持续交付（CD）。
- en: Deploying a Dockerfile to the cloud
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Dockerfile部署到云
- en: One of the advantages of using Docker is that we can deploy it on any number
    of operating environments, from personal PCs to servers and cloud providers. In
    any case, we would expect our container to function the same way. Let's deploy
    the LocalCast Weather app to Google Cloud Run.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker的一个优点是我们可以在任何数量的操作系统环境中部署它，从个人PC到服务器和云提供商。在任何情况下，我们都期望我们的容器以相同的方式运行。让我们将LocalCast天气应用部署到Google
    Cloud Run。
- en: Google Cloud Run
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google Cloud Run
- en: Google Cloud Run allows you to deploy arbitrary Docker containers and execute
    them on the Google Cloud Platform without any onerous overhead. Fully managed
    instances offer some free time; however, there's no free-forever version here.
    Please be mindful of any costs you may incur. Refer to [https://cloud.google.com/run/pricing?hl=en_US%20for%20pricing](https://cloud.google.com/run/pricing?hl=en_US%20for%20pricing).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud Run允许您部署任意Docker容器，并在Google Cloud Platform上执行它们，而无需任何繁重的开销。完全管理的实例提供一些免费时间；然而，这里没有永久免费的版本。请注意您可能产生的任何费用。请参阅[https://cloud.google.com/run/pricing?hl=en_US%20for%20pricing](https://cloud.google.com/run/pricing?hl=en_US%20for%20pricing)。
- en: Refer to *Chapter 2*, *Setting Up Your Development Environment*, for instructions
    on how to install glcoud.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 参考第2章，*设置开发环境*，了解如何安装glcoud。
- en: This section uses the **local-weather-app** repo.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本节使用**local-weather-app**仓库。
- en: 'Let''s configure glcoud so we can deploy a `Dockerfile`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们配置glcoud，以便我们可以部署一个`Dockerfile`：
- en: 'Update your `Dockerfile` to override the `ENTRYPOINT` command:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新您的`Dockerfile`以覆盖`ENTRYPOINT`命令：
- en: '[PRE23]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `ENTRYPOINT` command in `minimal-node-web-server` runs a process called
    `dumb-init` to force the process ID for your Node process to be randomized. However,
    gcloud fails to execute this command, which is why we're overriding it.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`minimal-node-web-server` 中的 `ENTRYPOINT` 命令运行一个名为 `dumb-init` 的进程，以强制你的 Node
    进程的进程 ID 随机化。然而，gcloud 无法执行此命令，这就是我们为什么要覆盖它的原因。'
- en: 'Create a new gcloud project:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 gcloud 项目：
- en: '[PRE24]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Remember to use your own project name!
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记得使用你自己的项目名称！
- en: Navigate to [https://console.cloud.google.com/](https://console.cloud.google.com/
    )
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 [https://console.cloud.google.com/](https://console.cloud.google.com/)
- en: Locate your new project and select the **Billing** option from the sidebar,
    as shown in the following screenshot:![](img/B14094_09_10.png)
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到你的新项目，并从侧边栏中选择**计费**选项，如图下截图所示：![](img/B14094_09_10.png)
- en: 'Figure 9.10: Billing options'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.10：计费选项
- en: Follow the instructions to set up a billing account.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照说明设置计费账户。
- en: If you see it, the Freemium account option will also work. Otherwise, you may
    choose to take advantage of free trial offers. However, it is a good idea to set
    a budget alert to be notified if you get charged over a certain amount per month.
    Find more info at [https://cloud.google.com/billing/docs/how-to/modify-project](https://cloud.google.com/billing/docs/how-to/modify-project).
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你看到它，免费增值账户选项也将有效。否则，你可以选择利用免费试用优惠。然而，设置一个预算警报是个好主意，这样你就可以在每月超过一定金额时收到通知。更多信息请见
    [https://cloud.google.com/billing/docs/how-to/modify-project](https://cloud.google.com/billing/docs/how-to/modify-project)。
- en: 'Create a `.gcloudignore` file and ignore everything but your `Dockerfile` and
    `dist` folder:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `.gcloudignore` 文件，忽略除 `Dockerfile` 和 `dist` 文件夹之外的所有内容：
- en: '[PRE25]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add a new npm script to build your `Dockerfile` in the cloud:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在云端添加一个新的 npm 脚本来构建你的 `Dockerfile`：
- en: '[PRE26]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Remember to use your own project name!
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记得使用你自己的项目名称！
- en: 'Add another npm script to deploy your published container:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个 npm 脚本来部署你发布的容器：
- en: '[PRE27]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that you should provide the region closest to your geographical location
    for the best possible experience.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，你应该提供离你地理位置最近的区域，以获得最佳体验。
- en: 'Build your `Dockerfile` as follows:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式构建你的 `Dockerfile`：
- en: '[PRE28]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Before running this command, remember to build your application for `prod`.
    Whatever you have in your `dist` folder will get deployed.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在运行此命令之前，记得为 `prod` 构建你的应用程序。你 `dist` 文件夹中的任何内容都将被部署。
- en: Note that on the initial run, you will be prompted to answer questions to configure
    your account for initial use. Select your account and project name correctly,
    otherwise, take the default options. The `build` command may fail during the first
    run. Sometimes it takes multiple runs for gcloud to warm up and successfully build
    your container.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在首次运行时，你将需要回答问题以配置你的账户以供初始使用。正确选择你的账户和项目名称，否则，请选择默认选项。`build` 命令在首次运行时可能会失败。有时需要多次运行，gcloud
    才能预热并成功构建你的容器。
- en: 'Once your container is published, deploy it using the following command:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你的容器发布，使用以下命令部署它：
- en: '[PRE29]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A successful deployment will look like the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的部署看起来如下所示：
- en: '![](img/B14094_09_11.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_09_11.png)'
- en: 'Figure 9.11: A successful deployment'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11：成功的部署
- en: Congrats, you've just deployed your container on Google Cloud. You should be
    able to access your app using the URL in the Terminal output.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，你已经在 Google Cloud 上部署了你的容器。你应该能够通过终端输出的 URL 访问你的应用程序。
- en: As always, consider adding CLI commands as npm scripts to your project so that
    you can maintain a living documentation of your scripts. These scripts will also
    allow you to leverage pre and post scripts in npm, allowing you to automate the
    building of your application, your container, and the tagging process. So, the
    next time you need to deploy, you only need to run one command. I encourage the
    reader to seek inspiration from the npm scripts for Docker utility we set up earlier
    to create your own set of scripts for gcloud.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，考虑将 CLI 命令作为 npm 脚本添加到你的项目中，这样你可以维护你脚本的活文档。这些脚本还将允许你利用 npm 中的预脚本和后脚本，从而自动化构建你的应用程序、容器和标记过程。因此，下次你需要部署时，你只需要运行一个命令。我鼓励读者从我们之前设置的
    npm 脚本 Docker 工具中寻找灵感，以创建你自己的 gcloud 脚本集。
- en: For more information and some sample projects, refer to [https://cloud.google.com/run/docs/quickstarts/prebuilt-deploy](https://cloud.google.com/run/docs/quickstarts/prebuilt-deploy)
    and [https://cloud.google.com/run/docs/quickstarts/build-and-deploy](https://cloud.google.com/run/docs/quickstarts/build-and-deploy).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Docker with Cloud Run
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we submitted our `Dockerfile` and `dist` folder to
    gcloud so that it can build our container for us. This is a convenient option
    that avoids some of the additional configuration steps. However, you can still
    leverage your Docker-based workflow to build and publish your container.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s configure Docker with gcloud:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Set your default region:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Configure Docker with the gcloud container registry:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Tag your already built container with a gcloud hostname:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For detailed instructions on how to tag your image, refer to [https://cloud.google.com/container-registry/docs/pushing-and-pulling](https://cloud.google.com/container-registry/docs/pushing-and-pulling).
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Publish your container to gcloud using Docker:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Execute the `deploy` command:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: During initial deployment, this command may appear to be stuck. Try again in
    15 minutes or so.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Follow the onscreen instructions to complete your deployment.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the URL displayed on screen to check that your app has been successfully
    deployed.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding steps demonstrate a deployment technique that is similar to the
    one we leveraged when deploying to AWS ECS in *Chapter 13*, *Highly Available
    Cloud Infrastructure on AWS*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: For more information, refer to [https://cloud.google.com/sdk/gcloud/reference/run/deploy](https://cloud.google.com/sdk/gcloud/reference/run/deploy).
    For the following few sections, we will be switching back to LemonMart.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting Cloud Run
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to troubleshoot your glcoud commands, you may utilize the Google Cloud
    Platform Console at [https://console.cloud.google.com/](https://console.cloud.google.com/).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the Cloud Run menu, you can keep track of the containers you are running.
    If errors occur during your deployment, you may want to check the logs to see
    the messages created by your container. Refer to the following screenshot, which
    shows the logs from my `localcast-weather` deployment:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_09_12.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.12: Cloud Run logs'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about troubleshooting Cloud Run, refer to [https://cloud.google.com/run/docs/troubleshooting](https://cloud.google.com/run/docs/troubleshooting).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have mastered the fundamentals of working with Docker containers
    in your local development environment and pushing them to multiple registries
    and runtime environments in the cloud.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Continuous deployment
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CD is the idea that code changes that successfully pass through your pipeline
    can be automatically deployed to a target environment. Although there are examples
    of continuously deploying to production, most enterprises prefer to target a dev
    environment. A gated approach is adopted to move the changes through the various
    stages of dev, test, staging, and finally production. CircleCI can facilitate
    gated deployment with approval workflows, which is covered later in this section.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: CD是指代码更改成功通过您的管道后可以自动部署到目标环境。尽管有持续部署到生产环境的例子，但大多数企业更喜欢将目标设置为开发环境。采用门控方法将更改通过开发的各个阶段，包括测试、预发布和最终的生产。CircleCI可以通过审批工作流程促进门控部署，这一点将在本节后面介绍。
- en: 'In CircleCI, to deploy your image, we need to implement a `deploy` job. In
    this job, you can deploy to a multitude of targets such as Google Cloud Run, Docker
    Hub, Heroku, Azure, or AWS ECS. Integration with these targets will involve multiple steps.
    At a high level, these steps are as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在CircleCI中，为了部署您的镜像，我们需要实现一个`deploy`作业。在这个作业中，您可以部署到多个目标，例如Google Cloud Run、Docker
    Hub、Heroku、Azure或AWS ECS。与这些目标的集成将涉及多个步骤。从高层次来看，这些步骤如下：
- en: Configure an orb for your target environment, which provides the CLI tools required
    to deploy your software.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的目标环境配置一个orb，它提供了部署您的软件所需的CLI工具。
- en: Store login credentials or access keys specific to the target environment as
    CircleCI environment variables.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将针对目标环境的特定登录凭证或访问密钥存储为CircleCI环境变量。
- en: Build a container in the CI pipeline, if not using a platform-specific `build`
    command. Then use `docker push` to submit the resulting Docker image to the target
    platform's Docker registry.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不是使用特定平台的`build`命令，则在CI管道中构建容器。然后使用`docker push`将生成的Docker镜像提交到目标平台的Docker注册库。
- en: Execute a platform-specific `deploy` command to instruct the target to run the
    Docker image that was just pushed.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行特定平台的`deploy`命令，指示目标运行刚刚推送的Docker镜像。
- en: 'By using a Docker-based workflow, we achieve great amounts of flexibility in
    terms of systems and target environments we can use. The following diagram illustrates
    this point by highlighting the possible permutation of choices that are available
    to us:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用基于Docker的工作流程，我们在系统和目标环境方面实现了极大的灵活性。以下图表通过突出我们可用的可能选择排列来阐述这一点：
- en: '![](img/B14094_09_13.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图9.13](img/B14094_09_13.png)'
- en: 'Figure 9.13: n-to-n deployment'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13：n-to-n部署
- en: As you can see, in a containerized world, the possibilities are limitless. I
    will demonstrate how you can deploy to Google Cloud Run using containers and CI
    later in this chapter. Outside of Docker-based workflows, you can use purpose-built
    CLI tools to quickly deploy your app. Next, let's see how you can deploy your
    app to Vercel Now using CircleCI.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在容器化的世界中，可能性是无限的。我将在本章后面演示如何使用容器和CI将应用程序部署到Google Cloud Run。在基于Docker的工作流程之外，您可以使用专门构建的CLI工具快速部署您的应用程序。接下来，让我们看看如何使用CircleCI将应用程序部署到Vercel
    Now。
- en: Deploying to Vercel Now using CircleCI
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CircleCI将应用程序部署到Vercel Now
- en: In *Chapter 4*, *Automated Testing, CI, and Release to Production*, we configured
    the LocalCast Weather app to build using CircleCI. We can enhance our CI pipeline
    to take the build output and optionally deploy it to Vercel Now.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在**第4章**，“自动化测试、CI和发布到生产”中，我们配置了LocalCast Weather应用程序使用CircleCI进行构建。我们可以增强我们的CI管道，以使用构建输出，并可选择将其部署到Vercel
    Now。
- en: Note that ZEIT Now has rebranded to Vercel Now in 2020.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，ZEIT Now在2020年更名为Vercel Now。
- en: This section uses the **local-weather-app** repo. The `config.yml` file for
    this section is named `.circleci/config.ch9.yml`. You can also find a pull request
    that executes the `.yml` file from this chapter on CircleCI at [https://github.com/duluca/local-weather-app/pull/50](https://github.com/duluca/local-weather-app/pull/50)
    using the `branch deploy_Vercelnow`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 本节使用**local-weather-app**仓库。本节的`config.yml`文件命名为`.circleci/config.ch9.yml`。您还可以在[https://github.com/duluca/local-weather-app/pull/50](https://github.com/duluca/local-weather-app/pull/50)找到执行本章中`.yml`文件的拉取请求，使用`branch
    deploy_Vercelnow`。
- en: Note that this branch has a modified configuration in `config.yml` and `Dockerfile`
    to use the `projects/ch6` code from **local-weather-app**.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个分支在`config.yml`和`Dockerfile`中有一个修改过的配置，以使用来自**local-weather-app**的`projects/ch6`代码。
- en: 'Let''s update the `config.yml` file to add a new job named `deploy`. In the
    upcoming Workflows section, we will use this job to deploy a pipeline when approved:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`config.yml`文件，添加一个名为`deploy`的新作业。在即将到来的工作流程部分，我们将使用此作业在批准时部署管道：
- en: Create a token from your Vercel Now account.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的Vercel Now账户创建一个令牌。
- en: Add an environment variable to your CircleCI project named `NOW_TOKEN` and store
    your Vercel Now token as the value.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 CircleCI 项目中添加一个名为 `NOW_TOKEN` 的环境变量，并将您的 Vercel Now 令牌作为其值存储。
- en: 'In `config.yml`, update the `build` job with the new steps and add a new job
    named `deploy`:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `config.yml` 中，更新 `build` 作业的新步骤，并添加一个名为 `deploy` 的新作业：
- en: '[PRE35]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the `build` job, after the build is complete, we add two new steps. First,
    we move the compiled app that's in the `dist` folder to a workspace and persist
    that workspace so we can use it later in another job. In a new job, named `deploy`,
    we attach the workspace and use npx to run the `now` command to deploy the `dist`
    folder. This is a straightforward process.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `build` 作业中，构建完成后，我们添加两个新步骤。首先，我们将位于 `dist` 文件夹中的编译后的应用程序移动到工作区，并持久化该工作区，以便我们可以在另一个作业中使用它。在名为
    `deploy` 的新作业中，我们附加工作区并使用 npx 运行 `now` 命令来部署 `dist` 文件夹。这是一个简单的过程。
- en: Note that `$NOW_TOKEN` is the environment variable we stored on the CircleCI
    project.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `$NOW_TOKEN` 是我们在 CircleCI 项目中存储的环境变量。
- en: 'Implement a simple CircleCI workflow to continuously deploy the outcome of
    your `build` job:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个简单的 CircleCI 工作流程，以持续部署 `build` 作业的结果：
- en: '[PRE36]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that the `deploy` job waits for the `build` job to complete before it can
    execute.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`deploy` 作业在执行之前会等待 `build` 作业完成。
- en: 'Ensure that your CI pipeline executed successfully by inspecting the test results:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查测试结果来确保您的 CI 管道成功执行：
- en: '![](img/B14094_09_14.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_09_14.png)'
- en: 'Figure 9.14: Successful Vercel Now deployment of local-weather-app on the deploy_Vercelnow
    branch'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14：在 deploy_Vercelnow 分支上成功部署 local-weather-app 的 Vercel Now
- en: Most CLI commands for cloud providers need to be installed in your pipeline
    to function. Since Vercel Now has an npm package, this is easy to do. CLI tools
    for AWS, Google Cloud, or Microsoft Azure need to be installed using tools such
    as `brew` or `choco`. Doing this manually in a CI environment is tedious. Next,
    we will cover orbs, which helps to solve the problem.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数云服务提供商的 CLI 命令都需要安装到您的管道中才能正常工作。由于 Vercel Now 有 npm 包，这很容易做到。AWS、Google Cloud
    或 Microsoft Azure 的 CLI 工具需要使用 `brew` 或 `choco` 等工具安装。在 CI 环境中手动执行此操作很繁琐。接下来，我们将介绍
    orbs，它有助于解决这个问题。
- en: Deploying to GCloud using orbs
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 orbs 将应用程序部署到 GCloud
- en: Orbs contain a set of configuration elements to encapsulate shareable behavior
    between CircleCI projects. CircleCI provides orbs that are developed by the maintainers
    of CLI tools. These orbs make it easy for you to add a CLI tool to your pipeline
    without having to set it up manually, with minimal configuration.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Orbs 包含一组配置元素，用于封装 CircleCI 项目之间的可共享行为。CircleCI 提供由 CLI 工具维护者开发的 orbs。这些 orbs
    使您能够轻松地将 CLI 工具添加到您的管道中，而无需手动设置，配置简单。
- en: To work with orbs, your `config.yml` version number must be set to `2.1` and,
    in your CircleCI security settings, you must select the option to allow uncertified
    orbs.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 orbs，您的 `config.yml` 版本号必须设置为 `2.1`，并且在您的 CircleCI 安全设置中，您必须选择允许未认证 orbs
    的选项。
- en: 'The following are some orbs that you can use in your projects:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些您可以在项目中使用的 orbs：
- en: '`circleci/aws-cli` and `circleci/aws-ecr` provide you with the AWS CLI tool
    and help you to interact with **AWS Elastic Container Service** (**AWS ECS**),
    performing tasks such as deploying your containers to AWS ECR.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`circleci/aws-cli` 和 `circleci/aws-ecr` 为您提供 AWS CLI 工具，并帮助您与 **AWS 弹性容器服务**（**AWS
    ECS**）交互，执行诸如将容器部署到 AWS ECR 等任务。'
- en: '`circleci/aws-ecs` streamlines your CircleCI config to deploy your containers
    to AWS ECS.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`circleci/aws-ecs` 简化了您的 CircleCI 配置，以便将容器部署到 AWS ECS。'
- en: '`circleci/gcp-cli` and `circleci/gcp-gcr` provide you with the GCloud CLI tool
    and access to **Google Container Registry** (**GCR**).'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`circleci/gcp-cli` 和 `circleci/gcp-gcr` 为您提供 GCloud CLI 工具和访问 **Google 容器注册库**（**GCR**）的权限。'
- en: '`circleci/gcp-cloud-run` streamlines your CircleCI config to deploy your containers
    to Cloud Run.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`circleci/gcp-cloud-run` 简化了您的 CircleCI 配置，以便将容器部署到 Cloud Run。'
- en: '`circleci/azure-cli` and `circleci/azure-acr` provide you with the Azure CLI
    tools and access to **Azure Container Registry** (**ACR**).'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`circleci/azure-cli` 和 `circleci/azure-acr` 为您提供 Azure CLI 工具和访问 **Azure 容器注册库**（**ACR**）的权限。'
- en: Check out the Orb registry for more information on how to use these orbs at
    [https://circleci.com/orbs/registry](https://circleci.com/orbs/registry).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 Orb 注册表以获取有关如何使用这些 orbs 的更多信息：[https://circleci.com/orbs/registry](https://circleci.com/orbs/registry)。
- en: Now, let's configure the `circleci/gcp-cloud-run` orb with the Local Weather
    app so we can continuously deploy our app to GCloud, without having to manually
    install and configure the gcloud CLI tool on our CI server.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置`circleci/gcp-cloud-run` orb与Local Weather应用，这样我们就可以持续将我们的应用部署到GCloud，而无需在CI服务器上手动安装和配置gcloud
    CLI工具。
- en: On the **local-weather-app** repo, you can find a pull request that executes
    the Cloud Run configuration from this step on CircleCI, at [https://github.com/duluca/local-weather-app/pull/51](https://github.com/duluca/local-weather-app/pull/51),
    using the `deploy_cloudrun` branch.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在**local-weather-app**仓库中，你可以找到一个从这一步开始在CircleCI上执行Cloud Run配置的pull request，链接为[https://github.com/duluca/local-weather-app/pull/51](https://github.com/duluca/local-weather-app/pull/51)，使用的是`deploy_cloudrun`分支。
- en: Note that this branch has a modified configuration in `config.yml` and `Dockerfile`
    to use the `projects/ch6` code from **local-weather-app**.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个分支在`config.yml`和`Dockerfile`中有修改过的配置，以使用**local-weather-app**中的`projects/ch6`代码。
- en: 'First, configure your CircleCI and GCloud accounts so you can deploy from a
    CI server. This is markedly different from deploying from your development machine,
    because the gcloud CLI tools automatically set up the necessary authentication
    configuration for you. Here, you will have to do this manually:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，配置你的CircleCI和GCloud账户，以便你可以从CI服务器部署。这与从你的开发机器部署明显不同，因为gcloud CLI工具会自动为你设置必要的认证配置。在这里，你必须手动完成：
- en: In your CircleCI account settings, under the security section, ensure you allow
    execution of uncertified/unsigned orbs.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的CircleCI账户设置中，在安全部分确保你允许执行未经认证/未签名的orb。
- en: In the CircleCI project settings, add an environment variable named `GOOGLE_PROJECT_ID`.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在CircleCI项目设置中，添加一个名为`GOOGLE_PROJECT_ID`的环境变量。
- en: If you used the same project ID as I did, this should be `localcast-weather`.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你和我使用的是相同的项目ID，那么这个应该是`localcast-weather`。
- en: Create a GCloud service account key for your project's existing service account.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的项目现有的服务账户创建一个GCloud服务账户密钥。
- en: Creating a service account key will result in a JSON file. Do not check this
    file into your code repository. Do not share the contents of it over insecure
    communication channels such as email or SMS. Exposing the contents of this file
    means that any third party can access your GCloud resources permitted by the key
    permissions.
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建服务账户密钥将生成一个JSON文件。不要将此文件提交到你的代码仓库。不要通过不安全的通信渠道（如电子邮件或短信）共享其内容。泄露此文件的内容意味着任何第三方都可以通过密钥权限访问你的GCloud资源。
- en: Copy the contents of the JSON file to a CircleCI environment variable named
    `GCLOUD_SERVICE_KEY`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将JSON文件的内容复制到CircleCI环境变量`GCLOUD_SERVICE_KEY`中。
- en: Add another environment variable named `GOOGLE_COMPUTE_ZONE` and set it to your
    preferred zone.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个名为`GOOGLE_COMPUTE_ZONE`的环境变量，并将其设置为你的首选区域。
- en: I used `us-east1`.
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我使用了`us-east1`。
- en: 'Update your `config.yml` file to add an orb named `circleci/gcp-cloud-run`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新你的`config.yml`文件，添加一个名为`circleci/gcp-cloud-run`的orb：
- en: '[PRE37]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, implement a new job named `deploy_cloudrun`, leveraging orb features
    to initialize, build, deploy, and test our deployment:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实现一个名为`deploy_cloudrun`的新作业，利用orb功能来初始化、构建、部署和测试我们的部署：
- en: '[PRE38]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We first load the `dist` folder from the `build` job. We then run `cloudrun/init`,
    so that the CLI tool can be initialized. With `cloudrun/build`, we build the `Dockerfile`
    at the root of our project, which automatically stores the result of our build
    in GCR. Then, `cloudrun/deploy` deploys the image we just built, taking our code
    live. In the last command, using the `curl` tool, we retrieve the `index.html`
    file of our website and check to see that it's properly deployed by searching
    for the LocalCast Weather string.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先从`build`作业中加载`dist`文件夹。然后运行`cloudrun/init`，以便初始化CLI工具。使用`cloudrun/build`，我们构建项目根目录下的`Dockerfile`，构建结果自动存储在GCR中。然后，`cloudrun/deploy`部署我们刚刚构建的镜像，使我们的代码上线。在最后一个命令中，使用`curl`工具检索我们网站的`index.html`文件，并检查它是否已正确部署，通过搜索LocalCast
    Weather字符串来验证。
- en: 'Update your workflow to continuously deploy to gcloud:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新你的工作流程以持续部署到gcloud：
- en: '[PRE39]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that you can have multiple `deploy` jobs that simultaneously deploy to
    multiple targets.
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，你可以有多个同时部署到多个目标的`deploy`作业。
- en: 'Ensure that your CI pipeline executed successfully by inspecting the test results:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查测试结果来确保你的CI管道执行成功：
- en: '![](img/B14094_09_15.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_09_15.png)'
- en: 'Figure 9.15: Successful gcloud deployment of local-weather-app on the deploy_cloudrun
    branch'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15：在deploy_cloudrun分支上成功部署local-weather-app到gcloud
- en: CD works great for development and testing environments. However, it is usually
    desirable to have gated deployments, where a person must approve a deployment
    before it reaches a production environment. Next, let's see how you can implement
    this with CircleCI.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: CD 对于开发和测试环境来说效果很好。然而，通常希望有门控部署，即在部署到达生产环境之前，必须有人批准。接下来，让我们看看如何使用 CircleCI 实现这一点。
- en: Gated CI workflows
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 门控 CI 工作流程
- en: 'In CircleCI, you can define a workflow to control how and when your jobs are
    executed. Consider the following configuration, given the jobs `build` and `deploy`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CircleCI 中，您可以定义一个工作流程来控制作业的执行方式和时间。考虑以下配置，给定作业 `build` 和 `deploy`：
- en: '[PRE40]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'First, the `build` job gets executed. Then, we introduce a special job named
    `hold` with type `approval`, which requires the `build` job to be successfully
    completed. Once this happens, the pipeline is put on hold. If or when a decision-maker
    approves the `hold`, then the `deploy` step can execute. Refer to the following
    screenshot to see what a `hold` looks like:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，执行 `build` 作业。然后，我们引入一个名为 `hold` 的特殊作业，其类型为 `approval`，它要求 `build` 作业成功完成。一旦发生这种情况，管道就会被暂停。如果或当决策者批准了
    `hold`，则 `deploy` 步骤可以执行。参考以下截图以查看 `hold` 的外观：
- en: '![](img/B14094_09_16.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_09_16.png)'
- en: 'Figure 9.16: A hold in the pipeline'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.16：管道中的暂停
- en: '[PRE41]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this case, the `build` and `test` jobs are executed in parallel. If we're
    on a branch, this is where the pipeline stops. Once the branch is merged with
    `master`, then the pipeline is put on hold and a decision-maker has the option
    to deploy a particular build or not. This type of branch filtering ensures that
    only code that's been merged to `master` can be deployed, which is in line with
    GitHub flow.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`build` 和 `test` 作业是并行执行的。如果我们在一个分支上，这就是管道停止的地方。一旦分支与 `master` 合并，管道就会被暂停，决策者有选择部署特定构建或不部署的选项。这种分支过滤类型确保只有合并到
    `master` 的代码才能部署，这与 GitHub 流相一致。
- en: Next, we dive deeper into how you can customize Docker to fit your workflow
    and environments.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入了解如何自定义 Docker 以适应您的流程和环境。
- en: Advanced continuous integration
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级持续集成
- en: In *Chapter 4*, *Automated Testing, CI, and Release to Production*, we covered
    a basic CircleCI pipeline leveraging default features. Beyond the basic automation
    of unit test execution, one of the other goals of CI is to enable a consistent
    and repeatable environment to build, test, and generate deployable artifacts of
    your application with every code push. Before pushing some code, a developer should
    have a reasonable expectation that their build will pass; therefore, creating
    a reliable CI environment that automates commands that developers can also run
    in their local machines is paramount. To achieve this goal, we will build a custom
    build pipeline that can run on any OS without configuration or any variation in
    behavior.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 4 章*，*自动化测试、持续集成和发布到生产* 中，我们介绍了利用默认功能的基本 CircleCI 工作流程。除了单元测试执行的基本自动化之外，CI
    的另一个目标是通过每次代码推送都构建、测试和生成应用程序的可部署工件，以实现一致和可重复的环境。在推送一些代码之前，开发者应该对构建通过有一个合理的预期；因此，创建一个可靠的
    CI 环境至关重要，该环境可以自动化开发者也可以在本地机器上运行的命令。为了实现这一目标，我们将构建一个自定义的构建管道，该管道可以在任何操作系统上运行，无需配置或任何行为变化。
- en: This section uses the **lemon-mart** repo. Ensure that your project has been
    properly configured by executing `npm run docker:debug` as described earlier in
    the chapter.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 本节使用 **lemon-mart** 仓库。请确保您的项目已按本章前面所述正确配置，通过执行 `npm run docker:debug`。
- en: Containerizing build environments
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器化构建环境
- en: In order to ensure a consistent build environment across various OS platforms,
    developer machines, and CI environments, you may containerize your build environment.
    Note that there are at least half a dozen common CI tools currently in use. Learning
    the ins and outs of every tool is an almost impossible task to achieve.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保在各种操作系统平台、开发机器和 CI 环境之间保持一致的构建环境，您可能需要将您的构建环境容器化。请注意，目前至少有六种常见的 CI 工具正在使用中。学习每个工具的细节几乎是一项几乎不可能完成的任务。
- en: Containerization of your build environment is an advanced concept that goes
    above and beyond what is currently expected of CI tools. However, containerization
    is a great way to standardize over 90% of your build infrastructure and can be
    executed in almost any CI environment. With this approach, the skills you learn
    and the build configuration you create become far more valuable, because both
    your knowledge and the tools you create become transferable and reusable.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 将构建环境容器化是一个高级概念，它超越了当前 CI 工具所期望的功能。然而，容器化是一种很好的方法，可以标准化超过 90% 的构建基础设施，并且可以在几乎任何
    CI 环境中执行。采用这种方法，你学到的技能和创建的构建配置将更有价值，因为你的知识和你创建的工具都变得可转移和可重复使用。
- en: There are many strategies to containerize your build environment with different
    levels of granularity and performance expectations. For the purpose of this book,
    we will focus on reusability and ease of use. Instead of creating a complicated,
    interdependent set of Docker images that may allow for more efficient fail-first
    and recovery paths, we will focus on a single and straightforward workflow. Newer
    versions of Docker have a great feature called multi-stage builds, which allow
    you to define a multi-image process in an easy-to-read manner and maintain a singular
    `Dockerfile`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多策略可以将构建环境容器化，具有不同粒度和性能期望。为了本书的目的，我们将关注可重用性和易用性。我们不会创建一个复杂且相互依赖的 Docker 镜像集，这可能允许更高效的失败和恢复路径，而是将重点放在一个简单直接的流程上。Docker
    的新版本有一个名为多阶段构建的出色功能，它允许你以易于阅读的方式定义多镜像过程，并维护一个单一的 `Dockerfile`。
- en: At the end of the process, you can extract an optimized container image as our
    deliverable artifact, shedding the complexity of the images used previously in
    the process.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程结束时，你可以提取一个优化的容器镜像作为我们的交付物，从而简化了之前过程中使用的镜像的复杂性。
- en: 'As a reminder, your single `Dockerfile` would look like the following sample:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，你的单个 `Dockerfile` 可能看起来像以下示例：
- en: '[PRE43]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Multi-stage Dockerfiles
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多阶段 Dockerfile
- en: 'Multi-stage builds work by using multiple `FROM` statements in a single `Dockerfile`,
    where each stage can perform a task and make any resources within its instance
    available to other stages. In a build environment, we can implement various build-related
    tasks as their own stages, and then copy the end result, such as the `dist` folder
    of an Angular build, to the final image, which contains a web server. In this
    case, we will implement three stages of images:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段构建通过在单个 `Dockerfile` 中使用多个 `FROM` 语句来实现，其中每个阶段都可以执行一个任务，并将其实例内的任何资源提供给其他阶段。在构建环境中，我们可以将各种与构建相关的任务作为它们自己的阶段来实现，然后将最终结果，如
    Angular 构建的 `dist` 文件夹，复制到包含 Web 服务器的最终镜像中。在这种情况下，我们将实现三个阶段的镜像：
- en: '**Builder**: Used to build a production version of your Angular app'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建器**：用于构建你的 Angular 应用的生产版本'
- en: '**Tester**: Used to run unit and e2e tests against headless Chrome instances'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试器**：用于对无头 Chrome 实例运行单元和端到端测试'
- en: '**Web server**: The final result containing only the optimized production bits'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web 服务器**：仅包含优化后的生产代码的最终结果'
- en: Multi-stage builds require Docker version 17.05 or higher. To read more about
    multi-stage builds, read the documentation at [https://docs.docker.com/develop/develop-images/multistage-build](https://docs.docker.com/develop/develop-images/multistage-build).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段构建需要 Docker 版本 17.05 或更高。要了解更多关于多阶段构建的信息，请阅读[https://docs.docker.com/develop/develop-images/multistage-build](https://docs.docker.com/develop/develop-images/multistage-build)上的文档。
- en: 'As the following diagram shows, the builder will build the application and
    the tester will execute the tests:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图所示，构建器将构建应用程序，测试器将执行测试：
- en: '![](img/B14094_09_17.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_09_17.png)'
- en: 'Figure 9.17: Multi-stage Dockerfile'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.17：多阶段 Dockerfile
- en: The final image will be built using the outcome of the builder step.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 最终镜像将使用构建步骤的结果来构建。
- en: Start by creating a new file to implement the multi-stage configuration, named
    `integration.Dockerfile`, at the root of your project.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在项目的根目录下创建一个新文件来实现多阶段配置，命名为 `integration.Dockerfile`。
- en: Builder
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建器
- en: The first stage is `builder`. We need a lightweight build environment that can
    ensure consistent builds across the board. For this purpose, I've created a sample
    Alpine-based Node build environment complete with the npm, bash, and Git tools.
    This minimal container is called `duluca/minimal-node-build-env`, which is based
    on node-alpine and can be found on Docker Hub at [https://hub.docker.com/r/duluca/minimal-node-build-env](https://hub.docker.com/r/duluca/minimal-node-build-env).
    This image is about 10 times smaller than node.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个阶段是 `builder`。我们需要一个轻量级的构建环境，以确保跨所有方面的构建一致性。为此，我创建了一个基于 Alpine 的 Node 构建环境，其中包括
    npm、bash 和 Git 工具。这个最小容器被称为 `duluca/minimal-node-build-env`，基于 node-alpine，可以在
    Docker Hub 上找到 [https://hub.docker.com/r/duluca/minimal-node-build-env](https://hub.docker.com/r/duluca/minimal-node-build-env)。这个镜像比
    node 小大约 10 倍。
- en: The size of Docker images has a real impact on build times, since the CI server
    or your team members will spend extra time pulling a larger image. Choose the
    environment that best fits your needs.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像的大小对构建时间有实际影响，因为 CI 服务器或您的团队成员将花费额外的时间来拉取更大的镜像。请选择最适合您需求的 环境。
- en: 'Let''s create a builder using a suitable base image:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用合适的基镜像创建一个构建器：
- en: 'Ensure that you have the `build:prod` command in place in `package.json`:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在 `package.json` 中有 `build:prod` 命令：
- en: '[PRE44]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Inherit from a Node.js-based build environment, such as `node:lts-alpine` or
    `duluca/minimal-node-build-env:lts-alpine`.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继承自基于 Node.js 的构建环境，例如 `node:lts-alpine` 或 `duluca/minimal-node-build-env:lts-alpine`。
- en: 'Implement your environment-specific build script in a new `Dockerfile`, named
    `integration.Dockerfile`, as shown:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的 `Dockerfile` 中实现特定环境的构建脚本，命名为 `integration.Dockerfile`，如下所示：
- en: '[PRE45]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: CI environments will check out your source code from GitHub and place it in
    the current directory. So, copying the source code from the **current working
    directory** (**CWD**) using the dot notation should work, as it does in your local
    development environment. If you run into issues, refer to your CI provider's documentation.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: CI 环境将从 GitHub 检出您的源代码并将其放置在当前目录中。因此，使用点符号从 **当前工作目录**（**CWD**）复制源代码应该可以工作，就像在您的本地开发环境中一样。如果您遇到问题，请参考您的
    CI 提供商的文档。
- en: Next, let's see how you can debug your Docker build.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看您如何调试您的 Docker 构建。
- en: Debugging build environments
  id: totrans-358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调试构建环境
- en: Depending on your particular needs, your initial setup of the builder portion
    of the Dockerfile may be frustrating. To test out new commands or debug errors,
    you may need to directly interact with the build environment.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的特定需求，您对 Dockerfile 中构建器部分的初始设置可能很令人沮丧。为了测试新命令或调试错误，您可能需要直接与构建环境交互。
- en: 'To interactively experiment and/or debug within the build environment, execute
    the following command:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 要在构建环境中交互式实验和/或调试，请执行以下命令：
- en: '[PRE46]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can test or debug commands within this temporary environment before baking
    them into your `Dockerfile`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在将它们烘焙到 `Dockerfile` 之前，在这个临时环境中测试或调试命令。
- en: Tester
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tester
- en: The second stage is `tester`. By default, the Angular CLI generates a testing
    requirement that is geared toward a development environment. This will not work
    in a CI environment; we must configure Angular to work against a headless browser
    that can execute without the assistance of a GPU and, furthermore, a containerized
    environment to execute the tests against.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个阶段是 `tester`。默认情况下，Angular CLI 生成的测试需求是针对开发环境的。这在 CI 环境中不起作用；我们必须配置 Angular
    以针对无头浏览器运行，该浏览器可以在没有 GPU 辅助的情况下执行，并且还需要一个容器化环境来执行测试。
- en: Angular testing tools are covered in *Chapter 4*, *Automated Testing, CI, and
    Release to Production*.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 测试工具在 *第 4 章*，*自动化测试、CI 和发布到生产* 中有所介绍。
- en: Conﬁguring a headless browser for Angular
  id: totrans-366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为 Angular 配置无头浏览器
- en: 'The protractor testing tool officially supports running against Chrome in headless
    mode. In order to execute Angular tests in a CI environment, you will need to
    configure your test runner, Karma, to run with a headless Chrome instance:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor 测试工具官方支持在无头模式下运行 Chrome。为了在 CI 环境中执行 Angular 测试，您需要配置测试运行器 Karma，使其与无头
    Chrome 实例一起运行：
- en: 'Update `karma.conf.js` to include a new headless browser option:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `karma.conf.js` 以包括新的无头浏览器选项：
- en: '[PRE47]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `ChromiumNoSandbox` custom launcher encapsulates all the configuration elements
    needed for a good default setup.
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ChromiumNoSandbox` 自定义启动器封装了良好默认设置所需的所有配置元素。'
- en: 'Update the `protractor` configuration to run in headless mode:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `protractor` 配置以在无头模式下运行：
- en: '[PRE48]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In order to test your application for responsive scenarios, you can use the
    `--window-size` option, as shown earlier, to change the browser settings.
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了测试你的应用程序在响应式场景下的表现，你可以使用前面提到的`--window-size`选项来更改浏览器设置。
- en: 'Update the `package.json` scripts to select the new browser option in the production
    build scenarios:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`package.json`中的脚本，以在生产构建场景中选择新的浏览器选项：
- en: '[PRE49]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note that `test:prod` doesn't include `npm run e2e`. e2e tests are integration
    tests that take longer to execute, so think twice about including them as part
    of your critical build pipeline. e2e tests will not run on the lightweight testing
    environment mentioned in the next section, as they require more resources and
    time to execute.
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`test:prod`不包括`npm run e2e`。e2e测试是执行时间较长的集成测试，所以在将它们作为关键构建流程的一部分时要三思。e2e测试不会在下一节中提到的轻量级测试环境中运行，因为它们需要更多的资源和时间来执行。
- en: Now, let's define the containerized testing environment.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义容器化的测试环境。
- en: Conﬁguring our testing environment
  id: totrans-378
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置我们的测试环境
- en: 'For a lightweight testing environment, we will be leveraging an Alpine-based
    installation of the Chromium browser:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个轻量级的测试环境，我们将利用基于Alpine的Chromium浏览器安装：
- en: Inherit from `duluca/minimal-node-chromium:lts-alpine`.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继承自`duluca/minimal-node-chromium:lts-alpine`。
- en: 'Append the following configuration to `integration.Dockerfile`:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下配置追加到`integration.Dockerfile`中：
- en: '[PRE50]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The preceding script will copy the production build from the `builder` stage
    and execute your test scripts in a predictable manner.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的脚本将从`builder`阶段复制生产构建，并以可预测的方式执行你的测试脚本。
- en: Web server
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Web服务器
- en: 'The third and final stage generates the container that will be your web server.
    Once this stage is complete, the prior stages will be discarded, and the end result
    will be an optimized sub-10 MB container:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个也是最后一个阶段生成将成为你的Web服务器的容器。一旦这个阶段完成，前面的阶段将被丢弃，最终结果将是一个优化后的小于10 MB的容器：
- en: 'Append the following `FROM` statement at the end of the file to build the web
    server, but this time, `COPY` the production-ready code from `builder`, as shown
    in the following code snippet:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件末尾追加以下`FROM`语句来构建Web服务器，但这次，从`builder`复制生产就绪代码，如下代码片段所示：
- en: '[PRE51]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Build and test your multi-stage `Dockerfile`:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建和测试你的多阶段`Dockerfile`：
- en: '[PRE52]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Depending on your operating system, you may see Terminal errors. So long as
    the Docker image successfully builds in the end, then you can safely ignore these
    errors. For reference purposes, when we later build this image on CircleCI, no
    errors are logged on the CI server.
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据你的操作系统，你可能会看到终端错误。只要Docker镜像最终成功构建，你就可以安全地忽略这些错误。为了参考，当我们稍后在CircleCI上构建此镜像时，CI服务器上没有记录任何错误。
- en: 'Save your script as a new npm script named `build:integration`, as shown:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的脚本保存为一个新的npm脚本，命名为`build:integration`，如下所示：
- en: '[PRE53]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Great work! You''ve defined a custom build and test environment. Let''s visualize
    the end result of our efforts as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 伟大的工作！你已经定义了一个自定义的构建和测试环境。让我们如下可视化我们的努力结果：
- en: '![](img/B14094_09_18.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_09_18.png)'
- en: 'Figure 9.18: Multi-stage build environment results'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18：多阶段构建环境结果
- en: By leveraging a multi-stage `Dockerfile`, we can define a customized build environment,
    and only ship the necessary bytes at the end of the process. In the preceding
    example, we are avoiding shipping 250+ MB of development dependencies to our production
    server and only delivering a 7 MB container that has a minimal memory footprint.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用多阶段`Dockerfile`，我们可以定义一个定制的构建环境，并在过程结束时只传输必要的字节。在先前的例子中，我们避免了将250+ MB的开发依赖项传输到我们的生产服务器，并且只交付了一个7
    MB的容器，它具有最小的内存占用。
- en: Now, let's execute this containerized pipeline on CircleCI.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在CircleCI上执行这个容器化流水线。
- en: CircleCI container-in-container
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CircleCI容器内容器
- en: In *Chapter 4*, *Automated Testing, CI, and Release to Production*, we created
    a relatively simple CircleCI file. Later on, we will repeat the same configuration
    for this project as well, but for now, we will be using a container-within-a-container
    setup leveraging the multi-stage `Dockerfile` we just created.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4章*，*自动化测试、持续集成和发布到生产*中，我们创建了一个相对简单的CircleCI文件。稍后，我们也将为这个项目重复相同的配置，但现在，我们将使用一个容器内的容器设置，利用我们刚刚创建的多阶段`Dockerfile`。
- en: On the **lemon-mart** repo, the `config.yml` file for this section is named
    `.circleci/config.docker-integration.yml`. You can also find a pull request that
    executes the `.yml` file from this chapter on CircleCI at [https://github.com/duluca/lemon-mart/pull/25](https://github.com/duluca/lemon-mart/pull/25)
    using the `docker-integration` branch.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Note that this build uses a modified `integration.Dockerfile` to use the `projects/ch8`
    code from **lemon-mart**.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'In your source code, create a folder named `.circleci` and add a file named
    `config.yml`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the preceding `config.yml` file, a workflow named `build-and-deploy` is defined,
    which contains a job named `build`. The job uses CircleCI's pre-built `circleci/node:lts
    image`.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'The `build` job has five steps:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '`checkout` checks out the source code from GitHub.'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`setup_remote_docker` informs CircleCI to set up a Docker-within-Docker environment,
    so we can run containers within our pipeline.'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`run` executes the `docker build -f integration.Dockerfile .` command to initiate
    our custom build process, caches the resulting Alpine-based image, and tags it
    with `$CIRCLE_BRANCH.`'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`save_cache` saves the image we created in the cache, so it can be consumed
    by the next step.'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`store_artifacts` reads the created image from the cache and publishes the image
    as a build artifact, which can be downloaded from the web interface or used by
    another job to deploy it to a cloud environment.'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After you sync your changes to GitHub, if everything goes well, you will have
    a passing *green* build. As shown in the following screenshot, this build was
    successful:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_09_19.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.19: Green build on CircleCI using the lemon-mart docker-integration
    branch'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Note that the tarred and gzipped image file size is 9.2 MB, which includes our
    web applications on top of the roughly 7 MB base image size.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, the CI server is running and executing our three-step pipeline.
    As you can see in the preceding screenshot, the build is producing a tarred and
    gzipped file of the web server image, named `built-image.tar.gz`. You can download
    this file from the **Artifacts** tab. However, we're not deploying the resulting
    image to a server.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: You have now adequately mastered working with CircleCI. We will revisit this
    multi-stage `Dockerfile` to perform a deployment on AWS in *Chapter 13*, *Highly
    Available Cloud Infrastructure on AWS*.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's see how you can get a code coverage report from your Angular app
    and record the result in CircleCI.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage reports
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good way to understand the amount and the trends of unit test coverage for
    your Angular project is through a code coverage report.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to generate the report for your app, execute the following command
    from your `project` folder:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The resulting report will be created as an HTML file under a folder named `coverage`;
    execute the following command to view it in your browser:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Install `http-server` as a development dependency in your project.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the folder-level sample coverage report generated by `istanbul/nyc`
    for LemonMart:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_09_20.png)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.20: Istanbul code coverage report for LemonMart'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'You can drill down on a particular folder, such as `src/app/auth`, and get
    a file-level report, as shown here:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_09_21.png)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.21: Istanbul code coverage report for src/app/auth'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'You can drill down further to get line-level coverage for a given file, such
    as `cache.service.ts`, as shown here:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_09_22.png)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.22: Istanbul code coverage report for cache.service.ts'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see that lines **5**, **12**, **17-18**,
    and **21-22** are not covered by any test. The **I** icon denotes that the `if`
    path was not taken. We can increase our code coverage by implementing unit tests
    that exercise the functions that are contained within `CacheService`. As an exercise,
    the reader should attempt to at least cover one of these functions with a new
    unit test and observe the code coverage report change.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage in CI
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ideally, your CI server configuration should generate and host the code coverage
    report with every test run. You can then use code coverage as another code quality
    gate to prevent pull requests being merged if the new code is bringing down the
    overall code coverage percentage. This is a great way to reinforce the **test-driven
    development** (**TDD**) mindset.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: You can use a service such as Coveralls, found at [https://coveralls.io/](https://coveralls.io/),
    to implement your code coverage checks, which can embed your code coverage levels
    directly on a GitHub pull request.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s configure Coveralls for LemonMart:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: On the **lemon-mart** repo, the `config.yml` file for this section is named
    `.circleci/config.ch9.yml`.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: In your CircleCI account settings, under the security section, ensure that you
    allow execution of uncertified/unsigned orbs.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register your GitHub project at [https://coveralls.io/](https://coveralls.io/).
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the repo token and store it as an environment variable in CircleCI named
    `COVERALLS_REPO_TOKEN`.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new branch before you make any code changes.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update `karma.conf.js` so it stores code coverage results under the `coverage`
    folder:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Update the `.circleci/config.yml` file with the Coveralls orb as shown:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Update the `build` job to store code coverage results and upload them to Coveralls:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note that the orb automatically configures Coveralls for your account, so the `coveralls`/`upload`
    command can upload your code coverage results.
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Commit your changes to the branch and publish it.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a pull request on GitHub using the branch.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the pull request, verify that you can see that Coveralls is reporting your project's
    code coverage, as shown:![](img/B14094_09_23.png)
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.23: Coveralls reporting code coverage'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Merge the pull request to your master branch.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations! Now, you can modify your branch protection rules to require
    that code coverage levels must be above a certain percentage before a pull request
    can be merged to master.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！现在，你可以修改你的分支保护规则，要求在合并到主分支之前，代码覆盖率必须高于一定百分比。
- en: The LemonMart project at [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
    implements a full-featured `config.yml` file. This file also implements [Cypress.io](http://Cypress.io),
    a far more robust solution compared to Angular's e2e tool, in CircleCI as well.
    The Cypress orb can record test results and allow you to view them from your CircleCI
    pipeline.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: LemonMart 项目在 [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
    中实现了一个功能齐全的 `config.yml` 文件。此文件还在 CircleCI 中实现了 [Cypress.io](http://Cypress.io)，与
    Angular 的 e2e 工具相比，这是一个更加健壮的解决方案。Cypress orb 可以记录测试结果，并允许你在 CircleCI 管道中查看它们。
- en: Leveraging what you have learned in this chapter, you can incorporate the `deploy`
    scripts from LocalCast Weather for LemonMart and implement a gated deployment
    workflow.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 利用本章所学，你可以将 LocalCast Weather 的 `deploy` 脚本集成到 LemonMart 中，并实现门控部署工作流程。
- en: Summary
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about DevOps and Docker. You containerized your
    web app, deployed a container to Google Cloud Run using CLI tools, and learned
    how to implement gated CI workflows. You leveraged advanced CI techniques to build
    a container-based CI environment leveraging a multi-stage `Dockerfile`. Also,
    you became familiar with orbs, workflows, and code coverage tools.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了 DevOps 和 Docker。你将你的 Web 应用程序容器化，使用 CLI 工具将容器部署到 Google Cloud Run，并学习了如何实现门控
    CI 工作流程。你利用高级 CI 技术构建了一个基于多阶段 `Dockerfile` 的 CI 环境。你还熟悉了 orbs、工作流程和代码覆盖率工具。
- en: We leveraged CircleCI as a cloud-based CI service and highlighted the fact that
    you can deploy the outcome of your builds to all major cloud hosting providers.
    You have seen how you can achieve CD. We covered example deployments to Vercel
    Now and Google Cloud Run via CircleCI, allowing you to implement automated deployments.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用 CircleCI 作为基于云的 CI 服务，并强调了你可以将构建结果部署到所有主要的云托管提供商。你已经看到了如何实现 CD。我们介绍了通过
    CircleCI 到 Vercel Now 和 Google Cloud Run 的示例部署，让你能够实现自动部署。
- en: With a robust CI/CD pipeline, you can share every iteration of your app with
    clients and team members and quickly deliver bug fixes or new features to your
    end users.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个健壮的 CI/CD 管道，你可以与客户和团队成员分享你应用的每个迭代，并快速将错误修复或新功能交付给最终用户。
- en: Exercise
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Add CircleCI and Coveralls badges to the `README.md` file on your code repository.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 CircleCI 和 Coveralls 徽章添加到你的代码仓库中的 `README.md` 文件。
- en: Implement Cypress for e2e testing and run it in your CircleCI pipeline using
    the Cypress orb.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为端到端测试实现 Cypress，并在你的 CircleCI 管道中使用 Cypress orb 运行它。
- en: Implement a Vercel Now deployment and a conditional workflow for the Lemon Mart
    app. You can find the resulting `config.yml` file on the lemon-mart repo, named
    `.circleci/config.ch9.yml`.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 Lemon Mart 应用程序的 Vercel Now 部署和条件工作流程。你可以在 lemon-mart 仓库中找到生成的 `config.yml`
    文件，命名为 `.circleci/config.ch9.yml`。
- en: Further reading
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Dockerfile reference*, 2020, [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Dockerfile 参考*，2020，[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)'
- en: '*CircleCI orbs*, 2020, [https://circleci.com/orbs/](https://circleci.com/orbs/)'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CircleCI orbs*，2020，[https://circleci.com/orbs/](https://circleci.com/orbs/)'
- en: '*Deploying container images*, 2020, [https://cloud.google.com/run/docs/depl](https://cloud.google.com/run/docs/depl)oying'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部署容器镜像*，2020，[https://cloud.google.com/run/docs/deploy](https://cloud.google.com/run/docs/deploy)ying'
- en: '*Creating and managing service account keys*, 2020, [https://cloud.google.com/iam/docs/creating-managing-service-account-keys#iam-service-account-keys-create-console](https://cloud.google.com/iam/docs/creating-managing-service-account-keys#iam-service-account-keys-cr)'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建和管理服务账户密钥*，2020，[https://cloud.google.com/iam/docs/creating-managing-service-account-keys#iam-service-account-keys-create-console](https://cloud.google.com/iam/docs/creating-managing-service-account-keys#iam-service-account-keys-cr)'
- en: Questions
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Answer the following questions as best as you can to ensure that you've understood
    the key concepts from this chapter without Googling. Do you need help answering
    the questions? See *Appendix D*, *Self-Assessment Answers* online at [https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf)
    or visit [https://expertlysimple.io/angular-self-assessment](https://expertlysimple.io/angular-self-assessment).
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地回答以下问题，以确保你在不使用谷歌搜索的情况下理解了本章的关键概念。你需要帮助回答这些问题吗？请参阅*附录D*，*自我评估答案*，在线访问[https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf)或访问[https://expertlysimple.io/angular-self-assessment](https://expertlysimple.io/angular-self-assessment)。
- en: Explain the difference between a Docker image and a Docker container.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释Docker镜像和Docker容器之间的区别。
- en: What is the purpose of a CD pipeline?
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CD管道的目的是什么？
- en: What is the benefit of CD?
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CD的好处是什么？
- en: How do we cover the configuration gap?
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何覆盖配置差距？
- en: What does a CircleCI orb do?
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CircleCI orb的功能是什么？
- en: What are the benefits of using a multi-stage `Dockerfile`?
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用多阶段`Dockerfile`的好处是什么？
- en: How does a code coverage report help maintain the quality of your app?
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码覆盖率报告如何帮助维护你应用程序的质量？
