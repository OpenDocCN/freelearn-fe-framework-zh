- en: '*Chapter 4*: Understanding Angular Animations'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：理解Angular动画'
- en: In this chapter, you'll learn about working with animations in Angular. You'll
    learn about multi-state animations, staggering animations, keyframe animations,
    and how to implement animations for switching routes in your Angular apps.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何在Angular中使用动画。您将学习多状态动画、阶段动画、关键帧动画，以及如何为Angular应用程序中的路由切换实现动画。
- en: 'The following are the recipes that we''re going to cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章将要涵盖的教程：
- en: Creating your first two-state Angular animation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您的第一个双状态Angular动画
- en: Working with multi-state animations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多状态动画
- en: Creating complex Angular animations using keyframes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用关键帧创建复杂的Angular动画
- en: Animating lists in Angular using stagger animations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用阶段动画在Angular中为列表添加动画
- en: Using animation callbacks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动画回调
- en: Basic route animations in Angular
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular中进行基本路由动画
- en: Complex route animations in Angular using keyframes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用关键帧在Angular中创建复杂的路由动画
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For the recipes in this chapter, make sure you have **Git** and **Node.js**
    installed on your machine. You also need to have the `@angular/cli` package installed,
    which you can install by using `npm install -g @angular/cli` from your terminal.
    The code for this chapter can be found at [https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter04](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter04).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的教程中，请确保您的计算机上安装了**Git**和**Node.js**。您还需要安装`@angular/cli`包，可以通过在终端中使用`npm
    install -g @angular/cli`来安装。本章的代码可以在[https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter04](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter04)找到。
- en: Creating your first two-state Angular animation
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个双状态Angular动画
- en: In this recipe, you'll create a basic two-state Angular animation using a fading
    effect. We'll start with a fresh Angular project with some UI already built into
    it, enable animations within the app, and then move toward creating our first
    animation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，您将使用淡入淡出效果创建一个基本的双状态Angular动画。我们将从一个带有一些UI的新的Angular项目开始，启用应用程序中的动画，然后开始创建我们的第一个动画。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `chapter04/start_here/ng-basic-animation`
    inside the cloned repository:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的项目位于克隆存储库中的`chapter04/start_here/ng-basic-animation`中：
- en: Open the project in Visual Studio Code.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab and you should see the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器标签页中打开应用程序，您应该会看到以下内容：
- en: '![Figure 4.1 – ng-basic-animation app running on http://localhost:4200'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 - ng-basic-animation应用程序运行在http://localhost:4200'
- en: '](image/Figure_4.1_B15150.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.1_B15150.jpg)'
- en: Figure 4.1 – ng-basic-animation app running on http://localhost:4200
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 - ng-basic-animation应用程序运行在http://localhost:4200
- en: Now that we have the app running, we will move on to the steps for the recipe.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序正在运行，我们将继续进行教程的步骤。
- en: How to do it…
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We have an app that doesn''t have Angular animations configured at all. So,
    we''ll begin by enabling Angular animations. Then, we''ll replace the CSS animations
    with Angular animations. Let''s continue with the steps as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个应用程序，没有配置Angular动画。因此，我们将从启用Angular动画开始。然后，我们将用Angular动画替换CSS动画。让我们按照以下步骤继续：
- en: 'First, we''ll inject `BrowserAnimationsModule` from the `@angular/platform-browser/animations`
    package in our `app.module.ts`, so we can use animations within our Angular applications.
    We''ll also import `BrowserAnimationsModule` in the `imports` array as follows:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将从`@angular/platform-browser/animations`包中在我们的`app.module.ts`中注入`BrowserAnimationsModule`，这样我们就可以在我们的Angular应用程序中使用动画。我们还将在`imports`数组中导入`BrowserAnimationsModule`，如下所示：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we''ll remove the CSS style transitions so we can see the full button
    (icon and text) by default for both the Facebook and Twitter buttons. Let''s remove
    the styles from `app.component.scss` as highlighted in the following code block:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将删除CSS样式转换，这样我们就可以默认看到Facebook和Twitter按钮的完整按钮（图标和文本）。让我们从`app.component.scss`中删除以下代码块中突出显示的样式：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We''ll also remove the `&--active` selector under `&__btn` in the `app.component.scss`
    file, and move the styles for `[class^="icon-"], [class*=" icon-"]` inside the
    `&__btn` selector. This is done so that there is a right-hand margin for all icons.
    Your code should look as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将在`app.component.scss`文件中删除`&--active`选择器下的`&__btn`，并将`[class^="icon-"],
    [class*=" icon-"]`的样式移动到`&__btn`选择器内。这样做是为了所有图标都有右边距。您的代码应如下所示：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s add the animation to be created to the template now. We''ll apply the
    animation to the text elements of both buttons. Modify `app.component.html` as
    follows:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们将要创建的动画添加到模板中。我们将动画应用于两个按钮的文本元素。修改`app.component.html`如下：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, we'll start creating our animation named `socialBtnText`, and for that,
    we'll import some functions from the `@angular/animations` package in our `app.component.ts`
    so we can create the two states for the button text.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开始创建名为`socialBtnText`的动画，为此，我们将从`@angular/animations`包中导入一些函数到我们的`app.component.ts`中，这样我们就可以为按钮文本创建两个状态。
- en: 'Add the following imports to your `app.component.ts`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下导入添加到您的`app.component.ts`中：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let''s add an animation named `socialBtnText` using the `trigger` method
    to the `animations` array in the `AppComponent` metadata as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用`trigger`方法将名为`socialBtnText`的动画添加到`AppComponent`元数据的`animations`数组中：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we''ll create the two states named `btn-active-text` and `btn-inactive-text`.
    We''ll set `width` and `visibility` for these states as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建名为`btn-active-text`和`btn-inactive-text`的两个状态。我们将为这些状态设置`width`和`visibility`，如下所示：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that we have the states configured, we can start writing the transitions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了状态，我们可以开始编写转换。
- en: 'We''ll first implement the `''btn-inactive-text => btn-active-text''` transition,
    which triggers upon clicking either of the buttons. Since this transition is going
    to be displaying the text, we''ll first increase the `width` value of the text
    element, and then we''ll set the text to `visible`. The content in the `animations[]`
    array should look as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先实现`'btn-inactive-text => btn-active-text'`转换，该转换在单击任一按钮时触发。由于此转换将显示文本，因此我们将首先增加文本元素的`width`值，然后将文本设置为`visible`。`animations[]`数组中的内容应如下所示：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You should see a smooth animation now for the button's active state. Let's implement
    the inactive state in the next step.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该看到按钮的活动状态有一个平滑的动画。让我们在下一步中实现非活动状态。
- en: 'Now we''ll implement the `''btn-active-text => btn-inactive-text''` transition.
    This should turn the visibility to `''hidden''` and set the width back to `''0px''`
    again. The code should look as follows:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将实现`'btn-active-text => btn-inactive-text'`转换。这应该将可见性变为`'hidden'`，并将宽度再次设置为`'0px'`。代码应该如下所示：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You''ll notice that there''s a slight jerk/lag when the button becomes inactive.
    That''s because the animation for width triggers first, and then it triggers the
    animation for `visibility: ''hidden''`. Therefore, we see both of them happening
    in sequence.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '您会注意到当按钮变为不活动状态时会有轻微的抖动/延迟。这是因为宽度的动画触发先于`visibility: ''hidden''`的动画。因此，我们看到它们都是按顺序发生的。'
- en: 'To have both animations work together, we''ll use the `group` method from the
    `@angular/animations` package. We''ll group together our `animate()` methods for
    the transition. The update in the `app.components.ts` file should look as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使两个动画一起工作，我们将使用`@angular/animations`包中的`group`方法。我们将为过渡组合我们的`animate()`方法。`app.components.ts`文件中的更新应如下所示：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since we want this to be really quick, the time we''ll set for the `animate()`
    methods for the `''btn-active-text => btn-inactive-text''` transition will be
    zero seconds (`0s`). Change it as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们希望这个过程非常快速，所以我们将为`'btn-active-text => btn-inactive-text'`过渡的`animate()`方法设置为零秒（`0s`）。更改如下：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Toward the end, we can remove the extra `margin-right` from the button icon
    when the button is not active. We'll do it by moving the code for the `[class^="icon-"],
    [class*=" icon-"]` selector inside another selector named `&--active` so it only
    applies when the button is active.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当按钮不活动时，我们可以去掉按钮图标的额外`margin-right`。我们将通过将`[class^="icon-"], [class*=" icon-"]`选择器的代码移动到另一个名为`&--active`的选择器内，这样它只在按钮处于活动状态时应用。
- en: 'Modify the following styles in the `&__btn` selector in the `app.component.scss`
    file, as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`app.component.scss`文件中`&__btn`选择器中的以下样式，如下所示：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Great! You now have implemented some good-looking animation buttons in the app.
    See the next section to understand how the recipe works.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！您现在已经在应用程序中实现了一些看起来不错的动画按钮。请查看下一节，了解这个方法是如何工作的。
- en: How it works…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Angular provides its own Animation API that allows you to animate any property
    that the CSS transitions work on. The benefit is that you can configure them dynamically
    based on the requirements. We first used the `trigger` method to register the
    animation with the states and transitions. We then defined those states and transitions
    using the `state` and `transition` methods respectively. And we also saw how to
    run animations in parallel using the `group` method. If we didn't group the animations,
    they'd run sequentially. Finally, we applied the states using some flags in the
    component to reflect the changes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了自己的动画API，允许您对CSS过渡适用的任何属性进行动画处理。好处是您可以根据要求动态配置它们。我们首先使用`trigger`方法将动画注册到状态和过渡中。然后我们分别使用`state`和`transition`方法定义这些状态和过渡。我们还看到了如何使用`group`方法并行运行动画。如果我们没有将动画分组，它们将按顺序运行。最后，我们使用组件中的一些标志应用了这些状态以反映变化。
- en: There's more…
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'You might have noticed that the Twitter button somehow looks bigger than it
    should be. This is because we have the width of the text set to a constant `80px`
    for our states and animations so far. While this looks good for the Facebook button,
    it doesn''t look good for the Twitter one. So, we can actually make it configurable
    by providing two different transitions based on different widths for the buttons.
    Here''s what you''ll do:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，Twitter按钮看起来比应该的要大一些。这是因为到目前为止，我们已经将文本的宽度设置为常量`80px`，用于我们的状态和动画。虽然这对Facebook按钮看起来不错，但对Twitter按钮来说就不太好看了。因此，我们实际上可以通过为按钮提供不同宽度的两种不同过渡来使其可配置。以下是你要做的：
- en: Create a new file in the app folder and name it `animations.ts`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序文件夹中创建一个新文件，命名为`animations.ts`。
- en: 'Move the code from the animations array in the `app.component.ts` file to this
    new file; it should look as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`app.component.ts`文件中动画数组中的代码移动到这个新文件中；它应如下所示：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And now, we''ll add the transitions as well:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们还将添加过渡效果：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we''ll use this `buttonTextAnimation` method for both our Facebook and
    Twitter buttons in `app.component.ts` as follows. Notice that we''ll create two
    different animations:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在`app.component.ts`中为我们的Facebook和Twitter按钮使用`buttonTextAnimation`方法如下。请注意，我们将创建两个不同的动画：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we''ll use the respective animations for the Facebook and Twitter
    buttons in `app.component.html` as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将在`app.component.html`中为Facebook和Twitter按钮使用相应的动画，如下所示：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: See also
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Animations in Angular ([https://angular.io/guide/animations](https://angular.io/guide/animations))
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular中的动画 ([https://angular.io/guide/animations](https://angular.io/guide/animations))
- en: '*Angular Animations Explained with Examples* ([https://www.freecodecamp.org/news/angular-animations-explained-with-examples/](https://www.freecodecamp.org/news/angular-animations-explained-with-examples/))'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用示例解释的Angular动画* ([https://www.freecodecamp.org/news/angular-animations-explained-with-examples/](https://www.freecodecamp.org/news/angular-animations-explained-with-examples/))'
- en: Working with multi-state animations
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多状态动画
- en: In this recipe, we'll work with Angular animations containing multiple states.
    This means that we'll work with more than two states for a particular item. We'll
    be using the same Facebook and Twitter cards example for this recipe as well.
    But we'll configure the state of the cards for their state before they appear
    on screen, when they're on screen, and when they're about to disappear from the
    screen again.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用包含多个状态的Angular动画。这意味着我们将为特定项目使用两个以上的状态。我们将继续使用相同的Facebook和Twitter卡片示例。但是我们将配置卡片的状态，以便它们在屏幕上出现之前的状态，当它们在屏幕上时的状态，以及当它们即将再次从屏幕上消失时的状态。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter04/start_here/ng-multi-state-animations`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱的项目位于`chapter04/start_here/ng-multi-state-animations`中：
- en: Open the project in Visual Studio Code.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`以安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab, and you should see the app as
    follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在新的浏览器标签中打开应用程序，您应该看到应用程序如下所示：
- en: '![Figure 4.2 – ng-multi-state-animations app running on http://localhost:4200'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 - ng-multi-state-animations应用程序在http://localhost:4200上运行'
- en: '](image/Figure_4.2_B15150.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.2_B15150.jpg)'
- en: Figure 4.2 – ng-multi-state-animations app running on http://localhost:4200
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 - ng-multi-state-animations应用程序在http://localhost:4200上运行
- en: Now that we have the app running locally, let's look at the steps of the recipe
    in the next section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序在本地运行，让我们在下一节中看一下食谱的步骤。
- en: How to do it…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We already have a working app that has a single animation built for the reach
    of social cards. When you tap either the Facebook or Twitter button, you''ll see
    the respective card appearing with a slide-in animation from left to right. To
    keep the recipe simple, we''ll implement two more states and animations for when
    the user moves the mouse cursor on the card and when the user moves away from
    the card. Let''s add the relevant code in the following steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个工作中的应用程序，为社交卡片的到达构建了一个单一动画。当您点击Facebook或Twitter按钮时，您将看到相应的卡片以从左到右的滑入动画出现。为了保持食谱简单，我们将为用户在卡片上移动鼠标和用户远离卡片时实现两个更多的状态和动画。让我们按照以下步骤添加相关代码：
- en: 'We''ll start with adding two `@HostListener` instances to `FbCardComponent`
    in the `components/fb-card/fb-card.component.ts` file, one for the `mouseenter`
    event on the card and one for the `mouseleave` event. We''ll name the states `hovered`
    and `active` respectively. The code should look as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从在`components/fb-card/fb-card.component.ts`文件中的`FbCardComponent`中添加两个`@HostListener`实例开始，一个用于卡片的`mouseenter`事件，另一个用于`mouseleave`事件。我们分别将状态命名为`hovered`和`active`。代码应如下所示：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we''ll do the same for `TwitterCardComponent` in the `twitter-card-component.ts`
    file. The code should look as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在`twitter-card-component.ts`文件中为`TwitterCardComponent`执行相同的操作。 代码应如下所示：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There should be no visual change so far since we're only updating the `cardState`
    variable to have the hover and active states. We haven't defined the transitions
    yet.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，由于我们只是更新`cardState`变量以具有悬停和活动状态，因此不应该有视觉变化。 我们还没有定义过渡。
- en: 'We''ll now define our state for when the user''s cursor enters the card, that
    is, the `mouseenter` event. The state is called `hovered` and should look as follows
    in the `animation.ts` file:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将定义当用户光标进入卡片时的状态，即`mouseenter`事件。 该状态称为`悬停`，应在`animation.ts`文件中如下所示：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you refresh the app now, tap either the Facebook or Twitter button, and hover
    the cursor over the card, you'll see the card's UI changing. That's because we
    changed the state to `hovered`. However, there's no animation yet. Let's add one
    in the next step.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在刷新应用程序，点击Facebook或Twitter按钮，并将光标悬停在卡片上，您将看到卡片的UI发生变化。 这是因为我们将状态更改为`悬停`。
    但是，目前还没有动画。 让我们在下一步中添加一个。
- en: 'We''ll add the `active => hovered` transition now in the `animations.ts` file
    so that we can smoothly navigate from `active` to the `hovered` state:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将在`animations.ts`文件中添加`活动=>悬停`过渡，以便我们可以平稳地从`活动`过渡到`悬停`状态：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You should now see the smooth transition on the `mouseenter` event if you refresh
    the app.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您刷新应用程序，现在应该在mouseenter事件上看到平滑的过渡。
- en: 'Finally, we''ll add the final transition, `hovered => active`, so when the
    user leaves the card, we revert to the active state with a smooth animation. The
    code should look as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加最终的过渡，即`悬停=>活动`，因此当用户离开卡片时，我们将以平滑的动画恢复到活动状态。 代码应如下所示：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Ta-da! You now know how to implement different states and different animations
    on a single element using `@angular/animations`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 哒哒！ 您现在知道如何使用`@angular/animations`在单个元素上实现不同状态和不同动画。
- en: How it works…
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Angular uses triggers for understanding what state the animation is in. An
    example syntax looks as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Angular使用触发器来了解动画所处的状态。 一个示例语法如下：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`expression` can be a valid JavaScript expression, and it evaluates to the
    name of the state. In our case, we bind it to the `cardState` property, which
    either contains `''active''` or `''hovered''`. Therefore, we end up with three
    transitions for our cards:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`expression`可以是有效的JavaScript表达式，并且评估为状态的名称。 在我们的情况下，我们将其绑定到`cardState`属性，该属性包含`''active''`或`''hovered''`。
    因此，我们为我们的卡片定义了三个过渡：'
- en: '`void => active` (when the element is added to the DOM and is rendered)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void=>活动`（当元素添加到DOM并呈现时）'
- en: '`active => hovered` (when the `mouseenter` event triggers on the card)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动=>悬停（当卡片上触发mouseenter事件时）
- en: '`hovered => active` (when the `mouseleave` event triggers on the card)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`悬停=>活动`（当卡片上触发mouseleave事件时）'
- en: See also
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Triggering the animation* ([https://angular.io/guide/animations#triggering-the-animation](https://angular.io/guide/animations#triggering-the-animation))'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*触发动画*（[https://angular.io/guide/animations#triggering-the-animation](https://angular.io/guide/animations#triggering-the-animation)）'
- en: '*Reusable* *animations* ([https://angular.io/guide/reusable-animations](https://angular.io/guide/reusable-animations))'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可重用* *动画*（[https://angular.io/guide/reusable-animations](https://angular.io/guide/reusable-animations)）'
- en: Creating complex Angular animations using keyframes
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用关键帧创建复杂的Angular动画
- en: Since you already know about Angular animations from the previous recipes, you
    might be thinking, "Well, that's easy enough." Well, time to level up your animation
    skills in this recipe. You'll create a complex Angular animation using keyframes
    in this recipe to get started with writing some advanced animations.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你已经了解了上一个教程中关于 Angular 动画的知识，你可能会想，“嗯，这很容易。” 现在是时候在这个教程中提升你的动画技能了。在这个教程中，你将使用关键帧创建一个复杂的
    Angular 动画，以便开始编写一些高级动画。
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter04/start_here/animations-using-keyframes`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的项目位于 `chapter04/start_here/animations-using-keyframes` 中。
- en: Open the project in Visual Studio Code.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行 `npm install` 来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行 `ng serve -o`。
- en: 'This should open the app in a new browser tab and you should see the app as
    follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签中打开应用程序，你应该看到应用程序如下：
- en: '![Figure 4.3 – animations-using-keyframes app running on http://localhost:4200'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.3 – 在 http://localhost:4200 上运行的使用关键帧的动画应用程序'
- en: '](image/Figure_4.3_B15150.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.3_B15150.jpg)'
- en: Figure 4.3 – animations-using-keyframes app running on http://localhost:4200
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 在 http://localhost:4200 上运行的使用关键帧的动画应用程序
- en: Now that we have the app running locally, let's look at the steps of the recipe
    in the next section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序在本地运行，让我们在下一节中看一下这个教程的步骤。
- en: How to do it…
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We have an app right now that has a single transition, that is, `void => *`,
    which triggers when the element is rendered on DOM. Right now, the animation is
    pretty simple and uses the `animate` function to define the animation. We''ll
    first convert it to keyframes, and then we''ll make it a bit complex:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个应用程序，它只有一个过渡，即 `void => *`，当元素在 DOM 上渲染时触发。现在，动画非常简单，使用 `animate` 函数来定义动画。我们将首先将其转换为关键帧，然后将其变得稍微复杂一些：
- en: 'Let''s begin with adding the `keyframes` method from `@angular/animations`
    to the `animations.ts` file as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从 `@angular/animations` 中添加 `keyframes` 方法到 `animations.ts` 文件中，如下所示：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we''ll convert the single style animation to keyframes as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将把单一样式动画转换为关键帧，如下所示：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Notice that in this code block, we''ve removed the `state(''active'', …)` part
    because we don''t need it anymore. Also, we moved the `style({transform: ''translateX(-200px)'',
    opacity: 0})` inside the `keyframes` array because it is now part of the keyframes
    animation itself. If you refresh the app now and try it, you''ll still see the
    same animation as before. But now we have it using `keyframes`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，在这个代码块中，我们已经删除了 `state(''active'', …)` 部分，因为我们不再需要它了。此外，我们将 `style({transform:
    ''translateX(-200px)'', opacity: 0})` 移到了 `keyframes` 数组内，因为它现在是关键帧动画本身的一部分。如果你现在刷新应用并尝试，你仍然会看到与之前相同的动画。但现在我们使用了
    `keyframes`。'
- en: 'Finally, let''s start adding some complex animations. Let''s start the animation
    with a scaled-down card by adding `scale3d` to the `transform` property of `style`
    at `offset: 0`. We''ll also increase the animation time to `1.5s`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '最后，让我们开始添加一些复杂的动画。我们将通过在 `offset: 0` 的 `style` 的 `transform` 属性中添加 `scale3d`
    来以缩小的卡片开始动画。我们还将增加动画时间到 `1.5s`：'
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You should now see that the card animation starts with a small card that slides
    from the left and moves toward the right, increasing in size.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该看到卡片动画从左侧滑动并向右移动，逐渐增大。
- en: 'Now we''ll implement a zig-zag-ish animation for the appearance of the card
    instead of the slide-in animation. Let''s add the following keyframe elements
    to the `keyframes` array to add a bumpy effect to our animation:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将为卡片的出现实现一种类似之字形的动画，而不是滑入动画。让我们向 `keyframes` 数组中添加以下关键帧元素，以给我们的动画添加颠簸效果：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you refresh the app and tap any of the buttons, you should see the card
    bumping to the right wall, and then to the left wall of the card, before returning
    to the normal state:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您刷新应用程序并点击任何按钮，您应该看到卡片向右墙移动，然后向卡片的左墙移动，然后返回到正常状态：
- en: '![Figure 4.4 – Card bumping to right and then the left wall'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4-卡片向右墙然后向左墙移动'
- en: '](image/Figure_4.04_B15150.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.04_B15150.jpg)'
- en: Figure 4.4 – Card bumping to right and then the left wall
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4-卡片向右墙然后向左墙移动
- en: 'As the last step, we''ll spin the card clockwise before it returns to its original
    position. For that, we''ll use `offset: 0.75`, using the `rotate` method with
    some additional angles. The code should look as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '作为最后一步，我们将在卡片返回到原始位置之前顺时针旋转卡片。为此，我们将使用`offset: 0.75`，使用`rotate`方法以及一些额外的角度。代码应如下所示：'
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Awesome! You now know how to implement complex animations in Angular using the
    `keyframes` method from the `@angular/common` package. See in the next section
    how it works.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在您知道如何使用`@angular/common`包中的`keyframes`方法在Angular中实现复杂的动画。在下一节中看看它是如何工作的。
- en: How it works…
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: For complex animations in Angular, the `keyframes` method is a really good way
    of defining different offsets of the animation throughout its journey. We can
    define the offsets using the `styles` method, which takes `AnimationStyleMetadata`
    as a parameter. `AnimationStyleMetadata` also allows us to pass the `offset` property,
    which can have a value between `0` and `1`. Thus, we can define different styles
    for different offsets to create advanced animations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在Angular中进行复杂的动画，`keyframes`方法是定义动画在其整个过程中不同偏移的一个非常好的方法。我们可以使用`styles`方法来定义偏移，该方法以`AnimationStyleMetadata`作为参数。`AnimationStyleMetadata`还允许我们传递`offset`属性，该属性的值可以在`0`和`1`之间。因此，我们可以为不同的偏移定义不同的样式，以创建高级动画。
- en: See also
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Animations in Angular* ([https://angular.io/guide/animations](https://angular.io/guide/animations))'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Angular中的动画* ([https://angular.io/guide/animations](https://angular.io/guide/animations))'
- en: '*Angular Animations Explained with Examples* ([https://www.freecodecamp.org/news/angular-animations-explained-with-examples/](https://www.freecodecamp.org/news/angular-animations-explained-with-examples/))'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用示例解释的Angular动画* ([https://www.freecodecamp.org/news/angular-animations-explained-with-examples/](https://www.freecodecamp.org/news/angular-animations-explained-with-examples/))'
- en: Animating lists in Angular using stagger animations
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用交错动画在Angular中为列表添加动画
- en: No matter what web application you build today, you are going to implement some
    sort of list most likely. And to make those lists even better, why not implement
    an elegant animation with them? In this recipe, you'll learn how to animate lists
    in Angular using stagger animations.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您今天构建什么样的Web应用程序，您很可能会实现某种列表。为了使这些列表变得更好，为什么不为它们实现一个优雅的动画呢？在这个食谱中，您将学习如何使用交错动画在Angular中为列表添加动画。
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter04/start_here/animating-lists`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱的项目位于`chapter04/start_here/animating-lists`中：
- en: Open the project in Visual Studio Code.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab. Log in to the app as an employee,
    and you should see the app as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器选项卡中打开应用程序。以员工身份登录应用程序，您应该看到应用程序如下：
- en: '![Figure 4.5 – animating-lists app running on http://localhost:4200'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5-在http://localhost:4200上运行的animating-lists应用程序'
- en: '](image/Figure_4.05_B15150.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.05_B15150.jpg)'
- en: Figure 4.5 – animating-lists app running on http://localhost:4200
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5-在http://localhost:4200上运行的animating-lists应用程序
- en: Now that we have the app running locally, let's see the steps of the recipe
    in the next section.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用程序，让我们在下一节中看看食谱的步骤。
- en: How to do it…
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: We have an app right now that has a list of bucket items. We need to animate
    the list using staggering animations. We'll be doing this step by step. I'm excited
    – are you?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个具有桶项目列表的应用程序。我们需要使用交错动画对列表进行动画处理。我们将一步一步地完成这个过程。我很兴奋 - 你呢？
- en: 'Cool. We''ll go through the following steps for the recipe:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们将按照以下步骤进行操作：
- en: 'First, let''s add `BrowserAnimationsModule` from the `@angular/platform-browser/animations`
    package in our `app.module.ts` so that we can enable animations for the app. The
    code should look as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在我们的`app.module.ts`中，让我们从`@angular/platform-browser/animations`包中添加`BrowserAnimationsModule`，以便我们可以为应用程序启用动画。代码应该如下所示：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, create a file named `animations.ts` inside the `constants` folder and
    add the following code to register a basic list item animation named `listItemAnimation`
    with Angular:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`constants`文件夹中创建一个名为`animations.ts`的文件，并添加以下代码以向Angular注册一个名为`listItemAnimation`的基本列表项动画：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that the `void => *` transition is for when the list item enters the
    view (or appears). The `* => void` transition is for when the item leaves the
    view (or disappears).
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，`void => *`过渡是用于当列表项进入视图（或出现）时。`* => void`过渡是用于当项目离开视图（或消失）时。
- en: 'Now, we''ll add the animation to `BucketComponent` in the `app/shared/bucket/bucket.component.ts`
    file as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在`app/shared/bucket/bucket.component.ts`文件中为`BucketComponent`添加动画，如下所示：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Since we have the animation imported in the component, we can use it in the
    template now.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在组件中导入了动画，现在可以在模板中使用它。
- en: 'Let''s add the animation to the list item as follows in `bucket.component.html`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`bucket.component.html`中按照以下方式将动画添加到列表项中：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you now refresh the app and add an item to the bucket list, you should see
    it appear with a fade-in effect. And if you delete an item, you should see it
    disappear with the animation as well.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您现在刷新应用程序并将项目添加到桶列表中，您应该会看到它以淡入效果出现。如果您删除一个项目，您也应该看到它以动画方式消失。
- en: One thing that you'll notice is that when you refresh the app, all the list
    items appear together simultaneously. We can, however, make them appear one by
    one, using `stagger` animations. We'll do that in the next step.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到的一件事是，当您刷新应用程序时，所有列表项会同时出现。然而，我们可以使用`stagger`动画使它们一个接一个地出现。我们将在下一步中完成这一点。
- en: 'We''ll modify `LIST_ITEM_ANIMATION` now to use the `stagger` method. This is
    because we can make each list item appear one after the other. First, we need
    to import the `stagger` method from `@angular/animations`, and then we need to
    wrap our `animate` methods within `stagger` methods. Update the `animations.ts`
    file as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将修改`LIST_ITEM_ANIMATION`以使用`stagger`方法。这是因为我们可以让每个列表项依次出现。首先，我们需要从`@angular/animations`中导入`stagger`方法，然后我们需要在`stagger`方法内部包装我们的`animate`方法。更新`animations.ts`文件如下：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This, however, *will not work*. And that's because the `stagger` method can
    only be used within a `query` method. Therefore, we need to modify our code a
    bit to use the `query` methods in the next step.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样*是行不通的*。那是因为`stagger`方法只能在`query`方法内部使用。因此，我们需要稍微修改我们的代码以在下一步中使用`query`方法。
- en: Let's import the `query` method from `@angular/animations` and modify our code
    a bit so it can be used with the `stagger` method. We're going to make a couple
    of changes.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从`@angular/animations`中导入`query`方法，并稍微修改我们的代码，以便它可以与`stagger`方法一起使用。我们将做一些改变。
- en: We'll rename the animation to `listAnimation` since the animation will now apply
    to the list instead of the individual list items.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将将动画重命名为`listAnimation`，因为动画现在将应用于列表而不是单个列表项。
- en: We'll wrap our `stagger` methods inside the appropriate `query` methods.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在适当的`query`方法中包装我们的`stagger`方法。
- en: We'll use only one transition, that is, `* => *`, for both queries, `:enter`
    and `:leave`, so whenever the list items change, the animation is triggered.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将仅使用一个转换，即`* => *`，用于两个查询，`:enter`和`:leave`，因此每当列表项发生变化时，动画就会触发。
- en: 'We''ll move `style({ opacity: 0 })` inside the `query('':enter'')` chunk as
    it needs to hide the items before the stagger animation.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们将`style({ opacity: 0 })`移动到`query('':enter'')`块内，因为它需要在交错动画之前隐藏项目。'
- en: 'The code should look as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 代码应该如下所示：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We now need to fix the import of the animation in `shared/components/bucket/bucket.component.ts`
    as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要修复`shared/components/bucket/bucket.component.ts`中动画的导入如下：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Since we''ve changed the name of the animation, let''s fix in the template
    of the bucket component as well. Update `shared/components/bucket/bucket.component.html`
    as follows:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自从我们改变了动画的名称，让我们也在桶组件的模板中进行修复。更新`shared/components/bucket/bucket.component.html`如下：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice that we're binding the `[@listAnimation]` property to `bucket.length`.
    This will make sure that the animation triggers whenever the length of the bucket
    changes, that is, when an item is added or removed from the bucket.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将`[@listAnimation]`属性绑定到`bucket.length`。这将确保每当桶的长度发生变化时动画触发，也就是说，当向桶中添加或移除项目时。
- en: Awesome! You now know how to implement staggering animations for lists in Angular.
    See in the next section how it works.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在你知道如何在Angular中为列表实现交错动画。在下一节中看看它是如何工作的。
- en: How it works…
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Stagger animations only work inside `query` methods. This is because of the
    fact that staggering animations usually are applied to the list itself and not
    to individual items. In order to search or query the items, we first use the `query`
    method. Then we use the `stagger` method to define how many milliseconds of staggering
    we want before the animation starts for the next list item. We also provide `animation`
    as well in the `stagger` method to define the animation for each element found
    with the query. Notice that we''re using `{ optional: true }` for both the `:enter`
    query and the `:leave` query. This is because if the list binding changes (`bucket.length`),
    we don''t get an error if no new element has entered the DOM or no element has
    left the DOM.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '交错动画只能在`query`方法内部工作。这是因为交错动画通常应用于列表本身，而不是单个项目。为了搜索或查询项目，我们首先使用`query`方法。然后我们使用`stagger`方法来定义在下一个列表项的动画开始之前我们想要多少毫秒的交错。我们还在`stagger`方法中提供`animation`来定义在查询中找到的每个元素的动画。请注意，我们对`：enter`查询和`：leave`查询都使用了`{
    optional: true }`。这是因为如果列表绑定发生变化（`bucket.length`），如果没有新元素进入DOM或没有元素离开DOM，我们不会收到错误。'
- en: See also
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Animations in Angular* ([https://angular.io/guide/animations](https://angular.io/guide/animations))'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Angular中的动画*（[https://angular.io/guide/animations](https://angular.io/guide/animations)）'
- en: Angular animations stagger docs ([https://angular.io/api/animations/stagger](https://angular.io/api/animations/stagger))
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular动画交错文档（[https://angular.io/api/animations/stagger](https://angular.io/api/animations/stagger)）
- en: Using animation callbacks
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动画回调
- en: In this recipe, you'll learn how to be notified and act upon animation state
    changes in Angular. As a simple example, we'll use the same bucket list app, and
    we'll reset the `item-to-add` option whenever the animation completes for adding
    an item.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何在Angular中被通知并对动画状态变化做出反应。作为一个简单的例子，我们将使用相同的桶列表应用程序，并且当动画完成添加项目时，我们将重置`item-to-add`选项。
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `chapter04/start_here/animation-callbacks`
    inside the cloned repository:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的项目位于克隆存储库中的`chapter04/start_here/animation-callbacks`中：
- en: Open the project in Visual Studio Code.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖。
- en: Once done, run `ng serve -o`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: This should open the app in a new browser tab.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器标签中打开应用程序。
- en: 'Click the **Login as Admin** button, and you should see something like the
    following:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**以管理员身份登录**按钮，你应该会看到类似以下的内容：
- en: '![Figure 4.6 – animation-callbacks app running on http://localhost:4200'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6-动画回调应用程序在http://localhost:4200上运行'
- en: '](image/Figure_4.06_B15150.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.06_B15150.jpg)'
- en: Figure 4.6 – animation-callbacks app running on http://localhost:4200
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6-动画回调应用程序在http://localhost:4200上运行
- en: Now that we have the app running locally, let's see the steps of the recipe
    in the next section.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用程序，让我们在下一节中看看食谱的步骤。
- en: How to do it…
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We have the same bucket app for this recipe that we used in the previous recipes.
    To see how to use animation callbacks, we''ll simply perform an action once the
    animation of a list item entering the DOM is finished and have one action for
    when a list item leaves the DOM. Let''s get started:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个食谱中使用了之前食谱中使用的相同的桶应用程序。为了看看如何使用动画回调，我们将简单地在列表项进入DOM的动画完成后执行一个动作，并在列表项离开DOM时执行一个动作。让我们开始吧：
- en: 'We''ll first create two methods named `onAnimationStarted` and `onAnimationDone`
    in `BucketComponent` inside the `shared/components/bucket/bucket.component.ts`
    file. These methods will be triggered for the respective phases of animations
    in the later steps:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`shared/components/bucket/bucket.component.ts`文件中的`BucketComponent`内部创建两个名为`onAnimationStarted`和`onAnimationDone`的方法。这些方法将在后续步骤中触发动画的相应阶段：
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now we''ll bind the animation''s `start` and `done` events to the `onAnimateEvent`
    method in the template. Modify the `shared/components/bucket/bucket.component.html`
    file as follows:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将把动画的`start`和`done`事件绑定到模板中的`onAnimateEvent`方法。修改`shared/components/bucket/bucket.component.html`文件如下：
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice that both the `.start` and`.done` events are associated with the trigger
    name, `listAnimation`. If you refresh the app now, you should see the logs on
    the console as follows:![Figure 4.7 – Logs on the console reflecting the .start
    and .done animation events
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，`.start`和`.done`事件都与触发器名称`listAnimation`相关联。如果现在刷新应用程序，你应该会在控制台上看到如下日志：![图4.7-控制台上反映.start和.done动画事件的日志
- en: '](image/Figure_4.07_B15150.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.07_B15150.jpg)'
- en: Figure 4.7 – Logs on the console reflecting the .start and .done animation events
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7-控制台上反映.start和.done动画事件的日志
- en: 'Since we have the events in place now, we''ll replace the `shopping_cart` icon
    with the save icon during the animation. This is similar to simulating what would
    happen if we needed to do an HTTP call to save the data. Let''s modify `shared/components/bucket/bucket.component.ts`
    as follows:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们现在已经有了事件，我们将在动画期间用保存图标替换`shopping_cart`图标。这类似于模拟如果我们需要进行HTTP调用来保存数据会发生什么。让我们修改`shared/components/bucket/bucket.component.ts`如下：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, we can modify our template to show the appropriate icon based on the
    value of the `isSaving` property. The code should look as follows:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以修改我们的模板，根据`isSaving`属性的值显示相应的图标。代码应该如下所示：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: And boom! The recipe is finished now. If you refresh the page or add/delete
    an item, you'll notice that the bucket icon is replaced with the save icon during
    the entire animation, all thanks to the animation callbacks.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 砰！食谱现在已经完成。如果刷新页面或添加/删除项目，你会注意到在整个动画过程中，桶图标都被保存图标替换，这都归功于动画回调。
- en: How it works…
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When an animation is registered with Angular using the `trigger` method, Angular
    itself creates a local property within the scope with the name of the trigger
    set as `@triggerName`. It also creates the `.start` and `.done` sub-properties
    as `EventEmitter` instances for the animation. Therefore, we can easily use them
    in the templates to capture the `AnimationEvent` instance passed by Angular. Each
    `AnimationEvent` contains the `phaseName` property, using which we can also identify
    whether it is the `start` event or the `done` event. We can also tell from `AnimationEvent`
    which state the animation started from and which state it ended on.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`trigger`方法在Angular中注册动画时，Angular本身会在作用域内创建一个名为`@triggerName`的本地属性。它还为动画创建了`.start`和`.done`子属性作为`EventEmitter`实例。因此，我们可以轻松地在模板中使用它们来捕获Angular传递的`AnimationEvent`实例。每个`AnimationEvent`包含`phaseName`属性，我们可以使用它来识别是`start`事件还是`done`事件。我们还可以从`AnimationEvent`中了解动画从哪个状态开始和结束在哪个状态。
- en: See also
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Animations in Angular ([https://angular.io/guide/animations](https://angular.io/guide/animations))
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular中的动画（[https://angular.io/guide/animations](https://angular.io/guide/animations)）
- en: AnimationEvent docs ([https://angular.io/api/animations/AnimationEvent](https://angular.io/api/animations/AnimationEvent))
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AnimationEvent文档（[https://angular.io/api/animations/AnimationEvent](https://angular.io/api/animations/AnimationEvent)）
- en: Basic route animations in Angular
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Angular中进行基本的路由动画
- en: In this recipe, you'll learn how to implement basic route animations in Angular.
    Although these are basic animations, they require a bit of a setup to be executed
    properly. You'll learn how to configure route animations by passing the transition
    state name to the route as a data property. You'll also learn how to use the `RouterOutlet`
    API to get the transition name and apply it to the animation to be executed.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，您将学习如何在Angular中实现基本的路由动画。虽然这些是基本动画，但它们需要一些设置才能正确执行。您将学习如何通过将转换状态名称传递给路由作为数据属性来配置路由动画。您还将学习如何使用`RouterOutlet`
    API来获取转换名称并将其应用于要执行的动画。
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The project that we are going to work with resides in `chapter04/start_here/route-animations`
    inside the cloned repository:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要处理的项目位于克隆存储库内的`chapter04/start_here/route-animations`中：
- en: Open the project in Visual Studio Code.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab, and you should see something
    like the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器选项卡中打开应用程序，您应该看到类似以下内容的内容：
- en: '![Figure 4.8 – route-animations app running on http://localhost:4200'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.8 - route-animations应用程序正在http://localhost:4200上运行'
- en: '](image/Figure_4.08_B15150.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.08_B15150.jpg)'
- en: Figure 4.8 – route-animations app running on http://localhost:4200
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 - route-animations应用程序正在http://localhost:4200上运行
- en: Now that we have the app running locally, let's see the steps of the recipe
    in the next section.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序在本地运行，让我们在下一节中看看这个教程的步骤。
- en: How to do it…
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We have a really simple app with two lazy-loaded routes at the moment. The
    routes are for the **Home** and the **About** pages, and we''ll now start configuring
    the animations for the app:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有一个非常简单的应用程序，其中有两个惰性加载的路由。这些路由是**主页**和**关于**页面，现在我们将开始为应用程序配置动画：
- en: 'First, we need to import `BrowserAnimationsModule` into `app.module.ts` as
    an import. The code should look as follows:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将`BrowserAnimationsModule`导入`app.module.ts`作为导入。代码应如下所示：
- en: '[PRE39]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We''ll now create a new folder inside the `app` folder named `constants`. We''ll
    also create a file inside the `constants` folder named `animations.ts`. Let''s
    put the following code in the `animations.ts` file to register a simple trigger:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在`app`文件夹内创建一个名为`constants`的新文件夹。我们还将在`constants`文件夹内创建一个名为`animations.ts`的文件。让我们将以下代码放入`animations.ts`文件中以注册一个简单的触发器：
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We''ll now register our queries and our states for the animations. Let''s add
    the following items in the `transition()` method''s array as follows:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将注册我们的查询和动画的状态。让我们在`transition()`方法的数组中添加以下项目：
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Alright! We have the `routeAnimation` trigger registered now for transition
    from every route to every other route. Now, let's provide those transition states
    in the routes.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！我们现在已经为从每个路由到其他每个路由的过渡注册了`routeAnimation`触发器。现在，让我们在路由中提供这些过渡状态。
- en: 'We can provide the states for the transitions using a unique identifier for
    each route. There are many ways to do it, but the easiest way is to provide it
    using the `data` attribute in the route configuration as follows in `app-routing.module.ts`:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用每个路由的唯一标识符为过渡提供状态。有许多方法可以做到这一点，但最简单的方法是在`app-routing.module.ts`中的路由配置中使用`data`属性进行提供，如下所示：
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, we need to provide this `transitionState` property from the current route
    to the `@routeAnimation` trigger somehow in `app.component.html`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要以某种方式从当前路由向`app.component.html`中的`@routeAnimation`触发器提供`transitionState`属性。
- en: 'For this, create a `@ViewChild` instance for the `<router-outlet>` element
    used in `app.component.html` so we can get the current route''s `data` and the
    `transitionState` value provided. The code in the `app.component.ts` file should
    look as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，在`app.component.html`中使用的`<router-outlet>`元素创建一个`@ViewChild`实例，以便我们可以获取当前路由的`data`和提供的`transitionState`值。`app.component.ts`文件中的代码应如下所示：
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We''ll also import `ROUTE_ANIMATION` from the `animations.ts` file into `app.component.ts`
    as follows:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将从`animations.ts`文件中将`ROUTE_ANIMATION`导入到`app.component.ts`中，如下所示：
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We''ll now create a function named `getRouteAnimationTransition()`, which will
    get the current route''s data and the `transitionState` value and return it back.
    This function will later be used in `app.component.html`. Modify your code in
    `app.component.ts` as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建一个名为`getRouteAnimationTransition()`的函数，它将获取当前路由的数据和`transitionState`值并将其返回。稍后将在`app.component.html`中使用此函数。按照以下方式修改`app.component.ts`中的代码：
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, let''s use the `getRouteAnimationState()` method with the `@routeAnimation`
    trigger in `app.component.html` so we can see the animation in play:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们在`app.component.html`中使用`getRouteAnimationState()`方法与`@routeAnimation`触发器，以便我们可以看到动画的播放：
- en: '[PRE46]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Voila! Refresh the app and see the magic in place. You should now see the fade-out
    and fade-in animations happening as you navigate from the **Home** page to the
    **About** page and vice versa.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 看哪！刷新应用程序，看到魔法发生。现在，当您从**主页**导航到**关于**页面，反之亦然，您应该看到淡出和淡入动画发生。
- en: How it works…
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the `animations.ts` file, we first defined our animation trigger named `routeAnimation`.
    Then we made sure that by default, the HTML element to which the trigger is assigned
    has `position: ''relative''` set as a style:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '在`animations.ts`文件中，我们首先定义了名为`routeAnimation`的动画触发器。然后，我们确保将触发器分配给的HTML元素默认具有`position:
    ''relative''`作为样式：'
- en: '[PRE47]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then we apply the styled `position: ''absolute''` to the children, as mentioned,
    using `:enter` and `:leave` as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，我们按照以下方式使用`:enter`和`:leave`将样式化的`position: ''absolute''应用于子元素，如下所示：'
- en: '[PRE48]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This makes sure that these elements, that is, the routes to be loaded, have
    the `position: ''absolute''` style and a full width using `width: ''100%''` so
    they can appear on top of each other. You can always fiddle around by commenting
    either of the styles to see what happens (at your own risk, though!).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '这确保了这些元素，也就是要加载的路由，具有 `position: ''absolute''` 样式和使用 `width: ''100%''` 的全宽度，这样它们可以彼此叠加显示。您可以随时尝试注释其中一个样式来查看发生了什么（尽管有风险！）。'
- en: 'Anyway, once the styles are set, we define what will happen to the route that''ll
    enter the view using the `:enter` query. We set the style to have `opacity: 0`
    so it seems like the route is fading in:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '无论如何，一旦样式设置好了，我们就定义了将要进入视图的路由的动作，使用 `:enter` 查询。我们将样式设置为 `opacity: 0`，这样看起来就像路由正在淡入：'
- en: '[PRE49]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we defined our route transitions as a combination of two sequential
    animations, the first for `query :leave` and the second for `query :enter`. For
    the route leaving the view, we set the opacity to `0` via animation, and for the
    route entering the view, we set the opacity to `1` via animation as well:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将我们的路由过渡定义为两个连续动画的组合，第一个是 `query :leave`，第二个是 `query :enter`。对于离开视图的路由，我们通过动画将不透明度设置为
    `0`，对于进入视图的路由，我们也通过动画将不透明度设置为 `1`：
- en: '[PRE50]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: See also
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Animations in Angular ([https://angular.io/guide/animations](https://angular.io/guide/animations))
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular中的动画 ([https://angular.io/guide/animations](https://angular.io/guide/animations))
- en: Angular route transition animations ([https://angular.io/guide/route-animations](https://angular.io/guide/route-animations))
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular路由过渡动画 ([https://angular.io/guide/route-animations](https://angular.io/guide/route-animations))
- en: Complex route animations in Angular using keyframes
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Angular中使用关键帧进行复杂的路由动画
- en: In the previous recipe, you learned how to create basic route animations, and
    in this one, we're going to level up our animation game. In this recipe, you'll
    learn how to implement some complex route animations in Angular using keyframes.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一篇教程中，您学会了如何创建基本的路由动画，在这一篇中，我们将提升我们的动画水平。在这篇教程中，您将学习如何在Angular中使用关键帧实现一些复杂的路由动画。
- en: Getting ready
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `chapter04/start_here/complex-route-animations`
    inside the cloned repository. It is in the same state as the final code of the
    *Basic route animations in Angular* recipe, except we don''t have any animations
    configured yet:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要处理的项目位于克隆存储库中的 `chapter04/start_here/complex-route-animations` 中。它与 *在Angular中进行基本路由动画*
    教程的最终代码处于相同状态，只是我们还没有配置任何动画：
- en: Open the project in Visual Studio Code.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行 `npm install` 来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行 `ng serve -o`。
- en: 'This should open the app in a new browser tab and you should see something
    like the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在新的浏览器标签中打开应用程序，您应该看到类似以下的内容：
- en: '![Figure 4.9 – complex-route-animations app running on http://localhost:4200'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.9 – complex-route-animations 应用程序运行在 http://localhost:4200'
- en: '](image/Figure_4.09_B15150.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.09_B15150.jpg)'
- en: Figure 4.9 – complex-route-animations app running on http://localhost:4200
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 – complex-route-animations 应用程序运行在 http://localhost:4200
- en: Now that we have the app running locally, let's see the steps of the recipe
    in the next section.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序在本地运行，让我们在下一节中看看这个教程的步骤。
- en: How to do it…
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We have a basic app with two routes, the `HomePage` route and the `AboutPage`
    route. Similar to the previous recipe, *Basic route animations in Angular*, we
    have this configured using the route data parameters. But we don''t just have
    any animations written yet. Also, we already have `BrowserAnimationsModule` imported
    in the `app.module.ts` file:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个基本的应用程序，有两个路由，`HomePage`路由和`AboutPage`路由。与之前的食谱*在Angular中的基本路由动画*类似，我们使用路由数据参数进行配置。但是，我们还没有编写任何动画。此外，我们已经在`app.module.ts`文件中导入了`BrowserAnimationsModule`：
- en: 'First, we''ll start by writing a simple animation for the route entering the
    view and for the route leaving the view, as follows, in the `animations.ts` file:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将在`animations.ts`文件中编写一个简单的动画，用于路由进入视图和离开视图，如下所示：
- en: '[PRE51]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You'll notice that we now have fade-in/fade-out animations for the entering
    and leaving routes. However, you'll notice that the entering route doesn't appear
    until the current route has left the view. This is because both our animations
    are running in sequence.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们现在为进入和离开路由都有淡入/淡出的动画。但是，您会注意到进入路由直到当前路由离开视图后才出现。这是因为我们的两个动画都是按顺序运行的。
- en: 'We''ll group the animations for the `:enter` and `:leave` queries using the
    `group` method as follows:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`group`方法对`:enter`和`:leave`查询的动画进行分组，如下所示：
- en: '[PRE52]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, you should see both animations triggering together. Although it doesn't
    look great yet, trust me, it will!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该看到两个动画一起触发。虽然现在看起来不是很好，但相信我，它会的！
- en: 'Stepping up the game, we''ll write a complex animation for our route entering
    the view. We''d like to create a **3D animation**, and therefore, we''ll work
    with some `translateZ()` transformations as well:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提升游戏水平，我们将为我们的路由进入视图编写一个复杂的动画。我们想创建一个**3D动画**，因此，我们将使用一些`translateZ()`转换：
- en: '[PRE53]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If you refresh the app now, you'll be like, "Pffttt, is that 3D, Ahsan? What?"
    Well, it is. However, we only see a sliding animation from left to right. And
    that's because we need to change our *perspective*.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在刷新应用程序，您可能会说：“Pffttt，这是3D吗，Ahsan？怎么回事？”好吧，是的。但是，我们只看到从左到右的滑动动画。这是因为我们需要改变我们的*perspective*。
- en: 'To view all the elements being translated into 3D, we need to apply the `perspective`
    style to the host element for the animation. We''ll do it by adding the `perspective:
    ''1000px''` style in our first `style` definition in the `animations.ts` file:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '要查看所有元素被转换为3D，我们需要将`perspective`样式应用于动画的宿主元素。我们将通过在`animations.ts`文件中的第一个`style`定义中添加`perspective:
    ''1000px''`样式来实现：'
- en: '[PRE54]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: And boom! Now we have the `:enter` query animation in 3D.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 砰！现在我们有了3D的`:enter`查询动画。
- en: 'Now let''s update the animation for the `:leave` query as follows so we can
    see it leaving the view sliding backward in the *z* axis:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们更新`:leave`查询的动画如下，这样我们就可以看到它在*z*轴上向后滑动离开视图：
- en: '[PRE55]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Woot woot! We now have a 3D animation for our routes that looks absolutely stunning.
    And this is, of course, not the end. The sky's the limit when it comes to what
    you can do with keyframes and animations in Angular.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 哇哇！我们现在为我们的路由创建了一个绝对令人惊叹的3D动画。当然，这还不是结束。当涉及到在Angular中使用关键帧和动画时，天空就是限制。
- en: How it works…
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Since we wanted to implement a 3D animation in this recipe, we first made sure
    that the animation host element had a value for the `perspective` style, so we
    can see all the magic in 3D. Then we defined our animations using the `keyframes`
    method with an animation state for each offset so we could set different angles
    and rotations at those states, just so it all looks cool. One important thing
    that we did was group our `:enter` and `:leave` queries using the `group` method,
    where we defined the animations. This made sure that we had the route entering
    and leaving the view simultaneously.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要在这个示例中实现3D动画，我们首先确保动画主机元素具有“透视”样式的值，这样我们就可以在3D中看到所有的魔法。然后我们使用`keyframes`方法定义了我们的动画，每个偏移都有一个动画状态，这样我们可以在这些状态下设置不同的角度和旋转，让一切看起来很酷。我们做的一个重要的事情是使用`group`方法对我们的`:enter`和`:leave`查询进行分组，我们在那里定义了动画。这确保了我们的路由同时进入和离开视图。
- en: See also
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Fireship.io's tutorial on Angular route animations ([https://fireship.io/lessons/angular-router-animations/](https://fireship.io/lessons/angular-router-animations/))
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fireship.io关于Angular路由动画的教程（[https://fireship.io/lessons/angular-router-animations/](https://fireship.io/lessons/angular-router-animations/)）
- en: Angular complex animation sequences ([https://angular.io/guide/complex-animation-sequences](https://angular.io/guide/complex-animation-sequences))
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular复杂动画序列（[https://angular.io/guide/complex-animation-sequences](https://angular.io/guide/complex-animation-sequences)）
