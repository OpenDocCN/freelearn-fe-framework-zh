<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer023">
<h1 class="chapter-number" id="_idParaDest-127"><a id="_idTextAnchor125"/>7</h1>
<h1 id="_idParaDest-128"><a id="_idTextAnchor126"/>Testing useEffect and Mocking Components</h1>
<p>In the previous chapter, you saw how test doubles can be used to verify network requests that occur upon user actions, such as clicking a submit button. We can also use them to verify side effects when our components mount, like when we're fetching data from the server that the component needs to function. In addition, test doubles can be used to verify the rendering of child components. Both use cases often occur together with <strong class="bold">container components</strong>, which are responsible for simply loading data and passing it to another component for display.</p>
<p>In this chapter, we’ll build a new component, <strong class="source-inline">AppointmentsDayViewLoader</strong>, that loads the day’s appointments from the server and passes them to the <strong class="source-inline">AppointmentsDayView</strong> component that we implemented in <a href="B18423_02.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Rendering Lists and Detail Views</em>. By doing so, the user can view a list of appointments occurring today.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Mocking child components</li>
<li>Fetching data on mount with <strong class="source-inline">useEffect</strong></li>
<li>Variants of the <strong class="source-inline">jest.mock</strong> call</li>
</ul>
<p>These are likely the most difficult tasks you’ll encounter while test-driving React components.</p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor127"/>Technical requirements</h1>
<p>The code files for this chapter can be found here: <a href="https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter07">https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter07</a><a href="https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter07%0D%0A"/></p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor128"/>Mocking child components</h1>
<p>In this section, we’re going to<a id="_idIndexMarker744"/> use the <strong class="source-inline">jest.mock</strong> test helper to replace the child component with a dummy implementation. Then, we’ll write expectations that check whether we passed the right props to the child component and that it is correctly rendered on the screen.</p>
<p>But first, let’s take a detailed look at how mocked components work.</p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor129"/>How to mock components, and why?</h2>
<p>The component we’re going to<a id="_idIndexMarker745"/> build in this chapter has the following <a id="_idIndexMarker746"/>shape:</p>
<pre class="source-code">
export const AppointmentsDayViewLoader = ({ today }) =&gt; {
  const [appointments, setAppointments] = useState([]);
  useEffect(() =&gt; {
    // fetch data from the server
    const result = await global.fetch(...);
    // populate the appointments array:
    setAppointments(await result.json());
  }, [today]);
  return (
    &lt;AppointmentsDayView appointments={appointments} /&gt;
  );
};</pre>
<p>Its purpose is to display all the current appointments for a given day. This information is then passed into the component as the <strong class="source-inline">today</strong> prop. The component’s job is to fetch data from the server and then pass it to the <strong class="source-inline">AppointmentsDayView</strong> component, which we built previously and already tested.</p>
<p>Think about the tests we may need. First, we’d want a test to prove that <strong class="source-inline">AppointmentsDayView</strong> loads with no appointments shown initially. Then, we’d want some tests that verify our <strong class="source-inline">global.fetch</strong> call is called successfully, and the returned data is passed into <strong class="source-inline">AppointmentsDayView</strong>.</p>
<p>How do we test that <strong class="source-inline">AppointmentsDayView</strong> is called with the right data? We could repeat some of the tests we have already written in the test suite for <strong class="source-inline">AppointmentsDayView</strong> – for example, by testing that a list of appointments is displayed, and that the relevant appointment data is shown.</p>
<p>However, we’d then be <a id="_idIndexMarker747"/>introducing repetition into our test suites. If we modify how <strong class="source-inline">AppointmentsDayView</strong> works, we’ll have two places to update tests.</p>
<p>An alternative is to mock the <a id="_idIndexMarker748"/>component with a spy object. For this, we can use the <strong class="source-inline">jest.mock</strong> function, in tandem with a spy. This is how it will look:</p>
<pre class="source-code">
jest.mock("../src/AppointmentsDayView", () =&gt; ({
  AppointmentsDayView: jest.fn(() =&gt; (
    &lt;div id="AppointmentsDayView" /&gt;
  )),
}));</pre>
<p>The first argument to the function is the file path that is being mocked. It must match the path that’s passed to the <strong class="source-inline">import</strong> statement. This function is mocking the entire module:</p>
<pre class="source-code">
import { MyComponent } from "some/file/path";
jest.mock("/some/file/path", ...);
describe("something that uses MyComponent", () =&gt; {
});</pre>
<p>In the preceding code, Jest hoists this call to the top of the file and hooks into import logic so that when the <strong class="source-inline">import</strong> statement is run, your mock is returned instead.</p>
<p>Any time <strong class="source-inline">AppointmentsDayView</strong> is referenced in either the test suite or the component under test, you’ll get this mock value rather than the real component. Instead of rendering our day view, we’ll get a single <strong class="source-inline">div</strong> with an <strong class="source-inline">id</strong> value of <strong class="source-inline">AppointmentsDayView</strong>.</p>
<p>The second parameter is the <strong class="bold">module factory parameter</strong>. This is a factory method that is invoked<a id="_idIndexMarker749"/> when the mock is imported. It should return a set of named exports – in our case, this means<a id="_idIndexMarker750"/> a single component, <strong class="source-inline">AppointmentsDayView</strong>. </p>
<p>Because the mock definition is hoisted to the top of the file, you can’t reference any variables in this function: they won’t have been defined by the time your function is run. However, you can write JSX, as we have done here!</p>
<p class="callout-heading">The complexity of component mock setup</p>
<p class="callout">This code is super cryptic, I know. Thankfully, you generally just need to write it once. I often find myself copy-pasting mocks when I need to introduce a new one into a test suite. I’ll look up a previous one I wrote in some other test suite and copy it across, changing the relevant details.</p>
<p>So, now comes the big question: why would you want to do this?</p>
<p>Firstly, using mocks can improve test organization by encouraging multiple test suites with independent surface areas. If both a parent component and its child component are non-trivial components, then having two separate test suites for those components can help reduce the complexity of your test suites.</p>
<p>The parent component’s test suite will contain just a handful of tests to prove that the child component was rendered and passed the expected prop value.</p>
<p>By mocking out the child component in the parent component’s test suite, you are effectively saying, “<em class="italic">I want to ignore this child component right now, but I promise I’ll test its functionality elsewhere!</em>”</p>
<p>A further reason is that you may already have tests for the child component. This is the scenario we find ourselves in: we already have tests for <strong class="source-inline">AppointmentsDayView</strong>, so unless we want to repeat ourselves, it makes sense to mock out the component wherever it’s used.</p>
<p>An extension of this reason is the use of library components. Because someone else built them, you have reason to trust that they’ve been tested and do the right thing. And since they’re library components, chances are they do something quite complex anyway, so rendering them within your tests may have unintended side effects.</p>
<p>Perhaps you have a library component that builds all sorts of elaborate HTML widgets and you don’t want your test <a id="_idIndexMarker751"/>code to know that. Instead, you can treat it as a <strong class="bold">black box</strong>. In that <a id="_idIndexMarker752"/>scenario, it’s preferable to verify the prop values that are passed to the component, again trusting that the component works as advertised.</p>
<p>Library components often have complex component APIs that allow the component to be configured in many ways. Mocking the component allows you to write contract tests that ensure you’re setting up props correctly. We’ll see this later in <a href="B18423_11.xhtml#_idTextAnchor207"><em class="italic">Chapter 11</em></a>, <em class="italic">Test-Driving React Router</em>, when we mock out React Router’s <strong class="source-inline">Link</strong> component.</p>
<p>The final reason to mock components is if they have side effects on mount, such as performing network requests to pull in data. By mocking out the component, your test suite does not need to account for those side effects. We’ll do this in <a href="B18423_08.xhtml#_idTextAnchor147"><em class="italic">Chapter 8</em></a>, <em class="italic">Building an Application Component</em>.</p>
<p>With all that said, let’s start building our new co<a id="_idTextAnchor130"/>mponent.</p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor131"/>Testing the initial component props</h2>
<p>We’ll start by building a test <a id="_idIndexMarker753"/>suite for the new component:</p>
<ol>
<li>Create a new file, <strong class="source-inline">test/AppointmentsDayViewLoader.js</strong>, and add all the following imports. We’re importing not just the component under test (<strong class="source-inline">AppointmentsDayViewLoader</strong>) but also the child component we’ll be mocking (<strong class="source-inline">AppointmentsDayView</strong>):<p class="source-code">import React from "react";</p><p class="source-code">import {</p><p class="source-code">  initializeReactContainer,</p><p class="source-code">  render,</p><p class="source-code">  element,</p><p class="source-code">} from "./reactTestExtensions";</p><p class="source-code">import {</p><p class="source-code">  AppointmentsDayViewLoader</p><p class="source-code">} from "../src/AppointmentsDayViewLoader";</p><p class="source-code">import {</p><p class="source-code">  AppointmentsDayView</p><p class="source-code">} from "../src/AppointmentsDayView";</p></li>
<li>Add the mock setup, just below the imports:<p class="source-code">jest.mock("../src/AppointmentsDayView", () =&gt; ({</p><p class="source-code">  AppointmentsDayView: jest.fn(() =&gt; (</p><p class="source-code">    &lt;div id="AppointmentsDayView" /&gt;</p><p class="source-code">  )),</p><p class="source-code">}));</p></li>
<li>Start with the first test, as <a id="_idIndexMarker754"/>shown here. This checks that the component we just mocked out is rendered. The mock renders a <strong class="source-inline">div</strong> element with an <strong class="source-inline">id</strong> value of <strong class="source-inline">AppointmentsDayView</strong>. The test looks up the <strong class="source-inline">id</strong> value using the <strong class="source-inline">element</strong> helper and checks that it isn’t null:<p class="source-code">describe("AppointmentsDayViewLoader", () =&gt; {</p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    initializeReactContainer();</p><p class="source-code">  });</p><p class="source-code">  it("renders an AppointmentsDayView", () =&gt; {</p><p class="source-code">    await render(&lt;AppointmentsDayViewLoader /&gt;);</p><p class="source-code">    expect(</p><p class="source-code">      element("#AppointmentsDayView")</p><p class="source-code">    ).not.toBeNull();</p><p class="source-code">  });</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Use of the ID attribute</p>
<p class="callout">If you have experience with <strong class="bold">React Testing Library</strong>, you <a id="_idIndexMarker755"/>may have come across the<a id="_idIndexMarker756"/> use of <strong class="source-inline">data-testid</strong> for identifying components. If you want to use these mocking<a id="_idIndexMarker757"/> techniques with React Testing Library, then you can use <strong class="source-inline">data-testid</strong> instead of the <strong class="source-inline">id</strong> attribute, and then find your <a id="_idIndexMarker758"/>element using the <strong class="source-inline">queryByTestId</strong> function.</p>
<p class="callout">Although it’s generally recommended not to rely on <strong class="source-inline">data-testid</strong> for selecting elements within your test suites, that doesn’t apply to mock components. You need IDs to be able to tell them apart because you could end up with more than a few mocked components all rendered by the same parent. Giving an ID to each component is the simplest way to find them for these DOM presence tests. Remember that the mocks will never make it outside of your unit testing environment, so there’s no harm in using IDs.</p>
<p class="callout">For more discussions on mocking strategies with React Testing Library, head over to <a href="https://reacttdd.com/component-mocks-with-react-testing-library/">https://reacttdd.com/mocking-with-react-testing-library</a>.</p>
<ol>
<li value="4">Let’s make that test <a id="_idIndexMarker759"/>pass. Create a new file, <strong class="source-inline">src/AppointmentsDayViewLoader.js</strong>, and go ahead and fill in the implementation, as follows. It does nothing but render the component, which is all the test asked for:<p class="source-code">import React from "react";</p><p class="source-code">import {</p><p class="source-code">  AppointmentsDayView</p><p class="source-code">} from "./AppointmentsDayView";</p><p class="source-code">export const AppointmentsDayViewLoader = () =&gt; (</p><p class="source-code">  &lt;AppointmentsDayView /&gt;</p><p class="source-code">);</p></li>
<li>Time for the next test. We’ll check whether the initial value of the props sent to</li>
</ol>
<p><strong class="source-inline">AppointmentsDayView</strong> is what we expect. We’ll do this by using the <strong class="source-inline">toBeCalledWith</strong> matcher, which we’ve used already. Notice the second parameter value of <strong class="source-inline">expect.anything()</strong>: that’s needed because React passes a second parameter to the component function when it’s rendered. You’ll never need to be <a id="_idIndexMarker760"/>concerned with this in your code – it’s an internal detail of React’s implementation – so we can safely ignore it. We’ll use <strong class="source-inline">expect.anything</strong> to assert that we don’t care what that parameter is:</p>
<p class="source-code">it("initially passes empty array of appointments to AppointmentsDayView", () =&gt; {</p>
<p class="source-code">  await render(&lt;AppointmentsDayViewLoader /&gt;);</p>
<p class="source-code">  expect(AppointmentsDayView).toBeCalledWith(</p>
<p class="source-code">    { appointments: [] },</p>
<p class="source-code">    expect.anything()</p>
<p class="source-code">  );</p>
<p class="source-code">});</p>
<p class="callout-heading">Verifying props and their presence in the DOM</p>
<p class="callout">It’s important to test both props that were passed to the mock and that the stubbed value is rendered in the DOM, as we have done in these two tests. In <a href="B18423_08.xhtml#_idTextAnchor147"><em class="italic">Chapter 8</em></a>, <em class="italic">Building an Application Component</em>, we’ll see a case where we want to check that a mocked component is unmounted after a user action.</p>
<ol>
<li value="6">Make that pass by updating your component definition, as shown here:<p class="source-code">export const AppointmentsDayViewLoader = () =&gt; (</p><p class="source-code">  &lt;AppointmentsDayView <strong class="bold">appointments={[]} </strong>/&gt;</p><p class="source-code">);</p></li>
</ol>
<p>You’ve just used your first <a id="_idIndexMarker761"/>mocked component! You’ve seen how to create the mock, and the two types of tests needed to verify its use. Next, we’ll add a <strong class="source-inline">useEffect</strong> hook to load data when the component is mounted and pass it through to the <strong class="source-inline">appointments</strong> prop.</p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor132"/>Fetching data on mount with useEffect</h1>
<p>The appointment<a id="_idIndexMarker762"/> data we’ll load comes from an endpoint that takes start and end dates. These values filter the result to a specific time range:</p>
<pre class="source-code">
GET /appointments/&lt;from&gt;-&lt;to&gt;</pre>
<p>Our new <a id="_idIndexMarker763"/>component is passed a <strong class="source-inline">today</strong> prop that is a <strong class="source-inline">Date</strong> object with the value of the current time. We will calculate the <strong class="source-inline">from</strong> and <strong class="source-inline">to</strong> dates from the <strong class="source-inline">today</strong> prop and construct a URL to pass to <strong class="source-inline">global.fetch</strong>.</p>
<p>To get there, first, we’ll cover a bit of theory on testing the <strong class="source-inline">useEffect</strong> hook. Then, we’ll implement a new <strong class="source-inline">renderAndWait</strong> function, which we’ll need because we’re invoking a promise when the component is mounted. Finally, we’ll use that function in our new tests, building out the complete <strong class="source-inline">useEffect</strong> implementation.</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/>Understanding the useEffect hook</h2>
<p>The <strong class="source-inline">useEffect</strong> hook is React’s way<a id="_idIndexMarker764"/> of running side effects. The idea is that you provide a function that will run each time any of the hook’s dependencies change. That dependency list is specified as the second parameter to the <strong class="source-inline">useEffect</strong> call.</p>
<p>Let’s take another look<a id="_idIndexMarker765"/> at our example:</p>
<pre class="source-code">
export const AppointmentsDayViewLoader = ({ today }) =&gt; {
  useEffect(() =&gt; {
    // ... code runs here
  }, [today]);
  
  // ... render something
}</pre>
<p>The hook code will run any time the <strong class="source-inline">today</strong> prop changes. This includes when the component first mounts. When we test-drive this, we’ll start with an empty dependency list and then use a specific test to force a refresh when the component is remounted with a new <strong class="source-inline">today</strong> prop value.</p>
<p>The function you pass to <strong class="source-inline">useEffect</strong> should return another function. This function performs teardown: it is called any time the value changes, especially <em class="italic">before</em> the hook function is invoked again, enabling you to cancel any running tasks.</p>
<p>We’ll explore this return<a id="_idIndexMarker766"/> function in detail in <a href="B18423_15.xhtml#_idTextAnchor306"><em class="italic">Chapter 15</em></a>, <em class="italic">Adding Animation</em>. However, for now, you should be aware that this affects how we call promises. We can’t do this:</p>
<pre class="source-code">
useEffect(async () =&gt; { ... }, []);</pre>
<p>Defining the outer function as <strong class="source-inline">async</strong> would mean it returns a promise, not a function. We must do this instead:</p>
<pre class="source-code">
useEffect(() =&gt; {
  const fetchAppointments = async () =&gt; {
    const result = await global.fetch(...);      
    setAppointments(await result.json());
  };
  fetchAppointments();
}, [today]);</pre>
<p>When running tests, if you were to call <strong class="source-inline">global.fetch</strong> directly from within the <strong class="source-inline">useEffect</strong> hook, you’d receive a warning from React. It would alert you that the <strong class="source-inline">useEffect</strong> hook should <a id="_idIndexMarker767"/>not return a promise. </p>
<p class="callout-heading">Using setters inside useEffect Hook functions</p>
<p class="callout">React guarantees that<a id="_idIndexMarker768"/> setters such as <strong class="source-inline">setAppointments</strong> remain static. This means they don’t need to appear in the <strong class="source-inline">useEffect</strong> dependency list.</p>
<p>To get started with our implementation, we’ll need to ensure our tests are ready for render calls that run promises. </p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor134"/>Adding the renderAndWait helper</h2>
<p>Just as we did with <strong class="source-inline">clickAndWait</strong> and <strong class="source-inline">submitAndWait</strong>, now, we need <strong class="source-inline">renderAndWait</strong>. This<a id="_idIndexMarker769"/> will render<a id="_idIndexMarker770"/> the component and then wait for our <strong class="source-inline">useEffect</strong> hook to run, including any promise tasks.</p>
<p>To be clear, this<a id="_idIndexMarker771"/> function is necessary not because of the <strong class="source-inline">useEffect</strong> hook itself – just a normal sync <strong class="source-inline">act</strong> call would ensure that it runs – because of the promise that <strong class="source-inline">useEffect</strong> runs:</p>
<ol>
<li value="1">In <strong class="source-inline">test/reactTestExtensions.js</strong>, add the following function below the definition of <strong class="source-inline">render</strong>:<p class="source-code">export const renderAndWait = (component) =&gt;</p><p class="source-code">  act(async () =&gt; (</p><p class="source-code">    ReactDOM.createRoot(container).render(component)</p><p class="source-code">  )</p><p class="source-code">);</p></li>
<li>Update the import in your test suite so that it references this new function:<p class="source-code">import {</p><p class="source-code">  initializeReactContainer,</p><p class="source-code">  render<strong class="bold">AndWait</strong>,</p><p class="source-code">  element,</p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>Then, update the<a id="_idIndexMarker772"/> first test:<p class="source-code">it("renders an AppointmentsDayView", <strong class="bold">async</strong> () =&gt; {</p><p class="source-code">  await <strong class="bold">renderAndWait</strong>(&lt;AppointmentsDayViewLoader /&gt;);</p><p class="source-code">  expect(</p><p class="source-code">    element("#AppointmentsDayView")</p><p class="source-code">  ).not.toBeNull();</p><p class="source-code">});</p></li>
<li>Add the second<a id="_idIndexMarker773"/> test, which checks that we send an empty array of appointments to <strong class="source-inline">AppointmentsDayView</strong> before the server has returned any data:<p class="source-code">it("initially passes empty array of appointments to AppointmentsDayView", <strong class="bold">async</strong> () =&gt; {</p><p class="source-code">  await <strong class="bold">renderAndWait</strong>(&lt;AppointmentsDayViewLoader /&gt;);</p><p class="source-code">  expect(AppointmentsDayView).toBeCalledWith(</p><p class="source-code">    { appointments: [] },</p><p class="source-code">    expect.anything()</p><p class="source-code">  );</p><p class="source-code">});</p></li>
</ol>
<p>Make sure to check that these tests are passing before you continue.</p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor135"/>Adding the useEffect hook</h2>
<p>We’re about to introduce<a id="_idIndexMarker774"/> a <strong class="source-inline">useEffect</strong> hook with a call to <strong class="source-inline">global.fetch</strong>. We’ll start by mocking that call using <strong class="source-inline">jest.spyOn</strong>. Then, we’ll continue with the test:</p>
<ol>
<li value="1">Add the following new imports to the top of the test suite:<p class="source-code">import { todayAt } from "./builders/time";</p><p class="source-code">import { fetchResponseOk } from "./builders/fetch";</p></li>
<li>Define a sample set of appointments at the top of the <strong class="source-inline">describe</strong> block:<p class="source-code">describe("AppointmentsDayViewLoader", () =&gt; {</p><p class="source-code">  const appointments = [</p><p class="source-code">    { startsAt: todayAt(9) },</p><p class="source-code">    { startsAt: todayAt(10) },</p><p class="source-code">  ];</p><p class="source-code">  ...</p><p class="source-code">});</p></li>
<li>To set up <strong class="source-inline">global.fetch</strong> so that it returns this sample array, modify the test suite’s <strong class="source-inline">beforeEach</strong> block, as shown here:<p class="source-code">beforeEach(() =&gt; {</p><p class="source-code">  initializeReactContainer();</p><p class="source-code"><strong class="bold">  jest</strong></p><p class="source-code"><strong class="bold">    .spyOn(global, "fetch")</strong></p><p class="source-code"><strong class="bold">    .mockResolvedValue(fetchResponseOk(appointments));</strong></p><p class="source-code">});</p></li>
<li>It’s time for our test. We assert that when the component is mounted, we should expect to see a call to <strong class="source-inline">global.fetch</strong> being made with the right parameters. Our test calculates what the right parameter values should be – it should be from <a id="_idIndexMarker775"/>midnight today to midnight tomorrow:<p class="source-code">it("fetches data when component is mounted", async () =&gt; {</p><p class="source-code">  const from = todayAt(0);</p><p class="source-code">  const to = todayAt(23, 59, 59, 999);</p><p class="source-code">  await renderAndWait(</p><p class="source-code">    &lt;AppointmentsDayViewLoader today={today} /&gt;</p><p class="source-code">  );</p><p class="source-code">  expect(global.fetch).toBeCalledWith(</p><p class="source-code">    `/appointments/${from}-${to}`,</p><p class="source-code">    {</p><p class="source-code">      method: "GET",</p><p class="source-code">      credentials: "same-origin",</p><p class="source-code">      headers: { "Content-Type": "application/json" },</p><p class="source-code">    }</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>To make this test <a id="_idIndexMarker776"/>pass, first, we’ll need to introduce a <strong class="source-inline">useEffect</strong> hook into the component file:<p class="source-code">import React<strong class="bold">, { useEffect }</strong> from "react";</p></li>
<li>Now, we can update the component to make the call, as follows. Although this is a lot of code already, notice how we aren’t making use of the <strong class="source-inline">return</strong> value yet: there’s no state being stored and <strong class="source-inline">AppointmentsDayView</strong> still has its <strong class="source-inline">appointments</strong> prop<a id="_idIndexMarker777"/> set to an empty array. We’ll fill that<a id="_idIndexMarker778"/> in later:<p class="source-code">export const AppointmentsDayViewLoader = (</p><p class="source-code"><strong class="bold">  { today }</strong></p><p class="source-code">) =&gt; {</p><p class="source-code">  <strong class="bold">useEffect(() =&gt; {</strong></p><p class="source-code"><strong class="bold">    const from = today.setHours(0, 0, 0, 0);</strong></p><p class="source-code"><strong class="bold">    const to = today.setHours(23, 59, 59, 999);</strong></p><p class="source-code"><strong class="bold">    const fetchAppointments = async () =&gt; {</strong></p><p class="source-code"><strong class="bold">      await global.fetch(</strong></p><p class="source-code"><strong class="bold">        `/appointments/${from}-${to}`,</strong></p><p class="source-code"><strong class="bold">        {</strong></p><p class="source-code"><strong class="bold">          method: "GET",</strong></p><p class="source-code"><strong class="bold">          credentials: "same-origin",</strong></p><p class="source-code"><strong class="bold">          headers: {</strong></p><p class="source-code"><strong class="bold">            "Content-Type": "application/json" </strong></p><p class="source-code"><strong class="bold">          },</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code"><strong class="bold">      );</strong></p><p class="source-code"><strong class="bold">    };</strong></p><p class="source-code"><strong class="bold">    fetchAppointments();</strong></p><p class="source-code"><strong class="bold">  }, [])</strong>;</p><p class="source-code">  return &lt;AppointmentsDayView appointments={[]} /&gt;;</p><p class="source-code">};</p></li>
<li>Before<a id="_idIndexMarker779"/> continuing with the next test, let’s set a default value for the <strong class="source-inline">today</strong> prop so that any callers <a id="_idIndexMarker780"/>don’t need to specify this:<p class="source-code">AppointmentsDayViewLoader.defaultProps = {</p><p class="source-code">  today: new Date(),</p><p class="source-code">};</p></li>
<li>The next test will ensure we use the return value of our <strong class="source-inline">global.fetch</strong> call. Notice how we <a id="_idIndexMarker781"/>use the <strong class="source-inline">toHaveBeenLastCalledWith</strong> matcher. This is important because the first render of the component will be an empty array. It’s the second call that<a id="_idIndexMarker782"/> will contain data:<p class="source-code">it("passes fetched appointments to AppointmentsDayView once they have loaded", async () =&gt; {</p><p class="source-code">  await renderAndWait(&lt;AppointmentsDayViewLoader /&gt;);</p><p class="source-code">  </p><p class="source-code">  expect(</p><p class="source-code">    AppointmentsDayView</p><p class="source-code">  ).toHaveBeenLastCalledWith(</p><p class="source-code">    { appointments },</p><p class="source-code">    expect.anything()</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>To make that pass, first, update your component’s <strong class="source-inline">import</strong> to pull in the <strong class="source-inline">useState</strong> function:<p class="source-code">import React, { useEffect, <strong class="bold">useState</strong> } from "react";</p></li>
<li>Now, update your <a id="_idIndexMarker783"/>component’s definition, as shown here:<p class="source-code">export const AppointmentsDayViewLoader = (</p><p class="source-code">  { today }</p><p class="source-code">) =&gt; {</p><p class="source-code">  <strong class="bold">const [</strong></p><p class="source-code"><strong class="bold">    appointments, setAppointments</strong></p><p class="source-code"><strong class="bold">  ] = useState([]);</strong></p><p class="source-code">  useEffect(() =&gt; {</p><p class="source-code">    ...</p><p class="source-code">    const fetchAppointments = async () =&gt; {</p><p class="source-code"><strong class="bold">      const result = </strong>await global.fetch(</p><p class="source-code">        ...</p><p class="source-code">      );</p><p class="source-code"><strong class="bold">      setAppointments(await result.json());</strong></p><p class="source-code">    };</p><p class="source-code">    fetchAppointments();</p><p class="source-code">  }, []);</p><p class="source-code">  return (</p><p class="source-code">    &lt;AppointmentsDayView</p><p class="source-code">      appointments={<strong class="bold">appointments</strong>}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">};</p></li>
</ol>
<p>This completes the basic <strong class="source-inline">useEffect</strong> implementation – our component is now loading data. However, there’s a final piece<a id="_idIndexMarker784"/> we must address with the <strong class="source-inline">useEffect</strong> implementation.</p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor136"/>Testing the useEffect dependency list</h2>
<p>The second parameter to the <strong class="source-inline">useEffect</strong> call is a <a id="_idIndexMarker785"/>dependency list that defines the variables that should cause the effect to be re-evaluated. In our case, the <strong class="source-inline">today</strong> prop is <a id="_idIndexMarker786"/>the important one. If the component is re-rendered with a new value for <strong class="source-inline">today</strong>, then we should pull down new appointments from the server.</p>
<p>We’ll write a test that renders a component twice. This kind of test is very important any time you’re using the <strong class="source-inline">useEffect</strong> hook. To support that, we’ll need to adjust our render functions to ensure they only create one root:</p>
<ol>
<li value="1">In <strong class="source-inline">test/reactTestExtensions.js</strong>, add a new top-level variable called <strong class="source-inline">reactRoot</strong> and update <strong class="source-inline">initializeReactContainer</strong> to set this variable:<p class="source-code">export let container;</p><p class="source-code"><strong class="bold">let reactRoot;</strong></p><p class="source-code">export const initializeReactContainer = () =&gt; {</p><p class="source-code">   container = document.createElement("div");</p><p class="source-code">   document.body.replaceChildren(container);</p><p class="source-code"><strong class="bold">  reactRoot = ReactDOM.createRoot(container);</strong></p><p class="source-code">};</p></li>
<li>Now, update the definitions of <strong class="source-inline">render</strong> and <strong class="source-inline">renderAndWait</strong> so that they use this <strong class="source-inline">reactRoot</strong> variable. After<a id="_idIndexMarker787"/> making this change, you’ll be able to re-mount components within a single test:<p class="source-code">export const render = (component) =&gt;</p><p class="source-code">  act(() =&gt; <strong class="bold">reactRoot.render</strong>(component));</p><p class="source-code">export const renderAndWait = (component) =&gt;</p><p class="source-code">  act(async () =&gt; <strong class="bold">reactRoot.render</strong>(component));</p></li>
<li>Back in your test<a id="_idIndexMarker788"/> suite, update <strong class="source-inline">import</strong> so that it includes <strong class="source-inline">today</strong>, <strong class="source-inline">tomorrow</strong>, and <strong class="source-inline">tomorrowAt</strong>. We’ll use <a id="_idIndexMarker789"/>these in the<a id="_idIndexMarker790"/> next test:<p class="source-code">import {</p><p class="source-code"><strong class="bold">  today,</strong></p><p class="source-code">  todayAt,</p><p class="source-code"><strong class="bold">  tomorrow,</strong></p><p class="source-code"><strong class="bold">  tomorrowAt</strong></p><p class="source-code">} from "./builders/time";</p></li>
<li>Now, add the test. This renders the component twice, with two separate values for the <strong class="source-inline">today</strong> prop. Then, it checks<a id="_idIndexMarker791"/> whether <strong class="source-inline">global.fetch</strong> was called twice:<p class="source-code">it("re-requests appointment when today prop changes", async () =&gt; {</p><p class="source-code">  const from = tomorrowAt(0);</p><p class="source-code">  const to = tomorrowAt(23, 59, 59, 999);</p><p class="source-code">  await renderAndWait(</p><p class="source-code">    &lt;AppointmentsDayViewLoader today={today} /&gt;</p><p class="source-code">  );</p><p class="source-code">  await renderAndWait(</p><p class="source-code">    &lt;AppointmentsDayViewLoader today={tomorrow} /&gt;</p><p class="source-code">  );</p><p class="source-code">  expect(global.fetch).toHaveBeenLastCalledWith(</p><p class="source-code">    `/appointments/${from}-${to}`,</p><p class="source-code">    expect.anything()</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>If you<a id="_idIndexMarker792"/> run the test <a id="_idIndexMarker793"/>now, you’ll <a id="_idIndexMarker794"/>see that <strong class="source-inline">global.fetch</strong> is<a id="_idIndexMarker795"/> only being <a id="_idIndexMarker796"/>called <a id="_idIndexMarker797"/>once:<p class="source-code">    AppointmentsDayViewLoader ' re-requests appointment when today prop changes</p><p class="source-code">    expect(</p><p class="source-code">      jest.fn()</p><p class="source-code">    ).toHaveBeenLastCalledWith(...expected)</p><p class="source-code">    Expected: "/appointments/1643932800000-1644019199999", Anything</p><p class="source-code">    Received: "/appointments/1643846400000-1643932799999", {"credentials": "same-origin", "headers": {"Content-Type": "application/json"}, "method": "GET"}</p></li>
<li>Making it pass is a<a id="_idIndexMarker798"/> one-word change. Find the second parameter of the <strong class="source-inline">useEffect</strong> call and change it from an empty array, as shown here:<p class="source-code">useEffect(() =&gt; {</p><p class="source-code">  ...</p><p class="source-code">}, [<strong class="bold">today</strong>]);</p></li>
</ol>
<p>That’s it for the implementation of this component. In the next section, we’ll clean up our test code with a new matcher.</p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor137"/>Building matchers for component mocks</h1>
<p>In this section, we’ll introduce a <a id="_idIndexMarker799"/>new matcher, <strong class="source-inline">toBeRenderedWithProps</strong>, that simplifies the expectations<a id="_idIndexMarker800"/> for our mock spy object. </p>
<p>Recall that our expectations look like this:</p>
<pre class="source-code">
expect(AppointmentsDayView).toBeCalledWith(
  { appointments },
  expect.anything()
);</pre>
<p>Imagine if you were working on a team that had tests like this. Would a new joiner understand what that second argument, <strong class="source-inline">expect.anything()</strong>, is doing? Will <em class="italic">you</em> understand what this is doing if you don’t go away for a while and forget how component mocks work?</p>
<p>Let’s wrap that into a matcher that allows us to hide the second property.</p>
<p>We need <em class="italic">two</em> matchers to cover the common use cases. The first, <strong class="source-inline">toBeRenderedWithProps</strong>, is the one we’ll <a id="_idIndexMarker801"/>work through in this chapter. The second, <strong class="source-inline">toBeFirstRenderedWithProps</strong>, is left as an <a id="_idIndexMarker802"/>exercise for you.</p>
<p>The matcher, <strong class="source-inline">toBeRenderedWithProps</strong>, will pass if the component is <em class="italic">currently rendered</em> with the given props. This function <a id="_idIndexMarker803"/>will be equivalent to using the <strong class="source-inline">toHaveBeenLastCalledWith</strong> matcher.</p>
<p>The essential part of this matcher is when it pulls out the last element of the <strong class="source-inline">mock.calls</strong> array:</p>
<pre class="source-code">
const mockedCall =
  mockedComponent.mock.calls[
    mockedComponent.mock.calls.length – 1
  ];</pre>
<p class="callout-heading">The mock.calls array</p>
<p class="callout">Recall that every mock function that’s created with <strong class="source-inline">jest.spyOn</strong> or <strong class="source-inline">jest.fn</strong> will have a <strong class="source-inline">mock.calls</strong> property, which is an array of all the calls. This was covered in <a href="B18423_06.xhtml#_idTextAnchor099"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring Test Doubles</em>.</p>
<p>The second matcher is <strong class="source-inline">toBeFirstRenderedWithProps</strong>. This will be useful for any test that checks the<a id="_idIndexMarker804"/> initial value of the child props and before any <strong class="source-inline">useEffect</strong> hooks have run. Rather than picking the last element of the <strong class="source-inline">mock.calls</strong> array, we’ll just pick the first:</p>
<pre class="source-code">
const mockedCall = mockedComponent.mock.calls[0];</pre>
<p>Let’s get started with <strong class="source-inline">toBeRenderedWithProps</strong>:</p>
<ol>
<li value="1">Create a new matcher test file at <strong class="source-inline">test/matchers/toBeRenderedWithProps.test.js</strong>. Add the following imports:<p class="source-code">import React from "react";</p><p class="source-code">import {</p><p class="source-code">  toBeRenderedWithProps,</p><p class="source-code">} from "./toBeRenderedWithProps";</p><p class="source-code">import {</p><p class="source-code">  initializeReactContainer,</p><p class="source-code">  render,</p><p class="source-code">} from "../reactTestExtensions";</p></li>
<li>Add the following<a id="_idIndexMarker805"/> test setup. Since our tests will be operating on a spy function, we can set that up in our <strong class="source-inline">beforeEach</strong> block, as shown here:<p class="source-code">describe("toBeRenderedWithProps", () =&gt; {</p><p class="source-code">  let Component;</p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    initializeReactContainer();</p><p class="source-code">    Component = jest.fn(() =&gt; &lt;div /&gt;);</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>As usual, our first test is to check that <strong class="source-inline">pass</strong> returns <strong class="source-inline">true</strong>. Notice how we must render the <a id="_idIndexMarker806"/>component before we call the matcher:<p class="source-code">it("returns pass is true when mock has been rendered", () =&gt; {</p><p class="source-code">  render(&lt;Component /&gt;);</p><p class="source-code">  const result = toBeRenderedWithProps(Component, {});</p><p class="source-code">  expect(result.pass).toBe(true);</p><p class="source-code">});</p></li>
<li>To make this pass, create a <a id="_idIndexMarker807"/>new file for the matcher, <strong class="source-inline">test/matchers/toBeRenderedWithProps.js</strong>, and add the following implementation:<p class="source-code">export const toBeRenderedWithProps = (</p><p class="source-code">  mockedComponent,</p><p class="source-code">  expectedProps</p><p class="source-code">) =&gt; ({  pass: true });</p></li>
<li>It’s time to triangulate. For the next test, let’s check that <strong class="source-inline">pass</strong> is <strong class="source-inline">false</strong> when we don’t render the component before calling it:<p class="source-code">it("returns pass is false when the mock has not been rendered", () =&gt; {</p><p class="source-code">  const result = toBeRenderedWithProps(Component, {});</p><p class="source-code">  expect(result.pass).toBe(false);</p><p class="source-code">});</p></li>
<li>To get the test to green, all we’ve got to do is check that the mock was called at least once:<p class="source-code">export const toBeRenderedWithProps = (</p><p class="source-code">  mockedComponent,</p><p class="source-code">  expectedProps</p><p class="source-code">) =&gt; ({</p><p class="source-code">  pass: mockedComponent.mock.calls.length &gt; 0,</p><p class="source-code">});</p></li>
<li>Next, we’ll need to check that <strong class="source-inline">pass</strong> is <strong class="source-inline">false</strong> if the props don’t match. We can’t write the <a id="_idIndexMarker808"/>opposite test – that <strong class="source-inline">pass</strong> is <strong class="source-inline">true</strong> if the props match – because that test would already pass, given our current implementation:<p class="source-code">it("returns pass is false when the properties do not match", () =&gt; {</p><p class="source-code">  render(&lt;Component a="b" /&gt;);</p><p class="source-code">  const result = toBeRenderedWithProps(</p><p class="source-code">    Component, {</p><p class="source-code">      c: "d",</p><p class="source-code">    }</p><p class="source-code">  );</p><p class="source-code">  expect(result.pass).toBe(false);</p><p class="source-code">});</p></li>
<li>For the component code, we’ll <a id="_idIndexMarker809"/>use the <strong class="source-inline">equals</strong> function from<a id="_idIndexMarker810"/> inside the <strong class="source-inline">expect-utils</strong> package, which<a id="_idIndexMarker811"/> is already installed as part of Jest. This tests for deep equality but also allows you to make use of <strong class="source-inline">expect</strong> helpers such as <strong class="source-inline">expect.anything</strong> and <strong class="source-inline">expect.objectContaining</strong>:<p class="source-code">import { equals } from "@jest/expect-utils";</p><p class="source-code">export const toBeRenderedWithProps = (</p><p class="source-code">  mockedComponent,</p><p class="source-code">  expectedProps</p><p class="source-code">) =&gt; {</p><p class="source-code">  const mockedCall = mockedComponent.mock.calls[0];</p><p class="source-code">  const actualProps = mockedCall ?</p><p class="source-code">    mockedCall[0] : null;</p><p class="source-code">  const pass = equals(actualProps, expectedProps);</p><p class="source-code">  return { pass };</p><p class="source-code">};</p></li>
<li>For our final <a id="_idIndexMarker812"/>test, we want an example that shows that this matcher works that the expectation will match on the last rendering of the mock:<p class="source-code">it("returns pass is true when the properties of the last render match", () =&gt; {</p><p class="source-code">  render(&lt;Component a="b" /&gt;);</p><p class="source-code">  render(&lt;Component c="d" /&gt;);</p><p class="source-code">  const result = toBeRenderedWithProps(</p><p class="source-code">    Component,</p><p class="source-code">    { c: "d" }</p><p class="source-code">  );</p><p class="source-code">  expect(result.pass).toBe(true);</p><p class="source-code">});</p></li>
<li>To make that pass, we <a id="_idIndexMarker813"/>need to update the implementation so that it chooses the last element of the <strong class="source-inline">mock.calls</strong> array, rather than the first:<p class="source-code">export const toBeRenderedWithProps = (</p><p class="source-code">  mockedComponent,</p><p class="source-code">  expectedProps</p><p class="source-code">) =&gt; {</p><p class="source-code">  const mockedCall =</p><p class="source-code"><strong class="bold">    mockedComponent.mock.calls[</strong></p><p class="source-code"><strong class="bold">      mockedComponent.mock.calls.length – 1</strong></p><p class="source-code"><strong class="bold">    ];</strong></p><p class="source-code">  ...</p><p class="source-code">};</p></li>
<li>We’ll leave our implementation here. Completing the tests for the message property is left as an exercise for you, but they follow the same order as the tests shown in <a href="B18423_03.xhtml#_idTextAnchor053"><em class="italic">Chapter 3</em></a>, <em class="italic">Refactoring the Test Suite</em>. For now, move to <strong class="source-inline">test/domMatchers.js</strong> and register <a id="_idIndexMarker814"/>your new matcher:<p class="source-code">import {</p><p class="source-code">  toBeRenderedWithProps,</p><p class="source-code">} from "./matchers/toBeRenderedWithProps";</p><p class="source-code">expect.extend({</p><p class="source-code">  ...,</p><p class="source-code">  toBeRenderedWithProps,</p><p class="source-code">});</p></li>
<li>Finally, back in your test <a id="_idIndexMarker815"/>suite, update the test that checks the <strong class="source-inline">appointments</strong> prop. It should look as follows; it’s much nicer<a id="_idIndexMarker816"/> now that the <strong class="source-inline">expect.anything</strong> parameter value has gone:<p class="source-code">it("passes fetched appointments to AppointmentsDayView once they have loaded", async () =&gt; {</p><p class="source-code">  await renderAndWait(&lt;AppointmentsDayViewLoader /&gt;);</p><p class="source-code">  expect(AppointmentsDayView).<strong class="bold">toBeRenderedWithProps({</strong></p><p class="source-code"><strong class="bold">    appointments,</strong></p><p class="source-code"><strong class="bold">  });</strong></p><p class="source-code">});</p></li>
</ol>
<p>With that, you’ve learned how to build a matcher for component mocks, which reduces the verbiage that we originally had when we used the built-in <strong class="source-inline">toBeCalledWith</strong> matcher.</p>
<p>The other test in this test suite needs a<a id="_idIndexMarker817"/> second matcher, <strong class="source-inline">toBeFirstRenderedWithProps</strong>. The implementation of this is left as an exercise for you. </p>
<p>In the next section, we’ll look at a variety of ways that component mocks can become more complicated.</p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor138"/>Variants of the jest.mock call</h1>
<p>Before we finish<a id="_idIndexMarker818"/> up this chapter, let’s take a look at some variations on the <strong class="source-inline">jest.mock</strong> call that you may end up using.</p>
<p>The key thing to remember is to <em class="italic">keep your mocks as simple as possible</em>. If you start to feel like your mocks need to become more complex, you should treat that as a sign that your components are overloaded and should be broken apart in some way.</p>
<p>That being said, there are cases where you must use different forms of the basic component <a id="_idIndexMarker819"/>mock.</p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor139"/>Removing the spy function</h2>
<p>To begin with, you <a id="_idIndexMarker820"/>can simplify your <strong class="source-inline">jest.mock</strong> calls by not <a id="_idIndexMarker821"/>using <strong class="source-inline">jest.fn</strong>:</p>
<pre class="source-code">
jest.mock("../src/AppointmentsDayView", () =&gt; ({
  AppointmentsDayView: () =&gt; (
    &lt;div id="AppointmentsDayView" /&gt;
  ),
}));</pre>
<p>With this form, you’ve set a stub return value, but you won’t be able to spy on any props. This is sometimes useful if, for example, you’ve got multiple files that are testing this same component but only some of them verify the mocked component props. It can also be useful with third-party components.</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor140"/>Rendering the children of mocked components</h2>
<p>Sometimes, you’ll want to <a id="_idIndexMarker822"/>render grandchild components, skipping <a id="_idIndexMarker823"/>out the child (their parent). This often happens, for example, when a third-party component renders a complex UI that is difficult to test: perhaps it loads elements via the shadow DOM, for example. In that case, you can pass <strong class="source-inline">children</strong> through your mock:</p>
<pre class="source-code">
jest.mock("../src/AppointmentsDayView", () =&gt; ({
  AppointmentsDayView: jest.fn(({ children }) =&gt; (
    &lt;div id="AppointmentsDayView"&gt;{children}&lt;/div&gt;
  )),
}));</pre>
<p>We will see examples of this in <a href="B18423_11.xhtml#_idTextAnchor207"><em class="italic">Chapter 11</em></a>, <em class="italic">Test-Driving React Router</em>.</p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor141"/>Checking multiple instances of the rendered component</h2>
<p>There are occasions when<a id="_idIndexMarker824"/> you’ll want to mock a component that has been rendered multiple times into the document. How can you tell them apart? If they have a unique ID prop (such as <strong class="source-inline">key</strong>), you can use that in the <strong class="source-inline">id</strong> field:</p>
<pre class="source-code">
jest.mock("../src/AppointmentsDayView", () =&gt; ({
  AppointmentsDayView: jest.fn(({ key }) =&gt; (
    &lt;div id={`AppointmentsDayView${key}`} /&gt;
  )),
}));</pre>
<p class="callout-heading">Approach with caution!</p>
<p class="callout">One of the biggest issues with mocking components is that mock definitions can get out of control. But mock setup is complicated and can be very confusing. Because of this, you should avoid writing anything but the simplest mocks.</p>
<p class="callout">Thankfully, most of the time, the plain form of component mock is all you’ll need. These variants are useful occasionally but should be avoided.</p>
<p>We’ll see this variation in action in <a href="B18423_11.xhtml#_idTextAnchor207"><em class="italic">Chapter 11</em></a>, <em class="italic">Test-Driving React Router</em>.</p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor142"/>Alternatives to module mocks</h2>
<p>Mocking out an entire module<a id="_idIndexMarker825"/> is fairly heavy-handed. The mock <a id="_idIndexMarker826"/>you set up must be used for all the tests in the same test module: you can’t mix and match tests, some using the mock and some not. If you wanted to do this with <strong class="source-inline">jest.mock</strong>, you’d have to create two test suites. One would have the mock and the other wouldn’t.</p>
<p>You also have the issue that the mock is at the module level. You can’t just mock out one part of the module. Jest has functions that allow you to reference the original implementation called <strong class="source-inline">requireActual</strong>. For me, that involves moving into the danger zone of overly complex test doubles, so I refrain from using it – I have encountered a use case that needed it.</p>
<p>However, there are alternatives to using <strong class="source-inline">jest.mock</strong>. One is shallow rendering, which utilizes a special renderer that renders a single parent component, ignoring all child components other than standard HTML elements. In a way, this is <a id="_idIndexMarker827"/>even more heavy-handed because <em class="italic">all</em> your components end up mocked out.</p>
<p>For <strong class="source-inline">CommonJS</strong> modules, you<a id="_idIndexMarker828"/> can also overwrite specific exports inside modules, simply by assigning new values to them! This gives you a much more granular way of setting mocks at the test level. However, this is not supported in <strong class="bold">ECMAScript</strong>, so in the<a id="_idIndexMarker829"/> interests of maximum capability, you may want to avoid this approach.</p>
<p>For examples of these alternative approaches and a discussion on when you ma<a id="_idTextAnchor143"/>y want to use them, take a look at <a href="https://reacttdd.com/alternatives-to-module-mocks">https://reacttdd.com/alternatives-to-module-mocks</a>.</p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor144"/>Summary</h1>
<p>This chapter covered the most complex form of mocking: setting up component mocks with <strong class="source-inline">jest.mock</strong>.</p>
<p>Since mocking is a complex art form, it’s best to stick with a small set of established patterns, which I’ve shown in this chapter. You can also refer to the code in <a href="B18423_11.xhtml#_idTextAnchor207"><em class="italic">Chapter 11</em></a>, <em class="italic">Test-Driving React Router</em>, for examples that show some of the variations that have been described in this chapter.</p>
<p>You also learned how to test-drive a <strong class="source-inline">useEffect</strong> hook before writing another matcher.</p>
<p>You should now feel confident with testing child components by using component mocks, Including loading data into those components through <strong class="source-inline">useEffect</strong> actions.</p>
<p>In the next chapter, we’ll extend this technique further by pulling out <strong class="source-inline">callback</strong> props from mock components and invoking them within our tests.</p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor145"/>Exercises</h1>
<p>The following are some exercises for you to try out:</p>
<ol>
<li value="1">Complete the message property tests on the <strong class="source-inline">toBeRenderedWithProps</strong> matcher.</li>
<li>Add the <strong class="source-inline">toBeFirstRenderedWithProps</strong> matcher and update your test suite to use this matcher. Since this matcher is very similar to <strong class="source-inline">toBeRenderedWithProps</strong>, you can add it to the same module file that contains the <strong class="source-inline">toBeRenderedWithProps</strong> matcher. You can also try to factor out any shared code into its own function that both matchers can use.</li>
<li>Add a <strong class="source-inline">toBeRendered</strong> matcher that checks if a component was rendered without checking its props.</li>
<li>Complete the matchers you’ve written so that they throw an exception if the passed argument is not a Jest mock.</li>
<li>Create a new component, <strong class="source-inline">AppointmentFormLoader</strong>, that calls the <strong class="source-inline">GET /availableTimeSlots</strong> endpoint when mounted. It should render an <strong class="source-inline">AppointmentForm</strong> component with its <strong class="source-inline">appointments</strong> prop set to the data returned from the server. </li>
</ol>
<h1 id="_idParaDest-146"><a id="_idTextAnchor146"/>Further reading</h1>
<p>To learn how to mock components without relying on <strong class="source-inline">jest.mock</strong>, please check out <a href="https://reacttdd.com/alternatives-to-module-mocks">https://reacttdd.com/alternatives-to-module-mocks</a>.</p>
</div>
</div></body></html>