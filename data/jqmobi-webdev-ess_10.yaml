- en: Chapter 10. Moving further with the Notekeeper Mobile Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。进一步了解Notekeeper移动应用程序
- en: In this chapter, we're going to begin assembling everything we've learned about
    lists, forms, pages, and content formatting thus far into a usable "mobile application";
    the Notekeeper application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将开始将迄今为止学到的关于列表、表单、页面和内容格式化的所有内容组合成一个可用的“移动应用程序”；即Notekeeper应用程序。
- en: 'In this chapter, we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Accept user input using forms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表单接受用户输入
- en: Store user inputted data locally using the HTML5 localStorage functionality
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTML5 localStorage功能在本地存储用户输入的数据
- en: Demonstrate how to add, edit, and remove items from the page dynamically
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演示如何动态地向页面添加、编辑和删除项目
- en: What is a mobile application?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是移动应用程序？
- en: Before writing our first mobile application, perhaps we should define what one
    is. Wikipedia says that a mobile application is *Software that is developed for
    small low-power handheld devices such as personal digital assistants, enterprise
    digital assistants or mobile phones*. While it's true that jQuery Mobile apps
    are written in HTML, CSS, and JavaScript, that doesn't prevent them from being
    sophisticated pieces of software. They're certainly developed with mobile devices
    in mind.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写我们的第一个移动应用程序之前，也许我们应该定义一下什么是移动应用程序。维基百科说，移动应用程序是*为小型低功耗手持设备开发的软件，如个人数字助理、企业数字助理或移动电话*。虽然jQuery
    Mobile应用程序是用HTML、CSS和JavaScript编写的，但这并不妨碍它们成为复杂的软件。它们肯定是针对移动设备开发的。
- en: Some critics might note that it can't really be software unless it's "installed".
    As you'll see later in the book, jQuery Mobile applications can actually be installed
    on a wide array of devices (including iOS, Android, and Windows Mobile) when coupled
    with the open source library PhoneGap. This means that you'll be able to have
    your cake and eat it too. You might be asking yourself if code written using jQuery
    Mobile can be considered software, and as you'll find out in this chapter, the
    answer is yes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一些评论家可能会指出，除非“安装”，否则它实际上不能成为软件。正如您将在本书的后面看到的，与开源库PhoneGap配合使用时，jQuery Mobile应用程序实际上可以安装在各种设备上（包括iOS、Android和Windows
    Mobile）。这意味着您将能够兼得。您可能会问自己，使用jQuery Mobile编写的代码是否可以被视为软件，正如您将在本章中了解到的那样，答案是肯定的。
- en: Designing your first mobile application
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计您的第一个移动应用程序
- en: The goal of any piece of software is to meet a need. Gmail met a need by freeing
    users from a single computer and letting them check their e-mail from any web
    browser. Photoshop met a need by allowing users to manipulate photos in ways no
    one had ever done. Our Notekeeper application meets a need by allowing us to record
    simple notes for later reference. I know, sort of a letdown by comparison but
    we've got to start somewhere right?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 任何软件的目标都是满足需求。Gmail通过让用户摆脱单一计算机并让他们可以从任何Web浏览器检查电子邮件来满足需求。Photoshop通过允许用户以前所未有的方式操纵照片来满足需求。我们的Notekeeper应用程序通过允许我们记录简单的笔记以供以后参考来满足需求。我知道，与之相比有点令人失望，但我们必须从某个地方开始对吧？
- en: 'When building software, it''s a good idea to spend time up front writing out
    a specification for your project: what it will do, what it will look like, and
    what it should have. Remember that if you don''t know what you''re building, how
    will you ever know if it''s done?'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建软件时，最好花时间事先撰写项目的规格说明：它将做什么，它将是什么样子，以及它应该具有什么。记住，如果你不知道你在构建什么，你怎么会知道它是否完成了？
- en: Listing out the requirements
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出要求
- en: 'We already know what we want our application to do, take notes. The problem
    is that there are so many ways that you could build a note-taking app that it''s
    essential to sketch out just what we want ours to do. Not too much, not too little,
    but just enough, for now. It''s a point of fact with developers that our applications
    are never "done", they''re only finished "for now". With Notekeeper, we''ve decided
    that we want to be able to do the following three things with our application:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道我们的应用想要做什么，记笔记。问题在于有很多种方式可以构建一个笔记应用，因此必须勾勒出我们想要的功能。不多不少，但目前足够。对开发人员来说，一个事实是我们的应用永远不会“完成”，它们只是暂时“完成”。对于Notekeeper，我们决定我们想要用我们的应用程序做以下三件事：
- en: Add a note
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加笔记
- en: Display a list of notes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示笔记列表
- en: View a note/delete a note
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看笔记/删除笔记
- en: 'After deciding what tasks our app needs to accomplish, we need to decide how
    it will accomplish them. The easiest approach is to simply write those things
    out in a list. By breaking each part down into smaller pieces we make it easier
    to understand, and to see just what we need to make it work. It''s just like getting
    directions to your favourite restaurant; a left turn here, a roundabout there,
    and you''re sitting down at the table before you know it. Let''s look at each
    thing we want Notekeeper to do, with the pieces and parts underneath:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定我们的应用程序需要完成哪些任务之后，我们需要决定它将如何完成这些任务。最简单的方法就是简单地将这些事情写成一个列表。通过将每个部分细分为更小的部分，我们使它更容易理解，并且看到我们需要做些什么才能让它工作。这就像得到去你最喜欢的餐厅的指南一样；这里拐个弯，那里转个圈，你转眼间就坐在餐桌前了。让我们看看我们希望Notekeeper做什么，以及下面的部分和部件：
- en: Adding a note (form)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个注释（表单）
- en: A form container. All user input widgets are wrapped up into a form.
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表单容器。所有用户输入的小部件都被包装成一个表单。
- en: A title, the name of the note. This will also be used to display existing notes.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标题，注释的名称。这也将用于显示现有的注释。
- en: The note itself. The content or body of the note.
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释本身。注释的内容或主体。
- en: A save button. This triggers the actual saving.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存按钮。这个按钮会触发实际的保存操作。
- en: The ability to display a list of notes (listview)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示注释列表的能力（列表视图）
- en: A row item containing the title of the note. This row should be a link to a
    page containing the body of the note.
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含注释标题的行项。此行应该是指向包含注释主体的页面的链接。
- en: A section header row might be nice.
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个部分标题行可能很好。
- en: The ability to view a note, and delete a note (label, paragraph, button)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看注释的能力，并删除注释（标签，段落，按钮）
- en: A label for the title of the note
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题的标签
- en: A paragraph containing the content of the note
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含注释内容的段落
- en: A button labeled **Delete**
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标有**删除**的按钮
- en: A back button
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回按钮
- en: Building your wireframes
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 制作线框图
- en: Now that we've listed out the functionality for our app, how about we sketch
    each piece so that we get an idea of what we want it to look like? Don't worry
    if you failed art, or if you can't draw a stick figure. Use a ruler if you have
    to, or consider using Microsoft Excel, or PowerPoint if you have those. You just
    need to be able to draw some boxes and some text labels.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经列出了我们的应用程序的功能，那么我们如何勾画出每一部分，以便我们知道我们想要的是什么样子？如果你的艺术功底不好，或者你连一个竖直线都画不出来，不要担心。如果你有尺子，可以使用尺子，或者考虑使用微软Excel或PowerPoint。你只需要能够画一些框和一些文本标签。
- en: Designing the add note wireframe
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计添加注释线框图
- en: 'Now, what about the add note part? We decided that it needs a title, a box
    for the note, and a submit button. The form is an invisible container so we don''t
    need to draw that:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加注释部分怎么样？我们决定它需要一个标题，一个注释框和一个提交按钮。表单是一个不可见的容器，所以我们不需要画出来：
- en: '![Designing the add note wireframe](img/Image4946.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![设计添加注释线框图](img/Image4946.jpg)'
- en: Display notes wireframe
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示注释框架
- en: 'The listview is an integral part of mobile development. It''s the simplest
    way to group similar items together, plus it offers lots of extra functionality
    such as scrolling, and built in images for links. We''ll be using a listview to
    display our list of notes:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表视图是移动开发的一个重要部分。这是将类似项目简单地分组在一起的最简单方法，另外它还提供了许多额外的功能，比如滚动和内置图片链接。我们将使用列表视图来显示我们的注释列表：
- en: '![Display notes wireframe](img/Image4953.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![显示注释框架](img/Image4953.jpg)'
- en: View note/delete button wireframe
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看注释/删除按钮框架
- en: 'Finally, once we''ve added a note, we need to be able delete the evidence,
    I mean clear out old notes to make way for new ones. Note that we''ve also sketched
    out a back button. Once you start seeing things laid out, you''ll find that you''ve
    forgotten something really important (like being able to return to the previous
    page):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦我们添加了一个注释，我们需要能够删除证据，我是说清除旧注释以为新注释腾出空间。请注意，我们还勾画了一个返回按钮。一旦你开始看到事情摆放出来，你会发现你忘记了一些非常重要的事情（比如能够返回到上一页）：
- en: '![View note/delete button wireframe](img/Image4962.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![查看注释/删除按钮框架](img/Image4962.jpg)'
- en: Writing the HTML
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写HTML
- en: Now that our wireframes are done, and we're happy with them it's time to turn
    pencil drawings into 1's and 0's. Since our app is relatively simple, none of
    the HTML should be difficult. You're more than halfway through the book after
    all and you should be doing these things in your sleep.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的线框图已经完成，我们对它们感到满意，是时候将铅笔画变成1和0了。由于我们的应用程序相对简单，HTML中的任何内容都不应该难倒你。毕竟，你已经过了书的一半了，而且你应该能够做到这些事情。
- en: 'The HTML that you come up with should look remarkably like what''s shown in
    the following code snippet. Let''s examine it together:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你所提出的 HTML 应该看起来与下面的代码片段非常相似。让我们一起来检查一下：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our Notekeeper application will make use of a single HTML file (`notekeeper.html`)
    and a single JavaScript file (`application.js`). Up until this point none of the
    code you''ve written has really needed JavaScript, but once you begin writing
    more complex applications, JavaScript will be a necessity. Preview the HTML from
    `Listing 10-1` in your web browser and you should see something similar to the
    following screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的笔记管理应用程序将使用单个 HTML 文件（`notekeeper.html`）和单个 JavaScript 文件（`application.js`）。直到这一点，您编写的代码都不需要
    JavaScript，但是一旦您开始编写更复杂的应用程序，JavaScript 就会成为必需品。在您的网络浏览器中预览 `列表 10-1` 中的 HTML，您应该会看到类似以下截图的内容：
- en: '![Writing the HTML](img/Image4970.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![编写 HTML](img/Image4970.jpg)'
- en: Notice that we're displaying the **Add Note** form on the same page as the view
    notes. With mobile application development, it's a good idea to condense things
    where possible. Don't make this a hard and fast rule but since there's so little
    to our app, it's an acceptable decision to place both parts together as long as
    they're clearly labeled. You can see that this page meets all the requirements
    we set for adding a note, and for displaying our existing notes. It has a title
    input field, a note input field, a save button, and the entire thing is wrapped
    inside a form container. It also has a listview that will be used to display our
    notes once we start adding them. What isn't seen here is a delete button, but
    that will show up once we add our first note and view the details page.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在同一个页面上显示**添加笔记**表单和查看笔记。在移动应用程序开发中，尽可能压缩东西是个好主意。不要将这个作为硬性规则，但由于我们的应用程序很简单，把这两部分放在一起是可以接受的决定，只要它们清晰地标记出来。你可以看到，这个页面满足了我们为添加笔记和显示现有笔记设定的所有要求。它有一个标题输入字段，一个笔记输入字段，一个保存按钮，并且整个东西都包裹在一个表单容器中。它还有一个列表视图，用于显示我们添加笔记后的笔记。这里看不到的是一个删除按钮，但一旦我们添加了第一个笔记并查看详细页面，它就会显示出来。
- en: Adding functionality with JavaScript
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JavaScript 添加功能
- en: As this book has mentioned, you don't need to write any JavaScript to get your
    money's worth from jQuery Mobile. But as you begin to progress in your experience
    with jQuery Mobile you'll begin to see how much additional value JavaScript can
    add to your projects. Before we look at the code, lets talk about how it will
    be structured. If you've done any web design or development at all, you've probably
    seen JavaScript. It has been around since 1995 after all. The problem is that
    there's been many different ways to do the same thing in JavaScript and not all
    of them good.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本书所提到的，您不需要编写任何 JavaScript 就能从 jQuery Mobile 中获得物有所值。但是随着您在 jQuery Mobile
    中的经验不断增加，您将开始看到 JavaScript 可以为您的项目增加多少附加值。在我们查看代码之前，让我们谈谈它将如何结构化。如果您有任何网络设计或开发经验，您可能已经看到过
    JavaScript。毕竟，它从 1995 年就开始存在了。问题是，JavaScript 有很多种不同的方法来做同样的事情，而不是所有方法都是好的。
- en: 'The JavaScript code in this application will use what''s called a design pattern.
    It''s just a fancy term that specifies a certain structure to the code. There
    are three main reasons for using an existing design pattern:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序中的 JavaScript 代码将使用所谓的设计模式。这只是一个花哨的术语，用来指定代码的某种结构。使用现有设计模式的主要原因有三个：
- en: It helps our code stay organized and tidy.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它帮助我们的代码保持组织和整洁。
- en: It prevents the variables and functions we write from being accidentally overwritten
    or altered by any other code we might add. A jQuery plugin perhaps, or code that's
    being loaded in from a third party website.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它防止我们编写的变量和函数被我们可能添加的任何其他代码意外覆盖或更改。也许是一个 jQuery 插件，或者是从第三方网站加载的代码。
- en: It will help the future developers to acclimiatize themselves to your code much
    more rapidly. You are thinking about future developers as you work on the next
    Facebook right?
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将帮助未来的开发人员更快地适应你的代码。你在开发下一个 Facebook 的时候有考虑到未来的开发人员吗？
- en: 'Let''s take a look at a very simple implementation of this design pattern before
    jumping into the full code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解完整代码之前，让我们先来看一个非常简单的实现这个设计模式的示例：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you''re familiar with JavaScript or jQuery, you''ll probably see some elements
    that you''re familiar with. For those readers who aren''t familiar with jQuery,
    or JavaScript we''ll review this example line by line. `KittyDressUp.js` starts
    off with jQuery''s best friend. Any code contained within the curly braces waits
    to execute until the document, or the HTML page, is completely loaded. This means
    that you, the developer, can be assured that everything which needs to be on the
    page is there before your code runs:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉 JavaScript 或 jQuery，您可能会看到一些您熟悉的元素。对于那些不熟悉 jQuery 或 JavaScript 的读者，我们将逐行审查这个示例。`KittyDressUp.js`
    以 jQuery 的最好朋友开头。包含在花括号内的任何代码都会等到文档或 HTML 页面完全加载后再执行。这意味着您，开发人员，可以确保您的代码在页面上需要的一切都加载完成后才运行：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In simple terms, the next line creates a variable named `kittyDressUp` and
    assigns it a value of an empty object. However, in our code this new object will
    contain our entire application:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，下一行创建了一个名为 `kittyDressUp` 的变量，并将其赋值为空对象的值。但是，在我们的代码中，这个新对象将包含我们的整个应用程序：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The following declaration is the core of the Kitty Dress Up application. It
    creates a function that accepts a single argument, and then immediately calls
    itself, passing in the empty object we created in the previous line. This concept
    is known as a self-executing function and is what keeps the external code from
    interfering with our application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的声明是 Kitty Dress Up 应用程序的核心。它创建了一个接受单个参数的函数，然后立即调用自身，并传入我们在前一行中创建的空对象。这个概念称为自执行函数，它是使外部代码无法干扰我们的应用程序的方法。
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next two lines set a few variables that can only be accessed from within
    the context, or scope, of our application:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行设置了一些只能从我们应用程序的上下文或范围中访问的变量：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, the last few lines set up two functions that are available for use
    within the application. You can see that each function is assigned a name that
    is within the scope of the larger application. The `app` variable is where the
    function lives, and the word after the . is the function name. Notice that within
    the `init` function we're calling another function inside the same application,
    `app.colors()`. We could also reference any of the variables that we defined at
    the top as well.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后几行设置了两个在应用程序中可用的函数。您可以看到每个函数都被分配了一个在更大应用程序范围内的名称。`app` 变量是函数所在的地方，. 后面的单词是函数名称。请注意，在
    `init` 函数内部，我们正在调用同一应用程序内的另一个函数，`app.colors()`。我们也可以引用我们在顶部定义的任何变量。
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Remember that `app` was the name of the parameter passed into the self-executing
    function, and that its value is an empty object. Taken as a whole these few lines
    create an object named `kittyDressUp` that contains two variables (`appName` and
    `version)`, and two functions (`init` and `colors)`. This example, as well as
    the code for Notekeeper, are simple examples, but they illustrate how you can
    go about wrapping up code for various pieces of a larger app into discrete packages.
    In fact, after `kittyDressUp.js` runs you could even pass the `kittyDressUp` into
    yet another set of code for use there.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`app` 是传递给自执行函数的参数名称，其值为空对象。作为整体，这几行代码创建了一个名为 `kittyDressUp` 的对象，其中包含两个变量（`appName`
    和 `version`），以及两个函数（`init` 和 `colors`）。这个示例以及 Notekeeper 的代码都是简单的示例，但它们说明了您可以如何将代码包装成离散包以用于更大应用程序的各个部分。事实上，在
    `kittyDressUp.js` 运行之后，您甚至可以将 `kittyDressUp` 传递到另一组代码中以供使用。
- en: Phew...everyone take five, you've earned it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀... 大家休息五分钟，你们赚了它。
- en: Storing Notekeeper data
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储 Notekeeper 数据
- en: 'Now that we''re back from our five minute break it''s time to roll up our sleeves
    and get to work adding functionality to our app. While we''ve talked about how
    we want Notekeeper to behave, we haven''t discussed the core issue of where to
    store the note data. There are a few possibilities, all of which have pros and
    cons. Let''s list them out:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们从五分钟的休息中回来了，是时候卷起袖子开始为我们的应用程序添加功能了。虽然我们已经讨论了我们希望 Notekeeper 的行为方式，但我们还没有讨论到存储笔记数据的核心问题。有几种可能性，都有利弊。让我们列出它们：
- en: '**Database (MySQL, SQL Server, PostgreSQL):** While a database would be the
    ideal solution, it''s a little complex for our app, it requires internet connectivity,
    and you''d need a server-side component (ColdFusion, PHP, .NET) acting as a middle
    man to save notes to the database.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库（MySQL、SQL Server、PostgreSQL）：** 虽然数据库是理想的解决方案，但它对我们的应用程序来说有点复杂，它需要互联网连接，并且您需要一个服务器端组件（ColdFusion、PHP、.NET）作为中间人将笔记保存到数据库中。'
- en: '**Text file:** Text files are great because they take up very little room.
    The problem is that as a web app, Notekeeper can''t save files to the user''s
    device.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本文件：** 文本文件非常棒，因为它们占用的空间很小。问题在于作为 Web 应用程序，Notekeeper 无法将文件保存到用户的设备上。'
- en: '**localStorage:** localStorage is relatively new, but it''s quickly becoming
    a good option. It stores information on the user''s machine in key/value pairs.
    It''s got a size limit, but it''s pretty large for plain text, most modern browsers
    support it, and it can be used in offline mode.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**localStorage：** localStorage相对较新，但它迅速成为一个很好的选择。它以键/值对的形式存储信息在用户的设备上。它有大小限制，但对于纯文本来说相当大，大多数现代浏览器都支持它，并且可以在离线模式下使用。'
- en: Using localStorage
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用localStorage
- en: 'For the purposes of this chapter, we''ll be selecting `localStorage` as our
    method of choice. Let''s take a quick look at how it behaves so that you''ll be
    familiar with it when you see it. As mentioned earlier, `localStorage` works on
    the premise of storing data in key/value pairs. Saving a value to `localStorage`
    works in one of two ways and is easy, no matter which one you choose:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章的目的，我们将选择`localStorage`作为我们的首选方法。让我们快速看一下其行为，这样当你看到它时，你就会熟悉它。如前所述，`localStorage`的工作原理是存储键/值对中的数据。将值保存到`localStorage`有两种方式，无论你选择哪一种，都很容易：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: or
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 或
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Which version you choose is personal preference, but because it's slightly less
    typing we'll be using the second method, square brackets. One issue we'll run
    into is that `localStorage` can't store complex data like arrays, or objects.
    It only stores strings. That's a problem because we're going to be storing all
    of our data inside one variable so that we always know where it lives. Never fear,
    we can pull a fast one on `localStorage` and convert our complex object into a
    string representation of itself using a built in function called `stringify()`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 选择哪个版本完全取决于个人偏好，但因为输入较少，我们将使用第二种方法，方括号。我们将遇到的一个问题是，`localStorage`无法存储如数组或对象之类的复杂数据。它只能存储字符串。这是一个问题，因为我们将把所有数据存储在一个变量中，以便始终知道其位置。别担心，我们可以欺骗`localStorage`，使用一个名为`stringify()`的内置函数将我们的复杂对象转换为其自身的字符串表示。
- en: 'The following code snippet shows how it works:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了它是如何工作的：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Retrieving a value is just as simple as setting it, and it also offers two options.
    You'll usually want to define a variable to receive the contents of the `localStorage`
    variable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 检索值与设置值一样简单，并且也提供两个选项。通常需要定义一个变量来接收`localStorage`变量的内容。
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: or
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 或
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you''re retrieving a complex value there''s an additional step that must
    be performed before you can use the contents of the variable. As we just mentioned,
    to store complex values you must first use the `stringify()` function, which has
    a counterpart function called `parse()`. The `parse()` function takes the string
    containing that complex object and turns it back into pure JavaScript. It''s used
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在检索复杂的值，则必须在使用变量内容之前执行另一步。正如我们刚才提到的，要存储复杂的值，您必须首先使用`stringify()`函数，它有一个称为`parse()`的相对应函数。`parse()`函数接受包含该复杂对象的字符串，并将其转换回纯粹的JavaScript。它的用法如下：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, if ever you wanted to delete the key completely then you can accomplish
    it in a single line of code, again with two flavors:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你想完全删除该密钥，那么你可以在单行代码中完成，有两种选择：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: or
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 或
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It''s worth noting that if you try to retrieve a key that doesn''t exist within
    localStorage, JavaScript won''t throw an error. It''ll just return "undefined"
    which is JavaScript''s way of saying "sorry, but nothing''s there". The following
    code snippet is an example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，如果您尝试检索在`localStorage`中不存在的密钥，JavaScript 不会引发错误。它只会返回“未定义”，这是 JavaScript
    表示“抱歉，什么也没有”的方式。以下代码片段是一个示例：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Effective use of boilerplates
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有效使用样板文件
- en: 'One last thing before we start building our JavaScript file. In our application,
    we''re only going to have one JavaScript file, and it''s going to contain the
    entire codebase. This is fine for smaller apps like ours, but it''s a bad idea
    for larger apps. It''s better to break up your project into distinct pieces, then
    put each of those into their own files. This makes it easier for teams of developers
    to work together (for example, Noelle works on the login process, while Mason
    builds out the list of vendors). It also makes each file smaller and easier to
    understand because it only addresses one part of the whole. When you want all
    of the pieces of your app to have a similar structure and design, it''s a good
    idea to start each section with a boilerplate. We''ll be using a boilerplate for
    our app''s only file (which you can see in the following code snippet, `Listing
    10-3)`. You might notice it looks very similar to the `kittyDressUp` example,
    and you''d be right:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建 JavaScript 文件之前，还有一件事情。在我们的应用程序中，我们只会有一个 JavaScript 文件，它将包含整个代码库。这对于像我们这样的小型应用程序来说是可以的，但对于更大的应用程序来说不是一个好主意。最好将项目分解为不同的部分，然后将每个部分放入它们自己的文件中。这样做可以使开发团队更容易地协同工作（例如，Noelle
    负责登录流程，而 Mason 则负责供应商列表）。它还使每个文件变得更小且更容易理解，因为它只涉及整体的一部分。当您希望应用程序的所有部分具有相似的结构和设计时，最好的方法是从一个模板开始每个部分。我们将为我们应用程序的唯一文件使用一个模板（你可以在以下代码片段中看到，`Listing
    10-3`）。你可能会注意到它看起来非常类似于 `kittyDressUp` 示例，你是对的：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Building the Add Note feature
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建添加注释功能
- en: At last, we can get started building! Since it's difficult to display a list
    of notes that don't exist, much less delete one, we'll start writing the `Add
    Note` functionality first. For a user to be able to add a note, they have to enter
    a title, the contents of a note, then hit the submit button. So let's start there.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以开始构建了！由于要显示不存在的笔记列表很困难，更不用说删除笔记了，我们将首先编写 `添加注释` 功能。用户要能够添加注释，他们必须输入标题、注释内容，然后点击提交按钮。所以我们从那里开始。
- en: Adding bindings
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加绑定
- en: 'We''re going to create a new, empty, function block under the `app.init()`
    function definition. It should look something similar to the following line of
    code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `app.init()` 函数定义下创建一个新的、空的函数块。它应该看起来类似于以下代码行：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The bindings function will contain any piece of code that needs to fire when
    a user does something in our app, like clicking the submit button or the delete
    button. We group that code together for the sake of organization. Within the `bindings()`
    function we''re going to add the following lines. This will fire when a user clicks
    the submit button on the `Add Note` form:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定函数将包含在我们的应用程序中当用户执行某些操作时需要触发的任何代码片段，例如点击提交按钮或删除按钮。我们将这些代码片段组合在一起以便组织。在 `bindings()`
    函数内部，我们将添加以下行。这将在用户单击 `添加注释` 表单的提交按钮时触发：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: jQuery's `val()` function is a shorthand method used to get the current value
    of any form input field.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 的 `val()` 函数是一个简写方法，用于获取任何表单输入字段的当前值。
- en: 'A few notes about this new addition:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个新添加的一些说明：
- en: When using jQuery, there will always be more than one way to accomplish something,
    and in most cases you simply pick the one that you like the best (they usually
    offer identical performance). You might be more familiar with `$('#btnAddNote').click()`
    and that's just fine as well.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 jQuery 时，总会有更多的方法来完成某件事情，在大多数情况下，你只需选择自己喜欢的方法即可（它们通常具有相同的性能）。你可能更熟悉 `$('#btnAddNote').click()`，那也完全可以。
- en: 'Notice that the `click` function accepts a single parameter: `e` which is the
    event object (in this case a click event). We call `e.preventDefault()` to stop
    the standard click event from happening on this element, but still allow the remaining
    code to continue running. You might have seen other developers use `return false`,
    but jQuery best practices recommend using `e.preventDefault()` instead.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，`click` 函数接受一个参数：`e`，它是事件对象（在本例中是点击事件）。我们调用 `e.preventDefault()` 来阻止在此元素上发生标准点击事件，但仍允许其余代码继续运行。你可能已经看到其他开发人员使用
    `return false`，但 jQuery 最佳实践建议使用 `e.preventDefault()`。
- en: Within the click binding, we're calling the `addNote` function, and passing
    into it the title typed in by the user, and the note. The whitespace is unimportant,
    serving merely to make it easier to see what we're doing.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在点击绑定中，我们调用 `addNote` 函数，并将用户输入的标题和注释传递给它。空白不重要，仅仅是为了更容易看到我们在做什么。
- en: 'Even though we''ve added the binding to our code, if you run the app right
    now, nothing will happen when you click the **Add Note** button. The reason is
    that nothing has actually called the `bindings()` function yet. Add the following
    line inside the `init()` function and you''ll be ready to go:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们已经将绑定添加到我们的代码中，如果你现在运行应用程序，当你点击**添加笔记**按钮时什么也不会发生。原因是还没有任何东西调用`bindings()`函数。在`init()`函数内添加以下行，然后你就可以准备好了：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Collecting and storing the data
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 收集和存储数据
- en: Next we add another new, empty, function block under `app.bindings:`
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`app.bindings`下面添加另一个新的空函数块：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, because we''re storing all of our notes into one key within `localStorage`,
    we first need to check to see if any notes already exist. Retrieve the Notekeeper
    key from `localStorage`, save it to a variable, then compare it. If the value
    of the key we ask for is an empty string, or `undefined` we''ll need to create
    an empty object. If there is a value, then we take that and use the `parse()`
    function to turn it into JavaScript:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为我们将所有的笔记都存储在`localStorage`的一个键中，我们首先需要检查是否已经存在任何笔记。从`localStorage`中检索Notekeeper键，将其保存到一个变量中，然后进行比较。如果我们要求的键的值是一个空字符串或`undefined`，我们将需要创建一个空对象。如果有一个值，那么我们将取出该值并使用`parse()`函数将其转换为JavaScript：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Notice that we''re expecting two variables to be passed into the `addNote()`
    function, `title` and `note`. Next we replace any spaces in the title with dashes,
    this makes it easier for some browsers to understand the string of text. Then
    we place the key/value pair into our newly minted notes object:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们期望将两个变量传递给`addNote()`函数，`title`和`note`。接下来，我们用破折号替换标题中的任何空格，这样某些浏览器更容易理解文本字符串。然后我们将键值对放入我们新创建的笔记对象中：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The JavaScript `replace` method makes string manipulation quite simple. It acts
    on a string, taking a search term and a replacement term. The search term can
    be a simple string, or a complex regular expression.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的`replace`方法使字符串操作非常简单。它作用于一个字符串，接受一个搜索项和一个替换项。搜索项可以是一个简单的字符串，也可以是一个复杂的正则表达式。
- en: 'The next step is to take our `notesObj` variable, `stringify()` it and place
    it into `localStorage`. We then clear the values from the two input fields to
    make it easier for the user to input another note. As a rule in building software
    it''s a nice touch to return the interface to its original state after an action
    such as adding or removing content:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将我们的`notesObj`变量`stringify()`并放入`localStorage`中。然后我们清除两个输入字段的值，以便用户更轻松地输入另一个笔记。在构建软件时，一般在添加或删除内容后将界面恢复到原始状态是一个不错的举措：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: All of these variable definitions should be familiar to you with perhaps one
    exception that we should point out. Many jQuery developers like to use conventional
    naming for variables which contain jQuery objects.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些变量定义对你来说应该很熟悉，也许有一个例外，我们应该指出。许多jQuery开发人员喜欢为包含jQuery对象的变量使用传统命名。
- en: 'Specifically, they prepend the variable name with a `$` sign just like with
    jQuery. This lets them, or future developers know, what''s contained within the
    variable. Let''s go ahead and add those definitions to the top of our app. Just
    after the line which reads `// variable definitions go here`, add the following
    lines. They refer to the title input field and the note textarea field respectively:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，它们在变量名前面加上了`$`符号，就像在jQuery中一样。这让他们或者未来的开发者知道变量中包含的是什么。让我们继续在我们的应用程序顶部添加这些定义。在读取`//
    变量定义放在这里`后面的一行，添加以下行。它们分别指的是标题输入字段和笔记文本区域字段：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As a final step to this function we fire off a call to `app.displayNotes()`
    to update the list of notes. Since that function doesn't exist yet, let's create
    it next.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个函数的最后一步，我们调用`app.displayNotes()`来更新笔记列表。由于该函数尚不存在，接下来我们来创建它。
- en: Building the Display Notes feature
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建显示笔记功能
- en: 'You probably tested out the `Add Note` feature while writing the previous section.
    This means that you''ll have at least one note saved in `localStorage` for use
    in testing the `Display Notes` feature. By now you''re familiar with our first
    steps for any new section. Go ahead and add your empty `displayNotes()` function
    to hold our code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写上一节时，你可能已经测试了`添加笔记`功能。这意味着你至少已经在`localStorage`中保存了一个笔记，用于测试`显示笔记`功能。到现在为止，你已经熟悉了我们在任何新节的第一步。继续添加你的空白`displayNotes()`函数来保存我们的代码：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Next we need to retrieve all of our notes from `localStorage:`
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要从`localStorage`中检索所有的笔记：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You might start to see a pattern with many of our functions, almost all of
    them begin with us retrieving notes from `localStorage`. While there are only
    two lines of code needed to perform this task, there''s no need for us to repeat
    those two lines each time we need to get the notes. So we''re going to write a
    quick helper function containing those two lines. It looks similar to the following
    code snippet:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到我们的许多函数都有一个模式，几乎所有这些函数都以从 `localStorage` 中检索笔记开始。虽然只需要两行代码来执行此任务，但我们不需要在每次需要获取笔记时重复这两行代码。所以我们将编写一个包含这两行代码的快速辅助函数。它看起来类似于以下代码片段：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With our new helper function in place, we can use it in the `displayNotes()`
    function as shown in the following code snippet:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的新辅助函数，我们可以像下面的代码片段中所示，在 `displayNotes()` 函数中使用它：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now that we have the `notesObj` variable containing our packet of notes, we
    need to loop over that packet and output the contents:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了包含我们笔记数据的 `notesObj` 变量，我们需要循环遍历该数据包并输出内容：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It might seem odd for the line inside the `for` loop to have multiple replace
    statements, but the nature of JavaScript allows for methods to be chained. Chaining
    refers to a method which returns the entire results of it's action. Adding an
    additional method call simply repeats the process.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `for` 循环内的一行具有多个替换语句可能看起来有些奇怪，但是 JavaScript 的性质允许方法链式调用。链式调用指的是返回其操作结果的整个结果的方法。添加额外的方法调用只是简单地重复该过程。
- en: There might be some new concepts in this code block so let's take a closer look.
    The variable named `html` is nothing special, but how we're using it might be.
    As we loop over the existing notes, we're storing new information into the `html`
    variable along with whatever else is inside it. We accomplish this by using the
    `+=` operator which allows us to assign and append at the same time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码块中可能有一些新概念，所以让我们仔细看看。名为 `html` 的变量并不特别，但我们如何使用它可能是特别的。当我们遍历现有的笔记时，我们将新信息存储到
    `html` 变量中，以及其他任何内容。我们通过使用 `+=` 运算符来实现这一点，该运算符允许我们同时赋值和追加。
- en: 'The second thing you might notice is the `li` on the right side of the assignment.
    Where does that come from? That''s a template for a single list item which has
    not yet been created. Let''s do that right before we talk about it. At the top
    of your `app.js` file, just after the line which reads `// variable definitions
    go here`, add the following two lines of code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第二件你可能注意到的事情是赋值右边的 `li`。它从哪里来？那是一个尚未创建的单个列表项的模板。让我们在谈论它之前就做这件事。在你的 `app.js`
    文件顶部，在读取 `// 变量定义在此` 之后的一行之后，添加以下两行代码：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You should already be familiar with the convention of adding a `$` before a
    variable to indicate a jQuery object. That's what we're doing with the `$ul` variable.
    The second variable, the `li` is slightly different. This contains the HTML for
    a single list item that will display a notes title. It's best practice to avoid
    mixing HTML or CSS in with your JavaScript wherever possible. We're declaring
    this as a template now in case we decide to use it in multiple places later.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经熟悉了在变量前加`$`来表示一个 jQuery 对象的约定。这就是我们在 `$ul` 变量中所做的事情。第二个变量，`li` 有些不同。它包含了一个单独的列表项的
    HTML，用于显示一个笔记标题。最好的做法是尽可能避免在 JavaScript 中混合使用 HTML 或 CSS。我们现在将其声明为一个模板，以防将来决定在多个地方使用它。
- en: The other part which might be of interest is the way we're using the `li` variable.
    When calling the string replace function, we're looking for all occurrences of
    the word LINK (upper case intended) and replacing it with the title of the note.
    Because JavaScript is a case-sensitive language it's a safe assumption that we
    won't run into a natural occurrence of that work.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能感兴趣的部分是我们如何使用 `li` 变量。在调用字符串替换函数时，我们正在查找单词 LINK 的所有出现，并用笔记的标题替换它。因为 JavaScript
    是大小写敏感的语言，所以我们可以安全地假设我们不会遇到该单词的自然出现。
- en: Dynamically adding notes to our listview
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态添加笔记到我们的列表视图
- en: There's one final thing we need to put in place before our notes show up on
    the page. You might have noticed that the only place which calls the `displayNotes()`
    function appears within the `addNote()` function. This is a good place for it,
    but it can't be the only place. We need something that runs when the page first
    loads. The prime place for this would be in the `init()` function, and that's
    where we'll place it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的笔记显示在页面上之前，还有最后一件事情要安排。您可能已经注意到，唯一调用`displayNotes()`函数的地方出现在`addNote()`函数内部。这是一个很好的地方，但它不能是唯一的地方。我们需要在页面首次加载时运行某些内容。这个地方最好是在`init()`函数中，并且这就是我们要放置它的地方。
- en: 'There''s one problem though, we can''t just load our notes and run, what happens
    if there are no notes? We need a nice message to display to the user so that they
    don''t think something''s wrong. Let''s create a new function called `app.checkForStorage()`
    which handles all of this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，有一个问题，我们不能只加载我们的笔记然后运行，如果没有笔记会发生什么？我们需要向用户显示一个友好的消息，以便他们不会认为出了什么问题。让我们创建一个名为`app.checkForStorage()`的新函数来处理所有这些：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'By now, all of this should be familiar to you: checking `localStorage` for
    notes, and calling the `displayNotes()` function if it finds them. The second
    part has some new items though. When we set the html for the `$ul` jQuery object,
    we''re calling two new variables. One for the listview header, and another if
    we don''t have any notes. Let''s add those two variable definitions now. Under
    `// variable definitions go here`, add the following two lines:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，所有这些对你来说应该都很熟悉：检查`localStorage`是否有笔记，并在找到它们时调用`displayNotes()`函数。不过，第二部分有一些新内容。当我们为`$ul`jQuery
    对象设置 html 时，我们调用了两个新变量。一个是列表视图的标题，另一个是如果我们没有任何笔记时的情况。让我们现在添加这两个变量定义。在`// 变量定义在此处`下面，添加以下两行：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The last part of the line normally might go unnoticed, but we won't let it.
    It's really crucial. jQuery Mobile offers developers options. The option of having
    static HTML code, that's already on the page when it loads; jQuery Mobile also
    provides an option for adding HTML code on the fly. That really gives developers
    lots of flexibility, but it presents a unique challenge as well. By design jQuery
    Mobile converts HTML into stylish looking buttons before the page loads. This
    means that any HTML added after that will be presented to the user without any
    style.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 行的最后一部分通常可能会被忽视，但我们不会让它被忽视。这真的很重要。jQuery Mobile 为开发人员提供了选择。一种选择是使用静态 HTML 代码，在页面加载时已经存在；jQuery
    Mobile 还提供了在运行时添加 HTML 代码的选项。这确实给开发人员带来了很大的灵活性，但同时也提出了一个独特的挑战。按设计，jQuery Mobile
    在页面加载之前将 HTML 转换为时尚的按钮。这意味着在此之后添加的任何 HTML 将以没有任何样式的方式呈现给用户。
- en: However, jQuery Mobile also offers a way to get around this by building in the
    ability to refresh each and every element that it converts. Most of them have
    a built-in function corresponding to the name of the element; in our case it's
    the `listview()` function. Actually this method offers the ability to add a completely
    new listview to the page. In our situation we only care about refreshing the one
    we have, so we simply add the `refresh` keyword and jQuery Mobile converts your
    plain text listview. Try leaving that last part off and see just how much work
    jQuery Mobile saves you. Maybe you should add the jQuery Mobile team to your Christmas
    card list?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，jQuery Mobile 也提供了一种方法来解决这个问题，即内置刷新每个转换的元素的功能。大多数元素都有一个与元素名称对应的内置函数；在我们的情况下，它是`listview()`函数。实际上，这种方法提供了向页面添加一个全新列表视图的能力。在我们的情况下，我们只关心刷新我们已经拥有的列表视图，因此我们只需添加`refresh`关键字，jQuery
    Mobile 就会将你的纯文本列表视图转换。试着省略最后一部分，看看 jQuery Mobile 能为你节省多少工作量。也许你应该将 jQuery Mobile
    团队加入你的圣诞卡列表？
- en: Finally, we have to actually call our newest function. Within the `init()` function
    add the following line. Then reload the page and watch your notes load up.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须实际调用我们的最新函数。在`init()`函数中添加以下行。然后重新加载页面，看看你的笔记如何加载。
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Viewing a note
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看笔记
- en: At this point we should be able to create a new note, and have that note be
    immediately displayed in our listview. In fact, the rows in the listview are already
    links, they just don't work, let's change that right now.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们应该能够创建一个新的笔记，并且该笔记会立即显示在我们的列表视图中。事实上，列表视图中的行已经是链接，它们只是不起作用，让我们立即更改它。
- en: Using the Live function
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Live 函数
- en: 'Add the following lines to the `bindings()` function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下行添加到`bindings()`函数中：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This new binding has a few new concepts so let's unpack them. First up, we're
    not using the `bind` function, instead we use jQuery's `live` function. The difference
    is that `bind` only works on existing page elements, whereas `live` is proactive.
    It works on existing elements as well as ones which get created after the binding
    is applied.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的绑定有一些新概念，所以让我们来解析一下。首先，我们不使用 `bind` 函数，而是使用jQuery的 `live`函数。区别在于 `bind`
    仅适用于现有的页面元素，而 `live` 是主动的。它既适用于现有元素，也适用于应用绑定后创建的元素。
- en: 'The second and third lines of the binding might look a little confusing but
    they only do one thing. They retrieve the URL from the href attribute of the link
    that was clicked. The `li` template we defined earlier in the chapter contained
    the following URL for each list item:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定的第二行和第三行可能看起来有点混乱，但它们只做一件事。它们从被点击的链接的 href 属性中检索URL。我们在本章前面定义的 `li` 模板包含每个列表项的以下URL：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After the `displayNote()` function runs, the URL looks like this (run your
    mouse over each list item to see the link displayed at the bottom of your browser
    window):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`displayNote()` 函数运行后，URL看起来像这样（将鼠标悬停在每个列表项上，以查看其在浏览器窗口底部的链接）：'
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Finally we tell our code to run a new function appropriately named `app.loadNote()`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们告诉我们的代码运行一个名为 `app.loadNote()` 的新函数。
- en: Dynamically creating a new page
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态创建一个新页面
- en: 'If you haven''t already created the new empty function block for our new `loadNote()`
    function, go ahead and do it now. Remember that we''re passing in the title of
    the note we want to view, so make sure to add that as an argument in the `loadNote()`
    function:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有为我们的新 `loadNote()` 函数创建一个新的空函数块，现在就去做吧。记住，我们要传入要查看的笔记的标题，所以确保在 `loadNote()`
    函数中添加这个作为参数：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then place the following two lines at the top of the function:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将以下两行放在函数的顶部：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first line retrieves our note object, while the second line pulls the specific
    note that the user has requested. The next variable definition breaks the rule
    we mentioned earlier in the chapter about mixing HTML and JavaScript, but every
    rule has exceptions. We're defining it here as opposed to the header of our JS
    file since this is the only place it is needed. This still serves the purpose
    of keeping the document organized.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行检索我们的笔记对象，而第二行提取用户请求的具体笔记。下一个变量定义打破了我们之前在本章提到的关于混合HTML和JavaScript的规则，但每个规则都有例外。我们在这里定义它，而不是在我们的JS文件的标题，因为它只在这里需要。这仍然可以保持文档的组织性。
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `page` variable now contains all of the HTML needed to display a "note
    details" page to the user. Do you recall that our app has only one HTML file?
    We''re actually creating an entire page from scratch using the previous HTML code.
    There are also some details in it worth pointing out:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`page` 变量现在包含了显示"笔记详情"页面所需的所有HTML。你还记得我们的应用只有一个HTML文件吗？我们实际上正在使用先前的HTML代码从头开始创建整个页面。其中也有一些值得指出的细节：'
- en: By default jQuery Mobile does not offer a back button for pages. You can, however,
    enable one on a page by page basis using the `data-add-back-btn="true"` attribute
    on any `div` tag which also has a `data-role="page"` attribute.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下 jQuery Mobile 不为页面提供返回按钮。然而，你可以在每个页面上使用 `data-add-back-btn="true"` 属性来启用返回按钮，该属性需要添加在带有
    `data-role="page"` 属性的任何 `div` 标签上。
- en: The `data-url` attribute is an identifier used by jQuery Mobile so that it can
    keep track of multiple pages which are generated.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data-url` 属性是 jQuery Mobile 使用的标识符，以便可以跟踪生成的多个页面。'
- en: 'Now that we have a whole page contained within a variable, what can we do with
    it? The first thing we can do is to turn it into a jQuery object. By wrapping
    any distinct chunk of HTML with a `$()` you turn it into a Grade-A jQuery object:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在一个变量中包含了整个页面，我们可以对它做什么？我们可以将它转换为jQuery对象。通过用 `$()` 将任何独立的HTML块包装起来，我们就可以将其转换为一流的jQuery对象：
- en: '[PRE40]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Then we can take the HTML of that newly created page and replace parts of it
    with the values from our selected note.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以取出新创建页面的HTML，并用我们选择的笔记的值替换部分内容。
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Since Version 1.4, jQuery has offered the option of a **callback** within certain
    functions. These include `.html(), .text(), .css()` and a few others. This function
    expects two arguments, of which the second contains the full HTML currently contained
    within the matching element. This means that we can make tweaks to the HTML contained
    inside our `newPage` variable without having to completely change it. Wonderful
    isn't it?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本1.4开始，jQuery提供了在某些函数内部使用**回调**的选项。这些函数包括`.html()`、`.text()`、`.css()`等几个。该函数期望两个参数，第二个参数包含当前匹配元素中包含的完整HTML。这意味着我们可以对`newPage`变量内包含的HTML进行微调，而不必完全更改它。太棒了，不是吗？
- en: 'Next we''re appending the entire `newPage` variable to the end of the current
    page, referenced here by the `$.mobile.pageContainer` constant. Finally, because
    we cancelled the default click action in our binding, we have to tell the link
    to perform an action which is to forward the user to this newly created page.
    jQuery Mobile offers a built-in way to do this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将整个`newPage`变量追加到当前页面的末尾，这里通过`$.mobile.pageContainer`常量引用。最后，因为我们取消了绑定中的默认点击操作，所以我们必须告诉链接执行一个操作，即将用户转到这个新创建的页面。jQuery
    Mobile提供了内置的方法来实现这一点：
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: And now for the grand reveal. If you load up `notekeeper.html` in your browser
    you should be able to add, display, and finally view notes, all within the confines
    of a single browser window. Isn't jQuery Mobile great?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是大揭示的时刻。如果你在浏览器中加载`notekeeper.html`，你应该能够在一个浏览器窗口内添加、显示和最终查看笔记。jQuery Mobile是不是很棒？
- en: '![Dynamically creating a new page](img/Image5068.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![动态创建新页面](img/Image5068.jpg)'
- en: Deleting a note
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除笔记
- en: 'Looking back to the requirements for our app, we''re doing pretty well. We''ve
    written HTML code that sets up the document structure, allowed us to add a note,
    display notes, and view a note. All that''s left is deleting a note and it begins
    with a last binding set up in our `bindings()` function. Let''s add it right now:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们应用程序的需求，我们做得相当不错。我们编写了设置文档结构的HTML代码，允许我们添加笔记、显示笔记和查看笔记。剩下的只是删除一个笔记，它始于我们在`bindings()`函数中设置的最后一个绑定。现在就让我们添加它：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: There's only one item that might be new to you in this binding, the use of jQuery's
    `.data()` function. HTML 5 allows you to store arbitrary data directly on any
    HTML element by using an attribute prepended with `data-` and this ability is
    at the core of jQuery Mobile's functionality. Anywhere you see `data-role="something"`,
    you're seeing HTML 5 data in action. Further jQuery allows you to retrieve any
    `data-` value by using the `.data()` function and passing in the key of the item
    you want to view. In the case above we've stored the title of the note into a
    `data-href` attribute directly on the delete button within the view page. Because
    the binding we're adding is a click handler assigned to the delete button we can
    retrieve the title of the note by calling `$(this).data('href')`. Neat-o!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个绑定中，可能有一个对你来说是新的项目，那就是jQuery的`.data()`函数的使用。HTML 5允许你通过使用以`data-`为前缀的属性直接在任何HTML元素上存储任意数据，而这种能力是jQuery
    Mobile功能的核心。任何你看到`data-role="something"`的地方，你都在看HTML 5数据的作用。此外，jQuery允许你通过使用`.data()`函数并传入你想查看的项目的键来检索任何`data-`值。在上面的情况中，我们将笔记的标题存储到了查看页面中的删除按钮上的`data-href`属性中。因为我们正在添加的绑定是一个分配给删除按钮的点击处理程序，所以我们可以通过调用`$(this).data('href')`来检索笔记的标题。太棒了！
- en: This will be the last function that we add in this chapter. Are you sad? It's
    a poignant moment for certain, but we can look back on this with fondness after
    you're a successful jQuery Mobile developer. Once again we start with an empty
    function which accepts a single argument, the title of the note we're deleting.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们在本章中添加的最后一个函数。你难过吗？这确实是一个令人难忘的时刻，但是在你成为一名成功的jQuery Mobile开发人员之后，我们可以怀着美好的回忆回顾这一刻。再次，我们从一个接受单个参数，即我们要删除的笔记的标题的空函数开始。
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Follow the function definition up with our helper function for retrieving notes:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 随后是我们用于检索笔记的辅助函数的函数定义：
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then we delete the note. You''ve already seen this in action when we reviewed
    `localStorage` so it should be familiar to you:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们删除笔记。你已经在我们审阅`localStorage`时看到了它的作用，所以应该对你来说很熟悉：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Deleting the note is followed in quick succession by writing the remaining notes
    back to `localStorage`. The final two lines in the `deleteNote()` function take
    us back to the main page of the app, the list of notes. They also trigger the
    original `checkForStorage()` function.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 删除备注紧随其后的是将剩余备注重新写入`localStorage`。`deleteNote()`函数中的最后两行将我们带回到应用程序的主页面，即备注列表。它们还会触发原始的`checkForStorage()`函数。
- en: '[PRE47]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The last line may seem odd to you, but keep in mind that we don't know in advance
    if there are still any notes left. Running through the storage check allows us
    to display the placeholder text, in case there are no notes. It's a good habit
    to get into, as it helps our app become less prone to errors.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行可能对你来说有些奇怪，但请记住，我们事先不知道是否还有任何备注。运行存储检查允许我们显示占位文本，以防没有备注。养成这种习惯很好，因为它有助于减少我们的应用程序出现错误的可能性。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built a living, breathing mobile application with jQuery
    Mobile. Stop and give yourself a pat on the back. We walked through the process
    of listing the requirements for our app, building the wireframes, and writing
    the HTML. We learned about HTML 5's `localStorage`, using templates for text replacement,
    and some of the cooler features of jQuery Mobile including dynamically adding
    and refreshing elements on the page.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 jQuery Mobile 构建了一个活生生的移动应用程序。停下来给自己一个赞。我们通过列出应用程序的要求、构建线框图和编写 HTML
    的过程来完成了这一过程。我们学习了关于 HTML 5 的`localStorage`，使用模板进行文本替换，以及 jQuery Mobile 的一些更酷的功能，包括动态添加和刷新页面上的元素。
- en: In the next chapter, you'll learn how to set global configuration options for
    jQuery Mobile, how to use other APIs within jQuery Mobile to work with forms and
    content blocks.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何为 jQuery Mobile 设置全局配置选项，如何在 jQuery Mobile 中使用其他 API 来处理表单和内容块。
