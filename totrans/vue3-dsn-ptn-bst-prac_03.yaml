- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Setting Up a Working Project
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置工作项目
- en: In the previous chapters, we laid the theoretical foundation for designing a
    web application in JavaScript using the *Vue 3 framework*. However, so far, we
    have not really gotten into a real project. That is what this chapter is about.
    We will use the new set of tools that comes along with Vue 3 to create a project
    from scratch and prepare a template that we will use in other projects. As is
    custom, this initial project for a web application is to build a *To-Do list*
    (the equivalent of *Hello World*). As we progress with the introduction of each
    new concept, we will over-engineer the application to turn it into something much
    more useful, or at the very least, more interesting to look upon.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们为使用 *Vue 3 框架* 设计 JavaScript Web 应用程序奠定了理论基础。然而，到目前为止，我们还没有真正进入一个实际项目。这正是本章的内容。我们将使用
    Vue 3 伴随的新工具集从头开始创建一个项目，并准备一个我们将在其他项目中使用的模板。按照惯例，这个 Web 应用的初始项目是构建一个 *待办事项列表*（相当于
    *Hello World*）。随着我们对每个新概念的介绍，我们将过度设计应用程序，使其变得更有用，或者至少更吸引人。
- en: 'Some of the practical skills we will learn here are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将学习的一些实用技能如下：
- en: Setting up your working environment and **integrated development** **environment**
    (**IDE**)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置你的工作环境和 **集成开发** **环境**（**IDE**）
- en: Using the new command-line tools and the new **Vite** bundler to scaffold our
    application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的命令行工具和新的 **Vite** 打包器来构建我们的应用程序
- en: Modifying the basic template and folder structure to accommodate *best practices*
    and advanced architecture *design patterns*
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改基本模板和文件夹结构以适应 *最佳实践* 和高级架构 *设计模式*
- en: Integrating out-of-the-box **CSS frameworks** into our application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将现成的 **CSS 框架**集成到我们的应用程序中
- en: Configuring the Vite bundler to accommodate our needs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Vite 打包器以满足我们的需求
- en: Unlike in previous chapters, this one will be mostly practical, and there will
    be references to the official documentation for each element of the ecosystem,
    as these change from time to time. You don’t need to memorize the steps, as starting
    up a project from scratch is not so common for large projects and the tools to
    scaffold them evolve. Let’s start.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章不同，这一章将主要侧重于实践，并且会对生态系统中每个元素的官方文档进行参考，因为这些内容会不时发生变化。你不需要记住这些步骤，因为从头开始启动项目对于大型项目来说并不常见，而且构建这些项目的工具也在不断进化。让我们开始吧。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the practical steps in this chapter, you will need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的实际步骤，你需要以下内容：
- en: A computer running **Windows**, **Linux**, or **macOS** with a 64-bit architecture.
    I will be using **Ubuntu 22.04**, but these tools are cross-platform, and the
    steps translate between OSs (when something is different, I will point it out).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台运行 **Windows**、**Linux** 或 **macOS** 且具有 64 位架构的计算机。我将使用 **Ubuntu 22.04**，但这些工具是跨平台的，步骤可以在不同的操作系统之间转换（如果有不同之处，我会指出）。
- en: '**Node.js 16.16.0 LTS** with **npm** (**node package manager**) installed.
    You can find the steps to install Node.js in the official documentation, at [https://nodejs.org/](https://nodejs.org/).
    The building tools work on top of Node.js, so without this, you can’t go very
    far. Node.js is a JavaScript version adapted to run on servers and in systems
    “outside” the browser, something that makes it very, very handy and powerful.
    Most of today’s bundlers for web development use Node.js in one way or another,
    if not at least for the great convenience it provides.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js 16.16.0 LTS** 以及已安装的 **npm**（**节点包管理器**）。你可以在官方文档中找到安装 Node.js 的步骤，网址为
    [https://nodejs.org/](https://nodejs.org/)。构建工具在 Node.js 上运行，所以没有这个，你无法走得很远。Node.js
    是一个适用于在服务器和浏览器“外部”运行的 JavaScript 版本，这使得它非常方便且强大。今天的大多数 Web 开发打包器都以某种方式使用 Node.js，如果不是至少为了它提供的极大便利性。'
- en: A `Volar` plugin. The official site is [https://code.visualstudio.com/](https://code.visualstudio.com/),
    and in this book, we will be using this editor as the recommended IDE to work
    with Vue and Vite.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `Volar` 插件。官方网站是 [https://code.visualstudio.com/](https://code.visualstudio.com/)，在这本书中，我们将使用这个编辑器作为推荐的开发环境（IDE）来与
    Vue 和 Vite 一起工作。
- en: '**Sublime Text** (free trial/paid): This is another popular option, especially
    among macOS users. The official site is [https://www.sublimetext.com/](https://www.sublimetext.com/).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sublime Text**（免费试用/付费）：这是另一个流行的选择，尤其是在 macOS 用户中。官方网站是 [https://www.sublimetext.com/](https://www.sublimetext.com/)。'
- en: '**Jetbrains WebStorm** (free trial, paid): The official site is [https://www.jetbrains.com/webstorm/](https://www.jetbrains.com/webstorm/).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jetbrains WebStorm**（免费试用，付费）：官方网站是[https://www.jetbrains.com/webstorm/](https://www.jetbrains.com/webstorm/)。'
- en: '**Komodo IDE** (free): The official site is [https://www.activestate.com/products/komodo-ide/](https://www.activestate.com/products/komodo-ide/).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Komodo IDE**（免费）：官方网站是[https://www.activestate.com/products/komodo-ide/](https://www.activestate.com/products/komodo-ide/)。'
- en: '**NetBeans IDE** (free): The official site is [https://netbeans.apache.org/](https://netbeans.apache.org/).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NetBeans IDE**（免费）：官方网站是[https://netbeans.apache.org/](https://netbeans.apache.org/)。'
- en: A **console** or **terminal emulator**. Users of Linux and macOS will be most
    familiar with this concept. Windows users can use **Command Prompt**, an integrated
    terminal on some IDEs, or install a **Windows Terminal** from the Microsoft Store.*   A
    modern web browser, either based on the Chromium engine (Google Chrome, Microsoft
    Edge, Opera, Brave, Vivaldi, etc.) or Mozilla Firefox.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制台**或**终端模拟器**。Linux和macOS用户对此概念最为熟悉。Windows用户可以使用**命令提示符**，某些IDE的集成终端，或者从Microsoft
    Store安装**Windows Terminal**.*   一个现代的网页浏览器，无论是基于Chromium引擎（Google Chrome、Microsoft
    Edge、Opera、Brave、Vivaldi等）还是Mozilla Firefox。'
- en: With these installed, we are ready to follow the examples and basic projects.
    However, I would recommend that you also install **Git**, for code versioning
    control. We will use it later in this book, in [*Chapter 9*](B18602_09.xhtml#_idTextAnchor199),
    *Testing and Source Control*. In modern development, it is hard to imagine working
    on a project without some tool to keep track of code changes and version control.
    Git has become the industry standard. You can install it following the documentation
    from the official website at [https://git-scm.com/](https://git-scm.com/).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 安装好这些工具后，我们就可以开始跟随示例和基本项目了。然而，我建议您也安装**Git**，用于代码版本控制。我们将在本书的[*第9章*](B18602_09.xhtml#_idTextAnchor199)
    *测试和源代码控制*中使用它。在现代开发中，很难想象在没有一些工具来跟踪代码更改和版本控制的情况下进行项目工作。Git已成为行业标准。您可以通过访问官方网站上的文档进行安装：[https://git-scm.com/](https://git-scm.com/)。
- en: 'The code files of this chapter can be found on GitHub here: [https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter03](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter03).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：[https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter03](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter03)。
- en: 'Check out the following video to see the Code in Action: [https://packt.link/CmuO9](https://packt.link/CmuO9)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://packt.link/CmuO9](https://packt.link/CmuO9)
- en: Now, with our tools in place, we are ready to start our first project in Vue
    3.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着我们的工具准备就绪，我们就可以开始我们的第一个Vue 3项目了。
- en: Project setup and tools
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置和工具
- en: 'We will create a new project using **Vite** as our bundler, directly from the
    command line. Open a terminal window in the directory where you will place our
    project, and follow these steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**Vite**作为打包器，直接从命令行创建一个新的项目。在您将放置项目的目录中打开一个终端窗口，并按照以下步骤操作：
- en: 'Type the following command:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令：
- en: '`$ npm create vite@latest`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ npm create vite@latest`'
- en: If you get a prompt to install additional packages, type `Y` (yes).
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果出现提示安装附加包，请输入`Y`（是）。
- en: 'Next, you will be prompted to enter project information in the following order:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您将被提示按照以下顺序输入项目信息：
- en: '`.`) as the name.'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.`) 作为名称。'
- en: '`chapter-3` (or any name of your choosing). This option may not show if you
    entered or accepted a project name or accepted the default name suggested. If
    you entered a period (`.`) as the name to create the project in the current directory,
    then this option will be mandatory.'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`chapter-3`（或您选择的任何名称）。如果已输入或接受了一个项目名称或接受默认名称，则此选项可能不会显示。如果您输入点（`.`）作为创建项目的名称，那么此选项将是强制性的。'
- en: '`vue` with the arrow keys and press *Enter*.'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用箭头键选择`vue`并按*Enter*键。
- en: '**Select variant:** Just like before, use the arrow keys and select JavaScript
    (or TypeScript, but we will use plain JavaScript throughout this book).'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选择版本**：就像之前一样，使用箭头键选择JavaScript（或TypeScript，但本书我们将使用纯JavaScript）。'
- en: 'Next, you will see how the assistant downloads additional content based on
    your selections and scaffolds the project. It will create a directory structure
    with multiple files. However, if we intend to run the project, we soon will discover
    that it just doesn’t work. That is because the scaffolding does not install dependencies,
    only the skeleton. So, there is still one more step to do, and that is to install
    the dependencies using `npm`. In the terminal, enter the following command and
    hit *Enter* (if you installed in the current directory; if not, first enter the
    directory just created):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将看到助手如何根据您的选择下载额外内容并搭建项目。它将创建一个包含多个文件的目录结构。然而，如果我们打算运行项目，我们很快就会发现问题在于它根本无法工作。这是因为搭建过程并没有安装依赖项，只是提供了一个骨架。因此，我们还需要再进行一个步骤，那就是使用`npm`安装依赖项。在终端中，输入以下命令并按*Enter*（如果您是在当前目录下安装的；如果不是，首先进入刚刚创建的目录）：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The package manager will download and install the dependencies for our project
    and place them in a new directory named `node_modules`. As you can guess already,
    our development environment for **Vue** with **Vite** is a **Node.js** project.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理器将下载并安装我们项目的依赖项，并将它们放置在一个名为`node_modules`的新目录中。正如您所猜测的，我们使用Vite的**Vue**开发环境是一个**Node.js**项目。
- en: 'With the dependencies in place, now is the time to run the project and see
    what the scaffolding tool prepared for us. In the terminal, enter the following
    command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项就绪后，现在就是运行项目并查看搭建工具为我们准备了什么的时候了。在终端中，输入以下命令：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'What happens next may be quite fast. Vite will parse your project files and
    launch a developer server on your machine with a web address that you can use
    in your browser. You will see something like this in your terminal:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来发生的事情可能相当快。Vite将解析您的项目文件，并在您的机器上启动一个开发服务器，您可以在浏览器中使用这个网址。您在终端中会看到如下内容：
- en: '![Figure 3.1 - The result of running the development server with Vite](img/Figure_3.01_B18602.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 - 使用Vite运行开发服务器的结果](img/Figure_3.01_B18602.jpg)'
- en: Figure 3.1 - The result of running the development server with Vite
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 - 使用Vite运行开发服务器的结果
- en: 'The most important information here is `localhost` and the port where your
    project website is being served. The milliseconds shown there are just to let
    you know how fast Vite is to get you up and running (bragging rights, if you ask
    me). Next, to see the results of our labor so far, open the **local address**
    in your web browser, and you should be welcomed by a website looking something
    like the following screen:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最重要的信息是`localhost`和您的项目网站正在提供服务的端口。显示的毫秒数只是为了让您知道Vite启动的速度有多快（如果您问我，这就是炫耀的权利）。接下来，为了查看我们到目前为止的工作结果，请在您的网络浏览器中打开**本地地址**，您应该会看到一个类似于以下屏幕的网站：
- en: '![ Figure 3.2: Basic Vite + Vue project in the browser](img/Figure_3.02_B18602.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2：浏览器中的基本Vite + Vue项目](img/Figure_3.02_B18602.jpg)'
- en: 'Figure 3.2: Basic Vite + Vue project in the browser'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：浏览器中的基本Vite + Vue项目
- en: This website is fully functional as it is, if not very productive. To test that
    Vue 3 is working, click the button in the middle of the screen and you’ll see
    how the counter increases with each click. This is reactivity in action! Moreover,
    Vite offers us a development server with live updates and **Hot Module Replacement**
    (**HMR**), which means that as soon as we make changes in our code and save the
    files, the website will update automatically. In practice, it is very common when
    developing user interfaces to keep this self-updating site open in the browser
    to preview our work, and in some cases, several browsers at the same time. Very
    neat!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网站本身已经完全可用，尽管不是非常高效。为了测试Vue 3是否工作正常，点击屏幕中间的按钮，您会看到每次点击计数器都会增加。这就是响应性的体现！此外，Vite为我们提供了一个带有实时更新和**热模块替换**（**HMR**）的开发服务器，这意味着只要我们在代码中进行更改并保存文件，网站就会自动更新。在实践中，当开发用户界面时，通常会在浏览器中保持这个自更新网站打开以预览我们的工作，在某些情况下，甚至同时打开几个浏览器。非常方便！
- en: We have advanced in our journey, but we are far from over. The scaffolded site
    is nothing more than a starting point. We will modify it to better serve our purposes
    and will create a simple To-Do application in the rest of the chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在这段旅程中取得了进步，但距离终点还远。搭建的网站不过是一个起点。我们将对其进行修改，以更好地满足我们的需求，并在本章的剩余部分创建一个简单的待办事项应用。
- en: In the next section, we will take a closer look at the structure and organization
    of our starting project.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更详细地查看我们起始项目的结构和组织。
- en: Folder structure and modifications
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件夹结构和修改
- en: 'In [*Chapter 1*](B18602_01.xhtml#_idTextAnchor017), *The Vue 3 Framework*,
    we mentioned that frameworks prescribe some structure for your application. Vue
    3 is not an exception, but the conventions used in the directory structure are
    minimal when compared to other frameworks. If you open the directory where you
    installed the project in the Files Explorer (either from your OS or in your IDE),
    you will find a structure like this one:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B18602_01.xhtml#_idTextAnchor017)《Vue 3框架》中，我们提到框架为你的应用程序规定了一些结构。Vue
    3并不是例外，但与其他框架相比，目录结构中使用的约定是最小的。如果你在文件资源管理器中打开你安装项目的目录（无论是从你的操作系统还是在你的IDE中），你会找到一个类似这样的结构：
- en: '![Figure 3.3: Project structure in Visual Code](img/Figure_3.03_B18602.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3：Visual Code中的项目结构](img/Figure_3.03_B18602.jpg)'
- en: 'Figure 3.3: Project structure in Visual Code'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：Visual Code中的项目结构
- en: 'The `.vscode` folder was created by the IDE, and `node_modules` was created
    by `npm` to allocate the dependencies. We will ignore them, as we don’t need to
    worry or work with them. Starting from the top, let’s review what each directory
    is:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`.vscode`文件夹是由IDE创建的，`node_modules`是由`npm`创建的，用于分配依赖项。我们将忽略它们，因为我们不需要担心或处理它们。从顶部开始，让我们回顾每个目录的作用：'
- en: '`public`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`'
- en: This folder contains a directory structure and files that will not be processed
    by the bundler and will be copied directly into the final website. You can freely
    place your own static content here. This is where you will place your images,
    web fonts, third-party CSS libraries, icons, and so on. As a general rule, files
    here are those that will never be referenced by your code, such as `manifest.json`,
    `favicon.ico`, `robots.txt` and so on.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件夹包含目录结构和文件，这些文件不会被打包器处理，将被直接复制到最终网站中。你可以在这里自由放置自己的静态内容。这就是你将放置你的图片、网络字体、第三方CSS库、图标等的地方。一般来说，这里的文件是那些永远不会被你的代码引用的文件，例如`manifest.json`、`favicon.ico`、`robots.txt`等等。
- en: '`src`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`'
- en: 'Here is where we will place our JavaScript, dynamic CSS, components, and so
    on. If we expand this folder, we will find that the scaffolding tool has already
    created a minimal structure with the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里放置我们的JavaScript、动态CSS、组件等等。如果我们展开这个文件夹，我们会发现脚手架工具已经创建了一个最小结构，如下所示：
- en: An `assets` folder with an SVG file. In this folder, we can include files that
    will be manipulated either by the code or by the bundler. You can import them
    directly into your code, and the bundler will take care of mapping them properly
    when serving them on a web server.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含SVG文件的`assets`文件夹。在这个文件夹中，我们可以包含将被代码或打包器处理的文件。你可以直接将它们导入到你的代码中，打包器将负责在服务器上提供它们时正确映射它们。
- en: A `components` folder, where we will place our `.vue` extension. We can create
    the directory structure here as we please. The scaffolding tool has been placed
    inside a `HelloWorld.vue` component for us.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`components`文件夹，我们将在这里放置我们的`.vue`扩展。我们可以根据需要在这里创建目录结构。脚手架工具已经被放置在一个`HelloWorld.vue`组件中供我们使用。
- en: An `App.vue` file. This is the main component of our application and the root
    component of our hierarchy. It is a convention to call it this way.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`App.vue`文件。这是我们应用程序的主组件，也是我们层次结构的根组件。按照惯例，我们这样称呼它。
- en: A `main.js` file, which is the starting point of our application. It is in charge
    of loading the initial dependencies, the main component (`App.vue`), creating
    the Vue 3 application with all extras (plugins, global directives, and components),
    and launching and mounting the application to the web page.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`main.js`文件，这是我们的应用程序的起点。它负责加载初始依赖项、主组件（`App.vue`）、创建带有所有额外功能（插件、全局指令和组件）的Vue
    3应用程序，并将应用程序启动和挂载到网页上。
- en: A `styles.css` file, which is a global stylesheet that will apply to our entire
    application. Previous versions of the scaffolding tool used to place it in the
    `assets` folder, but now it has moved to the `src/` root giving it a more predominant
    place. This file, when imported into the `main.js` file, will be parsed and bundled
    with our JavaScript.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`styles.css`文件，这是一个全局样式表，将应用于我们的整个应用程序。之前的脚手架工具通常将其放置在`assets`文件夹中，但现在它已经移动到`src/`根目录，给它一个更突出的位置。当这个文件被导入到`main.js`文件中时，它将被解析并与我们的JavaScript打包。
- en: 'It is now time to investigate the files in the project root, in the same order
    as they appear:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候调查项目根目录中的文件了，按照它们出现的顺序：
- en: '`.gitignore` is a file that controls what is excluded from the Git source control.
    We will see Git in [*Chapter 9*](B18602_09.xhtml#_idTextAnchor199), *Testing and*
    *Source Control*.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.gitignore` 是一个控制从 Git 源代码控制中排除内容的文件。我们将在 [*第 9 章*](B18602_09.xhtml#_idTextAnchor199)
    中看到 Git，*测试和* *源代码控制*。'
- en: '`index.html` is the main file and the starting point for our web application.
    The bundler will start accessing and processing other files in the order they
    appear, starting with `index.html`. You can modify it to fit your needs, as the
    generated file is quite basic. Notice how towards the end of the `body` tag, the
    scaffolding tool included a `script` tag to load our `main.js` file. This file
    is the one that creates our Vue application. Unlike other bundlers that automatically
    generate this file and then inject it into `index.html`, Vite requires that you
    have this imported explicitly. Among other advantages, this gives you control
    of when the Vue application will be loaded inside your web page.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.html` 是主文件，也是我们 Web 应用的起点。打包器将按照文件出现的顺序开始访问和处理其他文件，首先是 `index.html`。你可以根据需要修改它，因为生成的文件相当基础。注意，在
    `body` 标签的末尾，脚手架工具包含了一个 `script` 标签来加载我们的 `main.js` 文件。这个文件就是创建我们的 Vue 应用的文件。与其他自动生成此文件并将其注入
    `index.html` 的打包器不同，Vite 要求你显式地导入它。除了其他优点之外，这让你可以控制 Vue 应用在网页中加载的时间。'
- en: '`package-lock.json` is used by `npm` to manage the dependencies in `node_modules`.
    Ignore it.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package-lock.json` 由 `npm` 用于管理 `node_modules` 中的依赖项。忽略它。'
- en: '`package.json` is very important. This file defines the project, keeps track
    of your development and production dependencies, and provides some nice features
    such as the automation of some tasks by simple commands. Of interest at this time
    is the `scripts` section, which defines simple aliases for commands. We can run
    these from the command line by typing `npm run <script name>`. The scaffolding
    tool already prepared three Vite commands for us:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.json` 文件非常重要。该文件定义了项目，跟踪你的开发和生产依赖项，并提供了一些便捷的功能，例如通过简单的命令自动化一些任务。目前值得关注的是
    `scripts` 部分，它定义了命令的简单别名。我们可以通过在命令行中输入 `npm run <script name>` 来运行这些命令。脚手架工具已经为我们准备好了三个
    Vite 命令：'
- en: '`npm run dev`: This will launch the website in developer mode, with a local
    server and live reload.'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm run dev`：这将以开发者模式启动网站，带有本地服务器和实时刷新。'
- en: '`npm run build`: This will bundle our code and optimize it to create a production-ready
    version.'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm run build`：这将打包我们的代码并将其优化，以创建一个生产就绪版本。'
- en: '`npm run preview`: This is a middle point between the previous two. It will
    allow you to see locally the built production-ready version. This may sound confusing
    until you consider that while in development, the addresses and resources that
    your application access, as well as the public URL, may be different than those
    in production. This option lets you run the application locally, but still reference
    and use those production endpoints and resources. It is a good practice to run
    a “preview” before you deploy your application.'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm run preview`：这是前两个选项之间的中间点。它将允许你在本地查看构建的生产就绪版本。这听起来可能有些令人困惑，直到你考虑到，在开发期间，你的应用程序访问的地址和资源，以及公共
    URL，可能与生产环境中的不同。此选项允许你在本地运行应用程序，但仍然引用和使用那些生产端点和资源。在部署应用程序之前运行“预览”是一个好的做法。'
- en: '`vite.config.js` is the configuration file that governs how Vite will behave
    during development and when bundling for production. We will see some of the most
    important or common options later in this chapter.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vite.config.js` 是一个配置文件，它决定了 Vite 在开发和打包生产版本时的行为。我们将在本章后面看到一些最重要的或常见的选项。'
- en: 'Now that we have a clearer view of what was given to us by the Vite scaffolding
    tool, it is time to start building our sample application. Before we dig deep
    into the code, there are a couple more items we need to address: how to integrate
    third-party stylesheets and CSS frameworks, and some Vite configurations that
    will make our life easier.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 Vite 脚手架工具提供的内容有了更清晰的了解，是时候开始构建我们的示例应用了。在我们深入代码之前，还有几件事情需要处理：如何集成第三方样式表和
    CSS 框架，以及一些会使我们的生活更轻松的 Vite 配置。
- en: Integration with CSS frameworks
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 CSS 框架的集成
- en: 'If we remember the last three principles discussed in [*Chapter 2*](B18602_02.xhtml#_idTextAnchor040),
    *Software Design Principles and Patterns*, (*don’t repeat yourself*, *keep it
    clean*, and *code for the next*), reinventing the wheel in matters of visual appearance
    and graphic language is something not desirable in most cases. The web has an
    ever-growing collection of CSS frameworks and libraries that we can easily incorporate
    into our applications. From the old popular Bootstrap to atomic design, to utility
    classes such as Tailwind, and passing by graphics languages such as Material Design
    and skeuomorphism, the spectrum of options is huge. Vue has a good number of component
    libraries already implementing some of these libraries, which you can find in
    the `npm` repositories. Using these, you’ll be restricted to learning about and
    applying the conventions applied by the designer, which, in some cases, may set
    in stone how you can build your user interface. Typical examples of these are
    the use of **Vue-material** (and others) that adheres to Google’s Material Design
    specifications or the incorporation of web fonts and icon fonts. It is impossible
    to discuss each one, but here are guidelines and some examples of how to incorporate
    these libraries into your project:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还记得在[*第二章*](B18602_02.xhtml#_idTextAnchor040)“软件设计原则和模式”中讨论的最后三个原则（*不要重复自己*、*保持简洁*和*为未来编写代码*），那么在视觉外观和图形语言方面重新发明轮子通常是不受欢迎的。网络上有不断增长的CSS框架和库集合，我们可以轻松地将它们整合到我们的应用程序中。从旧的流行Bootstrap到原子设计，再到像Tailwind这样的实用类，以及经过图形语言如Material
    Design和拟物主义，选项范围非常广泛。Vue已经有一些组件库实现了这些库中的一些，你可以在`npm`仓库中找到它们。使用这些库，你将局限于了解和应用设计师应用的约定，这在某些情况下可能会使你构建用户界面的方式变得固定。这些典型的例子包括使用**Vue-material**（以及其他）遵守Google的Material
    Design规范或整合网络字体和图标字体。不可能讨论每一个，但这里有一些指南和一些示例，说明如何将这些库整合到你的项目中：
- en: Place the static assets provided by the framework or library in the `public`
    folder, following their required structure, and respecting whatever tree structure
    is needed.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照框架或库提供的静态资产的要求结构，将它们放置在`public`文件夹中，并尊重所需的树结构。
- en: Include the dependencies for the CSS framework or libraries in your `index.html`
    file, following their instructions. Often, this will imply importing stylesheets
    and JavaScript files in the `head` section or the `body` tag. In either case,
    make sure these are placed before the loading of our application (the `script`
    tag that references our `main.js` file).
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`index.html`文件中包含CSS框架或库的依赖项，按照它们的说明进行。通常，这意味着在`head`部分或`body`标签中导入样式表和JavaScript文件。在任何情况下，确保这些文件在我们应用程序加载之前放置（引用我们的`main.js`文件的`script`标签）。
- en: If the framework or library needs to be instantiated, do so before we mount
    our application. You can do this directly in `index.html` in a `script` tag, in
    `main.js`, or in another module.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果框架或库需要实例化，请在挂载我们的应用程序之前进行。你可以在`index.html`中的`script`标签、`main.js`或另一个模块中直接这样做。
- en: Use the classes (and JavaScript functions) in your component’s template section
    normally, as you would in plain HTML using these libraries. Some frameworks create
    JavaScript global objects attached to the `window` object, so you can access them
    directly in your component’s `script` section. If this is not the case, consider
    encapsulating the functionality to use it in your application, using a design
    pattern such as a *singleton*, *proxy*, or *decorator* patterns.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件的模板部分通常使用类（以及JavaScript函数），就像在纯HTML中使用这些库一样。一些框架会在`window`对象上创建JavaScript全局对象，因此你可以在组件的`script`部分直接访问它们。如果不是这种情况，考虑使用设计模式如*单例*、*代理*或*装饰者*模式来封装功能，以便在应用程序中使用。
- en: Now let’s put these simple instructions to work by applying them to our example
    project. We will incorporate a CSS-only framework (meaning that it doesn’t use
    additional JavaScript), and font icons to include basic iconography. In a production
    build, we should remove unused CSS rules. Some CSS frameworks provide this feature
    out of the box, such as Tailwind ([https://tailwindcss.com/](https://tailwindcss.com/)).
    However, this topic is beyond the scope of this book but is worth researching
    online.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将这些简单的说明付诸实践，应用到我们的示例项目中。我们将整合一个仅使用CSS的框架（这意味着它不使用额外的JavaScript），以及字体图标来包含基本的图标。在生产构建中，我们应该删除未使用的CSS规则。一些CSS框架提供了这个功能，例如Tailwind
    ([https://tailwindcss.com/](https://tailwindcss.com/))。然而，这个主题超出了本书的范围，但值得在网上进行研究。
- en: The w3.css framework
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The w3.css框架
- en: 'The website [w3school.com](http://w3school.com) offers a free CSS-only framework
    that is partially based on the Material Design language, made popular by Google,
    and used in many mobile applications. It offers many utility classes that you
    can implement, license-free, in your applications. You can find out more on the
    official website: [https://www.w3schools.com/w3css/](https://www.w3schools.com/w3css/).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 网站 [w3school.com](http://w3school.com) 提供了一个基于Google流行的Material Design语言的部分CSS框架，用于许多移动应用程序。它提供了许多你可以免费实施的应用程序实用类。你可以在官方网站上了解更多信息：[https://www.w3schools.com/w3css/](https://www.w3schools.com/w3css/)。
- en: 'We will follow the guidelines mentioned before, so let’s follow the steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循之前提到的指南，所以让我们按照以下步骤进行：
- en: 'Download the `w3.css` file from [https://www.w3schools.com/w3css/w3css_downloads.asp](https://www.w3schools.com/w3css/w3css_downloads.asp)
    and place it in a new folder named `css` in the `public` directory. When you are
    done, it should look like this:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://www.w3schools.com/w3css/w3css_downloads.asp](https://www.w3schools.com/w3css/w3css_downloads.asp)
    下载`w3.css`文件，并将其放置在`public`目录中名为`css`的新文件夹中。完成后，它应该看起来像这样：
- en: '![Figure 3.4 - Location for the w3.css file](img/Figure_3.04_B18602.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 - w3.css文件的位置](img/Figure_3.04_B18602.jpg)'
- en: Figure 3.4 - Location for the w3.css file
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 - w3.css文件的位置
- en: 'Modify `index.html` at the root of our project by adding the reference to the
    `w3.css` file using a `link` tag like this:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加类似这样的`link`标签来修改我们项目的根目录下的`index.html`文件，引用`w3.css`文件：
- en: '[PRE2]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With that inclusion, the classes defined in the CSS file are now ready to be
    used in our component’s templates. Also, to avoid unwelcome styles from the scaffolding
    of a project, remember to clear the `styles.css` file provided by the installer.
    If we now run the development server with `npm run dev`, we will see that the
    appearance of the website has changed slightly, as the new stylesheet has been
    successfully applied. The next step now is to add an *icon font*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次添加，CSS文件中定义的类现在可以用于我们的组件模板中。为了避免项目脚手架中不欢迎的样式，请记住清除安装程序提供的`styles.css`文件。如果我们现在使用`npm
    run dev`运行开发服务器，我们会看到网站的外观略有变化，因为新的样式表已经成功应用。下一步现在是要添加一个 *图标字体*。
- en: FontAwesome is just awesome
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FontAwesome真是太棒了
- en: One of the ways that developers save resources when dealing with a multitude
    of icons is with the use of **font icons**. These are font files that, instead
    of characters, display icons. This concept is not new, but it has a lot of applications
    in web development. Using fonts for icons, as opposed to other techniques (such
    as CSS sprite sheets, for example) has plenty of benefits. One of the most relevant
    is that these icons are subject to the same manipulation as regular fonts, so
    we can easily alter their size, color, and so on, and keep them in coordination
    with the rest of the text. Not all is joy and happiness with this approach, since
    now, the major trade-off is that these icons display only one or two colors at
    most and have to be rather simple by necessity.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者在处理大量图标时节省资源的一种方法是通过使用 **字体图标**。这些是字体文件，它们显示图标而不是字符。这个概念并不新鲜，但在网络开发中有许多应用。与CSS精灵表等其他技术相比，使用字体作为图标有许多好处。其中最相关的一点是，这些图标可以像常规字体一样进行操作，因此我们可以轻松地改变它们的大小、颜色等，并使它们与文本保持协调。这种方法并非全是快乐和幸福，因为现在，主要的权衡是这些图标最多只能显示一种或两种颜色，并且必须从必要性出发相对简单。
- en: '**FontAwesome** is a website that offers **icon fonts** to use in our applications,
    both web and desktop. It has been doing this for years and has some of the best
    icon collections out there. We can download and use its free tier for our project.
    Let’s follow again the guidelines to implement them in our project:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**FontAwesome** 是一个提供 **图标字体** 以供我们在应用程序中使用（无论是网页还是桌面）的网站。它已经这样做了很多年，并且拥有一些最好的图标集合。我们可以下载并使用其免费层来为我们项目使用。让我们再次遵循指南，在我们的项目中实现它们：'
- en: Download the fonts *for the web* from [https://fontawesome.com/download](https://fontawesome.com/download).
    It will download a rather large ZIP file with all the different alternatives.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://fontawesome.com/download](https://fontawesome.com/download) 下载 *网页字体*。这将下载一个包含所有不同替代方案的相当大的ZIP文件。
- en: From within the ZIP file, copy the `css/` and `webfonts/` directories as they
    are, to our `public/` folder. We will not use everything in this folder in our
    projects here, so you can delete what we don’t use later.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从ZIP文件中，将`css/`和`webfonts/`目录原样复制到我们的`public/`文件夹中。我们在这里的项目中不会使用这个文件夹中的所有内容，所以你可以稍后删除我们不需要的部分。
- en: 'Edit the `index.html` file to add the stylesheets that we will use. These CSS
    files will automatically load the icon fonts from the `/``webfonts/` folder:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`index.html`文件以添加我们将使用的样式表。这些CSS文件将自动从`/webfonts/`文件夹加载图标字体：
- en: '[PRE3]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And that is all we need to do to include FontAwesome in our project. There
    are other alternatives that have encapsulated the fonts into Vue components, and
    even the website provides a Vue implementation. However, for our purposes in this
    book, we will use the *direct* approach. If we open the icons section of the site,
    we can browse and search all the available icons. You can restrict the search
    to “solid” and “brands” since those are the ones we have included in our project.
    For example, if you want to display the Vue icon using FontAwesome, we can include
    the following in our template:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们包含FontAwesome到项目中的所有需要做的事情。还有其他一些替代方案已经将字体封装到Vue组件中，甚至网站还提供了Vue实现。然而，就本书的目的而言，我们将使用*直接*方法。如果我们打开网站的图标部分，我们可以浏览和搜索所有可用的图标。你可以将搜索限制为“solid”和“brands”，因为这是我们项目中包含的。例如，如果你想使用FontAwesome显示Vue图标，我们可以在模板中包含以下内容：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'These classes make all the magic happen in any empty element, but for tradition
    and convenience, we always use the `i` tag. Moreover, you do not even need to
    type them. Once you locate the icon you want to use, the website offers this neat
    feature to “click and copy” the code. The previous line came from here:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类在任意空元素中实现所有魔法，但出于传统和方便的考虑，我们总是使用`i`标签。此外，你甚至不需要手动输入它们。一旦你找到了想要使用的图标，网站提供了一种“点击并复制”代码的便捷功能。上一行代码来自这里：
- en: '![ Figure 3.5 - FontAwesome icon page](img/Figure_3.05_B18602.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 - FontAwesome图标页面](img/Figure_3.05_B18602.jpg)'
- en: Figure 3.5 - FontAwesome icon page
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 - FontAwesome图标页面
- en: Let’s keep in mind that including a large library of icons when only using a
    few of them will impact performance. For production builds, ensure that you only
    include the icons you will use in your application by creating icon fonts only
    with the necessary icons. For the purposes of our book and during development,
    we can skip this practice.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们记住，当只使用少量图标时，包含大量图标库会影响性能。对于生产构建，请确保你只包含你将在应用程序中使用的图标，通过仅使用必要的图标创建图标字体。就本书的目的和开发过程而言，我们可以跳过这一做法。
- en: With a nice stylesheet and some good icon fonts, we are almost ready to start
    our coding. There is just one more thing to do and it is to include a few extra
    options in our Vite configuration.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 配备了漂亮的样式表和一些好的图标字体后，我们几乎可以开始编码了。还有一件事要做，那就是在我们的Vite配置中包含一些额外的选项。
- en: Vite configuration options
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vite配置选项
- en: The `vite.config.js` file exports the configuration that Vite will use for development
    and also for production. Vite was meant to be functional for many different frameworks
    and not only for Vue 3, even though it is the official bundler for it. When we
    open the file, we notice that Vue is a plugin for Vite. Internally, Vite uses
    **Rollup.js** ([https://www.rollupjs.org/](https://www.rollupjs.org/)) and **esbuild**
    ([https://esbuild.github.io/](https://esbuild.github.io/)), for development and
    production build, respectively. This means that we can pass options to Vite, but
    also have even more fine-grained control over some edge cases by passing arguments
    to these two underlining tools. Additionally, you can pass different configurations
    for each processing mode (development and production), so we are not left without
    options here.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`vite.config.js`文件导出Vite将用于开发和生产的配置。Vite旨在适用于许多不同的框架，而不仅仅是Vue 3，尽管它是Vue 3的官方打包器。当我们打开文件时，我们注意到Vue是Vite的一个插件。内部，Vite分别使用**Rollup.js**([https://www.rollupjs.org/](https://www.rollupjs.org/))和**esbuild**([https://esbuild.github.io/](https://esbuild.github.io/))进行开发和生产构建。这意味着我们可以向Vite传递选项，还可以通过向这两个底层工具传递参数来对一些边缘情况有更精细的控制。此外，你可以为每种处理模式（开发和生产）传递不同的配置，所以我们在这里并不缺乏选项。'
- en: We will see some specific configurations for deployment in [*Chapter 10*](B18602_10.xhtml#_idTextAnchor224),
    *Deploying Your Application*, but for now, we will focus only on the development
    part with a few additions to keep us from typing too much and repeating ourselves
    in the code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第10章*](B18602_10.xhtml#_idTextAnchor224)“部署您的应用程序”中看到一些特定的部署配置，但到目前为止，我们将只关注开发部分，并添加一些内容以避免在代码中过多重复输入。
- en: 'Open the `vite.config.js` file and add the following import:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`vite.config.js`文件并添加以下导入：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Yes, the path import is not JavaScript, but Node.js, and we can do this because
    this file is read and executed in a Node.js context. It will never reach the browser
    or any JavaScriptcontext.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，路径导入不是JavaScript，而是Node.js，我们可以这样做，因为此文件是在Node.js上下文中读取和执行的。它永远不会到达浏览器或任何JavaScript上下文。
- en: 'Modify the export configuration so it looks like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 修改导出配置，使其看起来像这样：
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In these lines, we are indicating an alias named `@components` matched to the
    project path `/src/components`. This way, when we are importing components, we
    can avoid writing relative or full paths, and just reference the imports inside
    components in this manner:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些行中，我们指定了一个名为`@components`的别名，与项目路径`/src/components`匹配。这样，当我们导入组件时，我们可以避免编写相对路径或完整路径，只需以这种方式引用组件内部的导入：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Having aliases for paths is a nice feature to have for a developer experience.
    Paths to components can get quite long in a large project, and code reorganization
    does happen from time to time, making maintenance yet another point of possible
    disruption. Having an alias defined gives us more flexibility by making changes
    only in one place (*principle: Don’t* *repeat yourself*).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为路径设置别名是一个很好的开发者体验特性。在大型项目中，组件的路径可能会相当长，而且代码重组有时会发生，这使得维护又是一个可能的中断点。定义别名可以让我们通过只在一个地方进行更改来获得更多的灵活性（原则：不要*重复自己*）。
- en: You can find a complete reference of the Vite configuration file at [https://vitejs.dev/config.](https://vitejs.dev/config)
    Vite offers a short list of official plugins (such as for Vue) at https://vitejs.dev/plugins/,
    but the community has provided a fair share of plugins to cover many scenarios
    at https://github.com/vitejs/awesome-vite#plugins. These can be installed and
    imported into our configuration file when and if needed.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://vitejs.dev/config.](https://vitejs.dev/config)找到Vite配置文件的完整参考。Vite在[https://vitejs.dev/plugins/](https://vitejs.dev/plugins/)提供了一个官方插件短列表（例如Vue插件），但社区也提供了一些插件来覆盖许多场景，请访问[https://github.com/vitejs/awesome-vite#plugins](https://github.com/vitejs/awesome-vite#plugins)。这些插件可以在需要时安装并导入到我们的配置文件中。
- en: At this point, we have enough preparation done so we can move ahead and finally
    create our simple To-Do app.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了足够的准备工作，可以继续前进，最终创建我们的简单待办事项应用程序。
- en: The To-Do app
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 待办事项应用程序
- en: 'Our example application will build on the scaffolding files of a basic application.
    It will provide us with an input element to enter our to-do items and will display
    the list of tasks pending and completed. The purpose of this exercise is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例应用程序将基于基本应用程序的框架文件构建。它将为我们提供一个输入元素来输入我们的待办事项，并将显示待办和已完成的任务列表。这个练习的目的如下：
- en: Develop the application with live updates
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发具有实时更新的应用程序
- en: Create a component, with reactive elements in the `script` `setup` syntax
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个组件，使用`script` `setup`语法中的响应式元素
- en: Apply styles and icon fonts from third-party libraries
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用第三方库的样式和图标字体
- en: 'When we are done, we will have a simple website that should look like this
    (the to-do items have been added as an example):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成时，我们将拥有一个简单的网站，其外观应该如下（已添加待办事项作为示例）：
- en: '![ Figure 3.6 - The final result of our To-Do List application with styles
    applied](img/Figure_3.06_B18602.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 - 应用样式后的最终待办事项应用程序结果](img/Figure_3.06_B18602.jpg)'
- en: Figure 3.6 - The final result of our To-Do List application with styles applied
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 - 应用样式后的最终待办事项应用程序结果
- en: For the purpose of this exercise, we will develop the entire To-Do application
    in one single component, which we will import into our `main` component (`App.vue`).
    This, of course, is purposely breaking some of the principles that we saw in [*Chapter
    2*](B18602_02.xhtml#_idTextAnchor040), *Software Design Principles and Design
    Patterns*. In [*Chapter 4*](B18602_04.xhtml#_idTextAnchor102), *User Interface
    Composition with Components*, we will take this product and “make it right” with
    multiple components.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个练习的目的，我们将开发整个待办事项应用程序的一个单一组件，然后将其导入我们的`main`组件（`App.vue`）。当然，这是故意打破我们在[*第二章*](B18602_02.xhtml#_idTextAnchor040)，*软件设计原则和设计模式*中看到的一些原则。在[*第四章*](B18602_04.xhtml#_idTextAnchor102)，*组件用户界面组合*中，我们将使用这个产品并通过多个组件“使其正确”。
- en: 'In the application, the user will do the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，用户将执行以下操作：
- en: Type a short description and press the *Enter* key or click the plus sign to
    enter it as a task.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入简短描述并按*Enter*键或点击加号将其作为任务输入。
- en: The system will display the pending and completed tasks in separate lists, displaying
    how many are in each group.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统将显示待办和已完成任务分别在不同的列表中，显示每个组中有多少。
- en: The user can click on any task to mark if it has been done or undone, and the
    application will move it to the corresponding group.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户可以点击任何任务来标记它是否已完成或未完成，应用程序将将其移动到相应的组。
- en: Knowing how the application has to work, let’s move onto the code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 了解应用程序的工作方式后，让我们继续编写代码。
- en: App.vue
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: App.vue
- en: 'This is our main component. In the starter application, we need to remove the
    content from each section and change it to the following (we’ll explain next what
    each part does):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的主要组件。在启动应用程序中，我们需要从每个部分中删除内容，并更改为以下内容（我们将在下一节解释每个部分的作用）：
- en: '[PRE8]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the `script` section, we only need to import a component named `ToDos` (we
    will create this file next). Notice how we are using already an alias for the
    path (`@components`). Our main component will not handle any other data or functionality,
    and we are using it only as a wrapper to control the layout of this application.
    With that in mind, our template now will look like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在`script`部分，我们只需要导入一个名为`ToDos`的组件（我们将在下一节创建此文件）。注意我们是如何使用已经定义的别名来指定路径（`@components`）。我们的主组件不会处理任何其他数据或功能，我们只使用它作为包装器来控制这个应用程序的布局。考虑到这一点，我们的模板现在将看起来像这样：
- en: '[PRE9]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We declare a `div` element with a private class (`.app`) that we will define
    in the `style` section. We also applied one of the styles we imported from `W3.css`
    to give our application a background color. Inside our `div` element, we place
    our `ToDos` component. Notice that we are using the same name as imported into
    our `script` section in Pascal case. We can use this notation, or the HTML kebab-case
    equivalent, `<to-dos />`, (lowercase words separated by hyphens). However, the
    recommendation is to always use Pascal case in our templates, with multiple words,
    to avoid conflicts with HTML components, present or future. This name will be
    transformed into kebab case in the final HTML.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个具有私有类（`.app`）的`div`元素，我们将在`style`部分中定义它。我们还应用了我们从`W3.css`导入的一种样式，为我们的应用程序添加了背景颜色。在我们的`div`元素内部，我们放置了`ToDos`组件。注意我们使用的是与`script`部分导入时相同的名称，并且使用的是Pascal大小写。我们可以使用这种表示法，或者HTML的kebab-case等价表示法（`<to-dos
    />`，单词之间用连字符分隔，且为小写）。然而，建议在我们的模板中始终使用Pascal大小写，以避免与现有或未来的HTML组件发生冲突。这个名称将在最终的HTML中转换为kebab-case。
- en: 'Next, we will define the style, using the CSS `flex` layout to center our component
    in the center of the screen:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义样式，使用CSS的`flex`布局将组件居中显示在屏幕中央：
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With our main component in place, now let’s create our `ToDos` component in
    the `/src/components` directory, properly named `ToDos.vue`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在主组件就位后，现在让我们在`/src/components`目录中创建我们的`ToDos`组件，正确命名为`ToDos.vue`。
- en: ToDos.vue
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ToDos.vue
- en: 'In this component, we will place all the logic of this simple application.
    We will need the following reactive variables:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组件中，我们将放置这个简单应用程序的所有逻辑。我们需要以下响应式变量：
- en: A variable to capture the text from the input, and create our task
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个变量用于捕获输入框中的文本，并创建我们的任务
- en: 'An array where we will host our task objects with the following fields: a unique
    ID, a description, and a Boolean value to indicate whether it is complete or not'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数组，我们将在这里存放具有以下字段的任务对象：一个唯一的ID、一个描述和一个布尔值，用于指示它是否已完成
- en: A filtering function or computed property (or properties) to display only the
    tasks that are completed
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个过滤函数或计算属性（或属性），用于仅显示已完成的任务
- en: 'With the preceding requirements, let’s populate our `script` section with the
    following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的要求，让我们用以下代码填充我们的`script`部分：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We start by importing the `ref` and `computed` constructors from Vue in line
    `//1`, since this is all that we will need in this application from the framework.
    In line `//2`, we start declaring two constants to point to reactive values: `_todo_text`,
    which will host our user’s task description in the input element, and `_todo_list`,
    which will be the array of tasks (to-do items). In lines `//3` and `//4`, we declare
    two `computed` properties named `_pending` and `_done`. The first one will have
    a reactive array of all the to-do items that are incomplete, and the second one
    all those marked as completed. Notice that by using a `computed` property, we
    only need to keep a single array with all the items. Computed properties are used
    to get a view segment of the list according to our needs. This is a commonly used
    pattern for these kinds of circumstances as opposed to, for example, having two
    arrays for each group and moving items between them.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从第`//1`行开始导入Vue的`ref`和`computed`构造函数，因为这是我们在这个应用程序中需要从框架中获取的所有内容。在第`//2`行，我们开始声明两个常量来指向响应式值：`_todo_text`，它将在输入元素中存储用户的任务描述，以及`_todo_list`，它将是我们任务（待办项）的数组。在第`//3`行和第`//4`行，我们声明了两个名为`_pending`和`_done`的`computed`属性。第一个将包含所有未完成的待办项的响应式数组，第二个将包含所有标记为完成的项。请注意，通过使用`computed`属性，我们只需要保留一个包含所有项目的数组。`computed`属性用于根据我们的需求获取列表的视图段。这与，例如，为每个组保留两个数组并将项目在它们之间移动的常见模式相比，是一种常用的模式。
- en: Finally, we have a helper function in line `//5`, to reset the value of our
    item text, and in line `//6`, we have a simple function that checks the value
    of the description and creates a task (to-do item) to add to our list. It is important
    to note that the moment we modify `_task_list`, all the properties and variables
    that depend on it will be automatically re-evaluated. Such is the case with the
    `computed` properties.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第`//5`行，我们有一个辅助函数来重置项目文本的值，而在第`//6`行，我们有一个简单的函数，它检查描述的值并创建一个任务（待办项）添加到我们的列表中。重要的是要注意，当我们修改`_task_list`时，所有依赖于它的属性和变量都将自动重新评估。这种情况与`computed`属性相同。
- en: 'This is all that we will need in our component’s logic to achieve the results
    we want. Now, it is time to create the template with HTML. We will split the code
    into sections for convenience. The segments that appear highlighted mark those
    with bindings or interactions with the framework and our code in the `script`
    section:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的组件逻辑中，要实现我们想要的结果，我们只需要这些。现在，是时候用HTML创建模板了。为了方便，我们将代码分成几个部分。代码中突出显示的部分标记了与框架和`script`部分中的代码有绑定或交互的部分：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The template of our component starts in line `//1` by defining a wrapper element
    with some styles. Then, in line `//2`, we place a simple header with styles and
    an icon font. Notice how we are using CSS classes from the **W3 CSS framework**,
    at the same time as our own scoped styles. The next lines in the code will focus
    on capturing the user input:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件模板从第`//1`行开始，通过定义一个带有一些样式的包装元素来定义。然后，在第`//2`行，我们放置了一个带有样式和图标字体的简单标题。注意我们是如何同时使用**W3
    CSS框架**的CSS类和我们的作用域样式。接下来的代码行将专注于捕获用户输入：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The interactivity with the user starts in the section in line `//3`, where
    we define an input element and attach our `_todo_text` reactive variable with
    the `v-model` directive. From this time on, anything that the user types into
    our input box will be the value of our variable in the code. Just for convenience,
    we are also capturing the *Enter* key with the following attribute:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与用户的交互从第`//3`行的部分开始，我们在这里定义了一个输入元素，并使用`v-model`指令附加我们的`_todo_text`响应式变量。从这时起，用户在我们输入框中输入的任何内容都将是我们代码中变量的值。为了方便起见，我们还通过以下属性捕获了*Enter*键：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will trigger the `addToDo` function from our script. We will add the same
    in the plus button next to the input field, also on the `click` event:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这将触发脚本中的`addToDo`函数。我们将在输入字段旁边的加号按钮上添加相同的操作，也是在`click`事件上：
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This gives us two ways to enter our descriptions as tasks for our to-do list,
    using multiple events linked to the same function. The following code now focuses
    on displaying the input data:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了两种方式将我们的描述作为任务添加到待办事项列表中，即使用与同一功能相关联的多个事件。以下代码现在专注于显示输入数据：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To display our task list, we have two almost identical blocks of code, starting
    on lines `//4` and `//5` – one for the pending tasks and the other for the completed
    ones. We will only focus on the first block (starting on line `//4`) since the
    behavior of these blocks is almost the same. In the first `div` element, we create
    a small header that displays the number of items on the `_pending` array, by interpolating
    its length. We do this with the following line:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示我们的任务列表，我们有两个几乎相同的代码块，从第`//4`行和第`//5`行开始——一个用于待办任务，另一个用于已完成任务。我们只关注第一个代码块（从第`//4`行开始），因为这两个代码块的行为几乎相同。在第一个`div`元素中，我们创建了一个小标题，显示`_pending`数组中的项目数量，通过插值其长度。我们用以下行来完成这个操作：
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice how we can access the array attributes directly inside the double curly
    brackets, without the use of the `.value` attribute. While in our JavaScript code,
    we should write this as `_pending.value.length`, when we are using interpolation
    in our HTML, Vue is smart enough to identify the reactive variable in our `template`
    section and access the value directly. This is true for `computed` properties
    as well as reactive variables created with `ref()`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何在双大括号内直接访问数组属性，而不使用`.value`属性。虽然在我们的JavaScript代码中，我们应该写成`_pending.value.length`，但当我们使用HTML中的插值时，Vue足够智能，能够识别`template`部分中的响应式变量并直接访问其值。这对于`computed`属性以及使用`ref()`创建的响应式变量同样适用。
- en: In the next `div` element, we create a list with a `v-for/:key` directive that
    will iterate over our `_pending` array and create a copy of the element for each
    item. Inside each one, we can now reference each item with the name `todo`, which
    we declared in the `v-for` directive. Next, we wrap an `input` checkbox and a
    span inside a `label` element and bind the `todo.checked` property (Boolean) to
    the input with `v-model`. Vue will take care of assigning a `true` or `false`
    value depending on the state of the checkbox. When that happens, it will also
    trigger the recalculation of the `computed` properties and we will see how just
    by checking/unchecking an item, it moves between groups (pending and completed)
    and also updates the total number of each block. We also have a `span` element
    to display the text of the task.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个`div`元素中，我们创建了一个带有`v-for/:key`指令的列表，该指令将遍历我们的`_pending`数组并为每个项目创建一个元素副本。在每一个元素中，我们现在可以使用在`v-for`指令中声明的名称`todo`来引用每个项目。接下来，我们在`label`元素内包裹一个`input`复选框和一个`span`，并将`todo.checked`属性（布尔值）绑定到输入框上，使用`v-model`。Vue将负责根据复选框的状态分配`true`或`false`值。当发生这种情况时，它还会触发`computed`属性的重新计算，我们会看到只需通过勾选/取消勾选一个项目，它就会在组（待办和已完成）之间移动，并更新每个块的总量。我们还有一个`span`元素来显示任务的文本。
- en: Finally, for the cases when a list group is empty, we also have a `div` element
    that will be visible only when that list is empty in line `//``6` (`_pending.length==0`).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于列表组为空的情况，我们还有一个`div`元素，当该列表在第`//``6`行（`_pending.length==0`）为空时才会可见。
- en: As mentioned before, the part that displays our “done” list works in the same
    way, applying the same logic.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，显示“已完成”列表的部分也是以相同的方式工作，应用相同的逻辑。
- en: 'Our scoped styles will be quite small in this case, as we only need a couple
    of extra settings since most of the heavy lifting has been done using the `w3.css`
    library. Inside our `style` section, add the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的作用域样式将会相当小，因为我们只需要一些额外的设置，因为大部分繁重的工作都是使用`w3.css`库完成的。在我们的`style`部分中，添加以下内容：
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `todo-container` class limits the maximum and minimum width of our component,
    and we also modify the `label` element to display its children using the `flex`
    layout.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`todo-container`类限制了我们的组件的最大和最小宽度，我们还修改了`label`元素，使用`flex`布局显示其子元素。'
- en: 'To see the application in action, save all the changes and start the Vite development
    server with the following command in the terminal:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看应用程序的实际运行情况，保存所有更改，并在终端中使用以下命令启动Vite开发服务器：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once Vite is ready, open the address in the web browser just as we did before.
    If all is well, you should see our To-Do list working as expected. If not, check
    with the source code in the repository to make sure that your typed code matches
    the full example.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Vite准备就绪，就像我们之前做的那样，在网页浏览器中打开地址。如果一切顺利，你应该会看到我们的待办列表按预期工作。如果不这样，请检查存储库中的源代码，以确保你输入的代码与完整示例匹配。
- en: A quick critique of our To-Do application
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对我们的待办应用进行快速评估
- en: 'The application we just made is working and is a bit more advanced than a simple
    `Hello World` or a counter button. However, we have not applied all the best practices
    and patterns that we should or could. This is done on purpose, as a learning exercise.
    Sometimes, to know how to build something right, we first need to build it to
    work as is. In general, all engineering practices understand that there is an
    iterative refinement process that provides learning and sophistication with each
    interaction. Once we build our first prototype, it is time to take a step back
    and do a sincere critique of it, thinking about how we can improve it and do things
    better. In this case, here is our critique:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的应用程序正在运行，并且比简单的 `Hello World` 或计数按钮更高级一些。然而，我们还没有应用所有应该或可以应用的最佳实践和模式。这是故意的，作为一个学习练习。有时，为了知道如何正确构建某物，我们首先需要构建它以使其工作。一般来说，所有工程实践都理解，有一个迭代精炼的过程，每次交互都提供学习和成熟。一旦我们构建了第一个原型，就是时候退后一步，真诚地对其进行分析，思考我们如何改进它并做得更好。在这种情况下，以下是我们的分析：
- en: We have duplication of code in our template, as the `_pending` and `_done` computed
    properties are basically the same, with a minor difference based on the value
    of a variable.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的模板中，代码有重复，因为 `_pending` 和 `_done` 计算属性基本上是相同的，只是基于变量值的微小差异。
- en: We are not leveraging the power of components, as everything is built in a single
    component.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有充分利用组件的力量，因为一切都是在单个组件中构建的。
- en: Our component is also creating our models (the To-Do items), so our business
    logic is tied to our component.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的组件也在创建我们的模型（待办事项），因此我们的业务逻辑与我们的组件绑定。
- en: We have done very little in terms of input sanitization and control. It is foreseeable
    that some code, even equal inputs, will break our application.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在输入清理和控制方面，我们做得很少。可以预见，一些代码，甚至是相等的输入，都会破坏我们的应用程序。
- en: Our to-do list is volatile. A refresh of the page will wipe clean our list.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的待办事项列表是易变的。页面刷新将清除我们的列表。
- en: Our task only accommodates two states (done and pending). What if we want to
    have a third state or more? For example, in progress, waiting, or next in line?
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的任务只容纳两种状态（完成和待办）。如果我们想有第三种状态或更多状态怎么办？例如，进行中、等待或下一个？
- en: The current design does not provide a way to edit or delete a task once it has
    been created.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前设计不提供编辑或删除已创建任务的方法。
- en: We can only manage one list of items at a time.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们一次只能管理一个项目列表。
- en: As we move forward, we will improve our application and apply principles and
    patterns to make this a more resilient and useful application. In the next chapter,
    we will look at how to compose a web application with web components in a more
    approachable way.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进，我们将改进我们的应用程序，并应用原则和模式，使其成为一个更具弹性和有用的应用程序。在下一章中，我们将探讨如何以更易于接受的方式使用 Web
    组件来组合 Web 应用程序。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have started to create applications using real-life tools,
    from IDEs to command-line tools, to scaffold, preview, and build our application.
    We have also created a simple To-Do application and learned how we can integrate
    third-party CSS libraries and icon fonts into our application and defined some
    general guidelines to incorporate others. We also took a critical approach to
    our simple application as a step to improve its functionality and, at the same
    time, our skills. In the next chapter, we will look into how to better organize
    our code and create a component hierarchy to create our user interfaces.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经开始使用真实工具创建应用程序，从 IDE 到命令行工具，以构建、预览和构建我们的应用程序。我们还创建了一个简单的待办事项应用程序，并学习了如何将第三方
    CSS 库和图标字体集成到我们的应用程序中，并定义了一些一般性指南以纳入其他库。我们还以批判性的态度对待我们的简单应用程序，作为提高其功能性和技能的步骤。在下一章中，我们将探讨如何更好地组织我们的代码并创建组件层次结构以创建我们的用户界面。
- en: Review questions
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习问题
- en: What are the requirements to develop a Vue 3 application with Vite?
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个使用 Vite 的 Vue 3 应用程序有哪些要求？
- en: Is it possible to integrate third-party libraries and frameworks with Vue 3?
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否可以将第三方库和框架与 Vue 3 集成？
- en: What are some steps to integrate a CSS-only library with a Vue application?
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 CSS-only 库集成到 Vue 应用程序中的一些步骤是什么？
- en: Is creating an application inside a single component a good idea? Why yes or
    no? Can you think of scenarios when a single-component application is the right
    fit? How about a scenario when it is not?
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单个组件中创建应用程序是一个好主意吗？为什么是或不是？你能想到哪些场景，单组件应用程序是合适的？又或者，有哪些场景它是不合适的？
- en: Why is software development an iterative refinement process?
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么软件开发是一个迭代精炼的过程？
