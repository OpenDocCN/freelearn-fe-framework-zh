- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Error Handling in Remix
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Remix的错误处理
- en: 'Error handling is an important part of building resilient user experiences.
    We can distinguish two kinds of errors:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理是构建弹性用户体验的重要组成部分。我们可以区分两种错误：
- en: Unexpected errors, such as network timeouts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意外错误，例如网络超时
- en: Expected failures (exceptions) thrown on purpose
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故意抛出的预期失败（异常）
- en: 'Remix provides primitives and conventions to handle both unexpected and expected
    errors uniformly. This chapter covers the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Remix提供了处理意外和预期错误的原语和约定。本章涵盖了以下主题：
- en: Dealing with unexpected errors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理意外错误
- en: Handling thrown responses
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理抛出的响应
- en: Handling page-not-found (404) errors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理页面未找到（404）错误
- en: First, we will fabricate some unexpected errors and learn how to handle them.
    Next, we will review the difference between returning and throwing `Response`
    objects in `loader` and `action` functions. We will see how we can handle thrown
    responses with Remix’s `ErrorBoundary`. Finally, we will add not-found error handling
    to BeeRich.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将制造一些意外错误并学习如何处理它们。接下来，我们将回顾在`loader`和`action`函数中返回和抛出`Response`对象之间的区别。我们将看到如何使用Remix的`ErrorBoundary`处理抛出的响应。最后，我们将向BeeRich添加未找到错误处理。
- en: After reading this chapter, you will understand how to manage both unexpected
    and expected failures in Remix declaratively using Remix’s `ErrorBoundary` component.
    You will also know how throwing responses fits into Remix’s exception-handling
    story and know the difference between throwing and returning responses. Finally,
    you will know how to handle not-found errors with Remix.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，您将了解如何使用Remix的`ErrorBoundary`组件声明式地管理意外和预期失败。您还将知道抛出响应如何融入Remix的异常处理故事，以及抛出和返回响应之间的区别。最后，您将了解如何使用Remix处理未找到错误。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can go ahead and use the solution from the previous chapter. No additional
    setup steps are required for this chapter. If you get stuck, you can find the
    solution code for this chapter here: https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/07-error-handling-in-remix.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以继续使用上一章中的解决方案。本章不需要额外的设置步骤。如果您遇到困难，可以在此处找到本章的解决方案代码：https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/07-error-handling-in-remix。
- en: Dealing with unexpected errors
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理意外错误
- en: During runtime, a Remix application is executed both in the browser and on the
    server. A lot can go wrong, and unexpected errors can happen both on the client
    and server. It is important to consider the error case to provide a resilient
    user experience. In this section, we will investigate how to handle unexpected
    errors in Remix both at the root level and in nested routes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，Remix应用程序在浏览器和服务器上执行。可能会出错，客户端和服务器上可能会发生意外错误。考虑错误情况以提供弹性用户体验非常重要。在本节中，我们将研究如何在Remix的根级别和嵌套路由中处理意外错误。
- en: Invoking client and server errors
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用客户端和服务器错误
- en: 'In [*Chapter 2*](B17399_02.xhtml#_idTextAnchor030), *Creating a New Remix App*,
    we provided a troubleshooting guide and investigated how Remix handles errors
    on both the client and server uniformly. Let’s review Remix’s default error handling
    again by invoking some “unexpected” errors:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B17399_02.xhtml#_idTextAnchor030)《创建新的Remix应用程序》中，我们提供了一个故障排除指南，并调查了Remix如何统一处理客户端和服务器上的错误。让我们通过调用一些“意外”的错误来再次回顾Remix的默认错误处理：
- en: Open your BeeRich application in an editor.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开您的BeeRich应用程序。
- en: Open the `dashboard.tsx` route module inside the `app/routes` folder.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/routes`文件夹中打开`dashboard.tsx`路由模块。
- en: 'Add the following code inside the `loader` function body before the return
    statement:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`loader`函数体中返回语句之前添加以下代码：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By throwing an error in a `loader` function, we prevent the application from
    handling incoming requests. This creates an unexpected failure on the server.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过在`loader`函数中抛出错误，我们阻止了应用程序处理传入的请求。这会在服务器上创建一个意外的失败。
- en: Execute `npm run dev` in a terminal to run the app.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中执行`npm run dev`以运行应用程序。
- en: Visit the BeeRich dashboard by opening [http://localhost:3000/dashboard](http://localhost:3000/dashboard)
    in a new browser window.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新浏览器窗口中打开[http://localhost:3000/dashboard](http://localhost:3000/dashboard)以访问BeeRich仪表板。
- en: 'Throwing an error in a `loader` function renders Remix’s error page, as visible
    in *Figure 7**.1*:'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`loader`函数中抛出错误会渲染Remix的错误页面，如*图7.1*所示：
- en: '![Figure 7.1 – Application error in the loader function](img/Figure_07.1_B17399.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – `loader`函数中的应用错误](img/Figure_07.1_B17399.jpg)'
- en: Figure 7.1 – Application error in the loader function
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.1** – 加载函数中的应用错误'
- en: '*Figure 7**.1* showcases Remix’s default behavior when handling unexpected
    errors. We can see our error message stating “Something went wrong!” on the screen
    and the stack trace of the `loader` function that failed to execute.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7**.1 展示了 Remix 处理意外错误时的默认行为。我们可以看到屏幕上显示的“出了点问题！”错误消息以及未能执行的 `loader` 函数的堆栈跟踪。'
- en: 'Now, let’s throw an error in a route component. Move the error from the `loader`
    function inside the `dashboard.tsx` route component:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在路由组件中抛出一个错误。将错误从 `loader` 函数移动到 `dashboard.tsx` 路由组件内部：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Refresh the browser window.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新浏览器窗口。
- en: By reloading the page, we trigger a full-page reload. Remix handles initial
    document requests on the server. Hence, the dashboard route module component is
    first called on the server, and we again throw an error on the server.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过重新加载页面，我们触发整个页面的重新加载。Remix 在服务器上处理初始文档请求。因此，仪表板路由模块组件首先在服务器上被调用，我们再次在服务器上抛出错误。
- en: The error stack trace changes, but Remix still displays “Something went wrong!”
    on the screen.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 错误堆栈跟踪会改变，但 Remix 仍然在屏幕上显示“出了点问题！”。
- en: 'Now, wrap the error inside a `useEffect` hook to ensure that the error is executed
    on the client instead:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将错误包裹在一个 `useEffect` 钩子中，以确保错误在客户端执行：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: React’s `useEffect` hook only executes on the client, not the server. This is
    because the hook is executed after the initial render, and on the server, we only
    render once.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: React 的 `useEffect` 钩子仅在客户端执行，不在服务器上执行。这是因为钩子在初始渲染之后执行，而在服务器上我们只渲染一次。
- en: Refresh the browser window one more time. You should see yet another stack trace
    on the page. This time, the stack trace originates from client-side scripts.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次刷新浏览器窗口。你应该在页面上看到另一个堆栈跟踪。这次，堆栈跟踪来自客户端脚本。
- en: 'As visible in *Figure 7**.2*, notice that the filenames in the stack trace
    include hashes. This means the files have been bundled and are part of the client
    bundle:'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如**图 7**.2 所示，请注意堆栈跟踪中的文件名包含哈希值。这意味着文件已被打包，并且是客户端打包的一部分：
- en: '![Figure 7.2 – Application error on the client](img/Figure_07.2_B17399.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![**图 7.2** – 客户端应用错误](img/Figure_07.2_B17399.jpg)'
- en: Figure 7.2 – Application error on the client
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.2** – 客户端应用错误'
- en: This experiment tells us that Remix provides the same default experience for
    both browser and server errors. Next, let’s replace Remix’s default error page
    with custom UIs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验告诉我们 Remix 为浏览器和服务器错误提供了相同的默认体验。接下来，让我们用自定义 UI 替换 Remix 的默认错误页面。
- en: Handling errors with the root error boundary
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用根错误边界处理错误
- en: In React, failures during rendering can be handled through error boundaries.
    Error boundaries are class components that implement the error boundary life cycle
    methods. Remix builds on top of React’s error boundaries and extends its capabilities
    to handle server-side errors. Instead of nesting React error boundaries inside
    our component tree, we declare them through Remix’s route module API by exporting
    an `ErrorBoundary` component in our route modules.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，渲染过程中的失败可以通过错误边界来处理。错误边界是实现了错误边界生命周期方法的类组件。Remix 在 React 的错误边界之上构建，并扩展了其功能以处理服务器端错误。我们不是在组件树中嵌套
    React 错误边界，而是通过在路由模块 API 中导出 `ErrorBoundary` 组件来声明它们。
- en: 'The `ErrorBoundary` component in the `root.tsx` route module is the topmost
    error boundary of our application. To replace Remix’s default error page, we need
    to export an `ErrorBoundary` component from `root.tsx`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`root.tsx` 路由模块中的 `ErrorBoundary` 组件是我们应用程序中最顶层的错误边界。为了替换 Remix 的默认错误页面，我们需要从
    `root.tsx` 导出 `ErrorBoundary` 组件：'
- en: Open the `app/root.tsx` route module in your editor.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的编辑器中打开 `app/root.tsx` 路由模块。
- en: 'Import the `useRouteError` hook from Remix:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Remix 导入 `useRouteError` 钩子：
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: import { H1 } from './components/headings';import { ButtonLink } from './components/links';export
    function ErrorBoundary() {  ErrorBoundary component is part of Remix’s route API
    and replaces the route module component in case of an error. We can access the
    error that caused the failure by calling useRouteError. We further use the error
    object to display an error message.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`import { H1 } from ''./components/headings'';import { ButtonLink } from ''./components/links'';export
    function ErrorBoundary() {  ErrorBoundary 组件是 Remix 路由 API 的一部分，并在发生错误时替换路由模块组件。我们可以通过调用
    useRouteError 访问导致失败的错误。我们进一步使用错误对象来显示错误信息。`'
- en: '[PRE4]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Fabricate an unexpected error and refresh the browser window to inspect the
    updated error page:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制造一个意外的错误，并刷新浏览器窗口以检查更新的错误页面：
- en: '![Figure 7.3 – Custom root ErrorBoundary component](img/Figure_07.3_B17399.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 自定义根 ErrorBoundary 组件](img/Figure_07.3_B17399.jpg)'
- en: Figure 7.3 – Custom root ErrorBoundary component
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 自定义根 ErrorBoundary 组件
- en: As visible in *Figure 7**.3*, we now render a custom error page for our application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 7.3* 所示，我们现在为我们的应用程序渲染了一个自定义错误页面。
- en: Investigate the code of the `ErrorBoundary` component in `root.tsx`. Notice
    that we render our styled `H1` and `ButtonLink` components. Why are our custom
    styles not applied to the page?
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `root.tsx` 中 `ErrorBoundary` 组件的代码。注意我们渲染了我们的样式化 `H1` 和 `ButtonLink` 组件。为什么我们的自定义样式没有应用到页面上？
- en: Review the `Meta`, `Links`, and `Scripts` components to append our meta and
    link tags and the client-side JavaScript scripts to the HTML document. This happens
    in the route module component in `root.tsx`. However, on error, we do not render
    the route module component but the `ErrorBoundary` component.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `Meta`、`Links` 和 `Scripts` 组件，将我们的元数据和链接标签以及客户端 JavaScript 脚本附加到 HTML 文档中。这发生在
    `root.tsx` 中的路由模块组件中。然而，在发生错误时，我们不渲染路由模块组件，而是渲染 `ErrorBoundary` 组件。
- en: Remix wraps the content of our error boundary in an HTML body tag by default.
    However, we can also provide a custom HTML document. Let’s update the code so
    that we render the `Meta`, `Links`, and `Scripts` components in the `root.tsx`
    file’s `ErrorBoundary` component.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Remix 默认将错误边界的内容包裹在一个 HTML body 标签中。然而，我们也可以提供一个自定义的 HTML 文档。让我们更新代码，以便在 `root.tsx`
    文件中的 `ErrorBoundary` 组件中渲染 `Meta`、`Links` 和 `Scripts` 组件。
- en: 'Create a new `Document` component in `root.tsx` so that we can reuse code between
    the `App` and `ErrorBoundary` components:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `root.tsx` 中创建一个新的 `Document` 组件，以便我们可以在 `App` 和 `ErrorBoundary` 组件之间重用代码：
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, update the `App` component so that it uses `Document`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新 `App` 组件以便它使用 `Document`：
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, wrap the content of the error boundary inside the `Document` component
    as well:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，也将错误边界的内容包裹在 `Document` 组件内部：
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Figure 7.4 – Styled root ErrorBoundary component](img/Figure_07.4_B17399.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 样式化根 ErrorBoundary 组件](img/Figure_07.4_B17399.jpg)'
- en: Figure 7.4 – Styled root ErrorBoundary component
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 样式化根 ErrorBoundary 组件
- en: Amazing! Now, we can utilize client-side JavaScript and our custom styles in
    the root `ErrorBoundary` component. One thing that we must keep in mind when reusing
    components for our `ErrorBoundary` component is that we can’t call the `useLoaderData`
    hook. Be sure not to render components that access loader data, as loader data
    is not defined when the `ErrorBoundary` component is rendered.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，我们可以在根 `ErrorBoundary` 组件中利用客户端 JavaScript 和我们的自定义样式。当我们为 `ErrorBoundary`
    组件重用组件时，我们必须记住的一件事是我们不能调用 `useLoaderData` 钩子。确保不要渲染访问 loader 数据的组件，因为在 `ErrorBoundary`
    组件渲染时，loader 数据未定义。
- en: Error boundaries don’t have access to useLoaderData
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 错误边界无法访问 useLoaderData
- en: An error boundary is rendered if an error occurs within the `loader` or `action`
    function of the route module. Conclusively, loader data is not available in the
    error boundary.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路由模块的 `loader` 或 `action` 函数中发生错误，则会渲染错误边界。最终，错误边界中不可用 loader 数据。
- en: The top-level `ErrorBoundary` component in BeeRich does not render any navigation
    bar or other layout components. Keeping the top-level `ErrorBoundary` component
    simple ensures that it renders even in the case of an unexpected failure.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: BeeRich 中的顶级 `ErrorBoundary` 组件不渲染任何导航栏或其他布局组件。保持顶级 `ErrorBoundary` 组件简单可以确保即使在意外失败的情况下也能渲染。
- en: Next, let’s see how we can improve error handling further by declaring nested
    error boundaries.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何通过声明嵌套错误边界来进一步改进错误处理。
- en: Nested error handling
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套错误处理
- en: Error boundaries can be nested. When an error is thrown, it bubbles upward through
    the route hierarchy until Remix finds the nearest error boundary. Nested error
    boundaries let us contain errors.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 错误边界可以嵌套。当抛出错误时，它会通过路由层次结构向上冒泡，直到 Remix 找到最近的错误边界。嵌套错误边界让我们能够包含错误。
- en: 'Let’s add a nested error boundary to the dashboard route module:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在仪表板路由模块中添加一个嵌套错误边界：
- en: Open the `dashboard.tsx` route module inside the `app/routes` folder.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app/routes` 文件夹内的 `dashboard.tsx` 路由模块。
- en: 'Add a simple `ErrorBoundary` export to the page:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面中添加一个简单的 `ErrorBoundary` 导出：
- en: '[PRE8]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, throw an error in the `dashboard.tsx` route module’s `loader` function:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `dashboard.tsx` 路由模块的 `loader` 函数中抛出一个错误：
- en: '[PRE9]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run the app and visit the dashboard by opening [http://localhost:3000/dashboard](http://localhost:3000/dashboard)
    in a new browser window.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用并在新浏览器窗口中打开 [http://localhost:3000/dashboard](http://localhost:3000/dashboard)
    访问仪表板。
- en: Note that we are not rendering the root error boundary but the one nested in
    `dashboard.tsx`. Remix uses the closest error boundary available and renders it
    within the parent route component’s `Outlet`.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们不是渲染根错误边界，而是在 `dashboard.tsx` 中嵌套的错误边界。Remix 使用最近的可用错误边界并在父路由组件的 `Outlet`
    中渲染它。
- en: 'Let’s make the error boundary look nice. Like we did in `root.tsx`, we want
    to share markup between the `ErrorBoundary` component and the route component.
    Refactor the route component so that it’s a reusable `Layout` component. First,
    remove `export default` from the function definition and add a `LayoutProps` type
    to specify the properties the component expects:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们让错误边界看起来更美观。就像我们在 `root.tsx` 中做的那样，我们希望在 `ErrorBoundary` 组件和路由组件之间共享标记。重构路由组件，使其成为一个可重用的
    `Layout` 组件。首先，从函数定义中移除 `export default` 并添加一个 `LayoutProps` 类型来指定组件期望的属性：
- en: '[PRE10]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Remove the `useLoaderData` call from the `Layout` function body. Since error
    boundaries cannot call `useLoaderData`, we must pass the loader data as optional
    props. As visible in `LayoutProps`, we ensure that the `Layout` component also
    accepts `null` as a value for `firstExpense` and `firstInvoice`. This can be the
    case if we don’t find any expenses or invoices in our database or when the error
    boundary is rendered.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Layout` 函数体中移除 `useLoaderData` 调用。由于错误边界不能调用 `useLoaderData`，我们必须将加载数据作为可选属性传递。如
    `LayoutProps` 所见，我们确保 `Layout` 组件也接受 `null` 作为 `firstExpense` 和 `firstInvoice`
    的值。这可能是在我们的数据库中没有找到任何费用或发票时，或者当错误边界被渲染时的情况。
- en: 'Replace the rendering of `Outlet` with `children`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Outlet` 的渲染替换为 `children`：
- en: '[PRE11]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: export default function Component() {  const { firstExpense, firstInvoice }
    = useLoaderData<typeof loader>();  return (    <Layout firstExpense={firstExpense}
    firstInvoice={firstInvoice}>      <Outlet />    </Layout>  );}
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`export default function Component() {  const { firstExpense, firstInvoice
    } = useLoaderData<typeof loader>();  return (    <Layout firstExpense={firstExpense}
    firstInvoice={firstInvoice}>      <Outlet />    </Layout>  );}'
- en: '[PRE12]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, update the `ErrorBoundary` component in `dashboard.tsx`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新 `dashboard.tsx` 中的 `ErrorBoundary` 组件：
- en: '[PRE13]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run the app and visit the [http://localhost:3000/dashboard](http://localhost:3000/dashboard)
    page.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序并访问 [http://localhost:3000/dashboard](http://localhost:3000/dashboard)
    页面。
- en: Without throwing an error, we should see the expense overview page. If you can’t
    remember why this is happening, look inside the `dashboard._index.tsx` route module.
    If the dashboard’s index route is active, it redirects to the expense overview
    page.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果没有抛出错误，我们应该看到费用概览页面。如果你不记得这是为什么，请查看 `dashboard._index.tsx` 路由模块内部。如果仪表板的索引路由是活动的，它将重定向到费用概览页面。
- en: 'Next, throw an error in any `loader` function or React component that is active
    inside the dashboard:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在任何活动在仪表板内的 `loader` 函数或 React 组件中抛出错误：
- en: '[PRE14]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The browser window should now render the styled nested error boundary. As visible
    in *Figure 7**.5*, adding an error boundary to the dashboard route lets us isolate
    the error and render all parent routes correctly:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 浏览器窗口现在应该渲染样式化的嵌套错误边界。如 *图 7**.5* 所见，将错误边界添加到仪表板路由中使我们能够隔离错误并正确渲染所有父路由：
- en: '![Figure 7.5 – Nested dashboard ErrorBoundary component](img/Figure_07.5_B17399.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 嵌套仪表板 ErrorBoundary 组件](img/Figure_07.5_B17399.jpg)'
- en: Figure 7.5 – Nested dashboard ErrorBoundary component
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 嵌套仪表板 ErrorBoundary 组件
- en: Nested error boundaries allow us to contain errors within a subset of the route
    hierarchy. This ensures that the parent routes render as expected. The closer
    the error boundary is to the error that occurred, the more contained the error
    will be.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套错误边界允许我们在路由层次结构的子集中包含错误。这确保了父路由按预期渲染。错误边界离发生的错误越近，错误就越被限制。
- en: In this section, you learned how to handle unexpected errors in Remix using
    Remix’s `ErrorBoundary` component. Next, let’s look at how to use the `ErrorBoundary`
    component to handle expected exceptions.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何使用 Remix 的 `ErrorBoundary` 组件来处理意外的错误。接下来，让我们看看如何使用 `ErrorBoundary`
    组件来处理预期的异常。
- en: Handling thrown responses
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理抛出的响应
- en: 'We already take advantage of throwing `Response` objects in BeeRich. For instance,
    in [*Chapter 4*](B17399_04.xhtml#_idTextAnchor057), *Routing in Remix,* we added
    the following `loader` function to the `dashboard.expenses.$id.tsx` route module:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 BeeRich 中利用了抛出 `Response` 对象的优势。例如，在 [*第 4 章*](B17399_04.xhtml#_idTextAnchor057)，*Remix
    中的路由*，我们在 `dashboard.expenses.$id.tsx` 路由模块中添加了以下 `loader` 函数：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the `loader` function, we throw a `Response` object if we cannot find the
    expense for the `id` route parameter. This creates an expected failure during
    `loader` function execution. Let’s investigate Remix’s default behavior when an
    expected exception occurs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `loader` 函数中，如果我们找不到 `id` 路由参数对应的费用，我们将抛出一个 `Response` 对象。这将在 `loader` 函数执行期间创建一个预期的失败。让我们调查
    Remix 在发生预期异常时的默认行为。
- en: Throwing responses
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抛出响应
- en: 'In JavaScript, the `throw` statement is used to throw user-defined exceptions.
    A `catch` block can then catch the thrown exception. We can throw any value, including
    `Response` objects. Remix takes advantage of this, offering a convention to stop
    `action` and `loader` functions early with exception responses. Let’s invoke the
    not-found response that was thrown in the expense details `loader`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，`throw` 语句用于抛出用户定义的异常。然后，`catch` 块可以捕获抛出的异常。我们可以抛出任何值，包括 `Response`
    对象。Remix 利用这一点，提供了一个约定来使用异常响应提前停止 `action` 和 `loader` 函数。让我们调用在费用详情 `loader` 中抛出的未找到响应：
- en: Run BeeRich on localhost by executing `npm` `run dev`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行 `npm run dev` 在本地主机上运行 BeeRich。
- en: Visit the expense overview page by opening [http://localhost:3000/dashboard/expenses](http://localhost:3000/dashboard/expenses)
    in a new browser window.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新浏览器窗口中打开 [http://localhost:3000/dashboard/expenses](http://localhost:3000/dashboard/expenses)
    访问费用概览页面。
- en: Now, click on an expense in the overview list. This will redirect us to the
    expense details page.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击概览列表中的费用。这将将我们重定向到费用详情页面。
- en: 'Replace the `id` route parameter in the URL with a fake one: [http://localhost:3000/dashboard/expenses/fake-id](http://localhost:3000/dashboard/expenses/fake-id).
    Then, reload the browser window.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 URL 中的 `id` 路由参数替换为假的：[http://localhost:3000/dashboard/expenses/fake-id](http://localhost:3000/dashboard/expenses/fake-id)。然后，重新加载浏览器窗口。
- en: This should render our dashboard error boundary to the page.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会将我们的仪表板错误边界渲染到页面上。
- en: Remix lets us handle unexpected errors and thrown responses uniformly with the
    `ErrorBoundary` component. Any `Response` object thrown in a `loader` or `action`
    function triggers the `ErrorBoundary` component.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 允许我们使用 `ErrorBoundary` 组件统一处理意外的错误和抛出的响应。在 `loader` 或 `action` 函数中抛出的任何
    `Response` 对象都会触发 `ErrorBoundary` 组件。
- en: Thrown responses allow us to retrieve additional information, such as the status
    code from the error in the `ErrorBoundary` component. For that, we need to check
    whether the thrown error object is a `Response` object or an unexpected error.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出的响应允许我们检索额外的信息，例如 `ErrorBoundary` 组件中错误的状态码。为此，我们需要检查抛出的错误对象是否是 `Response`
    对象或意外的错误。
- en: Handling exceptions with error boundaries
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用错误边界处理异常
- en: 'Let’s add a third error boundary, this time for the nested expense details
    page:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加第三个错误边界，这次是为嵌套费用详情页面：
- en: Open the `dashboard.expenses.$id.tsx` route module.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `dashboard.expenses.$id.tsx` 路由模块。
- en: 'Import Remix’s `useRouteError` and `isRouteErrorResponse` helpers:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 Remix 的 `useRouteError` 和 `isRouteErrorResponse` 辅助函数：
- en: '[PRE16]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a new `ErrorBoundary` export and add the following code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `ErrorBoundary` 导出，并添加以下代码：
- en: '[PRE17]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next, test the implementation. Navigate to an expense details page and use a
    fake `id` route parameter in the URL. You should now see the nested `ErrorBoundary`
    component rendered on the page.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，测试实现。导航到费用详情页面，并在 URL 中使用假的 `id` 路由参数。你现在应该能看到页面上的嵌套 `ErrorBoundary` 组件被渲染。
- en: Notice how we still render the expense overview list; this is the power of nested
    error handling!
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们仍然渲染了费用概览列表；这就是嵌套错误处理的力量！
- en: '![Figure 7.6 – Nested expense details ErrorBoundary component](img/Figure_07.6_B17399.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 嵌套费用详情 ErrorBoundary 组件](img/Figure_07.6_B17399.jpg)'
- en: Figure 7.6 – Nested expense details ErrorBoundary component
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 嵌套费用详情 ErrorBoundary 组件
- en: Now that we’ve implemented a nested error boundary for the expense details page,
    go ahead and implement the same experience for the income details page.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经为费用详情页面实现了嵌套错误边界，那么接下来为收入详情页面实现相同的体验。
- en: Once you’ve finished working on the income details page, we’ll revisit the unpleasant
    experience from [*Chapter 6*](B17399_06.xhtml#_idTextAnchor090), *Enhancing the*
    *User Experience*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成收入详情页面的工作，我们将重新审视来自 [*第 6 章*](B17399_06.xhtml#_idTextAnchor090)，*增强用户体验*
    的不愉快体验。
- en: Creating a resilient experience
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个有弹性的体验
- en: 'Do you remember that we created an unpleasant experience in [*Chapter 6*](B17399_06.xhtml#_idTextAnchor090),
    *Enhancing the User Experience,* when introducing the expense deletion form? If
    you are on an expense details page (`dashboard/expenses/$id`) and quickly delete
    all expenses in one go, you may end up on a not-found page. This is because of
    our redirect logic in the `dashboard/expenses/$id` `deleteExpense` function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们在[*第6章*](B17399_06.xhtml#_idTextAnchor090)，“增强用户体验”中引入支出删除表单时创建了一个不愉快的体验吗？如果你在一个支出详情页（`dashboard/expenses/$id`）上，并且一次性快速删除所有支出，你可能会结束在一个未找到的页面上。这是因为我们在`dashboard/expenses/$id`的`deleteExpense`函数中的重定向逻辑：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We use the `referer` header, if available, to redirect the user back to the
    current route after deletion. This is meant to improve the user experience. If
    the user is currently on the details page, `/dashboard/expenses/1`, and deletes
    the expense with `id` `2`, then we do not want to redirect the user away from
    `/dashboard/expenses/1`. However, we also have an `if` condition in the `deleteExpense`
    function to make sure that we do redirect the user if the user is currently on
    the details page of the expense that is being deleted.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如果可用，会使用`referer`头将用户在删除后重定向回当前路由。这是为了提升用户体验。如果用户当前在详情页，`/dashboard/expenses/1`，并且删除了`id`为`2`的支出，我们不希望将用户从`/dashboard/expenses/1`重定向走。然而，在`deleteExpense`函数中我们也有一个`if`条件来确保如果用户当前在要删除的支出的详情页上，我们会重定向用户。
- en: This logic fails when we quickly delete several expenses. Triggering many expense
    deletions simultaneously creates a race condition between the different action
    requests. It is going to be the response of the last triggered `action` that decides
    where the user is going to be redirected. However, by that time, we might have
    already deleted the expense that we currently have in the details view.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们快速删除多个支出时，这个逻辑会失败。同时触发多个支出删除操作会创建不同动作请求之间的竞争条件。最终决定用户将被重定向到哪里的将是最后触发的`action`的响应。然而，到那时，我们可能已经删除了当前在详情视图中查看的支出。
- en: Let’s say we are on the details page, `/dashboard/expenses/1`, and quickly delete
    the expenses with `id` `1` and then also with `id` `2`. In the `deleteExpense`
    function handling the deletion of expense `1`, we return a redirect to `/dashboard/expenses`
    since we know that expense `1` has been deleted. However, in the `deleteExpense`
    function handling the deletion of expense `2`, we will return a redirect to `/dashboard/expenses/1`
    (the current page). Remix takes the response of the last user action and commits
    to the redirect to `/dashboard/expenses/1`. We throw a 404 not-found error in
    the `loader` function as the expense with `id` `1` cannot be found (it has been
    deleted).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在详情页，`/dashboard/expenses/1`，并且快速删除了`id`为`1`的支出，然后又删除了`id`为`2`的支出。在处理删除支出`1`的`deleteExpense`函数中，我们知道支出`1`已经被删除，因此我们返回重定向到`/dashboard/expenses`。然而，在处理删除支出`2`的`deleteExpense`函数中，我们将返回重定向到当前页`/dashboard/expenses/1`。Remix会取最后用户动作的响应并提交重定向到`/dashboard/expenses/1`。我们在`loader`函数中抛出一个404未找到错误，因为`id`为`1`的支出找不到（它已经被删除了）。
- en: As shown in *Figure 7**.6*, we've enhanced the user experience by introducing
    the nested `ErrorBoundary` component for expense details. Nice! Now, if there's
    a 404 error, the user stays on the expenses overview page, and the error is contained
    in the nested `ErrorBoundary`. We avoid showing the user a full-screen error message
    and instead gracefully display the not-found error as part of the dashboard UI.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图7**.6所示，我们通过引入嵌套的`ErrorBoundary`组件来增强支出详情的用户体验。太棒了！现在，如果出现404错误，用户将停留在支出概览页，错误被包含在嵌套的`ErrorBoundary`中。我们避免了向用户显示全屏的错误消息，而是优雅地将未找到错误作为仪表板UI的一部分显示。
- en: Declarative error handling
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式错误处理
- en: Remix’s error boundaries let us handle errors and exceptions declaratively.
    By adding nested error boundaries, we can handle edge cases gracefully for a resilient
    user experience.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Remix的错误边界允许我们声明式地处理错误和异常。通过添加嵌套的错误边界，我们可以优雅地处理边缘情况，以提供弹性的用户体验。
- en: Now that we’ve ensured a resilient user experience with nested error boundaries,
    let’s enhance the root error boundary with custom error messages for common HTTP
    status codes. In the next section, we will handle page-not-found errors.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过嵌套错误边界确保了弹性的用户体验，让我们增强根错误边界，为常见的HTTP状态码添加自定义错误消息。在下一节中，我们将处理页面未找到错误（404）。
- en: Handling page-not-found (404) errors
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理页面未找到（404）错误
- en: 'We can also handle thrown responses in the root `ErrorBoundary` component.
    One special case that can only be handled in the root `ErrorBoundary` component
    is the page-not-found exception thrown by Remix. Let’s revisit the root error
    boundary to handle thrown responses at the root level:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在根`ErrorBoundary`组件中处理抛出的响应。一个只能在根`ErrorBoundary`组件中处理的特殊情况是Remix抛出的页面未找到异常。让我们回顾根错误边界以在根级别处理抛出的响应：
- en: Run BeeRich on localhost by executing `npm` `run dev`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`npm run dev`在本地运行BeeRich。
- en: Visit a non-existing page such as [http://localhost:3000/cheesecake](http://localhost:3000/cheesecake)
    in a new browser window.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新浏览器窗口中访问一个不存在的页面，例如[http://localhost:3000/cheesecake](http://localhost:3000/cheesecake)。
- en: When visiting a non-existing route, Remix throws a response with HTTP status
    code 404 at the root level. We can use `isRouteErrorResponse` to render a 404
    page using the root error boundary.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当访问一个不存在的路由时，Remix会在根级别抛出一个带有HTTP状态码404的响应。我们可以使用`isRouteErrorResponse`来使用根错误边界渲染一个404页面。
- en: Open the `root.tsx` file in an editor.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开`root.tsx`文件。
- en: 'Import `isRouteErrorResponse` from Remix:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Remix导入`isRouteErrorResponse`：
- en: '[PRE19]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'const error = useRouteError();let heading = ''Unexpected Error'';let message
    =  ''We are very sorry. An unexpected error occurred. Please try again or contact
    us if the problem persists.'';if (H1 and p texts with the heading and message
    values:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'const error = useRouteError();let heading = ''Unexpected Error'';let message
    =  ''We are very sorry. An unexpected error occurred. Please try again or contact
    us if the problem persists.'';if (H1 and p texts with the heading and message
    values:'
- en: '[PRE20]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Revisit [http://localhost:3000/cheesecake](http://localhost:3000/cheesecake).
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次访问[http://localhost:3000/cheesecake](http://localhost:3000/cheesecake)。
- en: 'You should now see the 404 not-found page shown in *Figure 7**.7*:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你现在应该能看到*图7.7*中显示的404未找到页面。7*：
- en: '![Figure 7.7 – Screenshot of BeeRich’s 404 page](img/Figure_07.7_B17399.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7 – BeeRich的404页面截图](img/Figure_07.7_B17399.jpg)'
- en: Figure 7.7 – Screenshot of BeeRich’s 404 page
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – BeeRich的404页面截图
- en: Great! We’ve added root and nested error boundaries to BeeRich. Note that we
    can throw custom 404 responses in `loader` and `action` functions. Nested error
    boundaries can handle these thrown exceptions. Remix throws a root-level 404 response
    if the requested URL does not match any routes. Since the exception is thrown
    at the root level, we use the root error boundary to handle the global 404 not-found
    page in Remix.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们已经将根和嵌套错误边界添加到了BeeRich中。请注意，我们可以在`loader`和`action`函数中抛出自定义的404响应。嵌套错误边界可以处理这些抛出的异常。如果请求的URL不匹配任何路由，Remix会抛出一个根级别的404响应。由于异常是在根级别抛出的，我们使用根错误边界来处理Remix中的全局404未找到页面。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned that Remix lets us handle both expected and unexpected
    failures declaratively using Remix’s `ErrorBoundary` component.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了Remix让我们可以使用Remix的`ErrorBoundary`组件声明式地处理预期的和意外的失败。
- en: The root `ErrorBoundary` export handles thrown responses and errors if no other
    nested error boundary has handled them yet. Both errors and thrown responses bubble
    upward through the route hierarchy.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 根`ErrorBoundary`导出处理了抛出的响应和错误，如果还没有其他嵌套错误边界处理它们的话。错误和抛出的响应会通过路由层次结构向上冒泡。
- en: Then, you learned that error boundaries do not have access to loader data. It
    is important not to render any components in the boundaries that access the `useLoaderData`
    hook.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你学习了错误边界无法访问加载器数据。在边界中渲染任何访问`useLoaderData`钩子的组件是很重要的。
- en: Using error boundaries makes the application more resilient toward errors. Tight
    error boundaries keep parts of our application functional if an unexpected error
    only affects a nested route module.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用错误边界使应用程序对错误更加健壮。紧密的错误边界可以在意外错误仅影响嵌套路由模块时保持我们应用程序的部分功能。
- en: In the next chapter, we will throw some more responses – 401 responses, to be
    precise – as we implement an authentication flow and learn more about state management
    with Remix.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将抛出更多的响应——更确切地说，是401响应——因为我们实现了一个身份验证流程，并学习了如何使用Remix进行状态管理。
- en: Further reading
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find a list of all HTTP status codes on MDN: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在MDN上找到所有HTTP状态码的列表：[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)。
- en: 'If you want to learn more about exception and error handling, I recommend that
    you check out Shawn Wang''s (`@swyx`) blog post *Errors Are Not* *Exceptions*:
    [https://www.swyx.io/errors-not-exceptions](https://www.swyx.io/errors-not-exceptions).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于异常和错误处理的信息，我推荐你查看 Shawn Wang（`@swyx`）的博客文章 *错误不是异常*：[https://www.swyx.io/errors-not-exceptions](https://www.swyx.io/errors-not-exceptions)。
- en: 'You can find more information about the `ErrorBoundary` route module export
    in the Remix documentation: [https://remix.run/docs/en/2/route/error-boundary](https://remix.run/docs/en/2/route/error-boundary).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Remix 文档中找到更多关于 `ErrorBoundary` 路由模块导出的信息：[https://remix.run/docs/en/2/route/error-boundary](https://remix.run/docs/en/2/route/error-boundary)。
- en: 'The Remix docs also contain a guide with more information about not-found error
    handling, which you can find here: [https://remix.run/docs/en/2/guides/not-found](https://remix.run/docs/en/2/guides/not-found).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 文档还包含一个关于处理未找到错误的指南，你可以在这里找到：[https://remix.run/docs/en/2/guides/not-found](https://remix.run/docs/en/2/guides/not-found)。
