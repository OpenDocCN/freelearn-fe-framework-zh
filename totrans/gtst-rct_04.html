<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;4.&#xA0;Stateful Components and Events"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Stateful Components and Events</h1></div></div></div><p class="calibre7">In this chapter, we will exploit the React states and events in detail. This chapter will cover the components that have a state, the practices to communicate between them, and how to respond to users input/events in order to have the UI reflect this state. We will develop a web page where we can update the name of our liked pages from Facebook. This also covers how the state changes your React UI having enhanced performance using the virtual DOM.</p><p class="calibre7">This chapter will cover the following items:</p><div class="book"><ul class="itemizedlist"><li class="listitem">React states</li><li class="listitem">Event ecosystem</li></ul></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Stateful Components and Events">
<div class="book" title="Properties versus states in ReactJS"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec22" class="calibre1"/>Properties versus states in ReactJS</h1></div></div></div><p class="calibre7">Let's glance <a id="id124" class="calibre1"/>through the differences between props and states in React.</p><p class="calibre7"><span class="strong"><strong class="calibre8">Properties</strong></span> are <a id="id125" class="calibre1"/>declared when React components are created, while <span class="strong"><strong class="calibre8">states</strong></span> are <a id="id126" class="calibre1"/>declared within the component definitions. Thus, during the component initialization phase props are declared.</p><div class="book"><ul class="itemizedlist"><li class="listitem">In most of the scenarios, React components take data and pass in the form of props. In the other cases, when you are required to take user input to have a server request, states are used.</li><li class="listitem"><code class="literal">(this.props)</code> is used to access parameters passed from the parent component, while <code class="literal">(this.state)</code> is used to manage dynamic data. State should be considered private data.</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Exploring the state property"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec23" class="calibre1"/>Exploring the state property</h1></div></div></div><p class="calibre7">In the last <a id="id127" class="calibre1"/>chapter, we explored React properties (<span class="strong"><strong class="calibre8">props</strong></span>). Just as <a id="id128" class="calibre1"/>components can have properties, they can also have <span class="strong"><strong class="calibre8">states</strong></span>. States are primarily set to those components where it is necessary to change, for example if the component has to be updated or replaced in future. Thus, it is not mandatory to have a state for the entire component.</p><p class="calibre7">Components can be both stateless and stateful:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">Stateless components </strong></span>are those where only props are present, but no state is defined. Thus, there will no change in these prop values for these components <a id="id129" class="calibre1"/>within the component life cycle. The only source of static data should be presented to the component instance via the props. Thus, props are immutable data for a React component.</li><li class="listitem"><span class="strong"><strong class="calibre8">Stateful components: </strong></span> Stateless components, are<a id="id130" class="calibre1"/> meant to represent any React component declared as a function that has no state and returns the same markup given the same props. As the name implies, stateful components are those where both props and states are declared. Generally, any kind of such data-change communication is done via the state change <code class="literal">[setState(data, callback)]</code>. The updated state is then rendered in the UI. In case of interactive apps <code class="literal">[form submission etc]</code> where the data changes continuously, it's necessary to have such stateful components. Otherwise, for non-interactive apps, it's advisable to have fewer stateful components, because they increase complexity and redundancy in the app.</li></ul></div></div>

<div class="book" title="Exploring the state property">
<div class="book" title="Initializing a state"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec32" class="calibre1"/>Initializing a state</h2></div></div></div><p class="calibre7">Initialization <a id="id131" class="calibre1"/>of a component state is done by the method <code class="literal">getInitialState()</code>, which returns an object:</p><div class="informaltable"><pre class="programlisting">object getInitialState()</pre></div><p class="calibre7">The <code class="literal">getInitialState()</code> method is invoked once before the component is mounted. The return value will be used as the initial value of <code class="literal">this.state</code></p><div class="informaltable" title="Note"><h3 class="title2"><a id="note11" class="calibre1"/>Note</h3><p class="calibre7">For all the following examples, we have the same content in the <code class="literal">index.html</code> file. Thus, we can use the same <code class="literal">index.html</code> file and only change the contents of the corresponding JavaScript file based on the topic being discussed.</p></div><p class="calibre7">We can create <a id="id132" class="calibre1"/>a React stateful component as follows:</p><div class="informaltable"><pre class="programlisting">var FormComponent = React.createClass({
  getInitialState:function(){
    return {
      name: 'Doel',
      id: 1
    };
    },
  render : function() {
    return &lt;div&gt;
      My name is {this.state.name}
      and my id is {this.state.id}.
    &lt;/div&gt;;
  }
});
React.renderComponent(
  &lt;FormComponent /&gt;,
  document.body
);</pre></div><div class="informaltable" title="Note"><h3 class="title2"><a id="note12" class="calibre1"/>Note</h3><p class="calibre7">The <code class="literal">getInitialState</code>() method initiates the component with the values (name: <code class="literal">Doel</code>, id: <code class="literal">1</code>), during the first render cycle. These values are persisted until the state values are changed and can be collected by running <code class="literal">{this.state.&lt;VALUE&gt;}</code>.</p></div></div></div>

<div class="book" title="Exploring the state property">
<div class="book" title="Setting a state"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec33" class="calibre1"/>Setting a state</h2></div></div></div><p class="calibre7">Data <a id="id133" class="calibre1"/>change in React is commonly done by invoking the method <code class="literal">setState(data, callback)</code>, which together with the data of <code class="literal">this.state</code> re-renders the component. If you provide an optional callback argument, React will call it when executing this method, although usually it's not required as React keeps the UI updated.</p><p class="calibre7">A state is set from inside the component.</p><p class="calibre7">The following code shows how the state is updated/set:</p><div class="informaltable"><pre class="programlisting">var InterfaceComponent = React.createClass({
  getInitialState : function() {
    return {
      name : "doel"
    };
  },
  handleClick : function() {
    this.setState({
      name : "doel sengupta"
    });
  },
  render : function() {
    return &lt;div onClick={this.handleClick}&gt;
      hello {this.state.name}, your name is successfully updated!
    &lt;/div&gt;;
  }
});
React.renderComponent(
  &lt;InterfaceComponent /&gt;,
  document.body
);</pre></div><p class="calibre7">Here is <a id="id134" class="calibre1"/>what we did:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Changed values in states are reflected only after the component is mounted.</li><li class="listitem">Mounting of the component happens when it has been passed to <code class="literal">React.render(&lt;Component /&gt;)</code>.</li><li class="listitem">Our event handler <code class="literal">onClick</code> calls the <code class="literal">handleClick()</code> function, which is internally calling <code class="literal">this.state</code>(). So when the <code class="literal">onClick </code>event is initialized on the name <code class="literal">doel</code>, it will change its value from <code class="literal">doel</code> to <code class="literal">doel sengupta</code>.</li></ul></div><p class="calibre7">In the <a id="id135" class="calibre1"/>React documentation (<a class="calibre1" href="http://facebook.github.io/react/docs/interactivity-and-dynamic-uis.html">http://facebook.github.io/react/docs/interactivity-and-dynamic-uis.html</a>), Facebook recommends:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Have many stateless components to render data and a stateful component as parent, which passes its states to the stateless children via props.</li><li class="listitem">Essentially, the function of the stateful component is to contain the interaction logic and the stateless components render the data.</li><li class="listitem">The state of a component has the data that is manipulated by the component's event handlers.</li><li class="listitem">You should keep minimal data in <code class="literal">this.state</code> and perform all the computations within the <code class="literal">render</code> method. This reduces redundancy or storage of computed values and ensures more reliability on React's computational abilities.</li><li class="listitem">React components should be built within <code class="literal">render</code>() based on the underlying props and states</li><li class="listitem">Props should be essentially used as the source of truth. Any data that can be changed via <a id="id136" class="calibre1"/>the user's input or otherwise, should be stored in states.</li></ul></div></div></div>

<div class="book" title="Exploring the state property">
<div class="book" title="Replacing a state"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec34" class="calibre1"/>Replacing a state</h2></div></div></div><p class="calibre7">It's also<a id="id137" class="calibre1"/> possible to replace values in the state by using the <code class="literal">replaceState() </code>method. Let's look at an example of this:</p><p class="calibre7">Here's a snippet of code from <code class="literal">index.html</code>:</p><div class="informaltable"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.0-rc1/react.min.js"&gt;&lt;/script&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/JSXTransformer.js"&gt;&lt;/script&gt;
    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"&gt;&lt;/script&gt;
  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.0-rc1/react-dom.js"&gt;&lt;/script&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;My React App&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="myApp"&gt;&lt;/div&gt;
    &lt;script type="text/jsx", src="replace_state.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">Here's the code for <code class="literal">replace_state.js</code>:</p><div class="informaltable"><pre class="programlisting">//calling replaceSet() method 
var FormComponent = React.createClass({
  getInitialState : function() {
    return {
      first_name : "michael",
      last_name : "jackson"
    };
  },
  handleClick : function() {
    this.replaceState({
      last_name : "jordan"
    });
  },
  render : function() {
    return &lt;div onClick={this.handleClick}&gt;
      Hi {this.first_name + " " + this.state.last_name }
    &lt;/div&gt;;
  }
});</pre></div><div class="informaltable" title="Note"><h3 class="title2"><a id="note13" class="calibre1"/>Note</h3><p class="calibre7">The <code class="literal">replaceState</code>() method is used when existing values are to be cleared and new ones have to be added.</p></div><p class="calibre7">Here's what the app looks<a id="id138" class="calibre1"/> like when it is run for the first time:</p><div class="mediaobject"><img src="../images/00014.jpeg" alt="Replacing a state" class="calibre9"/><div class="caption"><p class="calibre25">App screenshot during initial page load</p></div></div><p class="calibre10"> </p><p class="calibre7">After the page initially loads, the value of the <code class="literal">first_name</code> attribute is <code class="literal">michael</code>, but when the <code class="literal">onClick</code> function is called the value changes to <code class="literal">undefined</code>. The component states with <a id="id139" class="calibre1"/>the attributes  <code class="literal">first_name</code> and <code class="literal">last_name</code> have been replaced with only <code class="literal">last_name</code> when <code class="literal">replaceState</code>() is called. The following screenshot illustrates this:</p><div class="mediaobject"><img src="../images/00015.jpeg" alt="Replacing a state" class="calibre9"/><div class="caption"><p class="calibre25">Re-rendering the component after replaceState() is called</p></div></div><p class="calibre10"> </p></div></div>

<div class="book" title="Exploring the state property">
<div class="book" title="A React state example using an interactive form"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec35" class="calibre1"/>A React state example using an interactive form</h2></div></div></div><p class="calibre7">Let's<a id="id140" class="calibre1"/> build a form and see how the values can be passed between <code class="literal">Component1</code> and <code class="literal">Component2</code>, as in the next example.</p><p class="calibre7">Here's a snippet of code from <code class="literal">index.html</code>:</p><div class="informaltable"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.0-rc1/react.min.js"&gt;&lt;/script&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/JSXTransformer.js"&gt;&lt;/script&gt;
    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"&gt;&lt;/script&gt;
  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.0-rc1/react-dom.js"&gt;&lt;/script&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;My React App&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="myApp"&gt;&lt;/div&gt;
    &lt;script type="text/jsx", src="react_state.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">This<a id="id141" class="calibre1"/> code shows how to pass values between components. The next code snippet is in the <code class="literal">react_state.js</code> file:</p><div class="informaltable"><pre class="programlisting">/* declaration of React component1 with initial values and the changed value to be set in  the update function.
*/
var Component1 =
React.createClass({
  getInitialState:function(){
    return {
      name: 'hi',
      id: 1
    };
  },
  update: function(e){
    this.setState({name: e.target.value});
  },
  render:function(){
    return (
      &lt;div&gt;
/* The render method returns the Component2 with props name and the value to be called on update method*/
<span class="strong"><strong class="calibre8">        &lt; Component2 name={this.state.name} update={this.update} /&gt;</strong></span>
      &lt;/div&gt;
      );

  }
});
/* Declaration of Component2 which calls the update function when onChange method is called. */
var Component2 = React.createClass({
  render:function(){
    return (
      &lt;div&gt;
<span class="strong"><strong class="calibre8">        &lt;input type="text" onChange={this.props.update} /&gt;</strong></span>
<span class="strong"><strong class="calibre8">        &lt;br /&gt;</strong></span>
<span class="strong"><strong class="calibre8">        &lt;b&gt;{this.props.name}&lt;/b&gt;</strong></span>
      &lt;/div&gt;
      );

  }
});
ReactDOM.render(&lt; Component1 name="this is the text property"  /&gt;, document.getElementById('myApp'));</pre></div><p class="calibre7">When <a id="id142" class="calibre1"/>we first run the code we see:</p><div class="mediaobject"><img src="../images/00016.jpeg" alt="A React state example using an interactive form" class="calibre9"/><div class="caption"><p class="calibre25">User interactive form</p></div></div><p class="calibre10"> </p><p class="calibre7">After typing in the textbox, the value below automatically changes, as seen here:</p><div class="mediaobject"><img src="../images/00017.jpeg" alt="A React state example using an interactive form" class="calibre9"/><div class="caption"><p class="calibre25">Form data updated using this.setState()</p></div></div><p class="calibre10"> </p><p class="calibre7">Let's now<a id="id143" class="calibre1"/> dig deeper into how events flow within a React ecosystem.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Events"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec24" class="calibre1"/>Events</h1></div></div></div><p class="calibre7">React <a id="id144" class="calibre1"/>uses <code class="literal">SyntheticEvent</code>, which is a cross-browser wrapper around the browser's native event. So all the event handlers in the react applications will be passed instances of <code class="literal">SyntheticEvent</code>. React's event ecosystem has the same interface as any of the browser's native events with the advantage that it works identically in all the browsers and provides <code class="literal">stopPropagation</code>() and <code class="literal">preventDefault</code>() too.</p><p class="calibre7">If React is installed as an NPM module, then these <code class="literal">SyntheticEvent</code>-related files can be found in the following location within your app: <code class="literal">app/node_modules/react/lib</code>.</p><p class="calibre7">All these events comply with the W3C standard. The main event flow happens as:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Dispatching the event : <code class="literal">@param {object} dispatchConfig</code></li><li class="listitem">Marker identifying the event target: <code class="literal">@param {object} dispatchMarker</code></li><li class="listitem">Native event: <code class="literal">@param {object} nativeEvent</code></li></ul></div><p class="calibre7">The way React uses this event delegation is by listening to the nodes that have listeners. Depending on the event handlers on the particular node, the synthetic event system of React implements its own bubbling.</p><p class="calibre7">Some of the event names in the Synthetic Event system are as follows. Refer to the Facebook documentation for the complete list of the listed registered events.</p></div>

<div class="book" title="Events">
<div class="book" title="Form events"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec36" class="calibre1"/>Form events</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">Event <a id="id145" class="calibre1"/>names for Form events are:<div class="book"><ul class="itemizedlist3"><li class="listitem"><code class="literal">onChange</code>, <code class="literal">onInput</code>, <code class="literal">onSubmit</code></li></ul></div><div class="note" title="Note"><h3 class="title2"><a id="note14" class="calibre1"/>Note</h3><p class="calibre7">For more information about the <code class="literal">onChange</code> event, refer to Forms (<a class="calibre1" href="https://facebook.github.io/react/docs/forms.html">https://facebook.github.io/react/docs/forms.html</a>).</p></div></li></ul></div></div></div>

<div class="book" title="Events">
<div class="book" title="Mouse events"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec37" class="calibre1"/>Mouse events</h2></div></div></div><div class="book"><ul class="itemizedlist"><li class="listitem">Event <a id="id146" class="calibre1"/>names for Mouse events are:<div class="book"><ul class="itemizedlist3"><li class="listitem"><code class="literal">onClick</code>, <code class="literal">onContextMenu</code>, <code class="literal">onDoubleClick</code>, <code class="literal">onDrag</code>, <code class="literal">onDragEnd</code>, <code class="literal">onDragEnter</code>, <code class="literal">onDragExit</code></li><li class="listitem"><code class="literal">onDragLeave</code>, <code class="literal">onDragOver</code>, <code class="literal">onDragStart</code>, <code class="literal">onDrop</code>, <code class="literal">onMouseDown</code>, <code class="literal">onMouseEnter</code>, <code class="literal">onMouseLeave</code></li><li class="listitem"><code class="literal">onMouseMove</code>, <code class="literal">onMouseOut,</code> <code class="literal">onMouseOver</code>, <code class="literal">onMouseUp</code></li></ul></div></li></ul></div><p class="calibre7">Let's show an example of some of the different events called by the <code class="literal">SyntheticEvent</code> system on a React component.</p><p class="calibre7">In the<a id="id147" class="calibre1"/> JavaScript file, we have the following code snippet:</p><div class="informaltable"><pre class="programlisting">/* React component EventBox is decalred which shows the different functions it fires in response of diffenrent Synthetic events.*/
var EventBox = React.createClass({

  getInitialState:function(){
    return {e: 'On initial page load'}
  },

  update: function(e){
    this.setState({e: e.type})
  },

  render:function(){
    return (
      &lt;div&gt;
        &lt;textarea
/*Following are the various events (on the left hand side ). In response of all these events then the update function is called. */
<span class="strong"><strong class="calibre8">          onKeyDown={this.update}</strong></span>
<span class="strong"><strong class="calibre8">          onKeyPress={this.update}</strong></span>
<span class="strong"><strong class="calibre8">          onCopy={this.update}</strong></span>
<span class="strong"><strong class="calibre8">          onFocus={this.update}</strong></span>
<span class="strong"><strong class="calibre8">          onBlur={this.update}</strong></span>
<span class="strong"><strong class="calibre8">          onDoubleClick={this.update}</strong></span>
/&gt;
        &lt;h1&gt;{this.state.e}&lt;/h1&gt;
      &lt;/div&gt;
    );});</pre></div><p class="calibre7">The following code displays a textbox in the browser. As we type in the box, the corresponding event type prints out below. Since we are updating the state with <code class="literal">event.type</code>, the corresponding event is shown below as we type in the box.</p><div class="informaltable"><pre class="programlisting">ReactDOM.render(&lt;EventBox /&gt;, document.getElementById('myTextarea'));</pre></div><div class="mediaobject"><img src="../images/00018.jpeg" alt="Mouse events" class="calibre9"/><div class="caption"><p class="calibre25">User interactive form</p></div></div><p class="calibre10"> </p></div></div>

<div class="book" title="Events">
<div class="book" title="nativeEvent"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec38" class="calibre1"/>nativeEvent</h2></div></div></div><p class="calibre7">Sometimes <a id="id148" class="calibre1"/>we may need the underlying browser event for our application; in that case, we need to use its <code class="literal">nativeEvent</code> attribute. This code shows how we can attach DOM events, which are not provided by the React synthetic event system, to a React component.</p><p class="calibre7">The following is the code snippet for the <code class="literal">index.js</code> file:</p><div class="informaltable"><pre class="programlisting">/* React component MyBrowserDimension, with nativeEvent attribute which is needed for manipulating the underlying browser events(window.innerWidth, window.innerHeight). */
var MyBrowserDimension = React.createClass({
getInitialState:function(){
    return {
      width: window.innerWidth,
      height: window.innerHeight
    };
  },

  update: function(){
    this.setState({
     height: window.innerHeight,
     width: window.innerWidth
    });
  },

<span class="strong"><strong class="calibre8">//componentDidMount is called after the component is mounted and //has a DOM presentation. This is often a place where we will //attach generic DOM events.</strong></span>

  componentDidMount:function(){
    window.addEventListener('resize', this.update );
    window.addEventListener('resize', this.update );
  },

  componentWillUnmount:function(){
    window.removeEventListener('resize', this.update );
    window.removeEventListener('resize', this.update );
  },

  render:function(){
    return &lt;div&gt;
      &lt;p&gt;My Browser Window current Inner Width is: {this.state.width} pixels&lt;/p&gt;
      &lt;p&gt;My Browser Window current height is {this.state.height} pixels&lt;/p&gt;
    &lt;/div&gt;;
  }
});

ReactDOM.render(&lt;MyBrowserDimension /&gt;, document.getElementById('myApp'));</pre></div><p class="calibre7">Here's<a id="id149" class="calibre1"/> the source code for the corresponding HTML page:</p><div class="informaltable"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.0-rc1/react.js"&gt;&lt;/script&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.0-rc1/react-dom.js"&gt;&lt;/script&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/JSXTransformer.js"&gt;&lt;/script&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;React DOM attributes&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="myApp"&gt;&lt;/div&gt;
    &lt;script type="text/jsx", src="index.js"&gt;&lt;/script&gt;
&lt;/html&gt;</pre></div><p class="calibre7">From the following screenshots, we can see that as we resize the browser window, the width and height values change. The<a id="id150" class="calibre1"/> first image shows the full size [1311/681] of the browser.</p><div class="mediaobject"><img src="../images/00019.jpeg" alt="nativeEvent" class="calibre9"/><div class="caption"><p class="calibre25">App showing browser's native attributes</p></div></div><p class="calibre10"> </p><p class="calibre7">The second image from the preceding application code shows that after resizing the browser window, the pixel values changed to 497/219.</p><div class="mediaobject"><img src="../images/00020.jpeg" alt="nativeEvent" class="calibre9"/><div class="caption"><p class="calibre25">Native DOM attributes changing with browser window changes</p></div></div><p class="calibre10"> </p><div class="informaltable" title="Note"><h3 class="title2"><a id="note15" class="calibre1"/>Note</h3><p class="calibre7"><a id="id151" class="calibre1"/>According to the Facebook developer team (<a class="calibre1" href="http://facebook.github.io/react/tips/dom-event-listeners.html">http://facebook.github.io/react/tips/dom-event-listeners.html</a>):</p><div class="blockquote"><blockquote class="blockquote1"><p class="calibre23"><span class="strong"><em class="calibre12">"The event callbacks which are declared in a React app, are all bound to the React components. These event callbacks are not tied to the original elements. By autobinding, these methods are automatically bounded to the current element."</em></span></p></blockquote></div></div><p class="calibre7"> Also, every <code class="literal">SyntheticEvent</code> object has the following attributes:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">boolean bubbles</code>: All <a id="id152" class="calibre1"/>event handlers are triggered in the event bubbling phases; it can be <code class="literal">true</code>/<code class="literal">false</code></li><li class="listitem"><code class="literal">boolean cancelable</code>: Whether the SyntheticEvent object can be cancelled or not (true/false)</li><li class="listitem"><code class="literal">DOMEventTarget currentTarget</code>: As per W3C recommendations, the <code class="literal">currentTarget</code> event property returns the element whose event listeners triggered the event</li></ul></div><p class="calibre7">This is particularly useful during capturing and bubbling.</p><p class="calibre7">The <code class="literal">currentTarget</code> property always refers to the element whose event listener triggered the event, as <a id="id153" class="calibre1"/>opposed to the <code class="literal">target</code> property, which returns the element that triggered the event.</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">boolean defaultPrevented</code>: Whether the <code class="literal">SyntheticEvent</code> object can be prevented by default or not (true/false)</li><li class="listitem"><code class="literal">number eventPhase</code>: The <code class="literal">eventPhase</code> event property returns a number that <a id="id154" class="calibre1"/>indicates which phase of the event flow is currently being evaluated (see: <a class="calibre1" href="https://developer.mozilla.org/en-US/docs/Web/API/Event/eventPhase">https://developer.mozilla.org/en-US/docs/Web/API/Event/eventPhase</a>)<p class="calibre24">The number is represented by four constants:</p><p class="calibre24"><code class="literal">0</code> – <code class="literal">NONE</code>.</p><p class="calibre24"><code class="literal">1 </code>– <code class="literal">CAPTURING_PHASE</code>: The event flow is within the capturing phase.</p><p class="calibre24"><code class="literal">2 </code>– <code class="literal">AT_TARGET</code>: The event flow is in the target phase, that is, it is being evaluated at the event target.</p><p class="calibre24"><code class="literal">3 </code>– <code class="literal">BUBBLING_PHASE</code>: The event flow is in the bubbling phase.</p></li><li class="listitem"><code class="literal">boolean isTrusted</code>: As per JS recommendations, in Chrome, Firefox, and Opera, the event is trusted (returns true) if it is invoked by the user, and not trusted if it is invoked by a script ((returns false)).</li><li class="listitem"><code class="literal">DOMEvent nativeEvent</code>: <code class="literal">nativeEvent</code> is a kind of <code class="literal">DOMEvent</code>.</li><li class="listitem"><code class="literal">void preventDefault()</code>: The <code class="literal">preventDefault()</code> method does cancel the event if it is cancellable (it cancels the default action of the method) but it does not prevent further propagation of an event through the DOM. The return type of <code class="literal">preventDefault()</code> in React is void.</li><li class="listitem"><code class="literal">void stopPropagation()</code>:  <code class="literal">stopPropagation</code> is called to prevent events from bubbling up to their parent elements, which thereby prevents any parent event handlers from being invoked.</li><li class="listitem"><code class="literal">boolean isDefaultPrevented()</code>:  <code class="literal">isDefaultPrevented</code> is used to check whether the <code class="literal">preventDefault()</code> method is called (true) or not (false).</li><li class="listitem"><code class="literal">boolean isPropagationStopped()</code>:  <code class="literal">isPropagationStopped</code> is used to check whether the <code class="literal">stopPropagation()</code> method is called (true) or not (false).</li><li class="listitem"><code class="literal">DOMEventTarget target</code>: It is used to identify the target of the <code class="literal">SyntheticEvent</code> object declared, which returns the element that triggered the event. The return type is in <code class="literal">DOMEventTarget</code>.</li><li class="listitem"><code class="literal">number timeStamp</code>: This is used to identify the timestamp of the <code class="literal">SyntheticEvent</code> object  declared. The return type is in the form number.</li><li class="listitem"><code class="literal">string type</code>: This is used to identify a<a id="id155" class="calibre1"/> kind of <code class="literal">SyntheticEvent</code> object declared. The return type is in the form string.</li></ul></div><div class="informaltable" title="Note"><h3 class="title2"><a id="note16" class="calibre1"/>Note</h3><p class="calibre7">Note: As of v0.14, returning false from an event handler will no longer stop event propagation. Instead,<code class="literal"> e.stopPropagation()</code> or <code class="literal">e.preventDefault()</code> should be triggered manually, as appropriate.</p></div></div></div>

<div class="book" title="Events">
<div class="book" title="Event pooling"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec39" class="calibre1"/>Event pooling</h2></div></div></div><p class="calibre7">A <span class="strong"><strong class="calibre8">pool</strong></span> is a place where events/objects are kept, so that they can be reused at a later stage, after <a id="id156" class="calibre1"/>being garbage collected. In the React <a id="id157" class="calibre1"/>ecosystem, the event objects (<code class="literal">SyntheticEvent</code>) that are received in callbacks are pooled. As mentioned before, after the event callback has been called, <code class="literal">SyntheticEvent</code> will be put back in the pool with empty attributes, which thereby reduces the pressure on the Garbage Collector. Next are some key highlights for event pooling as mentioned in the Facebook documentation as well.</p><p class="calibre7">The <code class="literal">SyntheticEvent</code> system in React is pooled.</p><div class="blockquote"><blockquote class="blockquote1"><p class="calibre23"><span class="strong"><em class="calibre12">"This means that the <code class="literal">SyntheticEvent</code> object will be reused.</em></span></p><p class="calibre23"><span class="strong"><em class="calibre12">All properties will be nullified after the event callback has been invoked.</em></span></p><p class="calibre23"><span class="strong"><em class="calibre12">This is for performance reasons.</em></span></p><p class="calibre23"><span class="strong"><em class="calibre12">We cannot access the event in an asynchronous way.</em></span></p><p class="calibre23"><span class="strong"><em class="calibre12">In order to access the event properties in an asynchronous way, we should call <code class="literal">event.persist</code>() on the event, which will remove the synthetic event from the pool and allow references to the event to be retained by user code."</em></span></p></blockquote></div></div></div>

<div class="book" title="Events">
<div class="book" title="Supported events"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch04lvl2sec40" class="calibre1"/>Supported events</h2></div></div></div><p class="calibre7">React <a id="id158" class="calibre1"/>normalizes events so that they have consistent properties across different browsers.</p><p class="calibre7">According to the Facebook documentation (<a class="calibre1" href="http://facebook.github.io/react/docs/events.html">http://facebook.github.io/react/docs/events.html</a>)</p><div class="blockquote"><blockquote class="blockquote1"><p class="calibre23"><span class="strong"><em class="calibre12">"The event handlers of the Synthetic Events of the React ecosystem are triggered by an event in the bubbling phase."</em></span></p></blockquote></div><p class="calibre7">Now that<a id="id159" class="calibre1"/> we have covered what a state is in the React component and how event handling happens, let's see how we can use these in the app that we were building in the last chapter.</p><p class="calibre7">Until the <a id="id160" class="calibre1"/>last chapter, we were able to display the likes of a user, using the Graph-API and Facebook login into our app. Based on its props, each component has rendered itself once. Props are immutable: they are passed from the parent and are <span class="strong"><em class="calibre12">owned</em></span> by the parent. Now, we will be able to update the name of the liked component <code class="literal">onClick</code> on any part of the particular <code class="literal">div</code> where the React component resides.</p><p class="calibre7">The <code class="literal">index.html</code> code snippet for the following example is:</p><div class="informaltable"><pre class="programlisting">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Learning React State&lt;/title&gt;
    &lt;script src="http://fb.me/react-0.13.3.js"&gt;&lt;/script&gt;
    &lt;script src="http://fb.me/JSXTransformer-0.13.3.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Facebook User's list of likes&lt;/h1&gt;
    &lt;div id="user"&gt;&lt;/div&gt;
    &lt;div id="main"&gt;&lt;/div&gt;
    &lt;a onClick='logout()' href='#'&gt;Logout&lt;/a&gt;
    &lt;script&gt;
      window.fbAsyncInit = function() {
        FB.init({
          appId      : '1512084142440038',
          xfbml      : true,
          version    : 'v2.2'
        });

        checkLoginStatusAndLoadUserLikes();
      };

      (function(d, s, id){
         var js, fjs = d.getElementsByTagName(s)[0];
         if (d.getElementById(id)) {return;}
         js = d.createElement(s); js.id = id;
         js.src = "//connect.facebook.net/en_US/sdk/debug.js";
         fjs.parentNode.insertBefore(js, fjs);
       }(document, 'script', 'facebook-jssdk'));
    &lt;/script&gt;

    &lt;script type="text/jsx" src="index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">The following<a id="id161" class="calibre1"/> code is within the <code class="literal">js</code> file:</p><div class="informaltable"><pre class="programlisting">// The following code block explains in order to login to user's Facebook //account and call the function internally( loginAndLoadUserLikes) if //successfully connected.
function checkLoginStatusAndLoadUserLikes() {
  FB.getLoginStatus(function(response) {
    if (response.status === 'connected') {
      loadUserAndLikes();
    } else {
      loginAndLoadUserLikes();
    }
  });
}

function loginAndLoadUserLikes() {
  FB.login(function(response) {
    loadUserAndLikes();
  }, {scope: 'user_likes'});
}

//Once logged in, this method should load the details of the specific user.
var UserDetails = React.createClass({
  render: function () {
    return (
      &lt;section id="user-details"&gt;
        &lt;a href={this.props.userDetails.link} target="__blank"&gt;
          {this.props.userDetails.name}
        &lt;/a&gt;
        {' | '}
        &lt;a href="#" onClick={this.handleLogout}&gt;Logout&lt;/a&gt;
      &lt;/section&gt;
    )
  },

//Specified user should be able to logout from the respective account  
handleLogout: function () {
    FB.logout(function () {
      alert("You're logged out, refresh the page in order to login again.");
    });
  }
});

//Once logged in, this method should load the likes pages of the specific user.
function loadUserAndLikes () {
  FB.api('/me', function (userResponse) {
    React.render(&lt;UserDetails userDetails={userResponse} /&gt;, document.getElementById('user'));

    var fields = { fields: 'category,name,picture.type(normal)' };
    FB.api('/me/likes', fields, function (likesResponse) {
      React.render(&lt;UserLikesList list={likesResponse.data} /&gt;, document.getElementById('main'));
    });
  });
}

//Once logged in, this method should list the liked pages of the specific user.
var UserLikesList = React.createClass({
  render: function() {
    var items = this.props.list.map(function (likeObject) {
      return &lt;UserLikeItem data={likeObject} /&gt;;
    });

    return (
      &lt;ul id="user-likes-list"&gt;
        {items}
      &lt;/ul&gt;
    );
  }
});
<span class="strong"><strong class="calibre8">var UserLikeItem = React.createClass({</strong></span>
<span class="strong"><strong class="calibre8">  getInitialState: function() {</strong></span>
<span class="strong"><strong class="calibre8">    return {data_name: this.props.data.name};</strong></span>
<span class="strong"><strong class="calibre8">  },</strong></span>
<span class="strong"><strong class="calibre8">  handleClick: function(){</strong></span>
<span class="strong"><strong class="calibre8">     this.setState({</strong></span>
<span class="strong"><strong class="calibre8">	data_name: 'I liked it'})</strong></span>
<span class="strong"><strong class="calibre8">	},</strong></span>

<span class="strong"><strong class="calibre8">  render: function() {</strong></span>
<span class="strong"><strong class="calibre8">    var props_data = this.props.data;</strong></span>

<span class="strong"><strong class="calibre8">    return (</strong></span>
<span class="strong"><strong class="calibre8">      &lt;div onClick={this.handleClick}&gt;</strong></span>
<span class="strong"><strong class="calibre8">        &lt;img src={props_data.picture.data.url} title={props_data.name} /&gt;</strong></span>
<span class="strong"><strong class="calibre8">        &lt;h1&gt; {this.state.data_name}  &lt;small&gt;{props_data.category}&lt;/small&gt;&lt;/h1&gt;</strong></span>
<span class="strong"><strong class="calibre8">      &lt;/div&gt;</strong></span>
    );
  }
});</pre></div><p class="calibre7">The highlighted<a id="id162" class="calibre1"/> part shows the changes we made, in order to save the state.</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">getInitialState()</code>: is declared by initializing the value of the liked data name's value from the props data. <code class="literal">getInitialState()</code> executes exactly once during the lifecycle of the component and sets up the initial state of the component.</li></ul></div><p class="calibre7">The reason for the <span class="strong"><em class="calibre12">mutable state</em></span> (the state that can be changed) is as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The <span class="strong"><strong class="calibre8">mutable state</strong></span> is <a id="id163" class="calibre1"/>introduced to the component (<code class="literal">UserLikedItem</code>). In order to implement interactions,<code class="literal"> this.state</code> can be changed by calling <code class="literal">this.setState() </code>and is private to the component. When the state updates, the component (<code class="literal">UserLikedItem</code>) re-renders itself.</li><li class="listitem"><code class="literal">render()</code> methods are written by the Facebook developer team, declaratively as functions of <code class="literal">this.props</code> and <code class="literal">this.state</code>. They ensure that the framework guarantees the UI is always consistent with the inputs.</li><li class="listitem">This is a perfect example of how data flows between components in the React ecosystem. The property (data) is passed from the React component <code class="literal">UserLikesList</code> to another component, <code class="literal">UserLikedItem</code>.</li></ul></div><div class="mediaobject"><img src="../images/00021.jpeg" alt="Supported events" class="calibre9"/><div class="caption"><p class="calibre25">App fetching user's liked pages from Facebook</p></div></div><p class="calibre10"> </p><p class="calibre7">React attaches<a id="id164" class="calibre1"/> event handlers to components using a camelCase naming convention. We attach an <code class="literal">onClick</code> handler to the <code class="literal">div</code> element, so that whenever a user clicks at any portion of the image or the image name or category, it will change to <span class="strong"><strong class="calibre8">I liked it</strong></span>.</p><div class="mediaobject"><img src="../images/00022.jpeg" alt="Supported events" class="calibre9"/><div class="caption"><p class="calibre25">React this.setState() replacing liked item's name</p></div></div><p class="calibre10"> </p></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec25" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">According to Facebook's Reconciliation documentation (<a class="calibre1" href="https://facebook.github.io/react/docs/reconciliation.html">https://facebook.github.io/react/docs/reconciliation.html</a>)</p><div class="blockquote"><blockquote class="blockquote1"><p class="calibre23"><span class="strong"><em class="calibre12">"React's key design decision is to make the API seem like it re-renders the whole app on every update."</em></span></p></blockquote></div><p class="calibre7">Thus, whenever the <code class="literal">setState</code>() method is called on an object, that particular node is marked. At the end of the event loop, all the nodes are re-rendered where the <code class="literal">setState</code>() method is called.</p><p class="calibre7">React is fast because it never talks to the DOM directly. It maintains an in-memory representation of the actual DOM. Whenever the <code class="literal">render()</code> method is called, it returns a mapping of the actual DOM. React can detect (using a diff algorithm) changes in the mapped DOM compared to the in-memory representation. It then re-renders the changes and updates the UI likewise.</p><p class="calibre7">The event ecosystem in React is implemented by a full synthetic event system (<code class="literal">SyntheticEvent()</code>). Cross-browser efficiency is achieved as all the events bubble up consistently.</p><p class="calibre7">In the current chapter, we have explored the stateful components in React and how the synthetic event system is handled in React applications. States are used for those properties in React components that are mutable. In the next chapter, we will explore the component lifecycle and how these lifecycle methods interact with various events and the DOM as a whole.</p></div></body></html>