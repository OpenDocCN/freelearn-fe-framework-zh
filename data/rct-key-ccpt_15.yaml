- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Server-side Rendering & Building Fullstack Apps with Next.js
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端渲染与使用Next.js构建全栈应用程序
- en: Learning Objectives
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够做到以下几件事情：
- en: Describe the difference between client-side and server-side React
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述客户端和服务器端React之间的区别
- en: Determine which kind of React app to build
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定要构建哪种类型的React应用程序
- en: Build fullstack React apps with the help of the Next.js framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Next.js框架构建全栈React应用程序
- en: Explain the key features and advantages of Next.js
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释Next.js的关键特性和优势
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Thus far in this book, you have learned a lot about building client-side React
    applications, that is, applications where the (transpiled) React code executes
    in the browsers of your website visitors.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，你已经学到了很多关于构建客户端React应用程序的知识，即，在网站访问者的浏览器中执行（转换后的）React代码的应用程序。
- en: This makes sense because React was originally created to simplify the process
    of building interactive and reactive UIs by running JavaScript code on the client
    side. To this date, most React features, including the ones covered up to this
    point in this book (e.g., state, context, and routing), exist to fulfill this
    purpose.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有意义的，因为React最初是为了通过在客户端运行JavaScript代码来简化构建交互性和反应性UI的过程而创建的。到目前为止，大多数React特性，包括本书中介绍到的（例如，状态、上下文和路由），都是为了实现这一目的。
- en: But, as you will learn in this and the following chapters, you can actually
    also execute React code on the server side. There are certain React features that
    may only be used there—for example, React Server Components, which will be covered
    in great detail in the *Chapter 16,* *React Server Components & Server Actions*
    .
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如你将在本章和接下来的章节中了解到的那样，你实际上也可以在服务器端执行React代码。有一些React特性可能只能在服务器端使用——例如，将在第16章中详细介绍的React服务器组件，即*React服务器组件与服务器操作*。
- en: This chapter will get you started with React on the server side, briefly explain
    what **server-side rendering** ( **SSR** ) is, and introduce you to Next.js, a
    popular and feature-rich fullstack framework for React that allows you to blend
    backend and frontend code. You will learn how to create Next.js apps and how to
    use core Next.js features like file-based routing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带你开始学习服务器端React，简要解释什么是**服务器端渲染**（**SSR**），并介绍Next.js，这是一个流行的、功能丰富的React全栈框架，允许你混合后端和前端代码。你将学习如何创建Next.js应用程序以及如何使用核心Next.js功能，如基于文件的路由。
- en: What’s the Problem with Client-Side React Apps?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端React应用程序的问题是什么？
- en: The big advantage of **single-page applications** ( **SPAs** ) and client-side
    React is that you can build highly reactive and interactive web UIs. The UI can
    be updated almost instantly, visible page reloads and switches can be avoided,
    and hence your users benefit from a mobile-app-like user experience.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**单页应用程序**（**SPAs**）和客户端React的大优势在于，你可以构建高度反应性和交互式的Web UI。UI可以几乎瞬间更新，可以避免可见的页面重新加载和切换，因此你的用户可以享受到类似移动应用的用户体验。'
- en: 'But this reliance on client-side code (and, therefore, JavaScript) also has
    potential disadvantages:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这种对客户端代码（以及因此JavaScript）的依赖也有潜在的缺点：
- en: If users disable JavaScript, the website will be pretty much unusable.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户禁用了JavaScript，网站将几乎无法使用。
- en: The initially fetched HTML document is almost empty—data fetching and content
    rendering only take place after that initial HTTP request and response.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始获取的HTML文档几乎是空的——数据获取和内容渲染仅在最初的HTTP请求和响应之后进行。
- en: The first point might not matter too much, since only a small subset of all
    users will disable JavaScript and you can show an appropriate warning message
    via the `<noscript>` tag.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个点可能不是很重要，因为只有一小部分用户会禁用JavaScript，你可以通过`<noscript>`标签显示适当的警告信息。
- en: But the second point can have significant consequences. Since the initial HTML
    document is almost empty, users won’t see any content until all the JavaScript
    code has been fetched and executed. While most users might not see a notable delay,
    depending on the device and internet connection of a user, this may take up to
    a few seconds for some users.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，第二个点可能具有重大影响。由于初始HTML文档几乎是空的，用户在所有JavaScript代码被获取并执行之前将看不到任何内容。虽然大多数用户可能不会注意到明显的延迟，但根据用户的设备和互联网连接，这可能会花费一些用户几秒钟的时间。
- en: In addition, search engine crawlers (e.g., Google’s crawler) will not necessarily
    wait for all your client-side JavaScript code to be fetched and executed when
    indexing your page. Therefore, those crawlers may see a mostly empty page and
    hence rank your website badly (or not index it at all).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，搜索引擎爬虫（例如，谷歌的爬虫）在索引你的页面时，并不一定会等待所有客户端JavaScript代码被获取和执行。因此，这些爬虫可能会看到一个几乎空白的页面，从而对你的网站进行较差的排名（或者根本不进行索引）。
- en: '![A screen shot of a computer  Description automatically generated](img/B31339_15_01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B31339_15_01.png)'
- en: 'Figure 15.1: The page content is nowhere to be found in the page source code
    (i.e., the fetched HTML document)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1：页面内容在页面源代码中无处可寻（即，获取的HTML文档）
- en: '*Figure 15.1* shows the page source code (which can be inspected by right-clicking
    on the website) of a typical React app. As you can see in that figure, there’s
    almost no content between the `<body>` tags. The title ( `"Hello World!"` ) and
    the text below it are missing in that source code. The content is missing there
    because it’s not part of the initial HTTP response. Instead, it’s rendered by
    the transpiled React code after the page loaded (and after that code was downloaded
    from the server).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15.1*显示了典型React应用的页面源代码（可以通过右键点击网站进行检查）。如图所示，在`<body>`标签之间几乎没有内容。标题（`"Hello
    World!"`）及其下的文本在该源代码中缺失。内容之所以缺失，是因为它不是初始HTTP响应的一部分。相反，它是在页面加载后（以及从服务器下载了该代码之后）由转换后的React代码渲染的。'
- en: Of course, these disadvantages won’t matter in all cases. If you’re building
    some company-internal application, or a UI that’s hidden behind some login (and
    hence won’t be indexed anyway), or if you’re only targeting users with fast devices
    and internet connections, you might not need to worry about these potential problems.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些缺点在所有情况下可能并不重要。如果你正在构建一些公司内部的应用程序，或者一个隐藏在登录之后（因此无论如何都不会被索引）的UI，或者如果你只针对拥有快速设备和网络连接的用户，你可能不需要担心这些潜在的问题。
- en: But if you’re building a public-facing website where search engine indexing
    matters or that may be visited by users with slow devices or internet connections,
    you might want to consider getting rid of these disadvantages. And that’s precisely
    where **SSR** can help out.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你正在构建一个面向公众的网站，其中搜索引擎索引很重要，或者可能会被使用慢速设备或网络连接的用户访问，你可能想要考虑消除这些缺点。这正是**SSR**能够提供帮助的地方。
- en: Making Sense of Server-side Rendering (SSR)
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解服务器端渲染（SSR）
- en: When working with React, SSR refers to the process of rendering web pages, and
    therefore your React components, on the server that handles the incoming HTTP
    request when a user visits your website.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用React时，SSR指的是在用户访问你的网站时，在处理传入HTTP请求的服务器上渲染网页和因此你的React组件的过程。
- en: With SSR enabled, the server will render your React component tree and hence
    produce the actual HTML code yielded by your components and their JSX instructions.
    It’s this finished HTML code that’s then sent back to the client. As a result,
    website visitors will receive an HTML file that’s not empty anymore but that instead
    contains the actual page content. Search engine crawlers will also see that content
    and index the page accordingly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 启用SSR后，服务器将渲染你的React组件树，从而生成由你的组件及其JSX指令产生的实际HTML代码。正是这完成的HTML代码随后被发送回客户端。因此，网站访客将收到一个不再空白的HTML文件，而是包含实际页面内容。搜索引擎爬虫也会看到这些内容并相应地索引页面。
- en: '![A diagram of a software development process  Description automatically generated](img/B31339_15_02.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![软件开发流程图  自动生成的描述](img/B31339_15_02.png)'
- en: 'Figure 15.2: React SSR in action'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2：React SSR的实际应用
- en: Best of all, you don’t lose the client-side advantages of React because, when
    enabling SSR, React still works on the client side as it did before! It’ll take
    over control once that initial HTML document has been received and provide users
    with the same SPA experience you were able to deliver without SSR. Though, technically,
    when using SSR, React will be initialized slightly differently on the client.
    Instead of re-rendering the entire DOM there, it’ll **hydrate** the page content
    that was rendered on the server. **Hydration** means that React will connect your
    component structure to the rendered HTML code (which was rendered based on that
    same structure, of course) and make it interactive.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的是，你不会失去 React 的客户端优势，因为，当启用 SSR 时，React 仍然像以前一样在客户端工作！一旦收到那个初始 HTML 文档，它将接管控制权，并为用户提供与没有
    SSR 时相同的 SPA 体验。尽管技术上讲，在使用 SSR 时，React 将在客户端以略微不同的方式初始化。它不会在那里重新渲染整个 DOM，而是会**水合**服务器上渲染的页面内容。**水合**意味着
    React 将将你的组件结构连接到基于该结构渲染的 HTML 代码（当然，是基于相同的结构渲染的），并使其具有交互性。
- en: '![A diagram of a software development process  Description automatically generated](img/B31339_15_03.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![软件开发流程图  自动生成的描述](img/B31339_15_03.png)'
- en: 'Figure 15.3: After receiving the rendered HTML code, React hydrates the code
    on the client side'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.3：在收到渲染的 HTML 代码后，React 在客户端水合代码
- en: 'Consequently, you’ll get the best of both worlds: non-empty, pre-rendered pages
    for the initial HTTP request sent by the browser, and a highly reactive web application
    for the user to enjoy.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你将获得两者的最佳之处：对于浏览器发送的初始 HTTP 请求，将获得非空、预渲染的页面，并且用户将享受到高度反应性的 Web 应用程序。
- en: Adding SSR to a React Application
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 React 应用程序中添加 SSR
- en: It is extremely important to understand that SSR-enabled React applications
    need to execute code in two environments (server and browser), whereas client-side
    React applications only rely on the browser. Therefore, to use SSR, a server-side
    environment must be added to the React project—it’s not enough to just adjust
    the React code in a few places.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 极其重要的是要理解，启用了 SSR 的 React 应用程序需要在两个环境（服务器和浏览器）中执行代码，而客户端 React 应用程序仅依赖于浏览器。因此，要使用
    SSR，必须将服务器端环境添加到 React 项目中——仅仅调整几个地方的 React 代码是不够的。
- en: For example, standard Vite-based projects don’t support SSR out of the box.
    Consequently, if you want to support SSR, you must edit your Vite project setup
    (and some of your project code files) to enable executing React code on both the
    client and server side. For example, you must add some code that handles incoming
    HTTP requests and triggers React code execution on the server side.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，标准的基于 Vite 的项目默认不支持 SSR。因此，如果你想支持 SSR，你必须编辑你的 Vite 项目设置（以及一些项目代码文件）以启用在客户端和服务器端执行
    React 代码。例如，你必须添加一些处理传入 HTTP 请求并在服务器端触发 React 代码执行的代码。
- en: '**Note**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Manually enabling SSR requires backend development and build process configuration
    knowledge—in addition to the React knowledge you need.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 手动启用 SSR 需要后端开发和构建过程配置知识——除了你需要了解的 React 知识之外。
- en: Thankfully, though, as you’ll learn throughout this chapter, you often don’t
    need to go through that setup process. Instead, you can rely on frameworks like
    Next.js to do the heavy lifting for you.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，正如你将在本章中了解到的那样，你通常不需要经历那个设置过程。相反，你可以依赖像 Next.js 这样的框架来为你做繁重的工作。
- en: 'If you’re interested in manually configuring SSR in Vite-based projects, the
    official Vite SSR documentation is a great place to learn more: [https://vitejs.dev/guide/ssr](https://vitejs.dev/guide/ssr)
    .'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对手动配置基于 Vite 的项目中的 SSR 感兴趣，官方的 Vite SSR 文档是一个学习更多知识的好地方：[https://vitejs.dev/guide/ssr](https://vitejs.dev/guide/ssr)。
- en: 'In addition, you can explore the following demo project that was set up according
    to the official Vite SSR instructions: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/02-ssr-enabled](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/02-ssr-enabled)
    .'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以探索以下根据官方 Vite SSR 指令设置的演示项目：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/02-ssr-enabled](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/02-ssr-enabled)。
- en: The fact that manually enabling SSR is a non-trivial process that requires advanced
    Node.js and backend development knowledge is one of the reasons why the official
    React documentation recommends creating new React projects with the help of frameworks
    like Next.js (see [https://react.dev/learn/start-a-new-react-project](https://react.dev/learn/start-a-new-react-project)
    ).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 手动启用SSR是一个非平凡的过程，需要高级的Node.js和后端开发知识，这是官方React文档建议使用Next.js等框架创建新React项目的原因之一（见[https://react.dev/learn/start-a-new-react-project](https://react.dev/learn/start-a-new-react-project)）。
- en: But it’s not the only reason.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并非唯一原因。
- en: Server-side Data Fetching Is Not Trivial
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端数据获取并非易事
- en: 'Besides the non-trivial setup process, SSR-enabled projects also suffer from
    another possible problem: server-side data fetching is difficult.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了非平凡的设置过程之外，启用SSR的项目还可能遇到另一个可能的问题：服务器端数据获取困难。
- en: If you’re building a React app that needs to fetch data in some components (e.g.,
    with the help of `useEffect()` , as shown in *Chapter 8* , *Handling Side Effects*
    ), you’ll find out that the data is not fetched when the component is rendered
    on the server. Instead, the data fetching will only occur on the client side.
    The server-side rendered HTML markup will not contain the content that depends
    on the fetched data.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建一个需要在某些组件中获取数据（例如，通过`useEffect()`，如第8章*处理副作用*中所示）的React应用，你会发现当组件在服务器上渲染时，数据并未被获取。相反，数据获取只会发生在客户端。服务器端渲染的HTML标记将不包含依赖于获取数据的内
    容。
- en: The reason for this behavior is that React component functions are only executed
    on the server once—i.e., it’s only the first component render cycle that’s performed
    on the server. You can think of SSR producing only an initial page snapshot. Subsequent
    state updates are ignored, and effect functions (triggered via `useEffect()` )
    are also therefore not executed on the server side. As a result, data fetching
    that relies on effect functions and subsequent state updates will not work on
    the server side.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为的原因是React组件函数仅在服务器端执行一次——即，仅在服务器上执行了第一次组件渲染周期。你可以将SSR视为仅生成初始页面快照。后续的状态更新将被忽略，并且通过`useEffect()`触发的影响函数（副作用）在服务器端也不会执行。因此，依赖于影响函数和后续状态更新的数据获取在服务器端将不会工作。
- en: 'Consider this example, where a `Todos` component function uses `useEffect()`
    to fetch some (dummy) to-dos data from [https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)
    :'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子，其中`Todos`组件函数使用`useEffect()`从[https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)获取一些（模拟）待办事项数据：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Note**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'You find the complete example code on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/03-ssr-data-fetching](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/03-ssr-data-fetching)
    .'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到完整的示例代码：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/03-ssr-data-fetching](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/03-ssr-data-fetching)。
- en: When running this code on the server, there won’t be any errors. Instead, the
    app will run as expected and fetch the dummy to-dos from the backend server.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当在服务器上运行此代码时，不会出现任何错误。相反，应用将按预期运行并从后端服务器获取模拟的待办事项。
- en: However, the HTML document that’s produced on the server will not contain the
    fetched to-dos. Instead, it will just contain the fallback text ( `"No todos found"`
    ).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在服务器上生成的HTML文档将不包含获取的待办事项。相反，它只会包含回退文本（`"No todos found"`）。
- en: '![A computer screen with text  Description automatically generated](img/B31339_15_04.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![带有文本的计算机屏幕，描述自动生成](img/B31339_15_04.png)'
- en: 'Figure 15.4: The rendered HTML does not contain the actual to-dos'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4：渲染的HTML不包含实际的待办事项
- en: The generated markup does not contain the fetched to-dos because, as explained
    above, React component functions only execute once on the server side (and the
    function passed to `useEffect()` doesn’t execute at all).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的标记不包含获取的待办事项，因为，如上所述，React组件函数仅在服务器端执行一次（并且传递给`useEffect()`的函数根本不执行）。
- en: Due to this behavior, you can’t easily perform asynchronous operations and,
    for example, fetch data via `useEffect()` in your React components when using
    SSR. Hence, the server-side rendered HTML content will never contain that data.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种行为，你无法轻松执行异步操作，例如，在启用SSR时，在React组件中使用`useEffect()`获取数据。因此，服务器端渲染的HTML内容将永远不会包含那些数据。
- en: While you can come up with workarounds to that problem (e.g., perform the data
    fetching operation on the server, before executing the component functions) that’s
    a problem that will be solved by Next.js and a concept called **React Server Components**
    ( **RSC** ).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以想出解决该问题的方法（例如，在执行组件函数之前在服务器上执行数据获取操作），但这将是 Next.js 和一个称为 **React 服务器组件**（**RSC**）的概念解决的问题。
- en: Introducing Next.js
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Next.js
- en: 'Next.js is a React framework—i.e., a framework that builds upon React and adds
    extra features and patterns to it. Specifically, Next.js adds features like file-based
    routing, built-in SSR, or automatic caching to improve performance. Though, most
    importantly, it unlocks two crucial React concepts: **React Server Components**
    ( **RSC** ) and **Server Actions** . As you will learn, these features enable
    server-side React code to perform asynchronous operations and, for example, fetch
    and render data on the server.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 是一个 React 框架——即建立在 React 之上并添加额外功能和模式的框架。具体来说，Next.js 添加了诸如基于文件的路由、内置
    SSR 或自动缓存以改进性能等功能。尽管如此，最重要的是，它解锁了两个关键的 React 概念：**React 服务器组件**（**RSC**）和 **服务器操作**。正如您将学到的，这些功能使服务器端
    React 代码能够执行异步操作，例如在服务器上获取和渲染数据。
- en: Thus, Next.js saves you the effort of manually enabling SSR, and, additionally,
    unlocks other powerful features that help with fetching data on the server.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Next.js 可以节省您手动启用 SSR 的麻烦，并且额外解锁了其他有助于在服务器上获取数据的强大功能。
- en: '**Note**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: There are also alternative React frameworks like Remix/React Router (they were
    merged to bring optional fullstack React framework features to React Router) or
    TanStack Start.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些替代的 React 框架，如 Remix/React Router（它们被合并以将可选的全栈 React 框架功能引入 React Router）或
    TanStack Start。
- en: Next.js has not only existed for a very long time but it’s also the most popular
    (measured by usage) fullstack framework at the point in time when this book was
    written.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 不仅存在了很长时间，而且还是本书撰写时最受欢迎（按使用量衡量）的全栈框架。
- en: This chapter will get you started with Next.js and provide a brief overview
    of its core concepts. The next chapter ( *Chapter 16* , *React Server Components
    & Server Actions* ) will then build upon this knowledge to dive even deeper.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将引导您开始使用 Next.js，并提供其核心概念的简要概述。接下来的第 16 章（*第 16 章*，*React 服务器组件与服务器操作*）将在此基础上进一步深入探讨。
- en: Creating Next.js Projects
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Next.js 项目
- en: To use Next.js, you must first create a Next.js project. Technically, it’ll
    still be a React project, which means you will be able to use React features like
    components, props, state, Hooks, or JSX. But it’ll be a project that comes with
    the `next` package installed, and that enforces a certain folder structure that’s
    needed by Next.js. You can’t install Next.js into an existing (Vite-based) React
    project and start using it there. Significant adjustments to the project configuration
    and structure would be required. Next.js brings its own build process and does
    not use Vite under the hood. Hence, creating a brand-new project makes more sense.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Next.js，您必须首先创建一个 Next.js 项目。技术上，它仍然是一个 React 项目，这意味着您将能够使用 React 功能，如组件、属性、状态、Hooks
    或 JSX。但这是一个已经安装了 `next` 包的项目，并且需要 Next.js 的特定文件夹结构。您不能将 Next.js 安装到现有的（基于 Vite
    的）React 项目中并开始在那里使用它。需要对项目配置和结构进行重大调整。Next.js 带有自己的构建过程，并且底层不使用 Vite。因此，创建一个全新的项目更有意义。
- en: 'To get started with a new Next.js project, you should run the following command
    in your system terminal or command prompt (in a place on your system where you
    want the new project folder to be created):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始一个新的 Next.js 项目，您应该在系统终端或命令提示符（在您希望创建新项目文件夹的系统位置）中运行以下命令：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After running this command, you’ll have to make a couple of choices in the terminal
    (e.g., if you want to use TypeScript).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，您需要在终端中进行一些选择（例如，如果您想使用 TypeScript）。
- en: 'You can confirm all those choices by simply pressing the *Enter* key, hence
    accepting the default option. However, you should ensure that you choose `No`
    for TypeScript (unless you know how to use it) and `Yes` for **App Router** .
    You can find a (slightly cleaned up) starting project on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/04-nextjs-intro](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/04-nextjs-intro)
    .'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过简单地按 *Enter* 键来确认所有这些选择，从而接受默认选项。但是，您应该确保您选择 `No` 以用于 TypeScript（除非您知道如何使用它）和
    `Yes` 以用于 **App Router**。您可以在 GitHub 上找到一个（略微清理过的）起始项目：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/04-nextjs-intro](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/04-nextjs-intro)。
- en: 'Inside the created project folder, a development server can be started via:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建的项目文件夹内，可以通过以下方式启动开发服务器：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While the command is the same as in a Vite project, the server will actually
    target a different port by default. Instead of `localhost:5173` (Vite), Next.js
    projects use `localhost:3000` for the preview development server.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然命令与 Vite 项目相同，但服务器默认会针对不同的端口。Next.js 项目使用 `localhost:3000` 而不是 `localhost:5173`（Vite）作为预览开发服务器。
- en: Just as in a Vite-based project, you should keep this process up and running
    while you’re working on the project code. The underlying build process will automatically
    reload and update the preview website as you make changes to your code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在基于 Vite 的项目中一样，当您在项目代码上工作时，应保持此过程运行。底层构建过程会自动重新加载并更新预览网站，当您对代码进行更改时。
- en: '**Note**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Next.js is an established, mature framework that’s never stopped innovating
    and changing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 是一个成熟、稳定的框架，它从未停止创新和变化。
- en: In late 2022, the so-called **App Router** was introduced as a new way of structuring
    and building Next.js applications (the old approach is now referred to as Pages
    Router). This book, of course, covers the new App Router approach.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到 2022 年底，所谓的 **App Router** 被引入作为一种新的构建和结构化 Next.js 应用程序的方法（旧的方法现在被称为 Pages
    Router）。当然，这本书涵盖了新的 App Router 方法。
- en: As of mid-2024 (when this edition is written), the App Router approach, despite
    being marked as stable, still frequently receives new features and changes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 2024 年中（本书撰写时），尽管 App Router 方法被标记为稳定，但它仍然经常收到新功能和更改。
- en: 'Therefore, even though unlikely, the concepts and code explained in this book
    may change or break over time. The setup process described above may change, too.
    In such cases, a note (with instructions on how to adjust the code) will be added
    to the Changelog document on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/main/CHANGELOG.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/main/CHANGELOG.md)
    .'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管可能性不大，但本书中解释的概念和代码可能会随着时间的推移而改变或损坏。上述设置过程也可能发生变化。在这种情况下，将在 GitHub 的 Changelog
    文档中添加一条注释（包含如何调整代码的说明）：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/main/CHANGELOG.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/main/CHANGELOG.md)。
- en: 'A newly created Next.js project comes with all its dependencies installed (
    `npm install` is automatically executed as part of the project creation process)
    and a project structure like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新创建的 Next.js 项目会自动安装所有依赖（`npm install` 是项目创建过程的一部分自动执行）并具有如下项目结构：
- en: An `app/` folder that holds route-related files (see the next section)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含与路由相关的文件的 `app/` 文件夹（参见下一节）
- en: A `public/` folder that can be used to store assets that should be served statically
    (i.e., without being changed by the build process)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `public/` 文件夹，可以用来存储应该以静态方式提供（即，在构建过程中不被更改）的资产
- en: '`jsconfig.json` and `nextjs.config.mjs` files for configuring the project and
    Next.js-specific behaviors'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于配置项目和 Next.js 特定行为的 `jsconfig.json` 和 `nextjs.config.mjs` 文件
- en: '`package.json` and `package-lock.json` for managing project dependencies'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于管理项目依赖的 `package.json` 和 `package-lock.json` 文件
- en: Hence, except for the `app/` folder, it’s not too different from the structure
    you know from Vite. However, it is worth noting that Next.js, unlike Vite, does
    not enforce `.jsx` as a file extension for JavaScript files that contain JSX code.
    You can use it but you don’t have to. For example, the starting project uses `page.js`
    and `layout.js` , not `page.jsx` and `layout.jsx` , even though these files contain
    JSX code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除了 `app/` 文件夹外，它与您从 Vite 知道的结构并没有太大的不同。然而，值得注意的是，Next.js 与 Vite 不同，它不强制要求
    `.jsx` 作为包含 JSX 代码的 JavaScript 文件的文件扩展名。您可以使用它，但不必使用。例如，起始项目使用 `page.js` 和 `layout.js`，而不是
    `page.jsx` 和 `layout.jsx`，尽管这些文件包含 JSX 代码。
- en: Just like Vite-based projects, Next.js projects come with a build workflow that
    processes and transpiles your code files automatically, when running the development
    server or building for production (which you can do via `npm run build` ).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 就像基于 Vite 的项目一样，Next.js 项目自带一个构建工作流程，当运行开发服务器或构建生产版本（你可以通过 `npm run build` 来做）时，它会自动处理和转换你的代码文件。
- en: Like pretty much all modern React project setups, Next.js projects therefore
    support importing style files (like `globals.css` ) or images into JavaScript
    files. It also allows you to omit or set file extensions on imports. In addition,
    Next.js has CSS Modules support, too.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 就像几乎所有现代的 React 项目设置一样，Next.js 项目因此支持将样式文件（如 `globals.css`）或图片导入到 JavaScript
    文件中。它还允许你在导入时省略或设置文件扩展名。此外，Next.js 还支持 CSS Modules。
- en: 'Put in other words: you can work in Next.js projects in pretty much the same
    way as you do in Vite-based projects.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：你可以在 Next.js 项目中以几乎与在 Vite 基于的项目中相同的方式进行工作。
- en: Working with File-Based Routes
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用基于文件的路线
- en: In Vite-based projects, you have a high degree of flexibility when it comes
    to the project structure. Inside the `src/` folder, you can create any subfolders
    and files of your choice. The names of those files and folders also don’t really
    matter (if they’re valid and use the right extensions).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Vite 的项目中，当涉及到项目结构时，你拥有很高的灵活性。在 `src/` 文件夹内，你可以创建任何你选择的子文件夹和文件。这些文件和文件夹的名称实际上并不重要（只要它们是有效的并且使用了正确的扩展名）。
- en: When working with React Router, you would set up routes in one of your JSX code
    files and load any component stored in any file for any route (see *Chapter 13*
    , *Multipage Apps with React Router* ).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 React Router 时，你会在你的 JSX 代码文件中设置路由，并为任何路由加载和渲染存储在任何文件中的任何组件（参见 *第 13 章*，*使用
    React Router 的多页应用*）。
- en: In Next.js projects, that’s a bit different because Next.js uses the file system
    for defining routes—you don’t set up routes in code. As a result, while you still
    have lots of flexibility, there are some routing-related rules regarding the project
    structure and file names that must be followed—otherwise, the app will break and
    not work as intended.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Next.js 项目中，这略有不同，因为 Next.js 使用文件系统来定义路由——你不需要在代码中设置路由。因此，尽管你仍然拥有很多灵活性，但必须遵循一些关于项目结构和文件名的路由相关规则——否则，应用将崩溃并且无法按预期工作。
- en: Next.js implements file-based routing via its own built-in router. This router
    analyzes your file system and derives supported routes, their URL paths, and which
    React components to load and render based on the file and folder structure in
    your project.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 通过其内置的路由器实现了基于文件的路由。这个路由器分析你的文件系统，根据你在项目中的文件和文件夹结构推导出支持的路线、它们的 URL 路径以及要加载和渲染的
    React 组件。
- en: When using the App Router approach, you therefore must store all components
    that should be loaded as pages inside the `app/` folder (or a nested folder) in
    files named `page.js` . Since all route component files must be named `page.js`
    , it’s the parent folder names that define the route path for which the component
    will get loaded.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 App Router 方法时，因此你必须将所有应作为页面加载的组件存储在 `app/` 文件夹（或嵌套文件夹）内的 `page.js` 文件中。由于所有路线组件文件都必须命名为
    `page.js`，因此父文件夹的名称定义了组件将被加载的路线路径。
- en: 'For example, you might have a file and folder structure as shown in *Figure
    15.5* :'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能有一个如图 *图 15.5* 所示的文件和文件夹结构：
- en: '![A diagram of a web site  Description automatically generated](img/B31339_15_05.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![一个网站图示  自动生成的描述](img/B31339_15_05.png)'
- en: 'Figure 15.5: In Next.js, page.js files contain route components. The folder
    names determine the path'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.5：在 Next.js 中，page.js 文件包含路线组件。文件夹名称决定了路径
- en: 'In *Figure 15.5* , you can see that four routes are defined via the file system:
    a root route ( `/` ) and the `/about` , `/users` , and `/terms/en` routes. For
    each route, the component stored in the respective `page.js` will be loaded and
    rendered onto the screen.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 15.5* 中，你可以看到通过文件系统定义了四个路线：根路线（`/`）、`/about`、`/users` 和 `/terms/en` 路线。对于每个路线，存储在相应
    `page.js` 中的组件将被加载并渲染到屏幕上。
- en: 'For example, you might have an `app/page.js` file like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能有一个像这样的 `app/page.js` 文件：
- en: '[PRE3]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, a regular React component function is stored in this `page.js`
    file. The name of the component function does not matter—it’s just important that
    it’s a component function that’s exported inside a file named `page.js` . As a
    result, the following content will be visible on the screen if a user visits `<domain>/`
    (or just `<domain>` , without the forward slash):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，一个常规的 React 组件函数存储在这个 `page.js` 文件中。组件函数的名称并不重要——重要的是它是一个文件 `page.js`
    内导出的组件函数。因此，如果用户访问 `<domain>/`（或只是 `<domain>`，不带斜杠），屏幕上将会显示以下内容：
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_15_06.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  自动生成的描述](img/B31339_15_06.png)'
- en: 'Figure 15.6: The Next.js router loads the component stored in the app/page.js
    file and renders its content'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.6：Next.js 路由器加载存储在 app/page.js 文件中的组件，并渲染其内容
- en: You can therefore easily add as many, possibly nested, routes as needed—simply
    by creating folders, subfolders, and `page.js` files.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以轻松地添加所需数量，可能嵌套的，路由——只需创建文件夹、子文件夹和 `page.js` 文件即可。
- en: Server-side Rendering with Next.js
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Next.js 进行服务器端渲染
- en: 'Besides providing a built-in file-based router (and many other features that
    will be explored throughout this and the next chapters), Next.js has one other
    crucial advantage: it implements SSR out of the box. You don’t have to add any
    files, change any configuration, or adjust any code to render React components
    on the server—instead, it works right from the start.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供内置的基于文件的路由器（以及将在本章和下一章中探讨的许多其他功能）之外，Next.js 还有一个其他关键优势：它默认实现 SSR。你不需要添加任何文件，更改任何配置，或调整任何代码来在服务器上渲染
    React 组件——相反，它从一开始就工作。
- en: Consequently, the `app/page.js` file component (the `Home` component in the
    example above), is evaluated and rendered on the server side when a user visits
    `<domain>/` . It’s the finished HTML code that’s sent to the browser. And, just
    as with Vite-based projects with custom SSR, Next.js renders all child components
    that may be used inside of `page.js` on the server, too.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当用户访问 `<domain>/` 时，`app/page.js` 文件组件（例如上述示例中的 `Home` 组件）将在服务器端进行评估和渲染。发送到浏览器的就是完成的
    HTML 代码。而且，就像基于 Vite 的具有自定义 SSR 的项目一样，Next.js 也会在服务器上渲染 `page.js` 内可能使用的所有子组件。
- en: In addition, when building websites with Next.js, you still build React apps.
    That’s why Next.js apps become interactive on the client side once the SSR is
    done. Technically, as you’ll also learn in the next chapter ( *React Server Components
    & Server Actions* ), they’ll be made interactive in a different way than in Vite-based
    SSR-enabled React apps (where React hydrates the server-side rendered markup on
    the client), but ultimately, your website users will have a SPA-like user experience.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当使用 Next.js 构建网站时，你仍然在构建 React 应用程序。这就是为什么一旦完成 SSR，Next.js 应用程序在客户端就会变得交互式。技术上，正如你将在下一章（*React
    服务器组件 & 服务器操作*）中了解到的那样，它们将以与基于 Vite 的 SSR 启用的 React 应用程序（其中 React 在客户端刷新服务器端渲染的标记）不同的方式变得交互式，但最终，你的网站用户将获得类似
    SPA 的用户体验。
- en: Therefore, if you want to build a React app that supports SSR, relying on a
    framework like Next.js instead of setting up SSR manually is recommended.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想构建一个支持 SSR 的 React 应用程序，建议依靠像 Next.js 这样的框架，而不是手动设置 SSR。
- en: In addition, you will be able to use other helpful features, like the file-based
    routing system, especially since it doesn’t stop at defining routes via `page.js`
    files. It, for example, also simplifies the process of defining layouts.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你将能够使用其他有用的功能，例如基于文件的路由系统，特别是因为它不仅限于通过 `page.js` 文件定义路由。例如，它还简化了定义布局的过程。
- en: Working with Layouts
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与布局一起工作
- en: As mentioned, when it comes to routing, file names and where you store those
    files matter.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，当涉及到路由时，文件名和存储这些文件的位置很重要。
- en: For example, you’ll also find a `layout.js` file next to the `page.js` file
    in the `app/` folder from the example above.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你还会在上述示例的 `app/` 文件夹中找到 `page.js` 文件旁边的 `layout.js` 文件。
- en: '![A screenshot of a black screen  Description automatically generated](img/B31339_15_07.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![黑屏截图  自动生成的描述](img/B31339_15_07.png)'
- en: 'Figure 15.7: Besides a page.js file, a styling file, and a favicon, a layout.js
    file can be found in the app/ folder'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.7：除了 `page.js` 文件、样式文件和 favicon 之外，在 `app/` 文件夹中还可以找到 `layout.js` 文件
- en: Just like `page.js` , `layout.js` is a reserved file name—i.e., that file is
    handled by Next.js in a special way.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `page.js` 一样，`layout.js` 是一个保留的文件名——即该文件以特殊方式由 Next.js 处理。
- en: This `layout.js` file also exports a component function, but the created component
    will not be rendered for one specific path. Instead, it is used as a wrapper around
    all sibling or nested pages. Thus, the `layout.js` file can be used to define
    JSX code that will be shared across multiple pages.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`layout.js`文件也导出一个组件函数，但创建的组件不会为特定的路径渲染。相反，它被用作所有同级或嵌套页面的包装器。因此，`layout.js`文件可以用来定义将在多个页面之间共享的JSX代码。
- en: Since it’s meant to be used as a wrapper component, the component function exported
    by `layout.js` must use the special `children` prop (see *Chapter 3* , *Components
    & Props* ) to define the place where the wrapped page content should be displayed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它被设计为包装组件，`layout.js`导出的组件函数必须使用特殊的`children`属性（见*第3章*，*组件与属性*）来定义被包装页面内容应该显示的位置。
- en: 'For example, you could use the `app/layout.js` file to define a global layout
    that adds a navigation bar above the `<main>` content:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用`app/layout.js`文件来定义一个全局布局，在`<main>`内容上方添加导航栏：
- en: '[PRE4]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example code snippet, it’s also worth noting that the `RootLayout` component
    renders the `<html>` and `<body>` elements. In Vite-based projects, that’s not
    something you would do. There, you instead define a place in the `index.html`
    file where the rendered HTML should be injected (via the `createRoot()` function
    exposed by the `react-dom` package; see *Chapter 2* , *Understanding React Components
    & JSX* ).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例代码片段中，还值得注意的是，`RootLayout`组件渲染了`<html>`和`<body>`元素。在基于Vite的项目中，你不会这样做。在那里，你而是在`index.html`文件中定义一个位置，以便将渲染的HTML注入其中（通过`react-dom`包暴露的`createRoot()`函数；见*第2章*，*理解React组件与JSX*）。
- en: Next.js does not rely on such an `index.html` file; instead, it forces you to
    define a root `layout.js` file at the top level of the `app/` folder. It’s then
    this root layout that must define the general structure of the rendered HTML page.
    However, there is no `<head>` section in that file, since Next.js will manage
    and inject that section behind the scenes. In addition, Next.js will also insert
    JavaScript and CSS imports into the rendered HTML document.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js不依赖于这样的`index.html`文件；相反，它强制你在`app/`文件夹的顶层定义一个根`layout.js`文件。然后，这个根布局必须定义渲染的HTML页面的总体结构。然而，该文件中没有`<head>`部分，因为Next.js将在幕后管理和注入该部分。此外，Next.js还会将JavaScript和CSS导入插入到渲染的HTML文档中。
- en: You may add more (nested) `layout.js` files if you want to have nested layouts
    that only wrap some of your pages. Such layouts are optional; the root layout
    ( `app/layout.js` ) is mandatory, however.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要有嵌套布局，并且这些布局只包装一些页面，你可以添加更多（嵌套）`layout.js`文件。这样的布局是可选的；然而，根布局（`app/layout.js`）是必需的。
- en: With a `layout.js` file like the one shown in the previous code example, in
    a project that contains an `app/page.js` file, and an `app/events/page.js` file,
    website users could visit both pages and see a shared navigation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个包含`app/page.js`文件和`app/events/page.js`文件的项目中，使用类似于前一个代码示例中的`layout.js`文件，网站用户可以访问这两个页面并看到共享的导航。
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_15_08.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B31339_15_08.png)'
- en: 'Figure 15.8: As the user navigates from/to /events, the shared header persists'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8：当用户从/到/events导航时，共享的标题保持不变
- en: In *Figure 15.8* , the main content (defined by the `page.js` files) changes
    but the shared navigation (set up in `layout.js` ) persists.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图15.8*中，主要内容（由`page.js`文件定义）发生变化，但共享的导航（在`layout.js`中设置）保持不变。
- en: 'While sharing JSX markup is the most common use case for using layouts, you
    can also use them to share styles by importing a CSS file into a `layout.js` file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然共享JSX标记是使用布局的最常见用例，但你也可以通过将CSS文件导入到`layout.js`文件中来共享样式：
- en: '[PRE5]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this and the above examples, the component function is named `RootLayout`
    —that name does not matter, but it must be a component that’s exported.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个和上面的示例中，组件函数被命名为`RootLayout`——这个名称并不重要，但它必须是一个导出的组件。
- en: Of course, layouts that are used to share a navigation bar become even more
    useful if you add working links to them…
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你在共享导航栏的布局中添加了有效链接，那么这些布局将变得更加有用...
- en: Managing Internal Navigation
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理内部导航
- en: In the previous code example, the `<a>` element was used for creating links
    between the different Next.js application pages.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，使用`<a>`元素创建了不同Next.js应用程序页面之间的链接。
- en: However, just like other React apps, Next.js applications become SPAs once the
    initial page load is done. Therefore, creating internal links via `<a>` tags is
    discouraged for the same reasons it was discouraged when using React Router in
    Vite-based React projects (compare *Chapter 13* , *Multipage Apps with React Router*
    ).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，就像其他 React 应用程序一样，Next.js 应用程序在完成初始页面加载后将成为单页应用程序（SPA）。因此，出于与在基于 Vite 的 React
    项目中使用 React Router 时相同的原因，不建议使用 `<a>` 标签创建内部链接（比较 *第 13 章*，*使用 React Router 的多页应用程序*）。
- en: 'Like React Router, Next.js (which takes care of routing in Next.js projects)
    provides a special `Link` component that you should use for internal links (instead
    of the `<a>` element):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与 React Router 类似，Next.js（负责 Next.js 项目的路由）提供了一个特殊的 `Link` 组件，你应该用于内部链接（而不是
    `<a>` 元素）：
- en: '[PRE6]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This `<Link>` component accepts a `href` prop, which is set to the target path.
    Internally, Next.js will capture link clicks and update the browser address bar
    and website UI accordingly by loading and rendering the required `page.js` components.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`<Link>` 组件接受一个 `href` 属性，该属性设置为目标路径。内部，Next.js 将捕获链接点击，并通过加载和渲染所需的 `page.js`
    组件来相应地更新浏览器地址栏和网站 UI。'
- en: Highlighting Active Links & Using the “use client” Directive
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 突出显示活动链接和使用“use client”指令
- en: If you want to style links differently when they lead to the currently active
    page, you won’t find a built-in `NavLink` component as is the case with React
    Router. Instead, you must add your own logic by setting the `Link` component’s
    `className` prop dynamically based on the currently active path.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在链接指向当前激活页面时以不同的方式样式化链接，你不会在 React Router 中找到内置的 `NavLink` 组件。相反，你必须通过根据当前激活路径动态设置
    `Link` 组件的 `className` 属性来添加自己的逻辑。
- en: 'To find out which path is currently active, you can use the `usePathname()`
    Hook provided by Next.js:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出当前激活的路径，你可以使用 Next.js 提供的 `usePathname()` 钩子：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For example, you could adjust the `layout.js` file to look like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以调整 `layout.js` 文件，使其看起来像这样：
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, if you were to run this code, you’d get an error message:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你运行这段代码，你会得到一个错误消息：
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_15_09.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成](img/B31339_15_09.png)'
- en: 'Figure 15.9: Next.js complains about the usage of a Hook in a Server Component'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.9：Next.js 对服务器组件中 Hook 的使用提出警告
- en: This error message sounds quite cryptic as it mentions a `Client Component`
    and `Server Components` . Both are crucial React concepts that will be explored
    in the next chapter ( *React Server Components & Server Actions* ).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误消息听起来相当晦涩，因为它提到了 `Client Component` 和 `Server Components`。这两个都是将在下一章（*React
    服务器组件与服务器操作*）中探讨的关键 React 概念。
- en: 'For the current chapter, it’s enough to know the fix for this problem, which
    is to add the `"use client"` directive at the top of the `app/layout.js` file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于当前章节，了解这个问题的修复方法就足够了，即在 `app/layout.js` 文件的顶部添加 `"use client"` 指令：
- en: '[PRE9]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`"use client"` is a so-called **directive** , i.e., an instruction that “tells”
    React and Next.js that this file must be handled in a special way. Adding it will
    get rid of the error message shown in *Figure 15.9* , thus enabling path-aware
    `Link` styling. As mentioned, the concrete impact of this directive will be explored
    in the next chapter.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`"use client"` 是一个所谓的 **指令**，即一个“告诉”React 和 Next.js 该文件必须以特殊方式处理的指令。添加它将消除
    *图 15.9* 中显示的错误消息，从而启用路径感知的 `Link` 样式。正如之前提到的，这个指令的具体影响将在下一章中探讨。'
- en: Whenever you plan to use a Hook in a component in a Next.js project, the `"use
    client"` directive must be added—no matter if it’s a Hook provided by React or
    Next.js.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Next.js 项目中，无论你计划在组件中使用 React 或 Next.js 提供的哪个 Hook，都必须添加 `"use client"` 指令。
- en: '**Note**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You might wonder why `"use client"` is required for components that use Hooks.
    After all, this directive was not needed when using SSR in Vite-based projects.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么对于使用 Hooks 的组件来说需要 `"use client"`。毕竟，在使用基于 Vite 的项目中的 SSR 时，这个指令并不是必需的。
- en: The reason is that Next.js technically doesn’t use SSR, as introduced at the
    beginning of this section. Instead, Next.js (when using the App Router) uses a
    React feature called React Server Components. This crucial feature will be explored
    in great detail in the next chapter. There, you’ll also learn why exactly `"use
    client"` is needed in some components.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是 Next.js 在本节开头介绍的技术上并不使用 SSR。相反，Next.js（当使用 App Router 时）使用一个名为 React Server
    Components 的 React 功能。这个关键特性将在下一章中详细探讨。在那里，你还将了解到为什么在某些组件中需要 `"use client"`。
- en: Creating & Using Regular Components
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用常规组件
- en: The `Link` component mentioned in the previous sections is a component offered
    by Next.js. But, of course, you can also build your own components—it is still
    a React app after all.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节中提到的 `Link` 组件是 Next.js 提供的组件。但当然，你也可以构建你自己的组件——毕竟它仍然是一个 React 应用。
- en: Besides the components that are exposed as pages ( `page.js` ) or layouts (
    `layout.js` ), you can create and use component functions in any files (with any
    names) of your choice.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 除了作为页面（`page.js`）或布局（`layout.js`）暴露的组件外，你可以在你选择的任何文件（任何名称）中创建和使用组件函数。
- en: 'For example, you can add a `components/` folder next to the `app/` folder and
    add a `MainNavigation.js` file in it. This file can then hold a new `MainNavigation`
    component that returns the navigation-related JSX code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以在 `app/` 文件夹旁边添加一个 `components/` 文件夹，并在其中添加一个 `MainNavigation.js` 文件。然后，这个文件可以包含一个新的
    `MainNavigation` 组件，该组件返回与导航相关的 JSX 代码：
- en: '[PRE10]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Please note that `"use client"` must be added at the top of this `MainNavigation.js`
    file since the `usePathname()` Hook is used in the component function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，必须在 `MainNavigation.js` 文件顶部添加 `"use client"`，因为组件函数中使用了 `usePathname()`
    钩子。
- en: With the code moved into this newly added `MainNavigation` component, inside
    the `layout.js` file, `"use client"` can be removed since the `usePathname()`
    Hook is no longer used in that file. It’s used in a child component (inside `<MainNavigation/>`
    ) but React does not care about this.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码移动到这个新添加的 `MainNavigation` 组件中后，在 `layout.js` 文件中，可以移除 `"use client"`，因为该文件中不再使用
    `usePathname()` 钩子。它在子组件（在 `<MainNavigation/>` 内部）中使用，但 React 并不关心这一点。
- en: 'Hence, the updated `layout.js` file looks like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，更新后的 `layout.js` 文件看起来是这样的：
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Thanks to building, outsourcing, and using the custom `MainNavigation` component,
    the updated `layout.js` file therefore contains a lean and concise component function
    again.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了构建、外包和使用自定义的 `MainNavigation` 组件，因此更新后的 `layout.js` 文件再次包含了一个精简且简洁的组件函数。
- en: '**Note**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: With the exception of the route-related files, it is entirely up to you how
    you structure your Next.js project and how you name your files.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与路由相关的文件外，如何构建你的 Next.js 项目以及如何命名你的文件完全取决于你。
- en: As mentioned, you can store custom (non-page) components in a `components/`
    folder (or a folder with any other name of your choice) in any place of your choice.
    You can put that `components/` folder into the `app/` folder or into the root
    project folder.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你可以在你选择的任何位置（任何名称的文件夹）中存储自定义（非页面）组件在 `components/` 文件夹中。你可以将这个 `components/`
    文件夹放入 `app/` 文件夹或根项目文件夹中。
- en: You can also not use a `components/` folder at all, and instead store components
    in files that are located next to your `page.js` files. Because if a file is not
    named `page.js` , it won’t be treated as a page—so there is no danger of accidentally
    creating routes you don’t want in your project. If you have an `app/components/MainNavigation.js`
    but no `app/components/page.js` file, there won’t be a `/components` route. Files
    not named `page.js` (or one of the other reserved filenames—see the upcoming section
    *Other Filename Conventions* ) will simply be ignored by Next.js (for routing
    purposes).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以完全不使用 `components/` 文件夹，而是将组件存储在位于你的 `page.js` 文件旁边的文件中。因为如果一个文件不是命名为 `page.js`，它就不会被视为页面——所以不会意外地在你的项目中创建你不想要的路线。如果你有
    `app/components/MainNavigation.js` 但没有 `app/components/page.js` 文件，就不会有 `/components`
    路由。未命名为 `page.js`（或其他保留文件名——见即将到来的部分 *其他文件名约定*）的文件将被 Next.js（用于路由目的）简单地忽略。
- en: 'You find more information and ideas regarding Next.js project organization
    in the official documentation: [https://nextjs.org/docs/app/building-your-application/routing/colocation](https://nextjs.org/docs/app/building-your-application/routing/colocation)
    .'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方文档中找到更多关于 Next.js 项目组织的信息和想法：[https://nextjs.org/docs/app/building-your-application/routing/colocation](https://nextjs.org/docs/app/building-your-application/routing/colocation)。
- en: Handling Dynamic Routes
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理动态路由
- en: As you learned in *Chapter 13* , *Multipage Apps with React Router* , in the
    *From Static to Dynamic Routes* section, many React apps need to support dynamic
    routes, too.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 *第13章* 中学到的，*使用 React Router 的多页应用*，在 *从静态到动态路由* 部分中，许多 React 应用也需要支持动态路由。
- en: For example, you might want to allow your users to visit `/events/e1` to view
    the details for an event with ID `e1` and `/events/e2` for an event with ID `e2`
    (and so on).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能希望允许你的用户访问 `/events/e1` 来查看 ID 为 `e1` 的活动的详细信息，以及 `/events/e2` 来查看 ID
    为 `e2` 的活动（等等）。
- en: This is such a common requirement that Next.js, of course, supports it. You
    can add dynamic routes in a Next.js app by creating a folder (somewhere in the
    `app/` folder) that has its name wrapped by square brackets—for example, `app/events/[eventId]`
    . Of course, you still need a `page.js` file in that folder to actually create
    a route.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个如此常见的需求，Next.js当然支持它。你可以在Next.js应用程序中通过创建一个文件夹（在`app/`文件夹中的某个位置）并使用方括号包裹其名称来添加动态路由——例如，`app/events/[eventId]`。当然，你仍然需要在那个文件夹中创建一个`page.js`文件来实际创建路由。
- en: The part between the square brackets ( `eventId` , in this example) is entirely
    up to you. But the square brackets tell Next.js that you’re setting up a dynamic
    route.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号之间的部分（例如，`eventId`）完全由你决定。但方括号告诉Next.js你正在设置一个动态路由。
- en: The folder name between the square brackets acts as an identifier that can be
    used to retrieve the concrete value encoded in the URL (e.g., to retrieve `e1`
    in `/events/e1` ).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号之间的文件夹名称充当一个标识符，可以用来检索URL中编码的具体值（例如，检索`/events/e1`中的`e1`）。
- en: Every component that’s used as a page (or layout) receives a `params` prop that’s
    automatically set by Next.js. If it’s a page or layout in a dynamic route folder
    or in some nested child folder, the `params` prop will hold a `Promise` which
    resolves to an object that contains the chosen identifiers (like `eventId` ) as
    keys and the concrete URL path values (like `e1` ) as values for those keys. Since
    `params` holds a `Promise` , `await` must be used on it to get access to the underlying
    object.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用作页面（或布局）的组件都会接收到一个由Next.js自动设置的`params`属性。如果它是一个动态路由文件夹或某些嵌套子文件夹中的页面或布局，则`params`属性将包含一个解析为包含所选标识符（如`eventId`）作为键和具体URL路径值（如`e1`）作为这些键的值的对象。由于`params`包含一个`Promise`，因此必须对它使用`await`来访问其底层对象。
- en: 'For example, the `app/events/[eventId]/page.js` file would ensure that the
    component exported inside the `page.js` file gets rendered for visits to `/events/e1`
    , `/events/e2` , etc. This page component can then output event details with the
    help of the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`app/events/[eventId]/page.js`文件将确保在访问`/events/e1`、`/events/e2`等时，在`page.js`文件中导出的组件被渲染。然后，该页面组件可以使用以下代码输出事件详情：
- en: '[PRE12]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, the automatically provided `params` prop is used to get access
    to the `eventId` encoded in the URL. If some other identifier than `eventId` would
    be used in the folder name, that alternative name would be used to access the
    path value (e.g., for `[id]/page.js` , you’d access ( `await` `params).id` ).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，自动提供的`params`属性用于获取访问URL中编码的`eventId`。如果文件夹名称中使用的是除`eventId`之外的标识符，则将使用该替代名称来访问路径值（例如，对于`[id]/page.js`，你会访问（`await`）`params.id`）。
- en: As a result, users can visit this dynamic route and explore the event details
    for a chosen event ID.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，用户可以访问这个动态路由，探索所选事件ID的事件详情。
- en: '![A screenshot of a computer screen  Description automatically generated](img/B31339_15_10.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B31339_15_10.png)'
- en: 'Figure 15.10: The event details are loaded and displayed for /events/e1'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.10：为/events/e1加载并显示事件详情
- en: '**Note**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'You can find the complete example code, including the `lib/events.js` file,
    on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/08-nextjs-dynamic-routes](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/08-nextjs-dynamic-routes)
    .'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到完整的示例代码，包括`lib/events.js`文件：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/08-nextjs-dynamic-routes](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/08-nextjs-dynamic-routes)。
- en: 'Of course, when working with dynamic routes, you typically also need links
    to those dynamic paths in some parts of your application. Therefore, in this example,
    the `app/events/page.js` file contains code that dynamically renders a list of
    event items, where every item has a link to its detail page:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当使用动态路由时，你通常还需要在应用程序的一些部分中使用指向这些动态路径的链接。因此，在这个例子中，`app/events/page.js`文件包含代码，动态渲染一个事件项列表，其中每个项都有一个链接到其详情页面：
- en: '[PRE13]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Clicking these links will take users to the event detail page for the specific
    event ID.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 点击这些链接将用户带到特定事件ID的事件详情页面。
- en: '**Note**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Static routes, dynamic routes, and nested routes are the most important route
    types you need to know when working with Next.js. You’ll use them for most of
    your routes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Next.js时，静态路由、动态路由和嵌套路由是你需要了解的最重要路由类型。你将在大多数路由中使用它们。
- en: 'In addition, Next.js also offers other (more advanced and niche) route types
    and features that are worth exploring if you decide to dive deeper into Next.js:
    [https://nextjs.org/docs/app/building-your-application/routing](https://nextjs.org/docs/app/building-your-application/routing)
    .'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Next.js 还提供其他（更高级和特定）的路由类型和功能，如果你决定深入研究 Next.js，这些内容值得探索：[https://nextjs.org/docs/app/building-your-application/routing](https://nextjs.org/docs/app/building-your-application/routing)。
- en: Besides different route types that are enabled by using the proper folder names,
    Next.js also offers additional reserved filenames.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过使用适当的文件夹名称启用不同的路由类型之外，Next.js 还提供额外的保留文件名。
- en: Other Filename Conventions
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他文件命名约定
- en: Next.js does not just offer a variety of route types and routing-related features—it
    also offers more reserved filenames than just `page.js` and `layout.js` .
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 不仅提供各种路由类型和与路由相关的功能，还提供了比 `page.js` 和 `layout.js` 更多的保留文件名。
- en: 'Therefore, when working with the Next.js App Router, you should also be aware
    that the following reserved filenames exist, too:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当使用 Next.js App Router 时，你应该也意识到以下保留文件名也存在：
- en: '`loading.js` files can be added next to or above `page.js` and `layout.js`
    files to define components that should be displayed whilst the page (or layout)
    component is fetching data.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loading.js` 文件可以添加到 `page.js` 和 `layout.js` 文件旁边或上方，以定义在页面（或布局）组件获取数据时应显示的组件。'
- en: '`error.js` files can be added in the same places as `loading.js` files to render
    error fallback components in case one of the sibling or child pages throws an
    error.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error.js` 文件可以添加到与 `loading.js` 文件相同的位置，以在兄弟或子页面中抛出错误时渲染回退错误组件。'
- en: '`not-found.js` files can be added to display fallback content in case a website
    visitor tries to load a non-existent route or resource.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`not-found.js` 文件可以被添加以显示回退内容，以防网站访客尝试加载不存在的路由或资源。'
- en: '`route.js` files can be added to set up routes that do not render components
    but instead return data (e.g., in the JSON format).'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`route.js` 文件可以被添加来设置不渲染组件而是返回数据（例如，在 JSON 格式）的路由。'
- en: 'You can learn more about these file types and even more file name conventions
    in the official documentation: [https://nextjs.org/docs/app/building-your-application/routing#file-conventions](https://nextjs.org/docs/app/building-your-application/routing#file-conventions)
    .'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方文档中了解更多关于这些文件类型以及更多的文件命名约定：[https://nextjs.org/docs/app/building-your-application/routing#file-conventions](https://nextjs.org/docs/app/building-your-application/routing#file-conventions)。
- en: You’ll also see some of these file types in action in the next chapter.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你也将在下一章中看到一些这些文件类型的实际应用。
- en: Diving Deeper into Next.js
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入学习 Next.js
- en: At this point, you have a solid Next.js foundation but, as mentioned in the
    previous section, you can dive deeper into Next.js with the help of the official
    documentation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经有了坚实的 Next.js 基础，但如前所述，你可以借助官方文档深入了解 Next.js。
- en: There, besides learning more about routing, route types, and filenames, you
    can also explore how Next.js helps with caching, styling, or managing page metadata.
    Since this book is primarily about React itself, and not about Next.js, covering
    all these topics here would quickly bloat this book.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，除了了解更多关于路由、路由类型和文件名之外，你还可以探索 Next.js 如何帮助缓存、样式或管理页面元数据。由于这本书主要关于 React 本身，而不是
    Next.js，在这里涵盖所有这些主题会迅速使这本书膨胀。
- en: That’s why this chapter focused on setting a solid React SSR and Next.js foundation.
    The essentials covered throughout this chapter will help with understanding more
    advanced React and Next.js features like React Server Components in the next chapter.
    In addition, thanks to these fundamentals, you’ll also be able to quickly learn
    more about Next.js with the help of the official documentation or dedicated Next.js
    books or courses.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章重点在于建立一个坚实的 React SSR 和 Next.js 基础。本章涵盖的基本内容将有助于理解下一章中更高级的 React 和 Next.js
    功能，如 React 服务器组件。此外，得益于这些基础知识，你还将能够借助官方文档或专门的 Next.js 书籍或课程快速学习更多关于 Next.js 的知识。
- en: Summary and Key Takeaways
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要和关键要点
- en: By default, Vite-based React apps (like most React apps that don’t use Next.js
    or a similar framework) only support client-side rendering.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，基于 Vite 的 React 应用（如大多数不使用 Next.js 或类似框架的 React 应用）仅支持客户端渲染。
- en: Without SSR, a relatively empty `index.html` file is sent to the client.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有服务器端渲染（SSR）时，一个相对空白的 `index.html` 文件会被发送到客户端。
- en: This can lead to bad user experiences (if users see an empty page for a prolonged
    period) or suboptimal search engine ranking.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可能会导致不良的用户体验（如果用户长时间看到空页面）或次优的搜索引擎排名。
- en: You can enable SSR by manually adjusting React projects (code and build process)
    to support component function execution on the server side.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过手动调整React项目（代码和构建过程）以支持组件在服务器端执行来启用SSR。
- en: To avoid custom SSR setup work and take advantage of many other benefits, you
    can use frameworks like Next.js.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免自定义SSR设置工作并利用许多其他好处，您可以使用像Next.js这样的框架。
- en: Next.js projects come with built-in SSR support and can be created via the `npx
    create-next-app` command.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Next.js项目自带内置SSR支持，可以通过`npx create-next-app`命令创建。
- en: Modern Next.js uses the App Router approach, which takes advantage of an `app/`
    directory that is used for setting up routes with the help of the file system.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代Next.js使用App Router方法，该方法利用一个`app/`目录，该目录用于通过文件系统设置路由。
- en: Inside `app/` , you define pages by creating folders that contain `page.js`
    files (e.g., `app/about/page.js` adds support for an `/about` route).
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`app/`目录内，您通过创建包含`page.js`文件的文件夹来定义页面（例如，`app/about/page.js`添加了对`/about`路由的支持）。
- en: To share JSX code (and logic or styles) across pages, you can add `layout.js`
    files.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在页面之间共享JSX代码（以及逻辑或样式），您可以添加`layout.js`文件。
- en: Next.js also offers other reserved filenames to handle fallback content that’s
    shown while loading data or to handle errors.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Next.js还提供其他保留的文件名来处理加载数据时显示的回退内容或处理错误。
- en: You can link between pages via Next.js’ `Link` component.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过Next.js的`Link`组件在页面之间建立链接。
- en: When using React Hooks (like `useState()` or Next.js’ `useRouter()` ), you must
    add the `"use client"` directive at the top of the file that uses the Hook.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用React Hooks（如`useState()`或Next.js的`useRouter()`）时，您必须在使用Hook的文件顶部添加`"use
    client"`指令。
- en: Besides static pages (like `app/events/page.js` or `app/about/page.js` ), you
    can also set up dynamic pages by enclosing a folder name with square brackets
    (e.g., `app/events/[eventId]/page.js` ).
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了静态页面（如`app/events/page.js`或`app/about/page.js`），您还可以通过将文件夹名称用方括号括起来来设置动态页面（例如，`app/events/[eventId]/page.js`）。
- en: Dynamic path parameter values can be extracted in the loaded page component
    by using the special `params` prop that’s set on the component by Next.js.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态路径参数值可以通过Next.js在加载的页面组件中使用特殊`params`属性来提取，该属性由Next.js设置在组件上。
- en: Asynchronous operations can be problematic when using SSR—or, at least, they
    can’t be executed in components that are rendered on the server, hence forcing
    the client-side code to perform them. At least when not using React Server Components.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用SSR时，异步操作可能会出现问题——或者至少，它们不能在服务器上渲染的组件中执行，这迫使客户端代码执行它们。至少当不使用React Server
    Components时是这样。
- en: What’s Next?
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: At this point, you have learned a lot about SSR in React apps and about Next.js.
    You’re able to create Next.js projects, define routes, render page components,
    add navigation, and work with dynamic paths.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经了解了关于React应用中的SSR和Next.js的很多知识。您能够创建Next.js项目，定义路由，渲染页面组件，添加导航，并处理动态路径。
- en: You also learned that Next.js comes with built-in SSR. Thus, all React components
    (built-in and custom, page and non-page) are rendered on the server when a website
    visitor sends a request.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 您还了解到Next.js自带内置SSR。因此，当网站访客发送请求时，所有React组件（内置和自定义，页面和非页面）都在服务器上渲染。
- en: Modern Next.js does not stop there, though—instead, unlike the custom SSR setup
    introduced at the beginning of this chapter, Next.js projects that use the App
    Router help with asynchronous data fetching on the server side by unlocking React’s
    **React Server Component** feature. It’s that feature, and **Server Actions**
    , that will be explored in great detail in the next chapter!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现代Next.js并没有止步于此——与本章开头介绍的定制SSR设置不同，使用App Router的Next.js项目通过解锁React的**React
    Server Component**功能帮助在服务器端进行异步数据获取。下一章将详细介绍这个功能和**Server Actions**！
- en: Test Your Knowledge!
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试您的知识！
- en: 'Test your knowledge of the concepts covered in this chapter by answering the
    following questions. You can then compare your answers to examples that can be
    found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/15-ssr-next-intro/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/15-ssr-next-intro/exercises/questions-answers.md)
    :'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试您对本章涵盖的概念的理解。然后，您可以比较您的答案与可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/15-ssr-next-intro/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/15-ssr-next-intro/exercises/questions-answers.md)找到的示例：
- en: Which two main advantages can SSR offer?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSR可以提供哪两个主要优势？
- en: What are some potential disadvantages or weaknesses of SSR?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSR有哪些潜在的缺点或弱点？
- en: How does Next.js help with SSR?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Next.js 如何帮助进行 SSR？
- en: How are routes configured in Next.js (when using the “App Router”)?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用“App Router”时，Next.js 中是如何配置路由的？
- en: What’s special about a page component in Next.js?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Next.js 中的页面组件有什么特别之处？
- en: What’s the purpose of layout components in Next.js?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布局组件在 Next.js 中的用途是什么？
- en: Where can you store non-page (and non-layout) React components in a Next.js
    project?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Next.js 项目中，您可以在哪里存储非页面（和非布局）React 组件？
- en: When and where do you need to add the `"use client"` directive?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时何地需要添加 `"use client"` 指令？
- en: Apply What You Learned
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用所学知识
- en: With all the newly gained knowledge about Next.js, it’s time to apply it to
    a real demo project—a demo application that will be rendered on the server.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了关于 Next.js 的所有新知识后，是时候将其应用到实际演示项目中了——一个将在服务器上渲染的演示应用程序。
- en: In the following section, you’ll find an activity that allows you to practice
    working with Next.js. As always, you will also need to employ some of the concepts
    covered in earlier chapters.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将找到一个活动，让您练习使用 Next.js。一如既往，您还需要运用之前章节中介绍的一些概念。
- en: 'Activity 15.1: Migrating a Vite-Based React Router App'
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 15.1：迁移基于 Vite 的 React Router 应用
- en: In this activity, your job is to build upon the Vite-based app from *Activity
    13.1* . That app was built with Vite and React Router. Your job is to migrate
    it from Vite and React Router to Next.js.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您的任务是建立在 *活动 13.1* 中的基于 Vite 的应用程序之上。该应用程序是用 Vite 和 React Router 构建的。您的任务是将其从
    Vite 和 React Router 迁移到 Next.js。
- en: Therefore, you should create a new Next.js project (using the App Router) and
    rebuild the same app in that project.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您应该创建一个新的 Next.js 项目（使用 App Router），并在该项目中重新构建相同的应用程序。
- en: '**Note**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can find the starting code for this activity at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/activities/practice-1-start)
    . When downloading this code, you’ll always download the entire repository. Make
    sure to then navigate to the subfolder with the starting code ( `activities/practice-1-start`
    , in this case) to use the right code snapshot.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置找到此活动的起始代码：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/activities/practice-1-start)
    。在下载此代码时，您将始终下载整个存储库。请确保然后导航到包含起始代码的子文件夹（在这种情况下是 `activities/practice-1-start`）以使用正确的代码快照。
- en: 'Since your task is to migrate the project that was built in *Activity 13.1*
    , you might also want to use the finished code from that activity. You can find
    it here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/activities/practice-1)
    .'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您的任务是迁移在 *活动 13.1* 中构建的项目，您可能还想使用该活动的完成代码。您可以在以下位置找到它：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/activities/practice-1)
    。
- en: 'After downloading the code and running `npm install` in the project folder
    to install all required dependencies, the solution steps are as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 下载代码并在项目文件夹中运行 `npm install` 以安装所有必需的依赖项后，解决方案步骤如下：
- en: If you created a new Next.js project (i.e., if you’re not using the provided
    starting snapshot), clean up the `layout.js` and `page.js` files to remove everything
    but the component functions.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您创建了一个新的 Next.js 项目（即，如果您没有使用提供的起始快照），请清理 `layout.js` 和 `page.js` 文件，以删除除组件函数之外的所有内容。
- en: 'Create two new routes: a `/products` route and a `/products/<some-id>` route.'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两条新路由：一条是 `/products` 路由，另一条是 `/products/<some-id>` 路由。
- en: Migrate the `data.js` file into the Next.js project (e.g., into a `lib/` folder
    in the root project folder).
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `data.js` 文件迁移到 Next.js 项目中（例如，在根项目文件夹中的 `lib/` 文件夹中）。
- en: Update the page components to load and display the data provided by the `data.js`
    file.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新页面组件以加载和显示 `data.js` 文件提供的数据。
- en: Create a new `components/` folder and migrate (copy) the `MainNavigation` component
    into this folder.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `components/` 文件夹，并将 `MainNavigation` 组件迁移（复制）到这个文件夹中。
- en: Update the `MainNavigation` component (and any other component that needs it)
    to use Next.js’ `Link` component.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `MainNavigation` 组件（以及任何需要它的其他组件）以使用 Next.js 的 `Link` 组件。
- en: Highlight active links with the help of the `usePathname()` Hook—don’t forget
    about the `"use client"` directive!
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `usePathname()` 钩子来突出显示活动链接——别忘了 `"use client"` 指令！
- en: Migrate the styles from the `index.css` file into the `globals.css` file. Make
    sure that the file gets imported into the root layout file.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`index.css`文件中的样式迁移到`globals.css`文件中。确保该文件被导入到根布局文件中。
- en: 'The expected result should look as shown in the following screenshots:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的结果应如图下所示截图所示：
- en: '![img](img/B31339_15_11.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_15_11.png)'
- en: 'Figure 15.11: The home page content'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.11：主页内容
- en: '![img](img/B31339_15_12.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_15_12.png)'
- en: 'Figure 15.12: The /products page content'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.12：/products页面内容
- en: '![img](img/B31339_15_13.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_15_13.png)'
- en: 'Figure 15.13: The /products/<some-id> page content'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.13：/products/<some-id>页面内容
- en: '**Note**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'You will find the full code for this activity, and an example solution, here:
    [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/activities/practice-1)
    .'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到此活动的完整代码以及一个示例解决方案：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/activities/practice-1)
    .
