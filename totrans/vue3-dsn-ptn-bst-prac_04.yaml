- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: User Interface Composition with Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件进行用户界面组合
- en: In this chapter, we will take a closer look at how to compose user interfaces
    with components. While we could just create our entire web page with just one
    component, as we did with our initial *To-Do list* application in [*Chapter 3*](B18602_03.xhtml#_idTextAnchor079),
    *Setting Up a Working Project*, this approach is not a good practice save for
    simple applications, partial migrations of functionality in existing web applications,
    or some edge cases when there could be no other option. Components are central
    to Vue’s approach to building interfaces.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨如何使用组件来组合用户界面。虽然我们可以像在[*第3章*](B18602_03.xhtml#_idTextAnchor079)中我们的初始*待办事项列表*应用中那样，只用一个组件创建整个网页，但这并不是一个好的实践，除非是简单的应用、现有应用程序功能的部分迁移，或者在某些边缘情况下没有其他选择。组件是Vue构建界面的核心。
- en: 'In this chapter, we will do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将执行以下操作：
- en: Learn how to compose user interfaces with a hierarchy of components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用组件层次结构来组合用户界面
- en: Learn different ways in which components interact and communicate with each
    other
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习组件之间相互交互和通信的不同方式
- en: Look into special and custom components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索特殊和自定义组件
- en: Create an example plugin applying design patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个应用设计模式的示例插件
- en: Re-write our to-do application using our plugin and component composition
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们的插件和组件组合重新编写我们的待办事项应用
- en: This chapter will introduce core and advanced concepts and give you the tools
    for building solid web applications with reusable components. In particular, we
    will apply our knowledge of design patterns from [*Chapter 2*](B18602_02.xhtml#_idTextAnchor040),
    *Software Design Principles and Patterns*, in the implementation of the code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍核心和高级概念，并为您提供构建具有可重用组件的稳健Web应用程序的工具。特别是，我们将应用从[*第2章*](B18602_02.xhtml#_idTextAnchor040)中学习的设计模式，*软件设计原则和模式*，在代码实现中。
- en: A note about styles
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 关于样式的说明
- en: To avoid lengthy code listings, we will omit sample icons and styles in the
    code sample. The complete code, along with the styles and iconography, can be
    found in this book’s GitHub repository at [https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免代码示例过长，我们将省略示例中的图标和样式。完整的代码，包括样式和图标，可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices)。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The requirements to follow this chapter are the same as previously mentioned
    in [*Chapter 3*](B18602_03.xhtml#_idTextAnchor079), *Setting Up a* *Working Project*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循本章的要求与之前在[*第3章*](B18602_03.xhtml#_idTextAnchor079)中提到的相同，*设置一个* *工作项目*。
- en: 'Check out the following video to see the Code in Action: [https://packt.link/eqm4l](https://packt.link/eqm4l)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：[https://packt.link/eqm4l](https://packt.link/eqm4l)
- en: 'The code files of this chapter can be found on GitHub here: [https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter04](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter04)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：[https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter04](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter04)
- en: Page composition with components
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件进行页面组合
- en: 'To create a user interface, we must have a starting point, be it a crude sketch
    to a fancy full-fledged design. The graphic design of a web application is beyond
    the scope of this book, so we will consider that it has been created already.
    To translate the design into components, we could approach it as a process that
    answers the following questions:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建用户界面，我们必须有一个起点，无论是粗糙的草图还是复杂的设计。Web应用程序的图形设计超出了本书的范围，因此我们将假设它已经创建好了。为了将设计转换为组件，我们可以将其视为一个回答以下问题的过程：
- en: How can we represent the layout and multiple elements with components?
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用组件来表示布局和多个元素？
- en: How will these components communicate and relate to each other?
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些组件将如何相互通信和关联？
- en: What dynamic elements will enter or leave the scene, and what events or application
    states will they be triggered by?
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将有哪些动态元素进入或离开场景，以及它们将由哪些事件或应用程序状态触发？
- en: What design patterns can we apply that best serve the use case, considering
    trade-offs?
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑权衡，我们可以应用哪些设计模式来最好地满足用例？
- en: Vue 3 is specially fit to create dynamic, interactive interfaces. These questions
    lead us to a repeatable approach for the implementation. So, let’s define a general
    process with well-defined stages, step by step.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 3非常适合创建动态、交互式的界面。这些问题引导我们到一个可重复的实现方法。所以，让我们定义一个具有明确阶段和步骤的通用过程。
- en: Step 1 – identify layouts and user interface elements
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤1 – 识别布局和用户界面元素
- en: 'This step answers the question: *How can we represent the layout and multiple
    elements* *with components?*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤回答的问题是：*我们如何用组件来表示布局和多个元素？*
- en: 'We will take the page as a whole and consider what layout would work best,
    given the design. Should we use columns? Sections? Navigation menus? Islands of
    content? Are there dialogs or modal windows? A simple approach is to take the
    design image and mark the sections that may represent components with rectangles,
    from the outermost down to the singular unit of interaction. Iterate over this
    *slicing* of the page until you have a comfortable number of components. Considering
    the new To-Do application design, here is what this step may look like:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑整个页面，并根据设计考虑哪种布局最合适。我们应该使用列？部分？导航菜单？内容岛屿？是否有对话框或模态窗口？一种简单的方法是将设计图像取出来，并用矩形标记可能代表组件的部分，从最外层到单个交互单元。迭代这个页面的*切割*，直到你有一个舒适的组件数量。考虑到新的待办事项应用设计，这一步可能看起来是这样的：
- en: "![ Figure 4.1 \uFEFF– A slicing of the design into components with dashed boxes](img/Figure_4.01_B18602.jpg)"
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 将设计切割成带有虚线框的组件](img/Figure_4.01_B18602.jpg)'
- en: Figure 4.1 – A slicing of the design into components with dashed boxes
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 将设计切割成带有虚线框的组件
- en: 'Once we’ve identified the components, we must extract the relationships between
    them, creating a hierarchy from the topmost root component (usually, this will
    be our `App.vue`). New components may appear because of grouping components by
    context or functionality. This is a good time to name the components. This initial
    architecture will evolve as we implement design patterns. Following this example,
    the hierarchy may look something like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了组件，我们必须提取它们之间的关系，从最顶层的根组件（通常，这将是我们`App.vue`）创建一个层次结构。由于按上下文或功能分组组件，可能会出现新的组件。这是命名组件的好时机。这个初始架构将随着我们实现设计模式而演变。按照这个例子，层次结构可能看起来像这样：
- en: "![Figure 4.2 \uFEFF– An initial approach to the component’s hierarchy](img/Figure_4.02_B18602.jpg)"
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 组件层次结构的初步方法](img/Figure_4.02_B18602.jpg)'
- en: Figure 4.2 – An initial approach to the component’s hierarchy
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 组件层次结构的初步方法
- en: Notice how a new component appeared, `ToDoProject.vue`, from grouping other
    components. The `App` component usually deals with the main layout of the application
    and the starting point in the hierarchy. Now, with our initial design in place,
    it is time to move on to the next step.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到由于对其他组件的分组，出现了一个新的组件`ToDoProject.vue`。`App`组件通常处理应用程序的主要布局和层次结构中的起点。现在，随着我们的初始设计就位，是时候进行下一步了。
- en: Step 2 – identify relationships, the data flow, interactions, and events
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤2 – 识别关系、数据流、交互和事件
- en: 'This step answers the question: *How will these components communicate and
    relate to* *each other?*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤回答的问题是：*这些组件将如何相互沟通和关联？*
- en: In this stage, we need to understand the user’s interaction (with a use case,
    user story, or something else). For each component, we decide what information
    it will hold (the state), what will pass down to its children, what it needs from
    its parent, and what events it will trigger. In Vue, components can only relate
    vertically to one another. Siblings ignore the existence of each other for the
    best part. If a sibling component needs to share data with another, that data
    must be hosted by a common third party who can share it with both, usually the
    parent who has common visibility. There are other solutions for this, such as
    reactive state management, which we will cover in detail in [*Chapter 7*](B18602_07.xhtml#_idTextAnchor173),
    *Data Flow Management*. For this chapter, we will settle with the basic relationship
    functionality.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们需要了解用户的交互（使用用例、用户故事或其他）。对于每个组件，我们决定它将保存什么信息（状态），将传递给其子组件的内容，它需要从其父组件获取的内容，以及它将触发哪些事件。在Vue中，组件只能垂直地相互关联。兄弟组件大部分情况下会忽略彼此的存在。如果一个兄弟组件需要与另一个组件共享数据，那么这些数据必须由一个可以与双方共享的第三方托管，通常是具有共同可见性的父组件。还有其他解决方案，例如响应式状态管理，我们将在[*第7章*](B18602_07.xhtml#_idTextAnchor173)，*数据流管理*中详细讨论。对于本章，我们将满足基本的关联功能。
- en: 'There are many ways to document this information: scribbled notes in the hierarchy
    tree (see *Figure 4**.2*), descriptive formal documentation, UML diagrams (**UML**
    stands for **Universal Modeling Language**, an iconography representation of software
    components), and more. For simplicity, let’s write down only one segment of the
    tree in a table format:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 记录这些信息有许多方法：在层次结构树中手写的笔记（见 *图4.2*），描述性的正式文档，UML 图表（**UML** 代表 **通用建模语言**，是软件组件的图标表示），等等。为了简单起见，我们只将树的一个部分以表格格式写下：
- en: '| **Component** | **Function** | **State,** **I/O, events** |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **组件** | **功能** | **状态，输入/输出，事件** |'
- en: '| ToDoProject.vue | Hosts a list of to-do items and coordinates interaction
    with the user. This component will actively modify the items. | State: The to-do
    listEvents: Open new, edit, and delete modals |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| ToDoProject.vue | 托管待办事项列表并与用户协调交互。此组件将主动修改项目。 | 状态：待办事项列表 | 事件：打开新项目、编辑和删除模态框
    |'
- en: '| ToDoSummary.vue | Displays a summary count of to-do items by state. | Input:
    The list of to-do itemsState: Counters for each item state |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| ToDoSummary.vue | 显示按状态分类的待办事项汇总。 | 输入：待办事项列表 | 状态：每个项目状态的计数器 |'
- en: '| ToDoFilter.vue | Collects a string to filter the list of to-do items. | Output:
    A filter stringState: An auxiliary variable |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| ToDoFilter.vue | 收集一个字符串以过滤待办事项列表。 | 输出：一个过滤字符串 | 状态：一个辅助变量 |'
- en: '| ToDoList.vue | Displays the list of to-do items, and the signal operations
    for each one. | Input: The to-do list, a filter stringEvents: Toggle item state,
    edit and delete item |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| ToDoList.vue | 显示待办事项列表，以及每个项目的信号操作。 | 输入：待办事项列表，一个过滤字符串 | 事件：切换项目状态，编辑和删除项目
    |'
- en: For brevity, I have omitted the components and interactions that will make up
    the user dialogs. We will see them later in this chapter, but suffice it to say,
    it is the responsibility of `ToDoProject.vue` to manage the interaction using
    modal dialogs.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，我省略了将构成用户对话框的组件和交互。我们将在本章后面看到它们，但可以简单地说，`ToDoProject.vue` 负责使用模态对话框管理交互。
- en: Step 3 – identify user interactivity elements (inputs, dialogs, notifications,
    and more)
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3步 – 识别用户交互元素（输入、对话框、通知等）
- en: 'This step answers the question: *What dynamic elements will enter or leave
    the scene, and what events or application states will they be* *triggered by?*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤回答的问题是：*哪些动态元素将进入或离开场景，以及它们将触发哪些事件或应用程序状态？*
- en: 'In our application, the main CRUD operations (`ToDoProject.vue` component that
    controls this interaction as a response to certain events. This process is illustrated
    in this sequence diagram:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，主要的 CRUD 操作（`ToDoProject.vue` 组件作为对某些事件的响应来控制此交互）由 `ToDoProject.vue`
    组件执行。此过程在本序列图中表示：
- en: "![Figure 4.3 \uFEFF– User interaction through modals – edit an item](img/Figure_4.03_B18602.jpg)"
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 通过模态框进行用户交互 – 编辑项目](img/Figure_4.03_B18602.jpg)'
- en: Figure 4.3 – User interaction through modals – edit an item
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 通过模态框进行用户交互 – 编辑项目
- en: In this diagram, the `ToDoProject` component shares the to-do list with the
    `ToDoList` component. When the user triggers the `edit` event, the child component
    notifies the parent by raising such an event. The parent then makes a copy of
    the item and opens a modal dialog, passing said copy. When the dialog is accepted,
    the parent modifies the original item with the changes. Then, Vue’s reactivity
    reflects the state change in the child components.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图中，`ToDoProject` 组件与 `ToDoList` 组件共享待办事项列表。当用户触发 `edit` 事件时，子组件通过引发此类事件来通知父组件。然后，父组件复制项目并打开一个模态对话框，传递该副本。当对话框被接受时，父组件使用更改修改原始项目。然后，Vue
    的响应性反映了子组件中的状态变化。
- en: Often, these interactions help us identify the need for additional components
    that were not evident in *Step 1*, such as the implementation of design patterns...
    which is the next step.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些交互帮助我们识别在 *第1步* 中不明显需要的额外组件，例如设计模式的实现……这是下一步。
- en: Step 4 – identify design patterns and trade-offs
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4步 – 识别设计模式和权衡
- en: 'This step answers the question: *What design patterns can we apply that best
    serve the use case,* *considering trade-offs?*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤回答的问题是：*在考虑权衡的情况下，我们可以应用哪些最佳设计模式来满足用例？*
- en: Deciding what patterns to use can be a very creative process. There is no silver
    bullet, and multiple solutions can provide different results. It is common to
    make several prototypes to test different approaches.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 决定使用哪些模式可能是一个非常创造性的过程。没有银弹，多个解决方案可以提供不同的结果。通常需要制作几个原型来测试不同的方法。
- en: In our new application, we have introduced the concept of modal dialogs to capture
    user input. Modal dialogs are used when an operation requires a user action or
    decision to proceed. The user can accept or reject the dialog, and cannot interact
    with any other part of the application until such a decision is made. Given these
    conditions, one possible pattern to apply is the **Async** **Promise** pattern.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新应用程序中，我们引入了模态对话框的概念来捕获用户输入。当操作需要用户操作或决策才能继续时，会使用模态对话框。用户可以接受或拒绝对话框，并且在做出决定之前不能与应用程序的任何其他部分交互。在这些条件下，一个可能的模式是应用
    **异步** **Promise** 模式。
- en: In our code, we want to open a modal dialog as a promise that, by definition,
    will provide us with a `resolve()`(accept) or `reject()` (cancel) function. Moreover,
    we want to be able to use this solution in multiple projects, and globally in
    our application. We can create a plugin for this purpose, and use the **dependency
    injection pattern** to access the modal functionality from any component. These
    patterns will provide us with the solution we need to make our modal dialog reusable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们希望将模态对话框作为一个 promise 打开，这个 promise 按定义将提供给我们一个 `resolve()`（接受）或 `reject()`（取消）函数。此外，我们希望能够在多个项目中，以及在我们的应用程序中全局地使用这个解决方案。我们可以创建一个插件来实现这个目的，并使用
    **依赖注入模式** 从任何组件访问模态功能。这些模式将为我们提供所需的解决方案，使我们的模态对话框可重用。
- en: At this point, we are almost ready to start implementing the components conceptually.
    However, to create a more suitable and sturdy application, and implement the aforementioned
    patterns, we should take a moment to learn more about Vue components.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们几乎准备好从概念上开始实现组件。然而，为了创建一个更适合且更坚固的应用程序，并实现上述模式，我们应该花点时间来更多地了解 Vue 组件。
- en: Components in depth
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解组件
- en: Components are the building blocks of the framework. In [*Chapter 1*](B18602_01.xhtml#_idTextAnchor017),
    *The Vue 3 Framework*, we saw how to work with components, declare reactive variables,
    and more. In this section, we will explore more advanced features and definitions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是框架的构建块。在 [*第 1 章*](B18602_01.xhtml#_idTextAnchor017)，*Vue 3 框架* 中，我们看到了如何与组件一起工作，声明响应式变量，以及更多。在本节中，我们将探索更多高级功能和定义。
- en: Local and global components
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地组件和全局组件
- en: 'When we start our Vue 3 application, we mount the main component (`App.vue`)
    to an HTML element in the `main.js` file. After that, in the script section of
    each component, we can import other components to use locally through this command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始我们的 Vue 3 应用程序时，我们在 `main.js` 文件中将主组件 (`App.vue`) 挂载到一个 HTML 元素上。之后，在各个组件的脚本部分，我们可以通过以下命令导入其他组件以本地使用：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this manner, to use `MyComponent` in another component, we need to import
    it again in such a component. If one component is used continuously in multiple
    components, this repetitive action breaks the development DRY principle (see [*Chapter
    2*](B18602_02.xhtml#_idTextAnchor040), *Software Design Principles and Patterns*).
    The alternative is to declare the component as `main.js` file, we can use the
    `App.component()` method for this use case:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，为了在另一个组件中使用 `MyComponent`，我们需要在这个组件中再次导入它。如果一个组件在多个组件中连续使用，这种重复操作会打破开发
    DRY 原则（参见 [*第 2 章*](B18602_02.xhtml#_idTextAnchor040)，*软件设计原则和模式*）。另一种选择是将组件声明在
    `main.js` 文件中，我们可以使用 `App.component()` 方法来实现这种情况：
- en: Main.js
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Main.js
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `component()` method receives two arguments: a `String` that represents
    the HTML tag for the component, and an object with the component definition (either
    imported or in-lined). After registration, it is available to all the components
    in our application. There are, however, a few drawbacks to using global components:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`component()` 方法接收两个参数：一个表示组件 HTML 标签的 `String`，以及一个包含组件定义的对象（可以是导入的或内联的）。注册后，它将可供我们应用程序中的所有组件使用。然而，使用全局组件有一些缺点：'
- en: The component will be included in the final build, even if never used
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使从未使用过，组件也将包含在最终的构建中
- en: Global registrations obscures the relationship and dependencies between components
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局注册会模糊组件之间的关系和依赖
- en: Name collision may occur with locally imported components
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地导入的组件可能会发生名称冲突
- en: The recommendation is to globally register only those components that provide
    generic functionality and avoid those that are an integral part of a workflow
    or specific context.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 建议只全局注册那些提供通用功能的组件，并避免那些是工作流程或特定上下文不可或缺部分的组件。
- en: Static, asynchronous, and dynamic imports
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态、异步和动态导入
- en: So far, all the components we have imported have been *statically* defined with
    the `import XYZ from "filename"` syntax. Bundlers such as **Vite** include them
    in a single JavaScript file. This increases the bundle’s size and could create
    delays in the startup of our application as the browser needs to download, parse,
    and execute the bundle and all its dependencies before any user interaction may
    take place. This code may include features that are seldom used or accessed. The
    clear alternative to this is to split our bundle file into multiple smaller files
    and load them as needed. In this case, we have two approaches – one provided by
    Vue 3 and another one provided by the newest JavaScript syntax for dynamic imports.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们导入的所有组件都使用 `import XYZ from "filename"` 语法以*静态*方式定义。例如 **Vite** 这样的打包器将它们包含在一个单一的
    JavaScript 文件中。这增加了包的大小，并且可能会在我们的应用程序启动时造成延迟，因为浏览器需要下载、解析和执行包及其所有依赖项，然后才能进行任何用户交互。此代码可能包含很少使用或访问的功能。这种做法的明显替代方案是将我们的包文件分割成多个较小的文件，并在需要时加载它们。在这种情况下，我们有两种方法——一种由
    Vue 3 提供，另一种由最新的 JavaScript 动态导入语法提供。
- en: 'Vue 3 provides a function called `defineAsyncComponent`. This function takes
    a parameter another function that returns a dynamic import as an argument. Here
    is an example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 3 提供了一个名为 `defineAsyncComponent` 的函数。此函数接受一个参数，即返回动态导入的另一个函数。以下是一个示例：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The use of this function makes it safe to use in most bundlers. An alternative
    to this syntax is used by Vue Router, which we will see in [*Chapter 5*](B18602_05.xhtml#_idTextAnchor130),
    *Single-Page Applications*: the `import()` dynamic declaration provided by JavaScript
    ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import)),
    This has a very similar syntax:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此函数使其在大多数打包器中安全使用。Vue Router 使用此语法的替代方案，我们将在[*第五章*](B18602_05.xhtml#_idTextAnchor130)“单页应用程序”中看到：JavaScript
    提供的 `import()` 动态声明([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import))，其语法非常相似：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, this syntax is more succinct. However, it can only be used when
    defining routes with Vue Router as, internally, the way that Vue 3 and Vue Router
    handle lazy loading components is different. In the end, both approaches will
    split the main bundle file into multiple smaller files that will be automatically
    loaded when needed in our application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此语法更简洁。然而，它只能在定义 Vue Router 路由时使用，因为 Vue 3 和 Vue Router 处理懒加载组件的方式在内部是不同的。最终，两种方法都将主包文件分割成多个较小的文件，这些文件将在需要时自动加载到我们的应用程序中。
- en: 'However, `defineAsyncComponent` has some advantages. We can also pass any function
    that returns a promise that resolves to a component. This allows us to implement
    logic to control the process dynamically at runtime. Here is an example where
    we have decided to load one component based on the value of an input:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`defineAsyncComponent` 有一些优点。我们还可以传递任何返回解析为组件的 promise 的函数。这允许我们在运行时动态地控制过程。以下是一个示例，其中我们根据输入值的值决定加载一个组件：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The third syntax for `defineAsyncComponent` is probably the most useful. We
    can pass an object with attributes as an argument, which provides more control
    over the loading operation. It has these attributes:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`defineAsyncComponent` 的第三种语法可能是最有用的。我们可以将一个具有属性的对象作为参数传递，这提供了对加载操作的更多控制。它具有以下属性：'
- en: '`loader` (mandatory): It must provide a function that returns a promise that
    loads the component'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loader`（必填）：它必须提供一个返回加载组件的 promise 的函数'
- en: '`loadingComponent`: The component to display while the asynchronous component
    is loading'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadingComponent`: 在异步组件加载时显示的组件'
- en: '`delay`: The number of milliseconds to wait before displaying `loadingComponent`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay`: 在显示 `loadingComponent` 之前等待的毫秒数'
- en: '`errorComponent`: The component to display if the promise rejects, or if the
    loading fails for any reason'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`errorComponent`: 如果 promise 拒绝或由于任何原因加载失败时显示的组件'
- en: '`timeout`: The time in milliseconds before considering the operation to have
    failed and displaying `errorComponent`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeout`: 在认为操作失败并显示 `errorComponent` 之前的时间（毫秒）'
- en: 'Here is an example that uses all these attributes:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用所有这些属性的示例：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While the browser retrieves the component from the `loader` attribute, we display
    a `SpinnerComponent` to inform the user that the operation is underway. After
    1 minute of waiting, as defined by `timeout`, it will display the `LoadingError`
    component automatically.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器从 `loader` 属性检索组件时，我们显示 `SpinnerComponent` 来通知用户操作正在进行中。根据 `timeout` 定义的1分钟后，它将自动显示
    `LoadingError` 组件。
- en: With this approach, our code is better optimized. Now, let’s learn how to receive
    data and notify other components through events.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，我们的代码优化得更好。现在，让我们学习如何通过事件接收数据和通知其他组件。
- en: Props, events, and the v-model directive
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性、事件和 v-model 指令
- en: 'We have seen basic uses for props and events as means of passing data in and
    out of a component to its parent. But more powerful definitions are possible with
    multiple syntaxes. Props can be defined in the `script setup` syntax with `defineProps`
    and any of the following argument formats:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了使用属性和事件作为在组件与其父组件之间传递数据的基本用法。但通过多种语法，可以实现更强大的定义。属性可以在 `script setup`
    语法中使用 `defineProps` 和以下任何参数格式定义：
- en: 'As an array of strings – for example:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为字符串数组 – 例如：
- en: '`const $props=defineProps(``)`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`const $props=defineProps(``)`'
- en: As an object, whose attributes are used as a name, and the value is of the data
    type – for example,
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为对象，其属性用作名称，值是数据类型 – 例如，
- en: '`const $props=defineProps(``)`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`const $props=defineProps(``)`'
- en: As an object, whose attributes define an object with a type and default value
    – for example,
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对象，其属性定义了一个具有类型和默认值的对象 – 例如，
- en: '`const $props=defineProps(`**{**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`const $props=defineProps(`**{**'
- en: '**    name: { type: String, default: “John”},**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**    name: { type: String, default: “John”},**'
- en: '**    last_name: {type: String, default: “Doe”}**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**    last_name: {type: String, default: “Doe”}**'
- en: '`)`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`)`'
- en: We need to keep in mind that primitive values are passed to the component by
    **value**(meaning that changing their value inside the child component will not
    affect their value in the parent). However, complex data types, such as objects
    and arrays, are passed as **references**, so changes to their inner keys/values
    will reflect in the parent.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住，原始值是通过 **value**（意味着在子组件内部更改它们的值不会影响父组件中的值）传递给组件的。然而，复杂的数据类型，如对象和数组，作为
    **引用** 传递，因此它们内部键/值的更改将反映在父组件中。
- en: A note on complex types
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 关于复杂类型的说明
- en: When defining props of the `Object` or `Array` type with default values, the
    default attribute must be a function that returns said object or array. Otherwise,
    the reference to the object/array will be shared by all the instances of the component.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用默认值定义 `Object` 或 `Array` 类型的属性时，默认属性必须是一个返回该对象或数组的函数。否则，对象/数组的引用将由组件的所有实例共享。
- en: '*Events* are signals that our child component emits to the parent. This is
    an example of how to define the events for a component in the `script` `setup`
    syntax:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*事件* 是子组件向父组件发出的信号。这是在 `script` `setup` 语法中定义组件事件的示例：'
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Unlike props, emits only accept an array of strings declaration. Events can
    also pass a value to the receiver. Here is an example of the invocation from the
    aforementioned definition:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与属性不同，emits 只接受字符串声明的数组。事件还可以向接收者传递值。以下是从上述定义中调用的示例：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, `defineEmits` returns a function that accepts one of the same
    names provided in the definition array as the first argument. The second argument,
    `some_value`, is optional.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`defineEmits` 返回一个函数，该函数接受定义数组中提供的相同名称作为第一个参数。第二个参数 `some_value` 是可选的。
- en: Custom input controllers
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义输入控制器
- en: 'One special application with props and events acting together is to create
    custom input controllers. In the previous examples, we used the Vue `v-model`
    directive on basic HTML input elements to capture their value. Props and events
    that follow a special naming convention allow us to create input components that
    accept the `v-model` directive. Let’s take a look at the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当属性和事件共同作用时，有一个特殊的应用是创建自定义输入控制器。在之前的示例中，我们使用了 Vue 的 `v-model` 指令在基本的 HTML 输入元素上捕获它们的值。遵循特殊命名约定的属性和事件允许我们创建接受
    `v-model` 指令的输入组件。让我们看一下以下代码：
- en: Parent component template
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 父组件模板
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that we have the `MyComponent` in use inside our parent component, let’s
    see how we create the tie in:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在父组件中使用了 `MyComponent`，让我们看看我们如何创建连接：
- en: MyComponent script setup
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: MyComponent 脚本设置
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We are using the array definition of `Props` for brevity. Notice that the name
    of the prop is `modelValue`, and the event is `update:modelValue`. This syntax
    is expected. When the parent assigns a variable with `v-model`, the value will
    be copied to `modelValue`. When the child emits the `update:modelValue` event,
    the parent variable’s value will be updated. In this way, you can create powerful
    input controls. But there’s more – you can have multiple `v-models!`
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Props` 的数组定义来简化。请注意，prop 的名称是 `modelValue`，事件是 `update:modelValue`。这种语法是预期的。当父组件使用
    `v-model` 分配变量时，值将被复制到 `modelValue`。当子组件发出 `update:modelValue` 事件时，父组件变量的值将被更新。这样，您可以创建强大的输入控件。但还有更多——您可以有多个
    `v-model`！
- en: 'Let’s consider that `modelValue` is the default when using `v-model`. Vue 3
    has introduced a new syntax for this directive so that we can have multiple models.
    The declaration is very simple. Consider the following child component’s declaration:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑在使用 `v-model` 时 `modelValue` 是默认值。Vue 3 引入了一种新的语法来处理这个指令，以便我们可以拥有多个模型。声明非常简单。考虑以下子组件的声明：
- en: Child component props and event
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 子组件的 props 和事件
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With the preceding props and emits definition, we can now reference both from
    the parent component as the following example shows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 props 和 emits 定义之后，我们现在可以从父组件中引用它们，如下例所示：
- en: Parent component template
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 父组件模板
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we can see, we can attach a modifier to the `v-model:name_of_prop` directive.
    In the `Child` component, the event’s name now has to include the `update:` prefix.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们可以在 `v-model:name_of_prop` 指令上附加一个修饰符。在 `Child` 组件中，事件的名称现在必须包含 `update:`
    前缀。
- en: The use of props and events allows a direct data flow to occur between parent
    and child components. This implies that if data needs to be shared with multiple
    children, it has to be managed at the parent level. One issue with this restriction
    appears when the parent needs to pass data not to a child, but to a grandchild
    or other deeply nested component in the hierarchy tree. That is where the *dependency
    injection pattern* comes in to save the day. Vue implements this naturally with
    the `Provide` and `Inject` functions, which we will cover in more detail in the
    next section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 props 和事件允许在父组件和子组件之间直接进行数据流。这意味着如果需要与多个子组件共享数据，它必须在父级进行管理。当父组件需要将数据传递给不是子组件，而是孙组件或其他深层嵌套的组件时，这种限制就会产生一个问题。这就是
    *依赖注入模式* 来拯救的时刻。Vue 通过 `Provide` 和 `Inject` 函数自然地实现了这一点，我们将在下一节中更详细地介绍。
- en: Dependency injection with Provide and Inject
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Provide 和 Inject 进行依赖注入
- en: 'When data in the parent needs to be available in a deeply nested child, using
    only props, we would have to “pass” the data between components, even if they
    don’t need it or use it. This issue is called *props drilling*. The same occurs
    with events traveling in the opposite direction, having to “bubble” upwards. To
    solve this issue, Vue offers an implementation of the dependency injection pattern
    with two functions named `Provide` and `Inject`. Using these, the parent or root
    component *provides* data (either by value or reference, such as an object), that
    can be *injected* into any of its children down the hierarchy tree. Visually,
    we can represent this situation as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当父组件中的数据需要在深层嵌套的子组件中可用时，仅使用 props，我们就必须在组件之间“传递”数据，即使它们不需要或使用这些数据。这个问题被称为 *props
    钻孔*。同样，事件在相反方向上“冒泡”时也会发生这种情况。为了解决这个问题，Vue 提供了名为 `Provide` 和 `Inject` 的两个函数来实现依赖注入模式。使用这些函数，父或根组件可以
    *提供* 数据（无论是按值还是按引用，如对象），这些数据可以被 *注入* 到其层次树中的任何子组件中。直观上，我们可以将这种情况表示如下：
- en: "![Figure 4.\uFEFF4 – Representation of Provide/Inject](img/Figure_4.04_B18602.jpg)"
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – Provide/Inject 的表示](img/Figure_4.04_B18602.jpg)'
- en: Figure 4.4 – Representation of Provide/Inject
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – Provide/Inject 的表示
- en: 'As you can see, the process is very simple, as well as the syntax to implement
    the pattern:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个过程非常简单，以及实现该模式的语法：
- en: 'In the parent (root) component, we import the `provide` function from Vue and
    create a provision with a key (name) and the data to pass along:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在父（根）组件中，我们导入 Vue 的 `provide` 函数并创建一个带有键（名称）和要传递的数据的提供：
- en: '[PRE12]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the receiving component, we import the `inject` function and retrieve the
    data by key (name):'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接收组件中，我们导入 `inject` 函数并通过键（名称）检索数据：
- en: '[PRE13]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can also provide a resource at the application level in the following manner:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以以下列方式在应用级别提供资源：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this way, the provision can be injected into any component of our application.
    It is worth mentioning that we can also provide complex data types, such as arrays,
    objects, and reactive variables. In the following example, we are providing an
    object with functions and references to the parent methods:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，提供的内容可以注入到我们应用程序的任何组件中。值得一提的是，我们还可以提供复杂的数据类型，例如数组、对象和响应式变量。在以下示例中，我们提供了一个包含函数和父方法引用的对象：
- en: In the parent/root component
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在父/根组件中
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the child component
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在子组件中
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, we have effectively provided an `Admin.Users.Individual.Profile`
    is more descriptive than `user_data`. It is up to the team and the developer to
    define the naming convention (a path-like naming is just a suggestion, not a standard).
    As mentioned before in this book, once you’ve decided upon a convention, what
    matters is that you are consistent throughout the source code. Later in this chapter,
    we will use this method to create a plugin to display modal dialogs, but before
    that, we need to see a few more concepts regarding special components and templates.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有效地提供了一个`Admin.Users.Individual.Profile`，它比`user_data`更具描述性。命名约定（类似于路径的命名只是一个建议，而不是标准）由团队和开发者来定义。正如本书之前提到的，一旦你决定了一个约定，重要的是在整个源代码中保持一致性。在本章的后面部分，我们将使用这种方法创建一个用于显示模态对话框的插件，但在那之前，我们需要了解一些关于特殊组件和模板的更多概念。
- en: Special components
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊组件
- en: The hierarchy of components is very powerful but has limitations. We have seen
    how we can apply the dependency injection pattern to solve one of those, but there
    are other cases where we need a bit more flexibility, reusability, or power to
    share code or templates, or even move a component that’s rendering outside the
    hierarchy.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的层次结构非常强大，但也有局限性。我们已经看到如何应用依赖注入模式来解决这些问题之一，但还有其他一些情况需要更多的灵活性、可重用性或力量来共享代码或模板，甚至将渲染在层次结构之外的组件移动过来。
- en: Slots, slots, and more slots...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插槽，插槽，还有更多的插槽...
- en: 'Through the use of props, our component can receive JavaScript data. With analog
    reasoning, it is also possible to pass template fragments (HTML, JSX, and so on)
    into specific parts of a component’s template using placeholders called **slots**.
    Just like props, they accept several types of syntax. Let’s start with the most
    basic: the *default slot*.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用props，我们的组件可以接收JavaScript数据。通过类比推理，我们也可以使用称为**插槽**的占位符将模板片段（HTML、JSX等）传递到组件模板的特定部分。就像props一样，它们接受几种类型的语法。让我们从最基本的一个开始：*默认插槽*。
- en: 'Let’s assume we have a component named `MyMenuBar` that acts as a placeholder
    for a top menu. We want the parent component to populate the options in the same
    way that we use a common HTML tag such as `header` or `div`, like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为`MyMenuBar`的组件，它充当顶部菜单的占位符。我们希望父组件以我们使用常见HTML标签（如`header`或`div`）的方式填充选项，如下所示：
- en: Parent component
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 父组件
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: MyMenuBar component
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: MyMenuBar组件
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Provided that we applied the necessary styling and classes in `MyMenuBar`,
    the final rendered template may look something like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在`MyMenuBar`中应用了必要的样式和类，最终的渲染模板可能看起来像这样：
- en: '![Figure 4.5 – A menu bar using slots](img/Figure_4.05_B18602.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 使用插槽的菜单栏](img/Figure_4.05_B18602.jpg)'
- en: Figure 4.5 – A menu bar using slots
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 使用插槽的菜单栏
- en: 'The logic that’s applied is quite straightforward. The `<slot></slot>` placeholder
    will be replaced at runtime by whatever content is provided by the parent component
    inside the child tags. In the preceding example, if we inspect the rendered final
    HTML, we may find something like this (considering that we are using `W3.css`
    classes):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 应用到的逻辑非常直接。`<slot></slot>`占位符将在运行时被父组件在子标签内提供的任何内容所替换。在前面的示例中，如果我们检查渲染后的最终HTML，我们可能会发现如下内容（考虑到我们正在使用`W3.css`类）：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is a fundamental concept in user interface design. Now, what if we need
    multiple “slots” – for example, to create a layout component? Here, an alternative
    syntax called *named slots* comes into play. Consider the following example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用户界面设计中的一个基本概念。现在，如果我们需要多个“插槽”——例如，创建一个布局组件呢？在这里，一个称为*命名插槽*的替代语法就派上用场了。考虑以下示例：
- en: MyLayout component
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: MyLayout组件
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see, we have named each slot through the *name attribute*. In the
    parent component, we must now use the `template` element with the `v-slot` directive
    to access each one. Here is how a parent component would make use of `MyLayout`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们通过 *name 属性* 命名了每个槽。在父组件中，我们现在必须使用带有 `v-slot` 指令的 `template` 元素来访问每个槽。以下是一个父组件如何使用
    `MyLayout` 的示例：
- en: Parent component
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 父组件
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `v-slot` directive receives one argument, matching the slot name, with
    these remarks:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-slot` 指令接收一个参数，匹配槽名称，以下是一些注意事项：'
- en: If the name does not match any available slot, the content is not rendered.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果名称不匹配任何可用的槽，则内容不会被渲染。
- en: If no name is provided, or the name `default` is used, then the content is rendered
    in the default nameless slot.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有提供名称，或者使用了名称 `default`，那么内容将在默认的无名槽中渲染。
- en: 'If no content is provided for a template, then the default elements inside
    of the slot definition will be shown. Default content is placed in between the
    slot tags: `<slot>...default` `content here...</slot>`.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果模板没有提供内容，那么在槽定义内部的默认元素将被显示。默认内容放置在槽标签之间：`<slot>...default` `content here...</slot>`。
- en: 'There is also a shorthand notation for the `v-slot` directive. We just prefix
    the name of the slot with a numeral sign (`#`). For example, the templates in
    the preceding parent component can be simplified like so:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-slot` 指令也有简写符号。我们只需在槽名称前加上一个数字符号（`#`）。例如，前面父组件的模板可以简化如下：'
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Slots in Vue 3 are very powerful, to the point that they even admit a way to
    pass props to the parent if needed. The syntax varies depending on whether we
    are using a *default slot* or *named slots*. For example, consider the following
    component template definition:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 3 中的槽非常强大，甚至允许在需要时将属性传递给父组件。语法取决于我们是否使用 *默认槽* 或 *命名槽*。例如，考虑以下组件模板定义：
- en: PassingPropsUpward component
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 向上传递属性组件
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, the slot is passing a prop to the parent, named `data`. The parent component
    can then access it with the following syntax:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，槽将一个名为 `data` 的属性传递给父组件。父组件可以使用以下语法访问它：
- en: Parent component receiving props from the slot
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接收槽属性的父组件
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the parent component, we use the `v-slot` directive and assign a local name
    to the props passed by the slot – in this case, `upwardProp`. This variable will
    receive an object similar in function to the props object but scoped to the element.
    Because of this, these types of slots are called *named scoped slots*, and the
    syntax is similar. Take a look at this example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在父组件中，我们使用 `v-slot` 指令并给槽传递的属性分配一个本地名称——在这种情况下，`upwardProp`。这个变量将接收一个类似于属性对象的对象，但作用域限于元素。正因为如此，这类槽被称为
    *命名作用域槽*，语法类似。看看这个例子：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There are other advanced uses for slots that cover edge cases, but we will not
    cover those in this book. Instead, I encourage you to investigate the topic further
    in the official documentation at [https://vuejs.org/guide/components/slots.html](https://vuejs.org/guide/components/slots.html).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 槽还有其他高级用法，涵盖了边缘情况，但在这本书中我们将不涉及这些。相反，我鼓励您在官方文档中进一步研究这个主题：[https://vuejs.org/guide/components/slots.html](https://vuejs.org/guide/components/slots.html)。
- en: There is one more concept related to this topic that we will see later in this
    book, in [*Chapter 7*](B18602_07.xhtml#_idTextAnchor173), *Data Flow Management*,
    that applies to reactive central state management. Now, let’s look at some special
    components that behave a bit out of the ordinary.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 与此主题相关的一个概念我们将在本书的后面章节中看到，即 [*第7章*](B18602_07.xhtml#_idTextAnchor173)，*数据流管理*，它适用于响应式中心状态管理。现在，让我们看看一些有点不寻常的特殊组件。
- en: Composables and mixins
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合式和混入
- en: In Vue 2, a special component named `composables`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue 2 中，有一个名为 `composables` 的特殊组件。
- en: 'A **composable** is a function that uses the Composition API to encapsulate
    and reuse *stateful logic* between components. It is important to distinguish
    composables from service classes or other encapsulations of *business logic*.
    The main purpose of a composable is to share *user interface or user interaction
    logic*. In general, each composable does the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合式**是一个使用组合式 API 封装和重用组件之间 *状态逻辑* 的函数。区分组合式与服务类或其他 *业务逻辑* 的封装非常重要。组合式的主要目的是共享
    *用户界面或用户交互逻辑*。一般来说，每个组合式都执行以下操作：'
- en: Exposes a function that returns *reactive* variables.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个返回 *响应式* 变量的函数。
- en: Follows a naming convention prefixed with `use` in *camelCase* format – for
    example, `useStore()`, `useAdmin()`, `useWindowsEvents()`, and so on.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循以`use`为前缀的*camelCase*命名约定 – 例如，`useStore()`、`useAdmin()`、`useWindowsEvents()`等。
- en: It is self-contained in its own module.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在其自己的模块中是自包含的。
- en: It handles *stateful logic*. This means that it manages data that persists and
    changes over time.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它处理*状态逻辑*。这意味着它管理随时间持续变化的数据。
- en: 'The classical example of a composable attaches itself to environmental events
    (window resizing, mouse movements, sensors, animations, and so on). Let’s implement
    a simple composable that reads the vertical scroll of the document:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 组合式的经典例子是将其附加到环境事件（窗口大小调整、鼠标移动、传感器、动画等）上。让我们实现一个简单的组合式组件，它读取文档的垂直滚动：
- en: DocumentScroll.js
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: DocumentScroll.js
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this small composable, we start by importing component''s life cycle events
    and the reactive constructor from Vue (`//1`). Our main function, `useDocumentScroll`,
    contains the entire code that we will share and export later (`//6`). In `//2`,
    we create a reactive constant and initialize it to the current window vertical
    scroll. Then, we create an internal function, `update`, that updates the value
    of `y`. We add this function as a listener to the document scroll event in `//3`,
    and then remove it in `//4` (principle *“Clean after yourself,”* from [*Chapter
    2*](B18602_02.xhtml#_idTextAnchor040), *Software Design Principles and Patterns*).
    Finally, in `//5`, we return our reactive constant wrapped in an object. Then,
    in a component, we use this composable in this way:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小组合式组件中，我们首先从Vue导入组件的生命周期事件和响应式构造函数（`//1`）。我们的主函数`useDocumentScroll`包含了我们稍后要共享和导出的全部代码（`//6`）。在`//2`中，我们创建一个响应式常量并将其初始化为当前窗口的垂直滚动位置。然后，我们创建一个内部函数`update`，它更新`y`的值。我们在`//3`中将这个函数作为监听器添加到文档滚动事件，然后在`//4`中移除它（来自[*第2章*](B18602_02.xhtml#_idTextAnchor040)的*“清理自己的东西，”*原则）。最后，在`//5`中，我们返回一个包裹在对象中的响应式常量。然后，在一个组件中，我们这样使用这个组合式组件：
- en: SomeComponent.js – script setup
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: SomeComponent.js – 脚本设置
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once we have imported the reactive variable, we can use it in our code and template
    as usual. If we need to use this bit of logic in more than one component, we just
    need to import the composable (**DRY** principle).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们导入了响应式变量，我们就可以像往常一样在我们的代码和模板中使用它。如果我们需要在多个组件中使用这段逻辑，我们只需导入组合式组件（**DRY**原则）。
- en: Finally, [https://vueuse.org/](https://vueuse.org/) has an impressive collection
    of composables for our projects. It is worth checking out.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[https://vueuse.org/](https://vueuse.org/)为我们项目提供了一个令人印象深刻的组合式组件集合。它值得一看。
- en: Dynamic components with “component:is”
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有“component:is”的动态组件
- en: 'The Vue 3 framework provides a special component called `<component>` whose
    job is to be a placeholder to render other components dynamically. It works with
    a special attribute, `:is`, that can receive either a **String** with the name
    of a component, or a variable with the component definition. It also accepts some
    basic expressions (a line of code that resolves to a value). Here is a simple
    example using an expression:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 3框架提供了一个名为`<component>`的特殊组件，其任务是作为一个占位符动态渲染其他组件。它使用一个特殊属性`:is`，可以接收一个带有组件名称的**String**，或者一个带有组件定义的变量。它还接受一些基本表达式（一个解析为值的代码行）。以下是一个使用表达式的简单示例：
- en: CoinFlip component
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: CoinFlip组件
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When this component is rendered, we will see either the `Heads` or `Tails` component
    based on the result of the `flipCoin()` function.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个组件被渲染时，我们将根据`flipCoin()`函数的结果看到`Heads`或`Tails`组件。
- en: At this point, you might be wondering, why not use a simple `v-show/v-if`? The
    power of this component becomes apparent when managing components dynamically
    and we don’t know which ones are available at the time of creating the template.
    The official Vue Router, which we will see in [*Chapter 5*](B18602_05.xhtml#_idTextAnchor130),
    *Single-Page Applications*, uses this special component to simulate page navigation.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能想知道，为什么不使用简单的`v-show/v-if`？当动态管理组件并且不知道在创建模板时哪些组件可用时，这个组件的力量就显现出来了。我们将在[*第5章*](B18602_05.xhtml#_idTextAnchor130)中看到的官方Vue
    Router，*单页应用*，使用这个特殊组件来模拟页面导航。
- en: There is an edge case, however, that we need to be aware of. While most template
    attributes will pass through to the dynamic component, the use of some directives
    such as `v-model` will not work on *native input elements*. This situation is
    so rare that we will not discuss it in detail, but it can be found in the official
    documentation at [https://vuejs.org/api/built-in-special-elements.html#component](https://vuejs.org/api/built-in-special-elements.html#component).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个边缘情况，我们需要注意。虽然大多数模板属性将传递到动态组件，但某些指令（如`v-model`）在*原生输入元素*上不起作用。这种情况非常罕见，我们不会详细讨论，但可以在官方文档中找到[https://vuejs.org/api/built-in-special-elements.html#component](https://vuejs.org/api/built-in-special-elements.html#component)。
- en: 'Now that we have a deeper understanding of components, let’s put this new knowledge
    to work in two projects: a plugin, and a new version of our To-Do application.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对组件有了更深入的了解，让我们将新知识应用于两个项目：一个插件和我们的待办事项应用的新版本。
- en: A real-world example – a modals plugin
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个现实世界的例子 – 模态插件
- en: 'We have seen multiple approaches for sharing data and functionality *within*
    a project. Plugins are a design pattern for sharing functionality between projects
    and at the same time augmenting a system’s capabilities. Vue 3 provides a very
    simple interface to create plugins and attach them to our application instance.
    Any object that exposes an `install()` method or a function that accepts the same
    parameters can become a plugin. A plugin can do the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了多种在项目内部共享数据和功能的方法。插件是在项目之间共享功能并同时增强系统功能的设计模式。Vue 3 提供了一个非常简单的接口来创建插件并将它们附加到我们的应用实例。任何暴露`install()`方法或接受相同参数的函数都可以成为插件。插件可以执行以下操作：
- en: Register global components and directives
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册全局组件和指令
- en: Register an injectable resource at the application level
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用级别注册可注入的资源
- en: Create and attach new properties or methods to the application
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为应用创建和附加新的属性或方法
- en: In this section, we will create a plugin that implements modal dialogs as global
    components. We will use dependency injection to provide them as a resource and
    leverage Vue’s reactivity to manage them through promises.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个实现模态对话框作为全局组件的插件。我们将使用依赖注入来提供它们作为资源，并利用Vue的响应性通过promises来管理它们。
- en: Setting up our development project
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的开发项目
- en: Follow the instructions in [*Chapter 3*](B18602_03.xhtml#_idTextAnchor079),
    *Setting Up a Working Project*, so that you have a starting point. In the `src/`
    directory, create a new folder named `plugins/`, with a sub-folder named `modals/`.
    It is a standard approach to place our plugins in individual directories inside
    the `plugins/` folder.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[*第 3 章*](B18602_03.xhtml#_idTextAnchor079)中的说明，*设置工作项目*，以便您有一个起点。在`src/`目录下，创建一个名为`plugins/`的新文件夹，并在其中创建一个名为`modals/`的子文件夹。将插件放置在`plugins/`文件夹内的单独目录中是一种标准做法。
- en: The design
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: 'Our plugin will install a component globally and keep an internal reactive
    state to track the current modal dialog status. It will also provide an API to
    be injected as a dependency to those components that need to open a modal dialog.
    This interaction can be represented like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的插件将全局安装一个组件，并保持一个内部响应式状态来跟踪当前模态对话框的状态。它还将提供一个API，以便将其作为依赖项注入需要打开模态对话框的组件。这种交互可以表示如下：
- en: "![Figure 4.6 \uFEFF– The modal plugin’s representation](img/Figure_4.06_B18602.jpg)"
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 模态插件表示](img/Figure_4.06_B18602.jpg)'
- en: Figure 4.6 – The modal plugin’s representation
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 模态插件表示
- en: Components will implement a modal element, and we will open the dialog through
    code. When a modal is open, it will return a promise following the async pattern.
    When the user accepts the modal, the promise will resolve, and reject upon cancellation.
    The content of the modal will be provided by the parent component through the
    use of slots.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 组件将实现模态元素，我们将通过代码打开对话框。当模态打开时，它将返回一个遵循异步模式的promise。当用户接受模态时，promise将解析，并在取消时拒绝。模态的内容将由父组件通过使用插槽提供。
- en: The implementation
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'For this plugin, we will only need two files – one for the plugin''s logic
    and one for our component. Go ahead and create the `index.js` and `Modal.vue`
    files in the `src/plugins/modal` folder. At the moment, just scaffold the component
    with the section’s script setup, template, and style. We will come back later
    to complete it. With those files in place, let’s start, step by step, with the
    `index.js` file:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个插件，我们只需要两个文件——一个用于插件的逻辑，另一个用于我们的组件。请在前往`src/plugins/modal`文件夹中创建`index.js`和`Modal.vue`文件。目前，只需使用该节段的脚本设置、模板和样式来搭建组件。我们稍后再回来完成它。有了这些文件，让我们一步一步地开始处理`index.js`文件：
- en: /src/plugins/modals/index.js
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: /src/plugins/modals/index.js
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We start in `//1` by importing the `reactive` constructor from Vue, and a `Modal`
    component whose file we have not yet created. Then, in line `//2`, we create an
    internal state property, `_current`, and in `//3`, an object that will be our
    API. For now, these are just placeholders. The important section is in line `//4`,
    where we define the `install()` function. This function receives two parameters
    in order:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`//1`开始，从Vue导入`reactive`构造函数和一个我们尚未创建的`Modal`组件。然后在`//2`行中创建一个内部状态属性`_current`，在`//3`行中创建一个将成为我们的API的对象。目前，这些只是占位符。重要的部分在`//4`行，我们在这里定义了`install()`函数。这个函数接收两个参数：
- en: The application instance (`App`).
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序实例（`App`）。
- en: An object with options, if one was passed during the installation process.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在安装过程中传递了选项，则包含选项的对象。
- en: 'With the application instance, we register `Modal` as a global component and
    provide the API as an injectable resource under the name `$modals,` both at the
    application level. To use the plugin in our application, we must import it into
    `main.js` and register it with the `use` method. The code looks like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用应用程序实例，我们将`Modal`注册为全局组件，并将API作为名为`$modals`的可注入资源在应用程序级别提供。为了在我们的应用程序中使用此插件，我们必须将其导入到`main.js`中，并使用`use`方法进行注册。代码如下：
- en: /src/Main.js
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: /src/Main.js
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you can see, creating and using a plugin is rather simple. However, thus
    far, our plugin doesn’t do much. Let’s go back to our plugin code and complete
    the API. What we need is the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，创建和使用插件相当简单。然而，到目前为止，我们的插件并没有做很多事情。让我们回到我们的插件代码，并完成API。我们需要的是以下内容：
- en: A `show()` method that takes a name that identifies a modal dialog implementation
    and returns a promise. We will then save the name and references to the `resolve()`
    and `reject()` functions in our reactive state.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`show()`方法，它接受一个标识模态对话框实现的名称，并返回一个promise。然后我们将名称和`resolve()`和`reject()`函数的引用保存在我们的响应式状态中。
- en: An `accept()` and `cancel()` methods, to resolve and reject the promise, respectively.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accept()`和`cancel()`方法，分别用于解决和拒绝promise。'
- en: An `active()` method to retrieve the name of the current modal.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`active()`方法，用于检索当前模态的名称。
- en: 'Following these guidelines, we can complete the code so that our `index.js`
    file looks like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这些指南，我们可以完成代码，使我们的`index.js`文件看起来像这样：
- en: /src/plugins/modals/index.js
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: /src/plugins/modals/index.js
- en: '[PRE31]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Our internal state is kept with a `reactive` variable and only accessed through
    our API. In general, this is a good design for any API. Now, it is time to make
    the magic happen in our `Modal.vue` component, to complete the workflow. I’m omitting
    the classes and styles for brevity, but the full code can be found in this book’s
    GitHub repository at [https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`reactive`变量来保持内部状态，并且只通过我们的API进行访问。一般来说，这对任何API来说都是一个很好的设计。现在，是时候在我们的`Modal.vue`组件中施展魔法，以完成工作流程了。为了简洁，我省略了类和样式，但完整的代码可以在本书的GitHub仓库[https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices)中找到。
- en: 'Our modal component will have to do the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式组件需要执行以下操作：
- en: Cover the entire viewable area with a translucent element to block interaction
    with the rest of the application
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用半透明元素覆盖整个可查看区域，以阻止与应用程序其他部分的交互
- en: 'Provide the dialog to be displayed:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供要显示的对话框：
- en: A *prop* to register the name of the component, as provided by the parent.
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*属性*用于注册组件的名称，由父组件提供。
- en: A *header* to display a title. The title will also be a prop.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*标题*用于显示标题。标题也将是一个属性。
- en: An area for the parent component to populate with custom content.
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个区域供父组件填充自定义内容。
- en: A footer with *accept* and *cancel* buttons.
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含带有*接受*和*取消*按钮的页脚。
- en: A reactive property that triggers when the component should appear.
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个在组件应该出现时触发的响应式属性。
- en: 'With our definition in place, let’s work on the template:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的定义到位后，让我们开始处理模板：
- en: /src/plugins/modals/Modal.vue
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: /src/plugins/modals/Modal.vue
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In line `//1`, the reactive variable, `_show`, controls the visibility of the
    dialog modal. We display the prop `title` in line `//2`, and reserve a slot in
    line `//3`. The buttons in line `//4` will close the modal on the click event,
    each one with a representative Boolean value.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 `//1` 行，响应式变量 `_show` 控制对话框的可见性。我们在第 `//2` 行显示 `title` prop，并在第 `//3` 行预留一个槽位。第
    `//4` 行的按钮将在点击事件中关闭模态，每个按钮都有一个代表性的布尔值。
- en: 'Not, it’s time to write the logic of the component. In our script, we need
    to do the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候编写组件的逻辑了。在我们的脚本中，我们需要做以下事情：
- en: 'Define two props: `title` (for display) and `name` (for identification)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义两个 props：`title`（用于显示）和 `name`（用于识别）
- en: 'Inject the `$modals` resource so that we can interact with the API and do these
    things:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入 `$modals` 资源，以便我们可以与 API 交互并执行以下操作：
- en: Check if the modal’s name matches the current component (this “opens” the modal
    dialog)
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查模态的名称是否与当前组件匹配（这“打开”了模态对话框）
- en: Close the modal by resolving or rejecting the promise
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过解决或拒绝承诺来关闭模态
- en: Following these directions, we can complete our `script setup:`
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这些指示，我们可以完成我们的 `script setup：`
- en: '[PRE33]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We begin in line `//1` by importing the `inject` and `computed` functions. In
    line `//2`, we create the props with sensible defaults. In line `//3`, we inject
    the `$modals` resource (dependency) that we will use in the computed property
    in line `//4` to retrieve the current active modal and compare it with the component.
    Finally, in line `//5`, based on the click of the buttons, we trigger the resolution
    or rejection of the promise.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从第 `//1` 行开始，导入 `inject` 和 `computed` 函数。在第 `//2` 行，我们创建具有合理默认值的 props。在第
    `//3` 行，我们注入 `$modals` 资源（依赖项），我们将在第 `//4` 行的 computed 属性中使用它来检索当前活动模态并将其与组件进行比较。最后，在第
    `//5` 行，根据按钮的点击，我们触发承诺的解决或拒绝。
- en: 'To use this plugin from any component in our application, we must follow these
    steps:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用中的任何组件中使用此插件，我们必须遵循以下步骤：
- en: 'In `template`, define a modal component with the name registered in our plugin
    (`Modal`). Notice the use of the attributes for props:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `template` 中，定义一个名为我们在插件中注册的组件（`Modal`）。注意使用属性为 props：
- en: '[PRE34]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In our script setup, inject the dependency with the following code:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的脚本设置中，使用以下代码注入依赖项：
- en: '[PRE35]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Display the modal component by the given name with this code:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下代码通过给定的名称显示模态组件：
- en: '[PRE36]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With this, we have completed our first plugin in Vue 3\. Let’s put it to good
    use in our new To-Do list application.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，我们已经完成了我们的第一个 Vue 3 插件。让我们在我们的新待办事项应用中好好利用它。
- en: Implementing our new To-Do application
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现我们的新待办事项应用
- en: 'At the beginning of this chapter, we saw a design for our new to-do application,
    and we sliced it into hierarchical components (see *Figure 4**.1*). To follow
    the rest of this section, you will need a copy of the source code from this book’s
    GitHub repository ([https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices)).
    As our code base grows, it is not possible to see each piece of implementation
    in detail, so we will focus on the main changes and specific bits of code. With
    that in mind, let’s review the changes from the previous implementation, roughly
    in order of file execution. To start, we added two new directories to our project:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们看到了我们新待办事项应用的设计，并将其切割成层次组件（见 *图 4**.1*）。为了跟随本节的其余部分，你需要从本书的 GitHub
    仓库中获取源代码副本（[https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices)）。随着我们的代码库的增长，不可能详细查看每个实现，因此我们将关注主要更改和特定的代码片段。考虑到这一点，让我们回顾前一个实现中的更改，大致按照文件执行顺序。首先，我们在项目中添加了两个新的目录：
- en: '`/src/plugins`, where we placed our `Modals` plugin.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/src/plugins`，我们放置我们的 `Modals` 插件的位置。'
- en: '`/src/services`, where we place modules with our business or middleware logic.
    Here, we created a service object to handle the business logic of our To-Do list:
    the `todo.js` file.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/src/services`，我们放置具有我们的业务或中间件逻辑的模块。在这里，我们创建了一个服务对象来处理我们的待办事项列表的业务逻辑：`todo.js`
    文件。'
- en: In `main.js`, we import and add our plugin to the application object, using
    the `.use(Modals)` method to register our plugin.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.js` 中，我们导入并添加我们的插件到应用对象，使用 `.use(Modals)` 方法注册我们的插件。
- en: The `App.vue` file has become primarily a layout component, without any other
    application logic. We import and use a header, `(MainHeader.vue)`, and a parent
    component to manage our To-Do list and UI, (`ToDoProject.vue)`, just like in the
    design shown in *Figure 4**.2*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.vue`文件已经变成了一个主要的布局组件，没有其他应用程序逻辑。我们导入并使用一个头部组件`(MainHeader.vue)`和一个父组件来管理我们的待办事项和UI，(`ToDoProject.vue)`，就像*图
    4.2*中所示的设计一样。'
- en: 'The `ToDoProject` component contains the state of the list through reactive
    variables, where we have the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToDoProject`组件通过反应变量包含列表的状态，其中我们有以下内容：'
- en: '`_items` is an array that contains our To-Do items'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_items`是一个包含我们的待办事项的数组'
- en: '`_item` is an auxiliary reactive variable that we use to create new items or
    edit a duplicate of an item'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_item`是一个辅助反应变量，我们用它来创建新项目或编辑项目的副本'
- en: '`_filter` is another auxiliary reactive variable that we use to input a string
    to filter on our list'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_filter`是另一个辅助反应变量，我们用它来输入一个字符串以过滤我们的列表'
- en: It is worth mentioning that we also declare a constant, `$modals`, that receives
    the injected `Modals` object API. Notice how the `showModal()` function opens
    and manages the result of the dialog for new and edited items using this object.
    Then, the modal in question appears in the template, by the ending marked with
    a comment. It is customary to place all the modal templates toward the end of
    a component, instead of being spaced all over the template.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们还声明了一个常量`$modals`，它接收注入的`Modals`对象API。注意`showModal()`函数如何使用此对象打开和管理新项目和编辑项目的对话框结果。然后，相关的模态在模板中显示，通过注释的结尾标记。通常，将所有模态模板放置在组件的末尾，而不是分散在整个模板中。
- en: The `ToDoProject` component delegates state data through props to child components
    to display summary and list items. It also receives events from them, with instructions
    to manipulate the list. You can consider this component as the *root* of functionality.
    Our application only has one, but this begins to hint at the idea of how a web
    application starts to get organized by functionality.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToDoProject`组件通过props将状态数据委派给子组件以显示摘要和列表项。它也从它们那里接收事件，带有操作列表的指令。你可以将这个组件视为功能的*根*。我们的应用程序只有一个，但这开始暗示了网络应用程序如何通过功能开始组织。'
- en: There is another point worth mentioning, which is the use of *service objects
    and classes*. In our application, we have `todo.js`, which we import as `todoService`
    where needed. In this case, this is a *singleton*, but it could also be a class
    constructor. *Notice that it does not contain any interface logic, only application
    or business logic*. This is a defining factor that differentiates it from *composables*,
    which we have seen before.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的点，是使用*服务对象和类*。在我们的应用程序中，我们有`todo.js`，我们在需要的地方将其导入为`todoService`。在这种情况下，这是一个*单例*，但它也可以是一个类构造函数。*请注意，它不包含任何接口逻辑，只有应用程序或业务逻辑*。这是区分它与之前看到的*组合式*的一个决定性因素。
- en: 'Another change is that the To-Do items now have multiple states, and we can
    cycle through them with a click. We have implemented this logic in the `toggleStatus()`
    function of the service, *not in the component*. The flow between the states can
    be represented like this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个变化是待办事项现在有多个状态，我们可以通过点击在它们之间循环。我们在服务的`toggleStatus()`函数中实现了这个逻辑，*而不是在组件中*。状态之间的流程可以表示如下：
- en: "![Figure 4.7 \uFEFF– A circular finite state machine](img/Figure_4.07_B18602.jpg)"
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 一个循环有限状态机](img/Figure_4.07_B18602.jpg)'
- en: Figure 4.7 – A circular finite state machine
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 一个循环有限状态机
- en: 'You may recognize the design, as it represents a `switch` statement, like in
    our example:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认出了这个设计，因为它代表了一个`switch`语句，就像我们例子中的那样：
- en: Todo.js
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Todo.js
- en: '[PRE37]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This function, given its current status, will return the next one. Calling this
    function on each click, we can update the state of each item in a clean manner.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数，根据其当前状态，将返回下一个状态。在每次点击时调用此函数，我们可以以干净的方式更新每个项目的状态。
- en: The final point to remark about this new implementation is the use of computed
    properties in the `ToDoSummary` component. We use them to display summary cards
    with the different states of our items. Notice how well the reactivity works –
    the moment we alter the state of an item in the list, the summary is immediately
    updated!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个新实现的最后一个要点是`ToDoSummary`组件中计算属性的用法。我们使用它们来显示具有不同状态的项目的摘要卡片。注意反应性工作得有多好——当我们改变列表中项目的状态时，摘要会立即更新！
- en: With the new implementation in order, it is time to take a step back and view
    our work with a critical mind.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 新的实现已经有序进行，现在是时候退一步，用批判性的思维审视我们的工作了。
- en: A small critique of our new To-Do application
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对我们新的待办事项应用的小批评
- en: 'This new version of the To-Do application is a clear improvement over our first
    approach, but it can be improved:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的第一次方法相比，这个新的待办事项应用版本是一个明显的改进，但它还可以改进：
- en: We still have only one list of tasks.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们仍然只有一个任务列表。
- en: Everything still happens in just one page.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的操作都只在一个页面上发生。
- en: Our items are ephemeral. They disappear when we close or refresh the browser.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的项目是短暂的。当我们关闭或刷新浏览器时，它们就会消失。
- en: There is no security, no way to have multiple users, and so on.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有安全性，没有多用户的方式，等等。
- en: We can only add plain text. How about images or rich text?
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只能添加纯文本。图像或富文本怎么办？
- en: With a bit of work, we could expand our application so that it manages multiple
    projects, additional content, assignments, and more.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经过一些工作，我们可以扩展我们的应用程序，使其管理多个项目、额外内容、分配等等。
- en: We have made good progress, but there is still more to do.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经取得了良好的进展，但仍有许多工作要做。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we dived deep into components and learned how they can communicate,
    share functionality, and implement design patterns within the framework. We also
    saw an approach to transform a rough sketch or detailed design into components.
    We then learned about special components, created a plugin for modal dialogs using
    the framework’s dependency injection, and applied other patterns to make our coding
    easier and more congruent. Furthermore, we refactored our application and expanded
    its capabilities while taking a glimpse at better state management, independent
    from the HTML element we used before. We have made good progress, but there is
    still more to go.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入研究了组件，学习了它们如何在框架内进行通信、共享功能以及实现设计模式。我们还看到了将粗糙草图或详细设计转化为组件的方法。然后我们了解了特殊组件，使用框架的依赖注入创建了一个模态对话框插件，并应用其他模式使我们的编码更加容易和一致。此外，我们对应用程序进行了重构，扩展了其功能，同时审视了更好的状态管理，独立于我们之前使用的HTML元素。我们已经取得了良好的进展，但仍有许多工作要做。
- en: In the next chapter, we will create a **single-page application** (**SPA**)
    with what we learned this far.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将使用到目前为止所学的内容创建一个**单页应用**（SPA）。
- en: Review questions
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的掌握：
- en: How can we start from a visual design or prototype and plan the implementation
    with components?
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何从一个视觉设计或原型开始，并使用组件来规划实现？
- en: What are the many ways that components can communicate with each other?
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件之间可以以多少种方式相互通信？
- en: How we can reuse code in multiple components? Is there any other way?
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何在多个组件中重用代码？还有其他方法吗？
- en: What is a plugin, and how can we create one?
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件是什么，我们如何创建一个？
- en: Which patterns have we applied to the new To-Do application?
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在新的待办事项应用中应用了哪些模式？
- en: What would you change in the implementation?
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会在实现中做哪些改变？
