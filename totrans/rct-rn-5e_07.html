<html><head></head><body>
  <div id="_idContainer062" class="Basic-Text-Frame">
    <h1 class="chapterNumber">6</h1>
    <h1 id="_idParaDest-97" class="chapterTitle">Type-Checking and Validation with TypeScript</h1>
    <p class="normal">In this chapter, we’ll explore the importance of <strong class="keyWord">property validation</strong> in React components for creating robust, bug-free applications. We’ll introduce <strong class="keyWord">TypeScript</strong>, which is a powerful tool for static type-checking in JavaScript. </p>
    <p class="normal">We’ll guide you through setting up TypeScript in the project and cover its basic and advanced concepts. We’ll also provide examples of how to use TypeScript for type-checking in React components.</p>
    <p class="normal">By the end of this chapter, you’ll have a solid foundation in property validation and type-checking, and be ready to create more predictable, reliable components using TypeScript.</p>
    <p class="normal">The following topics will be covered in this chapter:</p>
    <ul>
      <li class="bulletList">Knowing what to expect</li>
      <li class="bulletList">An introduction to TypeScript</li>
      <li class="bulletList">Using TypeScript in React</li>
    </ul>
    <h1 id="_idParaDest-98" class="heading-1">Technical requirements </h1>
    <p class="normal">The code files for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter05"><span class="url">https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter05</span></a>.</p>
    <h1 id="_idParaDest-99" class="heading-1">Knowing what to expect</h1>
    <p class="normal">In any application, predictability is key. A predictable application behaves in expected ways, reducing bugs, improving user experience, and simplifying maintenance. When we talk about predictability in the context of React, we often refer to how components behave based on the props they receive. Props is short for properties and serves as the inputs to React components, determining their behavior and rendering. This is where the concept of <strong class="keyWord">props validation</strong> comes into play.</p>
    <h2 id="_idParaDest-100" class="heading-2">The importance of props validation</h2>
    <p class="normal">Props validation is a<a id="_idIndexMarker198"/> way to ensure that components receive the right type of data. It’s like a contract between components. When a component specifies the types of props it expects to receive, it <a id="_idIndexMarker199"/>makes a promise that it will behave in a certain way if it receives props of those types.</p>
    <p class="normal">Props validation is crucial for a few reasons, as follows:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">It helps catch errors early in the development process</strong>: If a component receives a prop of an unexpected type, it might not behave as expected, leading to bugs that can be hard to track down. By validating props, we can catch these errors before they cause problems.</li>
      <li class="bulletList"><strong class="keyWord">Props validation improves code readability</strong>: By looking at a component’s prop types, you can quickly understand what data the component expects to receive. This makes it easier to use and reuse components throughout your application.</li>
      <li class="bulletList"><strong class="keyWord">Props validation makes components more predictable</strong>: When a component clearly specifies the types of props it expects to receive, it’s easier to understand how the component will behave based on its props.</li>
    </ul>
    <h2 id="_idParaDest-101" class="heading-2">Potential issues without props validation</h2>
    <p class="normal">Without<a id="_idIndexMarker200"/> adequate props validation, components can become unpredictable and prone to bugs. Let’s take a look at a component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">MyList</span> = (<span class="hljs-params">{ list }</span>) =&gt; (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
    {list.map((user) =&gt; (
      <span class="hljs-tag">&lt;</span><span class="hljs-name">li</span><span class="hljs-tag"> </span><span class="hljs-attr">key</span><span class="hljs-tag">=</span><span class="hljs-string">{user.name}</span><span class="hljs-tag">&gt;</span>
        {user.name} ({user.email})
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">li</span><span class="hljs-tag">&gt;</span>
    ))}
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
);
</code></pre>
    <p class="normal">In this <a id="_idIndexMarker201"/>example, a component expects to receive a <strong class="keyWord">list prop</strong>, which<a id="_idIndexMarker202"/> should be an array of objects with name and email properties. If this component receives a list prop that is a string, a number, or even an array, but without objects, it might try to access <code class="inlineCode">user.name</code> or <code class="inlineCode">user.email</code>, which would result in an error.</p>
    <p class="normal">These types of errors can be hard to debug, especially in larger applications with many components. It also might be difficult to understand what exactly we should provide to the component without reading every single line of code of this component. Errors can also lead to crashes or unexpected behavior in your application. But what if we can add a props validation to our components that can help us catch these errors early and ensure that your components behave as expected? Let’s explore it.</p>
    <h2 id="_idParaDest-102" class="heading-2">Options for props validation</h2>
    <p class="normal">There<a id="_idIndexMarker203"/> are several tools you can use for props validation in React and React Native. One of these is <code class="inlineCode">PropTypes</code>, a library that allows you to specify the types of props a component should receive. Another option is TypeScript, a statically typed superset of JavaScript that provides powerful tools for type-checking. </p>
    <p class="normal">Now, I would like to show you examples of the <code class="inlineCode">MyList</code> component with <code class="inlineCode">PropTypes</code>. Take a look at this component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> <span class="hljs-title">PropTypes</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'prop-types'</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title">MyList</span> = (<span class="hljs-params">{ list }</span>) =&gt; (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
    {list.map((user) =&gt; (
      <span class="hljs-tag">&lt;</span><span class="hljs-name">li</span><span class="hljs-tag"> </span><span class="hljs-attr">key</span><span class="hljs-tag">=</span><span class="hljs-string">{user.name}</span><span class="hljs-tag">&gt;</span>
        {user.name} ({user.email})
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">li</span><span class="hljs-tag">&gt;</span>
    ))}
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
);
<span class="hljs-title">MyList</span>.<span class="hljs-property">propTypes</span> = {
  <span class="hljs-attr">list</span>: <span class="hljs-title">PropTypes</span>.<span class="hljs-title">arrayOf</span>(
    <span class="hljs-title">PropTypes</span>.<span class="hljs-title">shape</span>({
      <span class="hljs-attr">name</span>: <span class="hljs-title">PropTypes</span>.<span class="hljs-property">string</span>.<span class="hljs-property">isRequired</span>,
      <span class="hljs-attr">email</span>: <span class="hljs-title">PropTypes</span>.<span class="hljs-property">string</span>.<span class="hljs-property">isRequired</span>,
    })
  ).<span class="hljs-property">isRequired</span>,
};
</code></pre>
    <p class="normal">In this <a id="_idIndexMarker204"/>example, we’re using <code class="inlineCode">PropTypes</code> to specify that the <code class="inlineCode">list</code> prop should be an array of objects, and each object should have a <code class="inlineCode">name</code> and an <code class="inlineCode">email</code> property, both of which should be strings. </p>
    <p class="normal">Next, let’s take a look at the TypeScript example:</p>
    <pre class="programlisting code"><code class="hljs-code">type <span class="hljs-title">User</span> = {
  <span class="hljs-attr">name</span>: string;
  <span class="hljs-attr">email</span>: string;
};
type <span class="hljs-title">MyListProps</span> = {
  <span class="hljs-attr">list</span>: <span class="hljs-title">User</span>[];
};
<span class="hljs-keyword">const</span> <span class="hljs-title">MyList</span> = (<span class="hljs-params">{ list }: MyListProps</span>) =&gt; (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
    {list.map((user) =&gt; (
      <span class="hljs-tag">&lt;</span><span class="hljs-name">li</span><span class="hljs-tag"> </span><span class="hljs-attr">key</span><span class="hljs-tag">=</span><span class="hljs-string">{user.name}</span><span class="hljs-tag">&gt;</span>
        {user.name} ({user.email})
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">li</span><span class="hljs-tag">&gt;</span>
    ))}
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
);
</code></pre>
    <p class="normal">In this TypeScript example, we’re defining a <code class="inlineCode">User</code> type and a <code class="inlineCode">MyListProps</code> type. The <code class="inlineCode">User</code> type is an object with a <code class="inlineCode">name</code> and an <code class="inlineCode">email</code> property, both of which are strings. The <code class="inlineCode">MyListProps</code> type is an object with a <code class="inlineCode">list</code> property, which is an array of <code class="inlineCode">User</code> objects.</p>
    <p class="normal">While both PropTypes and TypeScript offer valuable tools for props validation, we’ll be focusing on TypeScript for the remainder of this book. TypeScript provides a more comprehensive and powerful approach to type-checking, and it’s becoming increasingly popular in the React and React Native communities. </p>
    <p class="normal">In the following chapters, all examples will use TypeScript. By the end of this book, you’ll have a solid understanding of TypeScript and how to use it in your own React and React Native projects. So, let’s dive in and start exploring the world of TypeScript!</p>
    <h1 id="_idParaDest-103" class="heading-1">Introduction to TypeScript</h1>
    <p class="normal">As we embark on this journey to learn about type-checking and validation, let’s momentarily step away from React and React Native and turn our attention to TypeScript. You might be wondering, “What exactly is TypeScript?”</p>
    <p class="normal"><strong class="keyWord">TypeScript</strong> is a<a id="_idIndexMarker205"/> statically typed superset <a id="_idIndexMarker206"/>of <strong class="keyWord">JavaScript</strong>, developed and maintained by Microsoft. This means that it adds additional features to JavaScript, one of the most significant being static typing. While JavaScript is dynamically typed, TypeScript introduces a type system that allows you to explicitly define the type of data that variables, function parameters, and function return values can have.</p>
    <p class="normal">But don’t worry, TypeScript is completely compatible with JavaScript. In fact, any valid JavaScript code is also valid TypeScript code. TypeScript uses a transpiler (a type of compiler) to convert TypeScript code, which browsers can’t understand directly, into JavaScript code, which can run in any environment where JavaScript runs.</p>
    <p class="normal">Consider the following JavaScript function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-keyword">return</span> "<span class="hljs-title">Hello</span>, " + name;
}
<span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-title">greet</span>("<span class="hljs-title">Mike</span>")); <span class="hljs-comment">// "Hello, Mike"</span>
<span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-title">greet</span>(<span class="hljs-number">32</span>)); <span class="hljs-comment">// "Hello, 32"</span>
</code></pre>
    <p class="normal">This function works as expected when you pass a string as an argument. But if you pass a number, it doesn’t throw an error, even though it doesn’t make much sense to greet a number.</p>
    <p class="normal">Now, let’s see how we could write this function in TypeScript:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name: string</span>) {
  <span class="hljs-keyword">return</span> "<span class="hljs-title">Hello</span>, " + name;
}
<span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-title">greet</span>("<span class="hljs-title">Mike</span>")); <span class="hljs-comment">// "Hello, Mike"</span>
<span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-title">greet</span>(<span class="hljs-number">32</span>)); <span class="hljs-comment">// Error: Argument of type 'number' is not assignable to parameter of type 'string'.</span>
</code></pre>
    <p class="normal">In the <a id="_idIndexMarker207"/>TypeScript version, we’ve added a type annotation to the <code class="inlineCode">name</code> parameter. This tells TypeScript that <code class="inlineCode">name</code> should always be a string. If we try to call <code class="inlineCode">greet</code> with a number, TypeScript will give us an error. This helps us catch the mistake before we even run the code.</p>
    <p class="normal">This is a simple example, but it illustrates one of the key benefits of TypeScript: it can help us catch errors early before they lead to bugs in our code. It’s like having a helpful co-pilot who points out potential issues before they become problematic.</p>
    <h2 id="_idParaDest-104" class="heading-2">Why use TypeScript?</h2>
    <p class="normal">Now that we’ve<a id="_idIndexMarker208"/> introduced what TypeScript is, let’s delve into why you might want to learn and use it in your projects:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Catch errors early</strong>: We’ve already discussed it, but it’s worth putting it in the first place on the list. One of the biggest advantages of TypeScript is its ability to catch errors at compile time, before even running the code. This can help prevent many common errors that might not be caught until runtime in regular JavaScript.</li>
      <li class="bulletList"><strong class="keyWord">Improve code readability</strong>: TypeScript’s <strong class="keyWord">type annotations</strong> make it clear what kind of values a function <a id="_idIndexMarker209"/>expects as arguments or what type of value a function returns. This can make the code easier to read and understand, especially for other developers who might be working on the same code base.</li>
      <li class="bulletList"><strong class="keyWord">Easier refactoring</strong>: TypeScript’s static typing also makes it easier to refactor code. If you change the type of a variable or the signature of a function, TypeScript can help you find all the places in your code where you need to make corresponding changes.</li>
      <li class="bulletList"><strong class="keyWord">Community and tooling support</strong>: TypeScript has gained significant popularity in the JavaScript community and is used by many large companies like Microsoft, Google, and Airbnb. This implies that there’s a large community of developers who can provide support and a wealth of resources for learning TypeScript. Additionally, many code editors have excellent support for TypeScript, providing features like <strong class="keyWord">autocompletion</strong>, <strong class="keyWord">type inference</strong>, and <strong class="keyWord">error highlighting</strong>.</li>
      <li class="bulletList"><strong class="keyWord">Integration with modern frameworks and libraries</strong>: TypeScript integrates well with modern JavaScript frameworks like React and React Native, which have built-in TypeScript definitions, making it easier to build strongly typed applications. Moreover, a vast majority of popular JavaScript libraries have TypeScript definitions available. These definitions, often contributed by the community, provide<a id="_idIndexMarker210"/> type information about the library’s functions and objects, making it easier and safer to use these libraries in your TypeScript projects. 
    <p class="bulletList">This widespread adoption of TypeScript in the JavaScript ecosystem ensures that you can leverage the benefits of TypeScript almost anywhere in your code base.</p> </li>
    </ul>
    <ul>
      <li class="bulletList"><strong class="keyWord">Increasing job market demand</strong>: The popularity of TypeScript extends beyond just development practices: it’s also increasingly sought after in the job market. Many companies, from start-ups to large corporations, are adopting TypeScript for their projects, and as a result, there’s a growing demand for developers who are proficient in TypeScript. This is particularly true for roles involving React and React Native, where TypeScript is often used for its benefits in scaling and maintaining large code bases. By learning TypeScript, you’re not only gaining a valuable skill for your projects but also making yourself more marketable as a developer.</li>
    </ul>
    <p class="normal">In summary, TypeScript offers a range of benefits that can help you write more robust, maintainable code. It’s a valuable tool in any JavaScript developer’s toolkit, and its growing popularity in the job market makes it a worthwhile investment for your career development.</p>
    <p class="normal">But understanding the benefits of TypeScript is just the first step. To truly harness its power, you need to know how to use it in your projects. In the next section, we’ll guide you through the process of setting up TypeScript in a React project. We’ll cover everything from installing TypeScript to configuring your project to use it. So, let’s dive in and start exploring the practical side of TypeScript!</p>
    <h2 id="_idParaDest-105" class="heading-2">Setting up TypeScript in a project</h2>
    <p class="normal">In the first chapter, we walked through<a id="_idIndexMarker211"/> the process of creating a new React project using <strong class="keyWord">Vite</strong>. Now, let’s see how we can create a TypeScript project.</p>
    <p class="normal"><strong class="keyWord">Vite</strong> provides<a id="_idIndexMarker212"/> a template for creating a new React and TypeScript project. You can create a new project with the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">npm create vite@latest my-react-app -- --template react-ts
</code></pre>
    <p class="normal">This command creates a new Vite project with the <code class="inlineCode">react-ts</code> template, which includes TypeScript. The project based on this template will include the <code class="inlineCode">tsconfig.json</code> file in the root of your project. This file is used to configure TypeScript for your project.</p>
    <p class="normal">Here’s what the <code class="inlineCode">tsconfig.json</code> file might look like:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation">{</span>
  "compilerOptions"<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    "target"<span class="hljs-punctuation">:</span> "esnext"<span class="hljs-punctuation">,</span>
    "module"<span class="hljs-punctuation">:</span> "esnext"<span class="hljs-punctuation">,</span>
    "jsx"<span class="hljs-punctuation">:</span> "react-jsx"<span class="hljs-punctuation">,</span>
    "strict"<span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
    "moduleResolution"<span class="hljs-punctuation">:</span> "node"<span class="hljs-punctuation">,</span>
    "esModuleInterop"<span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
    <p class="normal">These <a id="_idIndexMarker213"/>settings tell TypeScript to compile your code to the latest version of JavaScript (<code class="inlineCode">"target": "esnext"</code>), to use the latest module system (<code class="inlineCode">"module": "esnext"</code>), and to use the new JSX transform introduced in <em class="italic">React 17</em> (<code class="inlineCode">"jsx": "react-jsx"</code>). The <code class="inlineCode">"strict": true</code> option enables a wide range of type-checking behavior to catch more issues.</p>
    <p class="normal">With TypeScript set up, let’s write some code. However, TypeScript uses different file extensions than JavaScript: <code class="inlineCode">*.ts</code> for files without JSX, and <code class="inlineCode">*.tsx</code> for files with JSX. So, let’s create our first React component using TypeScript:</p>
    <pre class="programlisting code"><code class="hljs-code">type <span class="hljs-title">AppProps</span> = {
  <span class="hljs-attr">message</span>: string;
};
<span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params">{ message }: AppProps</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>{message}<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>;
}
</code></pre>
    <p class="normal">In this example, we’re defining an <code class="inlineCode">AppProps</code> type for the props of the <code class="inlineCode">App</code> component. This tells TypeScript that the message prop should be a string.</p>
    <p class="normal">Now, let’s take a look at the figure of how <code class="inlineCode">main.tsx</code> looks like right now:</p>
    <figure class="mediaobject"><img src="../Images/B19636_06_01.png" alt="Picture 2"/></figure>
    <p class="packt_figref">Figure 6.1: App component in the main.tsx file with the error from TypeScript</p>
    <p class="normal">This is <a id="_idIndexMarker214"/>how TypeScript checks and validates props usage in components. Here, we should pass the <code class="inlineCode">message</code> prop:</p>
    <figure class="mediaobject"><img src="../Images/B19636_06_02.png" alt="Picture 3"/></figure>
    <p class="packt_figref">Figure 6.2: App component in the main.tsx file without errors</p>
    <p class="normal">Finally, you can run your project with the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">npm run dev
</code></pre>
    <p class="normal">This command starts the <strong class="keyWord">Vite development server</strong>. If there are any <strong class="keyWord">type errors</strong> in your code, TypeScript will show them in the console as well. </p>
    <h2 id="_idParaDest-106" class="heading-2">Basic types in TypeScript</h2>
    <p class="normal">One of the<a id="_idIndexMarker215"/> key features of TypeScript is its rich type system. TypeScript introduces several basic types that you can use to describe the shape of your data. To specify the type of a variable, you use a colon after the variable name, followed by the type.</p>
    <p class="normal">Let’s explore these basic types:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Boolean</strong>: The most<a id="_idIndexMarker216"/> basic datatype is the simple <code class="inlineCode">true</code>/<code class="inlineCode">false</code> value, which JavaScript and TypeScript call a Boolean:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> <span class="hljs-attr">isDone</span>: boolean = <span class="hljs-literal">false</span>;
</code></pre>
      </li>
      <li class="bulletList"><strong class="keyWord">Number</strong>: As<a id="_idIndexMarker217"/> in JavaScript, all numbers in TypeScript are floating point values. These floating point numbers get the type number:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> <span class="hljs-attr">age</span>: number = <span class="hljs-number">32</span>;
</code></pre>
      </li>
      <li class="bulletList"><strong class="keyWord">String</strong>: Another <a id="_idIndexMarker218"/>fundamental part of creating programs in JavaScript for web pages and servers alike is working with <strong class="keyWord">textual data</strong>. As in other languages, we use the type string to refer to these textual datatypes:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> <span class="hljs-attr">color</span>: string = "blue";
</code></pre>
      </li>
      <li class="bulletList"><strong class="keyWord">Array</strong>: TypeScript, like<a id="_idIndexMarker219"/> JavaScript, allows you to work <a id="_idIndexMarker220"/>with arrays of values. Array types can be written in one of two ways. In the first, you use the type of the elements followed by <code class="inlineCode">[]</code> to denote an array of that element type:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: number[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
</code></pre>
      
    <p class="normal"> The second way uses a generic array type, <code class="inlineCode">Array&lt;elemType&gt;</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-title">Array</span>&lt;number&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
</code></pre> </li>
    </ul>
    <ul>
      <li class="bulletList"><strong class="keyWord">Tuple</strong>: Tuple<a id="_idIndexMarker221"/> types allow you to express an array where the type of a fixed number of elements is known but does not need to be the same. For example, you may want to represent a value as a pair of a <code class="inlineCode">string</code> and a <code class="inlineCode">number</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: [string, number];
x = ["hello", <span class="hljs-number">10</span>]; <span class="hljs-comment">// OK </span>
</code></pre>
      </li>
      <li class="bulletList"><strong class="keyWord">Enum</strong>: A<a id="_idIndexMarker222"/> helpful addition to the standard set of datatypes from JavaScript is the <code class="inlineCode">enum</code>. As in languages like C#, an <code class="inlineCode">enum</code> is a way of giving more friendly names to sets of numeric values:
        <pre class="programlisting code"><code class="hljs-code">enum <span class="hljs-title">Color</span> {
  <span class="hljs-title">Red</span>,
  <span class="hljs-title">Green</span>,
  <span class="hljs-title">Blue</span>,
}
<span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: <span class="hljs-title">Color</span> = <span class="hljs-title">Color</span>.<span class="hljs-property">Green</span>;
</code></pre>
      </li>
      <li class="bulletList"><strong class="keyWord">Any</strong>: We may<a id="_idIndexMarker223"/> need to describe the type of variables that we do not know when we are writing an application. These values may come from dynamic content, for example, from the user or a third-party library. In these cases, we want to opt out of type-checking and let the values pass through compile-time checks. To do so, we label these with the <code class="inlineCode">any</code> type:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> <span class="hljs-attr">notSure</span>: any = <span class="hljs-number">4</span>;
notSure = "maybe a string instead";
notSure = <span class="hljs-literal">false</span>; <span class="hljs-comment">// okay, definitely a Boolean</span>
</code></pre>
      </li>
      <li class="bulletList"><strong class="keyWord">Unknown</strong>: The <code class="inlineCode">unknown</code> type <a id="_idIndexMarker224"/>is a type-safe counterpart of <code class="inlineCode">any</code>. Anything is assignable to <code class="inlineCode">unknown</code>, but <code class="inlineCode">unknown</code> isn’t assignable to anything but itself and <code class="inlineCode">any</code> without a type assertion or a control flow-based narrowing. Likewise, no operations are permitted on an <code class="inlineCode">unknown</code> without first asserting or narrowing to a more specific type:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> <span class="hljs-attr">notSure</span>: unknown = <span class="hljs-number">4</span>;
notSure = "maybe a string instead";
<span class="hljs-comment">// OK, because of structural typing</span>
notSure = <span class="hljs-literal">false</span>; 
<span class="hljs-keyword">let</span> <span class="hljs-attr">surelyNotAString</span>: string = notSure; <span class="hljs-comment">// Error, 'unknown' is not assignable to 'string'</span>
</code></pre>
     
    <p class="normal">In this<a id="_idIndexMarker225"/> example, we can’t assign <code class="inlineCode">notSure</code> to <code class="inlineCode">surelyNotAString</code> without a type-check, because <code class="inlineCode">notSure</code> is of the <code class="inlineCode">unknown</code> type. This helps prevent errors because we can’t inadvertently perform operations on variables of the <code class="inlineCode">unknown</code> type without first checking their types.</p>
    <p class="normal">A common use case for <code class="inlineCode">unknown</code> is in a <code class="inlineCode">catch</code> clause, where the type of the <code class="inlineCode">error</code> object is not known:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> {
  <span class="hljs-comment">// some operation that might throw</span>
} <span class="hljs-keyword">catch</span> (<span class="hljs-attr">error</span>: unknown) {
  <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> <span class="hljs-title">Error</span>) {
    <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(error.<span class="hljs-property">message</span>);
  }
}
</code></pre>
    <p class="normal">In this example, we<a id="_idIndexMarker226"/> don’t know what the <code class="inlineCode">error</code> type might be, so we give it the <code class="inlineCode">unknown</code> type. This forces us to check its type before we can interact with it.</p>  </li>
    </ul>
    <ul>
      <li class="bulletList"><strong class="keyWord">Void</strong>: <code class="inlineCode">void</code> is <a id="_idIndexMarker227"/>a little like the opposite of <code class="inlineCode">any</code>: the absence of having any type at all. You may commonly see this as the return type of functions that do not return a value:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span> <span class="hljs-title">warnUser</span>(): <span class="hljs-keyword">void</span> {
  <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>("<span class="hljs-title">This</span> is my warning message");
}
</code></pre>
      </li>
      <li class="bulletList"><strong class="keyWord">Null and undefined</strong>: In TypeScript, both <code class="inlineCode">undefined</code> and <code class="inlineCode">null</code> actually have their<a id="_idIndexMarker228"/> own<a id="_idIndexMarker229"/> types named <code class="inlineCode">undefined</code> and <code class="inlineCode">null</code> respectively. Much like <code class="inlineCode">void</code>, they’re not extremely useful on their own:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> <span class="hljs-attr">u</span>: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">n</span>: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
</code></pre>
      
    <p class="normal">However, <code class="inlineCode">undefined</code> plays a crucial role in optional types. In TypeScript, you can make a type optional by adding <code class="inlineCode">?</code> after the type name. This means the value can be of the specified type or <code class="inlineCode">undefined</code>. For example:</p> 
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name?: string</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello </span><span class="hljs-subst">${name}</span><span class="hljs-string">'</span>;
}
<span class="hljs-title">greet</span>("<span class="hljs-title">Mike</span>");
<span class="hljs-title">greet</span>(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// OK</span>
<span class="hljs-title">greet</span>(); <span class="hljs-comment">// Also OK</span>
</code></pre> </li>
    </ul>
    <ul>
      <li class="bulletList"><strong class="keyWord">Never:</strong> The <code class="inlineCode">never</code> type<a id="_idIndexMarker230"/> in TypeScript represents a type of value that never occurs. It’s used in situations where a function never returns a value or reaches the end of its execution path. For example, a function that throws an error or one that has an infinite loop can be annotated with<a id="_idIndexMarker231"/> the <code class="inlineCode">never</code> type:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span> <span class="hljs-title">throwError</span>(<span class="hljs-params">errorMsg: string</span>): never {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Error</span>(errorMsg);
}
<span class="hljs-keyword">function</span> <span class="hljs-title">infiniteLoop</span>(): never {
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    }
}
</code></pre>
      </li>
    </ul>
    <p class="normal">Understanding these basic types is a crucial first step in working with TypeScript. As you start to use TypeScript<a id="_idIndexMarker232"/> in your projects, you’ll find that these types are powerful tools for writing robust, maintainable code.</p>
    <p class="normal">In the next section, we’ll delve deeper into TypeScript’s type system and explore interfaces and type aliases, which provide a way to define complex types.</p>
    <h2 id="_idParaDest-107" class="heading-2">Interfaces and type aliases</h2>
    <p class="normal">While the basic types are useful for simple data types, when dealing with more complex data structures, we need more powerful tools. This is where interfaces and type aliases come in. They allow us to define complex types and give them a name.</p>
    <h3 id="_idParaDest-108" class="heading-3">Interfaces</h3>
    <p class="normal">An interface in<a id="_idIndexMarker233"/> TypeScript is a way of defining a contract for complex <a id="_idIndexMarker234"/>types. It describes the shape an object should have. Here’s an example:</p>
    <pre class="programlisting code"><code class="hljs-code">interface <span class="hljs-title">User</span> {
  <span class="hljs-attr">name</span>: string;
  <span class="hljs-attr">email</span>: string;
}
</code></pre>
    <p class="normal">In this example, we’ve defined a <code class="inlineCode">User</code> interface with two properties: <code class="inlineCode">name</code> and <code class="inlineCode">email</code>, both of which are strings. We can use this interface to type-check objects:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-attr">user</span>: <span class="hljs-title">User</span> = {
  <span class="hljs-attr">name</span>: "<span class="hljs-title">Alice</span>",
  <span class="hljs-attr">email</span>: "alice@example.<span class="hljs-property">com</span>",
};
</code></pre>
    <p class="normal">If we try to assign an object that doesn’t match the <code class="inlineCode">User</code> interface to the user variable, TypeScript will<a id="_idIndexMarker235"/> give us an error.</p>
    <h3 id="_idParaDest-109" class="heading-3">Type aliases</h3>
    <p class="normal">Type aliases <a id="_idIndexMarker236"/>are very similar to interfaces, but can be used for other<a id="_idIndexMarker237"/> types as well, not just objects. Here’s an example of a <code class="inlineCode">type</code> alias:</p>
    <pre class="programlisting code"><code class="hljs-code">type <span class="hljs-title">Point</span> = {
  <span class="hljs-attr">x</span>: number;
  <span class="hljs-attr">y</span>: number;
};
type <span class="hljs-variable">ID</span> = number | string;
</code></pre>
    <p class="normal">In this example, we’ve defined a <code class="inlineCode">Point</code> type that represents a point in a two-dimensional space and <code class="inlineCode">ID</code> that can be a string or number. We can use these <code class="inlineCode">type</code> aliases in the same way we use interfaces:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-attr">point</span>: <span class="hljs-title">Point</span> = {
  <span class="hljs-attr">x</span>: <span class="hljs-number">10</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-number">20</span>,
};
<span class="hljs-keyword">const</span> <span class="hljs-attr">id</span>: <span class="hljs-variable">ID</span> = <span class="hljs-number">100</span>;
</code></pre>
    <h3 id="_idParaDest-110" class="heading-3">Interfaces vs type aliases</h3>
    <p class="normal">So, when <a id="_idIndexMarker238"/>should you use an interface, and when should you use a type alias? In many cases, the two are interchangeable, and it’s mostly a matter of personal preference.</p>
    <p class="normal">However, there are some differences. Interfaces are more extensible because they can be declared multiple times, and they will be merged together. Type<strong class="keyWord"> </strong>aliases can’t be re-opened to add new properties. On the other hand, type aliases can represent other types like union types, intersection types, tuples, and any other types that aren’t currently available in an interface.</p>
    <p class="normal">In general, if you’re defining the shape of an object, either an interface or a type alias would work. If you’re defining a type that could be something other than an object, you’ll need to use a type alias.</p>
    <p class="normal">In this <a id="_idIndexMarker239"/>section, we’ve taken our first steps into the world of TypeScript. We’ve learned about its setup in a <strong class="keyWord">Vite</strong> project, its basic types, and how to define complex types using interfaces and type aliases.</p>
    <p class="normal">Now let’s explore how we can use TypeScript with React components, state, event handlers.</p>
    <h1 id="_idParaDest-111" class="heading-1">Using TypeScript in React</h1>
    <p class="normal">Alright, we’ve <a id="_idIndexMarker240"/>made it this far! We’ve learned about the basics of TypeScript and talked about its benefits. Now, it’s time to roll up our sleeves and get our hands dirty with some practical TypeScript in React.</p>
    <p class="normal">In this section, we’re going to explore how to use TypeScript to type-check all the different parts of a React application. We’ll look at components, props, state, event handlers, context, and even refs. Don’t worry: I’ll walk you through plenty of examples to help illustrate these concepts.</p>
    <h2 id="_idParaDest-112" class="heading-2">Type-checking props in React components</h2>
    <p class="normal">In a <a id="_idIndexMarker241"/>React application, one of the primary areas where we can leverage TypeScript is in our components, specifically with props. Let’s see the example:</p>
    <pre class="programlisting code"><code class="hljs-code">type <span class="hljs-title">GreetingProps</span> = {
  <span class="hljs-attr">name</span>: string;
};
<span class="hljs-keyword">const</span> <span class="hljs-title">Greeting</span> = (<span class="hljs-params">{ name }: GreetingProps</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>Hello, {name}!<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>;
};
</code></pre>
    <p class="normal">In this example, we’re defining a <code class="inlineCode">GreetingProps</code> type that specifies the shape of the props that <code class="inlineCode">Greeting</code> should receive. We’re then using this type to type-check the <code class="inlineCode">name</code> prop in the <code class="inlineCode">Greeting</code> component.</p>
    <p class="normal">This is a simple example with just one prop, but the same approach can be used for components with more complex props. For example, if a component receives an object or an array as a prop, we can define a type that describes the shape of that object or array. Here’s an example:</p>
    <pre class="programlisting code"><code class="hljs-code">type <span class="hljs-title">UserProps</span> = {
  <span class="hljs-attr">user</span>: {
    <span class="hljs-attr">name</span>: string;
    <span class="hljs-attr">email</span>: string;
  };
};
<span class="hljs-keyword">const</span> <span class="hljs-title">UserCard</span> = (<span class="hljs-params">{ user }: UserProps</span>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>{user.name}<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>{user.email}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  );
};
</code></pre>
    <p class="normal">In this<a id="_idIndexMarker242"/> example, the <code class="inlineCode">UserCard</code> component receives a user prop that is an object with name and email properties. We define a <code class="inlineCode">UserProps</code> type that describes the shape of this object and use it to type-check the user prop.</p>
    <p class="normal">Let’s consider another common scenario in <a id="_idIndexMarker243"/>React: <strong class="keyWord">optional props</strong>. Sometimes, a component has props that aren’t always required. In these cases, we can provide a default value for the prop, and mark it as optional in our type definition. Here’s an example:</p>
    <pre class="programlisting code"><code class="hljs-code">type <span class="hljs-title">ButtonProps</span> = {
  <span class="hljs-attr">children</span>: <span class="hljs-title">React</span>.<span class="hljs-property">ReactNode</span>;
  disabled?: boolean;
};
<span class="hljs-keyword">const</span> <span class="hljs-title">Button</span> = (<span class="hljs-params">{ children, disabled = </span><span class="hljs-literal">false</span><span class="hljs-params"> }: ButtonProps</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">disabled</span><span class="hljs-tag">=</span><span class="hljs-string">{disabled}</span><span class="hljs-tag">&gt;</span>{children}<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>;
};
</code></pre>
    <p class="normal">In the <code class="inlineCode">ButtonProps</code> type, we’re using <code class="inlineCode">React.ReactNode</code> for the children prop. This is a special type provided by React that can accept any kind of renderable content. This includes strings, numbers, JSX elements, arrays of these types, or even functions that return these types. By using <code class="inlineCode">React.ReactNode</code>, we’re saying that the <code class="inlineCode">children</code> prop can be any kind of content that React can render. Also, we’re using the <code class="inlineCode">disabled</code> prop, which is optional. We indicate that <code class="inlineCode">disabled</code> is optional by adding a <code class="inlineCode">?</code> after the prop name in the <code class="inlineCode">ButtonProps</code> type. We also provide a default value of false for disabled in the component function parameters.</p>
    <p class="normal">This way, we can <a id="_idIndexMarker244"/>use the <code class="inlineCode">Button</code> component with or without the <code class="inlineCode">disabled</code> prop, and TypeScript will still type-check it correctly:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">Button</span><span class="hljs-tag">&gt;</span>Click me!<span class="hljs-tag">&lt;/</span><span class="hljs-name">Button</span><span class="hljs-tag">&gt;</span> // OK
<span class="hljs-tag">&lt;</span><span class="hljs-name">Button</span><span class="hljs-tag"> </span><span class="hljs-attr">disabled</span><span class="hljs-tag">&gt;</span>Don't click me!<span class="hljs-tag">&lt;/</span><span class="hljs-name">Button</span><span class="hljs-tag">&gt;</span> // OK
</code></pre>
    <h2 id="_idParaDest-113" class="heading-2">Typing state</h2>
    <p class="normal">Just as we<a id="_idIndexMarker245"/> type-checked our props, we can also use TypeScript to type-check the state in our components. This ensures that we’re always using the correct types of state values, providing another layer of safety to our code.</p>
    <p class="normal">Let’s look at an example of how we can apply TypeScript to state in a functional component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">Counter</span> = () =&gt; {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title">React</span>.<span class="hljs-property">useState</span>&lt;number&gt;(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Count: {count}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span>
<span class="hljs-tag">        </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{()</span><span class="hljs-tag"> =&gt;</span> {
          setCount(count + 1);
        }}
      &gt;
        Increment
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  );
};
</code></pre>
    <p class="normal">In this <code class="inlineCode">Counter</code> component, we’re using <code class="inlineCode">React.useState&lt;number&gt;(0)</code> to declare a state variable <code class="inlineCode">count</code> with an initial value of <code class="inlineCode">0</code>. By providing <code class="inlineCode">&lt;number&gt;</code> as a type argument to <code class="inlineCode">useState</code>, we’re telling TypeScript that <code class="inlineCode">count</code> should always be a number. By the way: we can omit passing <code class="inlineCode">&lt;number&gt;</code> because TypeScript is smart enough to infer that <code class="inlineCode">count</code> should be a number based on the initial value type.</p>
    <p class="normal">This also means that the <code class="inlineCode">setCount</code> function will only accept numbers. If we try to call <code class="inlineCode">setCount</code> with a non-number argument, TypeScript will give us an error.</p>
    <h2 id="_idParaDest-114" class="heading-2">Typing event handlers</h2>
    <p class="normal">Another<a id="_idIndexMarker246"/> area where TypeScript can be very useful in a React application is<a id="_idIndexMarker247"/> in <strong class="keyWord">event handlers</strong>. By type-checking our event handlers, we can ensure that we’re using the correct event types and accessing the right properties on the event objects.</p>
    <p class="normal">Let’s look at an example of a functional component with an input field and a typed event handler:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">InputField</span> = () =&gt; {
  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title">React</span>.<span class="hljs-title">useState</span>("");
  <span class="hljs-keyword">const</span> <span class="hljs-title">handleChange</span> = (<span class="hljs-params">event: React.ChangeEvent&lt;HTMLInputElement&gt;</span>) =&gt; {
    <span class="hljs-title">setValue</span>(event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);
  };
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span><span class="hljs-tag"> </span><span class="hljs-attr">value</span><span class="hljs-tag">=</span><span class="hljs-string">{value}</span><span class="hljs-tag"> </span><span class="hljs-attr">onChange</span><span class="hljs-tag">=</span><span class="hljs-string">{handleChange}</span><span class="hljs-tag"> /&gt;</span>;
};
</code></pre>
    <p class="normal">In this <code class="inlineCode">InputField</code> component, we’re defining a <code class="inlineCode">handleChange</code> function that will be called whenever the input field’s value changes. We’re using the <code class="inlineCode">React.ChangeEvent&lt;HTMLInputElement&gt;</code> type for the event parameter to specify that this function should receive a change event from an input field.</p>
    <p class="normal">This type includes all the properties we would expect from a change event on an input field, such as <code class="inlineCode">event.target.value</code>. If we try to access a property that doesn’t exist on this type of event, TypeScript will give us an error.</p>
    <h2 id="_idParaDest-115" class="heading-2">Typing context</h2>
    <p class="normal">When <a id="_idIndexMarker248"/>using TypeScript with React, we can also type-check our context to ensure that we’re always using the correct types of values. Let’s look at an example:</p>
    <pre class="programlisting code"><code class="hljs-code">type <span class="hljs-title">ThemeContextType</span> = {
  <span class="hljs-attr">theme</span>: string;
  <span class="hljs-attr">setTheme</span>: <span class="hljs-function">(</span><span class="hljs-params">theme: string</span><span class="hljs-function">) =&gt;</span> <span class="hljs-keyword">void</span>;
};
<span class="hljs-keyword">const</span> <span class="hljs-title">ThemeContext</span> = <span class="hljs-title">React</span>.<span class="hljs-property">createContext</span>&lt;<span class="hljs-title">ThemeContextType</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title">ThemeProvider</span> = (<span class="hljs-params">{ children }: { children: React.ReactNode }</span>) =&gt; {
  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title">React</span>.<span class="hljs-title">useState</span>('light');
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">ThemeContext.Provider</span><span class="hljs-tag"> </span><span class="hljs-attr">value</span><span class="hljs-tag">=</span><span class="hljs-string">{{</span><span class="hljs-tag"> </span><span class="hljs-attr">theme</span><span class="hljs-tag">, </span><span class="hljs-attr">setTheme</span><span class="hljs-tag"> }}&gt;</span>
      {children}
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">ThemeContext.Provider</span><span class="hljs-tag">&gt;</span>
  );
};
<span class="hljs-keyword">const</span> <span class="hljs-title">useTheme</span> = () =&gt; {
  <span class="hljs-keyword">const</span> context = <span class="hljs-title">React</span>.<span class="hljs-title">useContext</span>(<span class="hljs-title">ThemeContext</span>);
  <span class="hljs-keyword">if</span> (context === <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Error</span>('useTheme must be used within a <span class="hljs-title">ThemeProvider</span>');
  }
  <span class="hljs-keyword">return</span> context;
};
</code></pre>
    <p class="normal">In this <a id="_idIndexMarker249"/>example, we’re creating a <code class="inlineCode">ThemeContext</code> with <code class="inlineCode">React.createContext</code>. We’re providing a <code class="inlineCode">ThemeContextType</code> as a type argument to <code class="inlineCode">createContext</code> to specify the shape of the context value. This type includes a theme string and a <code class="inlineCode">setTheme</code> function.</p>
    <p class="normal">We’re then creating a <code class="inlineCode">ThemeProvider</code> component that provides the theme and <code class="inlineCode">setTheme</code> values to the context. Inside the <code class="inlineCode">useTheme</code> hook, we’re using <code class="inlineCode">React.useContext</code> to consume the <code class="inlineCode">ThemeContext</code>. If the context is <code class="inlineCode">null</code>, we throw an error. </p>
    <p class="normal">This is a common pattern to ensure that the context is used within a provider.</p>
    <p class="normal">With this example, I want to highlight an important TypeScript feature. In the <code class="inlineCode">useTheme</code> hook, we don’t specify the type. It returns the context value, which TypeScript knows is of the <code class="inlineCode">ThemeContextType</code> type and not <code class="inlineCode">null</code>, thanks to the error check. This means that when we use <code class="inlineCode">useTheme</code>, TypeScript will automatically provide the correct, non-null context type.</p>
    <h2 id="_idParaDest-116" class="heading-2">Typing refs</h2>
    <p class="normal">Now, let’s <a id="_idIndexMarker250"/>turn our attention to another powerful feature in React: refs. As you already know from <em class="chapterRef">Chapter 3</em>, <em class="italic">Understanding React Components and Hooks</em>, refs give us a way to<a id="_idIndexMarker251"/> access <strong class="keyWord">DOM nodes</strong> or <strong class="keyWord">React elements</strong> directly<a id="_idIndexMarker252"/> within our components. But how do we ensure we’re using refs correctly? TypeScript coming to the rescue.</p>
    <p class="normal">Consider this example where we apply TypeScript to refs:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">InputWithRef</span> = () =&gt; {
  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title">React</span>.<span class="hljs-property">useRef</span>&lt;<span class="hljs-title">HTMLInputElement</span>&gt;(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> <span class="hljs-title">focusInput</span> = () =&gt; {
    <span class="hljs-keyword">if</span> (inputRef.<span class="hljs-property">current</span>) {
      inputRef.<span class="hljs-property">current</span>.<span class="hljs-title">focus</span>();
    }
  };
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span><span class="hljs-tag"> </span><span class="hljs-attr">ref</span><span class="hljs-tag">=</span><span class="hljs-string">{inputRef}</span><span class="hljs-tag"> </span><span class="hljs-attr">type</span><span class="hljs-tag">=</span><span class="hljs-string">"text"</span><span class="hljs-tag"> /&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{focusInput}</span><span class="hljs-tag">&gt;</span>Focus the input<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  );
};
</code></pre>
    <p class="normal">In this <code class="inlineCode">InputField</code> component, we’re creating a ref with <code class="inlineCode">React.useRef</code>. We’re providing <code class="inlineCode">HTMLInputElement</code> as a type argument to <code class="inlineCode">useRef</code> to specify the type of the ref. <code class="inlineCode">HTMLInputElement</code> is a type provided by TypeScript’s built-in DOM typings, and it represents an input element in the DOM. This type corresponds to the type of the DOM element that the ref is attached to.</p>
    <p class="normal">This means that <code class="inlineCode">inputRef.current</code> will be of the <code class="inlineCode">HTMLInputElement | null</code> type, and TypeScript will know that it has a <code class="inlineCode">focus</code> method.</p>
    <h1 id="_idParaDest-117" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we delved into the world of type-checking and validation in React. We started with the importance of props validation, then introduced TypeScript and its benefits for robust type-checking. </p>
    <p class="normal">We then applied TypeScript to React, demonstrating its use in type-checking various aspects of React components, from props and state to event handlers, context, and refs. All of it allows you to create applications that are not only more dependable but also easier to maintain, allowing for early detection of errors and significantly improving both the quality of your code and your efficiency as a developer.</p>
    <p class="normal">As we move to the next chapter, <em class="italic">Handling Navigation with Routes</em>, we’ll shift our focus to navigation in React applications. We’ll learn how to set up and use routes to navigate between different parts of our application.</p>
  </div>
</body></html>