<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Putting Things to the Test"><div class="titlepage" id="aid-22O7C2"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Putting Things to the Test</h1></div></div></div><p>Writing tests is crucial for the maintainability of your code. It's a known fact that having a good range of tests that cover most of your functionality is equally important as the functionality itself.</p><p>The first thing that comes to mind when thinking about tests is probably code quality assurance. You test the code that you write, so this is definitely true. However, there are many other important aspects of writing tests:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Resistance to unexpected change</strong></span>: Your tests define what your code is supposed to do. They test whether your code conforms to your specifications. This has several benefits, where the most obvious is probably a resistance to unexpected change in the future. If you modify the code in the future, you'll less likely break your existing code because your tests will validate whether the existing functionality still works as specified.</li><li class="listitem"><span class="strong"><strong>Documentation</strong></span>: Your tests define what your code should do. At the same time, they display the API calls that are required to use the concerned functionality. This is the perfect documentation for any developer. Whenever I want to understand how a library really works, the tests are the first thing that I look at.</li><li class="listitem"><span class="strong"><strong>Avoiding unnecessary code</strong></span>: The practice of writing tests forces you to limit your code to fulfil the requirements of your specification and nothing more. Any code in your application that is not reached in your automated tests can be considered dead code. If you stick to a merciless refactoring approach, you'd then remove such unused code ASAP.</li></ul></div><p>So far, we haven't considered testing in our book at all, and given its importance, you may wonder why I come up with this now in the last chapter. In a real project, we'd definitely create tests much earlier if not at first. However, I hope you understand that in this book, we postponed this rather important topic until the end. I really love testing, but as we're mainly focused on the component architecture of Angular, placing this chapter at the end seemed more logical.</p><p>In this chapter, we'll look into how to perform proper unit testing on your components. We'll focus on unit testing; automated end-to-end testing is beyond the scope of this book. Still, we'll look into how to test user interaction on components, although not on the level it would be done in end-to-end testing.</p><p>In this chapter, we will delve into the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">An introduction to the Jasmine testing framework</li><li class="listitem">Writing simple JavaScript tests for components</li><li class="listitem">Creating a <code class="literal">tests.html</code> file, which serves as an in-browser test runner</li><li class="listitem">Creating Jasmine spies and observing component output properties</li><li class="listitem">Learning about Angular testing utilities, such as <code class="literal">inject</code>, <code class="literal">async</code>, <code class="literal">TestComponentBuilder</code>, <code class="literal">DebugElement</code>, and more</li><li class="listitem">Mocking components</li><li class="listitem">Mocking existing services</li><li class="listitem">Creating tests for our <code class="literal">AutoComplete</code> UI component</li><li class="listitem">Creating tests for our plugin system</li></ul></div><div class="section" title="An introduction to Jasmine"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec64"/>An introduction to Jasmine</h1></div></div></div><p>Jasmine is a very <a id="id493" class="indexterm"/>simple testing framework, which comes with an API that allows <a id="id494" class="indexterm"/>you to write <span class="strong"><strong>Behavior-driven Development</strong></span> (<span class="strong"><strong>BDD</strong></span>) style tests. BDD is an agile software development process of defining specifications in a written format.</p><p>In BDD, we define that an agile user story consists of multiple scenarios. These scenarios closely relate to or even replace the acceptance criteria of a story. They define requirements on a higher level, and they are mostly written narrative. Each scenario then consists of three parts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Given</strong></span>: This part is used to describe the initial state of the scenario. The test code is where we perform all the setup that is needed to execute the test scenario.</li><li class="listitem"><span class="strong"><strong>When</strong></span>: This part reflects the changes that we perform to the system under test. Usually, this part consists of some API calls and actions that reflect the behavior of a user of the system.</li><li class="listitem"><span class="strong"><strong>Then</strong></span>: This part specifies what the system should look like after the given state and the changes applied in the <span class="emphasis"><em>when</em></span> part. In our code, this is the part that is usually at the end of our tests function, where we use assertion libraries to verify the state of the system.</li><li class="listitem">Jasmine comes with an API that makes it very easy to write tests which structure according to the BDD style. Let's look at a very simple example of how we use Jasmine to write a test for a shopping cart system:<div class="informalexample"><pre class="programlisting">describe('Buying items in the shop', () =&gt; {
  it('should increase the basket count', () =&gt; {
    // Given
    const shop = new Shop();
    // When
    shop.buy('Toothpaste');
    shop.buy('Shampoo');
    // Then
    expect(shop.basket.length).toBe(2);
    expect(shop.basket).toContain('Toothpaste');
    expect(shop.basket).toContain('Shampoo');
  });
});</pre></div></li></ul></div><p>Jasmine provides us with a <a id="id495" class="indexterm"/>
<code class="literal">describe</code> function, which allows us to group certain scenarios on the same subject. In this example, we used the <code class="literal">describe</code> function to register a new test suite for tests about buying items in a shop.</p><p>Using the <code class="literal">it</code> function, we can register individual scenarios, which we'd like to get tested. In the <code class="literal">describe</code> callback function, we can register as many scenarios using the <code class="literal">it</code> function as we like.</p><p>Inside the callback function of the Jasmine <code class="literal">it</code> function, we can start writing our test. We use a <code class="literal">BDD</code> style to structure the code inside our test.</p><p>You don't necessarily need to run Jasmine in the browser, but if you do this, you'll get a nice summary report of all tests and their state:</p><div class="mediaobject"><img src="../Images/image00355.jpeg" alt="An introduction to Jasmine"/><div class="caption"><p>Jasmine provides a nice visual report over all your test specifications, which also allows you to rerun individual tests and provides you with more options</p></div></div><p style="clear:both; height: 1em;"> </p><p>Jasmine comes in three parts that are relevant to us:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Jasmine core</strong></span>: This <a id="id496" class="indexterm"/>contains the test definition APIs, the assertion library, and all the other core parts of the testing framework</li><li class="listitem"><span class="strong"><strong>Jasmine HTML</strong></span>: This <a id="id497" class="indexterm"/>is the HTML reporter, which will write all tests results to the browser document and even provide options to rerun individual tests</li><li class="listitem"><span class="strong"><strong>Jasmine boot</strong></span>: This <a id="id498" class="indexterm"/>is the file that bootstraps the Jasmine framework for the browser and performs any setup that is needed with the HTML reporter</li></ul></div><p>In our project, we will use Jasmine and the preceding parts directly from a CDN, so we don't need to install anything to get started. We create a new <code class="literal">tests.html</code> file, which will serve as a runner for our tests. In conjunction with <code class="literal">live-server</code>, we can always have this page open in our browser. This way we'll get immediate feedback on our tests while developing.</p><div class="note" title="Note"><h3 class="title"><a id="tip18"/>Tip</h3><p>Jasmine also plays nice with test runners such as Karma to run your tests. Karma is a popular test runner, which allows you to run your tests in parallel using the Karma CLI or integrate it in your build pipeline. This also allows you to run tests in different browsers. In this chapter, we will use the Jasmine HTML and Jasmine boot to run our tests directly in the browser. This allows us to skip the rather complex setup that we'd need to undertake if we used Karma as our test runner.</p></div><p>Let's look at the code of the <code class="literal">tests.html</code> file that we create in the root folder of our application, right next to the <code class="literal">index.html</code> file, which is already present:</p><div class="informalexample"><pre class="programlisting">...
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/es6-shim/0.35.0/es6-shim.min.js"&gt;&lt;/script&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/2.0.0-beta.17/angular2-polyfills.js"&gt;&lt;/script&gt;
&lt;script src="jspm_packages/system.js"&gt;&lt;/script&gt;
&lt;script src="config.js"&gt;&lt;/script&gt;
&lt;script src="<span class="strong"><strong>https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.4.1/jasmine.js</strong></span>"&gt;&lt;/script&gt;
&lt;script src="<span class="strong"><strong>https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.4.1/jasmine-html.js</strong></span>"&gt;&lt;/script&gt;
&lt;script src="<span class="strong"><strong>https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.4.1/boot.js</strong></span>"&gt;&lt;/script&gt;</pre></div><p>Besides loading the usual suspects for our Angular application (ES6 shim, Angular polyfills, and SystemJS), we now also load the three main components of Jasmine.</p><p>By default, Jasmine executes all registered tests on the window's <code class="literal">load</code> event. However, as we will load our tests <a id="id499" class="indexterm"/>using SystemJS, we need to defer the bootstrap of Jasmine until SystemJS has completely loaded our tests:</p><div class="informalexample"><pre class="programlisting">&lt;script&gt;
<span class="strong"><strong>  window._jasmineOnLoad = window.onload;</strong></span>
<span class="strong"><strong>  window.onload = null;</strong></span>
<span class="strong"><strong>    return System.import('./all.spec')</strong></span>
<span class="strong"><strong>    .then(window._jasmineOnLoad)</strong></span>
<span class="strong"><strong>    .catch(console.error.bind(console));</strong></span>
  ...
&lt;/script&gt;</pre></div><p>We first put aside the function that was registered by Jasmine boot on <code class="literal">window.onload</code>. We store the function in a temporary <code class="literal">_jasmineOnLoad</code> global variable.</p><p>Now, we use SystemJS to import our entry point module for our tests, which will be stored in the <code class="literal">all.spec.js</code> file. SystemJS returns a <code class="literal">Promise</code> that will be resolved if the test module has been loaded and executed successfully. We can use the <code class="literal">then</code> function of the returned <code class="literal">Promise</code> to execute the Jasmine boot function stored in <code class="literal">window._jasmineOnLoad</code>. In this way, we make sure that Jasmine is booted after all our tests have been registered.</p></div></div>
<div class="section" title="Writing our first test" id="aid-23MNU1"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec65"/>Writing our first test</h1></div></div></div><p>Now that we are all <a id="id500" class="indexterm"/>set with the Jasmine setup, we can start writing our first test. In this section, we will create a first test for the <code class="literal">AutoComplete</code> component that we created in <a class="link" title="Chapter 8. Time Will Tell" href="part0054.xhtml#aid-1JFUC2">Chapter 8</a>, <span class="emphasis"><em>Time Will Tell</em></span>, of this book.</p><p>As Angular components are just classes, we can already test a lot of the functionality by instantiating the <code class="literal">Component</code> class and testing its methods. Tests that can be performed like this should always be considered first. These tests can run without Angular bootstrapping the component.</p><p>The <code class="literal">AutoComplete</code> component filters displayed results based on the available items and a filter criteria. In the following test, we'll verify that the <code class="literal">filter</code> method on the component works as expected.</p><div class="note" title="Note"><h3 class="title"><a id="tip19"/>Tip</h3><p>In this book, we follow the practice to store test files by appending a <code class="literal">.spec.js</code> file to the name of the file that has to be tested. We'll also store these test files in the same folder of the subject. This makes it much easier to keep the context.</p></div><p>We'll create a new <code class="literal">auto-complete.spec.js</code> file in the folder of the <code class="literal">AutoComplete</code> component at <code class="literal">lib/ui/auto-complete</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import {describe, expect, it,} from '@angular/core/testing';</strong></span>
<span class="strong"><strong>import {AutoComplete} from './auto-complete';</strong></span>

<span class="strong"><strong>describe('AutoComplete', () =&gt; {</strong></span>
<span class="strong"><strong>  it('should filter items correctly', () =&gt; {</strong></span>
<span class="strong"><strong>    // Given</strong></span>
    const autoComplete = new AutoComplete();
    autoComplete.items = ['One', 'two', 'three'];
<span class="strong"><strong>    // When</strong></span>
    autoComplete.filterItems('o');
<span class="strong"><strong>    // Then</strong></span>
    expect(autoComplete.filteredItems).toEqual(['One', 'two']);
<span class="strong"><strong>  });</strong></span>
<span class="strong"><strong>});</strong></span>
</pre></div><p>As we loaded Jasmine <a id="id501" class="indexterm"/>prior to executing our test, we could rely on the global <code class="literal">describe</code>, <code class="literal">it</code>, and <code class="literal">expect</code> functions that are exposed by Jasmine. However, Angular provides us with some nice wrappers of the Jasmine functions, which we can import from the module located in <code class="literal">@angular/core/testing</code>.</p><p>As you can see, we don't really need to activate the <code class="literal">AutoComplete</code> component in order to test some of its functionality. By simply testing the component class, we can already execute some of our executable specifications.</p><p>We follow a BDD approach to structure our test, and in the <code class="literal">Given</code> section, we instantiate a new <code class="literal">AutoComplete</code> component class, and then we initialize the items list with some test items. Even if the items field is actually a component input, we can simply disregard this fact in order to test the filtering functionality.</p><p>In the <code class="literal">When</code> section of our test, we actually call the <code class="literal">filterItems</code> method of the component class and test whether it does filter the items according to the specification.</p><p>In the <code class="literal">Then</code> section, we use the <code class="literal">expect</code> function of Jasmine in order to assert the expected state after the <code class="literal">When</code> section. As the component should filter all items with partial and case-insensitive matches of the filter criteria, the expected value in <code class="literal">filteredItems</code> should be an array with the <code class="literal">One</code> and <code class="literal">two</code> items.</p><p>We use the assertion <code class="literal">toEqual</code> function in order to perform a deep equal check. If we use the <code class="literal">toBe</code> matcher, we'd compare the references of the two arrays, which will result in a negative match.</p><p>This is it for our first test. What's left to do still is to create our main test module that is loaded in the <code class="literal">tests.html</code> file.</p><p>We created the main entry point for all our tests in a <code class="literal">all.spec.js</code> file on the root path of our application. This file will then include all specification files that we create in our application:</p><div class="informalexample"><pre class="programlisting">import './lib/ui/auto-complete/auto-complete.spec';</pre></div><p>This is currently all that <a id="id502" class="indexterm"/>we need to make our test run. We simply import the test file that we just created. Now, <code class="literal">tests.html</code> will use SystemJS to load our <code class="literal">all.spec.js</code> file, and here, we then load the <code class="literal">auto-complete-spec.js</code> file.</p><p>We can now start <code class="literal">live-server</code> in the root path of our application and navigate to <code class="literal">http://127.0</code>
<code class="literal">.0.1:8080/tests.html</code> in our browser. As <code class="literal">live-server</code> will reload our browser on changes, we can start adding new tests while we constantly get updates on our test state in the browser.</p></div>
<div class="section" title="Spying on component outputs"><div class="titlepage" id="aid-24L8G2"><div><div><h1 class="title"><a id="ch11lvl1sec66"/>Spying on component outputs</h1></div></div></div><p>A common practice in <a id="id503" class="indexterm"/>testing is to use spy function calls during the execution of tests and then evaluate these calls, checking whether all functions have been called correctly.</p><p>Jasmine provides us with some nice helpers in order to use spy function calls. We can use the <code class="literal">spyOn</code> function of Jasmine in order to replace the original function with a spy function. The spy function will record any calls, and we can later on evaluate how many times it was called and with what parameters.</p><p>Let's look at a simple example of how to use the <code class="literal">spyOn</code> function:</p><div class="informalexample"><pre class="programlisting">class Calculator {
  multiply(a, b) {
    return a * b;
  }
  
  pythagorean(a, b) {
    return Math.sqrt(this.multiply(a, a) + this.multiply(b, b));
  }
}</pre></div><p>We will test a simple <code class="literal">Calculator</code> class that has two methods. The <code class="literal">multiply</code> method simply multiplies two numbers and returns the result. The <code class="literal">pythagorean</code> method calculates the hypotenuse of a right-angled triangle with two sides, <code class="literal">a</code> and <code class="literal">b</code>.</p><p>You might remember the formula for the Pythagorean theorem from your early school days:</p><div class="informalexample"><pre class="programlisting">a² + b² = c²</pre></div><p>We will use this formula to produce <code class="literal">c</code> from <code class="literal">a</code> and <code class="literal">b</code> by getting the square root of the result of <code class="literal">a*a + b*b</code>. For the multiplications, we'll use our <code class="literal">multiply</code> method instead of using arithmetic operators directly.</p><p>Now, we'd want to test our <a id="id504" class="indexterm"/>calculator <code class="literal">pythagorean</code> method, and as it uses the <code class="literal">multiply</code> method to multiply <code class="literal">a</code> and <code class="literal">b</code>, we can spy on this method to verify our test result in depth:</p><div class="informalexample"><pre class="programlisting">describe('Calculator pythagorean function', () =&gt; {
  it('should call multiply function correctly', () =&gt; {
    // Given
    const calc = new Calculator();
<span class="strong"><strong>    spyOn(calc, 'multiply').and.callThrough();</strong></span>
    // When
    const result = calc.pythagorean(6, 8);
    // Then
    expect(result).toBe(10);
<span class="strong"><strong>    expect(calc.mul).toHaveBeenCalled();</strong></span>
<span class="strong"><strong>    expect(calc.mul.calls.count()).toBe(2);</strong></span>
<span class="strong"><strong>    expect(calc.mul.calls.argsFor(0)).toEqual([6, 6]);</strong></span>
<span class="strong"><strong>    expect(calc.mul.calls.argsFor(1)).toEqual([8, 8]);</strong></span>
  });
});</pre></div><p>The <code class="literal">spyOn</code> function of Jasmine takes an object as first parameter and the function name on the object which we'd like to spy on.</p><p>This will effectively replace the original <code class="literal">multiply</code> function on our class instance with a new spy function of Jasmine. By default, spy functions will only record function calls, and they won't delegate the call further to the original function. We can use the <code class="literal">.and.callThrough()</code> function to specify that we'd like Jasmine to call the original function. This way our spy function will act as a proxy and record any calls at the same time.</p><p>In the <code class="literal">Then</code> section of our test, we can then inspect the spy function. Using the <code class="literal">toHaveBeenCalled</code> matcher, we can check whether the spy function was called after all.</p><p>Using the <code class="literal">calls</code> property of the spy function, we can inspect in more detail and verify the call count as well as the arguments that individual calls received.</p><p>Using the knowledge that we gained about Jasmine spies, we can now apply that to our component tests. As we know that all output properties of components contain an <code class="literal">EventEmitter</code>, we can actually spy on them to check whether our component sends output.</p><p>Inside components, we call the <code class="literal">next</code> method on <code class="literal">EventEmitter</code> in order to send output to parent component bindings. As this is an asynchronous operation and we'd also like to test our components without needing to involve parent components, we can simply spy on the <code class="literal">next</code> method of our output properties.</p><p>In the next two tests for our <code class="literal">AutoComplete</code> component, we'd like to verify the functionality when we save <a id="id505" class="indexterm"/>an edit in the <code class="literal">Editor</code> child component. Let's quickly recap on this behavior:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">On saved edits, we get the <code class="literal">onEditSaved</code> method on the <code class="literal">AutoComplete</code> component that is called</li><li class="listitem">If the saved value is an empty string, the <code class="literal">AutoComplete</code> component should emit a <code class="literal">selectedItemChange</code> event with a <code class="literal">null</code> value</li><li class="listitem">If the saved value is no empty string and the value is not present in the items of the <code class="literal">AutoComplete</code> component, an <code class="literal">itemCreated</code> event should be emitted</li></ul></div><p>Let's create the tests for the previous expected behavior to the already existing <code class="literal">lib/ui/auto-complete/auto-complete.spec.js</code> test file:</p><div class="informalexample"><pre class="programlisting">  ...
  it('should emit selectedItemChange event with null on empty content being saved', () =&gt; {
    // Given
    const autoComplete = new AutoComplete();
    autoComplete.items = ['one', 'two', 'three'];
    autoComplete.selectedItem = 'three';
<span class="strong"><strong>    spyOn(autoComplete.selectedItemChange, 'next');</strong></span>
<span class="strong"><strong>    spyOn(autoComplete.itemCreated, 'next');</strong></span>

    // When
<span class="strong"><strong>    autoComplete.onEditSaved('');</strong></span>

    // Then
<span class="strong"><strong>    expect(autoComplete.selectedItemChange.next).toHaveBeenCalledWith(null);</strong></span>
<span class="strong"><strong>    expect(autoComplete.itemCreated.next).not.toHaveBeenCalled();</strong></span>
  });</pre></div><p>We create two Jasmine spies here. The first one spies on the <code class="literal">selectedItemChange</code> output property, while the second one spies on the <code class="literal">itemCreated</code> output property.</p><p>After simulation, the editor was saved with an empty string. We can start verifying our spies in the <code class="literal">Then</code> section of our test.</p><p>The <code class="literal">next</code> function of the <code class="literal">selectedItemChange</code> event, <code class="literal">EventEmitter</code>, should have been called with a <code class="literal">null</code> value, while <code class="literal">next</code> of <code class="literal">itemCreated</code> shouldn't have been called at all. We can use the <code class="literal">not</code> property on the returned expectation object to invert the matcher.</p><p>Let's add a second test for the behavior when an editor was saved with a value that does not yet exist in the <a id="id506" class="indexterm"/>
<code class="literal">AutoComplete</code> component:</p><div class="informalexample"><pre class="programlisting">  it('should emit an itemCreated event on content being saved which does not match an existing item', () =&gt; {
    // Given
    const autoComplete = new AutoComplete();
    <span class="strong"><strong>autoComplete.items = ['one', 'two', 'three'];</strong></span>
    autoComplete.selectedItem = 'three';
<span class="strong"><strong>    spyOn(autoComplete.selectedItemChange, 'next');</strong></span>
<span class="strong"><strong>    spyOn(autoComplete.itemCreated, 'next');</strong></span>

    // When
<span class="strong"><strong>    autoComplete.onEditSaved('four');</strong></span>

    // Then
<span class="strong"><strong>    expect(autoComplete.selectedItemChange.next).not.toHaveBeenCalled();</strong></span>
<span class="strong"><strong>    expect(autoComplete.itemCreated.next).toHaveBeenCalledWith('four');</strong></span>
  });</pre></div><p>This time, we simulate a saved edit with a value, which isn't an empty string and does not exist in the autocomplete items already.</p><p>In the <code class="literal">Then</code> section of our code, we evaluate the spies and expect that the <code class="literal">itemCreated.next</code> function was called with a <code class="literal">four</code> string.</p><p>Using Jasmine spies, we managed to test our component output successfully without the need to bootstrap Angular. We performed these tests solely on the component class and by creating spies on the <code class="literal">EventEmitter</code> that is present on all output properties.</p></div>
<div class="section" title="Utilities to test components"><div class="titlepage" id="aid-25JP22"><div><div><h1 class="title"><a id="ch11lvl1sec67"/>Utilities to test components</h1></div></div></div><p>So far, we <a id="id507" class="indexterm"/>tested our components with plain vanilla JavaScript. The fact that components are in just regular classes make this possible. However, this can only be done for very simple use-cases. As soon as we'd like to test components for things that involve template compilation, user interaction on components, change detection, or dependency injection, we'll need to get a little help from Angular to perform our tests.</p><p>Angular comes with a whole bunch of testing tools that help us out here. In fact, the platform-agnostic way that Angular is built allows us to exchange the regular view adapter with a debug view adapter. This enables us to render components in such a way that allows us to inspect them in great detail.</p><p>To enable the debugging capabilities of Angular while rendering components, we need to modify our main entry point for our tests first.</p><p>Let's open up <code class="literal">all.spec.js</code> to make the necessary modifications:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import {setBaseTestProviders} from '@angular/core/testing';</strong></span>
<span class="strong"><strong>import {TEST_BROWSER_DYNAMIC_PLATFORM_PROVIDERS, TEST_BROWSER_DYNAMIC_APPLICATION_PROVIDERS} from '@angular/platform-browser-dynamic/testing';</strong></span>

<span class="strong"><strong>setBaseTestProviders(TEST_BROWSER_PLATFORM_PROVIDERS, TEST_BROWSER_APPLICATION_PROVIDERS);</strong></span>

import './lib/ui/auto-complete/auto-complete.spec';
import './lib/plugin/plugin.spec';</pre></div><p>Using the <code class="literal">setBaseTestProviders</code> function of the <code class="literal">@angular/core/testing</code> module, we can actually initialize <a id="id508" class="indexterm"/>a test platform injector, which will then be used in the context of our Angular testing. This function takes two arguments where the first one is an array of platform providers, and the second one is an array of application providers.</p><p>From the <code class="literal">@angular/platform-browser-dynamic/testing</code> module, we can import two constants that contain an already prepared list for both platform and application-level dependencies. Here are some of the providers present in these constants:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Platform-level providers</strong></span>: These consist mostly of platform initialization providers to <a id="id509" class="indexterm"/>debug</li><li class="listitem"><span class="strong"><strong>Application-level providers</strong></span>: These consist of the following:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">DebugDomRootRenderer</code>: This overrides the default <code class="literal">DomRenderer</code> in the browser and enables debugging of elements using <code class="literal">DebugElement</code> and probing</li><li class="listitem"><code class="literal">MockDirectiveResolver</code>: This overrides the default <code class="literal">DirectiveResolver</code> and allows overriding of directive metadata for testing purposes</li><li class="listitem"><code class="literal">MockViewResolver</code>: This overrides the default <code class="literal">ViewResolver</code> and allows overriding of component view specific metadata</li></ul></div></li></ul></div><p>Using the <code class="literal">setBaseTestProviders</code> function and the imported constants with the debugging providers, we can now initialize our test environment. After calling this function and passing our providers, Angular is set up for testing.</p><div class="section" title="Injecting in tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec77"/>Injecting in tests</h2></div></div></div><p>Injecting Angular <a id="id510" class="indexterm"/>dependencies in tests is made easy by two helper functions that we can use. The <code class="literal">inject</code> and <code class="literal">async</code> functions are available through the <code class="literal">@angular/core/testing</code> package, and they help us inject dependencies in our tests.</p><p>Let's look at this simple example where we inject the document element using the <code class="literal">inject</code> wrapper function. This test is irrelevant for our application, but it illustrates how we can now make use of injection in our tests:</p><div class="informalexample"><pre class="programlisting">import {describe, expect, it, <span class="strong"><strong>inject</strong></span>} from '@angular/core/testing';
import {DOCUMENT} from '@angular/platform-browser';

describe('Application initialized with test providers', () =&gt; {
  it('should inject document', <span class="strong"><strong>inject([DOCUMENT], (document) =&gt; {</strong></span>
<span class="strong"><strong>    expect(document).toBe(window.document);</strong></span>
<span class="strong"><strong>  })</strong></span>);
});</pre></div><p>We can simply use <code class="literal">inject</code> to wrap our test function. The <code class="literal">inject</code> function accepts an array as the first parameter that should include a list of injectables. The second parameter is our actual test function, which will now receive the injected document.</p><p>The <code class="literal">async</code> function on the <a id="id511" class="indexterm"/>other hand helps us with a different concern too. What if our tests actually involve asynchronous operations? Well, a standard asynchronous Jasmine test would look like the following:</p><div class="informalexample"><pre class="programlisting">describe('Async test', () =&gt; {
  it('should be completed by calling done', <span class="strong"><strong>(done)</strong></span> =&gt; {
    setTimeout(() =&gt; {
      expect(true).toBe(true);
<span class="strong"><strong>      done();</strong></span>
    }, 2000);
  });
});</pre></div><p>Jasmine provides us with a nice way to specify asynchronous tests. We can simply use the first parameter of our test functions, which resolves to a callback function. By calling this callback function, in our case we named it <code class="literal">done</code>, we tell Jasmine that our asynchronous operations are done, and we would like to finish the test.</p><p>Using callbacks to indicate whether our asynchronous test is finished is a valid option. However, this can make our test quite complicated if many asynchronous operations are involved. It's sometimes even impossible to monitor all the asynchronous operations that are happening under the hood, which also makes it impossible for us to determine the end of our test.</p><p>This is where the <code class="literal">async</code> helper function comes into play. Angular uses a library called Zone.js to monitor any asynchronous operation in the browser. Simply put, Zone.js hooks into any asynchronous operation and monitors where they are initiated as well as when they are finished. With this information, Angular knows exactly how many pending asynchronous operations there are.</p><p>If we're using the <code class="literal">async</code> helper, we tell Angular to automatically finish our test when all asynchronous operations in our test are done. The helper uses Zone.js to create a new zone and determine whether all the microtasks executed within this zone are finished.</p><p>Let's look at how we <a id="id512" class="indexterm"/>can combine injection with an asynchronous operation in our test:</p><div class="informalexample"><pre class="programlisting">import {describe, expect, it, <span class="strong"><strong>inject, async</strong></span>} from '@angular/core/testing';
import {DOCUMENT} from '@angular/platform-browser';

describe('Application initialized with test providers', () =&gt; {
  it('should inject document', <span class="strong"><strong>async(inject([DOCUMENT], (document) =&gt; {</strong></span>
<span class="strong"><strong>      </strong></span>
      setTimeout(() =&gt; {
        expect(document).toBe(window.document);
      }, 2000);
<span class="strong"><strong>    }))</strong></span>
  );
});</pre></div><p>By combining <code class="literal">inject</code> with <code class="literal">async</code> (wrapping), we now have an asynchronous operation in our test. The <code class="literal">async</code> helper will make our test wait until all asynchronous operations are completed. We don't need to rely on a callback, and we have the guarantee that even internal asynchronous operations will complete before our test finishes.</p><div class="note" title="Note"><h3 class="title"><a id="tip20"/>Tip</h3><p>Zone.js is designed to work with all asynchronous operations in the browser. It patches all core DOM APIs and makes sure that every operation goes through a zone. Angular also relies on Zone.js in order to initiate change detection.</p></div></div><div class="section" title="Test component builder"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec78"/>Test component builder</h2></div></div></div><p>Angular comes with <a id="id513" class="indexterm"/>another very important testing utility to test components and directives. So far, we only tested the component class of our components. However, as soon as we need to test components and their behavior in our application, this involves a few more things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Testing the view of components</strong></span>: It's sometimes required that we test the rendered view of components. With all the bindings in our view, dynamic instantiation using template directives and content insertion, it's required that we can have a way to test all this behavior.</li><li class="listitem"><span class="strong"><strong>Testing change detection</strong></span>: As soon as we update our model in our component class, we want to test the updates that are performed via change detection. This involves the whole change detection behavior of our components.</li><li class="listitem"><span class="strong"><strong>User interaction</strong></span>: Our component templates probably contain a set of event bindings, which trigger some behavior on user interaction. We'd also need a way to test the state after some user interaction.</li><li class="listitem"><span class="strong"><strong>Overriding and mocking</strong></span>: In a testing scenario, it's sometimes required to mock certain areas in our components in order to create a proper isolation for our test. In unit testing, we should be concerned only about the specific behavior that we want to test.</li></ul></div><p>The <code class="literal">TestComponentBuilder</code>, which is available through the <code class="literal">@angular/compiler/testing</code> package, helps us exactly with the previous concerns. It's our main tool to test components.</p><p><code class="literal">TestComponentBuilder</code> is <a id="id514" class="indexterm"/>provided to the test application injector, which we initialized in our <code class="literal">all.spec.js</code> module using the <code class="literal">setBaseTestProviders</code> function. The reason for this is that the builder itself also relies on a lot of platform and application dependencies to create components. As all our dependencies now come from the test injector and most of them are overridden to enable inspection, this makes perfect sense.</p><p>Let's look at a very simple example of how we can use <code class="literal">TestComponentBuilder</code> to test the view rendering of a dummy component:</p><div class="informalexample"><pre class="programlisting">@Component({
  selector: 'dummy-component',
<span class="strong"><strong>  template: 'dummy'</strong></span>
})
class DummyComponent {}

describe('Creating a component with TestComponentBuilder', () =&gt; {
  it('should render its view correctly', <span class="strong"><strong>async(inject([TestComponentBuilder], (tbc) =&gt; {</strong></span>
      <span class="strong"><strong>tbc.createAsync(DummyComponent).then((fixture) =&gt; {</strong></span>
        // When
<span class="strong"><strong>        fixture.detectChanges();</strong></span>
        // Then
<span class="strong"><strong>        expect(fixture.nativeElement.textContent).toBe('dummy');</strong></span>
<span class="strong"><strong>      });</strong></span>
<span class="strong"><strong>    }))</strong></span>
  );
});</pre></div><p>As <code class="literal">TestComponentBuilder</code> is exposed in the test injector, we need to use dependency injection to get hold of the instance. We use the <code class="literal">inject</code> helper for this purpose. As creating a component is an asynchronous operation, we also need to make our test wait for completion using the <code class="literal">async</code> helper.</p><p>In our test function, we call the <code class="literal">createAsync</code> method of <code class="literal">TestComponentBuilder</code> and pass a reference to <code class="literal">DummyComponent</code>, which we want to create. This method returns a <code class="literal">Promise</code>, which will resolve once the component is successfully compiled.</p><p>In the <code class="literal">then</code> callback of the <a id="id515" class="indexterm"/>returned promise, we'll receive a special fixture object of the <code class="literal">ComponentFixture</code> type. We can then call the <code class="literal">detectChanges</code> method on this fixture object, which will execute change detection on the created component. After this initial change detection, the view of our dummy component is updated. We can now use the <code class="literal">nativeElement</code> property of the fixture in order to access the root DOM element of the created component.</p><p>Let's look at the <code class="literal">ComponentFixture</code> type and the available fields in more detail:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Member</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p><code class="literal">detectChanges()</code></p>
</td><td valign="top">
<p>This executes change detection on the root component that was created in the context of the fixture. The template bindings will not be evaluated automatically after creating a component using <code class="literal">TestComponentBuilder</code>. It's our own responsibility to trigger change detection. Even after we change the state of our components, we'd need to trigger change detection again.</p>
</td></tr><tr><td valign="top">
<p><code class="literal">destroy()</code></p>
</td><td valign="top">
<p>This method destroys the underlying component and performs any cleanup that is required. This can be used to test the <code class="literal">OnDestroy</code> component's lifecycle.</p>
</td></tr><tr><td valign="top">
<p><code class="literal">componentInstance</code></p>
</td><td valign="top">
<p>This property points to the component class instance, and this is our main interaction point if we want to interact with the component.</p>
</td></tr><tr><td valign="top">
<p><code class="literal">nativeElement</code></p>
</td><td valign="top">
<p>This is a reference to the native DOM element at the root of the created component. This property can be used to inspect the rendered DOM of our component directly.</p>
</td></tr><tr><td valign="top">
<p><code class="literal">elementRef</code></p>
</td><td valign="top">
<p>This is the <code class="literal">ElementRef</code> wrapper around the root element of the created component.</p>
</td></tr><tr><td valign="top">
<p><code class="literal">debugElement</code></p>
</td><td valign="top">
<p>This property points to an instance of <code class="literal">DebugElement</code> that was created by <code class="literal">DebugDomRootRenderer</code> in the component view rendering pipeline. The debug element provides us with some nice utilities to inspect the rendered element tree and testing user interaction. We'll take a closer look at this later in another section.</p>
</td></tr></tbody></table></div><p>We've now looked at a very simple dummy component and how to test it using <code class="literal">TestComponentBuilder</code> in conjunction with the <code class="literal">inject</code> and <code class="literal">async</code> helper functions.</p><p>This is great, but it doesn't really reflect the complexity that we face when we need to test real components. Real components have a lot more dependencies than our dummy component. We rely on child directives and probably on injected services to obtain data.</p><p>Of course, the <code class="literal">TestComponentBuilder</code> also provides us with the tools that we need in order to test more complex components and keep the necessary isolation in a unit test.</p><p>Let's first look at an example where we'd like to test a <code class="literal">ParentComponent</code> component, which uses a <code class="literal">ChildComponent</code> <a id="id516" class="indexterm"/>component to render a list of numbers. As we'd only like to test <code class="literal">ParentComponent</code>, we're not interested in how <code class="literal">ChildComponent</code> renders this list. We want to remove the behavior of the child component from our test by providing a mock component for <code class="literal">ChildComponent</code> during our test, which allows us to easily verify that the data is received by the child component:</p><div class="informalexample"><pre class="programlisting">@Component({
  selector: 'child',
<span class="strong"><strong>  template:'&lt;ul&gt;&lt;li *ngFor="let n of numbers"&gt;Item: {{n}}&lt;/li&gt;&lt;/ul&gt;'</strong></span>
})
class ChildComponent {
<span class="strong"><strong>  @Input() numbers;</strong></span>
}

@Component({
  selector: 'parent',
<span class="strong"><strong>  template: '&lt;child [numbers]="numbers"&gt;&lt;/child&gt;',</strong></span>
<span class="strong"><strong>  directives: [ChildComponent]</strong></span>
})
class ParentComponent {
<span class="strong"><strong>  numbers = [1, 2, 3];</strong></span>
}</pre></div><p>This is our starting point. We have two components, where we'll only be interested in testing the parent component. However, the child component is required by the parent component, and it implies a very specific way to render the numbers that are passed by the parent. We would only like to test whether our numbers were passed successfully to the child component. We don't want to involve the rendering logic of the child component in our test. This is very important because changing only the child component could then break our parent component test, which we want to avoid.</p><p>The thing we want to achieve <a id="id517" class="indexterm"/>now is to create a mock of our child component in the context of our test:</p><div class="informalexample"><pre class="programlisting">@Component({
<span class="strong"><strong>  selector: 'child',</strong></span>
<span class="strong"><strong>  template: '{{numbers.toString()}}'</strong></span>
})
class MockChildComponent {
<span class="strong"><strong>  @Input() numbers;</strong></span>
}</pre></div><p>In our <code class="literal">MockChildComponent</code> class, it's important that we use the same selector property as the real component. Otherwise, the mocking will not work. In the template, we use a very simple output of the numbers input, which enables an easy inspection.</p><p>It's also important that we provide the same input properties as the original component. Otherwise, we won't imitate the real component correctly.</p><p>Now, we can go ahead and perform our test. Using an additional method of <code class="literal">TestComponentBuilder</code>, we are able to override the real <code class="literal">ChildComponent</code> with our mock component:</p><div class="informalexample"><pre class="programlisting">describe('ParentComponent', () =&gt; {
  it('should pass data to child correctly', async(inject([TestComponentBuilder], (tbc) =&gt; {
      tbc
<span class="strong"><strong>       .overrideDirective(ParentComponent, ChildComponent, MockChildComponent)</strong></span>
       .createAsync(ParentComponent).then((fixture) =&gt; {
         fixture.detectChanges();
<span class="strong"><strong>         expect(fixture.nativeElement.textContent).toBe('1,2,3');</strong></span>
       });
    }))
  );
});</pre></div><p>Using the <code class="literal">overrideDirective</code> method on <code class="literal">TestBuilderComponent</code>, we can modify the parent component's <code class="literal">directives</code> metadata before we create it. In this way, we're able to exchange the real child component with our <code class="literal">MockChildComponent</code> class.</p><p>As a result, we decouple <code class="literal">ParentComponent</code> from <code class="literal">ChildComponent</code> in the context of our test. We need this level of separation in order to create a proper isolation of our unit test. As our mock child component simply renders the string representation of the passed array, we can easily test the text content of our fixture.</p><div class="note" title="Note"><h3 class="title"><a id="tip21"/>Tip</h3><p>The definition of a unit test is to test a single unit and isolate the unit from any dependencies. If we want to stick to this paradigm, we'd need to create a mock for every dependent component. This can easily get us into a situation where we need to maintain more complexity only for the sake of our tests. The key here lies in finding the right balance. You should mock dependencies that have a great impact on our subject and ignore dependencies that have low impact on the functionality we'd like to test.</p></div><p>Let's look at a different use case where we have a component that injects a service in order to obtain data. As we also want to test only our component and not the service it relies on, we somehow need to sneak in a mock service instead of the real service into our component. <code class="literal">TestComponentBuilder</code> also provides a method to modify the <code class="literal">providers</code> metadata of directives, which comes in very handy for this case.</p><p>First, we declare our base component and a service that it relies on. In this example, the <code class="literal">NumbersComponent</code> class injects the <code class="literal">NumbersService</code> class, and it obtains an array with numbers from it:</p><div class="informalexample"><pre class="programlisting">@Injectable()
class NumbersService {
<span class="strong"><strong>  numbers = [1, 2, 3, 4, 5, 6];</strong></span>
}

@Component({
  selector: 'numbers-component',
<span class="strong"><strong>  template: '{{numbers.toString()}}',</strong></span>
<span class="strong"><strong>  providers: [NumbersService]</strong></span>
})
class NumbersComponent {
<span class="strong"><strong>  constructor(@Inject(NumbersService) numbersService) {</strong></span>
<span class="strong"><strong>    this.numbers = numbersService.numbers;</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>Now, we need to create a mock service that provides the data required in our test and isolates our component from the original service:</p><div class="informalexample"><pre class="programlisting">@Injectable()
class MockNumbersService extends NumbersService {
<span class="strong"><strong>  numbers = [1, 2, 3];</strong></span>
}</pre></div><p>In this simplified example, we just provide a different set of numbers. However, in a real mocking case, we can exclude a lot of steps that are unnecessary and could potentially create side effects. Using a mock service also ensures that our test, which is focused on the <code class="literal">NumbersComponent</code> class, will not break because of a change in the <code class="literal">NumbersService</code> class.</p><p>By extending the real service, we can leverage some of the behavior of our original service while overriding certain functionality in our mock. You need to be careful with this approach though, as we rely on the original service by doing this. If you'd like to create a fully isolated test, you should <a id="id518" class="indexterm"/>probably override all methods and properties. Or you can create a completely independent mock service, which provides the same methods and properties that are used in your test.</p><div class="note" title="Note"><h3 class="title"><a id="tip22"/>Tip</h3><p>When using TypeScript, you should use interfaces for this purpose where both your real service as well as your mock service implement the same interface.</p></div><p>Let's now look at the test case and how we can use <code class="literal">TestComponentBuilder</code> to provide our mock service instead of the real one:</p><div class="informalexample"><pre class="programlisting">describe('NumbersComponent', () =&gt; {
  it('should render numbers correctly', async(inject([TestComponentBuilder], (tbc) =&gt; {
      tbc
<span class="strong"><strong>       .overrideProviders(NumbersComponent, [</strong></span>
<span class="strong"><strong>         provide(NumbersService, {</strong></span>
<span class="strong"><strong>           useClass: MockNumbersService</strong></span>
<span class="strong"><strong>         })</strong></span>
<span class="strong"><strong>       ])</strong></span>
       .createAsync(NumbersComponent).then((fixture) =&gt; {
         fixture.detectChanges();
<span class="strong"><strong>         expect(fixture.nativeElement.textContent).toBe('1,2,3');</strong></span>
       });
    }))
  );
});</pre></div><p>Using the <code class="literal">overrideProviders</code> method on <code class="literal">TestComponentBuilder</code>, we can provide additional providers to the component under test. This allows us to override existing providers that are already present on the component. Using the <code class="literal">provide</code> function of the <code class="literal">@angular/core</code> module, we can create a provider which provides on requests for <code class="literal">NumberService</code> but also resolves to a <code class="literal">MockNumberService</code>.</p><p><code class="literal">TestComponentBuilder</code> allows us to perform tests in a very simple, isolated, and flexible fashion. It plays a major role when writing unit tests for components. If you'd like to read more about the available methods on <code class="literal">TestComponentBuilder</code>, you can visit the official documentation website at <a class="ulink" href="https://angular.io/docs/ts/latest/api/core/testing/TestComponentBuilder-class.html">https://angular.io/docs/ts/latest/api/core/testing/TestComponentBuilder-class.html</a>.</p><p>Now, it's time to use what we learned about <code class="literal">TestComponentBuilder</code> service and start to test our application <a id="id519" class="indexterm"/>components in action!</p></div></div>
<div class="section" title="Testing components in action"><div class="titlepage" id="aid-26I9K2"><div><div><h1 class="title"><a id="ch11lvl1sec68"/>Testing components in action</h1></div></div></div><p>In the previous <a id="id520" class="indexterm"/>topic, we learned about the <code class="literal">TestComponentBuilder</code> service and how to use it to create components in our testing environment. We learned about the <code class="literal">inject</code> and <code class="literal">async</code> helpers as well as how to mock components and services.</p><p>Let's now use this knowledge to work on our tests for the <code class="literal">AutoComplete</code> component. Let's add another test to the <code class="literal">auto-complete.spec.js</code> file on the <code class="literal">lib/ui/auto-complete</code> path.</p><p>As the <code class="literal">AutoComplete</code> component relies on the rather complex <code class="literal">Editor</code> component, it's probably a good idea to mock our <code class="literal">Editor</code> component before we start writing a test:</p><div class="informalexample"><pre class="programlisting">@Component({
<span class="strong"><strong>  selector: 'ngc-editor',</strong></span>
<span class="strong"><strong>  template: '{{content}}'</strong></span>
})
export class MockEditor {
<span class="strong"><strong>  @Input() content;</strong></span>
}</pre></div><p>This might look a bit tenuous, but this is actually all that we need for our current tests on the <code class="literal">AutoComplete</code> component. The <code class="literal">Editor</code> component should just accept a content input, which is the main interaction between the two components. In the template of our <code class="literal">MockEditor</code> component, we just render the content input property. This way, we can easily verify the result of using the <code class="literal">AutoComplete</code> component.</p><p>Let's use this mock editor to write our next test:</p><div class="informalexample"><pre class="programlisting">it('should initialize editor with selected item', <span class="strong"><strong>async(inject([TestComponentBuilder], (tcb) =&gt; {</strong></span>
    tcb
<span class="strong"><strong>      .overrideDirective(AutoComplete, Editor, MockEditor)</strong></span>
<span class="strong"><strong>      .createAsync(AutoComplete).then((fixture) =&gt; {</strong></span>
        // Given
        fixture.componentInstance.items = ['one', 'two', 'three'];
        fixture.componentInstance.selectedItem = 'two';
        // When
        fixture.detectChanges();
        // Then
<span class="strong"><strong>        expect(fixture.nativeElement.textContent.trim())</strong></span>
<span class="strong"><strong>          .toBe('two');</strong></span>
<span class="strong"><strong>      });</strong></span>
  <span class="strong"><strong>})));</strong></span>
</pre></div><p>In our tests, we'd like to test whether the <code class="literal">AutoComplete</code> component initializes <code class="literal">Editor</code> (respectively, our <code class="literal">MockEditor</code> component) with the right content. We test whether <code class="literal">selectedItem</code> of our <code class="literal">AutoComplete</code> component successfully reflects into the editor.</p><p>We use <code class="literal">TestComponentBuilder</code>, which creates components asynchronously. Using the <code class="literal">async</code> helper function, we tell Jasmine to wait for all asynchronous operations to complete for this test.</p><p>Using the <a id="id521" class="indexterm"/>
<code class="literal">ComponentFixture</code> that is provided by <code class="literal">TestComponentBuilder</code>, we can start to interact with the created component. Using the <code class="literal">componentInstance</code> member of the component fixture, we can set the required input properties of our <code class="literal">AutoComplete</code> component.</p><p>As we're responsible for the triggering of change detection manually in our tests, we use the <code class="literal">detectChanges</code> method on our fixture to update the component view, based on the new state. This will initiate the change detection lifecycle on our component and perform the necessary view updates.</p><p>After the view updates both of our <code class="literal">AutoComplete</code> component and the underlying <code class="literal">MockEditor</code> component, we can run our assertions to validate the updated DOM by getting the text content of the <code class="literal">nativeElement</code> property on our fixture.</p><p>For this particular test, we're fine with this approach. However, in other scenarios where we have more DOM elements involved, it wouldn't be sufficient to assert on the root component's <code class="literal">textContent</code> property directly. This would probably include a lot of noise, which we're not interested in for our assertion. We should always try to narrow our assertion to the fewest details possible.</p><p>As we have access to the native DOM element on our fixture, we can simply use the DOM API to select child elements in order to narrow our assertion:</p><div class="informalexample"><pre class="programlisting">expect(fixture.nativeElement<span class="strong"><strong>.querySelector('ngc-editor')</strong></span>.textContent.trim()).toBe('two');</pre></div><p>This would successfully select the DOM element of our mock editor, and we can only check the text content inside the editor.</p><p>Although this would be a feasible approach, Angular provides us with a much better approach to achieve this goal.</p><p>Provided by <code class="literal">ComponentFixture</code>, we have access to the <code class="literal">DebugElement</code> tree that is created by <code class="literal">DebugDomRootRenderer</code> in the context of our test. <code class="literal">DebugElement</code> allows us advanced inspection of the element tree that was created by Angular when rendering our components. It also contains an advanced querying API, which allows us to search for certain elements in the tree.</p><p>Let's rewrite our test to use the advanced capabilities provided by <code class="literal">DebugElement</code>:</p><div class="informalexample"><pre class="programlisting">...
<span class="strong"><strong>import {By} from '@angular/platform-browser';</strong></span>
...
  it('should initialize editor with selected item', async(inject([TestComponentBuilder], (tcb) =&gt; {
    tcb
      .overrideDirective(AutoComplete, Editor, MockEditor)
      .createAsync(AutoComplete).then((fixture) =&gt; {
        ...
        expect(<span class="strong"><strong>fixture.debugElement.query(By.directive(MockEditor)).nativeElement.textContent.trim()</strong></span>).toBe('two');
      });
  })));</pre></div><p>The <code class="literal">query</code> and <code class="literal">queryAll</code> methods that are available on every <code class="literal">DebugElement</code> object allow us to query the Angular view tree like we would query a DOM tree using <code class="literal">querySelector</code> and <code class="literal">querySelectorAll</code>. The difference here is that we can use a predicate helper to query for matching elements. Using the <code class="literal">By</code> helper class, we can create these predicates, which will then be used in order to query the <code class="literal">DebugElement</code> tree.</p><p>There are currently three <a id="id522" class="indexterm"/>different predicates available using the <code class="literal">By</code> helper:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Member</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p><code class="literal">By.all()</code></p>
</td><td valign="top">
<p>This is the predicate, which will result in querying for all the child <code class="literal">DebugElement</code> object of the current <code class="literal">DebugElement</code> object</p>
</td></tr><tr><td valign="top">
<p><code class="literal">By.css(selector)</code></p>
</td><td valign="top">
<p>This is the predicate, which will result in querying for <code class="literal">DebugElement</code> using the specified CSS selector</p>
</td></tr><tr><td valign="top">
<p><code class="literal">By.directive(type)</code></p>
</td><td valign="top">
<p>This is the predicate, which will result in querying for <code class="literal">DebugElement</code> that contain the specified directive</p>
</td></tr></tbody></table></div><p>Going back to our test, we can now use the query method on the fixture debug element in order to query for our editor. As we've exchanged the real <code class="literal">Editor</code> component with our <code class="literal">MockEditor</code> component, we need to query for the latter. We use a <code class="literal">By.directive(MockEditor)</code> predicate, which will successfully query for the <code class="literal">DebugElement</code> object that represents the host element of our <code class="literal">MockEditor</code> component.</p><p>The <code class="literal">query</code> method of the <code class="literal">DebugElement</code> object will always return a new <code class="literal">DebugElement</code> object of the first found element if there was a match. It will return <code class="literal">null</code> if the queried element was not found.</p><p>The <code class="literal">queryAll</code> method of the <code class="literal">DebugElement</code> will return an array of many <code class="literal">DebugElement</code> which <a id="id523" class="indexterm"/>contains all elements that match the predicate. If there were no matching elements, this method will return an empty array.</p></div>
<div class="section" title="Testing component interaction" id="aid-27GQ61"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec69"/>Testing component interaction</h1></div></div></div><p>Although UI interaction testing is probably part of end-to-end testing, we'll look at how to test basic user <a id="id524" class="indexterm"/>interaction on your components in this topic.</p><p>In this topic, we'll test the autocomplete component behavior if the user clicks on an item in the callout window that shows all available items.</p><p>Let's add this test to the already existing <code class="literal">auto-complete.spec.js</code> module:</p><div class="informalexample"><pre class="programlisting">it('should emit selectedItemChange on click in callout', async(inject([TestComponentBuilder], (tcb) =&gt; {
    tcb
      .overrideDirective(AutoComplete, Editor, MockEditor)
      .createAsync(AutoComplete).then((fixture) =&gt; {
<span class="strong"><strong>        spyOn(fixture.componentInstance.selectedItemChange, 'next');</strong></span>
        fixture.componentInstance.items = ['one', 'two', 'three'];
        fixture.componentInstance.selectedItem = 'one';
<span class="strong"><strong>        fixture.componentInstance.onEditModeChange(true);</strong></span>
<span class="strong"><strong>        fixture.componentInstance.onEditableInput('');</strong></span>
<span class="strong"><strong>        fixture.detectChanges();</strong></span>
<span class="strong"><strong>        fixture.debugElement</strong></span>
<span class="strong"><strong>          .queryAll(By.css('.auto-complete__item'))</strong></span>
<span class="strong"><strong>          .find((item) =&gt; item.nativeElement.textContent.trim() === 'two')</strong></span>
<span class="strong"><strong>          .triggerEventHandler('click');</strong></span>
        <span class="strong"><strong>expect(fixture.componentInstance.selectedItemChange.next).toHaveBeenCalledWith('two');</strong></span>
    });
  })));</pre></div><p>First, we want to set up a Jasmine spy on the <code class="literal">selectedItemChange</code> <code class="literal">EventEmitter</code> <code class="literal">next</code> function for our test. This way, we can check later whether our <code class="literal">AutoComplete</code> component successfully emitted the event when the user selects an item from the callout.</p><p>In the <code class="literal">Given</code> section of our test code, we also call the <code class="literal">onEditModeChanged</code> and <code class="literal">onEditableInput</code> methods on the <code class="literal">AutoComplete</code> component instance. With these calls, we simulate the editor that was used, and there's currently no content in the editor. This will result in the desired filtering, which will present all available items in the callout for selection.</p><p>In the <code class="literal">When</code> section of our code, we first need to trigger change detection on the fixture. This results in the callout with all available auto-complete items being rendered in the <code class="literal">AutoComplete</code> component.</p><p>Now, we can simulate the <code class="literal">click</code> event on one of our autocomplete items to fishing the actions in this test.</p><p>First, we'll select all <code class="literal">DebugElement</code> object that match the CSS class of our autocomplete items in the callout. This will provide us with an array containing all the elements, where we can now use the <code class="literal">Array.prototype.find</code> method to select one specific item based on the contained text.</p><p>On the <code class="literal">DebugElement</code> <a id="id525" class="indexterm"/>resulting from our query, we now call the <code class="literal">triggerEventHandler</code> method to simulate a click event. This will actually not trigger a real click event, but rather it will execute the handler attached to the binding in the view directly.</p><p>After simulating a click on the autocomplete item with the text content of <code class="literal">two</code>, we can now inspect our spy on the <code class="literal">selectedItemChange.next</code> function. According to the behavior in our component, this should have been called with the selected item value.</p><p>Testing user interaction on components is made very easy using the <code class="literal">DebugElement</code>. We also decouple our tests from the underlying DOM events by taking the shortcut enabled by the <code class="literal">triggerEventHandler</code> method.</p><div class="note" title="Note"><h3 class="title"><a id="tip23"/>Tip</h3><p>The <code class="literal">triggerEventHandler</code> method operates on the virtual element tree of Angular, rather than the actual DOM tree. Due to this, we can also use this method to trigger event handlers that are attached to component output properties.</p></div></div>
<div class="section" title="Testing our plugin system"><div class="titlepage" id="aid-28FAO2"><div><div><h1 class="title"><a id="ch11lvl1sec70"/>Testing our plugin system</h1></div></div></div><p>In the previous sections, we <a id="id526" class="indexterm"/>created tests for the <code class="literal">AutoComplete</code> component, which is a rather simple UI component. However, we learned about all the techniques that are required to perform testing on more complex components or even systems of components.</p><p>Now, we'll look into testing the plugin system that was created in <a class="link" title="Chapter 10. Making Things Pluggable" href="part0064.xhtml#aid-1T1401">Chapter 10</a>, <span class="emphasis"><em>Making Things Pluggable</em></span>.</p><p>It's probably a good time to recap on the plugin system architecture overview before working on this topic. As always with testing, it's crucial to understand exactly what's happening in the system under test.</p><p>Let's create a new <code class="literal">plugin.spec.js</code> file in the <code class="literal">lib/plugin</code> path.</p><p>Before we implement our first test function for this subject, we will need to create some dummy components and <a id="id527" class="indexterm"/>plugins to test our system with. Let's create these at the top of our testing module:</p><div class="informalexample"><pre class="programlisting">@Component({
  selector: 'dummy-plugin-component-1',
  template: 'dummy1'
})
<span class="strong"><strong>export class DummyPluginComponent1 {}</strong></span>

@Component({
  selector: 'dummy-plugin-component-2',
  template: 'dummy2'
})
<span class="strong"><strong>export class DummyPluginComponent2 {}</strong></span>

@Component({
  selector: 'dummy-application',
  template: 'dummy-slot:<span class="strong"><strong>&lt;ngc-plugin-slot name="dummy-slot"&gt;&lt;/ngc-plugin-slot&gt;</strong></span>',
  directives: [<span class="strong"><strong>PluginSlot</strong></span>]
})
export class DummyApplication {}</pre></div><p>Nothing special here. We declare two dummy components with a static template that will serve us in performing our plugin tests. Additionally, we created a dummy application component, which will be our main testing component. In the following tests, we will make use of a dummy component to test our <code class="literal">PluginSlot</code> directive, as opposed to testing a component directly.</p><p>Next, we'll need to mock our <code class="literal">PluginService</code> injectable, which is designed to load plugins asynchronously from URLs. In our mock, we'd want to override this functionality. Instead of loading plugins from URLs, we want to load some predefined test plugins:</p><div class="informalexample"><pre class="programlisting">@Injectable()
export class MockPluginService extends PluginService {
<span class="strong"><strong>  constructor() {</strong></span>
<span class="strong"><strong>    super();</strong></span>
<span class="strong"><strong>    this.change = {</strong></span>
<span class="strong"><strong>      subscribe() {}</strong></span>
<span class="strong"><strong>    };</strong></span>
<span class="strong"><strong>  }</strong></span>

<span class="strong"><strong>  loadPlugins() {}</strong></span>
}</pre></div><p>We override the <code class="literal">loadPlugins</code> method to avoid any plugins being loaded during the construction of the service. We also override the RxJS subject present on the <code class="literal">change</code> property in order to prevent any reactive behavior of our plugin system because this would only disturb our tests.</p><p>Let's dive right into our first test where we want to test a very basic plugin with one plugin component, to be instantiated correctly by the <code class="literal">PluginSlot</code> directive. First, we set up our test structure using the <code class="literal">describe</code> and <code class="literal">it</code> functions:</p><div class="informalexample"><pre class="programlisting">describe('PluginSlot', () =&gt; {
<span class="strong"><strong>  beforeEachProviders(() =&gt; [</strong></span>
<span class="strong"><strong>    provide(PluginService, {</strong></span>
<span class="strong"><strong>      useClass: MockPluginService</strong></span>
<span class="strong"><strong>    })</strong></span>
<span class="strong"><strong>  ]);</strong></span>

  it('should create dummy component into designated slot',async(inject([TestComponentBuilder<span class="strong"><strong>, PluginService</strong></span>], (tcb, <span class="strong"><strong>pluginService</strong></span>) =&gt; {
      tcb.createAsync(DummyApplication).then((fixture) =&gt; {
<span class="strong"><strong>          ...</strong></span>
        });
}));</pre></div><p>The only difference here to what we already knew is that we use a new <code class="literal">beforeEachProviders</code> function from the <code class="literal">@angular/core/testing</code> module. This function allows us to <a id="id528" class="indexterm"/>set up some default providers that are used in our tests. As all our plugin system tests will rely on the presence of <code class="literal">PluginService</code>, we use this function to set up the mock provider resolving to our <code class="literal">MockPluginService</code> class.</p><p>Instead of using <code class="literal">beforeEachProviders</code>, we could also use the <code class="literal">overrideProviders</code> method in the <code class="literal">TestComponentBuilder</code> to provide additional injectables. However, this will limit the use to the inside of our components. If we want to interact with the service from our test function, we need to use the <code class="literal">beforeEachProviders</code> helper.</p><p>Using the <code class="literal">inject</code> helper, we inject <code class="literal">TestComponentBuilder</code> and <code class="literal">PluginService</code>, which we provided using the <code class="literal">beforeEachProviders</code> helper.</p><p>Let's now implement the missing test body inside of the <code class="literal">Promise</code> callback after executing <code class="literal">createAsync</code>.</p><p>As a first step, we define a new dummy plugin, which uses the <code class="literal">PluginConfig</code> decorator from the previous chapter. We create a <code class="literal">PluginPlacement</code> in the plugin metadata, which includes a mapping of <code class="literal">DummyPluginComponent1</code> into the slot with the name <code class="literal">dummy-slot</code>. If you take a look at the <code class="literal">DummyApplication</code> component that we use in this test again, you can see that it contains a <code class="literal">PluginSlot</code> directive with the name attribute set to <code class="literal">dummy-slot</code>:</p><div class="informalexample"><pre class="programlisting">@PluginConfig({
  name: 'dummy-plugin',
  description: 'Dummy Plugin',
<span class="strong"><strong>  placements: [</strong></span>
<span class="strong"><strong>    new PluginPlacement({slot: 'dummy-slot', priority: 1, component: DummyPluginComponent1})</strong></span>
<span class="strong"><strong>  ]</strong></span>
})
class DummyPlugin {}</pre></div><p>This plugin should <a id="id529" class="indexterm"/>now cause the <code class="literal">DummyPluginComponent1</code> component to be rendered in the plugin slot of our <code class="literal">DummyApplication</code> class.</p><p>As a next step, we add the <code class="literal">DummyPlugin</code> class to the plugins list of our <code class="literal">MockPluginService</code> mock service:</p><div class="informalexample"><pre class="programlisting">pluginService.plugins = [{
  type: DummyPlugin,
  config: DummyPlugin._pluginConfig,
  instance: new DummyPlugin()
}];</pre></div><p>The object that we're adding to the plugins array of the <code class="literal">MockPluginService</code> simply simulates a plugin that would normally be loaded in <code class="literal">PluginService</code>.</p><p>Next, we put aside a reference to the <code class="literal">PluginSlot</code> directive, which is placed in our <code class="literal">DummyApplication</code> component. For this, we can use the <code class="literal">query</code> method on the <code class="literal">DebugElement</code> root of our fixture. We use a predicate, which allows us to query by the directive type of our <code class="literal">PluginSlot</code> component:</p><div class="informalexample"><pre class="programlisting">const pluginSlot = fixture.debugElement
<span class="strong"><strong>  .query(By.directive(PluginSlot))</strong></span>
  .injector
  .get(PluginSlot);</pre></div><p>We need the reference to the directive instance of the plugin slot in order to initialize the slot prior to our test assertion. This is an important step because we can't rely on the observable subject in our <code class="literal">MockPluginService</code> class to initialize our <code class="literal">PluginSlot</code> directive. We explicitly disabled the reactive features of our plugin system in order to perform proper testing. Therefore, we need to manually initialize our plugin slot before we can perform any assertion.</p><p>After executing the query with the directive predicate (searching for an element which contains the <code class="literal">PluginSlot</code> directive), we'll receive <code class="literal">DebugElement</code> of our plugin slot element. In order to get the directive instance, we use the element injector present on each <code class="literal">DebugElement</code> object.</p><p>The <code class="literal">initialize</code> method on the <code class="literal">PluginSlot</code> component instance will create all relevant plugin components. Luckily, this will also return a <code class="literal">Promise</code> to us, which will be resolved once all components have been created in the view of our <code class="literal">ApplicationDummy</code> component:</p><div class="informalexample"><pre class="programlisting">pluginSlot.initialize().then(() =&gt; {
  fixture.detectChanges();
  <span class="strong"><strong>expect(fixture.nativeElement.textContent).toBe('dummy-slot:dummy1');</strong></span>
});</pre></div><p>In the callback of the <code class="literal">Promise</code> returned by the <code class="literal">initialize</code> method of the <code class="literal">PluginSlot</code> instance, we can finally assert on the text content of the root element of our <code class="literal">DummyApplication</code> component.</p><p>As the <code class="literal">DummyPluginComponent1</code> class has a simple static template that contains the text <code class="literal">dummy1</code>, we should see a complete text content of <code class="literal">dummy-slot:dummy1</code> in our application view.</p><p>This is it for our first <a id="id530" class="indexterm"/>plugin test. Now, we will look at a second test, which we'll use to verify another feature of our plugin system. Our plugin system should also be able to render two components of the same plugin into two separate plugin slots. However, in the template of our <code class="literal">DummyApplication</code> component, we currently only have one plugin slot with the name <code class="literal">dummy-slot</code>.</p><p>In order to modify the template of our <code class="literal">DummyApplication</code> component just for a particular test, we can use the <code class="literal">overrideTemplate</code> method on <code class="literal">TestBuilderComponent</code>:</p><div class="informalexample"><pre class="programlisting">  it('should create two dummy components of same plugin into different slots',async(inject([TestComponentBuilder, PluginService], (tcb, pluginService) =&gt; {
<span class="strong"><strong>      const template = 'dummy-slot1:&lt;ngc-plugin-slot name="dummy-slot1"&gt;&lt;/ngc-plugin-slot&gt;dummy-slot2:&lt;ngc-plugin-slot name="dummy-slot2"&gt;&lt;/ngc-plugin-slot&gt;';</strong></span>

      tcb<span class="strong"><strong>.overrideTemplate(DummyApplication, template)</strong></span>
        .createAsync(DummyApplication).then((fixture) =&gt; {
<span class="strong"><strong>          ...</strong></span>
        });
    }))
  );</pre></div><p>In our test function, we create a new template for our <code class="literal">DummyApplication</code> component. We're adding two plugin slots to the template with their name attributes set to <code class="literal">dummy-slot1</code> and <code class="literal">dummy-slot2</code>.</p><p>Now, we can use the <code class="literal">overrideTemplate</code> method on <code class="literal">TestComponentBuilder</code> to override the <code class="literal">DummyApplication</code> component template before we create it. This provides us with the necessary flexibility to reuse mock and dummy components for different tests.</p><p>Let's take a look at the code that comes in the <code class="literal">createAsync</code> promise callback:</p><div class="informalexample"><pre class="programlisting">@PluginConfig({
  name: 'dummy-plugin',
  description: 'Dummy Plugin',
  placements: [
<span class="strong"><strong>    new PluginPlacement({slot: 'dummy-slot', priority: 1, component: DummyPluginComponent1}),</strong></span>
<span class="strong"><strong>    new PluginPlacement({slot: 'dummy-slot', priority: 2, component: DummyPluginComponent2})</strong></span>
  ]
})
class DummyPlugin {}</pre></div><p>First, we create a new <a id="id531" class="indexterm"/>
<code class="literal">DummyPlugin</code> plugin class and use the <code class="literal">PluginConfig</code> decorator to configure it. In the placement metadata, we configure the mappings so that we map two components into different plugin slots. The first component is mapped to the plugin slot with the name <code class="literal">DummySlot1</code>, while the second one will go to the slot with the name <code class="literal">DummySlot2</code>. We've overridden our <code class="literal">DummyApplication</code> template to include both of these plugin slots.</p><p>We now add our <code class="literal">DummyPlugin</code> class to the <code class="literal">MockPluginService</code> class and simulate the plugin being loaded:</p><div class="informalexample"><pre class="programlisting">pluginService.plugins = [{
  type: DummyPlugin,
  config: DummyPlugin._pluginConfig,
  instance: new DummyPlugin()
}];</pre></div><p>The following code queries for <code class="literal">DebugElements</code> in the fixture using the <code class="literal">queryAll</code> method. We use a predicate that queries for all elements containing the <code class="literal">PluginSlot</code> directive. With an additional call to <code class="literal">Array.prototype.map</code>, we transform the array in order to get back the component instances of the discovered <code class="literal">PluginSlot</code> components directly:</p><div class="informalexample"><pre class="programlisting">const pluginSlots = fixture.debugElement
<span class="strong"><strong>  .queryAll(By.directive(PluginSlot))</strong></span>
<span class="strong"><strong>  .map((debugElement) =&gt; debugElement.injector.get(PluginSlot));</strong></span>
</pre></div><p>Now, it's time to complete our test. Using the <code class="literal">Promise.all</code> function, we're able to streamline an array of Promises into a single Promise, which will resolve once all underlying Promises are resolved. We can then map our <code class="literal">pluginSlots</code> array by executing the initialize method on each of the <code class="literal">PluginSlot</code> components. This will return an array of Promises to us, which will resolve when all components within the plugin slots are created:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Promise.all(</strong></span>
<span class="strong"><strong>  pluginSlots.map((pluginSlot) =&gt; pluginSlot.initialize())</strong></span>
<span class="strong"><strong>)</strong></span>.then(() =&gt; {
  fixture.detectChanges();
<span class="strong"><strong>  expect(fixture.nativeElement.textContent).toBe('dummy-slot1:dummy1dummy-slot2:dumm</strong></span>
<span class="strong"><strong>y2');</strong></span>
});</pre></div><p>In the <code class="literal">then</code> callback of the consolidated promise using the <code class="literal">Promise.all</code> function, we can finally perform our assertion. With the overridden template of our <code class="literal">DummyApplication</code> component and the output of our two plugin components in the two separated plugin slots, we <a id="id532" class="indexterm"/>should get a text content of <code class="literal">dummy-slot1:dummy1dummy-slot2:dummy2</code>.</p><p>This is the last test that we look at in this chapter. However, there are more tests in the code that comes with this book. Just check out the code repository and get your hands on those tests yourself.</p></div>
<div class="section" title="Summary" id="aid-29DRA1"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec71"/>Summary</h1></div></div></div><p>In this chapter, we learned how to write concise unit tests for our components. We followed a BDD style approach of writing tests, and we also covered the basics of the JavaScript testing framework, Jasmine.</p><p>We learned about the debugging tools that are available in Angular and how to set up an injector environment for testing. Using <code class="literal">TestComponentBuilder</code>, we were able to perform tests in a very flexible but precise way. We also learned about the view tree of multiple <code class="literal">DebugElement</code> that are created along with <code class="literal">TestComponentBuilder</code> running in the debug environment. This allowed us to perform clever inspection and apply practical queries to the rendered views in order to assert expected results.</p><p>We used the <code class="literal">inject</code> and <code class="literal">async</code> helpers to inject dependencies and, at the same time, run asynchronous tests. We built both mock and dummy components in order to isolate our tests from the rest of our application.</p></div></body></html>