<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Unit Testing</h1>
                
            
            <article>
                
<p class="mce-root">Let's start this chapter with testing; most people think testing is boring. Guess what, they are mostly right! Testing can be fun in that you get to try and break your code, but it can sometimes be tedious work. However, it can help you catch mistakes before your customers do, and as a bonus, it can prevent you from making the same bug occur multiple times. How much is your reputation to your clients or customers worth? A little tedious work could mean the difference between a Triple-A application, and a mediocre application.</p>
<p class="mce-root">In this chapter, we will cover the following topics:</p>
<ul class="calibre13">
<li class="calibre14">Angular Testing Framework</li>
<li class="calibre14">NativeScript Testing Framework</li>
<li class="calibre14">How to write tests using Jasmine</li>
<li class="calibre14">How to run Karma tests</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Unit testing</h1>
                
            
            <article>
                
<p class="mce-root">Unit tests are used to test small pieces of application code functionality for correctness. This also allows us to verify that the functionality continues to work as expected, when you refactor code and/or add new features. Both NativeScript and Angular offer unit testing frameworks. We will explore both types of unit testing, as they both have pros and cons.</p>
<p class="mce-root">Developing tests at any time is good. However, it is preferable to develop them alongside your development of the project's code. Your mind will be fresh on the new features, modifications, and all the new code you just added. In our case, because we are presenting lots of new concepts throughout this book, we haven't followed the best practice since it would have complicated the book even more. So, although adding tests later is good, adding them before or while adding your new code is considered the best practice.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Angular testing</h1>
                
            
            <article>
                
<p class="mce-root">The first type of unit testing we will cover is Angular unit testing. It is based around <strong class="calibre1">Karma</strong> (<a href="https://karma-runner.github.io/" class="calibre3">https://karma-runner.github.io/</a>) and <strong class="calibre1">Jasmine</strong> (<a href="http://github.com/pivotal/jasmine" class="calibre3">http://github.com/pivotal/jasmine</a>). Karma is a full-featured test runner, which was produced by the Angular team. When the team was implementing Angular, they ran into issues , such as figuring out how to test Angular, so they built Karma. Karma has ended up becoming an industry-standard multipurpose test runner. Jasmine is an open source testing framework that implements a number of testing constructs helps you do all your testing easily. It has been around a lot longer than Karma. Since it was in use by a lot of people before Karma, it became the default testing library in the Angular community. You are free to use any of the other frameworks, such as Mocha, Chia, or even your own home-grown testing framework. However, since almost everything you will see in the Angular community is based around Jasmine, we will use it also.</p>
<p class="mce-root">Let's get the pieces you need installed for Angular testing in NativeScript:</p>
<pre class="calibre22"><strong class="calibre1">npm install jasmine-core karma karma-jasmine karma-chrome-launcher --save-dev</strong><br class="title-page-name"/><strong class="calibre1">npm install @types/jasmine karma-browserify browserify watchify --save-dev</strong></pre>
<p class="mce-root">You also should probably install Karma globally, especially on Windows. However, it is helpful to do so on other platforms also so that you can just type <kbd class="calibre11">karma</kbd> and it runs. In order to do that, type the following command:</p>
<pre class="calibre22"><strong class="calibre1">npm -g install karma</strong></pre>
<p class="mce-root">If you don't have TypeScript installed globally, where you can just type <kbd class="calibre11">tsc</kbd>, and it builds, you should install it globally. You have to transpile your TypeScript into JavaScript before running any tests. To install TypeScript globally, type the following command:</p>
<pre class="calibre22"><strong class="calibre1">npm -g install typescript</strong></pre>
<p class="mce-root">Karma was designed to run tests inside a browser; however, NativeScript code does not run in a browser at all. So, we have to do a couple of things differently to make the standard Karma testing system run with some NativeScript application code. The normal Angular-specific Karma configuration won't work in most cases. If you are going to do any Angular work with the web side of things, you should check out the standard Angular testing QuickStart project (<a href="https://github.com/angular/quickstart/" class="calibre3">https://github.com/angular/quickstart/</a>). That project will get everything set up for a traditional Angular application that runs in a browser.</p>
<p class="mce-root">However, in our case, because we are using NativeScript Angular, we will need a totally customized <kbd class="calibre11">Karma.conf.js</kbd> file. We have included it in the custom config file in the git repo, or you can type it from here. Save this file as <kbd class="calibre11">Karma.ang.conf.js</kbd><strong class="calibre1">.</strong> We are giving a different configuration name because the NativeScript testing we discuss later will use the default <kbd class="calibre11">Karma.conf.js</kbd> name:</p>
<pre class="calibre22">module.exports = function(config) {<br class="title-page-name"/>   config.set({<br class="title-page-name"/>     // Enable Jasmine (Testing)<br class="title-page-name"/>     frameworks: ['jasmine', 'browserify'],<br class="title-page-name"/><br class="title-page-name"/>     plugins: [<br class="title-page-name"/>       require('karma-jasmine'),<br class="title-page-name"/>       require('karma-chrome-launcher'),<br class="title-page-name"/>       require('karma-browserify')<br class="title-page-name"/>    ], <br class="title-page-name"/><br class="title-page-name"/>    files: [ 'app/**/*.spec.js' ],<br class="title-page-name"/><br class="title-page-name"/>    preprocessors: {<br class="title-page-name"/>       'app/**/*.js': ['browserify']<br class="title-page-name"/>    },<br class="title-page-name"/><br class="title-page-name"/>    reporters: ['progress'],<br class="title-page-name"/><br class="title-page-name"/>    browsers: ['Chrome'], <br class="title-page-name"/> });<br class="title-page-name"/>};</pre>
<p class="mce-root">This configuration sets it up so that Karma will use Jasmine, Browserify, and Chrome to run all the tests. Since Karma and Angular were designed for browsers first, all the testing still has to run inside a browser. This is the major downside for the Angular testing system when doing NativeScript code. It won't support any NativeScript-specific code. So, this type of testing is better done on files that are data models and/or any code that has no NativeScript-specific code in it, which unfortunately in some of your apps might not be very much code. However, if you are doing both a NativeScript and web application using the same code base, then you should have a lot of code that can run through the standard Angular testing framework.</p>
<p class="mce-root">For Angular testing, you will create Jasmine specification files, and they all end with <kbd class="calibre11">.spec.ts</kbd>. We must create these files in the same directory as the code you are testing. So, let's take a crack at creating a new specification file for testing. Since this type of unit testing does not allow you to use any NativeScript code, I chose a random model file to show how easy this type of unit testing is. Let's create a file called <kbd class="calibre11">track.model.spec.ts</kbd> in the <kbd class="calibre11">app/modules/shared/models</kbd> folder; this file will be used to test the <kbd class="calibre11">track.model.ts</kbd> file in that same folder. Here is our test code:</p>
<pre class="calibre22">// This disables a issue in TypeScript 2.2+ that affects testing<br class="title-page-name"/>// So this line is highly recommend to be added to all .spec.ts files<br class="title-page-name"/>export = 0;<br class="title-page-name"/><br class="title-page-name"/>// Import our model file (This is what we are going to test)<br class="title-page-name"/>// You can import ANY files you need<br class="title-page-name"/>import {TrackModel} from './track.model';<br class="title-page-name"/><br class="title-page-name"/>// We use describe to describe what this test set is going to be<br class="title-page-name"/>// You can have multiple describes in a testing file.<br class="title-page-name"/>describe('app/modules/shared/models/TrackModel', () =&gt; {<br class="title-page-name"/>  // Define whatever variables you need<br class="title-page-name"/>  let trackModel: TrackModel;<br class="title-page-name"/><br class="title-page-name"/>  // This runs before each "it" function runs, so we can <br class="title-page-name"/>  // configure anything we need to for the actual test<br class="title-page-name"/>  // There is an afterEach for running code after each test<br class="title-page-name"/>  // If you need tear down code<br class="title-page-name"/>  beforeEach( () =&gt; {<br class="title-page-name"/>    // Create a new TrackModel class<br class="title-page-name"/>    trackModel = new TrackModel({id: 1,<br class="title-page-name"/>       filepath: 'Somewhere',<br class="title-page-name"/>       name: 'in Cyberspace',<br class="title-page-name"/>       order: 10,<br class="title-page-name"/>       volume: 5,<br class="title-page-name"/>       mute: false,<br class="title-page-name"/>       model: 'My Model'});<br class="title-page-name"/>  });<br class="title-page-name"/><br class="title-page-name"/>  // Lets run the first test. It makes sure our model is allocated<br class="title-page-name"/>  // the beforeEach ran before this test, meaning it is defined.<br class="title-page-name"/>  // This is a good test to make sure everything is working properly.<br class="title-page-name"/>  it( "Model is defined", () =&gt; {<br class="title-page-name"/>    expect(trackModel).toBeDefined();<br class="title-page-name"/>  });<br class="title-page-name"/><br class="title-page-name"/>  // Make sure that the values we get OUT of the model actually<br class="title-page-name"/>  // match what default values we put in to the model<br class="title-page-name"/>  it ("Model to be configured correctly", () =&gt; {<br class="title-page-name"/>    expect(trackModel.id).toBe(1);<br class="title-page-name"/>    expect(trackModel.filepath).toBe('Somewhere' );<br class="title-page-name"/>    expect(trackModel.name).toBe('in Cyberspace');<br class="title-page-name"/>    expect(trackModel.order).toBe(10);<br class="title-page-name"/>    expect(trackModel.model).toBe('My Model');<br class="title-page-name"/>  });<br class="title-page-name"/><br class="title-page-name"/>  // Verify that the mute functionality actually works<br class="title-page-name"/>  it ('Verify mute', () =&gt; {<br class="title-page-name"/>    trackModel.mute = true;<br class="title-page-name"/>    expect(trackModel.mute).toBe(true);<br class="title-page-name"/>    expect(trackModel.volume).toBe(0);<br class="title-page-name"/>    trackModel.mute = false;<br class="title-page-name"/>    expect(trackModel.volume).toBe(5);<br class="title-page-name"/>  });<br class="title-page-name"/><br class="title-page-name"/>  // Verify the volume functionality actually works<br class="title-page-name"/>  it ('Verify Volume', () =&gt; {<br class="title-page-name"/>    trackModel.mute = true;<br class="title-page-name"/>    expect(trackModel.volume).toBe(0);<br class="title-page-name"/>    trackModel.volume = 6;<br class="title-page-name"/>    expect(trackModel.volume).toBe(6);<br class="title-page-name"/>    expect(trackModel.mute).toBe(false);<br class="title-page-name"/>  });<br class="title-page-name"/>}); </pre>
<p class="mce-root">So, let's break this down. The first line fixes an issue with testing inside a browser with a TypeScript-built file that uses modules. As I noted in the comments, this should be added to all your <kbd class="calibre11">spec.ts</kbd> files. The next line is where we load our model that we will test; you can import any files that you need here, including the Angular library. </p>
<div class="packt_tip">Remember that a <kbd class="calibre29">.spec.js</kbd> file is just a normal TypeScript file; the only thing  that differentiates it is that it has access to Jasmine globalized functions, and runs in a browser. So, all your normal TypeScript code will work fine.</div>
<p class="mce-root">The following line is where we start the actual testing framework. It is a Jasmine function that is used to create a test. Jasmine uses a <kbd class="calibre11">describe</kbd> function to start a group of tests. Describe has two parameters: the text description to print, and then the actual function to run. So, we basically put in the name of the model we are testing and then create the function. Inside each <kbd class="calibre11">describe</kbd> function, we add as many <kbd class="calibre11">it</kbd> functions as we need. Each <kbd class="calibre11">it</kbd> is used for a subset of the tests. You can also have multiple <kbd class="calibre11">describes</kbd>, if necessary.</p>
<p class="mce-root">So, in our test here, we have four separate test groups; the first one is really just to verify that everything is correct. It simply makes sure that our model gets defined properly. So, we are just using the Jasmine <kbd class="calibre11">expect</kbd> command to test for a valid object that was created with the <kbd class="calibre11">.toBeDefined()</kbd> function. Simple, isn't it?</p>
<p class="mce-root">The next test set attempts to make sure that the defaults are set properly from the <kbd class="calibre11">beforeEach</kbd> function. As you can see, we are using the <kbd class="calibre11">expect</kbd> command again with the <kbd class="calibre11">.toBe(value)</kbd> function. This is actually highly recommended; it seems obvious that the values set should match the values read, but you want to treat your modules as a black box. Verify all input and output to make sure that it really is set the same way you set it. So, even though we know we set ID to 1, we are verifying that when we get the ID, it still equals 1.</p>
<p class="mce-root">The third test function starts testing the mute capability, and the final one tests the volume functionality. Note that both the <em class="calibre21">mute</em> and <em class="calibre21">volume</em> have several states and/or impact multiple variables. Anything that is beyond a simple assignment should be tested through every single state you know of, both valid and invalid, if possible. In our case, we noted that mute affects volume and vice versa. So, we verify that when one has changed, the other changes with it. This is used as a contract to make sure that, down the road if this class changes, it will remain the same externally, or our tests will break. In this case, this is more of a brown-box; we know a side-effect of mute, and we are depending on that side-effect in the application, so we will test for that side-effect to make sure that it never changes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Running the tests</h1>
                
            
            <article>
                
<p class="mce-root">Now, let's run the test by typing <kbd class="calibre11">tsc</kbd> to create the transpiled JS files, and then running the following command:</p>
<pre class="calibre22"><strong class="calibre1"> karma start karma.ang.conf.js </strong></pre>
<p class="mce-root">Karma will then find ALL of the <kbd class="calibre11">.spec.js</kbd> files and then run all of them on your Chrome browser, testing all the functionalities that you defined in each <kbd class="calibre11">.spec.js</kbd> file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Unexpected test failure</h1>
                
            
            <article>
                
<div class="mce-root1"><img class="image-border45" src="../images/00055.jpeg"/></div>
<p class="mce-root">Now isn't it very interesting that one of our tests actually failed; <kbd class="calibre11">TrackModel Creation Verify mute FAILED</kbd> and <strong class="calibre1"><kbd class="calibre11">Expected 1 to be 5.</kbd></strong>. This failure was not preplanned for the book; it is actually a real corner case that we just found because we started to use unit testing. If you want to take a quick look at the code, here is the <kbd class="calibre11">TrackModel.ts</kbd> code stripped down to just show the relevant routines:</p>
<pre class="calibre22">export class TrackModel implements ITrack { <br class="title-page-name"/> private _volume: number = 1;<br class="title-page-name"/> private _mute: boolean;<br class="title-page-name"/> private _origVolume: number;<br class="title-page-name"/> constructor(model?: ITrack) {<br class="title-page-name"/>   if (model) {<br class="title-page-name"/>    for (let key in model) {<br class="title-page-name"/>      this[key] = model[key];<br class="title-page-name"/>    }<br class="title-page-name"/>   }<br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/> public set mute(value: boolean) {<br class="title-page-name"/>   value = typeof value === 'undefined' ? false : value;<br class="title-page-name"/>   this._mute = value;<br class="title-page-name"/>   if (this._mute) {<br class="title-page-name"/>     this._origVolume = this._volume;<br class="title-page-name"/>     this.volume = 0;<br class="title-page-name"/>   } else {<br class="title-page-name"/>     this.volume = this._origVolume;<br class="title-page-name"/>   }<br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/> public set volume(value: number) {<br class="title-page-name"/>   value = typeof value === 'undefined' ? 1 : value;<br class="title-page-name"/>   this._volume = value;<br class="title-page-name"/>   if (this._volume &gt; 0 &amp;&amp; this._mute) {<br class="title-page-name"/>     this._origVolume = this._volume;<br class="title-page-name"/>     this._mute = false;<br class="title-page-name"/>   }<br class="title-page-name"/> }<br class="title-page-name"/>}</pre>
<p class="mce-root">Now, I'll give you a few minutes to look at the preceding test code and this code and check whether you can spot why the test fails.</p>
<p class="mce-root">Good, I see, you are back; did you see where the corner case is? Don't feel bad if you couldn't find it quickly; it took me a few minutes to figure out why it was failing also.</p>
<p class="mce-root">Well, first, look at the error message; it said <kbd class="calibre11">Verify Mute FAILED</kbd>, so this means it was our mute test that failed. Then, we put <kbd class="calibre11">Verify mute</kbd> in the <kbd class="calibre11">it</kbd> function that tested our mute functionality. The second clue is the error, <kbd class="calibre11">Expected 1 to be 5</kbd>.<strong class="calibre1"> </strong>So, we expected something to be 5, but it was actually 1. So, this specific test and this line of code are failing in the test:<strong class="calibre1"><br class="title-page-name"/></strong></p>
<pre class="calibre22"> it ('Verify mute', () =&gt; {<br class="title-page-name"/>     expect(trackModel.volume).toBe(5);<br class="title-page-name"/> });</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Why did it fail?</h1>
                
            
            <article>
                
<p class="mce-root">Let's start by looking at the test initialization, <kbd class="calibre11">beforeEach</kbd>; you will see that <kbd class="calibre11">`mute: false`</kbd>. Well, next, let's look at the constructor; it basically does <kbd class="calibre11">this.mute = false</kbd> and the mute setter then runs down its <kbd class="calibre11">else</kbd> path, which is <kbd class="calibre11">this.volume = this._origVolume</kbd>. Guess what? <kbd class="calibre11">this._origVolume</kbd> has not been set yet, so it sets <kbd class="calibre11">this.volume = undefined</kbd>. Now take a look at the volume routine; the new volume comes in <kbd class="calibre11">undefined</kbd>, it is set to <kbd class="calibre11">1</kbd>, which overrides our original setting of 5. So, the test <kbd class="calibre11">Expected 1 to be 5.</kbd><span> fails.</span></p>
<p class="mce-root">Interesting corner case; it wouldn't have happened if we hadn't set <kbd class="calibre11">mute</kbd> to <kbd class="calibre11">false</kbd> as part of testing the initialization of properties. However this is something we should test, because maybe in one of the revisions of the application we will store the mute value and restore it on start.</p>
<p class="mce-root">To fix this, we should fix the class a little. We'll let you do the changes that you think are necessary to fix this issue. If you get stuck, you can rename the <kbd class="calibre11">track.model.fixed.ts</kbd> based on the <kbd class="calibre11">track.model.ts</kbd> file; it contains the correct code.</p>
<p class="mce-root">Once you have it fixed, run the same <kbd class="calibre11">tsc</kbd> and then the <kbd class="calibre11">karma start karma.ang.conf.js</kbd> command; you should see everything is successfull.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Test passes</h1>
                
            
            <article>
                
<div class="mce-root1"><img class="image-border46" src="../images/00056.jpeg"/></div>
<p class="mce-root">As this example pinpointed, your code might run correctly in some cases, but fail in others. Unit testing can pinpoint errors in your logic that you might not see readily. This is especially important when adding new features and/or fixing bugs. It is highly recommended that you create new tests for both, and then you will know at least at a minimum that your new or modified code is behaving properly after you make any code changes.</p>
<p class="mce-root">Let's switch gears slightly, and look at the NativeScript testing framework; the Angular framework is pretty cool, but it has the nasty limitation of not having NativeScript framework calls <span>available</span>, so it limits a lot of its usefulness.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">NativeScript testing framework</h1>
                
            
            <article>
                
<p class="mce-root">Okay, be ready to play with the NativeScript testing framework. It is fairly simple to install, you simply type the following command:</p>
<pre class="calibre22"><strong class="calibre1">tns test init</strong></pre>
<p class="mce-root">There is no reason to switch testing frameworks, so choose <kbd class="calibre11">jasmine</kbd> at the prompt asking you which testing framework to use with the NativeScript testing framework. This will install all the needed resources for the NativeScript testing system. NativeScript's testing system also uses Karma, and it supports a couple of different testing frameworks, but for consistency, we will want to continue to use Jasmine.</p>
<p class="mce-root">Remember earlier when I said Karma uses a browser to do all its tests, and I also said that NativeScript code doesn't run in a browser? So, why does NativeScript use Karma? How does Karma run the NativeScript code? Excellent questions! Karma is actually tricked into thinking that your NativeScript application is a browser. Karma uploads the tests to the browser (that is, the NativeScript application), and it then runs them. So, in effect, your application is a browser to Karma; this is a pretty ingenious solution by the NativeScript team.</p>
<p class="mce-root">Now, the big pro of the NativeScript testing system is that it can actually test all your NativeScript code. It will automatically run a special build of your application in your emulator (or on a real device) so that it can run all the NativeScript code and access the device properly. The biggest con of the NativeScript testing system is that it requires a lot more resources because it must use an emulator (or real device) to run the tests. So, it can be considerably more time-consuming to run testing than the standard unit testing we discussed earlier in this chapter.</p>
<p class="mce-root">Okay, so now you have it all installed. Let's move on. All of the NativeScript testing files will be in the <kbd class="calibre11">app/tests</kbd> folder. This folder was created when you ran the <kbd class="calibre11">tns test init</kbd>. If you open up that folder, you will see <kbd class="calibre11">example.js</kbd>. Feel free to delete or leave the file. It is just a dummy test to show you how to format your tests using Jasmine.</p>
<p class="mce-root">So, for our NativeScript test, I selected a simple service that uses NativeScript code. Let's create our <kbd class="calibre11">database.service.test.ts</kbd> file in the <kbd class="calibre11">app/test</kbd> folder. Your files in this folder can be named anything but, to keep things easier to find, we will end it with <kbd class="calibre11">.test.ts</kbd>. You can also create subdirectories to organize all your tests. In this case, we will test the <kbd class="calibre11">app/modules/core/services/database.service.ts</kbd> file.</p>
<p class="mce-root">This specific service, if you look at the code, actually uses the NativeScript <kbd class="calibre11">AppSettings</kbd> module to store and retrieve data from the Android and iOS system-wide storage system. So, this is a great file to test. Let's create our test file:</p>
<pre class="calibre22">// Import the reflect-metadata because angular needs it, even if we don't.<br class="title-page-name"/>// We could import the entire angular library; but for unit-testing; <br class="title-page-name"/>// smaller is better and faster.<br class="title-page-name"/>import 'reflect-metadata';<br class="title-page-name"/><br class="title-page-name"/>// Import our DatabaseService, we need at least something to test... ;-)<br class="title-page-name"/>import { DatabaseService } from "../modules/core/services/database.service";<br class="title-page-name"/><br class="title-page-name"/>// We do the exact same thing as we discussed earlier; <br class="title-page-name"/>// we describe what test group we are testing.<br class="title-page-name"/>describe("database.service.test", function() {<br class="title-page-name"/><br class="title-page-name"/>  // So that we can easily change the Testing key in case we find out later in our app<br class="title-page-name"/>  // we need "TestingKey" for some obscure reason.<br class="title-page-name"/>  const TestingKey = "TestingKey";<br class="title-page-name"/><br class="title-page-name"/>  // As before, we define a "it" function to define a test group<br class="title-page-name"/>  it("Test Database service class", function() {<br class="title-page-name"/><br class="title-page-name"/>    // We are just going to create the DatabaseService class here, <br class="title-page-name"/>    // no need for a beforeEach.<br class="title-page-name"/>    const dbService = new DatabaseService();<br class="title-page-name"/><br class="title-page-name"/>    // Lets attempt to write some data.<br class="title-page-name"/>    dbService.setItem(TestingKey, {key: "alpha", beta: "cygnus", delta: true});<br class="title-page-name"/><br class="title-page-name"/>    // Lets get that data back out...<br class="title-page-name"/>    let valueOut = dbService.getItem(TestingKey);<br class="title-page-name"/><br class="title-page-name"/>    // Does it match?<br class="title-page-name"/>    expect(valueOut).toBeDefined();<br class="title-page-name"/>    expect(valueOut.key).toBe("alpha");<br class="title-page-name"/>    expect(valueOut.beta).toBe("cygnus");<br class="title-page-name"/>    expect(valueOut.delta).toBe(true);<br class="title-page-name"/><br class="title-page-name"/>    // Lets write some new data over the same key<br class="title-page-name"/>    dbService.setItem(TestingKey, {key: "beta", beta: true});<br class="title-page-name"/><br class="title-page-name"/>    // Lets get the new data<br class="title-page-name"/>    valueOut = dbService.getItem(TestingKey);<br class="title-page-name"/><br class="title-page-name"/>    // Does it match?<br class="title-page-name"/>    expect(valueOut).toBeDefined();<br class="title-page-name"/>    expect(valueOut.key).toBe("beta");<br class="title-page-name"/>    expect(valueOut.beta).toBe(true);<br class="title-page-name"/>    expect(Object.keys(valueOut).length).toBe(2);<br class="title-page-name"/><br class="title-page-name"/>    // Lets remove the key<br class="title-page-name"/>    dbService.removeItem(TestingKey);<br class="title-page-name"/><br class="title-page-name"/>    // Lets make sure the key is gone<br class="title-page-name"/>    valueOut = dbService.getItem(TestingKey);<br class="title-page-name"/>    expect(valueOut).toBeFalsy();<br class="title-page-name"/>  });<br class="title-page-name"/>});</pre>
<p class="mce-root">You might already <span>be </span>able to read this test file pretty easily. Basically, it calls the database service a couple of times to set the same key with different values. Then, it asks the database service to return the values stored and verifies that the results match what we stored. Then, we tell the database service to delete our storage key and verify that the key is gone, all pretty straightforward. The only thing different in this file is the <kbd class="calibre11">include 'reflect-metadata'</kbd>. This is because the database service uses metadata in it, so we have to make sure that the metadata class is loaded before we load the database service class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Running the tests</h1>
                
            
            <article>
                
<p class="mce-root">Let's try testing the application; to run your tests, type the following command:</p>
<pre class="calibre22"><strong class="calibre1">tns test android</strong></pre>
<p class="mce-root">Alternatively, you can run the following command:</p>
<pre class="calibre22"><strong class="calibre1">tns test ios</strong></pre>
<p class="mce-root">This will start the testing, and you should see something like this:</p>
<div class="mce-root1"><img class="image-border47" src="../images/00057.jpeg"/></div>
<p class="mce-root">Note that there is an <kbd class="calibre11">ERROR</kbd> on this screen; this is a false error. Basically, when the app finishes running its tests, it quits. Karma sees that the application has quit unexpectedly and logs it as an <kbd class="calibre11">"ERROR" Disconnected</kbd>. The import information is the line below the error, where it says <kbd class="calibre11">Executed 2 of 2 SUCCESS</kbd>. This means that it ran two different <kbd class="calibre11">described</kbd> tests (that is, our <kbd class="calibre11">test.ts</kbd> file and the extra <kbd class="calibre11">example.js</kbd> file).</p>
<p class="mce-root">You might have also noted that our test file is identical to the Angular testing file. That is because they both use Jasmine and Karma. So, the test files can be set up almost identically. In this specific case, because the testing is actually running inside your application, any plugins, code, and modules, including any native code are all available to be tested. This is what makes the NativeScript testing harness a lot more powerful and useful. However, its greatest strength is also its weakness. Since it has to run inside a running NativeScript application, it takes a lot more time to build, start, and run all the tests. This is where the standard Angular testing framework can prove beneficial over the NativeScript testing framework. Anything that is not using any NativeScript-specific code can run from your command line almost instantly, with very little overhead. The quicker your tests run, the more likely you are to run them frequently.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="mce-root">In this chapter, we discussed how to do unit tests and the pros and cons of two of the methods of doing unit tests. In a nutshell, Angular testing works for generic TypeScript code that does not call any NativeScript-specific code, and it runs your tests really quickly. The NativeScript testing harness runs inside your NativeScript application and has full access to anything you write and anything a normal NativeScript application can do. However, it requires the NativeScript application to be running to run its tests, so it might require a full build step before it can run your tests.</p>
<p class="mce-root">Now that we have discussed the two types of unit testing, hang on to your testing hat. In the next chapter, we will cover how to do end-to-end testing or full screen and application testing of your awesome application.</p>


            </article>

            
        </section>
    </body></html>