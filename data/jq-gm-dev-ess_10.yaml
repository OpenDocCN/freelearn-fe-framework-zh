- en: Chapter 10. Making Some Noise
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第十章。发出一些声音
- en: This is the last chapter of this book, but it's far from the least important
    subject. Music and sound effects are a crucial part of a game's user experience.
    The right music can completely change the way a level feels. The right sound effects
    can help the player understand a game's mechanics or give him/her just the feedback
    that he/she needs to perform the right action at the right time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的最后一章，但这远非不重要的主题。音乐和音效是游戏用户体验的重要组成部分。合适的音乐可以完全改变关卡的感觉。合适的音效可以帮助玩家理解游戏的机制，或者给予他们在正确的时间执行正确操作所需的反馈。
- en: Furthermore, the player expects to have sound in a game since it's been present
    in games since the early days of gaming. Sadly, when it comes to sound, HTML games
    have some big problems. There is not one single powerful solution you can use
    that will make it possible to add sound to your game and have it work on all browsers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，玩家期望在游戏中有声音，因为自从游戏诞生以来，声音一直存在于游戏中。不幸的是，当涉及到声音时，HTML游戏存在一些大问题。您不能使用一个强大的解决方案使其能够在所有浏览器上添加声音并使其正常工作。
- en: 'In this chapter we will cover four different techniques to add sound to your
    game:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍四种不同的技术来为您的游戏添加声音：
- en: '**Embedding**: This is the oldest way to include sound in a page. It was used
    a lot in the old days to make a page play a MIDI file as background music. It''s
    not standard, doesn''t offer a consistent JavaScript API, and you have no guarantee
    that a given audio format is supported. On the plus side though, it''s supported
    by almost all the browsers you can find.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌入**：这是在页面中包含声音的最古老的方法。在旧时代，它经常用于使页面播放MIDI文件作为背景音乐。它不是标准的，不提供一致的JavaScript
    API，并且您无法保证支持给定的音频格式。不过，它被几乎所有您可以找到的浏览器支持。'
- en: '**HTML5 Audio**: You can use the `audio` tag to produce sound. On the plus
    side, almost all browsers support it. The downside is that you will have to deal
    with the fact that each browser supports a different variety of codec and that
    you will not be able to manipulate the sound.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTML5音频**：您可以使用`audio`标签来产生声音。积极的一面是，几乎所有的浏览器都支持它。不利之处在于，您将不得不处理每个浏览器支持不同编解码器的事实，而且您将无法操纵声音。'
- en: '**Web Audio API**: This is basically a JavaScript wrapper around OpenAL. This
    means that you can do anything you want with the sound. Sadly, at the moment only
    Chrome and Safari (on iOS too) support it.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web音频API**：这基本上是围绕OpenAL的JavaScript封装。这意味着您可以对声音做任何您想做的事情。遗憾的是，目前只有Chrome和Safari（iOS上也是如此）支持它。'
- en: '**Flash**: It''s possible to use Flash just to play the sound. This may seem
    like a strange idea since we''re making a JavaScript game here, but you could
    typically use this as a fallback for older browsers.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flash**：可以使用Flash来播放声音。这可能看起来像一个奇怪的想法，因为我们在这里制作的是一个JavaScript游戏，但您通常可以将其用作旧浏览器的后备方案。'
- en: Then we will have a look at a few interesting tools you could use to generate
    sound for your game.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将看一些有趣的工具，您可以用来为您的游戏生成声音。
- en: Abstracting audio
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象音频
- en: 'First let''s create a very simple library to abstract interactions between
    our framework and the sound implementation we chose. The following code represents
    a "contract" that all our implementations will have to respect:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个非常简单的库来抽象我们的框架与我们选择的音频实现之间的交互。以下代码代表了所有我们的实现都必须遵守的“契约”：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For the Web Audio API implementation, we will add more capabilities to our object,
    but this is the basic functionality you might expect for any audio library.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Web音频API的实现，我们将为我们的对象添加更多的功能，但这是您可能期望的任何音频库的基本功能。
- en: Using our small library
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用我们的小型库
- en: 'To use a sound in our game we will simply link the corresponding implementation
    to our HTML file:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的游戏中使用声音，我们只需将相应的实现链接到我们的HTML文件中：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we will add background music to our levels; we need to set up the sound
    and preload it. We will do this by splitting the `initialize` function into two
    parts:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为我们的关卡添加背景音乐；我们需要设置声音并预加载它。我们将通过将`initialize`函数拆分为两个部分来完成此操作：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `waitForSound` function checks whether the sound is preloaded. If it isn''t,
    we create a timeout to check its state again later (100 milliseconds later, to
    be precise). As you can see, once the sound is preloaded, we start the level and
    play the sound. Now we need to stop the sound when the level is finished as shown
    in the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitForSound`函数检查声音是否已预加载。如果没有，我们创建一个超时以稍后再次检查其状态（准确地说，100毫秒后）。正如您所见，一旦声音被预加载，我们就开始了级别并播放声音。现在，我们需要在级别完成时停止声音，如下面的代码所示：'
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Start it again when the next level begins:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当下一个级别开始时再次启动它：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With these modifications, and if the sound library respects the contract we
    just specified, we will have background music. Now let's have a look at different
    implementations for this sound library.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些修改，如果声音库遵守我们刚刚指定的契约，我们将拥有背景音乐。现在让我们来看看针对此声音库的不同实现。
- en: Embedding sound
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入声音
- en: 'HTML possesses a very handy way to delegate the reading of some content to
    a plugin: the `embed` tag. It''s not a standard tag but is supported by all browsers
    and is used widely to include Flash in websites.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: HTML具有一种非常方便的方法来将某些内容的阅读委托给插件：`embed`标签。这不是一个标准标签，但所有浏览器都支持它，并且被广泛用于在网站中包含Flash。
- en: 'This same HTML tag can be used to include sound in a web page. This is far
    from an ideal solution for many reasons:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相同的HTML标签可以用来在网页中包含声音。出于许多原因，这都不是一个理想的解决方案：
- en: There is no standard way to know programmatically whether browsers support this
    feature.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有标准的程序化方法来知道浏览器是否支持此功能。
- en: There is no standard way to control the sound playback since the exposed API
    depends on the plugin used to play the sound. It's possible to try to detect what
    plugin is loaded, but this process is not very reliable. Furthermore, it will
    be a lot of work to provide implementation for each possible plugin.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有标准的方式来控制声音播放，因为暴露的API取决于用于播放声音的插件。尝试检测加载了哪个插件是可能的，但这个过程并不是非常可靠。此外，为每个可能的插件提供实现将是很多工作。
- en: The supported format depends on the plugins installed and not only on the browser.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的格式取决于已安装的插件，而不仅仅是浏览器。
- en: Even if the sound format is supported, the browser may ask permission to start
    the plugin. As long as the user hasn't accepted the launch of the plugin, no sound
    will be played.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使声音格式受支持，浏览器也可能要求允许启动插件。只要用户没有接受启动插件，就不会播放任何声音。
- en: There may be some use cases where it's reasonable to use this method to include
    sounds in your game, but if any of the other techniques presented in the rest
    of this chapter work for you, I would recommend using those instead.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在一些情况，其中使用此方法将声音包含到游戏中是合理的，但如果本章其余部分介绍的任何其他技术对您有效，我建议使用那些技术。
- en: Implementation
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'Let''s have a look at the part of the implementation that takes care of the
    preloading:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看负责预加载的部分的实现：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Implementing preloading with the `embed` tag would require the knowledge of
    the exact plugin being used to play the sound. Sadly, this isn't possible. Instead
    we've chosen to create a completely generic implementation. As a side effect,
    we cannot support preloading. The previous code simply bypasses preloading by
    always returning `true`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`embed`标签实现预加载将需要知道用于播放声音的确切插件的知识。遗憾的是，这是不可能的。相反，我们选择创建一个完全通用的实现。作为副作用，我们不能支持预加载。上述代码简单地通过始终返回`true`来绕过预加载。
- en: 'This creates a major problem: the file will only start to load when you want
    to play it. This means that there will be quite a large delay between the call
    to the `play` function and the time when the player hears the sound. This isn''t
    a big issue for background music, but for sound effects it makes this time almost
    worthless. On the plus side, the second time you play the sound it will probably
    have been cached, so the delay should be reduced.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这造成了一个重大问题：文件只有在您想要播放它时才会开始加载。这意味着在调用`play`函数和播放器听到声音之间会有相当大的延迟。这对背景音乐来说不是什么大问题，但对于音效来说，这个时间几乎是毫无意义的。好的一面是，第二次播放声音时，它很可能已经被缓存，因此延迟应该会减少。
- en: Since we don't want to use any JavaScript API to interact with the plugin, we
    will simply inject the `embed` tag into the page and configure it to automatically
    start playback.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不想使用任何JavaScript API与插件交互，我们只需将`embed`标签注入页面并配置它自动开始播放。
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We store the generated tag in order to remove it during the `stop` method:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们存储生成的标签以便在`stop`方法中删除它：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The disadvantage of this is that we don't reuse the tag we've created. But as
    you won't use this technique in situations where you need to create lots of sound,
    this is not a big issue.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的缺点是我们不会重用我们创建的标签。但是，由于您不会在需要创建大量声音的情况下使用此技术，这并不是一个大问题。
- en: Supported format
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持的格式
- en: Since the list of supported formats using the `embed` tag depends on the installed
    plugin, it's not possible to guarantee that a given file will be playable. However,
    if you use WAV and MIDI, you should be safe.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用`embed`标签支持的格式列表取决于已安装的插件，无法保证某个文件可播放。但是，如果您使用 WAV 和 MIDI，应该是安全的。
- en: If you choose to use WAV files, be careful because there are many different
    ways the sound can be encoded in this format, and to maximize the compatibility
    you should use uncompressed waves.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择使用 WAV 文件，请注意，因为在此格式中，音频可以以许多不同的方式进行编码，为了最大限度地提高兼容性，您应该使用未压缩的波形。
- en: HTML5 Audio element
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML5 音频元素
- en: In order to match Flash's multimedia capabilities, `video` and `audio` elements
    were added to HTML5\. They both come with matching JavaScript APIs that allow
    you to create and manipulate the video or sound with JavaScript without needing
    to write to the document (just like the `Image` object allows you to load an image
    without having to use the `img` tag).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了匹配 Flash 的多媒体功能，HTML5 中添加了`video`和`audio`元素。它们都配有相匹配的 JavaScript API，允许您使用
    JavaScript 创建和操作视频或音频，而无需编写到文档中（就像`Image`对象允许您加载图像而无需使用`img`标签一样）。
- en: 'First let''s have a quick look at what the `audio` tag looks like:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们快速看一下`audio`标签的外观：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see here, it''s possible to provide multiple sources to the `audio`
    tag. This is to circumvent the single biggest issue with this API: compatibility
    with file formats. Indeed, even though all modern browsers support the `audio`
    element, there is not one single audio format that you can use that will be recognized
    by all of them. The solution is to provide multiple formats.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这里所看到的，可以为`audio`标签提供多个来源。这是为了绕过此 API 的最大问题：文件格式的兼容性。事实上，即使所有现代浏览器都支持`audio`元素，也没有一种单一的音频格式可供您使用，所有这些浏览器都能识别。解决方法是提供多种格式。
- en: 'This is far from ideal since it will force you to maintain multiple versions
    of your sound files on your server. The following table shows the compatibility
    of existing sound formats with current browser versions:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这远非理想，因为它将强迫您在服务器上维护多个版本的音频文件。以下表格显示了现有音频格式与当前浏览器版本的兼容性：
- en: '|   | **MP3** | **AAC** | **WAV** | **Ogg Vorbis** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '|   | **MP3** | **AAC** | **WAV** | **Ogg Vorbis** |'
- en: '| **Chrome** | ✓ |   | ✓ | ✓ |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **Chrome** | ✓ |   | ✓ | ✓ |'
- en: '| **Firefox** |   |   | ✓ | ✓ |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **Firefox** |   |   | ✓ | ✓ |'
- en: '| **Internet Explorer** | ✓ | ✓ |   |   |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **Internet Explorer** | ✓ | ✓ |   |   |'
- en: '| **Opera** |   |   | ✓ | ✓ |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **Opera** |   |   | ✓ | ✓ |'
- en: '| **Safari** | ✓ | ✓ | ✓ |   |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **Safari** | ✓ | ✓ | ✓ |   |'
- en: This means that if you want to support all browsers, you'll have to provide
    at least two file formats. The consensus is that you should choose MP3 and Ogg
    Vorbis (sound files ending with `.ogg`).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果您希望支持所有浏览器，您将至少需要提供两种文件格式。一致的意见是您应该选择 MP3 和 Ogg Vorbis（以`.ogg`结尾的音频文件）。
- en: 'For a game, you typically won''t use an HTML tag but will instead directly
    work with the JavaScript API. Before we begin, a small note of warning: even though
    the specification for this standard has not yet been finalized, most modern browsers
    support this feature quite well. Since the standard has changed during the past
    years, some older versions of current browsers may have slightly different implementations.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于游戏，您通常不会使用 HTML 标签，而是直接使用 JavaScript API 进行工作。在我们开始之前，有一个小警告：尽管此标准的规范尚未最终确定，但大多数现代浏览器对此功能的支持相当好。由于标准在过去几年中发生了变化，某些较旧版本的当前浏览器可能具有略有不同的实现。
- en: 'Let''s have a look at how you create an `audio` element in JavaScript:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 JavaScript 中创建一个`audio`元素：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To find out what format the browser can play with JavaScript, you can use the
    `canPlayType` method. The basic usage would be:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解浏览器可以使用 JavaScript 播放的格式，您可以使用`canPlayType`方法。基本用法将是：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The problems begin with the possible values returned by this function: `"probably"`,
    `"maybe"`, `"no"`, and `""`. This is probably far from what you would have expected,
    but there is a very good reason for this: depending on the format, it''s not always
    possible for a decoder to know for sure if it''s supported before accessing the
    file itself. Here is what those values mean:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出现在此函数返回的可能值："probably"、"maybe"、"no"和""。这可能远不如你期望的那样，但有一个非常好的理由：取决于格式，解码器在访问文件本身之前并不总是能确定是否支持它。这些值的含义如下：
- en: '`"probably"`: It''s almost a yes! The browser knows the file type and is pretty
    sure it can decode almost all files of this type.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"probably"`: 几乎可以确定是“是”！浏览器知道文件类型，并且相当确定它可以解码几乎所有这种类型的文件。'
- en: '`"maybe"`: The browser knows the file format but also knows it doesn''t support
    all variants of it. Another reason might be that the browser delegates the reading
    of this file to a plugin and has no way of being sure that the plugin can handle
    this particular file.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"maybe"`: 浏览器知道文件格式，但也知道不支持它的所有变体。另一个原因可能是浏览器将该文件的读取委托给插件，并且无法确定插件能处理这个特定的文件。'
- en: '`""`: The browser doesn''t know about this file type and won''t delegate the
    reading to a plugin either. With this response, you can safely assume that the
    file won''t be played.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`""`: 浏览器对这种文件类型一无所知，也不会将阅读委派给插件。通过这个响应，你可以安全地假设这个文件不会被播放。'
- en: '`"no"`: This is the same answer as `""`; it was used by some early implementations
    of the standard. If you want to support older browsers too, you should expect
    this response sometime.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"no"`: 这与`""`相同；一些早期的标准实现使用了它。如果你想要支持更旧的浏览器，也应该期望这个响应。'
- en: 'With this knowledge, what you would do to mimic the behavior of the HTML code
    we saw earlier is something like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，模仿我们之前看到的HTML代码的行为，你可以做像这样的事情：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This has given the priority to Ogg Vorbis but gives the priority to `"probably"`
    over `"maybe"`, so if the browser can only *maybe* play Ogg Vorbis but thinks
    it can *probably* play MP3, we will load the MP3 version of the file.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了Ogg Vorbis优先权，但在“可能”和“或许”之间更倾向于“可能”，因此如果浏览器可能只能*或许*播放Ogg Vorbis，但认为可以*可能*播放MP3，我们将加载文件的MP3版本。
- en: Preloading a sound
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预加载声音
- en: 'In contrast to the `embed` tag, the `audio` element provides a way to manage
    the preloading of the sound. This is done through the `readyState` property of
    the `audio` element. It can have many possible values:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与`embed`标签相比，`audio`元素提供了管理声音预加载的方法，通过`audio`元素的`readyState`属性来完成。它有很多可能的值：
- en: '`HAVE_NOTHING`: Either the file is not accessible or no data at all has been
    loaded until now; probably the former. The numerical value corresponding to this
    state is `0`.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HAVE_NOTHING`: 要么文件无法访问，要么到目前为止根本没有加载任何数据；可能是前者。这个状态对应的数字值是 `0`。'
- en: '`HAVE_METADATA`: The very beginning of the file has been preloaded; this is
    enough to parse the metadata part of the sound. With that data, the duration of
    the sound can be parsed. The numerical value corresponding to this state is `1`.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HAVE_METADATA`: 文件的开头部分已经预加载；这已经足够解析声音的元数据部分。有了这些数据，可以解析声音的持续时间。这个状态对应的数字值是
    `1`。'
- en: '`HAVE_CURRENT_DATA`: The sound has been loaded up to the current playback position
    but not enough to continue playback. Most likely, this is due to the playback
    position being the end of the file since, usually, a state transition occurs very
    fast to the file below. The numerical value corresponding to this state is `2`.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HAVE_CURRENT_DATA`: 声音已经加载到当前播放位置，但还不足以继续播放。最有可能是由于播放位置是文件的结尾，因为通常情况下，状态转换非常快速到下面的文件。这个状态对应的数字值是
    `2`。'
- en: '`HAVE_FUTURE_DATA`: The sound has been preloaded enough to start playing the
    rest of the file from the given playback position, but you have no guarantee that
    the playback won''t stop soon to allow for more buffering. The numerical value
    corresponding to this state is `3`.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HAVE_FUTURE_DATA`: 音频已经预加载足够，可以从给定的播放位置开始播放剩余的文件，但是不能保证播放不会很快停止以允许更多缓冲。这个状态对应的数字值是
    `3`。'
- en: '`HAVE_ENOUGH_DATA`: Enough of the sound has been preloaded so that the sound
    should play entirely without interruption (this is an estimate based on the playback
    rate and download speed). The numerical value corresponding to this state is `4`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HAVE_ENOUGH_DATA`: 足够的声音已经预加载，所以声音应该在完全不中断的情况下播放（这是基于播放速率和下载速度的估计）。这个状态对应的数字值是
    `4`。'
- en: 'For our implementation, we will consider a sound preloaded only if it''s in
    the `HAVE_ENOUGH_DATA` state. Let''s have a look at the preloading implementation
    of our small library:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的实现，我们将只考虑在 `HAVE_ENOUGH_DATA` 状态下预加载的声音。让我们看看我们小型库的预加载实现：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There are two parts in the preceding code; we've already seen the highlighted
    one—it's used to determine the supported sound format. It's wrapped in a function
    that will be executed only once and stores the supported format in the `sound`
    object as an object variable.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中有两部分；我们已经看到了突出显示的部分——它用于确定支持的声音格式。它被包装在一个只执行一次的函数中，并将支持的格式存储在 `sound`
    对象中作为对象变量。
- en: The rest of the code is the preloading implementation. First we create an `audio`
    object. Then we set the preloading mode to `auto`. This tells the browser that
    it can download as much as it wants from the file. After that, we point to the
    correct version of our file. Here you can see that the `src` argument is expected
    to omit the extension to allow the function to choose the correct version.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码是预加载的实现。首先我们创建一个 `audio` 对象。然后我们将预加载模式设置为 `auto`。这告诉浏览器它可以从文件中下载尽可能多的内容。之后，我们指向我们文件的正确版本。在这里，你可以看到
    `src` 参数预计会省略扩展名，以便函数选择正确的版本。
- en: Finally, we call the `load` function. This is necessary for some implementations
    to actually start loading the file. We will consider the sound preloaded only
    for the value `HAVE_ENOUGH_DATA` of the `readyState` property.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 `load` 函数。对于一些实现来说，这是必要的，才能开始加载文件。我们只有在 `readyState` 属性的值为 `HAVE_ENOUGH_DATA`
    时才会考虑声音预加载。
- en: Playing and stopping sounds
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放和停止声音
- en: 'Controlling the playback is pretty easy. Let''s first have a look at our implementation:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 控制播放很容易。让我们先看看我们的实现：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The implantation of the `play` part is pretty straightforward. However, some
    older browsers don't support the `loop` attribute. For these, we need to loop
    manually. To achieve this, we register an event handler that will be called when
    the sound reaches its end. This event handler will simply rewind the sound and
    play it again.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`play` 部分的实现非常直接。然而，一些旧版本的浏览器不支持 `loop` 属性。对于这些情况，我们需要手动循环。为了实现这一点，我们注册一个事件处理程序，当声音播放到结束时将被调用。这个事件处理程序简单地将声音倒回并再次播放。'
- en: As you can see, there is no `stop` function for the `audio` element, but there
    is a `pause` one. This means that if we call `start` again after a `pause` function,
    the sound will continue from where it was and will not start at the beginning.
    To rewind the sound, we set the current time to `0`, which means "at the beginning".
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`audio` 元素没有 `stop` 函数，但是有一个 `pause` 函数。这意味着如果我们在 `pause` 函数之后再次调用 `start`，声音将继续从原来的位置播放，而不会从头开始。为了倒带声音，我们将当前时间设置为
    `0`，这意味着“从头开始”。
- en: 'Having a `pause` function could be handy, so we will add one to our library:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个 `pause` 函数可能会很方便，所以我们将在我们的库中添加一个。
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now you may think that this is a pretty good solution, and in most cases, it
    is. There are, however, a few problems with it; you cannot manipulate the sound
    much beyond changing its playback speed. Effects, panning (control of the repartition
    of the sound among the available output channels), and such are out of the question.
    Furthermore, on some devices (mostly mobile ones), you cannot play two sounds
    simultaneously. Most of the time, this is due to hardware limitations, but the
    result is that you cannot have background music and sound effects at the same
    time. If you want to use this API on iOS, you have to be aware that you can only
    start to play the sound in response to an event generated by the user.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能会认为这是一个相当好的解决方案，在大多数情况下，确实如此。然而，它还是存在一些问题；你不能在很大程度上操作声音，除了改变它的播放速度之外。效果、声道平移（控制声音在可用输出通道中的分配）等都不可能实现。此外，在某些设备上（主要是移动设备），你不能同时播放两个声音。大多数情况下，这是由于硬件限制，但结果是你不能同时拥有背景音乐和音效。如果你想在
    iOS 上使用这个 API，你必须知道你只能在用户生成的事件响应中开始播放声音。
- en: Web Audio API
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web 音频 API
- en: The Web Audio API aims to give the JavaScript developer basically the same tool
    he is used to having when writing a native application. It replicates the capabilities
    of OpenAL, a very widely used API for game development. Furthermore it's a standard
    API. Sadly, for the moment, it's only implemented on Webkit-based browsers including
    the mobile version in iOS 6.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Web Audio API 的目标是给 JavaScript 开发人员基本上与编写本机应用程序时所用工具相同的工具。它复制了 OpenAL 的功能，OpenAL
    是一种非常广泛使用的游戏开发 API。而且它是一个标准 API。不幸的是，目前它只在基于 Webkit 的浏览器上实现，包括 iOS 6 的移动版本。
- en: Before work on this standard began, Mozilla added a similar API to Firefox called
    Audio Data and is currently working on migrating to the Web Audio API. It should
    probably be available in a stable version before the end of 2013\. As for Internet
    Explorer, nothing has been announced yet. If you want to use the Web Audio API
    in Firefox, you can now use the `audionode.js` library ([https://github.com/corbanbrook/audionode.js](https://github.com/corbanbrook/audionode.js)),
    but it's incomplete and hasn't been updated in years. However, if you stick to
    simple usage, it will probably do the trick!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在制定这一标准之前，Mozilla 在 Firefox 中添加了一个类似的 API，称为 Audio Data，并正在努力迁移到 Web Audio API。它可能会在
    2013 年底之前的稳定版本中提供。至于 Internet Explorer，目前尚未公布任何信息。如果你想在 Firefox 中使用 Web Audio
    API，现在可以使用 `audionode.js` 库 ([https://github.com/corbanbrook/audionode.js](https://github.com/corbanbrook/audionode.js))，但它并不完整，并且多年未更新。然而，如果你只是简单使用，它可能会起到作用！
- en: Instead of simply providing a way to play a sound, this API provides a full
    stack to generate sound effects. This has the side effect of producing a slightly
    more complex API.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 API 不仅提供了播放声音的方法，而且提供了生成声音效果的完整堆栈。这会导致 API 稍微复杂一些。
- en: Basic usage
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本用法
- en: The idea behind the Web Audio API is that you connect nodes together in order
    to route a sound to the speakers. You can imagine those nodes as real-life devices
    such as amplifiers, equalizers, effect pedals, or CD players. All that is done
    in the Web Audio API is done through the Audio context. It's an instantiated object,
    but you can only have one instance of it at any given time.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Web Audio API 的理念是你连接节点以将声音路由到扬声器。你可以想象这些节点是真实的设备，比如放大器、均衡器、效果器或 CD 播放器。所有这些都是通过音频上下文（Audio
    context）完成的。它是一个实例化的对象，但你一次只能有一个实例。
- en: 'Let''s start with a very basic example by connecting an MP3 source to the speaker,
    as shown in the following figure:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常基本的例子开始，将 MP3 源连接到扬声器，如下图所示：
- en: '![Basic usage](img/5060_10_01.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![基本用法](img/5060_10_01.jpg)'
- en: 'To create an MP3 source, you first need to load the sound. This is done through
    an asynchronous XML HTTP request. Once this is done, we have a file encoded as
    an MP3 that we will need to decode to obtain the bytes describing the sound wave
    and store them into a buffer:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 MP3 源，你首先需要加载声音。这是通过异步 XML HTTP 请求完成的。一旦完成，我们就有了一个编码为 MP3 的文件，我们需要对其进行解码以获得描述声波的字节并将其存储到缓冲区中：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'At this point, the `soundBuffer` object holds the decoded sound data. We then
    need to create a source node and connect it to the buffer. Metaphorically, this
    would be like putting a CD in the CD player:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`soundBuffer` 对象保存了解码后的声音数据。然后我们需要创建一个源节点并将其连接到缓冲区。比喻地说，这就像把 CD 放入 CD 播放器中一样：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we need to connect the source to the speakers:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将源连接到扬声器：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is like connecting our CD player to a headset or some speakers. At this
    point, you won''t hear anything because we still haven''t played the sound. To
    do this, we can write the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像将我们的 CD 播放器连接到耳机或扬声器一样。此时，你听不到任何声音，因为我们还没有播放声音。要做到这一点，我们可以写下以下内容：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If the name of this method changed recently to make it more understandable,
    it used to be called `noteOn` so you may want to support this too, since the change
    is fairly recent and a few browsers may still have the old name implemented. If
    you want to stop playback, you will call `stop` (or its new name `noteOff`). You
    are probably wondering why we need to pass an argument to this function. That
    would be because this API allows you to synchronize audio in a very precise way
    to do whatever you want (another sound or a visual effect). The value you pass
    is the moment at which the sound should start to play (or stop). This value is
    given in seconds.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个方法的名称最近更改为更容易理解，它以前称为 `noteOn`，所以你可能也想支持这个，因为这个更改是相当近期的，一些浏览器可能仍然实现了旧的名称。如果你想停止播放，你将调用
    `stop` （或它的新名称 `noteOff`）。你可能想知道为什么我们需要向这个函数传递一个参数。因为这个 API 允许你以非常精确的方式同步音频，以便做任何你想做的事情（另一个声音或视觉效果）。你传递的值是声音应该开始播放（或停止）的时刻。这个值以秒为单位给出。
- en: 'With what we''ve seen until now, we can already implement our small library,
    so let''s do it before we have a look at the more complex usage:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们到目前为止所见到的，我们已经可以实现我们的小型库了，所以在我们看更复杂的用法之前，让我们先这样做吧：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There's nothing new here except that the `play` and `stop` functions can only
    be called once. This means that you have to create a new `bufferSource` object
    each time you want to play the sound.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新的，除了 `play` 和 `stop` 函数只能被调用一次。这意味着你每次想播放声音时都必须创建一个新的 `bufferSource`
    对象。
- en: Connecting more nodes
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接更多节点
- en: 'Let''s add a new node to our context: a `gain` node. This node allows you to
    change the volume of your sound. The real-life version of this sound would be
    an amplifier. The following figure shows how our node will be connected:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向我们的上下文添加一个新的节点：一个 `gain` 节点。这个节点允许你改变你的声音的音量。这个声音的真实版本将是一个放大器。下图显示了我们的节点将如何连接：
- en: '![Connecting more nodes](img/5060_10_02.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![连接更多节点](img/5060_10_02.jpg)'
- en: 'First let''s create the node:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们创建节点：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then we will connect our source to the node input and the speakers to the node
    output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将我们的源连接到节点输入，将扬声器连接到节点输出：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once this is done, we can modify the volume by changing the value of the `gain.value`
    property, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这件事之后，我们可以通过改变 `gain.value` 属性的值来修改音量，如下所示：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `gain` parameter is something called `AudioParams`. It''s a parameter you
    will find in a lot of nodes, and it possesses a series of functions that allow
    you to manipulate a value, not only immediately but also making it change over
    time. Here are the functions you can call on this object:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`gain` 参数是一种叫做 `AudioParams` 的东西。它是你会在许多节点中找到的一个参数，它拥有一系列函数，允许你不仅立即操纵一个值，还可以使它随着时间而改变。以下是你可以在这个对象上调用的函数：'
- en: '`setValueAtTime(value,` `time)`: This will change the value at the specified
    time. The time is the absolute time given in seconds, just as for the `start`
    function.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setValueAtTime(value,` `time)`: 这将在指定的时间改变值。时间是以秒为单位的绝对时间，就像 `start` 函数一样。'
- en: '`linearRampToValueAtTime(value, time)`: This will make the current value change
    linearly until it reaches the specified value at the provided time.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linearRampToValueAtTime(value, time)`: 这将使当前值在提供的时间内线性变化，直到达到指定的值。'
- en: '`exponentialRampToValueAtTime(value, time)`: This will make the current value
    change exponentially until it reaches the specified value at the provided time.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exponentialRampToValueAtTime(value, time)`: 这将使当前值从提供的时间到达指定值的时间内呈指数变化。'
- en: '`setTargetAtTime(target, time, constant)`: This will make the current value
    approach the target value from the given time at a constant rate.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setTargetAtTime(target, time, constant)`: 这将使当前值以恒定速率从给定时间接近目标值。'
- en: '`setValueCurveAtTime(valuesArray, time, duration)`: This will make the value
    go through all the values in the provided array from the provided time during
    the provided duration.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setValueCurveAtTime(valuesArray, time, duration)`: 这将使值在提供的时间段内，根据提供的数组中的所有值进行过渡。'
- en: '`cancelScheduledValues(time)`: This will cancel all the programmed value changes
    from the given time.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cancelScheduledValues(time)`: 这将取消从给定时间开始的所有预定值变化。'
- en: 'The following figure shows examples of those functions:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示例显示了这些函数的示例：
- en: '![Connecting more nodes](img/5060_10_03.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![连接更多节点](img/5060_10_03.jpg)'
- en: All these functions can be set up to chain one after the other. The exact way
    in which they will interact can sometimes be complex, and some transitions will
    create an error. For more details, you should have a look at the specs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都可以设置成一个接一个地链式调用。它们之间的精确互动方式有时可能很复杂，一些过渡会产生错误。有关更多详细信息，请参阅规范。
- en: Loading more than one sound
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载多个声音
- en: This sound is just one among many available nodes you can use to create your
    sound graph. You can combine them as you want, and of course, connect more than
    one source to your `context.destination` object. If you want to use more than
    one sound, you will want to preload them all at once.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声音只是你可以用来创建声音图的众多可用节点中的一个。你可以随意组合它们，当然，也可以将多个源连接到你的`context.destination`对象上。如果你想使用多个声音，你会想要一次性预加载它们。
- en: 'You could use the API we''ve seen to do this, but there is a way to do this
    out of the box in Web Audio by using `BufferLoader`. The following code shows
    how this works:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用我们之前看到的API来做到这一点，但是在Web音频中，通过使用`BufferLoader`，可以直接实现这一点。以下代码显示了这是如何工作的：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The callback will be executed when the sound is buffered, just as with the `onload`
    callback in the previous example.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当声音被缓冲时，回调将被执行，就像前面示例中的`onload`回调一样。
- en: So many nodes, so little time
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么多节点，时间太少
- en: There is quite a number of effect nodes provided by this API; let's now have
    a quick overview of the nodes. This list is taken from the specifications ([http://www.w3.org/TR/webaudio/](http://www.w3.org/TR/webaudio/)).
    Keep in mind that the specifications are still evolving and the implementation
    is not always complete or up-to-date with the specifications.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个API提供了相当多的效果节点；现在让我们快速概述一下这些节点。这个列表来自规范（[http://www.w3.org/TR/webaudio/](http://www.w3.org/TR/webaudio/)）。请记住，规范仍在发展中，实现并不总是完整的或与规范保持最新。
- en: Delay node
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 延迟节点
- en: The **delay** node will simply delay the sounds coming in. It has only one parameter
    that represents the amount of time the sound should be delayed by.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**延迟**节点只会延迟传入的声音。它只有一个参数，表示声音应该延迟多长时间。'
- en: '![Delay node](img/5060_10_04.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![延迟节点](img/5060_10_04.jpg)'
- en: ScriptProcessor node
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 脚本处理器节点
- en: 'This node is a general-purpose node that allows you to write your own effect
    in JavaScript. It has two parameters:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个节点是一个通用的节点，允许你用JavaScript编写自己的效果。它有两个参数：
- en: '`bufferSize`: This defines the size of the buffer, which has to be one of the
    following values: 256, 512, 1024, 2048, 4096, 8192, or 16384\. The buffer is the
    part of the sound your JavaScript function will work on.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bufferSize`：这定义了缓冲区的大小，它必须是以下值之一：256、512、1024、2048、4096、8192或16384。缓冲区是你的JavaScript函数将要处理的声音的部分。'
- en: '`onaudioprocess`: This is the function that will modify your sound. It will
    receive an event as a parameter with the following properties: the node that called
    it, the input buffer, and the time at which the audio from the buffer will be
    played. The function will have to write the sound to the event''s output buffer.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onaudioprocess`：这是将修改你的声音的函数。它将接收一个事件作为参数，具有以下属性：调用它的节点、输入缓冲区和从缓冲区播放音频的时间。函数将不得不将声音写入事件的输出缓冲区。'
- en: '![ScriptProcessor node](img/5060_10_05.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![脚本处理器节点](img/5060_10_05.jpg)'
- en: Panner node
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定位器节点
- en: This node will allow you to spatialize the sound in a 3D environment. You can
    define the sound source's spatial properties with the `setPosition`, `setOrientation`,
    and `setVelocity` functions. To modify the listener's spatial properties, you
    will have to access the `context.listener` object and use those same functions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个节点将允许你在3D环境中对声音进行空间化处理。你可以使用`setPosition`、`setOrientation`和`setVelocity`函数定义声源的空间属性。要修改听者的空间属性，你将不得不访问`context.listener`对象并使用相同的函数。
- en: There are many mode parameters you can set on this node to fine-tune the ways
    the spatialization is done, but you'll have to look at the specs for the details.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个节点上设置许多模式参数来微调空间化的方式，但是你需要查看规范以获取详细信息。
- en: '![Panner node](img/5060_10_06.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![Panner node](img/5060_10_06.jpg)'
- en: Convolver node
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 卷积节点
- en: 'This node creates a **Convolver** effect ([http://en.wikipedia.org/wiki/Convolution](http://en.wikipedia.org/wiki/Convolution)).
    It takes two parameters: the buffer holding the sound wave used as an **impulse**
    for the convolution and a Boolean value that specifies whether the effect should
    be normalized or not.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个节点创建一个**卷积器**效果（[http://en.wikipedia.org/wiki/Convolution](http://en.wikipedia.org/wiki/Convolution)）。它接受两个参数：保存用作卷积的声波的缓冲区和一个布尔值，指定效果是否应该被归一化。
- en: '![Convolver node](img/5060_10_07.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![卷积节点](img/5060_10_07.jpg)'
- en: Analyser node
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析节点
- en: This node doesn't change the sound at all; instead, it can be used to do frequency
    and time-domain analyses.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此节点根本不改变声音；相反，它可以用于进行频率和时域分析。
- en: '![Analyser node](img/5060_10_08.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![分析节点](img/5060_10_08.jpg)'
- en: DynamicCompressor node
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态压缩器节点
- en: 'This node implements a compressor effect. You can configure the effect with
    the following parameters: **threshold**, **knee**, **ratio** , **reduction** ,
    **attack** , and **release**.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此节点实现了一个压缩器效果。您可以使用以下参数配置效果：**threshold**，**knee**，**ratio**，**reduction**，**attack**和**release**。
- en: '![DynamicCompressor node](img/5060_10_09.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![动态压缩器节点](img/5060_10_09.jpg)'
- en: BiquadFilter node
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双二次滤波器节点
- en: 'This node can be used to apply a series of low-order filters. To specify which
    one you can use the node''s `type` property to assign it one of the following
    values: `lowpass`, `highpass`, `bandpass`, `lowshelf`, `highshelf`, `peaking`,
    `notch`, and `allpass`. You can configure the chosen effect by setting some properties
    of the node. For details, you can have a look at the specs.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此节点可用于应用一系列低阶滤波器。要指定使用哪一个，您可以使用节点的 `type` 属性将其分配给以下值之一：`lowpass`，`highpass`，`bandpass`，`lowshelf`，`highshelf`，`peaking`，`notch`
    和 `allpass`。您可以通过设置节点的一些属性来配置所选择的效果。有关详细信息，您可以查看规格。
- en: WaveShaper node
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WaveShaper 节点
- en: This node implements a waveshaper effect ([http://en.wikipedia.org/wiki/Waveshaper](http://en.wikipedia.org/wiki/Waveshaper))
    defined by its shaping function provided as an array in the curve properties of
    the node.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此节点实现了一个波形整形器效果（[http://en.wikipedia.org/wiki/Waveshaper](http://en.wikipedia.org/wiki/Waveshaper)），由节点的曲线属性中提供的整形函数数组定义。
- en: Flash fallbacks
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flash 回退
- en: This may seem strange, but there are a few situations where you may want to
    use Flash for sound. For example, you may have designed a simple game with HTML
    because you wanted to target iOS devices and desktops at the same time. But you
    want older browsers such as IE 6 to have sound too. Or you want to use only MP3
    and provide Flash for devices that don't support it. Those are some situations
    where you may want to use Flash if the HTML5 Audio element is not supported.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来很奇怪，但有几种情况下您可能希望使用 Flash 进行声音处理。例如，您可能已经使用 HTML 设计了一个简单的游戏，因为您想同时面向 iOS
    设备和台式机。但是您还希望旧版浏览器（如 IE 6）也具有声音。或者您希望仅使用 MP3 并为不支持 Flash 的设备提供 Flash。这些是一些情况，在这些情况下，如果不支持
    HTML5 Audio 元素，则可能希望使用 Flash。
- en: There are some libraries that allow you to abstract this; we will take a detailed
    look at one of them—SoundManager 2—and then a quick overview of some available
    alternatives.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些库可以使您抽象化此过程；我们将详细查看其中之一——SoundManager 2——然后快速概述一些可用的替代方案。
- en: SoundManager 2
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SoundManager 2
- en: To use SoundManager 2 ([http://www.schillmania.com/projects/soundmanager2/](http://www.schillmania.com/projects/soundmanager2/)),
    you only need to include a smallish JavaScript code on your page and provide a
    link to the Flash files (hosted on the same server to comply with the same-origin
    policy). Let's have a quick look at what the implementation of preloading would
    look like.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 SoundManager 2（[http://www.schillmania.com/projects/soundmanager2/](http://www.schillmania.com/projects/soundmanager2/)），您只需要在页面上包含一小段
    JavaScript 代码，并提供指向 Flash 文件的链接（在同一服务器上托管以遵守同一来源策略）。让我们快速看一下预加载的实现将会是什么样子。
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To use SoundManager 2, we first have to configure it; that's what the highlighted
    part of the preceding code does. The `url` parameter is the path to the Flash
    file that will be used to play the sound. We've chosen Flash Version 8 because
    you don't need a higher version if you want to mimic the HTML5 Audio element.
    We then set a flag to make the library use HTML5 to play the sound when Flash
    is not available. Since this method can take some time before all is loaded and
    ready to be used, we set an event handler to detect whether the `SoundManager`
    object is ready. This event handler simply sets a flag. There are more available
    parameters, and I recommend that you take a look at them in the well-written documentation
    for `SoundManager`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 SoundManager 2，我们首先必须配置它；这是前面代码中突出显示的部分所做的。 `url` 参数是播放声音所使用的 Flash 文件的路径。我们选择了
    Flash 版本 8，因为如果要模仿 HTML5 Audio 元素，则不需要更高版本。然后，我们设置一个标志，以在 Flash 不可用时使库使用 HTML5
    播放声音。由于此方法可能需要一些时间才能加载和准备就绪，我们设置了一个事件处理程序来检测 `SoundManager` 对象是否已准备就绪。此事件处理程序仅设置一个标志。还有更多可用参数，我建议您在写得很好的
    `SoundManager` 文档中查看它们。
- en: To implement the `preload` function, we have to take into account that SoundManager
    may not be ready. If that is the case, we wait for the next call to `isPreloaded`
    to start the preloading (if `SoundManager` is ready at this point).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 `preload` 函数，我们必须考虑到 SoundManager 可能尚未准备好。如果是这种情况，我们等待下一次调用 `isPreloaded`
    来开始预加载（如果此时 `SoundManager` 已准备就绪）。
- en: 'To query the status of the sound we can use the `readyState` parameter, but
    be careful; the available values are not the same as the ones for the HTML5 Audio
    element:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询音频状态，我们可以使用 `readyState` 参数，但要小心；可用值与 HTML5 音频元素的值不同：
- en: '`0`: Sound is not initialized; preloading has not started yet'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`: 音频未初始化；预加载尚未开始'
- en: '`1`: Sound is loading'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`: 音频正在加载'
- en: '`2`: An error occurred during the loading of the sound'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`: 加载音频时发生错误'
- en: '`3`: The file has been loaded'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3`: 文件已加载'
- en: 'Obviously, we will consider a sound as being ready if the `readyState` parameter
    has the value `3`. Here is the implementation of the last three methods; there
    is nothing special here since each of them has an exact match in `SoundManager`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，如果 `readyState` 参数的值为 `3`，我们将认为音频已准备就绪。下面是最后三个方法的实现；这里没有特别之处，因为每个方法都与 `SoundManager`
    中的一个精确匹配：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That's it for the SoundManager implementation of our sound library.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们音频库的 SoundManager 实现了。
- en: Alternatives to SoundManager
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替代方案 SoundManager
- en: There are many other libraries that do what SoundManager does. jPlayer ([http://www.jplayer.org/](http://www.jplayer.org/))
    is one of them. Contrary to what SoundManager does, it allows you to play video
    too and was conceived from the ground up around the HTML5 Audio and Video elements
    whereas this was added later to SoundManager. Furthermore, it's conceived as a
    jQuery plugin. However, it's conceived to be used as a media player, with a UI
    visible to the user. This can be disabled if you want to use it in your game.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他库可以完成 SoundManager 的功能。jPlayer ([http://www.jplayer.org/](http://www.jplayer.org/))
    就是其中之一。与 SoundManager 不同的是，它允许您播放视频，并且从一开始就围绕 HTML5 音频和视频元素构建，而这些后来才添加到 SoundManager。此外，它被构想为一个
    jQuery 插件。但是，它被构想为媒体播放器，用户可以看到 UI。如果您想在游戏中使用它，可以禁用此功能。
- en: Another possibility is that of using SoundJS ([http://www.createjs.com/#!/SoundJS](http://www.createjs.com/#!/SoundJS)).
    It's a part of the CreateJS suite of tools and is well adapted to game programming.
    SoundJS supports HTML5 Audio, Web Audio API, and Flash. If you're familiar with
    CreateJS, using it should not be a problem; otherwise, it will probably seem a
    little harder to use than the two previous ones. I would argue that this is worth
    the effort since it's a very clean and modern library.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是使用 SoundJS ([http://www.createjs.com/#!/SoundJS](http://www.createjs.com/#!/SoundJS))。它是
    CreateJS 工具套件的一部分，非常适合游戏编程。SoundJS 支持 HTML5 音频、Web Audio API 和 Flash。如果您熟悉 CreateJS，使用它应该不是问题；否则，它可能会比前两种更难使用。我认为这值得付出努力，因为这是一个非常干净和现代的库。
- en: If you don't want to learn yet another library to play your sounds, you could
    use `mediaelement.js` ([http://mediaelementjs.com/](http://mediaelementjs.com/));
    it provides an implementation of the HTML5 Audio and Video elements for browsers
    that don't support it. If you use this library, you will simply write your code
    using the `audio` element, and a Flash or Silverlight script will be used to play
    it where needed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想学习另一个播放音频的库，可以使用 `mediaelement.js` ([http://mediaelementjs.com/](http://mediaelementjs.com/))；它为不支持
    HTML5 音频和视频元素的浏览器提供了实现。如果使用此库，您只需使用 `audio` 元素编写代码，需要时将使用 Flash 或 Silverlight
    脚本进行播放。
- en: Generating sound effects
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成音效
- en: 'Until now, we mostly spoke about music. Of course, the same techniques can
    be used to play sound effects. There is however a very elegant solution for dealing
    with them: generating them at runtime. This mimics the way a lot of effects were
    created on old game consoles. To do this in JavaScript, you can use `SFXR.js`
    ([https://github.com/humphd/sfxr.js](https://github.com/humphd/sfxr.js)). It''s
    a port of the popular SFXR. Sadly, it only works with Firefox''s Audio Data API.
    Nevertheless, I would encourage you to check it out!'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们大多讨论的是音乐。当然，相同的技术也可以用于播放音效。不过，处理它们的一个非常优雅的解决方案是：在运行时生成它们。这模仿了许多旧游戏主机上创建效果的方式。要在
    JavaScript 中执行此操作，您可以使用 `SFXR.js` ([https://github.com/humphd/sfxr.js](https://github.com/humphd/sfxr.js))。它是受欢迎的
    SFXR 的一个端口。不幸的是，它只能与 Firefox 的 Audio Data API 一起使用。尽管如此，我鼓励您去了解一下！
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You have now learned lots of different ways to play sounds in your games using
    standard APIs, plugins, and Flash libraries, and your head is probably hurting
    right now! The state of audio in the browser is not very nice at the moment, but
    in a few years, when the Web Audio API is supported across all browsers, we will
    be in a much better situation! So, I would recommend spending some time on learning
    it well even if it's slightly more complex than the HTML5 Audio element.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经学会了使用标准 API、插件和 Flash 库在游戏中播放声音的许多不同方法，你的脑袋现在可能有些疼了！目前浏览器中的音频状态并不是很好，但是在几年后，当
    Web Audio API 在所有浏览器中得到支持时，我们将处于一个更好的境地！因此，我建议花一些时间好好学习它，即使它比 HTML5 音频元素稍微复杂一些。
- en: You now have all the tools you need to create the perfect jQuery game! I really
    hope you enjoyed reading this book and that it will inspire you to create many
    wonderful games.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经拥有了创建完美的 jQuery 游戏所需的所有工具！我真诚地希望你喜欢阅读这本书，并且它将激励你创造许多精彩的游戏。
