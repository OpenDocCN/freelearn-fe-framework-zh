<html><head></head><body>
<div id="_idContainer072">
<h1 class="chapter-number" id="_idParaDest-153"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-154"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.2.1">Boosting Performance with Reactive Caching</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Caching data and assets is one of the most efficient ways to improve the user experience of our web applications. </span><span class="koboSpan" id="kobo.3.2">It’s a good way to speed up the load times of our web applications and keep the number of network requests to </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">a minimum.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We will start this chapter by defining the caching requirement for our application’s client side and looking at its motivation. </span><span class="koboSpan" id="kobo.5.2">Then, we will learn how to implement this requirement reactively using RxJS operators. </span><span class="koboSpan" id="kobo.5.3">After that, we will describe a better way to do this using the latest features of RxJS 7. </span><span class="koboSpan" id="kobo.5.4">Finally, we will highlight another use case of caching streams, which is for </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">side effects.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Defining the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">caching requirement</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Exploring the reactive pattern to </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">cache streams</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Highlighting the use of caching for </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">side effects</span></span></li>
</ul>
<h1 id="_idParaDest-155"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.15.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.16.1">This chapter assumes that you have a basic understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">of RxJS.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">The source code of this chapter is available </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">at</span></span><span class="No-Break"><span class="P---URL"> </span></span><a href="https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap10"><span class="No-Break"><span class="koboSpan" id="kobo.20.1">https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap10</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.21.1">.</span></span></p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.22.1">Defining the caching requirement</span></h1>
<p><span class="koboSpan" id="kobo.23.1">As you </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.24.1">have learned throughout the previous chapters, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.25.1">HTTPClient</span></strong><span class="koboSpan" id="kobo.26.1"> module is Observable-based, which means that methods such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.27.1">get</span></strong><span class="koboSpan" id="kobo.28.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.29.1">post</span></strong><span class="koboSpan" id="kobo.30.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.31.1">put</span></strong><span class="koboSpan" id="kobo.32.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">delete</span></strong><span class="koboSpan" id="kobo.34.1"> return an Observable. </span><span class="koboSpan" id="kobo.34.2">Subscribing multiple times to this Observable will cause the source Observable to be created repeatedly, hence performing a request on each subscription – as we learned in </span><a href="B21180_09.xhtml#_idTextAnchor146"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.35.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.36.1">, </span><em class="italic"><span class="koboSpan" id="kobo.37.1">Demystifying Multicasting</span></em><span class="koboSpan" id="kobo.38.1">, this means it is a cold Observable. </span><span class="koboSpan" id="kobo.38.2">This behavior will result in an overhead of HTTP requests, which may decrease the performance of your web applications, especially if the server takes some time </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">to respond.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">Reducing HTTP requests by caching the result on the client side is one of the most commonly used techniques to optimize web applications. </span><strong class="bold"><span class="koboSpan" id="kobo.41.1">Client-side caching</span></strong><span class="koboSpan" id="kobo.42.1"> involves </span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.43.1">storing previously requested data so that you don’t raise repetitive requests to the server and harm your </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">application’s performance.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">Let’s picture this with a streaming service scenario. </span><span class="koboSpan" id="kobo.45.2">Imagine that you’re watching your favorite TV show on a streaming service. </span><span class="koboSpan" id="kobo.45.3">When you start watching, the streaming service fetches the episodes from the internet and streams them to your device. </span><span class="koboSpan" id="kobo.45.4">Now, let’s say you want to rewind a bit and watch a scene again. </span><span class="koboSpan" id="kobo.45.5">Instead of fetching the episodes from the internet again, the streaming service has already stored the episodes you’ve watched in a special memory bank. </span><span class="koboSpan" id="kobo.45.6">This memory bank allows you to rewind and rewatch scenes without having to re-fetch them from </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">the internet.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">But when should we cache data? </span><span class="koboSpan" id="kobo.47.2">When data is shared (used by more than one component in your app) and doesn’t change frequently, it makes a lot of sense to cache it and share it among multiple components. </span><span class="koboSpan" id="kobo.47.3">For example, the user’s profile data is subject to caching. </span><span class="koboSpan" id="kobo.47.4">We </span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.48.1">generally retrieve the user’s profile information after they log in, and it won’t change during the </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">user’s session.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">Additionally, reference data, such as lists of countries, currencies, or categories, are subjects for caching. </span><span class="koboSpan" id="kobo.50.2">Since this doesn’t change frequently, you can cache it and share it among </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">multiple components.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">In the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">RecipesApp</span></strong><span class="koboSpan" id="kobo.54.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">/api/recipes</span></strong><span class="koboSpan" id="kobo.56.1"> GET request is called every time the </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">RecipesList</span></strong><span class="koboSpan" id="kobo.58.1"> component is rendered to load the list of recipes. </span><span class="koboSpan" id="kobo.58.2">In other words, whenever the user clicks on the recipe app's logo or navigates between </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">HomeComponent</span></strong><span class="koboSpan" id="kobo.60.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">RecipeCreationComponent</span></strong><span class="koboSpan" id="kobo.62.1">, a GET request will be issued, even if the list of recipes </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">hasn’t changed.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">The following screenshot shows the raised requests in the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.65.1">Network</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.66.1"> tab:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<span class="koboSpan" id="kobo.67.1"><img alt="Figure 10.1 – The GET HTTP requests and their overhead" src="image/B21180_10_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.68.1">Figure 10.1 – The GET HTTP requests and their overhead</span></p>
<p><span class="koboSpan" id="kobo.69.1">As you may have noticed, all those outgoing requests result from the navigation between </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">HomeComponent</span></strong><span class="koboSpan" id="kobo.71.1"> and the </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">other components.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">In this chapter, we will assume that the list of recipes does not change frequently. </span><span class="koboSpan" id="kobo.73.2">In this case, it is useless to </span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.74.1">request the server on every component’s load; it would be better to cache the result and read the data from the cache to enhance the performance and the </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">user experience.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">But what if there are new recipes? </span><span class="koboSpan" id="kobo.76.2">What about updates? </span><span class="koboSpan" id="kobo.76.3">Well, there are two techniques we can utilize to </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">handle updates:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.78.1">We could update the cache data after each interval of time to retrieve the most recent version of the data – this technique</span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.79.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">called </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.81.1">polling</span></strong></span></li>
<li><span class="koboSpan" id="kobo.82.1">We could place a server push notification to get real-time </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">updates instantly</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.84.1">In this chapter, to understand the caching behavior in RxJS through basic examples, we will keep it simple and implement </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.85.1">a client-side cache with and without a </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">refresh capability.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.87.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.88.1">Though we will cover the polling technique in this chapter, we will cover the second technique in </span><a href="B21180_11.xhtml#_idTextAnchor170"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.89.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.90.1">, </span><em class="italic"><span class="koboSpan" id="kobo.91.1">Processing </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.92.1">Real-Time Updates</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">So, without further</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.95.1"> ado, let’s look at how we can </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">implement this.</span></span></p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.97.1">Exploring the reactive pattern to cache streams</span></h1>
<p><span class="koboSpan" id="kobo.98.1">You’ll be glad to </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.99.1">know that RxJS ships with a very useful operator to implement a stream caching mechanism – this is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">shareReplay</span></strong><span class="koboSpan" id="kobo.101.1"> multicast operator. </span><span class="koboSpan" id="kobo.101.2">Let’s take </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">a look.</span></span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.103.1">The shareReplay operator</span></h2>
<p><span class="koboSpan" id="kobo.104.1">In RxJS, </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">shareReplay</span></strong><span class="koboSpan" id="kobo.106.1"> works</span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.107.1"> similarly to the streaming service memory bank, sharing an </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.108.1">Observable’s execution with multiple subscribers. </span><span class="koboSpan" id="kobo.108.2">When you subscribe to an Observable that uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">shareReplay</span></strong><span class="koboSpan" id="kobo.110.1">, it fetches the data, just like streaming a show. </span><span class="koboSpan" id="kobo.110.2">However, </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">shareReplay</span></strong><span class="koboSpan" id="kobo.112.1"> caches or remembers the emitted values from the Observable. </span><span class="koboSpan" id="kobo.112.2">If you subscribe again later, instead of fetching the data again, it replays the cached values from its </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">memory bank.</span></span></p>
<p><span class="koboSpan" id="kobo.114.1">This can be useful when you have multiple subscribers to an Observable, but you don’t want each subscriber to trigger a new data fetch. </span><span class="koboSpan" id="kobo.114.2">Instead, you want them to share the same set of data, like multiple viewers sharing the same TV show episodes. </span><span class="koboSpan" id="kobo.114.3">This can improve performance and reduce unnecessary data fetching in </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.116.1">So, in a nutshell, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">shareReplay</span></strong><span class="koboSpan" id="kobo.118.1"> operator does </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.120.1">Shares an Observable’s execution with </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">multiple subscribers</span></span></li>
<li><span class="koboSpan" id="kobo.122.1">Offers the possibility to replay a specified number of emissions to </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">the subscribers</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.124.1">Now, let’s see how we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">shareReplay</span></strong><span class="koboSpan" id="kobo.126.1"> operator for </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">our requirement.</span></span></p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.128.1">Using shareReplay in RecipesApp</span></h2>
<p><span class="koboSpan" id="kobo.129.1">Our goal is to</span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.130.1"> cache</span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.131.1"> the list of recipes in our </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.132.1">app. </span><span class="koboSpan" id="kobo.132.2">This is represented by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">recipes$</span></strong><span class="koboSpan" id="kobo.134.1"> stream defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">RecipesService</span></strong><span class="koboSpan" id="kobo.136.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.138.1">
export class RecipesService {
recipes$ = this.http.get&lt;Recipe[]&gt;(`${BASE_PATH}/recipes`);
}</span></pre> <p><span class="koboSpan" id="kobo.139.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">recipes$</span></strong><span class="koboSpan" id="kobo.141.1"> stream is initially a cold Observable, meaning the stream’s data is re-emitted for every subscriber, resulting in an overhead of HTTP requests. </span><span class="koboSpan" id="kobo.141.2">This is not what we want. </span><span class="koboSpan" id="kobo.141.3">We want to share the last stream’s emission with all subscribers – in other words, we want to transform the cold stream into a hot stream using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">shareReplay</span></strong><span class="koboSpan" id="kobo.143.1"> operator, </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.145.1">
export class RecipesService {
recipes$ =
this.http.get&lt;Recipe[]&gt;(`${BASE_PATH}/recipes`).pipe(
shareReplay(1));
}</span></pre> <p><span class="koboSpan" id="kobo.146.1">By </span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.147.1">passing </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">1</span></strong><span class="koboSpan" id="kobo.149.1"> as </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.150.1">an </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.151.1">argument, </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">shareReplay</span></strong><span class="koboSpan" id="kobo.153.1"> cached the last emission </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">recipes$</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">Now, let’s explain the complete </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">data-sharing workflow:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.159.1">First, </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">HomeComponent</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.161.1">is initialized.</span></span></li>
<li><span class="koboSpan" id="kobo.162.1">Then, </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">HomeComponent</span></strong><span class="koboSpan" id="kobo.164.1"> triggers the rendering of the child component – that </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">is, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">RecipesListComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.169.1"> loads the </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">recipes$</span></strong><span class="koboSpan" id="kobo.171.1"> Observable that’s available in </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">RecipeService</span></strong><span class="koboSpan" id="kobo.173.1">. </span><span class="koboSpan" id="kobo.173.2">It will perform the GET HTTP request to retrieve the list of recipes since this is the first time we have asked for </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">the data.</span></span></li>
<li><span class="koboSpan" id="kobo.175.1">Then, the cache will be initialized by the data coming back from </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">the server.</span></span></li>
<li><span class="koboSpan" id="kobo.177.1">The next time the data is requested, it will be retrieved from the cache thanks to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">shareReplay</span></strong><span class="koboSpan" id="kobo.179.1"> operator. </span><span class="koboSpan" id="kobo.179.2">Under</span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.180.1"> the hood, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">shareReplay</span></strong><span class="koboSpan" id="kobo.182.1"> operator creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">ReplaySubject</span></strong><span class="koboSpan" id="kobo.184.1"> instance that will replay the emissions of the source Observable with all future subscribers. </span><span class="koboSpan" id="kobo.184.2">After the first subscription, it will connect the subject to the source Observable and broadcast all </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">its values.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.186.1">This is the multicasting concept we explained in </span><a href="B21180_09.xhtml#_idTextAnchor146"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.187.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.188.1">, </span><em class="italic"><span class="koboSpan" id="kobo.189.1">Demystifying Multicasting</span></em><span class="koboSpan" id="kobo.190.1">. </span><span class="koboSpan" id="kobo.190.2">The next time we request </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.191.1">the </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.192.1">recipes</span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.193.1"> list, our cache will replay the most recent value and send it to the subscriber. </span><span class="koboSpan" id="kobo.193.2">No additional HTTP call is involved. </span><span class="koboSpan" id="kobo.193.3">So, when the user leaves the page, it unsubscribes and replays the values from </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">the cache.</span></span></p>
<p><span class="koboSpan" id="kobo.195.1">The following diagram also illustrates the </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">complete workflow:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<span class="koboSpan" id="kobo.197.1"><img alt="Figure 10.2 – ShareReplay execution" src="image/B21180_10_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.198.1">Figure 10.2 – ShareReplay execution</span></p>
<p><span class="koboSpan" id="kobo.199.1">This works perfectly fine when the data doesn’t need to be refreshed at all. </span><span class="koboSpan" id="kobo.199.2">But as described in the requirement, we need to refresh </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">RecipesList</span></strong><span class="koboSpan" id="kobo.201.1"> every interval. </span><span class="koboSpan" id="kobo.201.2">If the polling technique is used, we can update the cache </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.203.1">
import { switchMap, shareReplay, timer } from 'rxjs/operators';
const REFRESH_INTERVAL = 50000;
const timer$ = timer(0, REFRESH_INTERVAL);
export class RecipesService {
recipes$ = timer$.pipe(
    switchMap(_ =&gt;
    this.http.get&lt;Recipe[]&gt;(`${BASE_PATH}/recipes`)),
    shareReplay(1)
  );
}</span></pre> <p><span class="koboSpan" id="kobo.204.1">Here, we created a </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">timer$</span></strong><span class="koboSpan" id="kobo.206.1"> Observable that will emit every 50 seconds. </span><span class="koboSpan" id="kobo.206.2">This interval is configured in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">REFRESH_INTERVAL</span></strong><span class="koboSpan" id="kobo.208.1"> constant, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">timer</span></strong><span class="koboSpan" id="kobo.210.1"> function available in RxJS to create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">timer$</span></strong><span class="koboSpan" id="kobo.212.1"> Observable. </span><span class="koboSpan" id="kobo.212.2">For</span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.213.1"> more </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.214.1">details </span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.215.1">about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">timer</span></strong><span class="koboSpan" id="kobo.217.1"> function, please </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.218.1">refer </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">to </span></span><a href="https://rxjs.dev/api/index/function/timer#examples"><span class="No-Break"><span class="koboSpan" id="kobo.220.1">https://rxjs.dev/api/index/function/timer#examples</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.221.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.222.1">Then, for every emission, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">switchMap</span></strong><span class="koboSpan" id="kobo.224.1"> operator to transform the value into the Observable that’s returned by the HTTP client. </span><span class="koboSpan" id="kobo.224.2">This will issue an HTTP GET every 50 seconds and, consequently, update </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">the cache.</span></span></p>
<p><span class="koboSpan" id="kobo.226.1">This is a known RXJS pattern for executing a treatment every </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.227.1">x</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.228.1"> seconds.</span></span></p>
<p><span class="koboSpan" id="kobo.229.1">Now, let’s see how we can customize the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">shareReplay</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.231.1"> operator.</span></span></p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.232.1">Customizing the shareReplay operator</span></h2>
<p><span class="koboSpan" id="kobo.233.1">With RxJS 6.4.0, a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">shareReplay</span></strong><span class="koboSpan" id="kobo.235.1"> signature was provided to customize the operator’s behavior. </span><span class="koboSpan" id="kobo.235.2">The </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.236.1">new</span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.237.1"> signature takes a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">config</span></strong><span class="koboSpan" id="kobo.239.1"> parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">ShareReplayConfig</span></strong><span class="koboSpan" id="kobo.241.1"> type, </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.243.1">
function shareReplay&lt;T&gt;(config: ShareReplayConfig): MonoTypeOperatorFunction&lt;T&gt;;</span></pre> <p><span class="koboSpan" id="kobo.244.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">ShareReplayConfig</span></strong><span class="koboSpan" id="kobo.246.1"> interface contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">following properties:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.248.1">
interface ShareReplayConfig {
  refCount: boolean;
  bufferSize?: number;
  windowTime?: number;
  scheduler?: SchedulerLike;
}</span></pre> <p><span class="koboSpan" id="kobo.249.1">Let’s discover the purpose of </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">each property:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">refCount</span></strong><span class="koboSpan" id="kobo.252.1">: If </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">refCount</span></strong><span class="koboSpan" id="kobo.254.1"> is enabled (set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">true</span></strong><span class="koboSpan" id="kobo.256.1">), the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">shareReplay</span></strong><span class="koboSpan" id="kobo.258.1"> stream will unsubscribe from the source Observable when there are no subscribers. </span><span class="koboSpan" id="kobo.258.2">Therefore, the source will no longer emit. </span><span class="koboSpan" id="kobo.258.3">This means that if a new subscriber comes along later, then a new stream will be created that subscribes to the source Observable. </span><span class="koboSpan" id="kobo.258.4">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">refCount</span></strong><span class="koboSpan" id="kobo.260.1"> is disabled (set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">false</span></strong><span class="koboSpan" id="kobo.262.1">), the source will not be unsubscribed, meaning that the inner </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">ReplaySubject</span></strong><span class="koboSpan" id="kobo.264.1"> will still be subscribed to the source and potentially run forever. </span><span class="koboSpan" id="kobo.264.2">To avoid memory issues, it is highly recommended to set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">refCount</span></strong><span class="koboSpan" id="kobo.266.1"> property </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">bufferSize</span></strong><span class="koboSpan" id="kobo.271.1">: This refers to how many values you want to replay. </span><span class="koboSpan" id="kobo.271.2">For example, if you just want the one previous value to be replayed for each new subscriber to the shared stream, then you should mention </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">1</span></strong><span class="koboSpan" id="kobo.273.1"> as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">bufferSize</span></strong><span class="koboSpan" id="kobo.275.1"> value like so: </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">shareReplay({bufferSize: 1})</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">windowTime</span></strong><span class="koboSpan" id="kobo.279.1">: This refers to the time limit in milliseconds for data stored in the buffer to be emitted to </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">future subscribers.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">scheduler</span></strong><span class="koboSpan" id="kobo.282.1">: This is used to control the execution and provide a way to manage concurrency (for more details, please refer to the official </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">documentation: </span></span><a href="https://rxjs.dev/api/index/interface/SchedulerLike"><span class="No-Break"><span class="koboSpan" id="kobo.284.1">https://rxjs.dev/api/index/interface/SchedulerLike</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.285.1">).</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.286.1">In our case, we need to configure </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">bufferSize</span></strong><span class="koboSpan" id="kobo.288.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">1</span></strong><span class="koboSpan" id="kobo.290.1"> to store only the latest value and set </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">refCount</span></strong><span class="koboSpan" id="kobo.292.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">true</span></strong><span class="koboSpan" id="kobo.294.1"> to prevent </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">memory leaks.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">So, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">shareReplayConfig</span></strong><span class="koboSpan" id="kobo.298.1"> object, the final code of </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">RecipesService</span></strong><span class="koboSpan" id="kobo.300.1"> will look </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.302.1">
import { switchMap, shareReplay, timer } from 'rxjs/operators';
const REFRESH_INTERVAL = 50000;
const timer$ = timer(0, REFRESH_INTERVAL);
export class RecipesService {
recipes$ = timer$.pipe(
    switchMap(_ =&gt;
    this.http.get&lt;Recipe[]&gt;(`${BASE_PATH}/recipes`)),
    shareReplay({bufferSize: 1, refCount: true })
  );
}</span></pre> <p><span class="koboSpan" id="kobo.303.1">When using </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">shareReplay</span></strong><span class="koboSpan" id="kobo.305.1"> on</span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.306.1"> Observables </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.307.1">that don’t complete on their own, always consider the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">refCount</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.309.1"> flag.</span></span></p>
<p><span class="koboSpan" id="kobo.310.1">Now that we know the behavior of </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">shareReplay</span></strong><span class="koboSpan" id="kobo.312.1">, I want to shed light on an improvement that’s become available starting from RxJS 7 that allows you to replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">shareReplay</span></strong><span class="koboSpan" id="kobo.314.1"> operator with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">share</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.316.1"> operator.</span></span></p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.317.1">Replacing the shareReplay operator with the share operator</span></h2>
<p><span class="koboSpan" id="kobo.318.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">share</span></strong><span class="koboSpan" id="kobo.320.1"> operator</span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.321.1"> is </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.322.1">similar</span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.323.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">shareReplay</span></strong><span class="koboSpan" id="kobo.325.1"> but, by default, it doesn’t have a buffer and it doesn’t replay that buffer </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">on subscription.</span></span></p>
<p><span class="koboSpan" id="kobo.327.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">share</span></strong><span class="koboSpan" id="kobo.329.1"> operator, once the subscriber count reaches </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">0</span></strong><span class="koboSpan" id="kobo.331.1">, the source Observable automatically unsubscribes. </span><span class="koboSpan" id="kobo.331.2">On the other hand, when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">refCount</span></strong><span class="koboSpan" id="kobo.333.1"> option of </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">shareReplay</span></strong><span class="koboSpan" id="kobo.335.1"> is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">true</span></strong><span class="koboSpan" id="kobo.337.1">, it behaves similarly to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">share</span></strong><span class="koboSpan" id="kobo.339.1"> operator in terms of reference counting, but it also offers the ability to replay </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">emitted values.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">Here’s a table that compares </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">the two:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-2">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.343.1">Feature</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">share</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">shareReplay</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.346.1">Behavior</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.347.1">Creates a </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">multicast Observable.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.349.1">Creates a </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">multicast Observable.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.351.1">Replaying</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.352.1">Does not replay the previous </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">emission.</span></span></p>
<p><span class="koboSpan" id="kobo.354.1">It uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">Subjects</span></strong><span class="koboSpan" id="kobo.356.1"> under the </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">hood.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.358.1">Replays the latest or a specified number of previous emissions to </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">new subscribers.</span></span></p>
<p><span class="koboSpan" id="kobo.360.1">It uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">ReplaySubject</span></strong><span class="koboSpan" id="kobo.362.1"> under </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">the hood.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.364.1">Unsubscription logic</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.365.1">Unsubscribes when the last </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">subscriber unsubscribes.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.367.1">Offers a </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">refCount</span></strong><span class="koboSpan" id="kobo.369.1"> option to unsubscribe when the last subscriber unsubscribes. </span><span class="koboSpan" id="kobo.369.2">By default, </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">refCount</span></strong><span class="koboSpan" id="kobo.371.1"> is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">false</span></strong><span class="koboSpan" id="kobo.373.1">. </span><span class="koboSpan" id="kobo.373.2">However, if you keep it set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">false</span></strong><span class="koboSpan" id="kobo.375.1">, the source Observable will remain active even when the subscriber count reaches zero. </span><span class="koboSpan" id="kobo.375.2">This situation can be risky because if the source Observable never completes, it might lead to </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">memory leaks.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.377.1">Figure 10.3 – share and shareReplay comparison table</span></p>
<p><span class="koboSpan" id="kobo.378.1">In RxJS 7, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">share</span></strong><span class="koboSpan" id="kobo.380.1"> operator was enhanced with an optional configuration object as an argument, </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">share(config)</span></strong><span class="koboSpan" id="kobo.382.1">, which makes it more flexible and ready to do the job of other operators, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">shareReplay()</span></strong><span class="koboSpan" id="kobo.384.1">. </span><span class="koboSpan" id="kobo.384.2">In this configuration object, there are </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">four properties:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">Connector</span></strong><span class="koboSpan" id="kobo.387.1">: With this option, you can control whether or not </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">share</span></strong><span class="koboSpan" id="kobo.389.1"> will replay emissions. </span><span class="koboSpan" id="kobo.389.2">You can choose the subject type you’re connecting through (such </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">ReplaySubject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">).</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">resetOnRefCountZero</span></strong><span class="koboSpan" id="kobo.394.1">: With this option, you can control when your Observable should be reset. </span><span class="koboSpan" id="kobo.394.2">If this option is enabled and all the subscriptions of our Observable are</span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.395.1"> unsubscribed, the Observable is reset. </span><span class="koboSpan" id="kobo.395.2">However, if </span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.396.1">this option</span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.397.1"> is disabled, the subject will remain connected to </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">the source.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">resetOnComplete</span></strong><span class="koboSpan" id="kobo.400.1">: If enabled, the resulting Observable will reset </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">on completion.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">resetOnError</span></strong><span class="koboSpan" id="kobo.403.1">: If enabled, the resulting Observable will reset after </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">an error.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.405.1">So, </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">shareReplay</span></strong><span class="koboSpan" id="kobo.407.1"> is nothing but a </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">share</span></strong><span class="koboSpan" id="kobo.409.1"> operator that uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">ReplaySubject</span></strong><span class="koboSpan" id="kobo.411.1"> as a connector and a specific </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">reset strategy.</span></span></p>
<p><span class="koboSpan" id="kobo.413.1">The following code shows how we can achieve the behavior of the optimized </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">shareReplay</span></strong><span class="koboSpan" id="kobo.415.1"> operator by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">share</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.417.1">operator instead:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.418.1">
  recipes$ = timer$.pipe(
    switchMap(_ =&gt;
      this.http.get&lt;Recipe[]&gt;(`${BASE_PATH}/recipes`)),
    share({
      connector: () =&gt; new ReplaySubject(),
      resetOnRefCountZero: true,
      resetOnComplete: true,
      resetOnError: true
    })
  );</span></pre> <p><span class="koboSpan" id="kobo.419.1">The preceding code shows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">share</span></strong><span class="koboSpan" id="kobo.421.1"> operator with the same behavior as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">shareReplay</span></strong><span class="koboSpan" id="kobo.423.1"> operator. </span><span class="koboSpan" id="kobo.423.2">This is because we referenced </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">ReplaySubject</span></strong><span class="koboSpan" id="kobo.425.1"> as a connector, so we’re telling </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">share</span></strong><span class="koboSpan" id="kobo.427.1"> to use </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">replay logic.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">Then, for the reset strategy, we enabled all the reset options – </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">resetOnRefCountZero</span></strong><span class="koboSpan" id="kobo.431.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">resetOnComplete</span></strong><span class="koboSpan" id="kobo.433.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">resetOnError</span></strong><span class="koboSpan" id="kobo.435.1"> – to get optimized behavior and </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">enhanced performance.</span></span></p>
<p><span class="koboSpan" id="kobo.437.1">That’s it – by</span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.438.1"> using</span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.439.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">share</span></strong><span class="koboSpan" id="kobo.441.1"> operator, we </span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.442.1">can achieve the same behavior as the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">shareReplay</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.444.1"> operator!</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.445.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.446.1">Apart from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">shareReplay</span></strong><span class="koboSpan" id="kobo.448.1"> operator, a lot of work was done in RxJS 7 to consolidate multicasting operators. </span><span class="koboSpan" id="kobo.448.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">multicast</span></strong><span class="koboSpan" id="kobo.450.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">publish</span></strong><span class="koboSpan" id="kobo.452.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">publishReplay</span></strong><span class="koboSpan" id="kobo.454.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">publishLast</span></strong><span class="koboSpan" id="kobo.456.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">refCount</span></strong><span class="koboSpan" id="kobo.458.1"> operators were deprecated and will be removed in RxJS 8, and the only operators that will remain are </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">shareReplay</span></strong><span class="koboSpan" id="kobo.460.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">share</span></strong><span class="koboSpan" id="kobo.462.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">connectable</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.466.1">As we have seen in this section, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">share</span></strong><span class="koboSpan" id="kobo.468.1"> operator rules them all, meaning that in most cases, it is highly recommended to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">share</span></strong><span class="koboSpan" id="kobo.470.1"> operator instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">connectable</span></strong><span class="koboSpan" id="kobo.472.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">shareReplay</span></strong><span class="koboSpan" id="kobo.474.1">. </span><span class="koboSpan" id="kobo.474.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">shareReplay</span></strong><span class="koboSpan" id="kobo.476.1"> operator is too popular to deprecate but may be deprecated in future versions as there is an alternative to it, especially because </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">shareReplay</span></strong><span class="koboSpan" id="kobo.478.1">, when not used carefully, can cause memory leaks, particularly with </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">infinite streams.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.480.1">So, if you’re using RxJS 7, it is highly recommended to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">share</span></strong><span class="koboSpan" id="kobo.482.1"> operator instead </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">shareReplay</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.486.1">Now that we’ve learned how we can optimize HTTP requests by caching our data using </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">shareReplay</span></strong><span class="koboSpan" id="kobo.488.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">share</span></strong><span class="koboSpan" id="kobo.490.1"> operators and have put those operators in place in </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">RecipesApp</span></strong><span class="koboSpan" id="kobo.492.1"> to </span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.493.1">cache</span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.494.1"> the list of </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.495.1">recipes, let’s discover another situation where caching streams is </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">very useful.</span></span></p>
<h1 id="_idParaDest-162"><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.497.1">Highlighting the use of caching for side effects</span></h1>
<p><span class="koboSpan" id="kobo.498.1">The use case we covered in this chapter </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.499.1">involved optimizing HTTP requests to enhance our web applications’ performance. </span><span class="koboSpan" id="kobo.499.2">All you have to do is put the result in a cache, which acts as a shared place for </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">all consumers.</span></span></p>
<p><span class="koboSpan" id="kobo.501.1">There are other use cases where caching streams makes a lot of sense, namely when accounting for expensive side effects on the streams. </span><span class="koboSpan" id="kobo.501.2">In general, we call the actions that we perform after a value is</span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.502.1"> emitted </span><strong class="bold"><span class="koboSpan" id="kobo.503.1">side effects</span></strong><span class="koboSpan" id="kobo.504.1">. </span><span class="koboSpan" id="kobo.504.2">This could be logging, displaying messages, doing a mapping, and </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.506.1">Here’s an example of a side effect using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">tap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.508.1"> operator:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.509.1">
import {map, from } from 'rxjs';
import { tap } from 'rxjs/operators';
const stream$ = from([1, 2, 'Hello', 5]);
stream$
  .pipe(
    tap((value) =&gt; console.log(value)),
    map((element) =&gt; {
      if (isNaN(element as number)) {
        throw new Error(element + ' is not a number');
      }
      return (element as number) * 2;
    })
  )
  .subscribe({
    next: (message) =&gt; console.log(message),
    error: (error) =&gt; console.log(error),
    complete: () =&gt; console.log('Stream Completed'),
  });
//console output
1
2
2
4
Hello
Error</span></pre> <p><span class="koboSpan" id="kobo.510.1">In the preceding code, we</span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.511.1"> are performing a transformation for every number that’s emitted, multiplying it by 2, and returning the multiplied value. </span><span class="koboSpan" id="kobo.511.2">If the value is not a number, an error is thrown. </span><span class="koboSpan" id="kobo.511.3">However, we need to log the initial value before the transformation. </span><span class="koboSpan" id="kobo.511.4">That’s why we called the </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">tap</span></strong><span class="koboSpan" id="kobo.513.1"> operator before the </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">map</span></strong><span class="koboSpan" id="kobo.515.1"> operator – so that we can log the original value. </span><span class="koboSpan" id="kobo.515.2">This is a basic example of a side effect, but others could also occur, such as handling errors or </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">displaying messages.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.517.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.518.1">For further details </span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.519.1">about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">tap</span></strong><span class="koboSpan" id="kobo.521.1"> operator, please refer to the official </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">documentation: </span></span><a href="https://rxjs.dev/api/operators/tap"><span class="No-Break"><span class="koboSpan" id="kobo.523.1">https://rxjs.dev/api/operators/tap</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.524.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">In some situations, side effects can perform other actions that are more complex than logging, such as displaying messaging and handling errors. </span><span class="koboSpan" id="kobo.525.2">This can include some computations that represent an expensive treatment in terms of performance. </span><span class="koboSpan" id="kobo.525.3">Unfortunately, every subscriber will execute those treatments, even though it is enough to run them only once. </span><span class="koboSpan" id="kobo.525.4">Otherwise, it will harm the performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.527.1">If you have this use</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.528.1"> case in your application, it is highly recommended that you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">share</span></strong><span class="koboSpan" id="kobo.530.1"> operator to cache the result and execute heavy treatments </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">only once.</span></span></p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.532.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.533.1">In this chapter, we explained various caching concepts in web applications, including their benefits and use cases. </span><span class="koboSpan" id="kobo.533.2">We focused on a concrete example in our recipe app, detailed the requirement, and implemented it reactively. </span><span class="koboSpan" id="kobo.533.3">Through this, we learned about the behavior of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">shareReplay</span></strong><span class="koboSpan" id="kobo.535.1"> operator, as well as the alternative implementation – that is, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">share</span></strong><span class="koboSpan" id="kobo.537.1"> operator in RxJS 7. </span><span class="koboSpan" id="kobo.537.2">Finally, we highlighted how caching can help us when we have heavy side effects in </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">our app.</span></span></p>
<p><span class="koboSpan" id="kobo.539.1">In the next chapter, we will explore the reactive pattern for </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">bulk operations.</span></span></p>
</div>
</body></html>