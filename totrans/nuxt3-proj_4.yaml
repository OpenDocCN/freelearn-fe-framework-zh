- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Weather Dashboard – Data Fetching and State Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we venture into [*Chapter 4*](B19760_04.xhtml#_idTextAnchor080) of our Nuxt
    3 exploration, we’re setting our sights on constructing a practical weather dashboard.
    Our journey starts with **Nuxt UI**, Nuxt’s official UI library, which simplifies
    the creation of stunning and responsive web applications. Nuxt UI offers a comprehensive
    collection of fully styled and customizable UI components, specifically designed
    for Nuxt. We’ll explore how to import Nuxt UI into our project and use its components.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll discuss data fetching in general. This will lay the groundwork for
    understanding how to retrieve and handle data dynamically in a Nuxt application.
    Specifically, we’ll use the **OpenWeatherMap** API in our project, providing a
    real-world context for our data fetching practices.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we’ll master `$fetch` for efficient data fetching. By fetching
    real weather data from the OpenWeatherMap API, you’ll learn how to display this
    information effectively and responsively.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will guide you through state management using **Pinia**. This approach
    centralizes and manages the state of your application’s data, facilitating easy
    access and manipulation of weather data across different components without the
    complexities of prop drilling.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the weather dashboard application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Nuxt UI in the weather dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring data fetching with `$fetch` in Nuxt 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating with the Pinia store to monitor city and weather data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter can be found at [https://github.com/PacktPublishing/Nuxt-3-Projects/tree/main/chapter04](https://github.com/PacktPublishing/Nuxt-3-Projects/tree/main/chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: The CiA video for this chapter can be found on [https://packt.link/1uNS1](https://packt.link/1uNS1)
  prefs: []
  type: TYPE_NORMAL
- en: Essential background – understanding Nuxt 3 Data Fetching and State Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before diving into the practical application, let’s build a solid foundation
    in two key areas – data fetching with Nuxt UI and state management using Pinia:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$fetch`, which simplifies the process of fetching and displaying data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State management with Pinia**: Pinia is a state management library designed
    for Vue applications, offering a more intuitive and straightforward approach than
    its predecessor, Vuex. With Pinia, you can centralize and manage the application’s
    state, facilitating data sharing across components without prop drilling. Pinia
    also offers API-style composition. More details can be found on Pinia’s official
    websi[te at https://pinia.vuej](https://pinia.vuejs.org/)s.org/.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we’ve covered those two areas, let’s start by setting up our weather
    dashboard application.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s kick off by creating our new project named weather-sky:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After initializing, navigate to the project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will incorporate `@nuxtjs/google-fonts` for our font needs. However,
    diverging from our usual path of adding Tailwind CSS, we’ll introduce Nuxt UI
    to our toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s install these packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once installed, open `nuxt.config.ts` and add both `@nuxtjs/google-fonts` and
    `@nuxt/ui` to the `modules` array, integrating them into our project setup.
  prefs: []
  type: TYPE_NORMAL
- en: Before implementing Nuxt UI theming, we’ll create a `tailwind.config.ts` file
    and include our standard configurations. However, this time, we won’t define the
    colors in the Tailwind configuration. Instead, we’ll leverage Nuxt UI theming
    capabilities to set this color. We’ll learn how to do that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how the `tailwind.config.ts` might look without adding the colors option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s integrate the Roboto font into our project. We do this by updating
    the `nuxt.config.ts` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s add a title in `app.vue` and see how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: Weather Sky initial page](img/B19760_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Weather Sky initial page'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Nuxt UI uses the system’s default color scheme. As a result, you might notice
    that the color of your app appears dark instead of light if you do not specify
    a custom color. This behavior ensures that your app automatically aligns with
    the user’s preferred theme.
  prefs: []
  type: TYPE_NORMAL
- en: To verify the font, a handy Chrome extension called **WhatFont** can be used.
    WhatFont is an efficient tool for quickly identifying the fonts used on web pages.
    It’s a great aid for designers and developers to confirm font choices and styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using WhatFont on our website, if you click on the extension icon and
    select the title, it will display the font details. In our case, it should confirm
    the use of **Roboto** with a weight of **400**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: The WhatFont extension](img/B19760_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: The WhatFont extension'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up our project, our next step is to integrate with Nuxt UI
    and make use of its features and components.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Nuxt UI in the weather dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nuxt UI is an official UI library from Nuxt, designed to enhance the user interface
    experience in Nuxt applications. It offers a range of features, including fully
    styled and customizable components, support for dark mode, keyboard shortcuts,
    and support for both left-to-right and right-to-left languages. Built with Headless
    UI and Tailwind CSS, Nuxt UI provides a robust framework for creating intuitive
    and visually appealing user interfaces in Nuxt apps. You can read more about it
    on the official website: [https://ui.nuxt.com/](https://ui.nuxt.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s go back to our project and start learning about Nuxt UI theming.
    We’ll utilize `app.config.ts` to define the primary color, integrating our design
    preferences within the Nuxt ecosystem. Here’s how we set it up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `app.config.ts` file is a central UI configuration file, offering dynamic
    theming capabilities. This flexibility enables us to tailor our application’s
    theme and component styles on the fly. By setting theme colors and integrating
    with Tailwind CSS, we gain access to a broader color palette, enhancing our design
    options. Moreover, the `ui` property provides specific component customizations,
    allowing for a personalized and coherent user interface. As we progress, we will
    explore, in detail, how to use this file to customize our components’ design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s put our Nuxt UI integration to the test and start using some of its components
    in our `app.vue` file. The following code snippet shows how to create a basic
    layout with a weather card:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this template, we use the `<u-container>` component from Nuxt UI, which provides
    a containerized space for our content. The `<u-card>` component within it is where
    we display our weather data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output of our updated Nuxt UI integration in the `app.vue` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: Nuxt UI integration](img/B19760_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Nuxt UI integration'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s consider enhancing our layout further. Suppose we want to add vertical
    spacing to the container. Typically, we could do this by adding the `py-6` class
    directly in our template. But what if we aim for a more streamlined approach,
    where this spacing becomes a default style for all containers in our application?
    This is where the power of component customization in Nuxt UI truly shines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nuxt UI allows us to override and customize component styles globally via the
    `app.config.ts` file. By doing this, we ensure consistent styling across our application
    without repeatedly adding the same class in different components. Here’s how we
    can achieve this for our `container` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this configuration, we’ve added a padding `property` to the `container`
    configuration within the `ui` property, based on the configuration options available
    for the `u-container` component, which we can find detailed here: https://ui.nuxt.com/layout/container#config.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: After modifying the configuration, it may be necessary to restart your development
    server to apply and view the changes in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, every time we use the `<u-container>` component in our application, it
    will automatically include this vertical padding, creating a consistent look and
    feel throughout the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now customize the `u-card` component and remove the shadow. This is done
    via the `app.config.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this configuration, we’re setting the `base` property to `'overflow-visible
    mb-6'`. This adjusts the default layout of the card, allowing for visible overflow
    and adding a margin at the bottom. Additionally, we’re applying `'shadow-none'`
    to the `shadow` property, effectively removing the default shadow from all cards.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll explore data fetching with `$fetch` in Nuxt 3, diving into how to
    efficiently fetch and manage data in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring data fetching with $fetch in Nuxt 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Nuxt 3, data fetching is a pivotal aspect that is managed using composables
    that work in both browser and server environments. Nuxt offers three primary tools
    for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '`useFetch`: This is the most straightforward method for data fetching within
    a component’s setup function, typically used for retrieving essential data for
    the component’s initial state. But in our project, we’ll work with more complex
    methods: `useAsyncData` and `$fetch`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useAsyncData`: This is like `useFetch` but includes additional logic for more
    complex data fetching scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$fetch`: This is a part of the `ofetch` library and is a versatile fetch API
    that works across Node.js, browsers, and workers. It features smart JSON parsing,
    automatic stringification for JSON bodies, user-friendly error handling, auto
    retry capabilities, and configurable timeouts. This makes `$fetch` a robust tool
    for efficient, reliable network requests in various environments. You can read
    more about it at https://github.com/unjs/ofetch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s progress with the next steps in our Nuxt 3 project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an account on OpenWeatherMap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**OpenWeatherMap** offers a comprehensive suite of weather APIs, providing
    real-time data for our weather dashboard.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can fetch weather data, it’s essential to have access to OpenWeatherMap’s
    APIs. Begin by creating an account on OpenWeatherMap. Go to their sign-up page:
    [https://openweathermap.org/register](https://openweathermap.org/register), provide
    the required details, and create your account. Once your account is set up, go
    to the dropdown menu under your username and navigate to the **My API keys** page,
    then generate a new key. Remember to copy this key, as it will be crucial for
    accessing the APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll focus on two APIs from OpenWeatherMap:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Geocoding API**: This API enables location searches, allowing users to find
    specific cities or regions. You can find the full documentation here: [https://openweathermap.org/api/geocoding-api](https://openweathermap.org/api/geocoding-api).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One Call API**: This provides detailed weather information for the searched
    location, offering current weather information, data forecasts, and more. For
    more info, visit [https://openweathermap.org/api/one-call-3](https://openweathermap.org/api/one-call-3).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To utilize the Geocoding API from OpenWeatherMap, we’ll implement a test scenario
    using `$fetch` in our Nuxt application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `app.vue`, create a script, then define a function that will use `$fetch`
    to call the Geocoding API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the breakdown of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: This function performs a lookup for cities using the OpenWeatherMap Geocoding
    API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `query` parameter is used to search for the name of the city or a part of
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `limit=5` parameter in the URL limits the number of results to five
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t forget to replace `apiKey` with your actual key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, invoke this function with a sample location query to test the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a similar output to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: Geocoding API response](img/B19760_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Geocoding API response'
  prefs: []
  type: TYPE_NORMAL
- en: With the successful testing of the API, let’s define types for the responses
    from OpenWeatherMap.
  prefs: []
  type: TYPE_NORMAL
- en: Defining global types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having previously discussed TypeScript types, we will now focus on defining
    them for the responses from OpenWeatherMap APIs. Anticipating the structure of
    the data we’ll receive from the API is crucial for type-safe development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inspecting the console output reveals that the `city` object contains specific
    fields. To handle this data effectively, we create an `index.ts` file in a `types`
    folder with the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we learned in the previous chapter, by exporting an empty object and declaring
    a global object that contains the `CityData` type, we’ve made these types globally
    available in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s enhance our application’s configuration strategy and find a way to
    save our API key.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing useRuntimeConfig to expose configuration within the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`useRuntimeConfig` is a composable in Nuxt 3 designed for accessing runtime
    configurations. This feature enables the global and centralized management of
    configuration values, such as API keys, across your application.'
  prefs: []
  type: TYPE_NORMAL
- en: Runtime configurations are stored in `nuxt.config.ts` using the `runtimeConfig`
    attribute. You can define a secret key, which will be accessible only on the server,
    or public keys. In our case, we’ll define the API key as a public key to be accessible
    on the client side, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `nuxt.config.ts` by adding the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we’ll update the `citiesLookup` method to retrieve the API key via `useRuntimeConfig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After updating, we’ll retest to ensure that the function remains effective with
    the new configuration setup. It should yield the same result. If you encounter
    a `401` error, it indicates an incorrect or invalid API key. In this case, debug
    the runtime configuration to verify that the key is displayed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll enhance our dashboard with a dynamic city search feature using Nuxt
    UI’s `SelectMenu` component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the CitiesLookup component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll build the `CitiesLookup` component, a key feature of our weather dashboard.
    Utilizing Nuxt UI’s `SelectMenu` component will enable users to dynamically search
    for cities. The integration of asynchronous search capabilities will create a
    seamless and intuitive user experience. First, let’s create the `CitiesLookup`
    component inside the `components` folder. Then, add the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This part sets up the UI for city searching. `USelectMenu` is bound to `activeCity`
    for capturing the user’s selection. The `:searchable` attribute is linked to the
    `citiesLookup` function, which we will see in the `script` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: We started by employing `useRuntimeConfig` to access the API key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also defined `activeCity` to store and react to the user’s selection from
    the drop-down menu.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `citiesLookup` function, which we initially tested in the previous section,
    is now adapted to fetch city data and format it for the `USelectMenu` component.
    First, we skip the fetch if the query is empty. The response from the Geocoding
    API is mapped to include a label for each city, combining the city name and country.
    This labeling is crucial for the `USelectMenu` component to display the options
    correctly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `:searchable` prop on `USelectMenu` takes our `citiesLookup` function. This
    setup creates a dynamic, asynchronous search feature where the drop-down menu
    options update in real time based on the user’s input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CityData` type is recognized directly without importing it, thanks to our
    global declaration approach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have our `CitiesLookup` component ready, let’s integrate it into
    the main application view. Here’s how we can incorporate it into `app.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `CitiesLookup` component in place, users can now search for a city
    such as `London`. The following screenshot illustrates performing such a search:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: CityLookup component](img/B19760_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: CityLookup component'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will focus on displaying the weather data for the selected city. This
    will involve fetching the weather data from the OpenWeatherMap API and presenting
    it in a user-friendly format on our dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep our application reactive, we need a mechanism to detect when a user
    selects a different city. This can be achieved by adding an event listener. `@update:modelValue`
    emits a `change` event whenever the `activeCity` value is updated. In `CitiesLookup`,
    update the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This emit will dispatch the newly selected city, contained within the `$event`
    parameter, to the parent component. In the `<script>` section, we declare the
    event emitter like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In `app.vue`, we’re set to catch the city selection updates. We listen for
    the `change` event emitted by our `CitiesLookup` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `<script>` section, we define the `onCityChanged` function, which
    will handle the event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Selecting **London** from the search results now logs the city details to the
    console, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: Listening to CitiesLookup change](img/B19760_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Listening to CitiesLookup change'
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, we’re prepared to fetch and display the weather data using
    OpenWeatherMap’s One Call API for the chosen city.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching the weather data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the city selected, the next step is to retrieve the weather details. Using
    the latitude and longitude from the selected city’s data, we will call the One
    Call API from OpenWeatherMap. For more information, visit the One Call API documentation
    link: [https://openweathermap.org/api/one-call-3](https://openweathermap.org/api/one-call-3).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is `app.vue` after implementing the `onCityChanged` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break the code down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`weatherData` is a reactive `ref` that will hold the fetched weather information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loading` is a flag indicating whether the data fetching is in progress'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onCityChanged` is an async function triggered when a new city is selected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API request is made with the selected city’s latitude and longitude
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On success, `weatherData` is populated with the weather response; if there’s
    an error, it’s logged to the console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We print the result to the console to inspect it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, in the application, by searching for `London` and selecting the first
    result, we observe the following output in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7: One Call API response](img/B19760_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: One Call API response'
  prefs: []
  type: TYPE_NORMAL
- en: 'The response will contain three types of weather data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Current weather**: Immediate weather conditions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hourly forecast**: Weather predictions broken down by hour'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Daily forecast**: Comprehensive weather outlook for the next 7 days'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the full details about the response in the API documentation. After
    examining the One Call API response from OpenWeatherMap, I have crafted specific
    types to represent the structure of the weather data – `WeatherDataResponse`,
    `HourlyWeather`, `DailyWeather`, and `Weather` – and added them to the `types/index.ts`
    file. They can be found in the project repository.
  prefs: []
  type: TYPE_NORMAL
- en: Each type reflects the various aspects of weather data, such as current conditions,
    hourly forecasts, and daily predictions.
  prefs: []
  type: TYPE_NORMAL
- en: This data, while accessible in the parent and child components, hints at increasing
    complexity as our application grows. To streamline state management and data flow,
    we turn to Pinia. This state management library offers a centralized store for
    our application’s reactive state, allowing for more organized and maintainable
    data handling. In the following section, we’ll delve into how Pinia can enhance
    our application’s architecture, then we’ll create components to display the weather
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with the Pinia store to monitor city and weather data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we’ve seen, managing data across components can get complex. To simplify
    this, we introduce Pinia: Vue’s state management solution that allows for a centralized
    and reactive state. For a deep dive into Pinia and its features, visit the official
    Pinia documentation: [https://pinia.vuejs.org/](https://pinia.vuejs.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s apply our knowledge and create our first store with Pinia to manage
    city and weather data efficiently. This practice will improve data handling in
    our application, making it more efficient and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Pinia and creating the first store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, install Pinia by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, update `nuxt.config.ts` and Include Pinia in the `modules` array to ensure
    that it’s loaded into your Nuxt application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a new directory in the root folder of the project, call it `stores`,
    and add a `weather.ts` file in which we’ll define the store. Within the file,
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Pinia offers two ways to define a store:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Options stores**: An object-based declaration, providing a familiar API for
    those used to Vue’s Options API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Setup stores**: Utilizes Vue’s Composition API, allowing for a more composable
    and reactive approach'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our weather application, we’ve chosen the setup store method, leveraging
    the Composition API’s full potential for a more flexible state management experience.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Reactive States and Functions in Pinia Store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our `weather.ts` store, we first establish reactive references – `activeCity`
    and `weatherData` – akin to how we would in the Composition API. These references
    will hold the currently selected city and weather information, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we migrate the `citiesLookup` function from the `CitiesLookup` component
    to our store, ensuring that it retrieves the API key from the runtime configuration.
    This function fetches and formats city data for `SelectMenu`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we introduce `getWeatherData`, a function to fetch weather details
    based on the selected city (as we did in the `app.vue` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the final step, we make sure to return all these references and functions
    from the store, making them accessible throughout the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the complete setup of our `weather.ts` store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Refactoring components for Pinia store integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our `CitiesLookup` component, thanks to `@nuxt/pinia`, all stores located
    in the `/stores` directory are automatically imported throughout the app. This
    eliminates the need for manual imports. By calling `useWeatherStore`, we gain
    access to the store defined in the Pinia store directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We then replace the local `citiesLookup` function with the one from the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When integrating our components with the Pinia store, a key consideration is
    maintaining reactivity when using store properties. Directly destructuring properties
    from the store, as in the following code, can lead to a loss of reactivity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where `storeToRefs` from Pinia becomes crucial. `storeToRefs` is a
    method that ensures reactivity is preserved when we extract properties from a
    store. By using the following code, we can destructure properties such as `activeCity`
    while maintaining their reactive nature, as demonstrated in the updated `CitiesLookup`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When you use `@pinia/nuxt` version `0.5.1` or later, `storeToRefs` is automatically
    imported. There’s no need to import it manually into your components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the final version of `CitiesLookup.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Refactoring `app.vue` to utilize our Pinia store involves updating the `onCityChanged`
    function. Here’s how the script now looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this refactored version, `activeCity` no longer needs to be passed as a parameter.
    Instead, we obtain a reactive reference to `activeCity` from the weather store
    using `storeToRefs`. Additionally, the weather data fetching is now handled directly
    by the `getWeatherData` method in the weather store, streamlining the component
    and centralizing the logic in the store. This approach simplifies `app.vue`, keeping
    it clean and focused on the UI logic.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve refactored our components to use the Pinia store, it’s time to
    test the application and ensure that everything functions seamlessly. Once we
    confirm the smooth operation of these updates, we’ll move on to our next challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing weather data widget components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having ensured that our application functions smoothly with the integrated Pinia
    store, we now turn our attention to developing the weather data display. As part
    of this process, we will be using `dayjs`, as we did in the previous chapter,
    to handle date and time formatting within our components.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by installing `dayjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Then, let’s create `EmptyPlaceholder.vue`, a component that provides a friendly
    message when no weather data is available. This placeholder will be displayed
    if there’s no active city selected or while the weather data is loading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the component’s template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This component is then integrated into `app.vue`, specifically under the `u-card`
    section, ensuring that it’s only visible when there’s no weather data or during
    loading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To enhance the user experience during data loading, we’ll implement a `loading`
    skeleton card. This feature provides a visual cue that content is being loaded.
    Here’s the updated `app.vue` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The added code creates a pulsing effect on two `div` elements, simulating the
    space where the weather data cards will appear once the data is loaded. `v-if="loading"`
    ensures that this skeleton is only visible during the loading phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving forward, we’ll develop a comprehensive display of weather data in `app.vue`.
    This includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Current weather**: The current weather conditions, including temperature,
    weather description, and relevant icons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hourly forecast**: A scrollable view of the hourly weather forecast. Each
    card in this section will detail the weather conditions for a specific hour.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**7-day forecast**: A grid layout presenting the 7-day weather forecast.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s begin with the `CurrentWeatherData.vue` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: The `template` section displays the current temperature in a large, bold font.
    It also shows a description of the current weather, as well as an image of the
    weather icon, sourced from OpenWeatherMap, corresponding to the current weather
    condition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `script` section accesses the reactive version of `weatherData` from the
    weather store using `storeToRefs`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s proceed to `HourlyWeatherCard.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This component is structured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It displays hourly forecasts in a `flex` container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses `dayjs` to convert and format the Unix timestamp, `(hour.dt)`, into
    a readable time format, `(HH:mm)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It includes weather information such as an image and description for the specific
    hour
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It utilizes `defineProps` to ensure that the component receives the correct
    `HourlyWeather` data type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that we need to loop over the hour data array in `app.vue` and call
    this component for each data item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s look at `ForecastCard.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Like `HourlyWeatherCard`, this component will be used in `app.vue`, looping
    over each item in the daily weather data array to dynamically present each day’s
    forecast.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all components created, let’s add them to `app.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`u-card` displays the selected city’s name and country'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `current-weather-data` component shows the current weather conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A horizontal slider, containing `hourly-weather-card` components, presents the
    hourly forecast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 7-day forecast is laid out in a grid, with each `forecast-card` component
    representing a day’s weather
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, it’s time to test the application to ensure that all components are functioning
    as expected. Check the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No active city**: Verify the display when no city is selected:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.8: No active city](img/B19760_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: No active city'
  prefs: []
  type: TYPE_NORMAL
- en: '**Loading state**: Observe the loading skeleton when data is being fetched:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.9: Loading state](img/B19760_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Loading state'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data display**: Ensure that all weather data is correctly displayed when
    a city is selected:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.10: Data display](img/B19760_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: Data display'
  prefs: []
  type: TYPE_NORMAL
- en: With all the pieces now in place, our weather dashboard in `app.vue` stands
    as a testament to our combined efforts and technical prowess. Congratulations
    on reaching this significant milestone!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the construction of a weather dashboard using Nuxt
    3, starting with the sleek and user-friendly Nuxt UI. Our journey included practical
    data fetching with the OpenWeatherMap API and efficient use of `$fetch` for dynamic
    data presentation. The chapter culminated with the integration of Pinia for centralized
    state management, making the handling of weather data across components simpler
    and more efficient. This chapter was designed to enhance your skills in building
    advanced, real-world applications with Nuxt 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we proceed to [*Chapter 5*](B19760_05.xhtml#_idTextAnchor101), we shift
    gears to a new challenge: constructing a community forum website with Nuxt 3\.
    This chapter will guide you through the intricacies of user registration, login,
    and post creation. We’ll dive into implementing robust authentication to secure
    the website, ensuring that features such as post creation are exclusive to registered
    users. You’ll learn practical skills such as form validation, exploring authentication
    strategies, and managing access tokens with cookies. Additionally, we’ll delve
    into configuring middleware for protected routes, cementing your understanding
    of web application security and user management in Nuxt 3.'
  prefs: []
  type: TYPE_NORMAL
- en: Practice questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do you integrate Nuxt UI into a Nuxt 3 project?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you customize the primary color in Nuxt UI?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is `$fetch`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you define a global type without needing to import it each time?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the purpose of the `useRuntimeConfig` composable in Nuxt 3?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the benefits of using Pinia for state management in Nuxt?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain the use of `storeToRefs` in a Nuxt 3 application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you ensure reactivity when using a global state from a Pinia store?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nuxt UI: [https://ui.nuxt.com/](https://ui.nuxt.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nuxt data fetching: [https://nuxt.com/docs/getting-started/data-fetching](https://nuxt.com/docs/getting-started/data-fetching)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pinia: [https://pinia.vuejs.org](https://pinia.vuejs.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenWeatherMap API: [https://openweathermap.org/api](https://openweathermap.org/api)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JavaScript asynchronous programming and promises: [https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Day.js documentation: [https://day.js.org/](https://day.js.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
