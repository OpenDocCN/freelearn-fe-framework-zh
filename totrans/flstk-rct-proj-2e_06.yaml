- en: Adding a React Frontend to Complete MERN
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A web application is incomplete without a frontend. It is the part that users
    interact with and it is crucial to any web experience. In this chapter, we will
    use React to add an interactive user interface to the basic user and auth features
    that have been implemented for the backend of the MERN skeleton application, which
    we started building in the previous chapter. This functional frontend will add
    React components that connect to the backend API and allow users to navigate seamlessly
    within the application based on authorization. By the end of this chapter, you
    will have learned how to easily integrate a React client-side with a Node-Express-MongoDB
    server-side to make a full-stack web application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Frontend features of the skeleton
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up development with React, React Router, and Material-UI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a home page built with React
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backend user API integration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auth integration for restricted access
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User list, profile, edit, delete, sign up, and sign in UI to complete the user
    frontend
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic server-side rendering
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the skeleton application frontend
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to fully implement the skeleton application features we discussed
    in the *Feature breakdown* section of Chapter 3, *Building a Backend with MongoDB,
    Express, and Node*, we will add the following user interface components to our
    base application:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '**Home page**: A view that renders at the root URL to welcome users to the
    web application.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sign-up page**: A view with a form for user sign-up, allowing new users to
    create a user account and redirecting them to a sign-in page when successfully
    created.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sign-in page**: A view with a sign-in form that allows existing users to
    sign in so they have access to protected views and actions.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User list page**: A view that fetches and shows a list of all the users in
    the database, and also links to individual user profiles.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Profile page**: A component that fetches and displays an individual user''s
    information. This is only accessible by signed-in users and also contains edit
    and delete options, which are only visible if the signed-in user is looking at
    their own profile.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edit profile page**: A form that fetches the user''s information to prefill
    the form fields. This allows the user to edit the information and this form is
    accessible only if the logged-in user is trying to edit their own profile.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delete user component**: An option that allows the signed-in user to delete
    their own profile after confirming their intent.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Menu navigation bar**: A component that lists all the available and relevant
    views to the user, and also helps to indicate the user''s current location in
    the application.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following React component tree diagram shows all the React components we
    will develop to build out the views for this base application:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbd95d4d-c412-47f9-af09-4e8e52f511aa.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: '**MainRouter** will be the main React component. This contains all the other
    custom React views in the application. **Home**, **Signup**, **Signin**, **Users**,
    **Profile**, and **EditProfile** will render at individual routes declared with
    React Router, whereas the **Menu** component will render across all these views. **DeleteUser**
    will be a part of the **Profile** view.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The code discussed in this chapter, as well as the complete skeleton, is available
    on GitHub at [https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter03%20and%2004/mern-skeleton](https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter03%20and%2004/mern-skeleton).
    You can clone this code and run the application as you go through the code explanations
    in the rest of this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: In order to implement these frontend React views, we will have to extend the
    existing project code, which contains the standalone server application for the
    MERN skeleton. Next, we'll take a brief look at the files that will make up this
    frontend and that are needed to complete the full-stack skeleton application code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Folder and file structure
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following folder structure shows the new folders and files to be added
    to the skeleton project we started implementing in the previous chapter, in order
    to complete it with a React frontend:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `client` folder will contain the React components, helpers, and frontend
    assets, such as images and CSS. Besides this folder and the Webpack configuration
    files for compiling and bundling the client code, we will also modify some of
    the other existing files to finish up the integration of the complete skeleton
    application in this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Before we start implementing the specific frontend features, we need to get
    set up for React development by installing the necessary modules and adding configuration
    to compile, bundle, and load the React views. We will go through these setup steps
    in the next section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Setting up for React development
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can start developing with React in our existing skeleton codebase,
    we need to add configuration to compile and bundle the frontend code, add the
    React-related dependencies that are necessary to build the interactive interface,
    and tie this all together in the MERN development flow.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we will add frontend configuration for Babel, Webpack, and
    React Hot Loader to compile, bundle, and hot reload the code. Next, we will modify
    the server code to initiate code bundling for both the frontend and backend in
    one command to make the development flow simple. Then, we will update the code
    further so that it serves the bundled code from the server when the application
    runs in the browser. Finally, we will finish setting up by installing the React
    dependencies that are necessary to start implementing the frontend.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Babel and Webpack
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is necessary to compile and bundle the React code that we will write to implement
    the frontend before the code can run in browsers. To compile and bundle the client
    code so that we can run it during development and also bundle it for production,
    we will update the configuration for Babel and Webpack. Then, we will configure
    the Express app to initiate frontend and backend code bundling in one command,
    so that just starting the server during development gets the complete stack ready
    for running and testing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Babel
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To compile React, first, install the Babel React preset module as a development
    dependency by running the following command from the command line:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Then, update `.babelrc` with the following code. This will include the module
    and also configure the `react-hot-loader` Babel plugin as required for the `react-hot-loader`
    module.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/.babelrc`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To put this updated Babel configuration to use, we need to update the Webpack
    configuration, which we will look at in the next section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Webpack
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To bundle client-side code after compiling it with Babel, and also to enable
    `react-hot-loader` for faster development, install the following modules by running
    these commands from the command line:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then, to configure Webpack for frontend development and to build the production
    bundle, we will add a `webpack.config.client.js` file and a `webpack.config.client.production.js`
    file with the same configuration code we described in [Chapter 2](fd935468-e403-4363-80b0-2d13845ea65c.xhtml),
    *Preparing the Development Environment*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: With Webpack configured and ready for bundling the frontend React code, next,
    we will add some code that we can use in our development flow. This will make
    the full-stack development process seamless.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Loading Webpack middleware for development
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During development, when we run the server, the Express app should also load
    the Webpack middleware that's relevant to the frontend with respect to the configuration
    that's been set for the client-side code, so that the frontend and backend development
    workflow is integrated. To enable this, we will use the `devBundle.js` file we
    discussed in [Chapter 2](fd935468-e403-4363-80b0-2d13845ea65c.xhtml), *Preparing
    the Development Environment*, in order to set up a `compile` method that takes
    the Express app and configures it to use the Webpack middleware. The `devBundle.js` file
    in the `server` folder will look as follows.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/devBundle.js`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this method, the Webpack middleware uses the values set in `webpack.config.client.js`,
    and we enable hot reloading from the server-side using Webpack Hot Middleware.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to import and call this `compile` method in `express.js` by
    adding the following highlighted lines, but only during development.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/express.js`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These two highlighted lines are only meant for development mode and should be
    commented out when building the code for production. When the Express app runs
    in development mode, adding this code will import the middleware, along with the client-side Webpack
    configuration. Then, it will initiate Webpack to compile and bundle the client-side
    code and also enable hot reloading.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The bundled code will be placed in the `dist` folder. This code will be needed
    to render the views. Next, we will configure the Express server app so that it
    serves the static files from this `dist` folder. This will ensure that the bundled
    React code can be loaded in the browser.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Loading bundled frontend code
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The frontend views that we will see rendered in the browser will load from the
    bundled files in the `dist` folder. For it to be possible to add these bundled
    files to the HTML view containing our frontend, we need to configure the Express
    app so that it serves static files, which are files that aren't generated dynamically
    by server-side code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Serving static files with Express
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To ensure that the Express server properly handles the requests to static files
    such as CSS files, images, or the bundled client-side JS, we will configure it
    so that it serves static files from the `dist` folder by adding the following
    configuration in `express.js`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/express.js`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this configuration in place, when the Express app receives a request at
    a route starting with `/dist`, it will know to look for the requested static resource
    in the `dist` folder before returning the resource in the response. Now, we can
    load the bundled files from the `dist` folder in the frontend.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Updating the template to load a bundled script
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To add the bundled frontend code in the HTML to render our React frontend, we
    will update the `template.js` file so that it adds the script file from the `dist`
    folder to the end of the `<body>` tag.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/template.js`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This script tag will load our React frontend code in the browser when we visit
    the root URL `'/'` with the server running. We are ready to see this in action
    and can start installing the dependencies that will add the React views.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Adding React dependencies
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The frontend views in our skeleton application will primarily be implemented
    using React. In addition, to enable client-side routing, we will use React Router,
    and to enhance the user experience with a sleek look and feel, we will use Material-UI.
    To add these libraries, we will install the following modules in this section:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '**Core React modules**: `react` and `react-dom`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**React Router modules**: `react-router` and `react-router-dom`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Material-UI modules**: `@material-ui/core` and `@material-ui/icons`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this book, we will use React to code up the frontend. To start writing
    the React component code, we will need to install the following modules as regular
    dependencies:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These are the core React library modules that are necessary for implementing
    the React-based web frontend. With other additional modules, we will add more
    functionality on top of React.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是实施基于React的Web前端所必需的核心React库模块。通过添加其他附加模块，我们将在React之上添加更多功能。
- en: React Router
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Router
- en: 'React Router provides a collection of navigational components that enable routing
    on the frontend for React applications. We will add the following React Router
    modules:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: React Router提供了一组导航组件，这些组件使React应用程序在前端实现路由功能。我们将添加以下React Router模块：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These modules will let us utilize declarative routing and have bookmarkable
    URL routes in the frontend.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块将使我们能够利用声明式路由，并在前端拥有可书签的URL路由。
- en: Material-UI
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Material-UI
- en: 'In order to keep the UI in our MERN applications sleek without delving too
    much into UI design and implementation, we will utilize the Material-UI library.
    It provides ready to use and customizable React components that implement Google''s
    material design. To start using Material-UI components to make the frontend, we
    need to install the following modules:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持我们的MERN应用程序的UI简洁，而不深入UI设计和实现，我们将利用Material-UI库。它提供了现成可使用且可定制的React组件，实现了谷歌的材质设计。为了开始使用Material-UI组件来构建前端，我们需要安装以下模块：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At the time of writing, the latest version of Material-UI is `4.9.8`. It is
    recommended that you install this exact version in order to ensure the code for
    the example projects does not break.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Material-UI的最新版本是`4.9.8`。建议您安装此确切版本，以确保示例项目的代码不会出错。
- en: 'To add the `Roboto` fonts that are recommended by Material-UI and to use the
    `Material-UI` icons, we will add the relevant style links into the `template.js`
    file, in the HTML document''s `<head>` section:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加Material-UI推荐的`Roboto`字体并使用`Material-UI`图标，我们将把相关的样式链接添加到`template.js`文件中，在HTML文档的`<head>`部分：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With the development configuration all set up and the necessary React modules
    added to the code base, we can now implement the custom React components, starting
    with a home page. This should load up as the first view of the complete application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发配置全部设置完成，并将必要的React模块添加到代码库之后，我们现在可以开始实现自定义的React组件，从主页开始。这个页面应该作为完整应用程序的第一个视图加载。
- en: Rendering a home page view
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染主页视图
- en: To demonstrate how to implement a functional frontend for this MERN skeleton,
    we will start by detailing how to render a simple home page at the root route
    of the application, before covering backend API integration, user auth integration,
    and implementing the other view components in the rest of this chapter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示如何实现这个MERN框架的前端功能，我们将首先详细说明如何在应用程序的根路由上渲染一个简单的首页，然后再介绍后端API集成、用户认证集成，以及在本章的其余部分实现其他视图组件。
- en: The process of implementing and rendering a working `Home` component at the
    root route will also expose the basic structure of the frontend code in the skeleton.
    We will start with the top-level entry component that houses the whole React app
    and renders the main router component, which links all the React components in
    the application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在根路由上实现和渲染一个工作的`Home`组件的过程，也将揭示前端代码骨架的基本结构。我们将从包含整个React应用的顶级入口组件开始，该组件渲染主路由组件，它将应用程序中的所有React组件链接起来。
- en: In the following sections, we will begin implementing the React frontend. First,
    we will add the root React component, which is integrated with React Router and
    Material-UI and configured for hot reloading. We will also learn how to customize
    the Material-UI theme and make the theme available to all our components. Finally,
    we will implement and load the React component representing the home page, in
    turn demonstrating how to add and render React views in this application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将开始实施React前端。首先，我们将添加根React组件，该组件与React Router和Material-UI集成，并配置为热重载。我们还将学习如何自定义Material-UI主题，并使主题对所有组件可用。最后，我们将实现并加载代表主页的React组件，从而展示如何在应用程序中添加和渲染React视图。
- en: Entry point at main.js
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入口点在main.js
- en: The `client/main.js` file in the client folder will be the entry point to render
    the complete React app, as already indicated in the client-side Webpack configuration
    object. In `client/main.js`, we import the root or top-level React component that
    will contain the whole frontend and render it to the `div` element with the `'root'` ID
    specified in the HTML document in `template.js`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/main.js`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, the top-level root React component is the `App` component and it is being
    rendered in the HTML. The `App` component is defined in `client/App.js`, as discussed
    in the next subsection.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Root React component
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The top-level React component that will contain all the components for the application's
    frontend is defined in the `client/App.js` file. In this file, we configure the
    React app so that it renders the view components with a customized Material-UI
    theme, enables frontend routing, and ensures that the React Hot Loader can instantly
    load changes as we develop the components.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will add code to customize the theme, make this
    theme and React Router capabilities available to our React components, and configure
    the root component for hot reloading.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the Material-UI theme
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Material-UI theme can be easily customized using the `ThemeProvider` component.
    It can also be used to configure the custom values of theme variables in `createMuiTheme()`.
    We will define a custom theme for the skeleton application in `client/theme.js`
    using `createMuiTheme`, and then export it so that it can be used in the `App`
    component.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/theme.js`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For the skeleton, we only apply minimal customization by setting some color
    values to be used in the UI. The theme variables that are generated here will
    be passed to, and available in, all the components we build.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping the root component with ThemeProvider and BrowserRouter
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The custom React components that we will create to make up the user interface
    will be accessed with the frontend routes specified in the `MainRouter` component.
    Essentially, this component houses all the custom views that have been developed
    for the application and needs to be given the theme values and routing features.
    This component will be our core component in the root `App` component, which is
    defined in the following code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/App.js`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When defining this root component in `App.js`, we wrap the `MainRouter` component
    with `ThemeProvider`, which gives it access to the Material-UI theme, and `BrowserRouter`,
    which enables frontend routing with React Router. The custom theme variables we
    defined previously are passed as a prop to `ThemeProvider`, making the theme available
    in all our custom React components. Finally, in the `App.js` file, we need to
    export this `App` component so that it can be imported and used in `main.js`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Marking the root component as hot-exported
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last line of code in `App.js`, which exports the `App` component, uses the**higher-order
    component** (**HOC**)  `hot` module from `react-hot-loader` to mark the root component
    as `hot`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/App.js`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Marking the `App` component as `hot` in this way essentially enables live reloading
    of our React components during development.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: For our MERN applications, we won't have to change the `main.js` and `App.js`
    code all that much after this point, and we can continue building out the rest
    of the React app by injecting new components into the `MainRouter` component,
    which is what we'll do in the next section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Adding a home route to MainRouter
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `MainRouter.js` code will help render our custom React components with respect
    to the routes or locations in the application. In this first version, we will
    only add the root route for rendering the `Home` component.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/MainRouter.js`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we develop more view components, we will update the `MainRouter` and add
    routes for the new components inside the `Switch` component.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The `Switch` component in React Router renders a route exclusively. In other
    words, it only renders the first child that matches the requested route path.
    On the other hand, without being nested in a `Switch`, every `Route` component
    renders inclusively when there is a path match; for example, a request at `'/'`
    also matches a route at `'/contact'`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The `Home` component, which we added this route for in `MainRouter`, needs to
    be defined and exported, which we'll do in the next section.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The Home component
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Home` component will be the React component containing the home page view
    of the skeleton application. It will be rendered in the browser when the user
    visits the root route, and we will compose it with Material-UI components.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `Home` component, as well as the `Menu`
    component, which will be implemented later in this chapter as an individual component
    that provides navigation across the application:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c93f1841-1700-46f7-ba0e-27e0b61d336a.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: 'The `Home` component and other view components that will be rendered in the
    browser for the user to interact with will follow a common code structure that
    contains the following parts in the given order:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Imports of libraries, modules, and files needed to construct the component
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Style declarations to define the specific CSS styles for the component elements
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that defines the React component
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this book, as we develop new React components representing the frontend
    views, we will focus mainly on the React component definition part. But for our
    first implementation, we will elaborate on all these parts to introduce the necessary
    structure.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Imports
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For each React component implementation, we need to import the libraries, modules,
    and files being used in the implementation code. The component file will start
    with imports from React, Material-UI, React Router modules, images, CSS, API fetch,
    and the auth helpers from our code, as required by the specific component. For
    example, for the `Home` component code in `Home.js`, we use the following imports.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/core/Home.js`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The image file is kept in the `client/assets/images/` folder and is imported
    so that it can be added to the `Home` component. These imports will help us build
    the component and also define the styles to be used in the component.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Style declarations
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the imports, we will define the CSS styles that are required to style
    the elements in the component by utilizing the `Material-UI` theme variables and
    `makeStyles`, which is a custom React hook API provided by `Material-UI`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Hooks are new to React. Hooks are functions that make it possible to use React
    state and life cycle features in function components, without having to write
    a class to define the component. React provides some built-in hooks, but we can
    also build custom hooks as needed to reuse stateful behavior across different
    components. To learn more about React Hooks, visit [reactjs.org/docs/hooks-intro.html](https://reactjs.org/docs/hooks-intro.html).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: For the `Home` component in `Home.js`, we have the following styles.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/core/Home.js`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The JSS style objects defined here will be injected into the component using
    the hook returned by `makeStyles`. The `makeStyles` hook API takes a function
    as an argument and gives access to our custom theme variables, which we can use
    when defining the styles.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Material-UI uses JSS, which is a CSS-in-JS styling solution for adding styles
    to components. JSS uses JavaScript as a language to describe styles. This book
    will not cover CSS and styling implementations in detail. It will mostly rely
    on the default look and feel of Material-UI components. To learn more about JSS,
    visit [http://cssinjs.org/?v=v9.8.1](http://cssinjs.org/?v=v9.8.1). For examples
    of how to customize the `Material-UI` component styles, check out the Material-UI
    documentation at [https://material-ui.com/](https://material-ui.com/).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: We can use these generated styles to style the elements in the component, as
    shown in the following `Home` component definition.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Component definition
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While writing the function to define the component, we will compose the content
    and behavior of the component. The `Home` component will contain a Material-UI `Card`
    with a headline, an image, and a caption, all styled with the styles we defined
    previously and returned by calling the `useStyles()` hook.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/core/Home.js`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, we defined and exported a function component named `Home`.
    The exported component can now be used for composition within other components.
    We already imported this `Home` component in a route in the `MainRouter` component,
    as we discussed earlier.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we will define all our React components as functional
    components. We will utilize React Hooks, which is a new addition to React, to
    add state and life cycle features, instead of using class definitions to achieve
    the same.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The other view components to be implemented in our MERN applications will adhere
    to the same structure. In the rest of this book, we will focus mainly on the component
    definition, highlighting the unique aspects of the implemented component.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: We are almost ready to run this code to render the home page component in the
    frontend. But before that, we need to update the Webpack configurations so that
    we can bundle and display images.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Bundling image assets
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The static image file that we imported into the `Home` component view must also
    be included in the bundle with the rest of the compiled JS code so that the code
    can access and load it. To enable this, we need to update the Webpack configuration
    files and add a module rule to load, bundle, and emit image files to the `dist` output
    directory, which contains the compiled frontend and backend code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `webpack.config.client.js`, `webpack.config.server.js`, and `webpack.config.client.production.js` files
    so that you can add the following module rule after the use of `babel-loader`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This module rule uses the `file-loader` node module for Webpack, which needs
    to be installed as a development dependency, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this image bundling configuration added, the home page component should
    successfully render the image when we run the application.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Running and opening in the browser
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The client code up to this point can be run so that we can view the `Home`
    component in the browser at the root URL. To run the application, use the following
    command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Then, open the root URL (`http://localhost:3000`) in the browser to see the
    `Home` component.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The `Home` component we've developed in this section is a basic view component
    without interactive features and does not require the use of the backend APIs
    for user CRUD or auth. However, the remaining view components for our skeleton
    frontend will need the backend APIs and auth, so we will look at how to integrate
    these in the next section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Integrating backend APIs
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users should be able to use the frontend views to fetch and modify user data
    in the database based on authentication and authorization. To implement these
    functionalities, the React components will access the API endpoints that are exposed
    by the backend using the Fetch API.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The Fetch API is a newer standard that makes network requests similar to **XMLHttpRequest**
    (**XHR**) but using promises instead, enabling a simpler and cleaner API. To learn
    more about the Fetch API, visit [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Fetch for user CRUD
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `client/user/api-user.js` file, we will add methods for accessing each
    of the user CRUD API endpoints, which the React components can use to exchange
    user data with the server and database as required. In the following sections,
    we will look at the implementation of these methods and how they correspond to
    each CRUD endpoint.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Creating a user
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `create` method will take user data from the view component, which is where
    we will invoke this method. Then, it will use `fetch` to make a `POST` call at
    the create API route, `'/api/users'`, to create a new user in the backend with
    the provided data.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/api-user.js`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finally, in this method, we return the response from the server as a promise.
    So, the component calling this method can use this promise to handle the response
    appropriately, depending on what is returned from the server. Similarly, we will
    implement the `list` method next.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Listing users
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `list` method will use fetch to make a `GET` call to retrieve all the users
    in the database, and then return the response from the server as a promise to
    the component.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/api-user.js`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The returned promise, if it resolves successfully, will give the component an
    array containing the user objects that were retrieved from the database. In the
    case of a single user read, we will deal with a single user object instead, as
    demonstrated next.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Reading a user profile
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `read` method will use fetch to make a `GET` call to retrieve a specific
    user by ID. Since this is a protected route, besides passing the user ID as a
    parameter, the requesting component must also provide valid credentials, which,
    in this case, will be a valid JWT received after a successful sign-in.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/api-user.js`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The JWT is attached to the `GET` fetch call in the `Authorization` header using
    the `Bearer` scheme, and then the response from the server is returned to the
    component in a promise. This promise, when it resolves, will either give the component
    the user details for the specific user or notify that access is restricted to
    authenticated users. Similarly, the updated user API method also needs to be passed
    valid JWT credentials for the fetch call, as shown in the next section.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Updating a user's data
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `update` method will take changed user data from the view component for
    a specific user, then use `fetch` to make a `PUT` call to update the existing
    user in the backend. This is also a protected route that will require a valid
    JWT as the credential.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/api-user.js`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we have seen with the other fetch calls, this method will also return a promise
    containing the server's response to the user update request. In the final method,
    we will learn how to call the user delete API.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a user
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `remove` method will allow the view component to delete a specific user
    from the database and use fetch to make a `DELETE` call. This, again, is a protected
    route that will require a valid JWT as a credential, similar to the `read` and
    `update` methods.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/api-user.js`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The response from the server to the delete request will be returned to the component
    as a promise, as in the other methods.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: In these five helper methods, we have covered calls to all the user CRUD-related
    API endpoints that we implemented on the backend. Finally, we can export these
    methods from the `api-user.js` file as follows.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/api-user.js`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: These user CRUD methods can now be imported and used by the React components
    as required. Next, we will implement similar helper methods to integrate the auth-related
    API endpoints.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Fetch for the auth API
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to integrate the auth API endpoints from the server with the frontend
    React components, we will add methods for fetching sign-in and sign-out API endpoints
    in the `client/auth/api-auth.js` file. Let's take a look at them.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Sign-in
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `signin` method will take user sign-in data from the view component, then
    use `fetch` to make a `POST` call to verify the user with the backend.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/auth/api-auth.js`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The response from the server will be returned to the component in a promise,
    which may provide the JWT if sign-in was successful. The component invoking this
    method needs to handle the response appropriately, such as storing the received
    JWT locally so it can be used when making calls to other protected API routes
    from the frontend. We will look at the implementation for this when we implement
    the **Sign In** view later in this chapter.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: After the user is successfully signed in, we also want the option to call the
    signout API when the user is signing out. The call to the signout API is discussed
    next.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Sign-out
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will add a `signout` method to `api-auth.js`, which will use fetch to make
    a GET call to the signout API endpoint on the server.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/auth/api-auth.js`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This method will also return a promise to inform the component about whether
    the API request was successful.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the `api-auth.js` file, we will export the `signin` and `signout`
    methods.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/auth/api-auth.js`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, these methods can be imported into the relevant React components so that
    we can implement the user sign-in and signout features.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: With these API fetch methods added, the React frontend has complete access to
    the endpoints we made available in the backend. Before we start putting these
    methods to use in our React components, we will look into how user auth state
    can be maintained across the frontend.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Adding auth in the frontend
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed in the previous chapter, implementing authentication with JWT
    relinquishes responsibility to the client-side to manage and store user auth state.
    To this end, we need to write code that will allow the client-side to store the
    JWT that's received from the server on successful sign-in, make it available when
    accessing protected routes, delete or invalidate the token when the user signs
    out, and also restrict access to views and components on the frontend based on
    the user auth state.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Using examples of the auth workflow from the React Router documentation, in
    the following sections, we will write helper methods to manage the auth state
    across the components, and also use a custom `PrivateRoute` component to add protected
    routes to the frontend of the MERN skeleton application.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Managing auth state
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To manage auth state in the frontend of the application, the frontend needs
    to be able to store, retrieve, and delete the auth credentials that are received
    from the server on successful user sign in. In our MERN applications, we will
    use the browser's `sessionsStorage` as the storage option to store the JWT auth
    credentials.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can use `localStorage` instead of `sessionStorage` to store
    the JWT credentials. With `sessionStorage`, the user auth state will only be remembered
    in the current window tab. With `localStorage`, the user auth state will be remembered
    across tabs in a browser.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: In `client/auth/auth-helper.js`, we will define the helper methods discussed
    in the following sections to store and retrieve JWT credentials from client-side `sessionStorage`,
    and also clear out the `sessionStorage` on user sign-out.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Saving credentials
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to save the JWT credentials that are received from the server on successful
    sign-in, we use the `authenticate` method, which is defined as follows.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/auth/auth-helper.js`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `authenticate` method takes the JWT credentials, `jwt`, and a callback function, `cb`,
    as arguments. It stores the credentials in `sessionStorage` after ensuring `window`
    is defined, in other words ensuring this code is running in a browser and hence
    has access to `sessionStorage`. Then, it executes the callback function that is
    passed in. This callback will allow the component – in our case, the component
    where sign-in is called – to define actions that should take place after successfully
    signing in and storing credentials. Next, we will discuss the method that lets
    us access these stored credentials.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving credentials
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our frontend components, we will need to retrieve the stored credentials
    to check if the current user is signed in. In the `isAuthenticated()` method,
    we can retrieve these credentials from `sessionStorage`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/auth/auth-helper.js`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: A call to `isAuthenticated()` will return either the stored credentials or `false`,
    depending on whether credentials were found in `sessionStorage`. Finding credentials
    in storage will mean a user is signed in, whereas not finding credentials will
    mean the user is not signed in. We will also add a method that allows us to delete
    the credentials from storage when a signed-in user signs out from the application.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Deleting credentials
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a user successfully signs out from the application, we want to clear the
    stored JWT credentials from `sessionStorage`. This can be accomplished by calling
    the `clearJWT` method, which is defined in the following code.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/auth/auth-helper.js`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This `clearJWT` method takes a callback function as an argument, and it removes
    the JWT credential from `sessionStorage`. The passed in `cb()` function allows
    the component initiating the `signout` functionality to dictate what should happen
    after a successful sign-out.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: The `clearJWT` method also uses the `signout` method we defined earlier in `api-auth.js`
    to call the signout API in the backend. If we had used `cookies` to store the
    credentials instead of `sessionStorage`, the response to this API call would be
    where we clear the cookie, as shown in the preceding code. Using the signout API
    call is optional since this is dependent on whether cookies are used as the credential
    storage mechanism.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: With these three methods, we now have ways of storing, retrieving, and deleting
    JWT credentials on the client-side. Using these methods, the React components
    we build for the frontend will be able to check and manage user auth state to
    restrict access in the frontend, as demonstrated in the following section with
    the custom `PrivateRoute` component.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: The PrivateRoute component
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code in the file defines the `PrivateRoute` component, as shown in the auth
    flow example at [https://reacttraining.com/react-router/web/example/auth-workflow](https://reacttraining.com/react-router/web/example/auth-workflow),
    which can be found in the React Router documentation. It will allow us to declare
    protected routes for the frontend to restrict view access based on user auth.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/auth/PrivateRoute.js`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Components to be rendered in this `PrivateRoute` will only load when the user
    is authenticated, which is determined by a call to the `isAuthenticated` method;
    otherwise, the user will be redirected to the `Signin` component. We load the
    components that should have restricted access, such as the user profile component,
    in a `PrivateRoute`. This will ensure that only authenticated users are able to
    view the user profile page.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: With the backend APIs integrated and the auth management helper methods ready
    for use in the components, we can now start building the remaining view components
    that utilize these methods and complete the frontend.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Completing the User frontend
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The React components that will be described in this section complete the interactive
    features we defined for the skeleton by allowing users to view, create, and modify
    user data stored in the database with respect to auth restrictions. The components
    we will implement are as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '`Users`: To fetch and list all users from the database to the view'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Signup`: To display a form that allows new users to sign up'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Signin`: To display a form that allows existing users to sign in'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Profile`: To display details for a specific user after retrieving from the
    database'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EditProfile`: To display details for a specific user and allow authorized
    user to update these details'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeleteUser`: To allow an authorized user to delete their account from the
    application'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Menu`: To add a common navigation bar to each view in the application'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each of these components, we will go over their unique aspects, as well
    as how to add them to the application in the `MainRouter`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: The Users component
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Users` component in `client/user/Users.js` shows the names of all the
    users that have been fetched from the database and links each name to the user
    profile. The following component can be viewed by any visitor to the application
    and will render at the `''/users''` route:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/276f7c2c-23cf-4c9e-937e-8481d3924c81.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
- en: In the component definition, similar to how we implemented the `Home` component,
    we define and export a function component. In this component, we start by initializing
    the state with an empty array of users.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/Users.js`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We are using the built-in React hook, `useState`, to add state to this function
    component. By calling this hook, we are essentially declaring a state variable
    named `users`, which can be updated by invoking `setUsers`, and also set the initial
    value of `users` to `[]`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Using the built-in `useState` hook allows us to add state behavior to a function
    component in React. Calling it will declare a state variable, similar to using
    `this.state` in class component definitions. The argument that's passed to `useState`
    is the initial value of this variable – in other words, the initial state. Invoking
    `useState` returns the current state and a function that updates the state value,
    which is similar to `this.setState` in a class definition.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: With the `users` state initialized, next, we will use another built-in React
    hook named `useEffect` to fetch a list of users from the backend and update the
    `users` value in the state.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The Effect Hook, `useEffect`, serves the purpose of the `componentDidMount`,
    `componentDidUpdate`, and `componentWillUnmount` React life cycle methods that
    we would otherwise use in React classes. Using this hook in a function component
    allows us to perform side effects such as fetching data from a backend. By default,
    React runs the effects defined with `useEffect` after every render, including
    the first render. But we can also instruct the effect to only rerun if something
    changes in state. Optionally, we can also define how to clean up after an effect,
    for example, to perform an action such as aborting a fetch signal when the component
    unmounts to avoid memory leaks.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: In our `Users` component, we use `useEffect` to call the `list` method from
    the `api-user.js` helper methods. This will fetch the user list from the backend
    and load the user data into the component by updating the state.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/Users.js`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this effect, we also add a cleanup function to abort the fetch call when
    the component unmounts. To associate a signal with the fetch call, we use the
    AbortController web API, which allows us to abort DOM requests as needed.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: In the second argument of this `useEffect` hook, we pass an empty array so that
    this effect cleanup runs only once upon mounting and unmounting, and not after
    every render.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the return of the `Users` function component, we add the actual
    view content. The view is composed of Material-UI components such as `Paper`,
    `List`, and `ListItem`. These elements are styled with the CSS that is defined
    and made available with the `makeStyles` hook, the same way as in the `Home` component.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/Users.js`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this view, to generate each list item, we iterate through the array of users
    in the state using the `map` function. A list item is rendered with an individual
    user's name from each item that's accessed per iteration on the users array.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: To add this `Users` component to the React application, we need to update the
    `MainRouter` component with a `Route` that renders this component at the `'/users'` path.
    Add the `Route` inside the `Switch` component after the `Home` route.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/MainRouter.js`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To see this view rendered in the browser, you can temporarily add a `Link`
    component to the `Home` component to be able to route to the `Users` component:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Clicking on this link after rendering the Home view at the root route in the
    browser will display the `Users` component we implemented in this section. We
    will implement the other React components similarly, starting with the `Signup`
    component in the next section.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: The Signup component
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Signup` component in `client/user/Signup.js` presents a form with name,
    email, and password fields to the user for sign-up at the `''/signup''` path,
    as displayed in the following screenshot:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b786119b-9e65-40ee-bb58-1d26f7a0f4d9.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
- en: In the component definition, we initialize the state using the `useState` hook
    with empty input field values, an empty error message, and set the dialog open
    variable to false.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/Signup.js`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We also define two handler functions to be called when the input values change
    or the submit button is clicked. The `handleChange` function takes the new value
    that's entered in the input field and sets it as the state.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/Signup.js`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `clickSubmit` function is called when the form is submitted. It takes the
    input values from the state and calls the `create` fetch method to sign up the
    user with the backend. Then, depending on the response from the server, either
    an error message is shown or a success dialog is shown.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/Signup.js`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the `return` function, we compose and style the form components in the signup
    view using components such as `TextField` from Material-UI.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/Signup.js`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This return also contains an error message block, along with a `Dialog` component
    that is conditionally rendered depending on the signup response from the server.
    If the server returns an error, the error block that was added below the form,
    which we implemented in the preceding code, will render in the view with the corresponding
    error message. If the server returns a successful response, a `Dialog` component
    will be rendered instead.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: The `Dialog` component in `Signup.js` is composed as follows.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/Signup.js`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'On successful account creation, the user is given confirmation and asked to
    sign in using this `Dialog` component, which links to the `Signin` component, as
    shown in the following screenshot:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3edd525-ab6e-4021-8e15-2f0b90fe1928.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
- en: To add the `Signup` component to the app, add the following `Route` to `MainRouter` in
    the `Switch` component.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/MainRouter.js`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This will render the `Signup` view at `'/signup'`. Similarly, we will implement
    the `Signin` component next.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: The Signin component
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Signin` component in `client/auth/Signin.js` is also a form with only
    email and password fields for signing in. This component is quite similar to the `Signup` component
    and will render at the `''/signin''` path. The key difference is in the implementation
    of redirection after a successful sign-in and storing the received JWT credentials.
    The rendered `Signin` component can be seen in the following screenshot:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c43a997a-7aac-4897-8e47-ac3c084e349e.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
- en: 'For redirection, we will use the `Redirect` component from React Router. First,
    initialize a `redirectToReferrer` value to `false` in the state with the other
    fields:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/auth/Signin.js`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `Signin` function will take props in the argument that contain React Router
    variables. We will use these for the redirect. `redirectToReferrer` should be
    set to `true` when the user successfully signs in after submitting the form and
    the received JWT is stored in `sessionStorage`. To store the JWT and redirect
    afterward, we will call the `authenticate()` method defined in `auth-helper.js`.
    This implementation will go in the `clickSubmit()` function so that it can be
    called on form submit.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/auth/Signin.js`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The redirection will happen conditionally based on the `redirectToReferrer` value
    using the `Redirect` component from React Router. We add the redirect code inside
    the function before the return block, as follows.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/auth/Signin.js`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `Redirect` component, if rendered, will take the app to the last location
    that was received in the props or to the `Home` component at the root.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: The function return code is not displayed here as it is very similar to the
    code in `Signup`. It will contain the same form elements with just `email` and `password` fields,
    a conditional error message, and the `submit` button.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: To add the `Signin` component to the app, add the following Route to `MainRouter` in
    the `Switch` component.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/MainRouter.js`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This will render the `Signin` component at `"/signin"` and can be linked in
    the Home component, similar to the `Signup` component, so that it can be viewed
    in the browser. Next, we will implement the profile view to display the details
    of a single user.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: The Profile component
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Profile` component in `client/user/Profile.js` shows a single user''s
    information in the view at the `''/user/:userId''` path, where the `userId` parameter
    represents the ID of the specific user. The completed `Profile` will display user
    details, and also conditionally show edit/delete options. The following screenshot
    shows how the `Profile` renders when the user currently browsing is viewing someone
    else''s profile and not their own profile:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cef473f4-40dc-4c07-9bb2-e6d42319711a.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
- en: This profile information can be fetched from the server if the user is signed
    in. To verify this, the component has to provide the JWT credential to the `read`
    fetch call; otherwise, the user should be redirected to the Sign In view.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: In the `Profile` component definition, we need to initialize the state with
    an empty user and set `redirectToSignin` to `false`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/Profile.js`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We also need to get access to the `match` props passed by the `Route` component,
    which will contain a `:userId` parameter value. This can be accessed as `match.params.userId`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: The `Profile` component should fetch user information and render the view with
    these details. To implement this, we will use the `useEffect` hook, as we did
    in the `Users` component.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/Profile.js`:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This effect uses the `match.params.userId` value and calls the `read` user fetch
    method. Since this method also requires credentials to authorize the signed-in
    user, the JWT is retrieved from `sessionStorage` using the `isAuthenticated` method
    from `auth-helper.js`, and passed in the call to `read`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Once the server responds, either the state is updated with the user information
    or the view is redirected to the Sign In view if the current user is not authenticated.
    We also add a cleanup function in this effect hook to abort the fetch signal when
    the component unmounts.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: This effect only needs to rerun when the `userId` parameter changes in the route,
    for example, when the app goes from one profile view to the other. To ensure this
    effect reruns when the `userId` value updates, we will add `[match.params.userId]` in
    the second argument to `useEffect`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: If the current user is not authenticated, we set up the conditional redirect
    to the Sign In view.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/Profile.js`'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The function will return the `Profile` view with the following elements if the
    user who's currently signed in is viewing another user's profile.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/Profile.js`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'However, if the user that''s currently signed in is viewing their own profile,
    they will be able to see edit and delete options in the `Profile` component, as
    shown in the following screenshot:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1015c42c-63e0-4226-9868-f65ee50d15d4.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
- en: To implement this feature, in the first `ListItem` component in the `Profile`,
    add a `ListItemSecondaryAction` component containing the `Edit` button and a `DeleteUser`
    component, which will render conditionally based on whether the current user is
    viewing their own profile.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/Profile.js`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `Edit` button will route to the `EditProfile` component, while the custom
    `DeleteUser` component will handle the delete operation with the `userId` passed
    to it as a prop.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: To add the `Profile` component to the app, add the `Route` to `MainRouter` in
    the `Switch` component.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/MainRouter.js`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: To visit this route in the browser and render a `Profile` with user details,
    the link should be composed with a valid user ID in it. In the next section, we
    will use this same approach of retrieving single user details and rendering it
    in the component to implement the Edit Profile view.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: The EditProfile component
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `EditProfile` component in `client/user/EditProfile.js` has similarities
    in its implementation to both the `Signup` and `Profile` components. It allows
    the authorized user to edit their own profile information in a form similar to
    the signup form, as shown in the following screenshot:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3df6da71-c22b-416b-bd85-8d3b6363b112.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
- en: Upon loading at `'/user/edit/:userId'`, the component will fetch the user's
    information with their ID after verifying JWT for auth, and then load the form
    with the received user information. The form will allow the user to edit and submit
    only the changed information to the `update` fetch call, and, on successful update,
    redirect the user to the `Profile` view with updated information.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '`EditProfile` will load the user information the same way as in the `Profile`
    component, that is, by fetching with `read` in `useEffect` using the `userId`
    parameter from `match.params`. It will gather credentials from `auth.isAuthenticated`.
    The form view will contain the same elements as the `Signup` component, with the
    input values being updated in the state when they change.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: On form submit, the component will call the `update` fetch method with the `userId`,
    JWT and updated user data.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/EditProfile.js`:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Depending on the response from the server, the user will either see an error
    message or be redirected to the updated Profile page using the `Redirect` component,
    as follows.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/EditProfile.js`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: To add the `EditProfile` component to the app, we will use a `PrivateRoute`,
    which will restrict the component from loading at all if the user is not signed
    in. The order of placement in `MainRouter` will also be important.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/MainRouter.js`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The route with the `'/user/edit/:userId'` path needs to be placed before the
    route with the `'/user/:userId'` path, so that the edit path is matched first
    exclusively in the Switch component when this route is requested, and not confused
    with the `Profile` route.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: With this profile edit view added, we only have the user delete UI implementation
    left to complete the user-related frontend.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: The DeleteUser component
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `DeleteUser` component in `client/user/DeleteUser.js` is basically a button
    that we will add to the Profile view that, when clicked, opens a `Dialog` component
    asking the user to confirm the `delete` action, as shown in the following screenshot:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46ebac43-14ae-484d-8393-7445c320f5bf.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
- en: This component initializes the state with `open` set to `false` for the `Dialog`
    component, as well as `redirect` set to `false` so that it isn't rendered first.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/DeleteUser.js`:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `DeleteUser` component will also receive props from the parent component.
    In this case, the props will contain the `userId` that was sent from the `Profile`
    component.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need some handler methods to open and close the `dialog` button. The
    dialog is opened when the user clicks the `delete` button.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/DeleteUser.js`:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The dialog is closed when the user clicks `cancel` on the dialog.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/DeleteUser.js`:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The component will have access to the `userId` that's passed in as a prop from
    the `Profile` component, which is needed to call the `remove` fetch method, along
    with the JWT credentials, after the user confirms the `delete` action in the dialog.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/DeleteUser.js`:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'On confirmation, the `deleteAccount` function calls the `remove` fetch method
    with the `userId` from props and JWT from `isAuthenticated`. On successful deletion,
    the user will be signed out and redirected to the Home view. The `Redirect` component
    from React Router is used to redirect the current user to the Home view, as follows:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The component function returns the `DeleteUser` component elements, including
    a `DeleteIcon` button and the confirmation `Dialog`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/DeleteUser.js`:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`DeleteUser` takes the `userId` as a prop to be used in the `delete` fetch
    call, so we need to add a required prop validation check for this React component.
    We''ll do this next.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Validating props with PropTypes
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To validate the required injection of `userId` as a prop to the component, we'll
    add the `PropTypes` requirement validator to the defined component.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/user/DeleteUser.js`:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Since we are using the `DeleteUser` component in the `Profile` component, it
    gets added to the application view when `Profile` is added in `MainRouter`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: With the delete user UI added, we now have a frontend that contains all the
    React component views in order to complete the skeleton application features.
    But, we still need a common navigation UI to link all these views together and
    make each view easy to access for the frontend user. In the next section, we will
    implement this navigation menu component.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: The  Menu component
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Menu` component will function as a navigation bar across the frontend application
    by providing links to all the available views, and also by indicating the user's
    current location in the application.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: To implement these navigation bar functionalities, we will use the HOC `withRouter` from
    React Router to get access to the `history` object's properties. The following
    code in the `Menu` component adds just the title, the `Home` icon linked to the
    root route, and the `Users` button, which is linked to the `'/users'` route.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/core/Menu.js`:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: To indicate the current location of the application on the `Menu`, we will highlight
    the link that matches the current location path by changing the color conditionally.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/core/Menu.js`:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `isActive` function is used to apply color to the buttons in the `Menu`,
    as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The remaining links such as SIGN IN, SIGN UP, MY PROFILE, and SIGN OUT will
    show up on the `Menu` based on whether the user is signed in or not. The following
    screenshot shows how the Menu renders when the user is not signed in:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af094174-ddd9-4444-9c5c-90ae2230144d.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
- en: For example, the links to SIGN UP and SIGN IN should only appear on the menu
    when the user is not signed in. Therefore, we need to add it to the `Menu` component
    after the `Users` button with a condition.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/core/Menu.js`:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Similarly, the link to `MY PROFILE` and the `SIGN OUT` button should only appear
    on the menu when the user is signed in, and should be added to the `Menu` component
    with the following condition check.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/core/Menu.js`:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The MY PROFILE button uses the signed-in user''s information to link to the
    user''s own profile, while the SIGN OUT button calls the `auth.clearJWT()` method
    when it''s clicked. When the user is signed in, the `Menu` will look as follows:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0cc63b3-2970-4e7d-b313-6ff5cc246d62.png)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
- en: To have the `Menu` navigation bar present in all the views, we need to add it
    to the `MainRouter` before all the other routes, and outside the `Switch` component.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/MainRouter.js`:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This will make the `Menu` component render on top of all the other components
    when these components are accessed at their respective routes.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: The skeleton frontend is now complete and has all necessary components to allow
    a user to sign up, view, and modify user data on the backend while considering
    authentication and authorization restrictions. However, it is still not possible
    to visit the frontend routes directly in the browser address bar; these can only
    be accessed when they're linked from within the frontend view. To enable this
    functionality in the skeleton application, we need to implement basic server-side
    rendering.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Implementing basic server-side rendering
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, when the React Router routes or pathnames are directly entered in
    the browser address bar or when a view that is not at the root path is refreshed,
    the URL does not work. This happens because the server does not recognize the
    React Router routes we defined in the frontend. We have to implement basic server-side
    rendering on the backend so that the server is able to respond when it receives
    a request to a frontend route.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: To render the relevant React components properly when the server receives requests
    to the frontend routes, we need to initially generate the React components on
    the server-side with regard to the React Router and Material-UI components, before
    the client-side JS is ready to take over the rendering.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea behind server-side rendering React apps is to use the `renderToString`
    method from `react-dom` to convert the root React component into a markup string.
    Then, we can attach it to the template that the server renders when it receives
    a request.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 'In `express.js`, we will replace the code that returns `template.js` in response
    to the `GET` request for `''/''` with code that, upon receiving any incoming GET
    request, generates some server-side rendered markup and the CSS of the relevant
    React component tree, before adding this markup and CSS to the template. This
    updated code will achieve the following:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the following sections, we will look at the implementation of the steps outlined
    in the preceding code block, and also discuss how to prepare the frontend so that
    it accepts and handles this server-rendered code.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Modules for server-side rendering
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement basic server-side rendering, we will need to import the following
    React, React Router, and Material-UI-specific modules into the server code. In
    our code structure, the following modules will be imported into `server/express.js`:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '**React modules**: The following modules are required to render the React components
    and use `renderToString`:'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '**Router modules**: `StaticRouter` is a stateless router that takes the requested
    URL to match with the frontend route which was declared in the `MainRouter` component.
    The `MainRouter` is the root component in our frontend.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '**Material-UI modules and the custom theme**: The following modules will help
    generate the CSS styles for the frontend components based on the stylings and
    Material-UI theme that are used on the frontend:'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: With these modules, we can prepare, generate, and return server-side rendered
    frontend code, as we will discuss next.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: Generating CSS and markup
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To generate the CSS and markup representing the React frontend views on the
    server-side, we will use Material-UI's `ServerStyleSheets` and React's `renderToString`.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: On every request received by the Express app, we will create a new `ServerStyleSheets`
    instance. Then, we will render the relevant React tree with the server-side collector
    in a call to `renderToString`, which ultimately returns the associated markup
    or HTML string version of the React view that is to be shown to the user in response
    to the requested URL.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: The following code will be executed on every GET request that's received by
    the Express app.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/express.js`:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: While rendering the React tree, the client app's root component, `MainRouter`,
    is wrapped with the Material-UI  `ThemeProvider` to provide the styling props
    that are needed by the `MainRouter` child components. The stateless `StaticRouter`
    is used here instead of the `BrowserRouter` that's used on the client-side in
    order to wrap `MainRouter` and provide the routing props that are used for implementing
    the client-side components.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Based on these values, such as the requested `location` route and `theme` that
    are passed in as props to the wrapping components, `renderToString` will return
    the markup containing the relevant view.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Sending a template with markup and CSS
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the markup has been generated, we need to check if there was a `redirect`
    rendered in the component to be sent in the markup. If there was no redirect,
    then we get the CSS string from `sheets` using `sheets.toString`, and, in the
    response, we send the `Template` back with the markup and CSS injected, as shown
    in the following code.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/server/express.js`:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: An example of a case where redirect is rendered in the component is when we're
    trying to access a `PrivateRoute` via a server-side render. As the server-side
    cannot access the auth token from the browser's `sessionStorage`, the redirect
    in `PrivateRoute` will render. The `context.url` value , in this case, will have
    the `'/signin'` route, and hence, instead of trying to render the `PrivateRoute`
    component, it will redirect to the `'/signin'` route.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: This completes the code we need to add to the server-side to enable the basic
    server-side rendering of the React views. Next, we need to update the frontend
    so it is able to integrate and render this server-generated code.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Updating template.js
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The markup and CSS that we generated on the server must be added to the `template.js` HTML
    code for it to be loaded when the server renders the template.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/template.js`:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This will load the server-generated code in the browser before the frontend
    script is ready to take over. In the next section, we will learn how the frontend
    script needs to account for this takeover from server-rendered code.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: Updating App.js
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the code that's been rendered on the server-side reaches the browser and
    the frontend script takes over, we need to remove the server-side injected CSS
    when the root React component mounts, using the `useEffect` hook.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-skeleton/client/App.js`:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This will give back full control over rendering the React app to the client-side.
    To ensure this transfer happens efficiently, we need to update how the ReactDOM
    renders the views.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: Hydrate instead of render
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the React components will be rendered on the server-side, we can update
    the `main.js` code so that it uses `ReactDOM.hydrate()` instead of `ReactDOM.render()`:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `hydrate` function hydrates a container that already has HTML content rendered
    by `ReactDOMServer`. This means the server-rendered markup is preserved and only
    event handlers are attached when React takes over in the browser, allowing the
    initial load performance to be better.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: With basic server-side rendering implemented, direct requests to the frontend
    routes from the browser address bar can now be handled properly by the server,
    making it possible to bookmark the React frontend views.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: The skeleton MERN application that we've developed in this chapter is now a
    completely functioning MERN web application with basic user features. We can extend
    the code in this skeleton to add a variety of features for different applications.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we completed the MERN skeleton application by adding a working
    React frontend, including frontend routing and basic server-side rendering of
    the React views.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: We started off by updating the development flow so that it included client-side
    code bundling for the React views. We updated the configuration for Webpack and
    Babel to compile the React code and discussed how to load the configured Webpack
    middleware from the Express app to initiate server-side and client-side code compilation
    from one place during development.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: With the development flow updated, and before building out the frontend, we
    added the relevant React dependencies, along with React Router for frontend routing
    and Material-UI, to use their existing components in the skeleton app's user interface.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: Then, we implemented the top-level root React components and integrated React
    Router, which allowed us to add client-side routes for navigation. Using these
    routes, we loaded the custom React components that we developed using Material-UI
    components to make up the skeleton application's user interface.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: To make these React views dynamic and interactive with data fetched from the
    backend, we used the Fetch API to connect to the backend user APIs. Then, we incorporated
    authentication and authorization on the frontend views. We did this using `sessionStorage`,
    which stores user-specific details, and JWT fetched from the server on successful
    sign-in, as well as by limiting access to certain views using a `PrivateRoute`
    component.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we modified the server code so that we could implement basic server-side
    rendering, which allows us to load the frontend routes directly in the browser
    with server-side rendered markup after the server recognizes that the incoming
    request is actually for a React route.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should be able to implement and integrate a React-based frontend that
    incorporates client-side routing and auth management with a standalone server application.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use the concepts we've learned in this chapter
    to extend the skeleton application code so that we can build a fully-featured
    social media application.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
