- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Angular’s Architecture and Concepts
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular的架构和概念
- en: Angular is a popular **Single-Page Application** (**SPA**) framework for building
    web applications. It is often preferred in enterprise application development
    because it is an opinionated, batteries-included framework that supports type-checking
    with TypeScript and concepts like **Dependency Injection** (**DI**) that allow
    for engineering scalable solutions by large teams. In contrast, React is a flexible
    and unopinionated library rather than a complete framework, requiring developers
    to pick their flavor from the community to build fully featured applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是一个流行的**单页应用**（SPA）框架，用于构建Web应用。它通常在企业应用开发中更受欢迎，因为它是一个有观点、包含电池的框架，支持使用TypeScript进行类型检查，以及像**依赖注入**（DI）这样的概念，允许大型团队通过这些概念构建可扩展的解决方案。相比之下，React是一个灵活且无观点的库，而不是一个完整的框架，需要开发者从社区中选择他们喜欢的风味来构建功能齐全的应用。
- en: React is undoubtedly the more popular choice of the two. The numbers don’t lie.
    React’s easier learning curve and deceptively small and simple starting point
    have attracted the attention of many developers. The many “Angular vs React” articles
    you have undoubtedly encountered online add to the confusion. These articles are
    usually too shallow, often contain misleading information about Angular, and lack
    insights into the very bright future of Angular.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: React无疑是两者中更受欢迎的选择。数据不会说谎。React更容易的学习曲线和看似小巧简单的起点吸引了众多开发者的注意。你无疑在网上遇到了许多“Angular
    vs React”的文章，这些文章增加了混乱。这些文章通常过于肤浅，经常包含关于Angular的误导性信息，并且缺乏对Angular光明的未来的洞察。
- en: This chapter aims to give you a deeper understanding of why Angular exists,
    the variety of patterns and paradigms you can leverage to solve complex problems,
    and, later in the book, the pitfalls to avoid as you scale your solution. It’s
    important to take your time to read through this material because every journey
    begins with a choice. The real story of your choice today can only be written
    several years into a project when it’s too late and expensive to switch technologies.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在帮助你更深入地理解为什么Angular存在，你可以利用哪些模式和范式来解决复杂问题，以及，在本书的后期，在扩展你的解决方案时需要避免的陷阱。花时间阅读这些材料很重要，因为每一次旅程都是从选择开始的。你今天的选择的真实故事只能在项目进行几年后才能写出来，那时切换技术已经太晚且成本高昂。
- en: 'This chapter covers the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Two Angulars
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个Angular
- en: A brief history of web frameworks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web框架的简要历史
- en: Angular and the philosophies behind it
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular及其背后的哲学
- en: Component architecture
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件架构
- en: Reactive programming
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程
- en: Modular architecture
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化架构
- en: Standalone architecture
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立架构
- en: Angular Router
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular路由器
- en: State management
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态管理
- en: React.js architecture
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React.js架构
- en: The future of Angular
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular的未来
- en: '*Chapter 2*, *Forms, Observables, Signals, and Subjects*, covers Angular fundamental
    concepts and building blocks. *Chapter 3*, *Architecting an Enterprise App*, covers
    technical, architectural, and tooling concerns for delivering large applications.
    With *Chapter 4*, *Creating a Router-First Line-of-Business App*, we dive into
    creating scalable Angular applications ready for the enterprise.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*第二章*，*表单、可观察者、信号和主题*，涵盖了Angular的基本概念和构建块。*第三章*，*构建企业应用*，涵盖了交付大型应用的技术、架构和工具问题。通过*第四章*，*创建以路由器为第一线的业务应用*，我们深入探讨创建适用于企业的可扩展Angular应用。'
- en: Each chapter introduces new concepts and progressively builds on best practices
    while covering optimal working methods with popular open-source tools. Along the
    way, tips and information boxes provide additional background and history, numbered
    steps, and bullet points that describe actions you need to take.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每一章都介绍新的概念，并逐步构建在最佳实践之上，同时涵盖使用流行的开源工具的最优工作方法。在这个过程中，提示和信息框提供了额外的背景和历史，编号步骤和项目符号，描述了你需要采取的行动。
- en: The code samples provided in this book have been developed using Angular 17\.
    Since the second edition, significant changes occurred in the JavaScript and Angular
    ecosystems. The transition to Angular’s Ivy engine meant some third-party tools
    stopped working. ESLint has superseded TSLint. Karma and Jasmine have become outdated
    and superseded by Jest or the more modern Vitest. Significant headway was made
    in replacing `commonjs` modules with **ES modules** (**ESM**).The totality of
    these changes meant that much of the second edition’s supporting tools were beyond
    repair. As a lesson learned, the example projects now utilize minimal tooling
    to allow for the best possible DevEx with the least possible amount of npm packages
    installed. The core samples of the book, which intentionally avoided third-party
    libraries, were initially written for Angular 5 and have survived the test of
    time. This book adopts the Angular Evergreen motto and encourages incremental,
    proactive, and timely upgrades of your dependencies to maintain the health of
    your project and your team.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的代码示例是使用Angular 17开发的。自第二版以来，JavaScript和Angular生态系统发生了重大变化。转向Angular的Ivy引擎意味着一些第三方工具停止工作。ESLint取代了TSLint。Karma和Jasmine已经过时，被Jest或更现代的Vitest所取代。在用**ES模块**（**ESM**）替换`commonjs`模块方面取得了重大进展。这些变化的总体影响是，第二版的大部分辅助工具都无法修复。作为经验教训，现在的示例项目使用了最少的工具，以便在安装尽可能少的npm包的情况下实现最佳可能的开发体验。本书的核心示例有意避免了第三方库，最初是为Angular
    5编写的，并经受了时间的考验。本书采用Angular Evergreen的口号，并鼓励逐步、主动和及时地升级你的依赖项，以保持项目和团队的健康。
- en: This book is supported by the companion site [https://AngularForEnterprise.com](https://AngularForEnterprise.com).
    Visit the site for the latest news and updates.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本书由配套网站[https://AngularForEnterprise.com](https://AngularForEnterprise.com)支持。访问该网站获取最新新闻和更新。
- en: 'The world of JavaScript, TypeScript, and Angular is constantly changing. To
    maintain consistency for my readers, I published a collection of open-source projects
    that support the content of the book:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript、TypeScript和Angular的世界不断变化。为了保持读者的连贯性，我发布了一系列开源项目，以支持本书的内容：
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_01_01.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B20960_01_01.png)'
- en: 'Figure 1.1: Code developed in support of this book'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：支持本书的代码
- en: 'The diagram above shows you the moving parts that make up the technical content
    supporting this book. Each component is detailed in the coming chapters. The code
    samples contain chapter-by-chapter snapshots and the final state of the code.
    The most up-to-date versions of the sample code for the book are on GitHub at
    the repositories linked below:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图表显示了构成支持本书的技术内容的各个组成部分。每个组件将在接下来的章节中详细介绍。代码示例包含逐章快照和代码的最终状态。本书的样本代码的最新版本可在以下链接的GitHub仓库中找到：
- en: 'For *Chapters 2* and *9*, LocalCast Weather: [https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于**第二章**和**第九章**，LocalCast天气：[https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
- en: 'For *Chapters 4* to *10*, Lemon Mart: [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于**第四章**到**第十章**，柠檬市场：[https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
- en: 'For *Chapter 5*, Lemon Mart Server: [https://github.com/duluca/lemon-mart-server](https://github.com/duluca/lemon-mart-server
    )'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于**第五章**，柠檬市场服务器：[https://github.com/duluca/lemon-mart-server](https://github.com/duluca/lemon-mart-server)
- en: You may read more about updating Angular in the supplemental reading, *Keeping
    Angular and Tools Evergreen*, available at [https://angularforenterprise.com/evergreen](https://angularforenterprise.com/evergreen).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在补充阅读材料《保持Angular和工具常青》中了解更多关于更新Angular的信息，该材料可在[https://angularforenterprise.com/evergreen](https://angularforenterprise.com/evergreen)找到。
- en: Now that you’re oriented with the book’s structure and supporting content, and
    before we dive into a prolonged history of the web, let’s first disambiguate the
    two major architectures of Angular and the underlying themes that motivated a
    dramatic rewrite of the framework in 2016.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了本书的结构和辅助内容，在我们深入探讨网络的漫长历史之前，让我们首先区分Angular的两大主要架构以及推动2016年框架大幅重写的潜在主题。
- en: Two Angulars
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两个Angular
- en: In its original incarnation, Angular.js, aka 1.x, pioneered the SPA era, a technique
    that tricks the browser into thinking that a single `index.html` houses an interactive
    application containing many pages. Angular.js also popularized the concept of
    two-way binding in web development, which automatically updates the view to match
    the state of the ViewModel. To implement such a feature, Angular.js used **Change
    Detection** to keep track of **Document Object Model** (**DOM**) elements of the
    browser and the ViewModel state of the application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在其原始版本 Angular.js（即 1.x），开创了单页应用（SPA）时代，这是一种欺骗浏览器认为单个 `index.html` 包含一个包含多个页面的交互式应用的技术。Angular.js
    还普及了双向绑定在网页开发中的概念，它自动将视图更新以匹配 ViewModel 的状态。为了实现这一功能，Angular.js 使用 **变更检测** 来跟踪浏览器中的
    **文档对象模型**（**DOM**）元素和应用程序的 ViewModel 状态。
- en: Change Detection depends on a sophisticated rendering loop to detect user interactions
    and other events to determine if the application needs to react to changes. Whenever
    a rendering loop is involved, like in games, performance can be measured as a
    frame rate expressed in **Frames per Second** (**FPS**). A slow change detection
    process results in a low FPS count, translating into a choppy **User Experience**
    (**UX**). With the demand for more interactive and complicated web applications,
    it became clear that the internal architecture of Angular.js couldn’t be improved
    to maintain a consistent FPS output. However, UX and performance are only one
    side of the experience story. As an application grows more complicated better
    tooling is needed to support a great **Developer Experience** (**DevEx**) – sometimes
    called **DevX** or **DX** – which is key to developer wellbeing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 变更检测依赖于一个复杂的渲染循环来检测用户交互和其他事件，以确定应用程序是否需要响应变化。每当涉及渲染循环时，如在游戏中，性能可以测量为每秒帧数，即 **每秒帧数**（**FPS**）。缓慢的变更检测过程会导致低
    FPS 数，转化为不流畅的 **用户体验**（**UX**）。随着对更多交互性和复杂网络应用的需求增加，很明显，Angular.js 的内部架构无法通过提高以保持一致的
    FPS 输出来进行改进。然而，用户体验和性能只是体验故事的一方面。随着应用程序变得更加复杂，需要更好的工具来支持优秀的 **开发者体验**（**DevEx**）——有时称为
    **DevX** 或 **DX**），这对于开发者的福祉至关重要。
- en: The Angular 2 rewrite, now simply referred to as Angular, aimed to solve both
    sides of the problem. Before frameworks and libraries like React, Angular, and
    Vue, we suffered from unmanaged complexity and JavaScript-framework-of-the-week
    syndrome. These frameworks succeeded with promises to fix all problems, bring
    about universally reusable web components, and make it easier to learn, develop,
    and scale web applications- at least for a while, some being better than others
    during different periods. The same problems that plagued early SPA are returning
    as the demand for ever more complicated web experiences increases, and the tooling
    to resolve these problems grows ever complex. To master Angular or any other modern
    framework, it is critical to learn about the past, present, and future of web
    development. The adolescent history of the web has taught us a couple of essential
    lessons. First, change is inevitable, and second, the developer’s happiness is
    a precious commodity that can make or break entire companies.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2 重写，现在简称为 Angular，旨在解决问题的两个方面。在 React、Angular 和 Vue 等框架和库出现之前，我们遭受着未管理的复杂性和“每周
    JavaScript 框架”综合症的困扰。这些框架通过承诺解决所有问题、带来通用可重用网络组件以及使学习、开发和扩展网络应用变得更加容易而取得成功——至少在一段时间内，某些框架在不同时期表现得比其他框架更好。随着对越来越复杂的网络体验的需求增加，以及解决这些问题的工具变得越来越复杂，早期单页应用（SPA）所面临的相同问题正在回归。要掌握
    Angular 或任何其他现代框架，了解网络开发的过去、现在和未来至关重要。网络发展的青少年历史教会了我们几个重要的教训。首先，变化是不可避免的，其次，开发者的幸福是一种宝贵的商品，它可以使整个公司兴衰。
- en: As you can see, Angular’s development has been deeply impacted by performance,
    UX, and DevEx concerns. But this wasn’t a unique problem that only impacted Angular.
    Let’s roll back the clock further and look at the last quarter century or so of
    web development history so that you can contextualize modern frameworks like Angular,
    React, and Vue.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Angular 的发展深受性能、用户体验（UX）和开发者体验（DevEx）等因素的影响。但这并非仅影响 Angular 的独特问题。让我们将时钟倒退至过去二十五年左右，回顾一下网络开发的历史，以便你能将现代框架如
    Angular、React 和 Vue 放置在正确的背景中进行理解。
- en: A brief history of web frameworks
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络框架简史
- en: It is essential to understand why we use frameworks such as Angular, React,
    or Vue in the first place to get an appreciation of the value they bring. As the
    web evolves, you may find that, in some cases, the framework is no longer necessary
    and should be discarded, and in others, critical to your business and must be
    retained. Web frameworks rose as JavaScript became more popular and capable in
    the browser. In 2004, the **Asynchronous JavaScript and XML** (**AJAX**) technique
    became very popular in creating websites that did not have to rely on full-page
    refreshes to create dynamic experiences, utilizing standardized web technologies
    like HTML, JavaScript/ECMAScript, and CSS. Browser vendors are supposed to implement
    these technologies as defined by the **World Wide Web Consortium** (**W3C**).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 理解为什么我们最初使用像 Angular、React 或 Vue 这样的框架至关重要，这样才能真正体会到它们带来的价值。随着网络的不断发展，你可能会发现，在某些情况下，框架不再是必需的，应该被舍弃；而在其他情况下，框架对你的业务至关重要，必须保留。随着
    JavaScript 在浏览器中的普及和强大，Web 框架应运而生。在 2004 年，**异步 JavaScript 和 XML**（**AJAX**）技术变得非常流行，用于创建不需要依赖完整页面刷新来创建动态体验的网站，利用了标准化的
    Web 技术，如 HTML、JavaScript/ECMAScript 和 CSS。浏览器供应商应该按照**万维网联盟**（**W3C**）的定义来实现这些技术。
- en: '**Internet Explorer** (**IE**) was the browser that most internet users relied
    on at the time. Microsoft used its market dominance to push proprietary technologies
    and APIs to secure IE’s edge as the go-to browser. Things started to get interesting
    when Mozilla’s Firefox challenged IE’s dominance, followed by Google’s Chrome
    browser. As both browsers successfully gained significant market share, the web
    development landscape became a mess. New browser versions appeared at breakneck
    speed. Competing corporate and technical interests led to the diverging implementation
    of web standards.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**Internet Explorer**（**IE**）是当时大多数互联网用户依赖的浏览器。微软利用其市场主导地位来推广专有技术和 API，以确保
    IE 作为首选浏览器的优势。当 Mozilla 的 Firefox 挑战 IE 的主导地位，随后是 Google 的 Chrome 浏览器出现时，事情开始变得有趣。随着这两个浏览器成功获得显著的市场份额，Web
    开发领域变得混乱。新的浏览器版本以惊人的速度出现。竞争的厂商和技术利益导致了 Web 标准实现的分歧。'
- en: 'This fracturing created an unsustainable environment for developers to deliver
    consistent experiences on the web. Differing qualities, versions, and names of
    implementations of various standards created an enormous challenge: successfully
    writing code that could manipulate the DOM of a browser consistently. Even the
    slightest difference in the APIs and capabilities of a browser would be enough
    to break a website.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种碎片化环境使得开发者难以在网络上提供一致的用户体验。各种标准的实现质量、版本和名称的差异创造了一个巨大的挑战：成功编写能够一致操作浏览器 DOM 的代码。即使是浏览器
    API 和功能的最微小差异也足以破坏一个网站。
- en: The jQuery era
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery 时代
- en: In 2006, jQuery was developed to smooth out the differences between APIs and
    browser capabilities. So instead of repeatedly writing code to check browser versions,
    you could use jQuery, and you were good to go. It hid away all the complexities
    of vendor-specific implementations and gracefully filled the gaps when there were
    missing features. For almost a decade, jQuery became the web development framework.
    It was unimaginable to write an interactive website without using jQuery.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2006 年，jQuery 被开发出来以平滑 API 和浏览器能力之间的差异。因此，你不必反复编写代码来检查浏览器版本，你可以使用 jQuery，一切就绪。它隐藏了供应商特定实现的复杂性，并在功能缺失时优雅地填补了空白。在近十年里，jQuery
    成为了 Web 开发框架。没有使用 jQuery 就无法编写交互式网站的想法是不可想象的。
- en: However, to create vibrant user experiences, jQuery alone was not enough. Native
    web applications ran all their code in the browser, which required fast computers
    to run the dynamically interpreted JavaScript and render web pages using complicated
    object graphs. In the 2000s, many users ran outdated browsers on relatively slow
    computers, so the user experience wasn’t great.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了创建充满活力的用户体验，仅使用 jQuery 是不够的。原生 Web 应用程序在浏览器中运行所有代码，这需要快速的计算机来运行动态解释的 JavaScript
    并使用复杂的对象图来渲染网页。在 2000 年代，许多用户在相对较慢的计算机上运行过时的浏览器，因此用户体验并不理想。
- en: 'Combined with AJAX, jQuery enabled any web developer to create interactive
    and dynamic websites that could run on any browser without running expensive server
    hardware and software. To have a solid understanding of the architectural nuances
    of code that runs on the client and server side, consider a traditional three-tier
    software architecture. Each tier is described in three primary layers, as shown
    in the following diagram:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 结合AJAX，jQuery使任何Web开发者都能够创建在任何浏览器上运行的交互式和动态网站，而无需运行昂贵的服务器硬件和软件。为了对客户端和服务器上运行的代码的架构细微差别有一个坚实的理解，可以考虑传统的三层软件架构。每个层级由三个主要层组成，如下面的图所示：
- en: '![](img/B20960_01_02.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B20960_01_02.png)'
- en: 'Figure 1.2: Three-tiered software architecture'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：三层软件架构
- en: The presentation layer contains **User Interface** (**UI**) related code. This
    is primarily code that runs on the client, referred to as a **thick client**.
    However, the presentation logic can instead reside on the server. In these cases,
    the client becomes a **thin client**. The business layer contains business logic
    and normally resides on the server side. An undisciplined implementation can result
    in business logic spreading across all three layers. This means a bug or a change
    in the logic needs to be implemented in many locations. In reality, no individual
    can locate every occurrence of this logic and can only partially repair code.
    This, of course, results in the creation of more exotic bugs. The persistence
    layer contains code related to data storage.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表示层包含与**用户界面**（**UI**）相关的代码。这主要是运行在客户端的代码，被称为**胖客户端**。然而，表示逻辑可以驻留在服务器上。在这些情况下，客户端变成**瘦客户端**。业务层包含业务逻辑，通常位于服务器端。无序的实现可能导致业务逻辑跨越所有三层。这意味着一个错误或逻辑的变化需要在许多位置实现。实际上，没有人能够定位到这种逻辑的所有发生位置，只能部分修复代码。这当然会导致更复杂的错误产生。持久层包含与数据存储相关的代码。
- en: To write easy-to-maintain and bug-free code, our overall design goal is to aim
    for low coupling and high cohesion between the components of our architecture.
    Low coupling means that pieces of code across these layers shouldn’t depend on
    each other and should be independently replaceable. High cohesion means that pieces
    of code related to each other, like code regarding a particular domain of business
    logic, should remain together. For example, when building an app to manage a restaurant,
    the code for the reservation system should be together and not spread across other
    systems like inventory tracking or user management.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写易于维护且无错误的代码，我们的整体设计目标是追求架构组件之间的低耦合和高内聚。低耦合意味着这些层之间的代码片段不应相互依赖，并且应该是可独立替换的。高内聚意味着相关的代码片段，如特定业务逻辑领域的代码，应保持在一起。例如，当构建一个用于管理餐厅的应用程序时，预订系统的代码应在一起，而不是分散在其他系统，如库存跟踪或用户管理。
- en: 'With jQuery and AJAX, writing thick clients for the web became possible, making
    it easier than ever to write unmaintainable code. Modern web apps have way more
    moving parts than a basic three-tiered application. The diagram that follows shows
    additional layers that fit around the presentation, business, and persistence
    layers:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用jQuery和AJAX，编写Web的胖客户端成为可能，这使得编写难以维护的代码变得比以往任何时候都容易。现代Web应用程序比基本的三层应用程序有更多的移动部件。下面的图显示了适合表示层、业务层和持久层的额外层：
- en: '![](img/B20960_01_03.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B20960_01_03.png)'
- en: 'Figure 1.3: Modern Web Architecture'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：现代Web架构
- en: You can observe the essential components of modern web development in the expanded
    architecture diagram, which includes an API layer that usually transforms and
    transfers data between the presentation and business layers. Beyond code within
    the operating environment, the tools and best practices layer defines and enforces
    patterns used to develop the software. Finally, the testing layer defines a barrage
    of automated tests to ensure the correctness of code, which is crucial in today’s
    iterative and fast-moving development cycles.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在扩展的架构图中观察到现代Web开发的必要组件，该图包括一个通常在表示层和业务层之间转换和传输数据的API层。除了操作环境中的代码之外，工具和最佳实践层定义并强制执行用于开发软件的模式。最后，测试层定义了一系列自动化测试，以确保代码的正确性，这在当今的迭代和快速发展的开发周期中至关重要。
- en: While there was a big appetite to democratize web development with thick clients
    primarily consuming client-side computing resources, the tooling wasn’t ready
    to enforce proper architectural practices and deliver maintainable software. This
    meant businesses kept investing in server-side rendering technologies.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有很多人希望用厚客户端民主化Web开发，主要消耗客户端计算资源，但工具还没有准备好执行适当的架构实践并交付可维护的软件。这意味着企业继续投资于服务器端渲染技术。
- en: The server-side MVC era
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端MVC时代
- en: 'In the late 2000s, many businesses still relied on server-side rendered web
    pages. The server dynamically created all the HTML, CSS, and data needed to render
    a page. The browser acted as a glorified viewer that would display the result.
    The following is a diagram that shows an example architectural overview of a server-side
    rendered web application in the ASP.NET MVC stack:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在2000年代后期，许多企业仍然依赖于服务器端渲染的网页。服务器动态创建渲染页面所需的全部HTML、CSS和数据。浏览器充当了一个被美化的查看器，用于显示结果。以下是一个展示ASP.NET
    MVC堆栈中服务器端渲染的Web应用程序示例架构概述的图表：
- en: '![](img/B20960_01_04.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B20960_01_04.png)'
- en: 'Figure 1.4: Server-side rendered MVC architecture'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：服务器端渲染的MVC架构
- en: '**Model-View-Controller** (**MVC**) is a typical pattern of code that has data
    manipulation logic in models, business logic in controllers, and presentation
    logic in views. In the case of ASP.NET MVC, the controller and model are coded
    using C#, and views are created using a templated version of HTML, JavaScript,
    and C#. The result is that the browser receives HTML, JavaScript, and needed data,
    and through jQuery and AJAX magic, web pages look to be interactive. Server-side
    rendering and MVC patterns are still popular and in use today. There are justified
    niche uses, such as [Facebook.com](http://Facebook.com). Facebook serves billions
    of devices that range from the very slow to the very fast. Without server-side
    rendering, it would be impossible for Facebook to guarantee consistent UX across
    its user base.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（**MVC**）是一种典型的代码模式，其中模型包含数据操作逻辑，控制器包含业务逻辑，视图包含展示逻辑。在ASP.NET MVC的情况下，控制器和模型使用C#编写，视图使用HTML、JavaScript和C#的模板版本创建。结果是浏览器接收HTML、JavaScript和所需数据，通过jQuery和AJAX魔法，网页看起来是交互式的。服务器端渲染和MVC模式至今仍然流行并在使用中。有一些合理的利基用途，例如[Facebook.com](http://Facebook.com)。Facebook服务于从非常慢到非常快的数十亿设备。没有服务器端渲染，Facebook无法保证其用户群的一致UX。'
- en: The combination of server-side rendering and MVC is an intricate pattern to
    execute; there are a lot of opportunities for presentation and business logic
    to become co-mingled. To ensure the low coupling of components, every member of
    the engineering team must be very experienced. Teams with a high concentration
    of senior developers are hard to come by, which would be an understatement.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染和MVC的组合是一个复杂的执行模式；在展示和业务逻辑混合方面有很多机会。为了确保组件的低耦合，工程团队中的每一位成员都必须非常经验丰富。高比例资深开发者的团队很难找到，这还是一种轻描淡写。
- en: Further complicating matters is that C# (or any other server-side language)
    cannot run natively in the browser. So developers who work on server-side rendered
    applications must be equally skilled at using frontend and backend technologies.
    It is easy for inexperienced developers to unintentionally co-mingle presentation
    and business logic in such implementations. When this happens, the inevitable
    UI modernization of an otherwise well-functioning system becomes impossible. In
    other words, to replace the sink in your kitchen with a new one, you must renovate
    your entire kitchen. Due to insufficient architecture, organizations spend millions
    of dollars writing and rewriting the same applications every decade.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步的是，C#（或任何其他服务器端语言）不能在浏览器中本地运行。因此，从事服务器端渲染应用程序的开发者必须同样擅长使用前端和后端技术。在这样实现中，缺乏经验的开发者很容易无意中将展示和业务逻辑混合在一起。当这种情况发生时，原本运行良好的系统的必然UI现代化变得不可能。换句话说，要更换厨房中的水槽，你必须翻新整个厨房。由于架构不足，组织每十年都要花费数百万美元来编写和重写相同的应用程序。
- en: Rich client era
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 丰富客户端时代
- en: In the 2000s, it was possible to build rich web applications decoupled from
    their server APIs using Java Applets, Flash, or Silverlight. However, these technologies
    relied on browser plugins that needed a separate installation. Most often, these
    plugins were outdated, created critical security vulnerabilities, and consumed
    too much power on mobile computers. Following the iPhone revolution in 2008, it
    was clear such plugins wouldn’t run on mobile phones, despite the best attempts
    by the Android OS. Besides, Apple CEO Steve Jobs’ disdain for such inelegant solutions
    marked the beginning of the end for the support of such technologies in the browser.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在2000年代，使用Java Applets、Flash或Silverlight等技术可以构建与服务器API解耦的丰富Web应用程序。然而，这些技术依赖于浏览器插件，需要单独安装。通常，这些插件已经过时，创建了关键的安全漏洞，并且在移动计算机上消耗了过多的电力。在2008年iPhone革命之后，很明显，即使Android操作系统做出了最好的努力，这样的插件也无法在手机上运行。此外，苹果公司CEO史蒂夫·乔布斯对这种不优雅的解决方案的厌恶标志着在浏览器中对这种技术支持结束的开始。
- en: In the early 2010s, frameworks like Backbone and AngularJS started showing up,
    demonstrating how to build rich web applications with a native feel and speed
    and do so in a seemingly cost-effective way. The following diagram shows a **Model-View-ViewModel**
    (**MVVM**) client with a **Representational State Transfer** (**REST**) API. When
    we decouple the client from the server via an API, we can architecturally enforce
    the implementation of presentation and business logic separately. Theoretically,
    this RESTful web services pattern would allow us to replace the kitchen sink as
    often as possible without remodeling the entire kitchen.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在2010年代初，像Backbone和AngularJS这样的框架开始出现，展示了如何以原生感觉和速度构建丰富的Web应用程序，并且似乎以成本效益的方式做到这一点。以下图表展示了一个**模型-视图-视图模型**（**MVVM**）客户端和一个**表示状态转换**（**REST**）API。当我们通过API将客户端从服务器解耦时，我们可以在架构上强制实施将表示和业务逻辑分开实现。从理论上讲，这种RESTful
    Web服务模式将允许我们尽可能多地替换厨房用具，而无需重新装修整个厨房。
- en: '![](img/B20960_01_05.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B20960_01_05.png)'
- en: 'Figure 1.5: Rich-client decoupled MVVM architecture'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5：富客户端解耦MVVM架构
- en: The MVVM architecture above shows a near doubling of boxes compared to the server-side
    MVC architecture. Does this mean we need to write twice as much code? Yes and
    no. Yes, we need to write more code to maintain a disciplined architecture; however,
    over time, we’ll write a lot less code because of the overall maintainability
    of the solution. The architecture surrounding the presentation logic indeed becomes
    a lot more complicated. The client and server must implement their presentation/API,
    business, and persistence layers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上述MVVM架构与服务器端MVC架构相比，箱子的数量几乎翻了一番。这意味着我们需要编写两倍多的代码吗？是的，也不完全是。是的，我们需要编写更多的代码来维护一个有纪律的架构；然而，随着时间的推移，我们将因为解决方案的整体可维护性而编写更少的代码。围绕表示逻辑的架构确实变得更加复杂。客户端和服务器必须实现它们的表示/API、业务和持久化层。
- en: Unfortunately, many early development efforts leveraging frameworks like Backbone
    and AngularJS collapsed under their weight because they failed to implement the
    client-side architecture properly.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，许多利用Backbone和AngularJS等框架的早期开发工作因为未能正确实现客户端架构而失败。
- en: These early development efforts also suffered from ill-designed RESTful Web
    APIs. Most APIs didn’t version their URIs, making it very difficult to introduce
    new functionality while supporting existing clients. Further, APIs often returned
    complicated data models exposing their internal relational data models to web
    apps. This design flaw creates a tight coupling between seemingly unrelated components/views
    written in HTML and models created in SQL. If you don’t implement additional layers
    of code to translate or map the structure of data, then you create an unintentional
    and uncontrolled coupling between layers. Over time, dealing with such coupling
    becomes very expensive very quickly, in most cases necessitating significant rewrites.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些早期的开发工作也受到了设计不良的RESTful Web API的困扰。大多数API没有对其URI进行版本控制，这使得在支持现有客户端的同时引入新功能变得非常困难。此外，API经常返回复杂的数据模型，将它们的内部关系数据模型暴露给Web应用程序。这种设计缺陷在用HTML编写的看似无关的组件/视图和用SQL创建的模型之间创建了一个紧密的耦合。如果你不实现额外的代码层来转换或映射数据结构，那么你将在层之间创建一个无意和不受控制的耦合。随着时间的推移，处理这种耦合变得非常昂贵，在大多数情况下需要重大的重写。
- en: Today, we use the API layer to flatten the data model before sending it to the
    client to avoid such problems. Newer technologies like GraphQL go further by exposing
    a well-defined data model and letting the consumer query for the exact data it
    needs. Using GraphQL, the number of HTTP requests and the amount of data transferred
    over the wire is optimal without the developers having to create many specialized
    APIs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们在将数据模型发送到客户端之前，使用API层将其扁平化，以避免出现此类问题。像GraphQL这样的新技术更进一步，通过暴露一个定义良好的数据模型，并允许消费者查询所需的确切数据。使用GraphQL，HTTP请求的数量和通过网络传输的数据量是最优的，而无需开发者创建许多专门的API。
- en: Backbone and AngularJS proved that creating web applications that run natively
    in the browser was viable. All SPA frameworks at the time relied on jQuery for
    DOM manipulation. Meanwhile, web standards continued to evolve, and evergreen
    browsers supporting new standards became commonplace. However, change is constant,
    and the evolution of web technologies made it unsustainable to gracefully evolve
    this first generation of SPA frameworks, as I hinted in the *Two Angulars* section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone和AngularJS证明了在浏览器中本地运行Web应用程序是可行的。当时所有的SPA框架都依赖于jQuery进行DOM操作。同时，网络标准持续发展，支持新标准的永续浏览器变得司空见惯。然而，变化是永恒的，网络技术的发展使得第一代SPA框架的优雅演进变得不可持续，正如我在“两个Angular”部分所暗示的。
- en: The next generation of web frameworks needed to solve many problems; they needed
    to enforce good architecture, be designed to evolve with web standards and be
    stable and scalable to enterprise needs without collapsing. Also, these new frameworks
    needed to gain acceptance from developers, who were burned out with too many rapid
    changes in the ecosystem. Remember, unhappy developers do not create successful
    businesses. Achieving these goals required a clean break from the past, so Angular
    and React emerged as platforms to address the problems of the past in different
    ways. As you’ll discover in the following sections, Angular offers the best tools
    and architecture for building scalable enterprise-grade applications.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 新一代Web框架需要解决许多问题；它们需要强制实施良好的架构，设计用于与网络标准同步发展，并且要稳定且可扩展以满足企业需求，而不会崩溃。此外，这些新框架需要获得开发者的认可，因为开发者已经厌倦了生态系统中太多的快速变化。记住，不快乐的开发者不会创造成功的业务。实现这些目标需要与过去彻底决裂，因此Angular和React作为平台以不同的方式解决了过去的问题。正如你将在接下来的章节中发现的那样，Angular提供了构建可扩展企业级应用程序的最佳工具和架构。
- en: Angular and the philosophies behind it
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular及其背后的哲学
- en: Angular is an open-source project maintained by Google and a community of developers.
    The new Angular platform vastly differs from the legacy framework you may have
    used. In collaboration with Microsoft, Google made TypeScript the default language
    for Angular. TypeScript is a superset of JavaScript that enables developers to
    target legacy browsers, such as Internet Explorer 11, while allowing them to write
    modern JavaScript code that works in evergreen browsers such as Chrome, Firefox,
    and Edge. The legacy version of Angular in the 1.x range, called AngularJS, was
    a monolithic JavaScript SPA framework. The modern version, Angular 2+, is a platform
    capable of targeting browsers, hybrid-mobile frameworks, desktop applications,
    and server-side rendered views.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是由Google和一群开发者维护的开源项目。新的Angular平台与您可能使用过的传统框架大相径庭。在与微软合作的过程中，Google将TypeScript设为Angular的默认语言。TypeScript是JavaScript的超集，它使开发者能够针对旧版浏览器，如Internet
    Explorer 11，同时允许他们编写在现代浏览器（如Chrome、Firefox和Edge）中运行的现代JavaScript代码。Angular 1.x范围内的传统版本，称为AngularJS，是一个单体JavaScript
    SPA框架。现代版本，Angular 2+，是一个能够针对浏览器、混合移动框架、桌面应用程序和服务器端渲染视图的平台。
- en: In the prior generation, upgrading to new versions of AngularJS was risky and
    costly because even minor updates introduced new coding patterns and experimental
    features. Each update introduced deprecations or refactored API surfaces, requiring
    rewriting of large portions of code. Also, updates were delivered in uncertain
    intervals, making it impossible for a team to plan resources to upgrade to a new
    version. The release methodology eventually led to an unpredictable, ever-evolving
    framework with seemingly no guiding hand to carry code bases forward. If you used
    AngularJS, you were likely stuck on a particular version because the specific
    architecture of your code base made it very difficult to move to a new version.
    In 2018, the Angular team released the last major update to AngularJS with version
    1.7\. This release marked the beginning of the end for the legacy framework, with
    end-of-life coming in January 2022.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一代中，升级到AngularJS的新版本是风险和成本高昂的，因为即使是微小的更新也引入了新的编码模式和实验性功能。每次更新都会引入弃用或重构API表面，需要重写大量代码。此外，更新以不确定的间隔交付，使得团队无法计划资源以升级到新版本。发布方法最终导致了一个不可预测、不断演变的框架，似乎没有任何指导之手来推动代码库向前发展。如果你使用AngularJS，你很可能会卡在特定版本上，因为你的代码库的特定架构使得迁移到新版本非常困难。2018年，Angular团队发布了AngularJS的最后一个主要更新，版本为1.7。这次发布标志着旧框架的终结，其生命周期的结束定于2022年1月。
- en: Deterministic releases
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定性发布
- en: 'Angular improves upon AngularJS in every way imaginable. The platform follows
    **semver**, as defined at [https://semver.org/](https://semver.org/), where minor
    version increments denote new feature additions and potential deprecation notices
    for the following major version, but no breaking changes. Furthermore, the Angular
    team at Google has committed to a deterministic release schedule with major versions
    released every 6 months. After this 6-month development window, starting with
    Angular 4, all major releases receive LTS with bug fixes and security patches
    for an additional 12 months. From release to end-of-life, each major version receives
    updates for 18 months. Refer to the following chart for the tentative release
    and support schedule for Angular:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Angular在各个方面都优于AngularJS。该平台遵循[https://semver.org/](https://semver.org/)中定义的**semver**，其中次要版本增量表示新功能添加和下一个主要版本的潜在弃用通知，但没有破坏性更改。此外，谷歌的Angular团队承诺了一个确定性的发布计划，每6个月发布一个主要版本。在此6个月的开发窗口之后，从Angular
    4开始，所有主要版本都收到LTS支持，包括额外的12个月的错误修复和安全补丁。从发布到生命周期的结束，每个主要版本都会收到18个月的更新。请参考以下图表，了解Angular的预期发布和支持计划：
- en: '![](img/B20960_01_06.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B20960_01_06.png)'
- en: 'Figure 1.6: Actively supported versions'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6：活跃支持版本
- en: What does this mean for you? You can be confident that your Angular code is
    supported and backward compatible for approximately 24 months, even if you make
    no changes to it. For example, if you wrote an Angular app in version 17 in November
    2023, and you didn’t use any deprecated functionality, your code will be runtime
    compatible with Angular 18 and supported through May 2025\. To upgrade your Angular
    17 code to Angular 19, you must ensure that you’re not using any deprecated APIs
    that receive a deprecation notice in Angular 18.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这对你意味着什么？你可以确信，即使你对Angular代码没有任何改动，你的Angular代码大约在24个月内都将得到支持和向后兼容。例如，如果你在2023年11月使用版本17编写了一个Angular应用，并且你没有使用任何弃用功能，你的代码将与Angular
    18运行时兼容，并且支持到2025年5月。要将你的Angular 17代码升级到Angular 19，你必须确保你没有使用Angular 18中收到弃用通知的任何弃用API。
- en: In practice, most deprecations are minor and are straightforward to refactor.
    Unless you work with low-level APIs for highly specialized user experiences, the
    time and effort it takes to update your code base should be minimal. However,
    this is a promise made by Google and not a contract. The Angular team has a significant
    incentive to ensure backward compatibility because Google runs around 1,000+ Angular
    apps with a single version of Angular active at any one time throughout the organization.
    So, by the time you read this, all of Google’s 1,000+ apps will be running on
    the latest version of Angular.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，大多数弃用都是微小的，并且重构起来非常直接。除非你使用针对高度专业用户体验的低级API，否则更新你的代码库所需的时间和精力应该是微不足道的。然而，这是谷歌做出的承诺，而不是合同。Angular
    团队有重大动力确保向后兼容性，因为谷歌在组织内部运行着大约1,000多个Angular应用，任何时候只有一个版本的Angular处于活跃状态。因此，在你阅读这段文字的时候，谷歌的所有1,000多个应用都将运行在Angular的最新版本上。
- en: First-class upgrades
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 首要升级
- en: You may think Google has infinite resources to update thousands of apps regularly.
    Like any organization, Google, too, has limited resources. It would be too expensive
    to assign a dedicated team to maintain every app. So the Angular team must ensure
    compatibility through automated tests and make it as painless as possible to move
    through major releases in the future. In Angular 6 `ng update` was introduced,
    making the update process a first-class experience.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能认为谷歌有无限的资源来定期更新数千个应用程序。像任何组织一样，谷歌的资源也是有限的。为每个应用程序分配一个专门的团队来维护将过于昂贵。因此，Angular团队必须通过自动化测试确保兼容性，并尽可能使未来通过主要版本变得无痛。在Angular
    6中引入了`ng update`，使更新过程成为一流的体验。
- en: The Angular team continually improves its release process with automated CLI
    tools to make upgrading deprecated functionality a mostly automated, reasonable
    endeavor. Air France and KLM demonstrated this strategy’s benefits, reducing their
    upgrade times from 30 days in Angular 2 to 1 day in Angular 7.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Angular团队通过自动化CLI工具不断改进其发布流程，使升级过时的功能成为一个主要自动化的、合理的努力。法国航空和荷兰皇家航空展示了这种策略的好处，将他们的升级时间从Angular
    2的30天减少到Angular 7的1天。
- en: 'A predictable and well-supported upgrade process is excellent news for developers
    and organizations. Instead of being perpetually stuck on a legacy version of Angular,
    you can plan and allocate the necessary resources to keep moving your application
    to the future without costly rewrites. As I wrote in a 2017 blog post, *The Best
    New Feature of Angular 4*, at [https://bit.ly/NgBestFeature](https://bit.ly/NgBestFeature),
    the message is clear:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可预测且得到良好支持的升级过程对开发者和组织来说是个好消息。您不必永远停留在Angular的旧版本上，您可以计划和分配必要的资源，以保持您的应用程序不断向未来迈进，而无需昂贵的重写。正如我在2017年的博客文章《Angular
    4的最佳新功能》中写道，[https://bit.ly/NgBestFeature](https://bit.ly/NgBestFeature)，信息很明确：
- en: '**For developers and managers:** Angular is here to stay, so you should be
    investing your time, attention, and money in learning it – even if you’re currently
    in love with some other framework.'
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**对于开发者和管理者：**Angular将长期存在，因此您应该投资时间、注意力和金钱来学习它——即使您目前对某些其他框架情有独钟。'
- en: ''
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**For decision makers (CIOs, CTOs, and so on):** Plan to begin your transition
    to Angular in the next 6 months. It’ll be an investment you’ll be able to explain
    to business-minded people, and your investment will pay dividends for many years
    to come, long after the initial LTS window expires, with graceful upgrade paths
    to Angular vNext and beyond.'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**对于决策者（CIOs、CTOs等）：**计划在接下来的6个月内开始您的Angular迁移。这将是一项您可以向有商业头脑的人解释的投资，您的投资将在未来多年内带来回报，远远超过初始LTS窗口到期，并且有优雅的升级路径到Angular
    vNext以及更远。'
- en: 'So why do Google (Angular) and Microsoft (TypeScript and Visual Studio Code)
    give away such technologies for free? There are multiple reasons:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么谷歌（Angular）和微软（TypeScript和Visual Studio Code）会免费提供这样的技术？有多个原因：
- en: A sophisticated framework that makes it easy to develop web apps demonstrates
    technical prowess, which retains and attracts developer talent.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个复杂的框架使得开发Web应用程序变得容易，这展示了技术实力，可以保留和吸引开发者人才。
- en: An open-source framework enables the proving and debugging of new ideas and
    tools with millions of developers at scale.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个开源框架使得数百万开发者可以大规模地验证和调试新想法和工具。
- en: Allowing developers to create great web experiences drives more business for
    Google and Microsoft.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许开发者创造出色的Web体验，为谷歌和微软带来更多商业机会。
- en: I don’t see any nefarious intent here and welcome open, mature, and high-quality
    tools that, if necessary, I can tinker with and bend to my own will. Not having
    to pay for a support contract for a proprietary piece of tech is a welcome bonus.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里看不到任何恶意意图，并欢迎开放、成熟和高品质的工具，如果需要，我可以对其进行调整以适应我的意愿。不必为专有技术的支持合同付费是一个受欢迎的额外好处。
- en: Beware - looking for Angular help on the web may be tricky. You’ll need to disambiguate
    between AngularJS or Angular, which may be referred to as Angular2, but also be
    aware that some advice given about versions 13 or below may not apply to 14+ because
    of the rendering engine change to Ivy. I always recommend reading the official
    documentation when learning. Documentation for Angular is at [https://angular.dev](https://angular.dev).
    This should not be confused with [angularjs.org](https://angularjs.org), which
    is about the legacy AngularJS framework or the retired [angular.io](http://angular.io)
    site.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 警惕 - 在网上寻找Angular帮助可能会很棘手。您需要区分AngularJS或Angular，它们可能被称为Angular2，但也要意识到，关于版本13或以下的一些建议可能不适用于14+，因为渲染引擎已更改为Ivy。我总是建议在学习时阅读官方文档。Angular的文档在[https://angular.dev](https://angular.dev)。这不应与[angularjs.org](https://angularjs.org)混淆，后者是关于遗留的AngularJS框架或已退役的[angular.io](http://angular.io)网站。
- en: For the latest updates on the upcoming Angular releases, view the official release
    schedule at [https://angular.dev/reference/releases](https://angular.dev/reference/releases).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看即将发布的Angular版本的最新更新，请查看官方发布时间表[https://angular.dev/reference/releases](https://angular.dev/reference/releases)。
- en: Maintainability
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可维护性
- en: Your time is valuable, and your happiness is paramount, so you must carefully
    choose the technologies to invest your time in. With this in mind, we must answer
    why Angular is the tool you should learn over React, Vue, or others. Angular is
    a great framework to start learning. The framework and the tooling help you get
    off the ground quickly and continue being successful, with a vibrant community
    and high-quality UI libraries you can use to deliver exceptional web applications.
    React and Vue are great libraries with their strengths and weaknesses. Every tool
    has its place and purpose.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您的时间宝贵，您的幸福至关重要，因此您必须仔细选择投入时间的科技。考虑到这一点，我们必须回答为什么Angular是您应该学习超过React、Vue或其他技术的工具。Angular是一个伟大的框架，适合开始学习。该框架和工具可以帮助您快速起步并持续成功，拥有充满活力的社区和高质量的UI库，您可以使用它们来交付卓越的Web应用程序。React和Vue是具有其优势和劣势的伟大库。每个工具都有其位置和目的。
- en: 'In some cases, React is the right choice for a project, while Vue is the right
    one in others. Becoming somewhat proficient in other web frameworks can only help
    further your understanding of Angular and make you a better developer overall.
    SPAs such as Backbone and AngularJS grabbed my full attention in 2012 when I realized
    the importance of decoupling frontend and backend concerns. Server-side rendered
    templates are nearly impossible to maintain and are the root cause of many expensive
    rewrites of software systems. If you care about creating maintainable software,
    you must abide by the prime directive: keep the business logic behind the API
    decoupled from the presentation logic implemented in the UI.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，React是项目的正确选择，而在其他情况下，Vue才是正确的选择。在某种程度上精通其他Web框架只能帮助您进一步理解Angular，并使您成为一名更好的开发者。在2012年，当我意识到解耦前端和后端关注点的重要性时，Backbone和AngularJS这样的SPA（单页应用程序）完全吸引了我的注意力。服务器端渲染的模板几乎无法维护，并且是许多昂贵的软件系统重写的根本原因。如果您关心创建可维护的软件，您必须遵守首要指令：保持API背后的业务逻辑与在UI中实现的展示逻辑解耦。
- en: Angular neatly fits the Pareto principle or the 80-20 rule. It has become a
    mature and evolving platform, allowing you to achieve 80% of tasks with 20% of
    the effort. As mentioned in the previous section, every major release is supported
    for 18 months, creating a continuum of learning, staying up to date, and deprecating
    old features. From the perspective of a full-stack developer, this continuum is
    invaluable since your skills and training will remain relevant and fresh for many
    years to come.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Angular完美符合帕累托原则或80-20法则。它已成为一个成熟且不断发展的平台，让您可以用20%的努力完成80%的任务。如前所述，每个主要版本都支持18个月，创造了一个学习的连续性，保持最新，并弃用旧功能。从全栈开发者的角度来看，这种连续性是无价的，因为您的技能和培训将在未来许多年里保持相关和新鲜。
- en: The philosophy behind Angular is to err on the side of configuration over convention.
    Although convention-based frameworks may seem elegant from the outside, they make
    it difficult for newcomers to pick up the framework. Configuration-based frameworks
    aim to expose their inner workings through explicit configuration and hooks, where
    you can attach your custom behavior to the framework. In essence, where AngularJS
    had tons of magic, which can be confusing, unpredictable, and challenging to debug,
    Angular tries to be non-magical.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的哲学是在配置和惯例之间倾向于配置。尽管基于惯例的框架在外观上可能看起来很优雅，但它们让新来者难以掌握框架。基于配置的框架旨在通过显式的配置和钩子来揭示其内部工作原理，你可以在这些钩子中附加你的自定义行为到框架中。本质上，AngularJS
    有很多魔法，这些魔法可能会让人困惑、不可预测，并且难以调试，而 Angular 则试图避免这些魔法。
- en: 'Configuration over convention results in verbose coding. Verbosity is a good
    thing. Terse code is the enemy of maintainability, only benefiting the original
    author. As Andy Hunt and David Thomas put it in *The Pragmatic Programmer*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 配置优于惯例导致代码冗长。冗长是好事。简洁的代码是可维护性的敌人，只对原始作者有利。正如 Andy Hunt 和 David Thomas 在 *《实用程序员》*
    中所说：
- en: Remember that you (and others after you) will be reading the code many hundreds
    of times, but only writing it a few times.
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 记住，你（以及你之后的人）将多次阅读代码，但只编写几次。
- en: 'Further, Andy Hunt’s *Law of Design* dictates:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Andy Hunt 的 *设计法则* 规定：
- en: If you can’t rip every piece out easily, then the design sucks.
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你不能轻易地移除每一部分，那么设计就是失败的。
- en: Verbose, decoupled, cohesive, and encapsulated code is the key to future-proofing
    your code. Through its various mechanisms, Angular enables the proper execution
    of these concepts. It eliminates many custom conventions invented in AngularJS,
    such as `ng-click`, and introduces a more natural language that builds on the
    existing HTML elements and properties. As a result, `ng-click` becomes `(click)`,
    extending HTML rather than replacing it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 详尽、解耦、一致和封装的代码是确保你的代码面向未来的关键。通过其各种机制，Angular 使这些概念得到适当的执行。它消除了 AngularJS 中许多自定义惯例，如
    `ng-click`，并引入了一种更自然的语言，它建立在现有的 HTML 元素和属性之上。因此，`ng-click` 变成了 `(click)`，它扩展了
    HTML 而不是取代它。
- en: Next, we’ll review Angular’s evergreen mindset and the reactive programming
    paradigm, the latest extensions of Angular’s initial philosophy.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回顾 Angular 的持续更新心态和响应式编程范式，这是 Angular 初始哲学的最新扩展。
- en: Angular Evergreen
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular Evergreen
- en: When you’re learning Angular, you’re not learning one specific version of Angular
    but a platform that is continually evolving. Since the first drafts, I designed
    this book to deemphasize the specific version of Angular you’re using. The Angular
    team champions this idea. Over the years, I have had many conversations with the
    Angular team and thought leaders within the community and listened to many presentations.
    As a result, you can depend on Angular as a mature web development platform. Angular
    frequently receives updates with great attention to backward compatibility. Furthermore,
    any code made incompatible by a new version is brought forward with help from
    automated tools or explicit guidance on updating your code by locating the **Angular
    Update Guide** on [https://angular.dev/update](https://angular.dev/update), so
    you’re never left guessing or scouring the internet for answers. The Angular team
    is committed to ensuring you – the developer – have the best web development experience
    possible.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在学习 Angular 时，你不仅仅是在学习 Angular 的一个特定版本，而是在学习一个不断发展的平台。自从最初的草案以来，我设计这本书时就是为了淡化你所使用的
    Angular 的特定版本。Angular 团队支持这一理念。多年来，我与 Angular 团队以及社区中的思想领袖进行了许多对话，并聆听了许多演讲。因此，你可以依赖
    Angular 作为成熟的 Web 开发平台。Angular 经常会进行更新，并且非常注重向后兼容性。此外，任何因新版本而变得不兼容的代码，都可以通过自动化工具的帮助或通过在
    [https://angular.dev/update](https://angular.dev/update) 上定位 **Angular 更新指南**
    来获得明确的指导来更新你的代码，这样你就永远不会感到困惑或在网上寻找答案。Angular 团队致力于确保你——开发者——拥有最佳的 Web 开发体验。
- en: 'To bring this idea front and center with developers, several colleagues and
    I have developed and published a Visual Studio Code extension called Angular Evergreen,
    as shown in the following image:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这个理念清晰地传达给开发者，我和几位同事一起开发并发布了一个名为 Angular Evergreen 的 Visual Studio Code 扩展，如下面的图像所示：
- en: '![](img/B20960_01_07.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B20960_01_07.png)'
- en: 'Figure 1.7: Angular Evergreen VS Code extension'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7：Angular Evergreen VS Code 扩展
- en: This extension detects your current version of Angular and compares it to the
    latest and next releases of Angular. Releases labeled next are meant for early
    adopters and testing your code’s compatibility with an upcoming version of Angular.
    Do not use next-labeled releases for production deployments.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此扩展检测您当前的 Angular 版本，并将其与 Angular 的最新和下一个版本进行比较。标记为“下一个”的版本是为早期采用者和测试您的代码与即将推出的
    Angular 版本的兼容性而设计的。不要在生产部署中使用标记为“下一个”的版本。
- en: Find more information, feature requests, and bug reports on the Angular Evergreen
    extension at [https://AngularEvergreen.com](https://AngularEvergreen.com).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[Angular Evergreen 扩展](https://AngularEvergreen.com)的网站上找到更多信息、功能请求和错误报告。
- en: One of the critical components of Angular that allows the platform to remain
    evergreen is TypeScript. TypeScript allows new features to be implemented efficiently
    while supporting older browsers, so your code can reach the widest audience possible.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的一个关键组件是 TypeScript，它使平台能够保持始终如一。TypeScript 允许高效地实现新功能，同时支持旧浏览器，因此您的代码可以触及尽可能广泛的受众。
- en: TypeScript
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript
- en: Angular is coded using TypeScript. Anders Hejlsberg of Microsoft created TypeScript
    to address several major issues with applying JavaScript at a large enterprise
    scale.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 使用 TypeScript 编码。微软的安德斯·海尔斯伯格创建了 TypeScript，以解决在大型企业规模上应用 JavaScript
    的几个主要问题。
- en: Anders Hejlsberg is the creator of Turbo Pascal and C# and Delphi’s chief architect.
    Anders designed C# to be a developer-friendly language built upon the familiar
    syntax of C and C++. As a result, C# became the language behind Microsoft’s popular
    .NET Framework. TypeScript shares a similar pedigree with Turbo Pascal and C#
    and their ideals, which made them a great success.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 安德斯·海尔斯伯格是 Turbo Pascal 和 C# 的创造者，以及 Delphi 的首席架构师。安德斯设计了 C# 以成为一个对开发者友好的语言，它建立在
    C 和 C++ 的熟悉语法之上。因此，C# 成为微软流行的 .NET 框架背后的语言。TypeScript 与 Turbo Pascal 和 C# 以及它们的理念有着相似的血统，这使它们取得了巨大的成功。
- en: JavaScript is a dynamically interpreted language where the browser parses and
    understands the code you write at runtime. Statically typed languages like Java
    or C# have an additional compilation step where the compiler can catch programming
    and logic errors during compile time. Detecting and fixing bugs at compile time
    versus runtime is much cheaper. TypeScript brings the benefits of statically typed
    languages to JavaScript by introducing types and generics. However, TypeScript
    is not a compiler in the traditional sense. It is a transpiler. A compiler builds
    code into machine language with C/C++ or **Intermediary Language** (**IL**) with
    Java or C#. A transpiler, however, transforms the code from one dialect to another.
    So, when TypeScript code is built, compiled, or transpiled, the result is pure
    JavaScript.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种动态解释语言，浏览器在运行时解析和理解您编写的代码。像 Java 或 C# 这样的静态类型语言有一个额外的编译步骤，编译器可以在编译时捕获编程和逻辑错误。在编译时与运行时检测和修复错误要便宜得多。TypeScript
    通过引入类型和泛型将静态类型语言的优点带到了 JavaScript。然而，TypeScript 并不是传统意义上的编译器。它是一个转译器。编译器使用 C/C++
    将代码编译成机器语言，或者使用 Java 或 C# 的**中间语言**（**IL**）。然而，转译器将代码从一种方言转换成另一种方言。因此，当 TypeScript
    代码被构建、编译或转译时，结果是纯 JavaScript。
- en: JavaScript’s official name is ECMAScript. The language’s feature set and syntax
    are maintained by the ECMA Technical Committee 39, or TC39 for short.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的官方名称是 ECMAScript。该语言的特性和语法由 ECMA 技术委员会 39，简称 TC39 维护。
- en: Transpilation has another significant benefit. The same tooling that converts
    TypeScript to JavaScript can be used to rewrite JavaScript with a new syntax to
    an older version that older browsers can parse and execute. Between 1999 and 2009,
    the JavaScript language didn’t see any new features. ECMAScript abandoned version
    4 due to various technical and political reasons. Browser vendors have struggled
    to implement new JavaScript features within their browsers, starting with the
    introduction of ES5 and then ES2015 (also known as ES6).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 转译还有另一个显著的好处。将 TypeScript 转换为 JavaScript 的相同工具也可以用来将 JavaScript 重新编写为旧语法，以便旧浏览器可以解析和执行。在
    1999 年到 2009 年间，JavaScript 语言没有看到任何新特性。由于各种技术和政治原因，ECMAScript 放弃了版本 4。浏览器供应商在他们的浏览器中实施新的
    JavaScript 特性时遇到了困难，从 ES5 的引入开始，然后是 ES2015（也称为 ES6）。
- en: 'As a result, user adoption of these new features has remained low. However,
    these new features meant developers could write code more productively. This created
    a gap known as the JavaScript Feature Gap, as demonstrated by the graphic that
    follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，用户对这些新特性的采用率一直很低。然而，这些新特性意味着开发者可以更高效地编写代码。这产生了一个被称为 JavaScript 特性差距的差距，如下面的图形所示：
- en: '![](img/B20960_01_08.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B20960_01_08.png)'
- en: 'Figure 1.8: The JavaScript Feature Gap'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8：JavaScript 特性差距
- en: The JavaScript Feature Gap is sliding, as TC39 has committed to updating JavaScript
    every year. As a result, TypeScript represents JavaScript’s past, present, and
    future. You can use future features of JavaScript today and still be able to target
    browsers of the past to maximize the audience you can reach. In 2023, this gap
    is smaller than ever, with ES2022 being a mature language with wide support from
    every major browser.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 特性差距正在缩小，因为 TC39 承诺每年更新 JavaScript。因此，TypeScript 代表了 JavaScript 的过去、现在和未来。你可以使用
    JavaScript 的未来特性，同时仍然能够针对过去的浏览器，以最大化你能够触及的受众。到 2023 年，这个差距比以往任何时候都要小，ES2022 是一种成熟的语言，得到了每个主要浏览器的广泛支持。
- en: Now, let’s go over Angular’s underlying architecture.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来了解一下 Angular 的底层架构。
- en: Component architecture
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件架构
- en: 'Angular follows the MV* pattern, a hybrid of the MVC and MVVM patterns. Previously,
    we went over the MVC pattern. At a high level, the architecture of both patterns
    is relatively similar, as shown in the diagram that follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 遵循 MV* 模式，这是 MVC 和 MVVM 模式的混合体。之前，我们讨论了 MVC 模式。从高层次来看，这两种模式的架构相对相似，如下面的图所示：
- en: '![](img/B20960_01_09.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B20960_01_09.png)'
- en: 'Figure 1.9: MV* architecture'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9：MV* 架构
- en: The new concept here is the ViewModel, which represents the glue code that connects
    your view to your model or service. In Angular, this glue is known as binding.
    Whereas MVC frameworks like Backbone or React must call a `render` method to process
    their HTML templates, in Angular, this process is seamless and transparent for
    the developer. Binding is what differentiates an MVC application from an MVVM
    one.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的新概念是 ViewModel，它代表连接你的视图到你的模型或服务的粘合代码。在 Angular 中，这种粘合被称为绑定。与像 Backbone 或
    React 这样的 MVC 框架必须调用 `render` 方法来处理它们的 HTML 模板不同，在 Angular 中，这个过程对开发者来说是无缝且透明的。绑定是区分
    MVC 应用程序和 MVVM 应用程序的关键。
- en: 'The most basic unit of an Angular app is a component. A component combines
    a JavaScript class, written in TypeScript, and an Angular template, written in
    HTML, CSS, and TypeScript, as one element. The class and the template fit together
    like a jigsaw puzzle through bindings so that they can communicate with each other,
    as shown in the diagram that follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 应用程序中最基本的单元是一个组件。组件将一个 TypeScript 编写的 JavaScript 类和一个 Angular 模板（由 HTML、CSS
    和 TypeScript 编写）结合成一个元素。通过绑定，类和模板就像拼图一样契合在一起，以便它们可以相互通信，如下面的图所示：
- en: '![](img/B20960_01_10.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B20960_01_10.png)'
- en: 'Figure 1.10: Anatomy of a component'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10：组件解剖结构
- en: Classes are an **Object-Oriented Programming** (**OOP**) construct. If you invest
    the time to dig deeper into the OOP paradigm, you will vastly improve your understanding
    of how Angular works. The OOP paradigm allows for the **Dependency Injection**
    (**DI**) of dependent services in your components, so you can make HTTP calls
    or trigger a toast message to be displayed to the user without pulling that logic
    into your component or duplicating your code. DI makes it very easy for developers
    to use many interdependent services without worrying about the order of the instantiation,
    initialization, or destruction of such objects from memory.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 类是面向对象编程（**OOP**）的结构。如果你投入时间深入研究 OOP 范式，你会大大提高你对 Angular 的工作原理的理解。OOP 范式允许在组件中注入依赖服务，这样你就可以进行
    HTTP 调用或触发显示给用户的 toast 消息，而无需将这种逻辑拉入你的组件或复制你的代码。依赖注入使得开发者能够轻松地使用许多相互依赖的服务，而无需担心这些对象从内存中实例化、初始化或销毁的顺序。
- en: Angular templates allow similar code reuse via directives, pipes, user controls,
    and other components. These are pieces of code that encapsulate highly interactive
    end-user code. This kind of interactivity code is often complicated and convoluted
    and must be kept isolated from business logic or presentation logic to keep your
    code maintainable.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 模板允许通过指令、管道、用户控件和其他组件进行类似的代码重用。这些是封装高度交互式最终用户代码的代码片段。这种交互式代码通常很复杂且错综复杂，必须将其与业务逻辑或展示逻辑隔离，以保持代码的可维护性。
- en: Angular 17 introduces a new **control flow syntax** (in preview), which replaces
    directives like `*ngIf` with `@if`, `*ngFor` with `@for`, and `*ngSwitch` with
    `@switch` and introduces `@empty`, `@defer`, contextual variables, and conditional
    statements. The new syntax makes templates easier to read and avoids importing
    legacy directives to every component in a standalone project. This book will exclusively
    use the control flow syntax.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 17 引入了一种新的 **控制流语法**（处于预览状态），它用 `@if` 替换了 `*ngIf`，用 `@for` 替换了 `*ngFor`，用
    `@switch` 替换了 `*ngSwitch`，并引入了 `@empty`、`@defer`、上下文变量和条件语句。新的语法使得模板更容易阅读，并避免了在独立项目中将遗留指令导入到每个组件中。本书将专门使用控制流语法。
- en: You can run `npx ng generate @angular/core:control-flow` to convert your existing
    template to the new syntax.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `npx ng generate @angular/core:control-flow` 命令将现有的模板转换为新的语法。
- en: 'Angular apps can be created in two different ways:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 应用程序可以通过两种不同的方式创建：
- en: An NgModule project
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NgModule 项目
- en: A standalone project
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立项目
- en: As of Angular 17, the default way is to bootstrap your app as a standalone project.
    This approach has many benefits, as further explained in *The Angular Router*
    section below. There is a lot of new terminology to learn, but modules as a concept
    aren’t going away. It’s just that they’re no longer required.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Angular 17，默认的方式是将您的应用程序作为独立项目启动。这种方法有很多好处，如以下 *Angular 路由* 部分进一步解释。有许多新的术语需要学习，但模块作为一个概念并不会消失。只是它们不再需要了。
- en: Whether your app starts with `bootstrapApplication` or `bootstrapModule`, at
    the root level of your application, Angular components, services, directives,
    pipes, and user controls are provided to the `bootstrapApplication` function or
    organized under modules. The root level configuration renders your first component,
    injects any services, and prepares any dependencies it may require. In a standalone
    app, you can lazily load individual components.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您的应用程序是从 `bootstrapApplication` 还是 `bootstrapModule` 开始，在应用程序的根级别，Angular
    组件、服务、指令、管道和用户控件都提供给 `bootstrapApplication` 函数或组织在模块下。根级别的配置渲染您的第一个组件，注入任何服务，并准备它可能需要的任何依赖项。在独立应用程序中，您可以懒加载单个组件。
- en: You may also introduce **feature modules** to lazy load groups of services and
    components. All these features help the initial app load up very quickly, improving
    First Contentful Paint times because the framework doesn’t have to download and
    load all web application components in the browser simultaneously. For instance,
    sending code for the admin dashboard to a user without admin privileges is useless.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以引入 **功能模块** 来懒加载服务组和组件。所有这些功能都有助于初始应用程序快速加载，提高首次内容绘制时间，因为框架不需要在浏览器中同时下载和加载所有网络应用程序组件。例如，向没有管理员权限的用户发送管理仪表板的代码是无用的。
- en: Being able to create standalone components allows us to ditch contrived modules.
    Previously, you were forced to place shared components in a shared module, leading
    to inefficiencies in reducing app size because developers wouldn’t necessarily
    want to create a module per shared component. For example, the LocalCast Weather
    app is a simple app that doesn’t benefit from the concept of a module, but the
    LemonMart app naturally reflects a modular architecture by implementing separate
    business functions in different modules. More on this later in the chapter in
    the *Modular architecture* section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 能够创建独立组件使我们能够放弃人为的模块。以前，您被迫将共享组件放在共享模块中，这导致在减少应用程序大小方面效率低下，因为开发者不一定想为每个共享组件创建一个模块。例如，LocalCast
    Weather 应用程序是一个简单的应用程序，它不受益于模块的概念，但 LemonMart 应用程序通过在不同模块中实现不同的业务功能，自然地反映了模块化架构。关于这一点，本章的
    *模块化架构* 部分将进行更多介绍。
- en: Standalone components shouldn’t be confused with Angular elements, an implementation
    of the web standard, custom elements, also known as Web Components. Implementing
    components in this manner would require the Angular framework to be reduced to
    only a few KB in size, as opposed to the current framework of around 150 KB. If
    this is successful, you will be able to use an Angular component you develop in
    any web application. Exciting stuff but also a tall order. You can read more about
    Angular elements at [https://angular.dev/guide/elements](https://angular.dev/guide/elements).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 独立组件不应与 Angular 元素混淆，Angular 元素是网络标准的实现，自定义元素，也称为 Web Components。以这种方式实现组件将需要将
    Angular 框架的大小减少到只有几 KB，而当前框架的大小约为 150 KB。如果这成功了，您将能够在任何网络应用程序中使用您开发的 Angular 组件。这是一件令人兴奋的事情，但也是一个艰巨的任务。您可以在
    [https://angular.dev/guide/elements](https://angular.dev/guide/elements) 上了解更多关于
    Angular 元素的信息。
- en: Angular heavily uses the RxJS library, which introduces reactive development
    patterns to Angular instead of more traditional imperative development patterns.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Angular大量使用RxJS库，它将响应式开发模式引入Angular，而不是更传统的命令式开发模式。
- en: Reactive programming
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程
- en: Angular supports multiple styles of programming. The plurality of coding styles
    within Angular is one of the reasons it is approachable to programmers with varying
    backgrounds. Whether you come from an object-oriented programming background or
    are a staunch believer in functional programming, you can build viable apps using
    Angular. In *Chapter 2*, *Forms, Observables, Signals, and Subjects*, you’ll begin
    leveraging reactive programming concepts in building the LocalCast Weather app.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Angular支持多种编程风格。Angular内部编程风格的多样性是它对具有不同背景的程序员友好的一部分原因。无论你是来自面向对象编程的背景，还是坚定地相信函数式编程，你都可以使用Angular构建可行的应用程序。在*第二章*，*表单、观察者、信号和主题*中，你将开始利用响应式编程概念构建LocalCast天气应用程序。
- en: As a programmer, you are most likely used to imperative programming. Imperative
    programming is when you, as the programmer, write sequential code describing everything
    that must be done in the order that you’ve defined them and the state of your
    application, depending on just the right variables to be set to function correctly.
    You write loops, conditionals, and call functions; you fire off events and expect
    them to be handled. Imperative and sequential logic is how you’re used to coding.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，你很可能习惯于命令式编程。命令式编程是指你作为程序员编写顺序代码，描述必须按你定义的顺序执行的所有操作以及应用程序的状态，这取决于正确设置的一组变量以正确运行。你编写循环、条件语句并调用函数；你触发事件并期望它们被处理。命令式和顺序逻辑是你习惯的编码方式。
- en: Reactive programming is a subset of functional programming. In functional programming,
    you can’t rely on variables you’ve set previously. Every function you write must
    stand on its own, receive its own set of inputs, and return a result without being
    influenced by the state of an outer function or class. Functional programming
    supports **Test Driven Development** (**TDD**) very well because every function
    is a unit that can be tested in isolation. As such, every function you write becomes
    composable. So you can mix, match, and combine any function you write with any
    other and construct a series of calls that yield the result you expect.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程是函数式编程的一个子集。在函数式编程中，你不能依赖于之前设置的变量。你写的每个函数都必须独立存在，接收它自己的输入集，并返回一个结果，而不受外部函数或类的状态的影响。函数式编程很好地支持**测试驱动开发**（**TDD**），因为每个函数都是一个可以独立测试的单元。因此，你写的每个函数都变得可组合。所以你可以混合、匹配和组合你写的任何函数，构建一系列调用，以产生你预期的结果。
- en: Reactive programming adds a twist to functional programming. You no longer deal
    with pure logic but an asynchronous data stream that you transform and mold into
    any shape you need with a composable set of functions. So when you subscribe to
    an event in a reactive stream, you’re shifting your coding paradigm from reactive
    programming to imperative programming.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程给函数式编程增添了一个转折。你不再处理纯逻辑，而是一个异步数据流，你可以使用一组可组合的函数将其塑造成你需要的任何形状。所以当你订阅响应式流中的事件时，你正在将你的编码范式从响应式编程转变为命令式编程。
- en: Later in the book, when implementing the LocalCast Weather app, you’ll leverage
    `subscribe` in action in the `CurrentWeatherComponent` and `CitySearchComponent`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书后面的部分，当实现LocalCast天气应用程序时，你将在`CurrentWeatherComponent`和`CitySearchComponent`中利用`subscribe`的实际操作。
- en: 'Consider the following example, aptly put by Mike Pearson in his presentation
    *Thinking Reactively: Most Difficult*, of providing instructions to get hot water
    from the faucet to help understand the differences between imperative and reactive
    programming:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下例子，由Mike Pearson在他的演示文稿*思考响应式：最难*中恰如其分地提出，提供从水龙头获取热水的指令，以帮助理解命令式编程和响应式编程之间的差异：
- en: '![A black screen with white circles  Description automatically generated](img/B20960_01_11.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![一个黑色屏幕上带有白色圆圈，描述自动生成](img/B20960_01_11.png)'
- en: 'Figure 1.11: Imperative vs Reactive methodology'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11：命令式与响应式方法
- en: As you can see, with imperative programming, you must define every step of the
    code execution. There are six steps in total. Every step depends on the previous
    step, which means you must consider the state of the environment to ensure a successful
    operation. In such an environment, it is easy to forget a step and very difficult
    to test the correctness of every individual step. In functional reactive programming,
    you work with asynchronous data streams resulting in a stateless workflow that
    is easy to compose with other actions. There are two steps in total, but *step
    2* doesn’t require any new logic. It simply disconnects the code in *step 1*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在使用命令式编程时，你必须定义代码执行的每一步。总共有六个步骤。每个步骤都依赖于前一个步骤，这意味着你必须考虑环境的状态以确保操作成功。在这样的环境中，很容易忘记一个步骤，并且很难测试每个步骤的正确性。在函数式响应式编程中，你与异步数据流一起工作，这导致了一个无状态的流程，它很容易与其他动作组合。总共有两个步骤，但**步骤2**不需要任何新的逻辑。它只是断开**步骤1**中的代码。
- en: RxJS is the library that allows you to implement your code in the reactive paradigm.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS是允许你在响应式范式下实现代码的库。
- en: Angular 16 introduced signals, in a developer preview, as a new paradigm to
    enable fine-grained reactivity within Angular. In *Chapter 2*, *Forms, Observables,
    Signals, and Subjects*, you will implement signals in your Angular application.
    Refer to the *Future of Angular* section later in the chapter for more information.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 16在开发者预览中引入了信号，作为一种新的范式，以在Angular中实现细粒度的响应性。在**第2章**，**表单、可观察者、信号和主题**中，你将在你的Angular应用程序中实现信号。请参考本章后面的**Angular的未来**部分以获取更多信息。
- en: RxJS
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RxJS
- en: '**RxJS** stands for **Reactive Extensions**, a modular library that enables
    reactive programming. It is an asynchronous programming paradigm that allows data
    stream manipulation through transformation, filtering, and control functions.
    You can think of reactive programming as an evolution of event-based programming.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**RxJS**代表**响应式扩展**，这是一个模块化库，它使得响应式编程成为可能。它是一种异步编程范式，允许通过转换、过滤和控制函数来操作数据流。你可以将响应式编程视为基于事件编程的进化。'
- en: Reactive data streams
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应式数据流
- en: 'In event-driven programming, you would define an event handler and attach it
    to an event source. In more concrete terms, if you had a **Save** button, which
    exposes an `onClick` event, you would implement a `confirmSave` function that,
    when triggered, would show a popup to ask the user ‘**Are you sure?’**. Look at
    the following diagram for a visualization of this process:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件驱动编程中，你会定义一个事件处理程序并将其附加到事件源。更具体地说，如果你有一个**保存**按钮，它暴露了一个`onClick`事件，你会实现一个`confirmSave`函数，当触发时，会显示一个弹出窗口询问用户“**你确定吗？**”。查看以下图表以了解此过程的可视化：
- en: '![](img/B20960_01_12.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B20960_01_12.png)'
- en: 'Figure 1.12: Event-driven implementation'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12：事件驱动实现
- en: In short, you would have an event firing once per user action. If the user clicks
    on the **Save** button many times, this pattern will gladly render as many popups
    as there are clicks, which doesn’t make much sense.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你会有一个事件在每次用户操作时触发一次。如果用户多次点击**保存**按钮，这个模式会乐意渲染与点击次数一样多的弹出窗口，这并没有太多意义。
- en: The **publish-subscribe** (**pub/sub**) pattern is a different type of event-driven
    programming. In this case, we can write multiple handlers to all simultaneously
    act on a given event’s result. Let’s say that your app just received some updated
    data. The publisher goes through its list of subscribers and passes the updated
    data to each.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**发布-订阅**（**pub/sub**）模式是另一种类型的事件驱动编程。在这种情况下，我们可以为给定事件的结果编写多个处理程序，以便它们可以同时作用于。假设你的应用程序刚刚接收了一些更新数据。发布者会遍历其订阅者列表，并将更新数据传递给每个订阅者。'
- en: 'Refer to the following diagram on how the updated data event triggers multiple
    functions:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下图表了解更新数据事件如何触发多个函数：
- en: An `updateCache` function updates your local cache with new data
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateCache`函数使用新数据更新你的本地缓存'
- en: A `fetchDetails` function retrieves further details about the data from the
    server
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetchDetails`函数从服务器检索有关数据的更多详细信息'
- en: A `showToastMessage` function informs the user that the app just received new
    data
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`showToastMessage`函数通知用户应用程序刚刚接收到了新数据'
- en: '![](img/B20960_01_13.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B20960_01_13.png)'
- en: 'Figure 1.13: Pub/sub pattern implementation'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13：发布/订阅模式实现
- en: All these events can happen asynchronously; however, the `fetchDetails` and
    `showToastMessage` functions will receive more data than they need, and it can
    get convoluted to try to compose these events in different ways to modify application
    behavior.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些事件都可以异步发生；然而，`fetchDetails` 和 `showToastMessage` 函数将接收到比它们所需更多的数据，尝试以不同的方式组合这些事件来修改应用程序的行为可能会变得复杂。
- en: In reactive programming, everything is treated as a stream. A stream will contain
    events that happen over time, which can contain some or no data. The following
    diagram visualizes a scenario where your app is listening for mouse clicks from
    the user. Uncontrolled streams of user clicks are meaningless. You exert some
    control over this stream by applying the `throttle` function, so you only get
    updates every 250 **milliseconds** (**ms**). If you subscribe to this new event
    stream, every 250 ms, you will receive a list of click events. You may try to
    extract some data from each click event, but in this case, you’re only interested
    in the number of click events that happened. Using the `map` function, we can
    shape the raw event data into the sum of all clicks.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式编程中，一切都是被视为流。一个流将包含随时间发生的事件，这些事件可能包含一些或没有数据。以下图表可视化了一个场景，其中你的应用程序正在监听用户的鼠标点击。未经控制的用户点击流是没有意义的。你通过应用
    `throttle` 函数来控制这个流，这样你每250毫秒只得到更新。如果你订阅这个新的事件流，每250毫秒，你将收到一个点击事件的列表。你可能试图从每个点击事件中提取一些数据，但在这个情况下，你只对发生的点击事件数量感兴趣。使用
    `map` 函数，我们可以将原始事件数据塑造成所有点击的总和。
- en: Further down the stream, we may only be interested in listening for events with
    two or more clicks, so we can use the `filter` function to act only on what is
    essentially a double-click event. Every time our filter event fires, it means
    that the user intended to double-click, and you can act on that information by
    popping up an alert.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据流进一步向下时，我们可能只对监听两个或更多点击的事件感兴趣，因此我们可以使用 `filter` 函数仅对本质上为双击事件进行操作。每次我们的过滤器事件触发时，都意味着用户有意进行双击，你可以通过弹出警告来利用这个信息。
- en: The true power of streams comes from the fact that you can choose to act on
    the event at any time as it passes through various control, transformation, and
    filter functions. You can choose to display click data on an HTML list using `@for`
    and Angular’s `async` pipe so that the user can monitor the types of click data
    being captured every 250 ms.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 流的真正力量来自于你可以选择在任何时候对事件进行操作，当它通过各种控制、转换和过滤器函数时。你可以选择使用 `@for` 和 Angular 的 `async`
    管道在 HTML 列表中显示点击数据，以便用户可以监控每250毫秒被捕获的点击数据类型。
- en: '![](img/B20960_01_14.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B20960_01_14.png)'
- en: 'Figure 1.14: A reactive data stream implementation'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14：响应式数据流实现
- en: Now let’s consider some more advanced Angular architectural patterns.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一些更高级的Angular架构模式。
- en: Modular architecture
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化架构
- en: 'As mentioned earlier in the *Component architecture section*, if you create
    an `NgModule` project, Angular components, services, and dependencies are organized
    into modules. Angular apps are bootstrapped via their root module, as shown in
    the diagram that follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文在 *组件架构部分* 中提到的，如果你创建一个 `NgModule` 项目，Angular 组件、服务和依赖项将组织到模块中。Angular 应用程序通过其根模块进行引导，如下面的图表所示：
- en: '![](img/B20960_01_15.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B20960_01_15.png)'
- en: 'Figure 1.15: Angular Bootstrap process showing major architectural elements'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.15：显示主要架构元素的Angular引导过程
- en: The root module can import other modules, declare components, and provide services.
    As your application grows, you must create sub-modules containing their components
    and services. Organizing your application in this manner allows you to implement
    lazy loading, allowing you to control which parts of your application get delivered
    to the browser and when. As you add more features to your application, you import
    modules from other libraries, like Angular Material or NgRx. You implement the
    router to enable rich navigational experiences between your components, allowing
    your routing configuration to orchestrate the creation of components.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 根模块可以导入其他模块，声明组件，并提供服务。随着你的应用程序增长，你必须创建包含其组件和服务的子模块。以这种方式组织你的应用程序允许你实现懒加载，这样你可以控制哪些应用程序的部分被发送到浏览器以及何时发送。当你向应用程序添加更多功能时，你会从其他库（如Angular
    Material或NgRx）导入模块。你实现路由器以在组件之间启用丰富的导航体验，允许你的路由配置编排组件的创建。
- en: '*Chapter 4*, *Creating a Router-First Line-of-Business App*, introduces router-first
    architecture, where I encourage you to start developing your application by creating
    all your routes ahead of time.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*第 4 章*，*创建一个 Router-First 业务应用*，介绍了 router-first 架构，我鼓励你通过提前创建所有路由来开始开发你的应用程序。'
- en: In Angular, services are provided as singletons to a module by default. You’ll
    quickly get used to this behavior. However, you must remember that if you provide
    the same service across multiple modules, each module has its own instance of
    the provided service. In the case of an authentication service, where we wish
    to have only one instance across our entire application, you must be careful to
    provide that instance of the authentication service only at the root module level.
    Any service, component, or module provided at the root level of your application
    becomes available in the feature module.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，服务默认以单例形式提供给模块。你会很快习惯这种行为。然而，你必须记住，如果你在多个模块中提供相同的服务，每个模块都有其提供的服务的独立实例。在认证服务的情况下，我们希望在整个应用程序中只有一个实例，你必须小心只在该根模块级别提供认证服务的实例。任何在应用程序根级别提供的服务、组件或模块都将在功能模块中可用。
- en: Standalone architecture
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立架构
- en: If you create a standalone project, your dependencies will be provided at the
    root level `bootstrapApplication` function. First-party and third-party libraries
    are updated to expose provider functions instead of modules. These provider functions
    are inherently tree-shakable, meaning the framework can remove them from the final
    package if unused. The provider functions can be customized using “with” functions,
    where a function named `withFeature()` can enable a certain feature.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建一个独立项目，你的依赖项将在根级别的 `bootstrapApplication` 函数中提供。第一方和第三方库被更新为暴露提供者函数而不是模块。这些提供者函数本质上是可摇树的，这意味着框架可以在最终包中删除未使用的它们。提供者函数可以使用“with”函数进行自定义，其中名为
    `withFeature()` 的函数可以启用某个特定功能。
- en: In standalone projects and while using standalone components in general, we
    must explicitly import the features they use that are not included in the providers.
    This means pipes, directives (including fundamental directives like `*ngIf` --
    unless you’re using `@if,` of course), and child components must be provided.
    This can feel more verbose and restrictive than an NgModule project, but the long-term
    benefits outweigh the short-term pain. The better information we can provide to
    the framework about our projects, the better the framework can optimize our code
    and improve performance.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在独立项目和通常使用独立组件的情况下，我们必须明确导入它们使用的、不包括在提供者中的功能。这意味着管道、指令（包括像 `*ngIf` 这样的基本指令——当然，除非你使用
    `@if`），以及子组件必须被提供。这可能会比 NgModule 项目更冗长和限制性，但长期的好处超过了短期的不便。我们向框架提供关于我们项目的更多信息，框架就能更好地优化我们的代码并提高性能。
- en: 'You can migrate existing NgModule projects to a standalone project using the
    following command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令将现有的 NgModule 项目迁移到独立项目：
- en: '[PRE0]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Beware - this is not a foolproof or entirely automated process. Read about it
    more at [https://angular.dev/reference/migrations/standalone](https://angular.dev/roadmap).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 警惕——这并不是一个万无一失或完全自动化的过程。更多关于此的信息请参阅 [https://angular.dev/reference/migrations/standalone](https://angular.dev/roadmap)。
- en: The router is the next most powerful technology you must master in Angular.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器是你在 Angular 中必须掌握的下一个最强大的技术。
- en: Angular Router
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 路由器
- en: The Angular Router, shipped in the `@angular/router` package, is a central and
    critical part of building SPAs that act and behave like regular websites that
    are easy to navigate, using browser controls or the zoom or micro zoom controls.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 路由器，包含在 `@angular/router` 包中，是构建类似常规网站且易于导航的 SPAs 的核心和关键部分，它使用浏览器控件或缩放或微缩控件进行操作。
- en: The Angular Router has advanced features such as lazy loading, router outlets,
    auxiliary routes, smart active link tracking, and the ability to be expressed
    as an `href`, which enables a highly flexible Router-first app architecture leveraging
    stateless data-driven components, using RxJS `BehaviorSubject` or a `signal`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 路由器具有高级功能，如懒加载、路由出口、辅助路由、智能活动链接跟踪，以及能够以 `href` 的形式表达，这使能够利用无状态数据驱动组件的灵活的
    Router-first 应用架构，使用 RxJS `BehaviorSubject` 或一个 `signal`。
- en: A class (a component or a service in Angular) is stateless if it doesn’t rely
    on instance variables in executing any of its behavior (via functions or property
    getters/setters). A class is data-driven when it’s used to manage access to data.
    A stateless data-driven component can hold references to data objects and allow
    access to them (including mutations via functions) but would not store any bookkeeping
    or state information in a variable.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类（在Angular中是一个组件或服务）在执行其任何行为（通过函数或属性获取器/设置器）时不依赖于实例变量，则该类是无状态的。当类用于管理数据访问时，它是数据驱动的。一个无状态的数据驱动组件可以持有数据对象的引用并允许访问它们（包括通过函数进行的突变），但不会在变量中存储任何账簿或状态信息。
- en: 'Large teams can work against a single code base, with each team responsible
    for a module’s development, without stepping on each other’s toes while enabling
    easy continuous integration. With its billions of lines of code, Google works
    against a single code base for a very good reason: integration after the fact
    is very expensive.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 大型团队可以在单个代码库上协同工作，每个团队负责一个模块的开发，同时避免相互干扰，并实现轻松的持续集成。谷歌拥有数亿行代码，之所以选择在单个代码库上工作，有一个非常好的原因：事后的集成成本非常高。
- en: Small teams can remix their UI layouts on the fly to quickly respond to changes
    without having to rearchitect their code. It is easy to underestimate the time
    wasted due to late-game changes in layout or navigation. Such changes are easier
    for larger teams to absorb but costly for small teams.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 小型团队可以即时混搭他们的UI布局以快速响应变化，而无需重新架构他们的代码。很容易低估由于布局或导航的后期变化而浪费的时间。对于大型团队来说，这些变化更容易吸收，但对于小型团队来说则成本高昂。
- en: Consider the following diagram; first off, depending on the bootstrap configuration,
    the app will either be a standalone or `NgModule` project. Regardless, you’ll
    define a `rootRouter` at the root of your application; components `a`, `master`,
    and `detail`; services; pipes; directives; and other modules will be provided.
    All these components will be parsed and eagerly loaded by the browser when a user
    first navigates to your application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图示；首先，根据引导配置，应用程序将要么是一个独立的，要么是`NgModule`项目。无论如何，你将在应用程序的根目录中定义一个`rootRouter`；组件`a`、`master`和`detail`；服务；管道；指令；以及其他模块将被提供。当用户首次导航到你的应用程序时，所有这些组件都将被浏览器解析和预加载。
- en: '![A diagram of a system  Description automatically generated](img/B20960_01_16.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![系统图  自动生成的描述](img/B20960_01_16.png)'
- en: 'Figure 1.16: Angular architecture'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.16：Angular架构
- en: If you were to implement a lazily loaded route, `/b`, you would need to create
    a feature module named `b`, which would have its `childRouter`; components `/b/a`
    and `/b/b`; services; pipes; directives; and other modules provided for it. During
    transpilation, Angular will package these components into a separate file or bundle,
    and this bundle will only be downloaded, parsed, and loaded if the user ever navigates
    to a path under `/b`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算实现一个懒加载的路由`/b`，你需要创建一个名为`b`的功能模块，它将拥有其`childRouter`；组件`/b/a`和`/b/b`；服务；管道；指令；以及其他为它提供的模块。在转换过程中，Angular会将这些组件打包到一个单独的文件或包中，并且这个包只有在用户导航到`/b`下的路径时才会被下载、解析和加载。
- en: In a standalone project, you can lazy load other standalone components represented
    by the triangles. You can organize components in a route configuration file. The
    `/c/a` and `/c/b` components will have access to providers at the root level.
    You may provide an **environment injector** for a specific component in the route
    config file. Practically speaking, this is only useful if you want to provide
    a service only ever used by that component or one with a specific scope, e.g.,
    a state that’s only used by that component. In contrast to a `NgModule` app, you
    will have to declare the modules you’re using in each component granularly. However,
    unlike an `NgModule` app, root-level providers not used by any component are tree-shakable.
    The combination of these two properties results in a small app bundle, and given
    each module can be individually lazy loaded, the size of each bundle will be smaller
    as well, leading to better overall performance.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个独立项目中，你可以懒加载由三角形表示的其他独立组件。你可以在路由配置文件中组织组件。`/c/a` 和 `/c/b` 组件将能够访问根级别的提供者。你可以在路由配置文件中为特定组件提供一个
    **环境注入器**。实际上，这只有在你想只为该组件或具有特定范围（例如，仅由该组件使用的状态）提供服务时才有用。与 `NgModule` 应用程序相比，你必须在每个组件中细粒度地声明你正在使用的模块。然而，与
    `NgModule` 应用程序不同，任何未由组件使用的根级别提供者都是可摇的。这两个属性的组合导致应用程序包体积小，并且由于每个模块都可以单独懒加载，每个包的大小也会更小，从而带来更好的整体性能。
- en: Let’s investigate lazy loading in more detail.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地研究懒加载。
- en: Lazy loading
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒加载
- en: The dashed line connecting `/b/...` to `rootRouter` demonstrates how lazy loading
    works. Lazy loading allows developers to achieve a sub-second First Meaningful
    Paint quickly. By deferring the loading of additional modules, we can keep the
    bundle size delivered to the browser to a minimum. The size of a module negatively
    impacts download and loading speeds because the more a browser has to do, the
    longer it takes for a user to see the app’s first screen. By defining lazily loaded
    modules, each module is packaged as separate files, which can be downloaded and
    loaded individually and on demand.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 连接 `/b/...` 到 `rootRouter` 的虚线展示了懒加载的工作原理。懒加载允许开发者快速实现亚秒级的首次有意义的绘制。通过延迟加载额外的模块，我们可以将发送到浏览器的包大小保持在最小。模块的大小会负面影响下载和加载速度，因为浏览器需要做的工作越多，用户看到应用第一个屏幕的时间就越长。通过定义懒加载的模块，每个模块都作为单独的文件打包，可以单独下载和按需加载。
- en: The Angular Router provides smart active link tracking, which results in a superior
    developer and user experience, making it very easy to implement highlighting features
    to indicate to the user the current tab or portion of the currently active app.
    Auxiliary routes maximize components’ reuse and help easily pull off complicated
    state transitions. With auxiliary routes, you can render multiple master and detail
    views using only a single outer template. You can also control how the route is
    displayed to the user in the browser’s URL bar and compose routes using `routerLink`
    in the template and `Router.navigate` in the component class, driving complicated
    scenarios.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 路由器提供了智能的活跃链接跟踪，这导致了卓越的开发者和用户体验，使得实现高亮功能以指示用户当前标签或当前活动应用的某个部分变得非常容易。辅助路由最大化了组件的重用，并有助于轻松完成复杂的状态转换。使用辅助路由，你可以仅使用单个外部模板渲染多个主视图和详细视图。你还可以控制路由在浏览器
    URL 栏中的显示方式，并在模板中使用 `routerLink` 和在组件类中使用 `Router.navigate` 来组合路由，处理复杂场景。
- en: In *Chapter 4*, *Creating a Router-First Line-of-Business App*, I cover implementing
    router basics, and advanced recipes are covered in *Chapter 8*, *Recipes – Reusability,
    Forms, and Caching*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 4 章*，*创建以路由为第一线的业务应用*，我介绍了实现路由基础，高级食谱在第 *第 8 章*，*食谱 – 可重用性、表单和缓存* 中介绍。
- en: Beyond routing, state management is another crucial concept to master if you
    want to build sophisticated Angular applications.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 除了路由之外，如果你想要构建复杂的 Angular 应用程序，掌握状态管理是另一个至关重要的概念。
- en: State management
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态管理
- en: An `EcmaScript` class backs every component and service in Angular. When instantiated,
    a class becomes an object in memory. As you work with an object, if you store
    values in object properties, you’re introducing state to your Angular application.
    If unmanaged, the state becomes a significant liability to the success and maintainability
    of your application.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Angular 组件和服务都有一个 `EcmaScript` 类作为后盾。当实例化时，类在内存中成为对象。当你与对象一起工作时，如果你在对象属性中存储值，你就在你的
    Angular 应用程序中引入了状态。如果未管理，状态就会成为你应用程序成功和可维护性的重大负担。
- en: I’m a fan of stateless design both in the backend and frontend. From my perspective,
    state is evil, and you should pay careful attention to not introduce state into
    your code. Earlier, we discussed how services in Angular are singletons by default.
    This is a terrible opportunity to introduce state to your application. You must
    avoid storing information in your services. In *Chapter 4*, *Creating a Router-First
    Line-of-Business App*, I introduce you to `readonly` `BehaviorSubject`, which
    acts as a data anchor for your application. In this case, we store these anchors
    in services to share them across components to synchronize data. The data anchor
    is a reference to the data instead of a copy. The service doesn’t store any metadata
    or do any bookkeeping.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我既喜欢后端也喜欢前端的无状态设计。从我的角度来看，状态是邪恶的，你应该仔细注意不要将状态引入到你的代码中。早些时候，我们讨论了 Angular 中的服务默认是单例的。这是一个引入状态到应用程序的糟糕机会。你必须避免在服务中存储信息。在
    *第 4 章*，*创建以路由为第一线的业务应用程序* 中，我向你介绍了 `readonly` `BehaviorSubject`，它作为应用程序的数据锚点。在这种情况下，我们将这些锚点存储在服务中以在组件之间共享，以同步数据。数据锚点是数据的引用而不是副本。服务不存储任何元数据或进行任何账目管理。
- en: In Angular components, the class is a ViewModel acting as the glue code between
    your code and the template. Components are relatively short-lived compared to
    services, and it is okay to use object properties in this context.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 组件中，类是一个 ViewModel，充当你的代码和模板之间的粘合代码。与服务相比，组件的生存周期相对较短，在这种情况下使用对象属性是可以的。
- en: However, beyond design, there are specific use cases for introducing robust
    mechanisms to maintain complicated data models in the state of your application.
    **Progressive web applications** (**PWA**) and mobile applications are cases where
    connectivity is not guaranteed. In these cases, being able to save and resume
    the entire state of your application is a must to provide a great UX for your
    end user.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了设计之外，还有特定的用例需要引入强大的机制来维护应用程序状态中的复杂数据模型。**渐进式 Web 应用程序**（**PWA**）和移动应用程序就是其中之一，在这些情况下，连接性无法保证。在这些情况下，能够保存和恢复应用程序的整个状态是必须的，以提供出色的用户体验。
- en: The NgRx library for Angular leverages the Flux pattern to enable sophisticated
    state management for your applications. In *Chapter 2*, *Forms, Observables, Signals,
    and Subjects,* and *Chapter 9*, *Recipes – Master/Detail, Data Tables, and NgRx*,
    I provide alternative implementations for various features using NgRx to demonstrate
    the differences in implementation between more lightweight methods.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的 NgRx 库利用 Flux 模式为你的应用程序提供复杂的状态管理。在 *第 2 章*，*表单、可观察对象、信号和主题* 和 *第 9
    章*，*食谱 – 主/详细信息、数据表和 NgRx* 中，我提供了使用 NgRx 的各种功能的替代实现，以展示与更轻量级方法之间的实现差异。
- en: The Flux pattern
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flux 模式
- en: Flux is the application architecture created by Facebook to assist in building
    client-side web applications. The Flux pattern defines a series of components
    that manage a store that stores the state of your application, via dispatchers
    that trigger/handle actions and view functions that read values from the store.
    Using the Flux pattern, you keep the state of your application in a store where
    access to the store is only possible through well-defined and decoupled functions,
    resulting in architecture that scales well because, in isolation, decoupled functions
    are easy to reason with and write automated unit tests for.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 是 Facebook 创建的应用架构，旨在协助构建客户端 Web 应用程序。Flux 模式定义了一系列组件，这些组件通过触发/处理动作和从存储中读取值的视图函数来管理存储应用程序状态。使用
    Flux 模式，你将应用程序的状态保存在存储中，存储的访问只能通过定义良好且解耦的函数进行，从而实现良好的架构扩展性，因为解耦的函数在独立情况下易于推理和编写单元测试。
- en: 'Consider the diagram that follows to understand the flow of information between
    these components:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图表，以了解这些组件之间信息流的流向：
- en: '![](img/B20960_01_17.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B20960_01_17.png)'
- en: 'Figure 1.17: NgRx data flow'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.17：NgRx 数据流
- en: NgRx implements the Flux pattern in Angular using RxJS.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: NgRx 使用 RxJS 在 Angular 中实现了 Flux 模式。
- en: NgRx
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NgRx
- en: The NgRx library brings Redux-like (a popular React.js library) reactive state
    management to Angular based on RxJS. State management with NgRx allows developers
    to write atomic, self-contained, and composable pieces of code, creating actions,
    reducers, and selectors. This kind of reactive programming allows side effects
    in state changes to be isolated and feels right at home with the general coding
    patterns of React.js. NgRx creates an abstraction layer over already complex and
    sophisticated tooling like RxJS.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: NgRx 库将基于 RxJS 的类似 Redux（一个流行的 React.js 库）的响应式状态管理引入 Angular。使用 NgRx 进行状态管理允许开发者编写原子、自包含和可组合的代码片段，创建动作、减少器和选择器。这种响应式编程允许在状态变化中隔离副作用，并且与
    React.js 的一般编码模式感觉非常自然。NgRx 在已经复杂和高级的工具（如 RxJS）之上创建了一个抽象层。
- en: 'There are excellent reasons to use NgRx, such as if you deal with 3+ input
    streams in your application. In such a scenario, the overhead of dealing with
    so many events makes it worthwhile to introduce a new coding paradigm to your
    project. However, most applications only have two input streams: REST APIs and
    user input. NgRx may make sense for offline-first **Progressive Web Apps** (**PWAs**),
    where you may have to persist and restore complicated state information (or niche
    enterprise apps with similar needs).'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NgRx 有许多优秀的理由，例如如果你在应用程序中处理 3+ 个输入流。在这种情况下，处理这么多事件的额外开销使得引入新的编码范式到你的项目中变得值得。然而，大多数应用程序只有两个输入流：REST
    API 和用户输入。对于可能需要持久化和恢复复杂状态信息（或具有类似需求的利基企业应用程序）的离线优先 **渐进式 Web 应用程序**（**PWAs**），NgRx
    可能是有意义的。
- en: 'Here’s an architectural overview of NgRx:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 NgRx 的架构概述：
- en: '![](img/B20960_01_18.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B20960_01_18.png)'
- en: 'Figure 1.18: NgRx architectural overview'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.18：NgRx 架构概述
- en: Consider the very top of the diagram as an observable action stream, where actions
    can be dispatched and acted upon as denoted by the circles. Effects and components
    can dispatch an action. Reducers and effects can act upon these actions to either
    store values in the store or trigger an interaction with the server. Selectors
    are leveraged by components to read values from the store.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 将图的最顶部视为可观察的动作流，动作可以像圆圈所示那样被分发和执行。效果和组件可以分发动作。减少器和效果可以对这些动作进行操作，要么将值存储在存储中，要么触发与服务器的交互。组件利用选择器从存储中读取值。
- en: Given my positive attitude toward minimal tooling and a lack of definite necessity
    for NgRx beyond the niche audiences previously mentioned, I do not recommend NgRx
    as a default choice. `RxJS/BehaviorSubject` are powerful and capable enough to
    unlock sophisticated and scalable patterns to help you build great Angular applications,
    as is demonstrated in the chapters that lead up to *Chapter 9*, *Recipes – Master/Detail,
    Data Tables, and NgRx*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我对最小工具的态度积极，并且没有明确的必要性需要 NgRx 之外的利基受众，我不建议将 NgRx 作为默认选择。`RxJS/BehaviorSubject`
    强大且足够强大，可以解锁复杂和可扩展的模式，帮助你构建出色的 Angular 应用程序，正如在 *第 9 章*，*食谱 - 主/详细，数据表和 NgRx*
    章节中所展示的那样。
- en: You can read more about NgRx at [https://ngrx.io](https://ngrx.io).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://ngrx.io](https://ngrx.io) 上了解更多关于 NgRx 的信息。
- en: NgRx component store
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NgRx 组件存储
- en: The NgRx component store, with the package name `@ngrx/component-store`, is
    a library that aims to simplify state management by targeting local/component
    states. It is an alternative to a reactive push-based subject-in-a-service approach.
    For scenarios where the state of a component is only changed by the component
    itself or a small collection of components, you can improve the testability, complexity,
    and performance of your code by using this library.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: NgRx 组件存储，包名为 `@ngrx/component-store`，是一个旨在通过针对本地/组件状态来简化状态管理的库。它是一种替代基于服务的响应式推送主题的方法。对于组件状态仅由组件自身或一小组组件更改的场景，你可以通过使用这个库来提高你代码的可测试性、复杂性和性能。
- en: In contrast to global-state solutions like NgRx, the NgRx component store, with
    its limited scope, can automatically clear itself when its associated view is
    detached from the component tree. Unlike a singleton service, you can have multiple
    instances of a component store, enabling distinct states for different components.
    Additionally, the conceptual model for the component store is straightforward.
    One only needs to grasp the select, updater, and effect concepts, all operating
    within a confined scope. Hence, for those crafting a standalone Angular app or
    seeking component-specific storage, the NgRx component store provides a sustainable
    and easily testable approach.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: You can find out more about the NgRx component store at [https://ngrx.io/guide/component-store](https://ngrx.io/guide/component-store).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: React.js architecture
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In contrast to Angular, React.js implements the Flux pattern hollistically.
    Following is a router-centric view of a React application, where components/containers
    and providers are represented in a strict tree-like manner.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_01_19.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.19: React.js architectural overview'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: In the initial releases of React, one had to laboriously pass values up/down
    the inheritance tree of every component for even the most basic functionality
    to work. Later, `react-redux` was introduced, so each component can read/write
    values directly to the store without traversing the tree.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: This basic overview should give you a sense of the significant architectural
    differences between Angular and React. However, keep in mind that just like Angular,
    React’s community, patterns, and practices are continually evolving and getting
    better over time.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'If you dig simplicity, check out Vue. It. Is. Simple. In a good way: [https://vuejs.org](https://vuejs.org).'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about React at [https://reactjs.org](https://reactjs.org).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Future of Angular
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the biggest benefits of Angular is that you can count on major releases
    every 6 months. However, with a regular cadence comes the pressure to release
    meaningful and splashy updates with every major release. We can probably blame
    Google for creating this pressure. If you’re not constantly producing, you’re
    out. This has an unfortunate side effect of new features being released in preview
    or an unfinished state. While an argument can be made that releasing upcoming
    features in preview allows for feedback to be collected from the developer community,
    no guarantees are made that performance regressions will not be introduced.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: If your team is not consuming every bit of Angular news coming out regularly,
    you may miss these nuances and roll out code into production that negatively impacts
    your business, potentially impacting revenue. For example, some users have noticed
    performance regressions in Angular 16, and the Angular team knew about this and
    fixed it in Angular 17, but this posture puts businesses who’ve taken up the new
    version at risk.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: The ambitious Angular Elements feature best exemplifies another aspect of this.
    Circa Angular 9, a big deal was made when announcing web component support for
    Angular. The promise was that you could create universally reusable components
    using your favorite framework. The team highlighted the great challenge of shipping
    a pared-down version of Angular along with the component – reducing the framework
    size from 150 KB to only a few KB. Instead of focusing on finalizing this feature,
    and despite making great incremental process, the team has found the task too
    daunting. So the team has moved on to different ideas to tackle this problem.
    But even those new ideas are being rushed and rolled out in a preview state, e.g.,
    Angular signals adding to the pile of unfinished work in production software.
    In Angular 17, signals are partially out of preview and have the potential to
    transform how Angular apps are built in the future with the implementation of
    signal-based components. Signals do not easily leak memory compared to RxJS’s
    leaky subscription concept. Signals can also work with async/await calls, avoiding
    many unnatural uses of reactive coding with RxJS. The stable delivery of all these
    features is probably due in Angular 19.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Find out up-to-date information about upcoming and in-preview features at [https://angular.dev/roadmap](https://angular.dev/roadmap).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: A large Angular application suffers from crippling performance issues just like
    Angular.js did, except the goalposts around the definition of *large* have moved
    significantly. The major trouble here is that it’s impossible to resolve these
    performance issues, at least not without significant engineering investment that
    leaves you digging under the hood of the Angular rendering engine.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Further, in 2023, by leveraging ES2022 features, it is possible to build reactive
    and interactive web applications using pure JavaScript. Angular signals expose
    these ES2022 features to enable fine-grained reactivity by replacing Zone.js with
    native JavaScript. This means that only the parts of the DOM that need to get
    updated are updated, significantly reducing render times. This is a topic I further
    explore in *Chapter 3*, *Architecting an Enterprise App*. Combining these changes
    results in a more optimized change detection cycle, resulting in smoother FPS.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Every release of Angular seeks to improve **Time-to-Interactive** (**TTI**)
    for modern browsers. In the past, this meant improving bundle sizes, introducing
    lazy loading of modules, and now individual components. Angular now supports **Server-side
    Rendering** (**SSR**) with non-destructive hydration. This means that a server
    can compute the DOM of a view and transfer it to the client, and the client can
    update the DOM displayed to the user without completely replacing it.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Angular is also moving away from Jasmine to Jest. Jasmine has always been a
    great unit-testing framework. However, making it work in a web application context
    always requires a lot of configuration and additional tools like Karma to execute
    the tests and get coverage reports. Jest includes all these features. The support
    is currently experimental, and it’s unclear whether Vitest will be a better option
    than Jest. Angular is moving away from webpack to esbuild, which is about 40x
    faster than webpack. Once again, it is only available as a (developer) preview.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, some of the most exciting things happening in Angular are in
    preview features. The ground truth is that teams are heads down, working on delivering
    features for their projects and trying their best to keep up with all the latest
    changes. It’s tough enough to keep updating dependencies continually; big changes
    in the mental model of the framework, combined with performance issues, risk losing
    the confidence of developers and businesses alike. Trust is hard to build and
    easy to lose.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: The reality is the Angular team is doing great work, and the framework is making
    the necessary changes to evolve and meet ever-growing expectations. It bears repeating
    Google mandates that the 2,000+ Angular projects they have must all be on the
    same version of Angular. This means that every new update to Angular is well-tested,
    and there are no backward compatibility surprises.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Angular remains an exciting, agile, and capable framework. My motivation is
    to inform you of where the land mines are. I hope you are as excited as I am about
    the state of modern web development and the future possibilities it unlocks. Buckle
    up your seatbelt, Dorothy, ‘cause Kansas is going bye-bye.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In summary, web technologies have evolved to a point where it is possible to
    create rich, fast, and native web applications that can run well on the vast majority
    of desktop and mobile browsers deployed today. Angular has become a mature and
    stable platform, applying lessons learned from the past. It enables sophisticated
    development methodologies that enable developers to create maintainable, interactive,
    and fast applications using technologies like TypeScript, RxJS, and NgRx-enabled
    patterns from object-oriented programming, reactive programming, the Flux pattern,
    and standalone components, along with the NgRx component store.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Angular is meant to be consumed in an evergreen manner, so it is a great idea
    always to keep your Angular up to date. Visit [https://AngularForEnterprise.com](https://AngularForEnterprise.com)
    for the latest updates and news.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Angular is engineered to be reactive through and through; therefore, you must
    adjust your programming style to fit this pattern. With signals, Angular even
    gains fine-grained reactivity. However, presentation layer reactivity is not the
    same as reactive programming. When signal-based components arrive circa Angular
    19, Angular will no longer require reactive programming to achieve a reactive
    presentation layer. In *Chapter 9*, *Recipes – Master/Detail, Data Tables, and
    NgRx*, I provide an example of a nearly observable and subscription-free application
    using signals and NgRx SignalStore to show what’s possible with Angular 17\. Until
    then, the official documentation should be your bible, found at [https://angular.dev](https://angular.dev).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will review the LocalCast Weather app as a standalone
    app; you will learn about capturing user input with reactive forms, keeping components
    decoupled, enabling data exchange between them using `BehaviorSubject` and how
    the NgRx component store and Angular signals differ from these concepts. In the
    following chapters, you will learn about advanced architectural patterns to create
    scalable applications and how your Angular frontend works within the context of
    a full-stack TypeScript application using minimal MEAN. The book wraps up by introducing
    you to DevOps and continuous integration techniques to publish your apps.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software*, Erich Gamma,
    Richard Helm, Ralph Johnson, John Vlissides, 1994, Addison Wesley, ISBN 0-201-63361-2.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Human JavaScript*, Henrik Joreteg, 2013, [http://read.humanjavascript.com](http://read.humanjavascript.com).'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What’s new in TypeScript x MS Build 2017*, Anders Hejlsberg, 2017, [https://www.youtube.com/watch?v=0sMZJ02rs2c](https://www.youtube.com/watch?v=0sMZJ02rs2c).'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Pragmatic Programmer, 20th Anniversary Edition*, David Thomas and Andrew
    Hunt, 2019, Addison Wesley, ISBN 978-0135957059.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Thinking Reactively: Most Difficult*, Mike Pearson, 2019, [https://www.youtube.com/watch?v=-4cwkHNguXE](https://www.youtube.com/watch?v=-4cwkHNguXE).'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Data Composition with RxJS, Deborah Kurata*, 2019, [https://www.youtube.com/watch?v=Z76QlSpYcck](https://www.youtube.com/watch?v=Z76QlSpYcck).'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Flux Pattern In-Depth Overview*, Facebook, 2019, [https://facebook.github.io/flux/docs/in-depth-overview](https://facebook.github.io/flux/docs/in-depth-overview).'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Developer experience: What is it and why should you care?*, GitHub, 2023,
    [https://github.blog/2023-06-08-developer-experience-what-is-it-and-why-should-you-care](https://github.blog/2023-06-08-developer-experience-what-is-it-and-why-should-you-care).'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Standalone Components*, Google, 2023, [https://angular.dev/reference/migrations/standalone](https://angular.dev/reference/migrations/standalone).'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Built-in control flow*, Google, 2023, [https://angular.dev/guide/templates/control-flow](https://angular.dev/guide/templates/control-flow).'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions as best as possible to ensure you’ve understood
    the key concepts from this chapter without googling anything. Do you know if you
    got all the answers right? Visit [https://angularforenterprise.com/self-assessment](https://angularforenterprise.com/self-assessment)
    for more:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between a standalone and an NgModule project?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the concept behind Angular Evergreen?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using the double-click example for reactive streams, implement the following
    steps using RxJS: listen to click events from an HTML target with the `fromEvent`
    function. Determine whether the mouse was double-clicked within a 250 ms timeframe
    using the `throttleTime`, `asyncScheduler`, `buffer`, and `filter` operators.
    If a double-click is detected, display an alert in the browser. Hint: use [https://stackblitz.com](https://stackblitz.com)
    or implement your code and use [https://rxjs.dev/](https://rxjs.dev/) for help.'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is NgRx, and what role does it play in an Angular application?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a module, a component, and a service in Angular?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/AngularEnterpise3e](https://packt.link/AngularEnterpise3e)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1116411172100421421.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
