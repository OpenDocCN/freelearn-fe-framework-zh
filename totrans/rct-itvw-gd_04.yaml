- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Handling Routing and Internationalization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理路由和国际化
- en: Navigating the vast world of software development doesn’t come without its difficulties.
    Our trip frequently necessitates expertly navigating various screens and language
    settings to ensure an excellent user experience. This chapter delves into the
    ideas of routing and internationalization, as well as the virtual environment
    and horizon of any modern React application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发的广阔世界中导航并非没有困难。我们的旅程经常需要熟练地导航各种屏幕和语言设置，以确保提供卓越的用户体验。本章深入探讨了路由和国际化以及任何现代
    React 应用程序的虚拟环境和视野。
- en: This chapter will take us on an in-depth investigation of screen navigation
    and introduce us to React Router. It is the most important tool in web application
    navigation since it refreshes the browser URL as users go across your application
    without refreshing the page. We’ll go over the many types of routes, such as basic
    and nested routes, learn how to add routes to our application, and even dive into
    the world of accessing URL parameters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带我们深入探讨屏幕导航，并介绍 React Router。它是网络应用导航中最重要的工具，因为它在用户在不刷新页面的情况下穿越您的应用时刷新浏览器
    URL。我们将介绍许多类型的路由，如基本路由和嵌套路由，学习如何将路由添加到我们的应用中，甚至深入到访问 URL 参数的世界。
- en: But our adventure does not end there. As we migrate into the realm of internationalization
    and localization, we will advance beyond the functional difficulties and chart
    our way throughout the globe. These aspects of development demonstrate our dedication
    to diversity, ensuring that our application speaks the language of its users,
    no matter where they are from.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们的冒险并未结束。随着我们进入国际化与本地化的领域，我们将超越功能性的困难，并在全球范围内规划我们的路线。这些发展方面展示了我们对多样性的承诺，确保我们的应用能够使用用户所在地的语言进行交流。
- en: We’ll present a detailed approach for adding translations and formatted messages
    to our program, increasing its accessibility to a global audience. We’ll also
    learn how to utilize placeholders and give parameters to these messages, allowing
    for dynamic translations. Consider this chapter to be your roadmap to a more user-friendly
    and worldwide application. We will utilize this knowledge to guide us through
    the realm of software development, avoiding any stumbling blocks and delivering
    a flawless user experience. Prepare to go on this fascinating adventure in the
    next few sections.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细介绍如何将翻译和格式化消息添加到我们的程序中，从而提高其面向全球受众的可用性。我们还将学习如何使用占位符并向这些消息传递参数，以实现动态翻译。将本章视为您通往更用户友好和全球化的应用的路线图。我们将利用这些知识来引导我们穿越软件开发领域，避免任何障碍，并提供无瑕疵的用户体验。在接下来的几节中，准备开始这场迷人的冒险。
- en: 'In the upcoming sections, we will cover the following topics as we aim to understand
    how to handle routing and how internationalization works:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将涵盖以下主题，以了解如何处理路由以及国际化是如何工作的：
- en: Navigating screens and an introduction to React Router
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航屏幕和 React Router 简介
- en: Routes, types of routes, and links
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由、路由类型和链接
- en: Adding routes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加路由
- en: Accessing URL parameters
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 URL 参数
- en: Nesting routes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套路由
- en: Introducing internationalization and localization
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍国际化与本地化
- en: Adding translations and formatted messages
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加翻译和格式化消息
- en: Passing arguments and placeholders
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递参数和占位符
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Please ensure that you have the JavaScript build tool **Vite.js** set up and
    installed on your machine. You can find it here: [https://vitejs.dev/](https://vitejs.dev/).
    We will be using it for our upcoming React project.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保您已在您的机器上设置并安装了 JavaScript 构建工具 **Vite.js**。您可以在以下链接找到它：[https://vitejs.dev/](https://vitejs.dev/)。我们将使用它来完成我们的下一个
    React 项目。
- en: 'Also, familiarize yourself with the React Router library: [https://reactrouter.com/en/main](https://reactrouter.com/en/main).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，熟悉一下 React Router 库：[https://reactrouter.com/en/main](https://reactrouter.com/en/main)。
- en: We are now ready to begin. The next section will introduce us to React Router.
    Let’s go for it!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备开始。下一节将向我们介绍 React Router。让我们行动起来吧！
- en: Navigating screens and an introduction to React Router
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航屏幕和 React Router 简介
- en: Understanding navigation and the React Router library is critical for any coder.
    In this section, we will go through the fundamentals of traversing screens with
    React Router and why it is crucial. The aim of this section is to provide an overview
    of React Router along with simple descriptions of how navigation works via various
    web apps without becoming unduly technical. We are going to close the gap between
    what employers expect and your existing skill level in this part by offering useful
    recommendations on enhancing workflow efficiency while utilizing React Router.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 理解导航和 React Router 库对于任何程序员来说都是至关重要的。在本节中，我们将探讨使用 React Router 遍历屏幕的基本原理以及为什么它至关重要。本节的目标是概述
    React Router，并简单描述通过各种 Web 应用程序进行导航的方式，而不使内容过于技术化。我们将通过提供有用的建议来缩小雇主期望与你的现有技能水平之间的差距，这些建议有助于在利用
    React Router 的同时提高工作流程效率。
- en: Now, let’s explore why we should be using the React Router library in the first
    place and what it can help us with. It’s worth mentioning that Next.js already
    has the functionality for routing built in, but this is still knowledge worth
    learning. This is because routing is different in other React frameworks and the
    core principles of how it works are still valid and can be used anywhere.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探讨为什么我们应该首先使用 React Router 库，以及它能帮助我们什么。值得一提的是，Next.js 已经内置了路由功能，但这仍然是一项值得学习的知识。这是因为在不同
    React 框架中，路由的方式不同，其核心工作原理仍然有效，并且可以在任何地方使用。
- en: What is the purpose of the React Router library?
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React Router 库的目的是什么？
- en: Creating routing logic can prove time-consuming and difficult, which is where
    React Router comes in handy. Because of the library’s extensive functionality,
    it can greatly ease our routing challenges. React Router is an open source web
    application routing module that allows you to move between different pages and
    components. It provides an easy-to-use interface for implementing dynamic routing
    in your web project. It supports numerous URLs and gives you complete control
    over your application’s routing, resulting in a seamless and engaging user experience.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 创建路由逻辑可能会很耗时且困难，这正是 React Router 发挥作用的地方。由于库的广泛功能，它可以极大地减轻我们的路由挑战。React Router
    是一个开源的 Web 应用程序路由模块，允许你在不同的页面和组件之间进行导航。它提供了一个易于使用的界面，用于在 Web 项目中实现动态路由。它支持众多 URL，并让你完全控制你应用的路由，从而实现无缝且引人入胜的用户体验。
- en: Now that we understand the purpose of using this library, we are going to learn
    how navigation works in the next section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了使用这个库的目的，我们将在下一节学习导航是如何工作的。
- en: How does navigating between screens work in React Router?
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 React Router 中，屏幕之间的导航是如何工作的？
- en: Navigating between screens can seem daunting at first, but using React Router
    makes it considerably easier and more practical. With React Router, you can efficiently
    manage all of your routes within your app, making it a breeze to switch between
    different screens. Plus, it allows you to keep your UI in sync with the URL. So,
    even if you’re not an expert, React Router means you can easily add the functionality
    you need to get your app running smoothly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕之间导航一开始可能看起来很令人畏惧，但使用 React Router 可以使这个过程变得相当容易和实用。使用 React Router，你可以高效地管理你应用中的所有路由，使得在不同屏幕之间切换变得轻而易举。此外，它允许你保持你的
    UI 与 URL 保持同步。所以，即使你不是专家，React Router 也能让你轻松地添加所需的功能，使你的应用运行顺畅。
- en: Client-side routing is enabled by React Router, and this is basically how routing
    is initiated. Essentially, the computer’s browser requests a page from a website’s
    server, which gets and determines the CSS and JavaScript files, and renders the
    HTML supplied from the server itself on a website. When a user clicks a link on
    the website, the process is restarted for a brand-new page.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 启用了客户端路由，这基本上是路由启动的方式。本质上，计算机的浏览器从网站的服务器请求一个页面，服务器获取并确定 CSS 和 JavaScript
    文件，并在网站上渲染从服务器本身提供的 HTML。当用户点击网站上的链接时，这个过程会为全新的页面重新启动。
- en: 'Next.js already has a routing solution built in, so we will use another popular
    JavaScript build tool, Vite.js, to see the code in this chapter. Here is the link
    for the tool: [https://vitejs.dev/](https://vitejs.dev/).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 已经内置了路由解决方案，因此我们将使用另一个流行的 JavaScript 构建工具 Vite.js 来查看本章中的代码。以下是工具的链接：[https://vitejs.dev/](https://vitejs.dev/)。
- en: 'The first step is to construct a `BrowserRouter` component and configure the
    primary route. This enables client-side routing for our web application. Our `main.jsx`
    file serves as the starting point, as shown here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是构建一个`BrowserRouter`组件并配置主路由。这为我们的Web应用启用了客户端路由。我们的`main.jsx`文件作为起点，如下所示：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code defines our initial route. So, in this case, it would be our root
    route. The root route is known as the first page that loads and is displayed on
    a website – commonly known as our home page.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了我们的初始路由。在这种情况下，它将是我们的根路由。根路由是加载并显示在网站上的第一页，通常称为我们的主页。
- en: Before we jump into the next section, let’s get a quick look at `BrowserRouter`
    and some of the subtopics surrounding it. Firstly, `BrowserRouter` is a router
    solution that keeps your UI in sync with the URL by using the HTML5 History API.
    This API utilizes events such as `popstate`, `replacestate`, and `pushstate`.
    We can use `BrowserRouter` to store the current location in the address bar using
    clean URLs and history. We can also use it to track changes in the URL in the
    cases of iframes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一节之前，让我们快速了解一下`BrowserRouter`及其相关的子主题。首先，`BrowserRouter`是一个通过使用HTML5历史API来保持UI与URL同步的路由解决方案。这个API利用了诸如`popstate`、`replacestate`和`pushstate`等事件。我们可以使用`BrowserRouter`通过使用干净的URL和历史记录来存储地址栏中的当前位置。我们还可以用它来跟踪iframe中的URL变化。
- en: 'React Router has many features that you can find in its documentation. Here’s
    an overview of what’s on offer:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: React Router有许多功能，你可以在其文档中找到。以下是提供的概述：
- en: '| **Feature** | **Description** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | **描述** |'
- en: '| Routers | Although your apps will only utilize one router, several of them
    can be accessed, depending on the setting it is operating in. Some of the ones
    that are included are `createBrowserRouter`, `createMemoryRouter`, `createHashRouter`,
    and `createStaticRouter`. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 路由器 | 虽然你的应用可能只会使用一个路由器，但根据其运行设置，可以访问多个路由器。其中包含的有些是`createBrowserRouter`、`createMemoryRouter`、`createHashRouter`和`createStaticRouter`。
    |'
- en: '| Router components | The type of router component you will use for page routing
    in your app. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 路由器组件 | 你将在你的应用中用于页面路由的路由器组件类型。 |'
- en: '| Route | The methods that will be used for creating and managing routes. These
    can include actions, lazy loading, and loaders. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 路由 | 用于创建和管理路由的方法。这些可以包括操作、懒加载和加载器。 |'
- en: '| Components | With this feature, we can use custom-made components to manage
    our data. For example, we can use the `Form` component, which emulates the browser
    for client-side routing and data mutations, or the `Await` component for automatic
    error handling. There’s also the important `Link` component for navigating to
    other pages. These are a few of the ones available to us. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | 使用此功能，我们可以使用自定义组件来管理我们的数据。例如，我们可以使用`Form`组件，该组件模拟浏览器进行客户端路由和数据变更，或者使用`Await`组件进行自动错误处理。还有用于导航到其他页面的重要`Link`组件。这些都是我们可用的组件之一。
    |'
- en: '| Hooks | These custom Hooks work just like any React Hook and give us new
    functionality. `useNavigation`, `useSearchParams`, `useOutlet`, and `useLocation`
    are all Hooks that have different purposes. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 钩子 | 这些自定义钩子就像任何React钩子一样工作，并为我们提供新的功能。`useNavigation`、`useSearchParams`、`useOutlet`和`useLocation`都是具有不同目的的钩子。
    |'
- en: '| Fetch utilities | These are used for managing the data we receive from APIs.
    We can get the data and perform redirects. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 获取工具 | 这些用于管理我们从API接收到的数据。我们可以获取数据并执行重定向。 |'
- en: '| Utilities | We can use utilities to perform different actions. For example,
    `matchPath` can be used to match a route path pattern and compare it to a URL
    path name, and the information about the match is returned. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 工具 | 我们可以使用工具执行不同的操作。例如，`matchPath`可以用来匹配路由路径模式并将其与URL路径名称进行比较，并返回匹配信息。 |'
- en: 'Table 4.1: React Router features'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1：React Router功能
- en: 'This covers most of the main features of React Router. To learn more, read
    the official documentation: [https://reactrouter.com/en/main](https://reactrouter.com/en/main).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了React Router的大部分主要功能。要了解更多信息，请阅读官方文档：[https://reactrouter.com/en/main](https://reactrouter.com/en/main)。
- en: In the next section, we will take this further and learn more about routing
    and links.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将进一步探讨并学习更多关于路由和链接的内容。
- en: Routes, types of routes, and links
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由、路由类型和链接
- en: Routes are the most critical components of a React Router app. They link URL
    segments to components, as well as perform data loading and data modifications.
    Sophisticated project layouts, as well as information dependencies, become straightforward
    thanks to route nesting and the process becomes easier because routes are objects
    that are provided to router construction operations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是 React Router 应用程序中最关键的组件。它们将 URL 段与组件链接，以及执行数据加载和数据修改。通过路由嵌套，复杂的项目布局和信息依赖变得简单，因为路由是提供给路由构建操作的对象，这使得整个过程变得更加容易。
- en: What types of routes can we use?
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们可以使用哪些类型的路由？
- en: 'React Router gives us access to various forms of routing. The following table
    explains this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 给我们提供了访问各种路由形式的能力。以下表格解释了这一点：
- en: '| **Route Type** | **Description** |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **路由类型** | **描述** |'
- en: '| `path` | The path pattern will be compared to the URL to see whether this
    route matches a URL, link href, or form action. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `path` | 路径模式将与 URL 进行比较，以查看此路由是否与 URL、链接 href 或表单操作匹配。|'
- en: '| `index` | This determines whether or not the route is an index route. Index
    routes, such as default child routes, render into their parent’s `Outlet` at their
    parent’s URL. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `index` | 这决定了路由是否是索引路由。索引路由，如默认子路由，将在其父级的 URL 中渲染到其父级的 `Outlet`。|'
- en: '| `children` | Nested routes allow you to render many components on a single
    page while maintaining route integrity. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `children` | 嵌套路由允许你在单个页面上渲染多个组件，同时保持路由完整性。|'
- en: '| `caseSensitive` | This specifies whether the route should match the case
    or not. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `caseSensitive` | 这指定了路由是否应该匹配大小写。|'
- en: '| `loader` | Before the route renders, the route loader is invoked and gives
    data for the element through `useLoaderData`. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `loader` | 在路由渲染之前，路由加载器被调用，并通过 `useLoaderData` 为元素提供数据。|'
- en: '| `action` | When a submission is submitted to the route from a form, fetcher,
    or submission, the route action is called. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `action` | 当一个表单、fetcher 或提交将提交发送到路由时，路由动作会被调用。|'
- en: 'Table 4.2: Types of routes'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.2：路由类型
- en: Now that we have learned about some different route types, it’s time to learn
    the code for creating a route and a link.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了不同类型的路由，是时候学习创建路由和链接的代码了。
- en: How do you create a route and a link?
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何创建路由和链接？
- en: We can create routes by using React `Element` and React `Component`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 React `Element` 和 React `Component` 来创建路由。
- en: 'The typical syntax for using `element` is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `element` 的典型语法如下：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you wanted to use `Component` instead, then the code would look like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用 `Component` 代替，那么代码将如下所示：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Links work slightly differently. Client-side routing enables our app to adjust
    the URL after a link click, rather than requesting another document from the server.
    Instead, the application can swiftly display a fresh UI and use `fetch` to execute
    data calls to update the content of the page with freshly obtained data. Since
    the web browser does not need to request a completely new page or revisit CSS
    and JavaScript content for the next page, this results in speedier loading times.
    It also allows for enhanced user interactions, such as scrolling.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 链接的工作方式略有不同。客户端路由允许我们的应用程序在点击链接后调整 URL，而不是从服务器请求另一个文档。相反，应用程序可以迅速显示新的 UI，并使用
    `fetch` 执行数据调用以更新页面内容。由于网络浏览器不需要请求全新的页面或重新访问下一页的 CSS 和 JavaScript 内容，这导致加载时间更快。它还允许增强用户交互，如滚动。
- en: 'The following example shows us how to use links for page navigation:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用链接进行页面导航：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code block shows us how to create a home page that has a link that navigates
    us to an about us page.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码块展示了如何创建一个包含链接的首页，该链接可以导航到关于我们页面。
- en: Now that we know about routes and links, let’s learn how to add routes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了路由和链接，让我们学习如何添加路由。
- en: Adding routes
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加路由
- en: Routes can be rendered throughout our application if we use the `<Routes>` component,
    which matches up with other child routes in our files. Routing searches through
    all of its child routes to find the best match, and if the location changes, then
    it renders that branch of the UI. To represent a nested UI, which also corresponds
    to nested URL pathways, `<Route>` components can also be nested. By rendering
    `<Outlet>`, parent routes render their child routes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `<Routes>` 组件，路由可以在我们的应用程序中渲染，该组件与我们的文件中的其他子路由相匹配。路由搜索其所有子路由以找到最佳匹配，如果位置发生变化，则渲染该
    UI 分支。为了表示嵌套 UI，这也对应于嵌套 URL 路径，`<Route>` 组件也可以嵌套。通过渲染 `<Outlet>`，父路由渲染其子路由。
- en: 'The following code example illustrates how to add routes to a file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了如何向文件中添加路由：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this file, there are four routes:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，有四个路由：
- en: '`"/"`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"/"`'
- en: '`"/``messages"`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"/messages"`'
- en: '`"/``actions"`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"/actions"`'
- en: '`"/``about"`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"/about"`'
- en: The routes for messages and actions are nested routes under the main route,
    which is `"/"`. The `"/about"` route is a top-level route because it is separate
    and not nested like the previous two. The component inside the property element
    will load when the page is on its defined route. Routes can also be declared with
    JSX and `createRoutesFromElements`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 消息和操作的路线是主路线`"/"`下的嵌套路线。`"/about"`路线是一个顶级路线，因为它独立且不像前两个那样嵌套。当页面位于其定义的路由时，属性元素内的组件将加载。路线也可以使用JSX和`createRoutesFromElements`声明。
- en: Those are the basics out of the way. Now, let’s move on to the next topic, which
    is accessing URL parameters. This is where we will learn how to navigate to a
    page that is determined by its ID. This gives us more customization options when
    we’re doing our `GET` requests, which is the next step after we have learned how
    to navigate to a page using basic routing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 基本知识已经介绍完毕。现在，让我们继续下一个主题，即访问URL参数。这将教会我们如何导航到由其ID确定的页面。这为我们进行`GET`请求提供了更多的定制选项，这是在我们学会使用基本路由导航到页面之后的下一步。
- en: Accessing URL parameters
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问URL参数
- en: 'We can use the `useParams` Hook in React, which provides a key/value object
    of the dynamic parameters from the current URL that matches the specified route.
    All of the parameters are inherited by child routes from their parent routes.
    A working example is shown here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用React中的`useParams`钩子，它提供了一个与指定路由匹配的当前URL动态参数的关键/值对象。所有参数都从父路由继承到子路由。一个工作示例如下：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, with this routing configuration, the application can render various components
    according to the URL’s structure. Firstly, the page route of `users`/`userId`
    renders the `ProfilePage` component and provides the component with the `userId`
    portion as `userId`. The route for `users`/`me` is the one that renders the component
    that’s supplied in the element attribute.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用这种路由配置，应用程序可以根据URL的结构渲染各种组件。首先，`users`/`userId`的页面路由渲染`ProfilePage`组件，并将`userId`部分作为`userId`提供给组件。`users`/`me`的路由是渲染元素属性中提供的组件的路由。
- en: As you can see, URL parameters are powerful and give us another level of customization
    for our routes. In the next section, we will take a look at nesting routes, which
    is the natural progression now that we have learned how to create basic routes.
    With nested routes, we will be able to have multiple components rendered on the
    same page.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，URL参数功能强大，为我们提供了对路由的另一个层次的定制。在下一节中，我们将探讨嵌套路由，这是我们现在已经学会了如何创建基本路由后的自然发展。有了嵌套路由，我们将在同一页面上渲染多个组件。
- en: Nesting routes
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套路由
- en: 'In React Router, nesting routes were influenced by Ember.js’s routing mechanism
    in 2014\. The Ember.js team discovered that parts of the URL usually determine
    the method to render a page layout and how the data is connected with the layouts
    that are rendered. One method of creating a page with nested elements can be seen
    in our example here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在2014年，React Router中的嵌套路由受到了Ember.js路由机制的影响。Ember.js团队发现，URL的某些部分通常决定了渲染页面布局的方法以及数据如何与渲染的布局连接。在我们的示例中可以看到创建具有嵌套元素的页面的一个方法：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code block is for a user-authenticated login flow. If the user is logged
    in, then the admin page loads. There is also a login and logout route. Now, let’s
    look at dynamic routing, which is another useful feature.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码块用于用户认证的登录流程。如果用户已登录，则加载管理页面。还有一个登录和登出路由。现在，让我们看看动态路由，这是另一个有用的功能。
- en: Dynamic routes
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态路由
- en: When developing apps with several pages or views that have a basic structure
    but differ in information or behavior, dynamic routing becomes convenient. Dynamic
    routing, as opposed to establishing a predetermined number of routes in your application,
    allows you to construct routes on the spot based on the present state of the app
    as a whole.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发具有多个页面或视图的应用程序时，这些页面或视图具有基本结构但信息或行为不同，动态路由变得方便。与在应用程序中建立预定的路由数量相反，动态路由允许您根据应用程序的整体当前状态现场构建路由。
- en: 'We can see what that looks like here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里看到它的样子：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `:id` property in the route structure indicates a dynamic value that can
    vary depending on the input provided by the user. React Router grabs the `id`
    parameter from the URL and provides it to the `Profile` component when the URL
    fits this pattern. Next, we’ll look at error pages since it’s a situation we need
    to be aware of when a user encounters a page that is broken.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 路由结构中的`:id`属性表示一个动态值，它可能根据用户提供的输入而变化。当 URL 符合此模式时，React Router 会从 URL 中获取 `id`
    参数并将其提供给 `Profile` 组件。接下来，我们将查看错误页面，因为当用户遇到损坏的页面时，这是我们需要了解的情况。
- en: Error pages
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误页面
- en: To address scenarios where users go to non-existent routes or face difficulties
    while traversing our application, we can create error pages or *not-found* pages
    in React Router. When anything goes wrong, this helps provide a better user experience
    by stopping users from encountering a blank page or an inconsistent layout.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决用户访问不存在路由或在使用我们的应用程序时遇到困难的情况，我们可以在 React Router 中创建错误页面或*找不到*页面。当出现问题时，这有助于提供更好的用户体验，防止用户遇到空白页面或不一致的布局。
- en: The following code example shows how to create error pages.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了如何创建错误页面。
- en: 'Firstly, we must create the necessary components:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须创建必要的组件：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code creates two components - one for `404` error pages and the other for
    general error pages.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了两个组件 - 一个用于`404`错误页面，另一个用于通用错误页面。
- en: 'Now, let’s set up the routes:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置路由：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code creates a component that contains all of the page routes for our app.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了一个包含我们应用程序所有页面路由的组件。
- en: With that, we’ve considered error pages and learned how to set up some routes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们已经考虑了错误页面并学习了如何设置一些路由。
- en: Next, we will cover internationalization and localization. Knowing how to tailor
    your application to different regions is important because we all live in different
    countries. So, let’s get right to it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍国际化和本地化。了解如何根据不同地区调整您的应用程序非常重要，因为我们所有人生活在不同国家。所以，让我们直接进入正题。
- en: Internationalization and localization
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际化和本地化
- en: Internationalization and localization are basic practices in software development
    that enable you to design and deploy systems that can be tailored to multiple
    languages and areas. Let’s learn the difference between them.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 国际化和本地化是软件开发中的基本实践，使您能够设计和部署可以针对多种语言和地区定制的系统。让我们学习它们之间的区别。
- en: What is internationalization?
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 国际化是什么？
- en: Internationalization is the process of creating and preparing your application
    so that it can potentially be used in several languages. This frequently entails
    extracting all of your application’s strings into distinct files that can potentially
    be translated into multiple languages. It also requires structuring your software
    to ensure that it can correctly manage and show these translations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 国际化是将您的应用程序创建和准备成可以在多种语言中使用的进程。这通常涉及将应用程序的所有字符串提取到可以翻译成多种语言的单独文件中。它还需要对您的软件进行结构化，以确保它可以正确管理和显示这些翻译。
- en: What is localization?
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地化是什么？
- en: This involves translating your locally optimized application into specific native
    languages. Translating an application’s text is only one aspect of localization.
    It might also include other regionally unique elements, such as text direction,
    number forms, and date and time formats, among other things.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这涉及到将您的本地优化应用程序翻译成特定的本地语言。翻译应用程序的文本只是本地化的一部分。它可能还包括其他区域特有的元素，例如文本方向、数字形式以及日期和时间格式等。
- en: React Router allows you to build localized routes. To manage language choice,
    you might, for instance, have several routes for various languages (such as `"/en/about`”
    and `"/fr/about"`) or you can utilize a context or state.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 允许您构建本地化路由。例如，为了管理语言选择，您可能为各种语言（如`"/en/about"`和`"/fr/about"`）设置多个路由，或者您可以使用上下文或状态。
- en: We have learned so much already and our knowledge has increased a lot. Next,
    we will move on to the penultimate section of this chapter, where we are going
    to learn all about adding translations and formatted messages in our React applications.
    We just learned about internationalization and localization, which is where we
    prepare our applications for different languages. Now, let’s learn how to implement
    different languages in the code we write.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学到了很多，我们的知识已经大大增加。接下来，我们将进入本章的倒数第二节，我们将学习如何在我们的React应用程序中添加翻译和格式化消息。我们刚刚学习了国际化本地化，这是我们为不同语言准备应用程序的地方。现在，让我们学习如何在编写的代码中实现不同的语言。
- en: Adding translations and formatted messages
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加翻译和格式化消息
- en: The process of translating text content in your application from one language
    into another and doing it in a style that follows regional customs and standards
    is referred to as translations and formatted messages. We can make use of a library
    such as **FormatJS** to add translations and formatted messages to a React application.
    React Router does not allow translations or localization by default; however,
    it can easily be used in tandem with FormatJS (or a comparable package) to build
    an internationalized routing system.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序中的文本内容从一种语言翻译成另一种语言，并按照区域习俗和标准进行翻译的过程被称为翻译和格式化消息。我们可以利用像**FormatJS**这样的库将翻译和格式化消息添加到React应用程序中。React
    Router默认不允许翻译或本地化；然而，它可以很容易地与FormatJS（或类似包）一起使用来构建国际化路由系统。
- en: 'Let’s look at a code example of what this could look like if we were to use
    the library:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个使用该库的代码示例，看看它可能是什么样子：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, the application has been set up for English and French translations.
    The default language is hardcoded to be French; however, in a real-world application,
    it can be generated dynamically, depending on what language user settings someone
    has set up in their browser. The `en` and `fr` language codes are mapped to the
    translation files that are imported by the `messages` object.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，应用程序已经设置了英语和法语翻译。默认语言是硬编码为法语；然而，在实际应用中，它可以根据用户在浏览器中设置的某种语言设置动态生成。`en`和`fr`语言代码映射到由`messages`对象导入的翻译文件。
- en: Translations and formatted messages – what are they exactly? We are about to
    find out. So, keep reading.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译和格式化消息——它们究竟是什么？我们马上就会找到答案。所以，继续阅读。
- en: What are translations?
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 翻译是什么？
- en: This often refers to translating text from one language into another within
    your program. In software, we often keep many language files that contain the
    translated texts for each supported language (commonly in JSON or a similar format).
    This enables the app to show the appropriate language, depending on the user’s
    preferences or locale, dynamically.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常指的是在程序中将文本从一种语言翻译成另一种语言。在软件中，我们通常保留许多包含每种支持语言翻译文本的语言文件（通常在JSON或类似格式中）。这使得应用程序能够根据用户的偏好或区域设置动态显示适当的语言。
- en: What are formatted messages?
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化消息是什么？
- en: Many applications require dynamic material to be shown within translated strings
    in addition to straightforward translations. Formatted communications have a role
    in this. With formatted messages, you can manage pluralization rules, add variables
    to your translated strings, format dates and numbers using regional standards,
    and much more.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序需要在翻译的字符串中显示动态内容，而不仅仅是直接的翻译。格式化通信在这方面发挥作用。使用格式化消息，您可以管理复数规则，向您的翻译字符串添加变量，使用区域标准格式化日期和数字，等等。
- en: We can develop apps that are readily adaptable to various languages and locations
    by combining translations with formatted messages, thus improving accessibility
    and user experience.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合翻译和格式化消息，我们可以开发出易于适应各种语言和位置的应用程序，从而提高可访问性和用户体验。
- en: Our progress has been fantastic – there’s just one more section to go and we
    will have completed this chapter. The last section will be about passing arguments
    and placeholders. So far, we’ve learned how to add data to one page; however,
    in real-world applications, we have multiple routes within our single-page applications.
    So, in the next section, we will learn how to pass arguments and placeholders
    so that we can have dynamic routing in our applications.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的进展非常出色——只剩下最后一部分，我们就会完成这一章。最后一部分将介绍传递参数和占位符。到目前为止，我们已经学会了如何向单页应用添加数据；然而，在实际应用中，我们在单页应用中有多条路由。因此，在下一节中，我们将学习如何传递参数和占位符，以便在我们的应用程序中实现动态路由。
- en: Passing arguments and placeholders
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递参数和占位符
- en: React and JavaScript in general, as well as React Router specifically, support
    passing placeholders and arguments. However, for dynamic routing and data transmission
    between routes, these work well when combined with React Router.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: React和JavaScript（一般而言），以及React Router（具体而言），支持传递占位符和参数。然而，对于动态路由和数据在路由之间的传输，当与React
    Router结合使用时，这些方法工作得很好。
- en: How do we pass arguments?
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们如何传递参数？
- en: With the use of several techniques, such as URL parameters, query parameters,
    or the state object of the history prop, we can send data to components that are
    displayed by React Router. Usually, this is done to convey precise data from one
    route to another.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用多种技术，例如URL参数、查询参数或history prop的状态对象，我们可以将数据发送到由React Router显示的组件。通常，这是为了将精确的数据从一个路由传递到另一个路由。
- en: 'This example shows us the process of passing arguments when we are using the
    state object of the history prop:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了当我们使用history prop的状态对象时传递参数的过程：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The receiving component reveals how we can access the data that we passed in:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接收组件揭示了我们可以如何访问我们传递的数据：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Lastly, we shall learn how to use placeholders (URL parameters).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将学习如何使用占位符（URL参数）。
- en: How do we use placeholders?
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们如何使用占位符？
- en: URL parameters, which are parts of the URL that can change depending on the
    content you would like to display but still render the same core component, are
    supported by React Router. These are regularly used to develop dynamic routes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: URL参数，这些参数是URL的一部分，可以根据您希望显示的内容而变化，但仍然渲染相同的核心组件，由React Router支持。这些通常用于开发动态路由。
- en: 'Here is an example of how to create a route and utilize a URL parameter in
    a component:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个如何在组件中创建路由并利用URL参数的示例：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this example, the `i``d` placeholder can depend on any value. When you go
    to `"/post/123"`, the `MyComponent` component renders, and `useParams()` returns
    an object with `{ id: "123"}` in it.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个示例中，`id`占位符可以依赖于任何值。当你访问`"/post/123"`时，`MyComponent`组件会渲染，并且`useParams()`返回一个包含`{
    id: "123"}`的对象。'
- en: Building dynamic and responsive apps using React Router requires both arguments
    and placeholders.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React Router构建动态和响应式应用需要参数和占位符。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: As we come to the end of this chapter, it’s evident that the journey through
    the environment of routing and internationalization in React apps has been both
    difficult and gratifying. We examined, probed, and unraveled the complexity of
    several critical themes, each of which contributed to the development of comprehensive,
    interactive, and internationally accessible apps.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本章的结束，很明显，在React应用的路由和国际化环境中进行探索之旅既困难又令人满意。我们考察、探究并揭开了几个关键主题的复杂性，每个主题都对开发全面、交互式和国际化的应用做出了贡献。
- en: We started by learning about React Router, our trusty navigator for the displays
    in our applications. We looked into routes, learned about their many types, and
    learned how to use them effectively in our applications. Our investigation of
    obtaining URL parameters and layering routes has broadened our expertise, allowing
    us to design sophisticated and complex pathways inside our apps.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从学习React Router开始，它是我们应用显示的可靠导航器。我们研究了路由，了解了它们的许多类型，并学习了如何在我们的应用中有效地使用它们。我们对获取URL参数和分层路由的研究扩大了我们的专业知识，使我们能够在应用内部设计复杂和精细的路径。
- en: Then, we shifted our focus to internationalization and localization, widening
    our horizons to ensure people all around the world can interact with our application.
    We recognized the significance of breaking down language barriers and the enormous
    impact this can have on user experience. Learning how to add translations and
    formatted messages has given us the ability to connect with users in their native
    language, allowing our application to become a worldwide entity. We also uncovered
    the power of creating dynamic and responsive translations by learning how to use
    placeholders and pass arguments to messages.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将焦点转向国际化本地化，拓宽视野以确保世界各地的人们都能与我们的应用互动。我们认识到打破语言障碍的重要性及其对用户体验的巨大影响。学习如何添加翻译和格式化消息使我们能够用用户的母语与他们建立联系，使我们的应用成为全球性的实体。我们还通过学习如何使用占位符和将参数传递给消息来发现创建动态和响应式翻译的强大功能。
- en: These abilities help us become efficient developers who are capable of creating
    programs that are not only useful but also ubiquitous. This path has given us
    the tools we need to design and build online apps that are not only responsive
    and resilient but also global and inclusive. As we finish this chapter, think
    about what you’ve learned, but keep in mind that this is just one stop on your
    larger trip. Continue to explore, learn, and, most importantly, continue your
    growth and follow the path that resonates with you most.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些能力帮助我们成为高效的开发者，能够创建不仅有用而且无处不在的程序。这条道路为我们提供了设计和构建不仅响应性强、弹性好，而且全球化和包容性的在线应用程序所需的工具。随着我们完成这一章，思考一下你学到了什么，但请记住，这仅仅是你的更大旅程中的一个站点。继续探索、学习和，最重要的是，继续你的成长，追随与你共鸣最多的道路。
- en: In the next chapter, we will learn about more advanced ReactJS concepts, such
    as error borders, portals, higher-order components, concurrent rendering, and
    forwarding refs. So, let’s get ready for another adventure as we increase our
    knowledge.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多高级的ReactJS概念，例如错误边框、端口、高阶组件、并发渲染和转发引用。因此，让我们为新的冒险做好准备，随着我们知识的增长。
