- en: Chapter 5.  Supporting Server Data Persistence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。支持服务器数据持久性
- en: It's now time to talk to the server! There is no fun in creating a workout,
    adding exercises, and saving it to later realize that all our efforts are lost
    because the data did not persist anywhere. We need to fix this.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候和服务器交流了！创建锻炼，添加锻炼，并保存它，然后发现所有努力都白费，因为数据没有持久化，这样就没有乐趣了。我们需要解决这个问题。
- en: Seldom are applications self-contained. Any consumer app, irrespective of its
    size, has parts that interact with elements outside its boundary. With web-based
    applications, the interaction is mostly with a server. Apps interact with the
    server to authenticate, authorize, store/retrieve data, validate data, and perform
    other such operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有应用程序是自包含的。无论大小如何，任何消费者应用程序都有与其边界之外的元素交互的部分。对于基于Web的应用程序，交互主要是与服务器进行的。应用程序与服务器交互以进行身份验证、授权、存储/检索数据、验证数据以及执行其他此类操作。
- en: This chapter explores the constructs that Angular provides for client-server
    interaction. In the process, we add a persistence layer to *Personal Trainer*
    that loads and saves data to a backend server.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了Angular为客户端-服务器交互提供的构造。在这个过程中，我们为“个人健身教练”添加了一个持久层，用于将数据加载和保存到后端服务器。
- en: 'The topics we cover in this chapter include the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括以下内容：
- en: '**Provisioning a backend to persist workout data**: We set up a MongoLab account
    and use its Data API to access and store workout data.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置后端以持久化锻炼数据**：我们设置了一个MongoLab账户，并使用其数据API来访问和存储锻炼数据。'
- en: '**Understanding the Angular HTTP client library**: The HTTP client library
    allows us to interact with a server over HTTP. You''ll learn how to make all types
    of `GET`, `POST`, `PUT`, and `DELETE` requests with the HTTP client library''s
    `XMLHttpRequest` class.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解Angular HTTP客户端库**：HTTP客户端库允许我们通过HTTP与服务器进行交互。您将学习如何使用HTTP客户端库的`XMLHttpRequest`类进行各种类型的`GET`、`POST`、`PUT`和`DELETE`请求。'
- en: '**Implementing the loading and saving of workout data**: We use the HTTP module
    to load and store workout data in the MongoLab databases.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现锻炼数据的加载和保存**：我们使用HTTP模块在MongoLab数据库中加载和存储锻炼数据。'
- en: '**Two ways in which we can use the HTTP module''s XMLHttpRequest**: Either
    Observables or with promises.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们可以使用HTTP模块的XMLHttpRequest的两种方式**：使用Observables或promises。'
- en: '**Using RxJS and Observables**: To subscribe to and query streams of data.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用RxJS和Observables**：订阅和查询数据流。'
- en: '**Using promises**: In this chapter, we will see how to use promises as part
    of HTTP invocation and response.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用promises**：在本章中，我们将看到如何在HTTP调用和响应中使用promises。'
- en: '**Working with cross-domain access**: As we are interacting with a MongoLab
    server in a different domain, you will learn about browser restrictions on cross-domain
    access. You will also learn how JSONP and CORS help us make cross-domain access
    easy and about Angular JSONP support.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理跨域访问**：由于我们与不同域中的MongoLab服务器进行交互，您将了解浏览器对跨域访问的限制。您还将了解JSONP和CORS如何帮助我们轻松实现跨域访问，以及关于Angular
    JSONP支持的内容。'
- en: Let's set the ball rolling.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Angular and server interactions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular和服务器交互
- en: Any client-server interaction typically boils down to sending HTTP requests
    to a server and receiving responses from a server. For heavy JavaScript apps,
    we depend on the AJAX request/response mechanism to communicate with the server.
    To support AJAX-based communication, Angular provides the Angular HTTP module.
    Before we delve into the HTTP module, we need to set up our server platform that
    stores the data and allows us to manage it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 任何客户端-服务器交互通常归结为向服务器发送HTTP请求并从服务器接收响应。对于重型JavaScript应用程序，我们依赖AJAX请求/响应机制与服务器进行通信。为了支持基于AJAX的通信，Angular提供了Angular
    HTTP模块。在我们深入研究HTTP模块之前，我们需要设置存储数据并允许我们管理数据的服务器平台。
- en: Setting up the persistence store
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置持久性存储
- en: For data persistence, we use a document database called MongoDB ([https://www.mongodb.org/](https://www.mongodb.org/)),
    hosted over MongoLab ([https://mongolab.com/](https://mongolab.com/)), as our
    data store. The reason we zeroed in on MongoLab is that it provides an interface
    to interact with the database directly. This saves us the effort of setting up
    server middleware to support MongoDB interaction.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了数据持久性，我们使用一个名为MongoDB的文档数据库（[https://www.mongodb.org/](https://www.mongodb.org/)），托管在MongoLab上（[https://mongolab.com/](https://mongolab.com/)），作为我们的数据存储。我们选择MongoLab的原因是它提供了一个直接与数据库交互的接口。这样可以省去我们设置服务器中间件来支持MongoDB交互的工作。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is never a good idea to expose the data store/database directly to the client.
    But in this case, since our primary aim is to learn about Angular and client-server
    interaction, we take this liberty and directly access the MongoDB instance hosted
    in MongoLab. There is also a new breed of apps that are built over **noBackend**
    solutions. In such a setup, frontend developers build apps without the knowledge
    of the exact backend involved. Server interaction is limited to making API calls
    to the backend. If you are interested in knowing more about these noBackend solutions,
    do check out [http://nobackend.org/](http://nobackend.org/).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将数据存储/数据库暴露给客户端从来都不是一个好主意。但在这种情况下，由于我们的主要目标是学习Angular和客户端-服务器交互，我们冒了这个风险并直接访问了托管在MongoLab中的MongoDB实例。还有一种新型应用程序是建立在**noBackend**解决方案之上的。在这样的设置中，前端开发人员构建应用程序而不知道确切的后端涉及。服务器交互仅限于向后端发出API调用。如果您对这些noBackend解决方案感兴趣，可以查看[http://nobackend.org/](http://nobackend.org/)。
- en: 'Our first task is to provision an account on MongoLab and create a database:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个任务是在MongoLab上配置一个账户并创建一个数据库：
- en: Go to [https://mongolab.com](https://mongolab.com) and sign up for a MongoLab
    account by following the instructions on the website.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[https://mongolab.com](https://mongolab.com)并按照网站上的说明注册一个MongoLab账户。
- en: Once the account is provisioned, log in and create a new Mongo database by clicking
    on the **Create New** button on the home page.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦账户被配置，登录并点击主页上的**创建新**按钮来创建一个新的Mongo数据库。
- en: On the database creation screen, you need to make some selections to provision
    the database. See the following screenshot to select the free database tier and
    other options:![Setting up the persistence store](../Images/image00383.jpeg)
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据库创建界面，您需要进行一些选择来配置数据库。请参考以下截图来选择免费的数据库层和其他选项：![设置持久性存储](../Images/image00383.jpeg)
- en: Create the database and make a note of the database name that you create.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建数据库并记下您创建的数据库名称。
- en: 'Once the database is provisioned, open the database and add two collections
    to it from the **Collection** tab:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦数据库被配置，打开数据库并从**集合**选项卡中向其中添加两个集合：
- en: '`exercises`: This stores all *Personal Trainer* exercises'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exercises`：这个集合存储所有*个人教练*的练习'
- en: '`workouts`: This stores all *Personal Trainer* workouts'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`workouts`：这个集合存储所有*个人教练*的锻炼'
- en: Collections in the MongoDB world equate to a database table.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB世界中，集合相当于数据库表。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: MongoDB belongs to a breed of databases called **document databases**. The central
    concepts here are documents, attributes, and their linkages. And unlike traditional
    databases, the schema is not rigid. We will not be covering what document databases
    are and how to perform data modeling for document-based stores in this book. *Personal
    Trainer* has a limited storage requirement and we manage it using the two previously
    mentioned document collections. We may not even be using the document database
    in its true sense.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB属于一类称为**文档数据库**的数据库。这里的中心概念是文档、属性和它们的链接。与传统数据库不同，模式并不是固定的。我们不会在本书中涵盖文档数据库是什么以及如何为基于文档的存储执行数据建模。*个人健身教练*有一个有限的存储需求，我们使用前面提到的两个文档集合来管理它。我们甚至可能并没有真正使用文档数据库。
- en: Once the collections are added, add yourself as a user to the database from
    the **Users** tab.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦集合被添加，从**用户**选项卡将自己添加为数据库的用户。
- en: 'The next step is to determine the API key for the MongoLab account. The provisioned
    API key has to be appended to every request made to MongoLab. To get the API key,
    perform the following steps:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是确定MongoLab账户的API密钥。配置的API密钥必须附加到发送到MongoLab的每个请求中。要获取API密钥，请执行以下步骤：
- en: Click on the username (not the account name) in the top-right corner to open
    the user profile.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右上角的用户名（而不是账户名）以打开用户配置文件。
- en: In the section titled **API Key**, the current API key is displayed; copy it.
    At the same time, click on the button below the API key to enable Data API access.
    This is disabled by default.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标题为**API密钥**的部分，显示当前的API密钥；复制它。同时，点击API密钥下面的按钮以启用数据API访问。这是默认禁用的。
- en: The data store schema is complete. We now need to seed these collections.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储模式已经完成。现在我们需要种子化这些集合。
- en: Seeding the database
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 种子化数据库
- en: The *Personal Trainer* app already has a predefined workout and a list of 12
    exercises. We need to seed the collections with this data.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*个人健身教练*应用程序已经有一个预定义的锻炼和一个包含12个练习的列表。我们需要用这些数据来种子化集合。'
- en: Open `seed.js` from `chapter5/checkpoint1/trainer/db` from the companion code
    base. It contains the seed JSON script and detailed instructions on how to seed
    data into the MongoLab database instance.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从伴随代码库的`chapter5/checkpoint1/trainer/db`中打开`seed.js`。它包含种子JSON脚本和有关如何将数据种子化到MongoLab数据库实例的详细说明。
- en: 'Once seeded, the database will have one workout in the workouts collection
    and 12 exercises in the exercises collection. Verify this on the MongoLab site;
    the collections should show this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库一旦被种子化，工作集合中将有一个锻炼，而练习集合中将有12个练习。在MongoLab网站上验证这一点；集合应该显示如下：
- en: '![Seeding the database](../Images/image00384.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![种子化数据库](../Images/image00384.jpeg)'
- en: Everything has been set up now, so let's start our discussion of the HTTP module
    and implement workout/exercise persistence for the *Personal Trainer* app.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已设置好，让我们开始讨论HTTP模块，并为*个人健身教练*应用程序实现锻炼/练习持久化。
- en: The basics of the HTTP module
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP模块的基础知识
- en: At the core of the HTTP module is the HTTP client. It performs HTTP requests
    using `XMLHttpRequest` as the default backend (JSONP is also available, as we
    will see later in this chapter). It supports requests such as `GET`, `POST`, `PUT`,
    and `DELETE`. In this chapter, we will use the HTTP client to make all of these
    types of requests. As we will see, the HTTP client makes it easy to make these
    calls with a minimal amount of setup and complexity. None of this terminology
    will come as a surprise to anyone who has previously worked with Angular or built
    JavaScript applications that communicate with a backend data store.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP模块的核心是HTTP客户端。它使用`XMLHttpRequest`作为默认后端执行HTTP请求（本章后面我们将看到也可以使用JSONP）。它支持诸如`GET`、`POST`、`PUT`和`DELETE`等请求。在本章中，我们将使用HTTP客户端来进行所有这些类型的请求。正如我们将看到的，HTTP客户端使得以最少的设置和复杂性轻松进行这些调用。如果之前有使用过Angular或构建过与后端数据存储通信的JavaScript应用程序的人，这些术语都不会让人感到意外。
- en: However, there is a substantial change in the way Angular handles HTTP requests.
    Calling a request now returns an Observable of HTTP responses. It does so by using
    the **RxJS** library, which is a well-known open source implementation of the
    asynchronous Observable pattern.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Angular处理HTTP请求的方式发生了重大变化。现在调用请求会返回一个HTTP响应的Observable。它通过使用**RxJS**库来实现，这是一个众所周知的异步Observable模式的开源实现。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the RxJS project on GitHub at [https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS).
    The site indicates that the project is being actively developed by Microsoft in
    collaboration with a community of open source developers. We will not be covering
    the asynchronous Observable pattern in great detail here, and we encourage you
    to visit that site to learn more about the pattern and how RxJS implements it.
    The version of RxJS that Angular is using is beta 5.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到RxJS项目，网址为[https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS)。该网站显示该项目正在由微软与一群开源开发人员共同开发。我们在这里不会详细介绍异步Observable模式，并鼓励您访问该网站了解更多关于该模式以及RxJS如何实现它的信息。Angular使用的RxJS版本是beta
    5。
- en: In the simplest of terms, using Observables allows a developer to think about
    the data that flows through an application as streams of information that the
    application can dip into and use whenever it wants. These streams change over
    time, which allows the application to react to these changes. This quality of
    Observables provides a foundation for **functional reactive programming** (**FRP**),
    which fundamentally shifts the paradigm for building web applications from imperative
    to reactive.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，使用Observables允许开发人员将应用程序中流动的数据视为信息流，应用程序可以随时获取并使用。这些流随时间变化，这使得应用程序可以对这些变化做出反应。Observables的这种特性为**函数式响应式编程**（**FRP**）提供了基础，从而从命令式转变为响应式构建Web应用程序的范式。
- en: The `RxJS` library provides operators that allow you to subscribe to and query
    these data streams. Moreover, you can easily mix and combine them, as we will
    see in this chapter. Another advantage of Observables is that it is easy to cancel
    or unsubscribe from them, making it possible to seamlessly handle errors inline.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`RxJS`库提供了操作符，允许您订阅和查询这些数据流。此外，您可以轻松地混合和组合它们，正如我们将在本章中看到的。Observables的另一个优势是它很容易取消订阅，使得可以无缝处理内联错误。'
- en: While it is still possible to use promises, the default method in Angular uses
    Observables. We will also cover promises in this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然仍然可以使用promises，但Angular的默认方法使用Observables。本章中我们也会介绍promises。
- en: Personal Trainer and server integration
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人教练和服务器集成
- en: As described in the previous section, client-server interaction is all about
    asynchronicity. As we alter our *Personal Trainer* app to load data from the server,
    this pattern becomes self-evident.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，客户端-服务器交互完全是关于异步性。当我们修改我们的*个人健身教练*应用程序以从服务器加载数据时，这种模式变得不言自明。
- en: In the previous chapter, the initial set of workouts and exercises was hardcoded
    in the `WorkoutService` implementation. Let's see how to load this data from the
    server first.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，锻炼和练习的初始集合是在`WorkoutService`实现中硬编码的。让我们先看看如何从服务器加载这些数据。
- en: Loading exercise and workout data
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载练习和锻炼数据
- en: Earlier in this chapter, we seeded our database with a data form, the `seed.js`
    file. We now need to render this data in our views. The MongoLab Data API is going
    to help us here.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们使用数据表单`seed.js`文件向数据库中添加了数据。现在我们需要在视图中呈现这些数据。MongoLab数据API将在这方面帮助我们。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The MongoLab Data API uses an API key to authenticate access requests. Every
    request made to the MongoLab endpoints needs to have a query string parameter,
    `apikey=<key>`, where `key` is the API key that we provisioned earlier in the
    chapter. Remember that the key is always provided to a user and associated with
    his/her account. Avoid sharing your API keys with others.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: MongoLab数据API使用API密钥来验证访问请求。对MongoLab端点发出的每个请求都需要具有查询字符串参数`apikey=<key>`，其中`key`是我们在本章前面提供的API密钥。请记住，密钥始终提供给用户并与其帐户关联。避免与他人分享您的API密钥。
- en: 'The API follows a predictable pattern to query and update data. For any MongoDB
    collection, the typical endpoint access pattern is one of the following (given
    here is the base URL: [https://api.mongolab.com/api/1/databases](https://api.mongolab.com/api/1/databases)):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: API遵循可预测的模式来查询和更新数据。对于任何MongoDB集合，典型的端点访问模式是以下之一（这里给出的是基本URL：[https://api.mongolab.com/api/1/databases](https://api.mongolab.com/api/1/databases)）：
- en: '`/<dbname>/collections/<name>?apiKey=<key>`: This has the following requests:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/<dbname>/collections/<name>?apiKey=<key>`：这有以下请求：'
- en: '`GET`: This action gets all objects in the given collection name.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`: 这个操作获取给定集合名称中的所有对象。'
- en: '`POST`: This action adds a new object to the collection name. MongoLab has
    an `_id` property that uniquely identifies the document (object). If not provided
    in the posted data, it is autogenerated.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`: 这个操作将新对象添加到集合名称中。MongoLab有一个`_id`属性，用于唯一标识文档（对象）。如果在发布的数据中未提供，则会自动生成。'
- en: '`/<dbname>/collections/<name>/<id>?apiKey=<key>`: This has the following requests:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/<dbname>/collections/<name>/<id>?apiKey=<key>`：这有以下请求：'
- en: '`GET`: This gets a specific document/collection item with a specific ID (a
    match done on the `_id` property) from the collection name'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`: 这会获取集合名称中具有特定ID的特定文档/集合项目（在`_id`属性上进行匹配）。'
- en: '`PUT`: This updates the specific item (`id`) in the collection name'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`: 这会更新集合名称中特定项目（`id`）。'
- en: '`DELETE`: This deletes the item with a specific ID from the collection name'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`: 这会从集合名称中删除具有特定ID的项目。'
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more details on the Data API interface, visit the MongoLab Data API documentation
    at [http://docs.mongolab.com/data-api](http://docs.mongolab.com/data-api).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有关数据API接口的更多详细信息，请访问MongoLab数据API文档[http://docs.mongolab.com/data-api](http://docs.mongolab.com/data-api)。
- en: Now we are in a position to start implementing exercise/workout list pages.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有能力开始实现练习/锻炼列表页面了。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code we are starting with in this chapter is `checkpoint 4.6` (folder:
    `trainer`) in the GitHub repository for this book. It is available on GitHub ([https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample)).
    Checkpoints are implemented as branches in GitHub. If you are not using Git, download
    the snapshot of Checkpoint 4.6 (a ZIP file) from the following GitHub location: [https://github.com/chandermani/angular2byexample/tree/checkpoint4.6](https://github.com/chandermani/angular2byexample/tree/checkpoint4.6).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开始时使用的代码是GitHub存储库中的`checkpoint 4.6`（文件夹：`trainer`）。它可以在GitHub上找到（[https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample)）。检查点在GitHub中作为分支实现。如果您不使用Git，请从以下GitHub位置下载Checkpoint
    4.6的快照（ZIP文件）：[https://github.com/chandermani/angular2byexample/tree/checkpoint4.6](https://github.com/chandermani/angular2byexample/tree/checkpoint4.6)。在第一次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: Loading exercise and workout lists from a server
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从服务器加载练习和锻炼列表
- en: 'To pull exercise and workout lists from the MongoLab database, we have to rewrite
    our `WorkoutService` service methods: `getExercises` and `getWorkouts`. But before
    we can do that, we have to set up our service to work with Angular''s HTTP module.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从MongoLab数据库中获取练习和锻炼列表，我们必须重写我们的`WorkoutService`服务方法：`getExercises`和`getWorkouts`。但在我们这样做之前，我们必须设置我们的服务以与Angular的HTTP模块一起工作。
- en: Adding the HTTP module and RxJS to our project
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将HTTP模块和RxJS添加到我们的项目中
- en: 'The Angular HTTP module is included in the Angular bundles that you have already
    installed. To use it, we need to import it into `app.module.ts,` like so:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的HTTP模块已经包含在您已经安装的Angular bundles中。要使用它，我们需要将其导入到`app.module.ts`中，如下所示：
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We also need an external third-party library: **Reactive Extensions for JavaScript**
    (**RxJS**). RxJS implements the Observable pattern and is used by Angular with
    the HTTP module. It is included in the Angular bundles that are already part of
    our project.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个外部第三方库：**JavaScript的Reactive Extensions**（**RxJS**）。RxJS实现了Observable模式，并且被Angular与HTTP模块一起使用。它已经包含在我们项目中的Angular
    bundles中。
- en: Updating workout-service to use the HTTP module and RxJS
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新workout-service以使用HTTP模块和RxJS
- en: 'Now, open `workout-service.ts` from `trainer/src/services`. In order to use
    the HTTP module and RxJS within `WorkoutService`, we need to add the following
    imports to that file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从`trainer/src/services`中打开`workout-service.ts`。为了在`WorkoutService`中使用HTTP模块和RxJS，我们需要在该文件中添加以下导入：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We are importing HTTP and Response from the HTTP module along with `Observable`
    from RxJS and two additional RxJS operators: `map` and `catch`. We'll see how
    these operators are used as we work through the code in this section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从HTTP模块中导入HTTP和Response，以及从RxJS导入`Observable`和另外两个RxJS操作符：`map`和`catch`。当我们在本节中处理代码时，我们将看到这些操作符是如何使用的。
- en: 'In the class definition, add the following properties, which include a workout
    property and ones that set the URL for the collections in our Mongo database and
    the key to that database as well as another property: `params`, which sets up
    the API key as a query string for API access:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义中，添加以下属性，其中包括一个锻炼属性和设置我们Mongo数据库中集合的URL以及该数据库的密钥的属性，以及另一个属性：`params`，它将API密钥设置为API访问的查询字符串：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We replace the `<dbname>` and `<key>` tokens with the database name and API
    key of the database that we provisioned earlier in the chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`<dbname>`和`<key>`标记替换为我们在本章前面提供的数据库名称和API密钥。
- en: 'Next, inject the HTTP module into the `WorkoutServiceconstructor` using the
    following line of code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下代码将HTTP模块注入到`WorkoutServiceconstructor`中：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then change the `getExercises()` method to this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将`getExercises()`方法更改为：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you are used to working with promises for asynchronous data operations, what
    you see here will look different. Instead of a promise that has a call to `then()`
    chained to it, where we expect to receive the data being returned asynchronously,
    we have a `map()` method.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于使用Promise进行异步数据操作，你在这里看到的将会有所不同。我们没有一个Promise，然后链接到它的`then()`调用，我们期望异步接收返回的数据，而是有一个`map()`方法。
- en: According to the Angular documentation ([https://angular.io/docs/ts/latest/guide/server-communication.html](https://angular.io/docs/ts/latest/guide/server-communication.html)),
    what happens here is that the `http.get` method returns an Observable of HTTP
    responses (`Observable<Response>`) from the RxJS library.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Angular文档（[https://angular.io/docs/ts/latest/guide/server-communication.html](https://angular.io/docs/ts/latest/guide/server-communication.html)），这里发生的是`http.get`方法从RxJS库返回一个HTTP响应的Observable（`Observable<Response>`）。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returning an Observable is the default response when using the HTTP module's
    `get` method. The Observable can, however, be converted to a promise. And, as
    we will see later in this chapter, the option to return JSONP also exists.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用HTTP模块的`get`方法时，返回Observable是默认的响应。然而，Observable可以转换为Promise。并且，正如我们将在本章后面看到的，还存在返回JSONP的选项。
- en: The `map` method that we can see in the code is an RxJS operator included in
    the `RxJS` library we imported earlier. It is needed here because what is retrieved
    from the remote server is not in a form that is required in our application. As
    you can see, we are using a `json()` method to convert the response body, `response`,
    into a JavaScript object.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中看到的`map`方法是我们之前导入的`RxJS`库中包含的RxJS操作符。这里需要它，因为从远程服务器检索到的内容不符合我们应用程序所需的形式。正如你所看到的，我们使用`json()`方法将响应体`response`转换为JavaScript对象。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Angular documentation also makes it clear that we should not be returning
    the `Observable<Response>` response object to the components that are calling
    this method. Instead, we should be hiding the particulars of our data access operations
    from the rest of the application. This way, we can change those operations if
    need be without having to make modifications in the other code within our application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Angular文档还明确指出，我们不应该将`Observable<Response>`响应对象返回给调用此方法的组件。相反，我们应该隐藏数据访问操作的细节，不让应用程序的其他部分知道。这样，我们可以在需要时更改这些操作，而不必修改应用程序中的其他代码。
- en: 'Before we move on, there is one more thing to touch upon in this code. The
    Observable also has a `catch` operator that accepts a method, `handleError`, for
    handling a failed response. The `handleError` method takes the failed response
    as a parameter. At the moment, we''ll follow the same approach that is laid out
    in the documentation for this `handleError` method. We log the error to the console
    and use `Observable.throw` to convert the JSON error into a user-friendly message,
    which we then return:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，这段代码还有一件事要提及。Observable还有一个`catch`操作符，接受一个名为`handleError`的方法来处理失败的响应。`handleError`方法将失败的响应作为参数。目前，我们将遵循文档中为这个`handleError`方法制定的相同方法。我们将错误记录到控制台，并使用`Observable.throw`将JSON错误转换为用户友好的消息，然后返回：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To be clear, this is not production code but it will give us the opportunity
    to show how to write code upstream to handle errors that are generated as part
    of data access.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 明确一点，这不是生产代码，但它将给我们一个机会展示如何编写上游代码来处理作为数据访问的一部分生成的错误。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to understand that at this stage, our Observable is what is
    called *cold*. This means that no data is flowing through it until there is a
    subscription to it. This can bring about a gotcha moment for things such as adds
    and updates if you are not careful to add subscriptions to your Observables.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，在这个阶段，我们的Observable被称为*冷*。这意味着在订阅之前，没有数据流经它。如果你不小心添加订阅到你的Observables中，这可能会带来一些意外的情况，比如添加和更新。
- en: Modifying getWorkouts() to use the HTTP module
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改`getWorkouts()`以使用HTTP模块
- en: 'The change in the code for retrieving workouts is almost identical to that
    for the exercises:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 检索锻炼的代码变化几乎与练习的代码变化相同。
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that the `getExercises` and `getWorkouts` methods are updated, we need to
    make sure that they work with the upstream callers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`getExercises`和`getWorkouts`方法已经更新，我们需要确保它们能够与上游调用方一起工作。
- en: Updating the workout/exercise list pages
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新锻炼/练习列表页面
- en: 'The exercises and workouts list pages (as well as `LeftNavExercises`) call
    either the `getExercises` or `getWorkouts` method in `model.ts`. In order to get
    these working with the remote calls that are now being made using the HTTP module,
    we need to modify those calls to subscribe to the Observable that is being returned
    by the HTTP module. So, update the code in the `ngOnInit` method in `exercises.component.ts`
    to the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 练习和锻炼列表页面（以及`LeftNavExercises`）调用`model.ts`中的`getExercises`或`getWorkouts`方法。为了使它们能够与现在使用HTTP模块进行的远程调用一起工作，我们需要修改这些调用，订阅由HTTP模块返回的Observable。因此，更新`exercises.component.ts`中的`ngOnInit`方法的代码如下：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our method now subscribes to the Observable that is being returned by the `getExercises`
    method; at the point when the response arrives, it assigns the results to `exerciseList`.
    If there is an error, it assigns it to a `console.error` call that displays the
    error in the console. All of this is now being handled asynchronously using the
    HTTP module with RxJS.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法现在订阅了`getExercises`方法返回的Observable；在响应到达时，它将结果分配给`exerciseList`。如果有错误，它将分配给`console.error`调用，显示控制台中的错误。所有这些现在都是使用HTTP模块和RxJS异步处理的。
- en: Go ahead and make similar changes to the `ngOnInit` methods in `workouts.component,ts`
    and `left-nav-exercises.component.ts`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 继续对`workouts.component.ts`和`left-nav-exercises.component.ts`中的`ngOnInit`方法进行类似的更改。
- en: Refresh the workout/exercise list page and the workout and exercise data will
    be loaded from the database server.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新锻炼/练习列表页面，锻炼和练习数据将从数据库服务器加载。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Look at the complete implementation in checkpoint 5.1 in the GitHub repository
    if you are having difficulty in retrieving/showing data. Note that in this checkpoint,
    we have disabled navigation links to the workout and exercise screens because
    we still have to add the Observable implementation to them. We'll do that in the
    next section. Also remember to replace the database name and API key before you
    run the code from Checkpoint 5.1. If you are not using Git, download the snapshot
    of Checkpoint 5.1 (a ZIP file) from the following GitHub location: [https://github.com/chandermani/angular2byexample/tree/checkpoint5.1](https://github.com/chandermani/angular2byexample/tree/checkpoint5.1).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在检索/显示数据时遇到困难，请查看GitHub存储库中检查点5.1的完整实现。请注意，在此检查点中，我们已禁用了导航链接到锻炼和练习屏幕，因为我们仍然需要为它们添加Observable实现。我们将在下一节中进行。在运行来自检查点5.1的代码之前，请记得替换数据库名称和API密钥。如果您不使用Git，请从以下GitHub位置下载检查点5.1的快照（ZIP文件）：[https://github.com/chandermani/angular2byexample/tree/checkpoint5.1](https://github.com/chandermani/angular2byexample/tree/checkpoint5.1)。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: 'This looks good and the lists are loading fine. Well, almost! There is a small
    glitch in the workout list page. We can easily spot it if we look carefully at
    any list item (in fact, there is only one item):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错，列表加载正常。嗯，几乎！锻炼列表页面有一个小故障。如果我们仔细观察任何列表项（实际上只有一个），我们可以很容易地发现它：
- en: '![Updating the workout/exercise list pages](../Images/image00385.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![更新锻炼/练习列表页面](../Images/image00385.jpeg)'
- en: The workout duration calculations are not working anymore! What could be the
    reason? We need to look back at how these calculations were implemented. The `WorkoutPlan`
    service (in `model.ts`) defines a `totalWorkoutDuration` method that does the
    math for this.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 锻炼持续时间的计算不再起作用！原因是什么？我们需要回顾这些计算是如何实现的。“WorkoutPlan”服务（在“model.ts”中）定义了一个“totalWorkoutDuration”方法来进行这些计算。
- en: The difference is in the workout array that is bound to the view. In the previous
    chapter, we created the array with model objects that were created using the `WorkoutPlan`
    service. But now, since we are retrieving data from the server, we bind a simple
    array of JavaScript objects to the view, which for obvious reasons has no calculation
    logic.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于绑定到视图的锻炼数组。在上一章中，我们使用“WorkoutPlan”服务创建了包含模型对象的数组。但是现在，由于我们正在从服务器检索数据，我们将一个简单的JavaScript对象数组绑定到视图，这是因为明显的原因没有计算逻辑。
- en: We can fix this problem by mapping a server response to our model class objects
    and returning them to any upstream caller.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将服务器响应映射到我们的模型类对象并将它们返回给任何上游调用者来解决这个问题。
- en: Mapping server data to application models
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将服务器数据映射到应用程序模型
- en: Mapping server data to our model and vice versa may be unnecessary if the model
    and server storage definition match. If we look at the `Exercise` model class
    and the seed data that we have added for the exercise in MongoLab, we will see
    that they do match and hence mapping becomes unnecessary.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型和服务器存储定义匹配，那么将服务器数据映射到我们的模型和反之亦然可能是不必要的。如果我们查看“Exercise”模型类和我们在MongoLab中为练习添加的种子数据，我们会发现它们是匹配的，因此映射变得不必要。
- en: 'Mapping a server response to the model data becomes imperative if:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以下情况成立，则将服务器响应映射到模型数据变得必要：
- en: Our model defines any methods
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的模型定义了任何方法
- en: A stored model is different from its representation in code
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储的模型与其在代码中的表示不同
- en: The same model class is used to represent data from different sources (this
    can happen for mashups, where we pull data from disparate sources)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的模型类用于表示来自不同来源的数据（这可能发生在混搭中，我们从不同的来源获取数据）
- en: 'The `WorkoutPlan` service is a prime example of an impedance mismatch between
    a model representation and its storage. Look at the following screenshot to understand
    these differences:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: “WorkoutPlan”服务是模型表示和存储之间阻抗不匹配的一个典型例子。查看以下屏幕截图以了解这些差异：
- en: '![Mapping server data to application models](../Images/image00386.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![将服务器数据映射到应用程序模型](../Images/image00386.jpeg)'
- en: 'The two major differences between the model and server data are as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 模型和服务器数据之间的两个主要差异如下：
- en: The model defines the `totalWorkoutDuration` method.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型定义了“totalWorkoutDuration”方法。
- en: The `exercises` array representation also differs. The `exercises` array of
    the model contains the full `Exercise` object while the server data stores just
    the exercise identifier or name.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “练习”数组的表示也不同。模型的“练习”数组包含完整的“Exercise”对象，而服务器数据只存储练习标识符或名称。
- en: This clearly means that loading and saving a workout require model mapping.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然意味着加载和保存锻炼需要模型映射。
- en: The way we will do this is by adding a second map to further transform the Observable
    response object. So far, we have only transformed the response into a plain JavaScript
    object. The nice thing is that the map request that we just used also returns
    an Observable, which allows us to chain another map request that transforms the
    JSON object. With the second map request, we will map that JSON object to the
    `WorkoutPlan` type in our model.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过添加第二个映射来实现这一点，进一步转换Observable响应对象。到目前为止，我们只是将响应转换为一个普通的JavaScript对象。好处是，我们刚刚使用的map请求也返回一个Observable，这允许我们链接另一个map请求，将JSON对象转换为`WorkoutPlan`类型。
- en: 'Let''s rewrite the `getWorkouts` method in the `workout-service.ts` file to
    add the second map:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`workout-service.ts`文件中重写`getWorkouts`方法，以添加第二个映射：
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As previously, our first map transforms the response Observable into an Observable
    consisting of an array of JavaScript objects. The second map then transforms this
    Observable into one made up of `WorkoutPlan` objects. Each `WorkoutPlan` object
    (we have only one at the moment) will then have the `totalWorkoutDuration` method
    that we need.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们的第一个映射将响应Observable转换为由JavaScript对象数组组成的Observable。然后，第二个映射将这个Observable转换为由`WorkoutPlan`对象组成的Observable。每个`WorkoutPlan`对象（目前我们只有一个）将具有我们需要的`totalWorkoutDuration`方法。
- en: Looking at the code for the second map, you can see that we operate on the JSON
    results from the first method, which is why we are using the `<any>` type. And
    then we create a typed array of `WorkoutPlans` and iterate through the first array
    using a fat arrow `forEach` function, assigning each JavaScript object to a `WorkoutPlan`
    object.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 查看第二个映射的代码，您可以看到我们是如何操作第一个方法的JSON结果的，这就是为什么我们使用了`<any>`类型。然后我们创建了一个`WorkoutPlans`的类型数组，并使用一个箭头函数`forEach`来遍历第一个数组，将每个JavaScript对象分配给一个`WorkoutPlan`对象。
- en: We return the results of these mappings to the callers that subscribe to them,
    `workouts.component.ts` in this case. The callers do not need to make any changes
    to the code they use to subscribe to our workouts Observable. Instead, the model
    mapping can take place at one spot in the application and then be used throughout
    it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些映射的结果返回给订阅它们的调用者，在这种情况下是`workouts.component.ts`。调用者不需要对他们用来订阅我们的workouts
    Observable的代码进行任何更改。相反，模型映射可以在应用程序的一个地方进行，然后在整个应用程序中使用。
- en: 'If you rerun the application, you will see that the total number of seconds
    now displays properly:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重新运行应用程序，您将看到总秒数现在正确显示了：
- en: '![Mapping server data to application models](../Images/image00387.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![将服务器数据映射到应用程序模型](../Images/image00387.jpeg)'
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Checkpoint 5.2 in the GitHub repository contains the working implementation
    for what we have covered so far. The GitHub branch is `checkpoint5.2` (folder:
    `trainer`).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub存储库中的检查点5.2包含了我们迄今为止所涵盖的工作实现。GitHub分支是`checkpoint5.2`（文件夹：`trainer`）。
- en: Loading exercise and workout data from the server
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从服务器加载练习和锻炼数据
- en: Just as we fixed the `getWorkouts` implementation in `WorkoutService` earlier,
    we can implement other get operations for exercise- and workout-related stuff.
    Copy the service implementation for the `getExercise` and `getWorkout` methods
    of `WorkoutService` from `workout-builder.component.ts` in the `trainer/src/components/workout-builder`
    folder in checkpoint 5.2.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前在`WorkoutService`中修复了`getWorkouts`的实现一样，我们可以为与练习和锻炼相关的其他获取操作实现`WorkoutService`的`getExercise`和`getWorkout`方法。从检查点5.2中的`trainer/src/components/workout-builder`文件夹中的`workout-builder.component.ts`复制`WorkoutService`的服务实现。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `getWorkout` and `getExercise` methods use the name of the workout/exercise
    to retrieve results. Every MongoLab collection item has an `_id` property that
    uniquely identifies the item/entity. In the case of our `Exercise` and `WorkoutPlan`
    objects, we use the name of the exercise for unique identification. Hence, the
    `name` and `_id` property of each object always match.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`getWorkout`和`getExercise`方法使用训练/练习的名称来检索结果。每个MongoLab集合项都有一个`_id`属性，用于唯一标识该项/实体。对于我们的`Exercise`和`WorkoutPlan`对象，我们使用练习的名称进行唯一标识。因此，每个对象的`name`和`_id`属性始终匹配。'
- en: 'At this point, we will need to add one more import to `workout-service.ts`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要在`workout-service.ts`中添加一个额外的导入：
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This import brings in the `forkJoin` operator which we will be discussing shortly.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个导入引入了我们将很快讨论的`forkJoin`操作符。
- en: 'Pay special attention to the implementation for the `getWorkout` method because
    there is a decent amount of data transformation happening due to the model and
    data storage format mismatch. This is how the `getWorkout` method now looks:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意`getWorkout`方法的实现，因为由于模型和数据存储格式不匹配，这里发生了相当多的数据转换。现在`getWorkout`方法的样子是这样的：
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There is a lot happening inside `getWorkout` that we need to understand.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`getWorkout`内部发生了很多事情，我们需要理解。'
- en: 'The `getWorkout` method uses Observable and its `forkJoin` operator to return
    two Observable objects: one that retrieves the `Workout` and another that retrieves
    a list of all the `Exercises`. What is interesting about the `forkJoin` operator
    is that not only does it allow us to return multiple Observable streams, but it
    also waits until both Observable streams have retrieved their data before further
    processing the results. In other words, it enables us to stream the responses
    from multiple concurrent HTTP requests and then operate on the combined results.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`getWorkout`方法使用Observable及其`forkJoin`操作符返回两个Observable对象：一个用于检索`Workout`，另一个用于检索所有`Exercises`的列表。`forkJoin`操作符的有趣之处在于它不仅允许我们返回多个Observable流，而且还会等待两个Observable流都检索到数据后再进一步处理结果。换句话说，它使我们能够从多个并发的HTTP请求中流式传输响应，然后对组合结果进行操作。'
- en: Once we have the `Workout` details and the complete list of exercises, we use
    the map operator (which we saw previously with the code for the `Workouts` list)
    to update the `exercises` array of the workout to the correct `Exercise` class
    object. It does this by searching the `allExercises` Observable for the name of
    the exercise in the `workout.exercises` array returned from the server, and then
    assigning the matching exercise to the workout services array. The end result
    is that we have a complete `WorkoutPlan` object with the `exercises` array set
    up correctly.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`Workout`的详细信息和完整的练习列表，我们就使用map操作符（我们之前在`Workouts`列表的代码中看到过）来更新`workout`的`exercises`数组，将其正确地设置为`Exercise`类对象。它通过在`allExercises`
    Observable中搜索来自服务器的`workout.exercises`数组中的练习名称，然后将匹配的练习分配给workout服务数组来实现这一点。最终结果是我们得到了一个完整的`WorkoutPlan`对象，其中`exercises`数组被正确设置。
- en: These `WorkoutService` changes warrant fixes in upstream callers too. We have
    already fixed the lists of exercises in the `LeftNavExercises` and `Exercises`
    components and the workouts in the `Workouts` component.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`WorkoutService`的更改也需要在上游调用者中进行修复。我们已经修复了`LeftNavExercises`和`Exercises`组件中的练习列表，以及`Workouts`组件中的训练。
- en: Now let's fix the `Workout` and `Exercise` components along similar lines. The
    `getWorkout` and `getExercise` methods in the workout services are not directly
    called by these components but by builder services. Let's now fix the builder
    services together with the `Workout` and `Exercise` components.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们以类似的方式修复`Workout`和`Exercise`组件。`Workout`服务中的`getWorkout`和`getExercise`方法不是直接由这些组件调用的，而是由构建器服务调用的。现在让我们一起修复构建器服务以及`Workout`和`Exercise`组件。
- en: Fixing the builder services
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复构建服务
- en: 'Now that we have `WorkoutService` set up to retrieve a workout from our remote
    data store, we have to modify `WorkoutBuilderService` to be able to retrieve that
    workout as an Observable. The method that pulls the `Workout` details is `startBuilding`.
    In order to do that, we will break the current `startBuilding` method into two
    methods, one for new workouts and one for existing workouts that we have retrieved
    from the server. Here is the code for new workouts:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了`WorkoutService`来从远程数据存储中检索锻炼，我们必须修改`WorkoutBuilderService`以能够将该锻炼作为Observable检索出来。提取`Workout`详情的方法是`startBuilding`。为了做到这一点，我们将当前的`startBuilding`方法分成两个方法，一个用于新的锻炼，一个用于我们从服务器检索到的现有锻炼。以下是新锻炼的代码：
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For existing workouts, we add the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现有的锻炼，我们添加以下代码：
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We'll let you make the same fixes in `ExerciseBuilderService`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会让你在`ExerciseBuilderService`中做同样的修复。
- en: Fixing the Workout and Exercise components
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复锻炼和锻炼组件
- en: Next, we will update our `Workout` and `Exercise` components to work with the
    Observable that we are returning from our remote data store. We will fix the `Workout`
    component and leave it to you to fix the `Exercise` component yourself as it follows
    a similar pattern. `LeftNavExercises`, used in the workout detail page navigation
    rendering, is already fixed, so let's jump on to fixing the `Workout` component.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新我们的`Workout`和`Exercise`组件，以便与我们从远程数据存储返回的Observable一起工作。我们将修复`Workout`组件，并留给你自己来修复`Exercise`组件，因为它遵循类似的模式。在锻炼详情页面导航渲染中使用的`LeftNavExercises`已经修复，所以让我们开始修复`Workout`组件。
- en: 'The `Workout` component uses its `ngOnit` life cycle hook to load a new or
    existing workout. When the route successfully resolves to this component, `ngOnit`
    uses the injected `WorkoutBuilderService` to load the workout. Here is what the
    method looks like:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Workout`组件使用它的`ngOnit`生命周期钩子来加载新的或现有的锻炼。当路由成功解析到这个组件时，`ngOnit`使用注入的`WorkoutBuilderService`来加载锻炼。方法如下：'
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Firstly, we change the method for a new workout to the `WorkoutBuilderService.startBuildingNew`
    method. This method creates a new `WorkoutPlan` object and assigns it to a local
    instance of `WorkoutPlan` that will be used to display the workout on the screen.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将新锻炼的方法更改为`WorkoutBuilderService.startBuildingNew`方法。这个方法创建一个新的`WorkoutPlan`对象，并将其分配给一个本地的`WorkoutPlan`实例，该实例将用于在屏幕上显示锻炼。
- en: Secondly, we change the code for retrieving an existing `WorkoutPlan` to handle
    the fact that what is now being returned is an Observable. We therefore add the
    code to subscribe to that Observable and set the results to a local instance of
    `WorkoutPlan`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们更改检索现有`WorkoutPlan`的代码，以处理现在返回的是一个Observable的事实。因此，我们添加了订阅该Observable并将结果设置为本地的`WorkoutPlan`实例的代码。
- en: To test the implementation, just load any existing workout detail page, such
    as *7 Minute Workout* under `/builder/workouts/`. The workout data should load
    successfully.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试实现，只需加载任何现有的锻炼详情页面，比如在`/builder/workouts/`下的*7分钟锻炼*。锻炼数据应该成功加载。
- en: The exercise detail page also needs fixing. The `Checkpoint 5.2` file contains
    the fixed `ExerciseBuilderService` and `Exercise` components that you can copy
    to load the exercise details; or you can do it yourself and compare the implementation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 锻炼详情页面也需要修复。`Checkpoint 5.2`文件包含了修复的`ExerciseBuilderService`和`Exercise`组件，你可以复制来加载锻炼详情；或者你可以自己做并比较实现。
- en: Updating the router guards
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新路由守卫
- en: As we move on to using Observable types with our data access, we are going to
    have to make some adjustments to the router guards that we have created for the
    routes leading to workout and exercise screens. This is because of some timing
    considerations that come into play when working with Observable types. Put simply,
    because an Observable is push-based, there is often a slight delay between when
    our subscription is created and the Observable it is subscribing to is returned.
    In the case of our remote calls that populate a form or display a list of items,
    we can manage that delay by simply adding a check for the existence of the item
    or list before displaying it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开始使用Observable类型来访问数据，我们将不得不对我们为通往锻炼和练习屏幕创建的路由守卫进行一些调整。这是因为在使用Observable类型时会涉及一些时间考虑。简单地说，因为Observable是基于推送的，所以在我们创建订阅和Observable返回之间通常会有一些延迟。在我们的远程调用中，用于填充表单或显示项目列表，我们可以通过简单地添加一个检查项目或列表是否存在来管理该延迟。
- en: However, no such option exists with our guards which run their checks immediately
    upon the creation of the subscription. To fix this problem, we need to add in
    some code to `workout-guard.ts` that ensures that the Observable is resolved before
    we run the check.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的守卫中并不存在这样的选项，它们会在订阅创建时立即运行检查。为了解决这个问题，我们需要在`workout-guard.ts`中添加一些代码，以确保Observable在我们运行检查之前得到解决。
- en: 'First import the `Observable` from RxJS:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先从RxJS中导入`Observable`：
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next update the `canActivate` method in the `WorkoutGuard` component, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来更新`WorkoutGuard`组件中的`canActivate`方法，如下所示：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What we are doing here is using the `take` operator and setting it to `1` in
    order to stop the Observable subscription when a single result is returned. We
    then `map` the workout object to a `boolean` (using the JavaScript double not
    operator) to determine whether it exists. Finally, we use the `do` operator to
    set the route to false in the event that it does not exist and route the user
    back to the workouts screen. This gives us the immediate result that we are looking
    for.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是使用`take`操作符，并将其设置为`1`，以便在返回单个结果时停止Observable订阅。然后，我们使用`map`将锻炼对象映射到`boolean`（使用JavaScript的双非运算符）以确定其是否存在。最后，我们使用`do`操作符在它不存在的情况下将路由设置为false，并将用户路由回锻炼屏幕。这给了我们我们正在寻找的即时结果。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`Checkpoint 5.2` in the GitHub repository contains the working implementation
    for what we have covered thus far. If you are not using Git, download the snapshot
    of Checkpoint 5.2 (a ZIP file) from the following GitHub location: [https://github.com/chandermani/angular2byexample/tree/checkpoint5.2](https://github.com/chandermani/angular2byexample/tree/checkpoint5.2).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub存储库中的`Checkpoint 5.2`包含了我们迄今为止所涵盖的工作实现。如果您不使用Git，请从以下GitHub位置下载Checkpoint
    5.2的快照（ZIP文件）：[https://github.com/chandermani/angular2byexample/tree/checkpoint5.2](https://github.com/chandermani/angular2byexample/tree/checkpoint5.2)。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: It is now time to fix, create, and update scenarios for the exercises and workouts.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候为练习和锻炼修复、创建和更新场景了。
- en: Performing CRUD on exercises/workouts
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在练习/锻炼上执行CRUD
- en: When it comes to create, read, update, and delete (CRUD) operations, all save,
    update, and delete methods need to be converted to the Observable pattern.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建、读取、更新和删除（CRUD）操作方面，所有保存、更新和删除方法都需要转换为Observable模式。
- en: Earlier in the chapter, we detailed the endpoint access pattern for CRUD operations
    in a MongoLab collection. Head back to the *Loading exercise and workout data* section
    and revisit the access patterns. We need this now as we plan to create/update
    workouts.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们详细介绍了对MongoLab集合中的CRUD操作的端点访问模式。回到*加载锻炼和锻炼数据*部分，重新审视访问模式。我们现在需要这个，因为我们计划创建/更新锻炼。
- en: Before we start the implementation, it is important to understand how MongoLab
    identifies a collection item and what our ID generation strategy is. Each collection
    item in MongoDB is uniquely identified in the collection using the `_id` property.
    While creating a new item, either we supply an ID or the server generates one
    itself. Once `_id` is set, it cannot be changed. For our model, we will use the
    `name` property of the exercise/workout as the unique ID and copy the name into
    the `_id` field (hence, there is no auto generation of `_id`). Also remember that
    our model classes do not contain this `_id` field; it has to be created before
    saving the record for the first time.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实施之前，了解MongoLab如何识别集合项以及我们的ID生成策略非常重要。MongoDB中的每个集合项都是通过`_id`属性在集合中唯一标识的。在创建新项目时，我们要么提供一个ID，要么服务器自动生成一个ID。一旦设置了`_id`，就不能更改。对于我们的模型，我们将使用锻炼/锻炼的`name`属性作为唯一ID，并将名称复制到`_id`字段中（因此，没有自动生成`_id`）。还要记住，我们的模型类不包含这个`_id`字段；在第一次保存记录之前，必须创建它。
- en: Let's fix the workout creation scenario first.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先修复锻炼创建的场景。
- en: Creating a new workout
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新的锻炼
- en: 'Taking the bottom-up approach, the first thing that needs to be fixed is `WorkoutService`.
    Update the `addWorkout` method as shown in the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 采用自下而上的方法，需要首先修复的是`WorkoutService`。按照下面的代码更新`addWorkout`方法：
- en: '[PRE16]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In `getWorkout`, we had to map data from the server model to our client model;
    the reverse has to be done here. First, we create a new array for the exercises,
    `workoutExercises`, and then add to that array a version of the exercises that
    is more compact for server storage. We only want to store the exercise name and
    duration in the exercises array on the server (this array is of type `any` because
    in its compact format it does not conform to the `ExercisePlan` type).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getWorkout`中，我们需要将数据从服务器模型映射到我们的客户端模型；在这里需要做相反的操作。首先，我们为锻炼创建一个新的数组`workoutExercises`，然后向该数组添加一个更紧凑的版本的锻炼，以便更好地存储在服务器上。我们只想在服务器上的锻炼数组中存储锻炼名称和持续时间（该数组的类型为`any`，因为在其紧凑格式中，它不符合`ExercisePlan`类型）。
- en: Next, we set up the body of our post by mapping these changes into a JSON object.
    Note that as part of constructing this object, we set the `_id` property as the
    name of the workout to uniquely identify it in the database of the workouts collection.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过将这些更改映射到JSON对象来设置我们的帖子的主体。请注意，作为构造此对象的一部分，我们将`_id`属性设置为锻炼的名称，以在锻炼集合的数据库中唯一标识它。
- en: Note
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The simplistic approach of using the *name* of the workout/exercise as a record
    identifier (or `id`) in MongoDB will break for any decent-sized app. Remember
    that we are creating a web-based application that can be accessed simultaneously
    by many users. Since there is always the possibility of two users coming up with
    the same name for a workout/ exercise, we need a strong mechanism to make sure
    that names are not duplicated.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中使用锻炼/锻炼的*名称*作为记录标识符（或`id`）的简单方法将在任何规模较大的应用程序中失效。请记住，我们正在创建一个可以同时被许多用户访问的基于Web的应用程序。由于总是有两个用户可能会为锻炼/锻炼取相同的名称，我们需要一个强大的机制来确保名称不重复。
- en: Another problem with the MongoLab REST API is that if there is a duplicate `POST`
    request with the same `id` field, one will create a new document and the second
    will update it, instead of the second failing. This implies that any duplicate
    checks on the `id` field on the client side still cannot safeguard against data
    loss. In such a scenario, assigning auto generation of the `id` value is preferable.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: MongoLab REST API的另一个问题是，如果有一个带有相同`id`字段的重复`POST`请求，一个将创建一个新文档，第二个将更新它，而不是第二个失败。这意味着客户端对`id`字段的任何重复检查仍然无法防止数据丢失。在这种情况下，最好分配`id`值的自动生成。
- en: In standard cases where we are creating entities, unique ID generation is done
    on the server (mostly by the database). The response to when an entity is created
    then contains the generated ID. In such a case, we need to update the model object
    before we return data to the calling code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在通常情况下，我们创建实体时，唯一的ID生成是在服务器上完成的（主要是由数据库完成）。然后，当实体被创建时，响应包含生成的ID。在这种情况下，我们需要在将数据返回给调用代码之前更新模型对象。
- en: Lastly, we call the `post` method of the HTTP module, passing the URL to connect
    to, an extra query string parameter (`apiKey`), and the data we are sending.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用HTTP模块的`post`方法，传递要连接的URL，一个额外的查询字符串参数（`apiKey`），以及我们要发送的数据。
- en: The last return statement should look familiar, as we use Observables to return
    the workout object as part of the Observable resolution. You need to be sure you add
    `.subscribe` to the Observable chain in order to make it hot. We'll do that shortly
    by adding a subscription to the save method of the to the `WorkoutComponent`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的返回语句应该看起来很熟悉，因为我们使用Observables作为Observable分辨率的一部分返回锻炼对象。您需要确保在Observable链中添加`.subscribe`以使其变热。我们将很快通过向`WorkoutComponent`的`save`方法添加订阅来做到这一点。
- en: Updating a workout
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新锻炼
- en: 'Why not try to implement the update operation? The `updateWorkout` method can
    be fixed in the same manner, the only difference being that the HTTP module''s
    `put` method is required:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不尝试实现更新操作呢？`updateWorkout`方法可以以相同的方式进行修复，唯一的区别是需要使用HTTP模块的`put`方法：
- en: '[PRE17]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding request URL now contains an extra fragment (`workout.name`) that
    denotes the identifier of the collection item that needs to be updated.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的请求URL现在包含一个额外的片段（`workout.name`），表示需要更新的集合项的标识符。
- en: The MongoLab `PUT` API request creates the document passed in as the request
    body if the document is not found in the collection. While making the `PUT` request,
    make sure that the original record exists. We can do this by making a `GET` request
    for the same document first and confirming that we get a document before we update
    it. We'll leave that for you to implement.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在集合中找不到文档，MongoLab的`PUT` API请求将创建传递的文档作为请求体。在进行`PUT`请求时，请确保原始记录存在。我们可以通过首先对相同文档进行`GET`请求并确认我们在更新之前获得文档来做到这一点。我们将把这个任务留给你来实现。
- en: Deleting a workout
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除锻炼
- en: 'The last operation that needs to be fixed is deleting the workout. Here is
    a simple implementation where we call the HTTP module''s `delete` method to delete
    the workout referenced by a specific URL:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 需要修复的最后一个操作是删除锻炼。这里是一个简单的实现，我们调用HTTP模块的`delete`方法来删除特定URL引用的锻炼：
- en: '[PRE18]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Fixing the upstream code
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复上游代码
- en: 'With that, it''s now time to fix the `WorkoutBuilderService` and `Workout`
    components. The `save` method of `WorkoutBuilderService` now looks like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，现在是时候修复`WorkoutBuilderService`和`Workout`组件了。`WorkoutBuilderService`的`save`方法现在看起来像这样：
- en: '[PRE19]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Most of it looks the same as it was earlier because it is the same! We did not
    have to update this code because we effectively isolated the interaction with
    the external server in our `WorkoutService` component.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分看起来与以前一样，因为它确实是一样的！我们不必更新这段代码，因为我们在`WorkoutService`组件中有效地隔离了与外部服务器的交互。
- en: 'Finally, the save code for the `Workout` component is shown here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里显示了`Workout`组件的保存代码：
- en: '[PRE20]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here we have made a change so that we now subscribe to the save. As you may
    recall from our previous discussions, `subscribe` makes an Observable live so
    that we can complete the save.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经进行了更改，以便我们现在订阅保存。正如您可能还记得我们之前的讨论，`subscribe`使Observable变为活动状态，以便我们可以完成保存。
- en: And that's it! We can now create new workouts, update existing workouts, and
    delete them too. That was not too difficult!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们现在可以创建新的锻炼，更新现有的锻炼，也可以删除它们。这并不太困难！
- en: Let's try it out. Open the new `Workout Builder` page, create a workout, and
    save it. Also try to edit an existing workout. Both scenarios should work seamlessly.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试。打开新的`Workout Builder`页面，创建一个锻炼，并保存它。还尝试编辑一个现有的锻炼。这两种情况应该都能无缝工作。
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Check out `checkpoint 5.3` for an up-to-date implementation if you are having
    issues running your local copy.  If you are not using Git, download the snapshot
    of Checkpoint 5.3 (a ZIP file) from the following GitHub location: [https://github.com/chandermani/angular2byexample/tree/checkpoint5.3](https://github.com/chandermani/angular2byexample/tree/checkpoint5.3).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在运行本地副本时遇到问题，请查看`checkpoint 5.3`以获取最新的实现。如果您不使用Git，请从以下GitHub位置下载Checkpoint
    5.3的快照（ZIP文件）：[https://github.com/chandermani/angular2byexample/tree/checkpoint5.3](https://github.com/chandermani/angular2byexample/tree/checkpoint5.3)。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: 'Something interesting happens on the network side while we make `POST` and
    `PUT` requests to save data. Open the browser''s network log console (F12) and
    see the requests being made. The log looks something like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行`POST`和`PUT`请求保存数据时，网络端会发生一些有趣的事情。打开浏览器的网络日志控制台（F12），看看正在进行的请求。日志看起来像这样：
- en: '![Fixing the upstream code](../Images/image00388.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![修复上游代码](../Images/image00388.jpeg)'
- en: An `OPTIONS` request is made to the same endpoint before the actual `PUT` is
    done. The behavior that we witness here is termed a **prefight request**. This
    happens because we are making a cross-domain request to `api.mongolab.com`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际进行`PUT`之前，会向相同的端点发出一个`OPTIONS`请求。我们在这里见证的行为被称为**预检请求**。这是因为我们正在向`api.mongolab.com`发出跨域请求。
- en: Using promises for HTTP requests
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用promises进行HTTP请求
- en: The bulk of this chapter has focused on how the Angular HTTP client uses Observables
    as the default for `XMLHttpRequests`. This represents a significant change from
    the way things used to work. Many developers are familiar with using promises
    for asynchronous HTTP requests. With that being the case, Angular continues to
    support promises but just not as the default choice. A developer has to opt for
    promises in an `XMLHttpRequest` in order to be able to use them.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容都集中在Angular HTTP客户端如何将Observables作为`XMLHttpRequests`的默认值。这代表了与以往工作方式的重大变化。许多开发人员习惯于使用promises进行异步HTTP请求。在这种情况下，Angular仍然支持promises，但不再是默认选择。开发人员必须选择在`XMLHttpRequest`中使用promises才能使用它们。
- en: 'For example, if we want to use promises with the `getExercises` method in `WorkoutService,`
    we will first need to import the RxJS `toPromise` operator:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想在`WorkoutService`的`getExercises`方法中使用promises，我们首先需要导入RxJS的`toPromise`操作符：
- en: '[PRE21]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then we will have to restructure the command as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将不得不重新构造命令如下：
- en: '[PRE22]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In order to convert this method to use promises, all we have to do is add `.toPromise()`
    to the method chain and then replace the call to `.map` with a success parameter,
    `then`, for the promise. We can leave `catch` as it is.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这个方法转换为使用promises，我们只需要在方法链中添加`.toPromise()`，然后用promise的成功参数`then`替换对`.map`的调用。我们可以保留`catch`不变。
- en: 'For upstream components, we just have to switch to handling the return value
    as a promise rather than an Observable. So, to use promises in this case, we would
    have to change the code in `Exercises.component.ts` and `LeftNavExercises.component.ts`
    to first add a new property for the error message:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上游组件，我们只需将返回值处理为promise而不是Observable。因此，在这种情况下使用promises，我们需要更改`Exercises.component.ts`和`LeftNavExercises.component.ts`中的代码，首先添加一个新的属性来存储错误消息。
- en: '[PRE23]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then change the method that is calling `WorkoutService` to the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后更改调用`WorkoutService`的方法如下：
- en: '[PRE24]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Of course, the ease with which we can substitute promises for Observables in
    this simple example does not indicate that they are essentially the same. A `then`
    promise returns another promise, which means that you can create successively
    chained promises. In the case of an Observable, a subscription is essentially
    the end of the line and cannot be mapped or subscribed to beyond that point.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以在这个简单的例子中轻松地用Promise替代Observables，并不意味着它们本质上是一样的。`then` promise返回另一个promise，这意味着你可以创建连续链接的promise。在Observable的情况下，订阅本质上是终点，不能在那一点之后进行映射或订阅。
- en: If you're familiar with promises, it may be tempting at this stage to stick
    with them and not give Observables a try. After all, much of what we have done
    with Observables in this chapter can be done with promises as well. For example,
    the mapping of two streams of Observables that we did with `getWorkouts` using
    the Observable's `forkJoin` operator can also be done with the promise's `q,all`
    function.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉promises，也许在这个阶段坚持使用它们而不尝试Observables会很诱人。毕竟，我们在本章中使用Observables所做的大部分工作也可以用promises完成。例如，我们使用Observable的`forkJoin`操作符对`getWorkouts`的两个流进行映射，也可以用promise的`q,all`函数完成。
- en: However, you would be selling yourself short if you took that approach. Observables
    open up an exciting new way of doing web development using what is called functional
    reactive programming. They involve a fundamental shift in thinking that treats
    an application's data as a constant stream of information to which the application
    reacts and responds. This shift allows applications to be built with a different
    architecture that makes them faster and more resilient. Observables are at the
    core of Angular in such things as event emitters and the new version of `NgModel`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你采取这种方法，你会卖自己短。Observables开启了一种令人兴奋的新的网页开发方式，使用了所谓的函数式响应式编程。它们涉及一种基本的思维转变，将应用程序的数据视为一种持续的信息流，应用程序对其做出反应和响应。这种转变使应用程序能够以不同的架构构建，使其更快速和更具弹性。Observables是Angular的核心，例如事件发射器和新版本的`NgModel`。
- en: While promises are a useful tool to have in your toolkit, we encourage you to
    investigate Observables as you get into developing with Angular. They are part
    of the forward-looking philosophy of Angular and will be useful in future-proofing
    both your applications and your skill set.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然promises是你工具箱中有用的工具，但我们鼓励你在使用Angular进行开发时调查Observables。它们是Angular前瞻性哲学的一部分，将有助于未来保护你的应用程序和技能。
- en: Note
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Check out the `checkpoint 5.3` file for an up-to-date implementation that includes
    the promises-related code that we covered previously.  If you are not using Git,
    download the snapshot of Checkpoint 5.3 (a ZIP file) from the following GitHub
    location: [https://github.com/chandermani/angular2byexample/tree/checkpoint5.3](https://github.com/chandermani/angular2byexample/tree/checkpoint5.3).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time. Be aware that in the next section, we will be reverting to
    the use of Observables for this code. This code can be found in the `checkpoint
    5.4` file.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`检查点5.3`文件，以获取包括我们之前介绍的与promises相关的代码的最新实现。如果您没有使用Git，请从以下GitHub位置下载Checkpoint
    5.3的快照（ZIP文件）：[https://github.com/chandermani/angular2byexample/tree/checkpoint5.3](https://github.com/chandermani/angular2byexample/tree/checkpoint5.3)。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。请注意，在下一节中，我们将重新使用Observables来处理此代码。此代码可以在`检查点5.4`文件中找到。
- en: The async pipe
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步管道
- en: As we have seen with many of the data operations covered in this chapter, there
    is a fairly common pattern being repeated over and over again. When an Observable
    is returned from an HTTP request, we convert the response to JSON and subscribe
    to it. The subscription then binds the Observable output to a UI element. Wouldn't
    it be nice if we could eliminate this repetitive coding and replace it with a
    simpler way to accomplish what we are wanting to do?
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中看到的许多数据操作一样，有一个相当常见的模式一遍又一遍地重复。当从HTTP请求返回一个Observable时，我们将响应转换为JSON并订阅它。然后订阅将Observable输出绑定到UI元素。如果我们能消除这种重复的编码，并用更简单的方法来实现我们想要做的事情，那不是挺好的吗？
- en: Not surprisingly, Angular provides us with just the right way to do that. It's
    called the **async pipe**, and it can be used like any other pipe for binding
    to an element on the screen. However, the async pipe is a much more powerful mechanism
    than other pipes. It takes an Observable or a promise as an input and subscribes
    to it automatically. It also handles the tear down of the subscription for an
    Observable without necessitating any further lines of code.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，Angular为我们提供了正确的方法。它被称为**异步管道**，可以像其他管道一样用于绑定屏幕上的元素。但是，异步管道比其他管道更强大。它以Observable或promise作为输入，并自动订阅它。它还处理Observable的订阅取消，而无需任何进一步的代码。
- en: Let's look at an example of this in our application. Let's go back to the `LeftNavExercises`
    component that we were just looking at in the previous section in connection with
    promises. Note that we have converted this component and the `Exercise` component
    from promises back to using Observables.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的应用程序中看一个例子。让我们回到我们刚在上一节中与promises相关联的`LeftNavExercises`组件。请注意，我们已将此组件和`Exercise`组件从promises转换回使用Observables。
- en: Note
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Check out `checkpoint 5.4` file for an up-to-date implementation that includes
    the conversion of this code to use Observables once again. If you are not using
    Git, download the snapshot of Checkpoint 5.4 (a ZIP file) from the following GitHub
    location: [https://github.com/chandermani/angular2byexample/tree/checkpoint5.4](https://github.com/chandermani/angular2byexample/tree/checkpoint5.4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`检查点5.4`文件，以获取包括将此代码转换回使用Observables的最新实现。如果您没有使用Git，请从以下GitHub位置下载Checkpoint
    5.4的快照（ZIP文件）：[https://github.com/chandermani/angular2byexample/tree/checkpoint5.4](https://github.com/chandermani/angular2byexample/tree/checkpoint5.4)。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: 'Then make the following changes in `LeftNavExercises`. First, change `exerciseList`
    from an array of exercises to an Observable of the same type:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`LeftNavExercises`中进行以下更改。首先，将`exerciseList`从一个练习数组更改为相同类型的Observable：
- en: '[PRE25]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then modify the call to `WorkoutService` to get the exercises to eliminate
    the subscription:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后修改对`WorkoutService`的调用以获取练习，以消除订阅：
- en: '[PRE26]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, open the template files for each of these components and add the `async`
    pipe to the `*ngFor` loop, like so:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开每个组件的模板文件，并在`*ngFor`循环中添加`async`管道，如下所示：
- en: '[PRE27]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Refresh the page and you will still see the Exercise list displaying. But this
    time, we have used the `async` pipe to eliminate the need to set up the subscription
    to the Observable. Pretty cool! This is a nice convenience that Angular has added,
    and since we have been spending time in this chapter understanding how Observables
    work with subscriptions, we have a clear idea of what the `async` pipe is now
    handling for us under the hood.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新页面，您仍然会看到练习列表显示。但是这一次，我们使用了`async`管道来消除设置对Observable的订阅的需要。非常酷！这是Angular添加的一个很好的便利，因为我们在本章中花时间了解了Observables如何与订阅配合工作，现在我们清楚地知道`async`管道现在在幕后为我们处理什么。
- en: We'll leave it to you to implement the same change in the `Exercises` component.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让您在`Exercises`组件中实现相同的更改。
- en: It is important to understand the cross-domain behavior of the HTTP request
    and the constructs that Angular provides to make cross-domain requests.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要了解HTTP请求的跨域行为以及Angular提供的构造来进行跨域请求。
- en: Cross-domain access and Angular
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨域访问和Angular
- en: Cross-domain requests are requests made for resources in a different domain.
    Such requests, when originated from JavaScript, have some restrictions imposed
    by the browser; these are called *same-origin policy* restrictions. Such a restriction
    stops the browser from making AJAX requests to domains that are different from
    the script's original source. The source match is done strictly based on a combination
    of protocol, host, and port.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 跨域请求是对不同域中资源的请求。当从JavaScript发起这样的请求时，浏览器会施加一些限制；这些被称为*同源策略*限制。这种限制阻止浏览器向与脚本原始来源不同的域发出AJAX请求。源匹配严格基于协议、主机和端口的组合。
- en: For our own app, the calls to `https://api.mongolab.com` are cross-domain invocations
    as our source code hosting is in a different domain (most probably, something
    like `http://localhost/....`).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们自己的应用程序，对`https://api.mongolab.com`的调用是跨域调用，因为我们的源代码托管在不同的域中（很可能是类似`http://localhost/....`的东西）。
- en: 'There are some workarounds and some standards that help relax/control cross-domain
    access. We will be exploring two of these techniques as they are the most commonly
    used ones. They are as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些变通方法和一些标准可以帮助放宽/控制跨域访问。我们将探讨其中两种技术，因为它们是最常用的。它们如下：
- en: '**JSON with Padding** (**JSONP**)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带填充的JSON**（**JSONP**）'
- en: '**Cross-Origin Resource Sharing** (**CORS**)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨域资源共享**（**CORS**）'
- en: A common way to circumvent this same-origin policy is to use the JSONP technique.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 绕过同源策略的常见方法是使用JSONP技术。
- en: Using JSONP to make cross-domain requests
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JSONP进行跨域请求
- en: The JSONP mechanism of remote invocation relies on the fact that browsers can
    execute JavaScript files from any domain irrespective of the source of origin
    as long as the script is included via the `<script>` tag.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 远程调用的JSONP机制依赖于浏览器可以执行来自任何域的JavaScript文件，只要脚本是通过`<script>`标签包含的，而与来源无关。
- en: In JSONP, instead of making a direct request to a server, a dynamic `<script>`
    tag is generated, with the `src` attribute set to the server endpoint that needs
    to be invoked. This `<script>` tag, when appended to the browser's DOM, causes
    a request to be made to the target server.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSONP中，不是直接向服务器发出请求，而是生成一个动态的`<script>`标签，其中`src`属性设置为需要调用的服务器端点。当这个`<script>`标签附加到浏览器的DOM时，会导致向目标服务器发出请求。
- en: The server then needs to send a response in a specific format, wrapping the
    response content inside a function invocation code (this extra padding around
    the response data gives this technique the name JSONP).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器然后需要以特定格式发送响应，将响应内容包裹在函数调用代码中（在响应数据周围添加额外填充使得这种技术被称为JSONP）。
- en: The Angular JSONP service hides this complexity and provides an easy API to
    make JSONP requests. The Plunker link, [http://plnkr.co/edit/ZKAUYeOnlIXau27IWG6V?p=preview](http://plnkr.co/edit/ZKAUYeOnlIXau27IWG6V?p=preview),
    highlights how JSONP requests are made. It uses the *Yahoo Stock API* to get quotes
    for any stock symbol.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Angular JSONP服务隐藏了这种复杂性，并提供了一个简单的API来进行JSONP请求。Plunker链接，[http://plnkr.co/edit/ZKAUYeOnlIXau27IWG6V?p=preview](http://plnkr.co/edit/ZKAUYeOnlIXau27IWG6V?p=preview)，突出了JSONP请求的制作方式。它使用*Yahoo
    Stock API*来获取任何股票符号的报价。
- en: Note
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Angular JSONP service only supports HTTP `GET` requests. Using any other
    HTTP request, such as `POST` or `PUT`, will generate an error.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Angular JSONP服务仅支持HTTP `GET`请求。使用任何其他HTTP请求，如`POST`或`PUT`，都会生成错误。
- en: If you look at the Plunker, you will see the familiar pattern for component
    creation that we have followed throughout this book. We will not go over this
    pattern again but will highlight a few details that are relevant to using the
    Angular JSONP service.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下Plunker，你会看到我们在整本书中一直遵循的组件创建的熟悉模式。我们不会再次介绍这个模式，但会强调一些与使用Angular JSONP服务相关的细节。
- en: 'First, along with the standard imports you will need to import the `JsonpModule`
    into `app.module.ts` as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，除了标准导入之外，您还需要将`JsonpModule`导入到`app.module.ts`中，如下所示：
- en: '[PRE28]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Next, we need to add the following imports to `get-quote-component.ts`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将以下导入添加到`get-quote-component.ts`中。
- en: '[PRE29]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We are importing `Jsonp` and `URLSearchParams` from the HttpModule and the
    RxJS Observable as well as `rxjs/Rx`. The latter will bring in the RxJS operators
    that we need for this example:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从HttpModule中导入`Jsonp`和`URLSearchParams`，以及RxJS Observable以及`rxjs/Rx`。后者将引入我们在这个例子中需要的RxJS操作符。
- en: Note
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As you work with Angular JSONP, it is important to understand that by default,
    it returns Observables using RxJS. This means that we will have to follow the
    pattern for subscribing to those Observables and use the RxJS operators to manipulate
    the results. We can also use the async pipe to streamline these operations.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Angular JSONP时，重要的是要理解，默认情况下它返回使用RxJS的Observables。这意味着我们将不得不遵循订阅这些Observables的模式，并使用RxJS操作符来操作结果。我们还可以使用async管道来简化这些操作。
- en: 'The next step is to inject JSONP into the constructor:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将JSONP注入到构造函数中：
- en: '[PRE30]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we have everything in place for our `getQuote` method. Take a look at the
    `getQuote` method in the Plunker. We start by defining several variables that
    we will use to construct our request:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了`getQuote`方法的所有内容。在Plunker中查看`getQuote`方法。我们首先定义几个变量，用于构造我们的请求：
- en: '[PRE31]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We are using the JSONP `get` method to execute the remote call to the Yahoo!
    quote service. In order to set up that method, we first set the URL for the request.
    The URL contains the address of the Yahoo! service as well as a rather lengthy
    query string. The query string contains several required name-value pairs that
    are needed to make a successful call to the Yahoo! service. These include `q`
    for the query to be executed, `format` for the format of the response, and `env`
    for the particular environment we are querying against.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用JSONP的`get`方法来执行对Yahoo！报价服务的远程调用。为了设置该方法，我们首先设置请求的URL。URL包含Yahoo！服务的地址以及一个相当长的查询字符串。查询字符串包含了几个必需的名称-值对，这些对于成功调用Yahoo！服务是必需的。这些包括`q`用于执行的查询，`format`用于响应的格式，以及`env`用于我们正在查询的特定环境。
- en: The Angular JSONP service provides a convenient way for us to create this query
    string. We can construct each parameter individually and then pass them in an
    array to the `get` method. Angular JSONP will then build the query string for
    us out of these parameters.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Angular JSONP服务为我们提供了一种方便的方式来创建这个查询字符串。我们可以逐个构造每个参数，然后将它们传递给`get`方法的数组。然后，Angular
    JSONP将根据这些参数为我们构建查询字符串。
- en: To make a JSONP request, the Angular JSONP service requires us to augment the
    original URL with an extra query string parameter, `callback=JSONP_ CALLBACK`,
    verbatim. Internally, the Angular JSONP service then generates a dynamic `script`
    tag and a function. It then substitutes the `JSONP_CALLBACK` token with the function
    name generated and makes the remote request.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行JSONP请求，Angular JSONP服务要求我们用额外的查询字符串参数`callback=JSONP_ CALLBACK`来扩展原始URL。在内部，Angular
    JSONP服务然后生成一个动态的`script`标签和一个函数。然后，它用生成的函数名替换`JSONP_CALLBACK`标记，并进行远程请求。
- en: 'Open the Plunker and enter symbols such as `GOOG`, `MSFT`, or `YHOO` to see
    the stock quote service in action. The browser network log for requests looks
    like this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Plunker并输入诸如`GOOG`、`MSFT`或`YHOO`之类的符号，以查看股票报价服务的运行情况。请求的浏览器网络日志如下：
- en: '[PRE32]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here, `__ng_jsonp__.__req1` is the dynamically generated function. And the
    response looks like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`__ng_jsonp__.__req1`是动态生成的函数。响应看起来像这样：
- en: '[PRE33]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The response is wrapped in the callback function. Angular parses and evaluates
    this response, which results in the invocation of the `__ng_jsonp__.__req1` callback
    function. Then, this function internally routes the data to our `finished` function
    callback.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 响应被包装在回调函数中。Angular解析和评估这个响应，这导致调用`__ng_jsonp__.__req1`回调函数。然后，这个函数内部将数据路由到我们的`finished`函数回调。
- en: 'We hope this explains how JSONP works and what the underlying mechanism of
    a JSONP request is. However, JSONP has its limitations, as given here:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这解释了JSONP的工作原理以及JSONP请求的基本机制。然而，JSONP也有其局限性，如下所示：
- en: Firstly, we can make only `GET` requests (which is obvious as these requests
    originate due to script tags)
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们只能进行`GET`请求（这是显而易见的，因为这些请求是由脚本标签发起的）
- en: Secondly, the server also needs to implement the part of the solution that involves
    wrapping the response in a function `callback`, as seen before
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，服务器还需要实现涉及将响应包装在一个名为`callback`的函数中的解决方案的部分，就像之前看到的那样
- en: There is always a security risk involved, as JSONP depends on dynamic script
    generation and injection
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是存在安全风险，因为JSONP依赖于动态脚本生成和注入
- en: Error handling too is not reliable because it is not easy to determine why a
    script load failed
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理也不可靠，因为很难确定为什么脚本加载失败
- en: Ultimately, we must recognize that JSONP is more of a workaround than a solution.
    As we moved towards Web 2.0, where mashups became commonplace and more and more
    service providers decided to expose their API over the Web, a far better solution/standard
    emerged: CORS.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们必须认识到JSONP更像是一种变通方法，而不是解决方案。随着我们向Web 2.0迈进，混搭变得司空见惯，越来越多的服务提供商决定通过Web公开他们的API，一个更好的解决方案/标准出现了：CORS。
- en: Cross-origin resource sharing
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨域资源共享
- en: Cross-origin Resource Sharing (CORS) provides a mechanism for the web server
    to support cross-site access control, allowing browsers to make cross-domain requests
    from scripts. With this standard, a consumer application (such as *Personal Trainer*)
    is allowed to make some types of requests, termed **simple requests**, without
    any special setup requirements. These simple requests are limited to `GET`, `POST`
    (with specific MIME types), and `HEAD`. All other types of requests are termed
    **complex requests**.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 跨域资源共享（CORS）提供了一种机制，使Web服务器能够支持跨站点访问控制，允许浏览器从脚本中进行跨域请求。通过这个标准，消费者应用程序（如*个人健身教练*）被允许进行一些类型的请求，称为**简单请求**，而无需任何特殊的设置要求。这些简单请求仅限于`GET`，`POST`（具有特定的MIME类型）和`HEAD`。所有其他类型的请求被称为**复杂请求**。
- en: For complex requests, CORS mandates that the request should be preceded by an
    HTTP `OPTIONS` request (also called a preflight request) that queries the server
    for HTTP methods allowed for cross-domain requests. And only on successful probing
    is the actual request made.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂的请求，CORS要求请求应该在HTTP `OPTIONS`请求（也称为预检请求）之前进行，该请求查询服务器允许跨域请求的HTTP方法。只有在成功探测后才会进行实际请求。
- en: Note
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about CORS from the MDN documentation available at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从MDN文档中了解更多关于CORS的信息，网址为[https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS)。
- en: The best part about CORS is that the client does not have to make any adjustment
    as in the case of JSONP. The complete handshake mechanism is transparent to the
    calling code and our Angular HTTP client calls work without a hitch.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: CORS最好的部分是客户端不需要像JSONP那样进行任何调整。完整的握手机制对调用代码是透明的，我们的Angular HTTP客户端调用可以毫无问题地工作。
- en: CORS requires configurations to be made on the server, and the MongoLab servers
    have already been configured to allow cross-domain requests. So the preceding
    `POST` requests that we made to the MongoLab to add and update `Exercise` and
    `Workout` documents all caused the preflight `OPTIONS` request.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: CORS需要在服务器上进行配置，MongoLab服务器已经配置为允许跨域请求。因此，我们之前向MongoLab发出的`POST`请求来添加和更新`Exercise`和`Workout`文档都引起了预检`OPTIONS`请求。
- en: Handling workouts not found
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理找不到的锻炼
- en: You might recall that in [Chapter 4](part0045.xhtml#1AT9A1-edca168d36254bda8a21f611a95615c3
    "Chapter 4.  Personal Trainer"), *Building Personal Trainer*, we created the `WorkoutGuard`
    to prevent navigation to the `WorkoutComponent` if a non-existent workout was
    in the route parameters. Now we would like to augment this functionality by displaying
    an error message on the workouts screen, indicating that the workout was not found.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得在[第4章](part0045.xhtml#1AT9A1-edca168d36254bda8a21f611a95615c3 "第4章。个人健身教练")
    *构建个人健身教练*中，我们创建了`WorkoutGuard`来防止导航到`WorkoutComponent`，如果路由参数中不存在锻炼。现在我们想通过在锻炼屏幕上显示错误消息来增强这个功能，指示找不到锻炼。
- en: 'In order to do this, we are going to modify `WorkoutGuard` so that it reroutes
    to the workouts screen if a workout is not found. To start, add the following
    child route to `workoutBuilderRoutes` (making sure it precedes the existing workouts
    route):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将修改`WorkoutGuard`，以便在找不到锻炼时重新路由到锻炼屏幕。首先，在`workoutBuilderRoutes`中添加以下子路由（确保它位于现有的锻炼路由之前）：
- en: '[PRE34]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, modify `WorkoutGuard` to redirect to this route in the event that a workout
    is not found:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改`WorkoutGuard`以便在找不到锻炼的情况下重定向到这个路由：
- en: '[PRE35]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then add a `notFound` boolean set to `false` to the variables in the `Workouts`
    component:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`Workouts`组件的变量中添加一个`notFound`布尔值设置为`false`：
- en: '[PRE36]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And, in the `ngOnInit` method of that component, add the following code to
    check for the workout-not-found path and set `notFound` value to `true`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，在该组件的`ngOnInit`方法中，添加以下代码来检查找不到的锻炼路径，并将`notFound`值设置为`true`：
- en: '[PRE37]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Finally in the `Workouts.component.html` template add the following `div` tag
    above the workout list that will display if the `notFound` is set to `true`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`Workouts.component.html`模板中添加以下`div`标签，它将在`notFound`设置为`true`时显示在锻炼列表上方。
- en: '[PRE38]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If we find workout-not-found in the path when a user is returned to the `Workouts`
    page, then this displays the following message on the screen:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在用户返回“锻炼”页面时在路径中找不到锻炼，则屏幕上会显示以下消息：
- en: '![Handling workouts not found](../Images/image00389.jpeg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![处理找不到的锻炼](../Images/image00389.jpeg)'
- en: We have fixed routing failure for the Workout Builder page, but the exercise
    builder page is still pending. Again, we will leave it to you to fix it yourself.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经修复了锻炼构建器页面的路由失败，但是锻炼构建器页面仍然未完成。同样，我们将把它留给你自己来修复。
- en: Another major (and pending) implementation is fixing *7 Minute Workout*, as
    it currently caters to only one workout routine.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个主要的（尚未实施）工作是修复*7分钟锻炼*，因为它目前只适用于一个锻炼例程。
- en: Fixing the 7 Minute Workout app
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复7分钟锻炼应用
- en: As it stands now, the *7 Minute Workout* (or *Workout Runner*) app can play
    only one specific workout. It needs to be fixed to support the execution of any
    workout plan built using *Personal Trainer*. There is an obvious need to integrate
    these two solutions. We already have the groundwork done to commence this integration.
    We've the shared model services and `WorkoutService` to load data, enough to get
    us started.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，*7分钟锻炼*（或*锻炼运行器*）应用程序只能播放一个特定的锻炼。它需要修复以支持使用*个人教练*构建的任何锻炼计划的执行。明显需要将这两个解决方案整合起来。我们已经做好了开始整合的准备工作。我们已经有了共享的模型服务和`WorkoutService`来加载数据，足以让我们开始。
- en: 'Fixing *7 Minute Workout* and converting it into a generic *Workout Runner*
    roughly involves the following steps:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 修复*7分钟锻炼*并将其转换为通用的*锻炼运行器*大致涉及以下步骤：
- en: Removing the hardcoded workout and exercises used in *7 Minute Workout*.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除*7分钟锻炼*中使用的硬编码锻炼和练习。
- en: Fixing the start page to show all available workouts and allowing users to select
    a workout to run.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复起始页面以显示所有可用的锻炼，并允许用户选择要运行的锻炼。
- en: Fixing the workout route configuration to pass the selected workout name as
    the route parameter to the workout page.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复锻炼路由配置，将所选的锻炼名称作为路由参数传递到锻炼页面。
- en: Loading the selected workout data using `WorkoutService` and starting the workout.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`WorkoutService`加载所选的锻炼数据并开始锻炼。
- en: And, of course, we need to rename the *7 Minute Workout* part of the app; the
    name is now a misnomer. I think the complete app can be called *Personal Trainer*.
    We can remove all references to *7 Minute Workout* from the view as well.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，我们需要重命名应用程序的*7分钟锻炼*部分；现在这个名字是错误的。我认为完整的应用程序可以称为*个人教练*。我们也可以从视图中删除所有关于*7分钟锻炼*的引用。
- en: An excellent exercise to try out yourself! And that is why we are not going
    to walk you through the solution. Instead, go ahead and implement the solution.
    Compare your implementation with the one available at `checkpoint 5.4`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的练习，你可以自己尝试！这就是为什么我们不会为你提供解决方案。相反，继续实施解决方案。将你的实现与`检查点5.4`中提供的实现进行比较。
- en: It's time to end the chapter and summarize your learning.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候结束这一章并总结你的学习了。
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We now have an app that can do a lot of stuff. It can run workouts, load workouts,
    save and update them, and track history. And if we look back, we have achieved
    this with minimal code. We bet that if we were to try this in standard jQuery
    or some other framework, it would require substantially more effort as compared
    to Angular.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个可以做很多事情的应用程序。它可以运行锻炼，加载锻炼，保存和更新它们，并跟踪历史记录。如果我们回顾一下，我们用了很少的代码就实现了这一切。我们敢打赌，如果我们尝试在标准的jQuery或其他框架中做这个，相比于Angular，它需要更多的努力。
- en: We started the chapter by providing a *MongoDB* database on *MongoLab* servers.
    Since MongoLab provided a RESTful API to access the database, we saved some time
    by not setting up our own server infrastructure.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在*MongoLab*服务器上提供*MongoDB*数据库来开始这一章。由于MongoLab提供了一个RESTful API来访问数据库，我们节省了一些时间，不需要设置自己的服务器基础设施。
- en: The first Angular construct that we touched upon was the HTTP client, which
    is the primary service for connecting to any HTTP backend.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接触到的第一个Angular构造是HTTP客户端，它是连接到任何HTTP后端的主要服务。
- en: You also learned how the HTTP module uses Observables. For the first time, in
    this chapter, we created our own Observable and explained how to create subscriptions
    to those Observables.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学会了HTTP模块如何使用Observables。在这一章中，我们第一次创建了自己的Observable，并解释了如何订阅这些Observables。
- en: We fixed our *Personal Trainer* app so that it uses the HTTP module to load
    and save workout data. (Note that data persistence for exercises is left for you
    to complete.) In the process, you also learned about issues surrounding cross-domain
    resource access. You learned about JSONP, a workaround to circumvent a browser's
    *same-origin* restrictions, and how to issue JSONP requests using Angular. We
    also touched upon CORS, which has emerged as a standard when it comes to cross-domain
    communication.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修复了我们的*个人健身教练*应用程序，使其使用HTTP模块来加载和保存锻炼数据。（请注意，关于锻炼数据的持久性留给你来完成。）在这个过程中，你还了解了围绕跨域资源访问的问题。你学会了JSONP，这是一个绕过浏览器*同源*限制的解决方法，以及如何使用Angular发出JSONP请求。我们还涉及了CORS，这在跨域通信方面已经成为了一个标准。
- en: 'We have now covered most of the building blocks of Angular, except the big
    one: Angular directives. We have used directives everywhere but have not created
    one. The next chapter is exclusively dedicated to Angular directives. We will
    be creating a number of small directives, such as a remote validator, AJAX button,
    and a validation cues directive for the *Workout Builder* app. You will also learn
    how to integrate a jQuery plugin as a directive in Angular.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了大部分Angular的构建模块，除了一个重要的：Angular指令。我们到处都使用了指令，但还没有创建一个。下一章将专门介绍Angular指令。我们将创建许多小指令，比如远程验证器、AJAX按钮，以及*锻炼构建器*应用程序的验证提示指令。你还将学习如何将jQuery插件集成为Angular指令。
