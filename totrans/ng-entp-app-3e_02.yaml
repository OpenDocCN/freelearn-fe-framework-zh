- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forms, Observables, Signals, and Subjects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll work on a simple weather app, **LocalCast Weather**,
    using Angular and a third-party web API from [OpenWeatherMap.org](https://www.geonames.org/postal-codes).
    The source code for this project is provided on GitHub at [https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app),
    including various stages of development in the `projects` folder.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve never used Angular before and need an introduction to Angular essentials,
    I recommend checking out *What is Angular?* on Angular.dev at [https://angular.dev/overview](https://angular.dev/overview)
    and going through the *Learn Angular Tutorial* at [https://angular.dev/tutorials/learn-angular](https://angular.dev/tutorials/learn-angular).
  prefs: []
  type: TYPE_NORMAL
- en: 'Feeling brave? Just type the following into your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: LocalCast Weather is a simple app that demonstrates the essential elements that
    make up an Angular application, such as components, standalone components, modules,
    providers, pipes, services, RxJS, unit testing, e2e using Cypress, environment
    variables, Angular Material, and **Continuous Integration** and **Continuous Delivery**
    (**CI/CD**) pipelines leveraging CircleCI.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve created a Kanban board for this project on GitHub. You can access it at
    the following link to get more context about the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/users/duluca/projects/1](https://github.com/duluca/local-weather-app).'
  prefs: []
  type: TYPE_NORMAL
- en: A Kanban board is a great way to document your plans for building an app. I
    touch on the importance of building a roadmap and creating information radiators
    for the status of your project in *Chapter 3*, *Architecting an Enterprise App*.
  prefs: []
  type: TYPE_NORMAL
- en: An information radiator is a physical or virtual display that is easily visible
    or accessible, conveying key information about a project or process. It typically
    includes metrics, progress charts, or status indicators and is designed to provide
    at-a-glance awareness without requiring the viewer to seek out information. The
    goal of an information radiator is to promote transparency, facilitate communication
    among team members, and enable stakeholders to get updates without interrupting
    the team’s workflow.
  prefs: []
  type: TYPE_NORMAL
- en: As a bonus, I created a rudimentary wiki page on my repository at [https://github.com/duluca/local-weather-app/wiki](https://github.com/duluca/local-weather-app/wiki).
    Note that you can’t upload images to `README.md` or wiki pages. To get around
    this limitation, you can create a new issue, upload an image in a comment, and
    copy and paste the URL for it to embed images in `README.md` or wiki pages. In
    the sample wiki, I followed this technique to embed the wireframe design into
    the page.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for the sample projects in the book is divided into **stages**
    to capture snapshots of various states of development. In this chapter, we pick
    up the app development from `stage5` and evolve it into `stage6`. In `stage5`,
    the app is polished, but it can only pull weather information for one city, which
    is hardcoded into the app. As a result, it is not a very useful app.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: The LocalCast Weather app as in projects/stage5'
  prefs: []
  type: TYPE_NORMAL
- en: You will inherit an existing project that is not interactive yet. To build an
    interactive app, we need to be able to handle user input. Enabling user input
    in your application opens possibilities for creating great user experiences.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following main topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Great UX should drive implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive forms versus template-driven forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component interaction with observables and RxJS/BehaviorSubject
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing subscriptions and memory leaks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding in the reactive paradigm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining API calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Angular Signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating apps with ChatGPT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the repository linked shortly. The repository contains the final and completed
    state of the code. You can verify your progress at the end of this chapter by
    looking for the end-of-chapter snapshot of code under the `projects` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'For *Chapter 2*:'
  prefs: []
  type: TYPE_NORMAL
- en: Clone the [https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
    repo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `npm install` on the root folder to install dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The beginning state of the project is reflected at:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The end state of the project is reflected at:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the stage name to any `ng` command to act only on that stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `dist/stage6` folder at the root of the repository will contain
    the compiled result.
  prefs: []
  type: TYPE_NORMAL
- en: Beware that the source code provided in the book and the version on GitHub are
    likely to be different. The ecosystem around these projects is ever evolving.
    Between changes to how the Angular CLI generates new code, bug fixes, new versions
    of libraries, and side-by-side implementations of multiple techniques, there’s
    a lot of variation impossible to account for. If you find errors or have questions,
    please create an issue or submit a pull request on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you should be comfortable leveraging observables
    and signals to build apps that provide a great UX. As a bonus, I’ll touch on how
    you can leverage **Generative AI** (**GenAI**) tools like ChatGPT ([https://chat.openai.com/](https://chat.openai.com/))
    to build quick prototypes. But first, let’s get back to UX because no matter how
    much you run, crawl, or scale the city walls, if you nail the UX, your app will
    be loved; but if you miss the mark, your app will be a dime a dozen.
  prefs: []
  type: TYPE_NORMAL
- en: Great UX should drive implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating an easy-to-use and rich **User Experience** (**UX**)should be your
    main goal. You shouldn’t pick a design just because it’s easiest to implement.
    However, often, you’ll find a great UX that is simple to implement in the front
    end of your app but a lot more difficult on the back end. Consider google.com’s
    landing page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a google search  Description automatically generated with
    medium confidence](img/B20960_02_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Google’s landing page'
  prefs: []
  type: TYPE_NORMAL
- en: In this context, Google Search is just a simple input field with two buttons.
    Easy to build, *right?* That simple input field unlocks some of the world’s most
    sophisticated and advanced software technologies backed by a global infrastructure
    of custom-built data centers and **Artificial Intelligence** (**AI**). It is a
    deceptively simple and insanely powerful way to interact with users. You can augment
    user input by leveraging modern web APIs like `GeoLocation` and add critical context
    to derive new meaning from user input. So, when the user types in `Paris`, you
    don’t have to guess whether they mean Paris, France, or Paris, Texas, or whether
    you should show the current temperature in Celsius or Fahrenheit. With `LocalStorage`,
    you can cache user credentials and remember user preferences to enable dark mode
    in your app.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we won’t be implementing an AI-driven super app, but we will enable
    users to search for their cities using a city name or postal code (often called
    *zip codes* in the US). Once you realize how complicated it can get to implement
    something as seemingly simple as a search by postal code, you may gain a new appreciation
    for well-designed web apps.
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish the UX goal, we need to build a UI centered around an input field.
    To do this, we need to leverage Angular forms with validation messages to create
    engaging search experiences with *search-as-you-type* functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, `RxJS`/`BehaviorSubject` or `signals` enables us to build
    decoupled components that can communicate with one another, and a reactive data
    stream allows us to merge data from multiple web APIs without increasing the complexity
    of our app. In addition, you will be introduced to Angular Signals and see how
    it differs from RxJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s see how to implement an input field using forms. Forms are the
    primary mechanism that we need to capture user input. In Angular, there are two
    kinds of forms: **reactive** and **template-driven**. We need to cover both techniques
    so that you’re familiar with how forms work in Angular.'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive versus template-driven forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we’ll implement the search bar on the home screen of the application. The
    next user story states **Display forecast information for current location**,
    which may be taken to imply an inherent GeoLocation functionality. However, as
    you may note, GeoLocation is a separate task. The challenge is that with native
    platform features such as GeoLocation, you are never guaranteed to receive the
    actual location information. This may be due to signal loss issues on mobile devices,
    or the user may simply refuse to give permission to share their location information.
  prefs: []
  type: TYPE_NORMAL
- en: 'First and foremost, we must deliver a good baseline UX and implement value-added
    functionality such as GeoLocation only afterward. In `stage5`, the status of the
    project is represented on the Kanban board, as captured in the following snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a chat  Description automatically generated with medium confidence](img/B20960_02_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: GitHub project Kanban board'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll implement the **Add city search capability** card (which captures a user
    story), as shown in the **In progress** column. As part of this story, we are
    going to implement a search-as-you-type functionality while providing feedback
    to the user if the service is unable to retrieve the expected data.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, it may be intuitive to implement a type-search mechanism; however,
    `OpenWeatherMap` APIs don’t provide such an endpoint. Instead, they provide bulk
    data downloads, which are costly and are in the multiples-of-megabytes range.
  prefs: []
  type: TYPE_NORMAL
- en: We will need to implement our application server to expose such an endpoint
    so that our app can effectively query while using minimal data.
  prefs: []
  type: TYPE_NORMAL
- en: The free endpoints for `OpenWeatherMap` do pose an interesting challenge, where
    a two-digit country code may accompany either a city name or zip code for the
    most accurate results. This is an excellent opportunity to implement a feedback
    mechanism for the user if more than one result is returned for a given query.
  prefs: []
  type: TYPE_NORMAL
- en: We want every iteration of the app to be a potentially releasable increment
    and avoid doing too much at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you begin working on a story, it is a good idea to break it into technical
    tasks. The following is the task breakdown for this story:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an Angular form control so that we can capture user input events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use an Angular Material input as documented at [https://material.angular.io/components/input](https://material.angular.io/components/input)
    to improve the UX of the input field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the search bar as a separate component to enforce the separation of concerns
    and a decoupled component architecture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend the existing endpoint to accept a zip code and make the country code
    optional in `weather.service.ts` to make it more intuitive for end users to interact
    with our app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Throttle requests so that we don’t query the API with every keystroke but at
    an interval where users still get immediate feedback without clicking a separate
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s tackle these tasks over the following few sections.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Angular reactive forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may wonder why we’re adding Angular forms since we’ve got just a single
    input field, not a form with multiple inputs. As a general rule of thumb, any
    time you add an input field, it should be wrapped in a `<form>` tag. The `Forms`
    module contains `FormControl` that enables you to write the backing code behind
    the input field to respond to user inputs and provide the appropriate data or
    the validation or message in response.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of forms in Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Template-driven forms**: These forms are like what you may be familiar with
    in the case of AngularJS, where the form logic is mainly inside the HTML template.
    I’m not a fan of this approach because it is harder to test these behaviors, and
    fat HTML templates become challenging to maintain quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reactive forms**: The behavior of reactive forms is driven by TypeScript
    code in the controller. This means that your validation logic can be unit tested
    and, better yet, reused across your application. Reactive forms are the core technology
    that, in the future, will enable the Angular Material team to write automated
    tools that can autogenerate an input form based on a TypeScript interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read more about reactive forms at [https://angular.dev/guide/forms/reactive-forms](https://angular.dev/guide/forms/reactive-forms).
  prefs: []
  type: TYPE_NORMAL
- en: In Angular, dependencies are encapsulated in modules provided by the framework.
    User-created modules are no longer mandatory, and our code sample is configured
    as a standalone app. For the component we define in the next section, you must
    import `FormsModule` and `ReactiveFormsModule` to be able to use these features
    in your template.
  prefs: []
  type: TYPE_NORMAL
- en: In a pure reactive form implementation, you only need `ReactiveFormsModule`.
    Note that `FormsModule` supports template-driven forms and other scenarios where
    you may only want to declare `FormControl` without `FormGroup`. This is how we
    implement the input field for this app. `FormGroup` is defined in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Note that reactive forms allow you to code in the reactive paradigm, which is
    a net positive when using observables. Next, let’s add a city search component
    to our app.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and verifying components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be creating a `citySearch` component using Angular Material form and
    input modules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the new `citySearch` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the form dependencies from the previous section and Material dependencies,
    `MatFormFieldModule` and `MatInputModule`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’re adding `MatFormFieldModule` because each input field should be wrapped
    in a `<mat-form-field>` tag to get the most out of the Angular Material functionality.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At a high level, `<form>` encapsulates numerous default behaviors for keyboard,
    screen-reader, and browser extension users; `<mat-form-field>` enables easy two-way
    data binding, a technique that should be used in moderation, and also allows graceful
    label, validation, and error message displays.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a basic template, replacing the existing content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a property named `search` and instantiate it as an instance of `FormControl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reactive forms have three levels of control:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`FormControl` is the most basic element with a one-to-one relationship with
    an input field.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormArray` represents repetitive input fields that represent a collection
    of objects.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormGroup` registers individual `FormControl` or `FormArray` objects as you
    add more input fields to a form.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `FormBuilder` object is used to orchestrate and maintain the actions
    of a `FormGroup` object more easily. `FormBuilder` and `FormGroup` are first used
    in *Chapter 6*, *Implementing Role-Based Navigation*, and all controls, including
    `FormArray`, are covered in depth in *Chapter 8*, *Recipes – Reusability, Forms,
    and Caching*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `app.component.ts`, import `CitySearchComponent`, then add `<app-city-search>`
    as a new `div` in between the row that contains the tagline of the app and the
    row that contains `mat-card`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Launch your app from your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Test the integration of components by checking out the app in the browser, as
    shown:![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B20960_02_04.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2.4: The LocalCast Weather app with a search field'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If no errors occur, we can start adding the `FormControl` elements and wire
    them up to a search endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a search option to the weather service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have been passing parameters to get the weather for a city using
    its name and country code. By allowing users to enter zip codes, we must make
    our service more flexible in accepting both types of inputs.
  prefs: []
  type: TYPE_NORMAL
- en: OpenWeatherMap’s API accepts URI parameters, so we can refactor the existing
    `getCurrentWeather` function using a TypeScript **union type** and a **type guard**.
  prefs: []
  type: TYPE_NORMAL
- en: 'That means we can supply different parameters while preserving type checking:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Refactor the `getCurrentWeather` function in `weather.service.ts` to handle
    both `zip` and `city` inputs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We renamed the `city` parameter to `search` since it can be a city name or a
    zip code. We then allowed its type to be either a `string` or a `number`, and
    depending on what the type is at runtime, we will either use `q` or `zip`. We
    also made `country` optional and only append it to the query if it exists.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getCurrentWeather` now has business logic embedded into it and is thus a good
    target for unit testing. Following the single responsibility principle from the
    SOLID principles, we will refactor the HTTP call to its own function, `getCurrentWeatherHelper`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you’re unfamiliar with SOLID principles, I cover them in the Agile engineering
    best practices section of *Chapter 3, Architecting an Enterprise App*. If you
    want to read more about it now, see the Wikipedia entry here: [https://en.wikipedia.org/wiki/SOLID](https://en.wikipedia.org/wiki/SOLID).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Refactor the HTTP call into `getCurrentWeatherHelper`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the next sample, note the use of a backtick character, `` ` ``, instead
    of a single-quote character, `''`, which leverages the template literals’ functionality
    that allows embedded expressions in JavaScript:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As a positive side effect, `getCurrentWeatherHelper` adheres to the open/closed
    principle from SOLID. After all, it is open to extension by our ability to change
    the function’s behavior by supplying different `uriParams` and is closed to modification
    because it won’t have to be changed frequently.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To demonstrate the latter point, let’s implement a new function to get the current
    weather by latitude and longitude.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement `getCurrentWeatherByCoords`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the functionality of `getCurrentWeatherHelper` is extensible
    without modifying its code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Ensure that you update `IWeatherService` with the changes made earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As a result of adhering to the SOLID design principles, we make it easier to
    robustly unit test flow-control logic and ultimately write code that is more resilient
    to bugs and cheaper to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s connect the new service method to the input field:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `citySearch` to inject `weatherService` and subscribe to input changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are treating all input as `string` at this point. The user input can be a
    city and zip code, city and country code, or a zip code and country code, separated
    by a comma. While a city or zip code is required, a country code is optional.
    We can use the `String.split` function to parse any potential comma-separated
    input and then trim any whitespace out from the beginning and the end of the string
    with `String.trim`. We then ensure that we trim all parts of the string by iterating
    over them with `Array.map`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We then deal with the optional parameter with the ternary operator `?:`, only
    passing in a value if it exists, otherwise leaving it undefined.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the search handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a hint for the user under the input field, informing them about the optional
    country functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, the subscribe handler will call the server and log its output
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Observe how this works using Chrome DevTools. Note how often the `search` function
    is run and that we are not handling service errors.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting user inputs with throttle/debounce
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We currently submit a request to the server with every keystroke. This is not
    desirable behavior because it can lead to a bad user experience and drain battery
    life, resulting in wasted network requests and performance issues both on the
    client and server side. Users make typos; they can change their minds about what
    they are inputting, and rarely do the first few characters of information input
    result in useful results.
  prefs: []
  type: TYPE_NORMAL
- en: We can still listen to every keystroke, but we don’t have to react to every
    stroke. By leveraging `throttle`/`debounce`, we can limit the number of events
    generated to a predetermined interval and maintain the type-as-you-search functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `throttle` and `debounce` are not functional equivalents, and their
    behavior will differ from framework to framework. In addition to throttling, we
    expect to capture the last input that the user has typed. In the `lodash` framework,
    the `throttle` function fulfills this requirement, whereas, in `RxJS`, `debounce`
    fulfills it.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is easy to inject throttling into the observable stream using `RxJS/debounceTime`.
    Implement `debounceTime` with `pipe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`debounceTime` will, at a maximum, run a search every second, but also run
    another search after the user has stopped typing. In comparison, `RxJS/throttleTime`
    will only run a search every second, on the second, and will not necessarily capture
    the last few characters the user may have input.'
  prefs: []
  type: TYPE_NORMAL
- en: RxJS also has the `throttle` and `debounce` functions, which you can use to
    implement custom logic to limit input that is not necessarily time-based.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is a time- and event-driven functionality, breakpoint debugging is
    not feasible. You may monitor the network calls within the **Chrome Dev Tools
    | Network** tab, but to get a more real-time feel for how often your search handler
    is being invoked, add a `console.log` statement.
  prefs: []
  type: TYPE_NORMAL
- en: It is not a good practice to check in code with active `console.log` statements.
    These debug statements make it difficult to read the actual code, which creates
    a high cost of maintainability. Even if debug statements are commented out, do
    not check them.
  prefs: []
  type: TYPE_NORMAL
- en: Input validation and error messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`FormControl` is highly customizable. It allows you to set a default initial
    value, add validators, or listen to changes on `blur`, `change`, and `submit`
    events, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We won’t be initializing `FormControl` with a value, but we need to implement
    a validator to disallow single-character inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `Validators` from `@angular/forms`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify `FormControl` to add a minimum length validator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the template to show a validation error message below the hint text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the addition of some extra margin to make room for lengthy error messages.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you are handling different kinds of errors, the `hasError` syntax in the
    template can get repetitive. You may want to implement a more scalable solution
    that can be customized through code, as shown:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `search` function to not execute a search with invalid input, replacing
    the condition in the existing `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Instead of doing a simple check to see whether `searchValue` is defined and
    not an empty string, we can tap into the validation engine for a more robust check
    by calling `this.search.invalid`.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we’re done with implementing `search` functionality. Next, let’s go
    over a what-if scenario to see how a template-driven form implementation would
    appear.
  prefs: []
  type: TYPE_NORMAL
- en: Template-driven forms with two-way binding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The alternative to reactive forms is template-driven forms. If you’re familiar
    with `ng-model` from AngularJS, you’ll find that the new `ngModel` directive is
    an API-compatible replacement for it.
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, `ngModel` implements `FormControl` that automatically attaches
    itself to `FormGroup`. `ngModel` can be used at the `<form>` level or the individual
    `<input>` level. You can read more about `ngModel` at [https://angular.dev/api/forms/NgModel](https://angular.dev/api/forms/NgModel).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `stage6` example code of the LocalCast Weather app repository on GitHub,
    I have included a template-driven component in `app.component.ts` named `<app-city-search-tpldriven>`
    rendered under `<div class="example">`. You can experiment with this component
    to see what the alternate template implementation looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note the `[()]` “box of bananas” two-way binding syntax in use with `ngModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The differences in the components are implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, most of the logic is implemented in the template; as such, you
    are required to maintain an active mental model of the template and the controller.
    Any changes to event handlers and validation logic require you to switch back
    and forth between the two files.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we have lost input limiting and the ability to prevent service
    calls when the input is invalid. It is still possible to implement these features,
    but they require convoluted solutions and do not neatly fit into the new Angular
    syntax and concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, I do not recommend the use of template-driven forms. There may be a
    few instances where it may be very convenient to use the box-of-bananas syntax.
    However, this sets a bad precedent for other team members to replicate the same
    pattern around the application.
  prefs: []
  type: TYPE_NORMAL
- en: Component interaction with BehaviorSubject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To update the current weather information, we need the `citySearch` component
    to interact with the `currentWeather` component. There are four main techniques
    to enable component interaction in Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: Global events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parent components listening for information bubbling up from children components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sibling, parent, or children components within a module that works off of similar
    data streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parent components passing information to children components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s explore them in detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Global events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This technique has been leveraged since the early days of programming in general.
    In JavaScript, you may have achieved this with global function delegates or jQuery’s
    event system. In AngularJS, you may have created a service and stored variables
    within it.
  prefs: []
  type: TYPE_NORMAL
- en: In Angular, you can still create a root-level service, store values in it, use
    Angular’s `EventEmitter` class, which is meant for directives, or use `RxJS/Subscription`
    to create a fancy messaging bus for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: As a pattern, global events are open to rampant abuse, and rather than helping
    to maintain a decoupled application architecture, they lead to a global state
    over time. A global state or a localized state at the controller level, where
    functions read and write to variables in any given class, is enemy number one
    of writing maintainable and unit-testable software.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, if you’re storing all your application data or routing all events
    in one service to enable component interaction, you’re merely inventing a better
    mousetrap. A single service will grow large and complex over time. This leads
    to unforeseen bugs, side effects from unintentional mutations of unrelated data,
    continuously increasing memory usage because data from previous views can’t be
    discarded, and low cohesion due to data stored from unrelated components of the
    application. Overusing a service is an anti-pattern that should be avoided at
    all costs. In a later section, you will find that, essentially, we will still
    be using services to enable component interaction; however, I want to point out
    that there’s a fine line that exists between a flexible architecture that enables
    decoupling and the global or centralized decoupling approach that does not scale
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Child-parent relationships with event emitters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your child component should be completely unaware of its parent. This is key
    to creating reusable components.
  prefs: []
  type: TYPE_NORMAL
- en: We can implement the communication between `CitySearchComponent` and the `CurrentWeatherComponent`,
    leveraging `AppComponent` as a parent element and letting the `AppComponent` controller
    orchestrate the data.
  prefs: []
  type: TYPE_NORMAL
- en: '*Commit your code now!* In the next two sections, you will be making code changes
    that you will need to discard.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this implementation will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CitySearchComponent` exposes `EventEmitter` through an `@Output` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`AppComponent` consumes that and calls `weatherService`, setting the `currentWeather`
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we are binding to `searchEvent` with the parenthesis syntax. The `$event`
    variable automatically captures the output from the event and passes it into the
    `doSearch` method.
  prefs: []
  type: TYPE_NORMAL
- en: We successfully bubbled the information up to the parent component, but we must
    also be able to pass it down to `CurrentWeatherComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Parent-child relationships with input binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By definition, the parent component will know what child components it is working
    with. Since the `currentWeather` property is bound to the `current` property on
    `CurrentWeatherComponent`, the results are passed down for display. This is achieved
    by creating an `@Input` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `ngOnInit` function of `CurrentWeatherComponent` is now superfluous
    and can be removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then update `AppComponent` to bind the data to the current weather:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: At this point, your code should work! Try searching for a city. If `CurrentWeatherComponent`
    updates, then success!
  prefs: []
  type: TYPE_NORMAL
- en: 'The event emitter to input binding approach is appropriate in cases where you
    are creating well-coupled components or user controls, and the child is not consuming
    any external data. A good demonstrator for this might be by adding forecast information
    to `CurrentWeatherComponent` as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, screenshot, font, line  Description automatically
    generated](img/B20960_02_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Weather forecast wireframe'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each day of the week can be implemented as a component that is repeated using
    `@for`, and it will be perfectly reasonable for `CurrentWeatherComponent` to retrieve
    and bind this information to its child component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In general, if you’re working with data-driven components, the parent-child
    or child-parent communication pattern results in an inflexible architecture, making
    it difficult to reuse or rearrange your components. A good example of tight coupling
    is when we imported `WeatherService` in `app.component.ts`. Note that `AppComponent`
    should have no idea about `WeatherService`; its only job is to lay out several
    components. Given ever-changing business requirements and design, this is an important
    lesson to remember.
  prefs: []
  type: TYPE_NORMAL
- en: '*Discard changes from the two sections* before moving on. We will instead be
    implementing an alternate solution.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we cover a better way for two components to interact with each other without
    introducing additional coupling with subjects.
  prefs: []
  type: TYPE_NORMAL
- en: Sibling interactions with subjects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main reason for components to interact is to send or receive updates to
    data either provided by the user or received from the server. In Angular, your
    services expose `RxJS/Observable` endpoints, which are data streams that your
    components can subscribe to. `RxJS/Observer` complements `RxJS/Observable` as
    a consumer of events emitted by `Observable`. `RxJS/Subject` brings the two functionalities
    together in an easy-to-work-with package.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can essentially describe a stream that belongs to a particular set of data,
    such as the current weather data that is being displayed, with subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`currentWeather$` is still a data stream and does not simply represent one
    data point. You can subscribe to changes to `currentWeather$` data using `subscribe`,
    or you can publish changes to it using `next` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note the naming convention for the `currentWeather$` property, which is postfixed
    with `$`. This is the naming convention for observable properties.
  prefs: []
  type: TYPE_NORMAL
- en: The default behavior of `Subject` is very much like generic pub/sub mechanisms,
    such as jQuery events. However, in an asynchronous world where components are
    loaded or unloaded in unpredictable ways, using the default `Subject` is not very
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three advanced variants of subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ReplaySubject` remembers and caches data points that occurred within the data
    stream so that a subscriber can replay old events at any given time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BehaviorSubject` remembers only the last data point while listening for new
    data points.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsyncSubject` is for one-time-only events that are not expected to reoccur.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReplaySubject` can have severe memory and performance implications on your
    application, so it should be used carefully. In the case of `CurrentWeatherComponent`,
    we are only interested in displaying the latest weather data received, but through
    user input or other events, we are open to receiving new data to keep `CurrentWeatherComponent`
    up to date. `BehaviorSubject` would be the appropriate mechanism to meet these
    needs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `currentWeather$` as a read-only property to `IWeatherService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`currentWeather$` is declared as read-only because its `BehaviorSubject` should
    not be reassigned. It’s our data anchor or a reference, not a copy of the data
    itself. Any updates to the value should be sent by calling the `next` function
    on the property.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define `BehaviorSubject` in `WeatherService` and set a default value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new function named `updateCurrentWeather`, which will trigger `getCurrentWeather`
    and update the value of `currentWeather$`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `IWeatherService` with the new function so that it appears as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `CurrentWeatherComponent` to subscribe to the new `BehaviorSubject`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `CitySearchComponent`, update the `getCurrentWeather` function call to utilize
    the new `updateCurrentWeather` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Test your app in the browser; it should appear as follows:![A screenshot of
    a weather forecast  Description automatically generated with medium confidence](img/B20960_02_06.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2.6: Weather information for Bursa, Turkey'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When you type in a new city, the component should update to include the current
    weather information for that city. We can move the **Add city search capability...**
    task to the **Done** column, as shown on our Kanban board:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B20960_02_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: GitHub project Kanban board status'
  prefs: []
  type: TYPE_NORMAL
- en: We have a functional app. However, we have introduced a memory leak in the way
    we handled the subscription to `currentWeather$`. In the next section, we’ll review
    how memory leaks can happen and avoid them altogether by using `first` and `takeUntilDestroyed`
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Managing subscriptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Subscriptions are a convenient way to read a value from a data stream for your
    application logic. If unmanaged, they can create memory leaks in your application.
    A leaky application will consume ever-increasing amounts of RAM, eventually leading
    the browser tab to become unresponsive, leading to a negative perception of your
    app and, even worse, potential data loss, which can frustrate end users.
  prefs: []
  type: TYPE_NORMAL
- en: The source of a memory leak may not be obvious. In `CurrentWeatherComponent`,
    we inject `WeatherSevice` to access the value of `BehaviorSubject`, `currentWeather$`.
    If we mismanage subscriptions,`currentWeather$`, we can end up with leaks in the
    component or the service.
  prefs: []
  type: TYPE_NORMAL
- en: Lifecycle of services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, Angular services are **shared instance services** or singletons
    automatically registered to a **root provider**. This means that, once created
    in memory, they’re kept alive as long as the app or feature module they’re a part
    of remains in memory. See the following example of a shared instance service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: From a practical perspective, this will mean that most services in your application
    will live in the memory for the application’s lifetime. However, the lifetime
    of a component may be much shorter, or there could be multiple instances of the
    same component created repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, there are use cases where a component needs its own instance
    or a copy of the service (e.g., caching values input into a form or displaying
    weather for different cities simultaneously). To create **multiple instance services,**
    see the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You would then provide the service with a **component provider**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the service would be destroyed when the component is destroyed.
    But this is not protection against memory leaks. If we don’t manage the interactions
    between long-lived and short-lived objects carefully, we can end up with dangling
    references between objects, leading to memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Exposé of a memory leak
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we subscribe to `currentWeather$`, we attach an event handler to it so
    that `CurrentWeatherComponent` can react to value changes pushed to `BehaviorSubject`.
    This presents a problem when the component needs to be destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: In managed languages such as JavaScript, memory is managed by the garbage collector,
    or GC for short, as opposed to having to allocate and deallocate memory by hand
    in unmanaged languages such as C or C++. At a very high level, the GC periodically
    scans the stack for objects not referenced by other objects.
  prefs: []
  type: TYPE_NORMAL
- en: If an object is found to be dereferenced, then the space it takes up in the
    stack can be freed up. However, if an unused object still has a reference to another
    object that is still in use, it can’t be garbage collected. The GC is not magical
    and can’t read our minds. When an object is unused and can’t be deallocated, the
    memory taken up by the object can never be used for another purpose so long as
    your application is running. This is considered a memory leak.
  prefs: []
  type: TYPE_NORMAL
- en: 'My colleague, Brendon Caulkins, provides a helpful analogy:'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine the memory space of the browser as a parking lot; every time we assign
    a value or create a subscription, we park a car in that lot. If we happen to abandon
    a car, we still leave the parking spot occupied; no one else can use it. If all
    the applications in the browser do this, or we do it repeatedly, you can imagine
    how quickly the parking lot gets full, and we never get to run our application.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, let’s see how we can ensure we don’t abandon our car in the parking lot.
  prefs: []
  type: TYPE_NORMAL
- en: Unsubscribing from a subscription
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Subscriptions or event handlers create references to other objects, such as
    from a short-lived component to a long-lived service. Granted, in our case, `CurrentWeatherComponent`
    is also a singleton, but that could change if we added more features to the app,
    navigating from page to page or displaying weather from multiple cities at once.
    If we don’t unsubscribe from `currentWeather$`, then any instance of `CurrentWeatherComponent`
    would be stuck in memory. We subscribe in `ngOnInit`, so we must unsubscribe in
    `ngOnDestroy`. `ngOnDestroy` is called when Angular determines that the framework
    no longer uses the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of how you can unsubscribe from a subscription in the
    sample code in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to implement the `OnDestroy` interface for the component. Then,
    we update `ngOnInit` to store a reference to the subscription in a property named
    `currentWeatherSubscription`. Finally, in `ngOnDestroy`, we can call the `unsubscribe`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Should our component get destroyed, it will no longer result in a memory leak.
    However, if we have multiple subscriptions in a component, this leads to tedious
    amounts of coding.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in `CitySearchComponent`, we subscribe to the `valueChanges` event
    of a `FormControl` object. We don’t need to manage the subscription to this event
    because `FormControl` is a child object of our component. When the parent component
    is dereferenced from all objects, all its children can be safely collected by
    the GC.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to values in data streams itself can be considered an anti-pattern
    because you switch your programming model from reactive to imperative. But of
    course, we must subscribe at least once to activate the data stream. In the next
    section, we will cover how you ensure you don’t leak memory when subscribing.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribe with first or takeUntilDestroyed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, an observable stream doesn’t end. Given how engrained RxJS is within
    every Angular operation, this is rarely the desired outcome. There are two common
    strategies that we can apply at the time of subscribing to a resource so we can
    ensure that streams will complete predictably and won’t lead to memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first strategy is, well, the first method. Observe the `updateCurrentWeather`
    method in `WeatherService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, we intend to get the current weather and display it –
    and do this only once per request. By piping in a `first()` call into the observable
    stream, we instruct RxJS to complete the stream after it receives one result.
    This way, when a resource that utilizes this stream is being GC’d, the relevant
    RxJS objects will not cause a leak.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second strategy is `takeUntilDestroyed`. The `first()` strategy doesn’t
    make sense with components that will update multiple times, that will update multiple
    times. For example `CurrentWeatherComponent` can update after the user enters
    new search text, so we want to receive updates as long as the component exists.
    See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`takeUntilDestroyed` can only be used within an injector context, i.e., a constructor.
    When using it in lifecycle hook calls, like `ngOnInit`, we must inject `DestroyRef`
    and pass it into the function. It automatically registers itself, so when the
    component is destroyed, it completes the stream. This way, the component can receive
    messages while it’s needed, but with no risk of leaking memory.'
  prefs: []
  type: TYPE_NORMAL
- en: By applying these alongside the `subscribe` method, we don’t have to rely on
    difficult-to-trace unsubscribe methods, and we can easily verify their implementation
    with a quick search of the word subscribe.
  prefs: []
  type: TYPE_NORMAL
- en: The best part is no part at all. Next, let’s see how we can consume an observable
    component without subscribing to it all.
  prefs: []
  type: TYPE_NORMAL
- en: Coding in the reactive paradigm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As covered in *Chapter 1*, *Angular’s Architecture and Concepts*, we should
    only subscribe to an observable stream to activate it. If we treat a `subscribe`
    function as an event handler, we implement our code imperatively.
  prefs: []
  type: TYPE_NORMAL
- en: Seeing anything other than an empty `subscribe()` call in your code base should
    be considered a red flag because it deviates from the reactive paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: In reactive programming, when you subscribe to an event in a reactive stream,
    you shift your coding paradigm from reactive programming to imperative programming.
    There are two places in our application where we subscribe, one in `CurrentWeatherComponent`,
    and the other in `CitySearchComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by fixing `CurrentWeatherComponent` so we don’t mix paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: Binding to an observable with an async pipe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular has been designed to be an asynchronous framework from the ground up.
    You can get the most out of Angular by staying in the reactive paradigm. It can
    feel unnatural to do so at first, but Angular provides all the tools you need
    to reflect the current state of your application to the user without having to
    shift to imperative programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may leverage the `async` pipe in your templates to reflect the current
    value of an observable. Let’s update `CurrentWeatherComponent` to use the `async`
    pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by replacing `current: ICurrentWeather` with an observable property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the constructor, assign `weatherService.currentWeather$` to `current$:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remove all code related to `SubSink`, `ngOnInit`, and `ngOnDestroy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the template to so you can bind to `current$`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `async` pipe automatically subscribes to the current value of `current$`
    and makes it available to the template to be used imperatively as the `current`
    variable. The beauty of this approach is that the `async` pipe implicitly manages
    the subscription, so you don’t have to worry about unsubscribing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Remove the `@else { <div>no data</div> }` block, which is no longer needed because
    `BehaviorSubject` is always initialized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So far, the reactive paradigm has allowed us to streamline and clean up our
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The async pipe allows you to display a loading message with simple `if-else`
    logic. To display a message while your observable is resolved, see the following
    technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s further improve our code.
  prefs: []
  type: TYPE_NORMAL
- en: Tapping into an observable stream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `CitySearchComponent` implements a callback within a `subscribe` statement
    when firing the `search` function. This leads to an imperative style of coding
    and mindset. The danger with switching programming paradigms is that you can introduce
    unintentional side effects to your code base by making it easier to store state
    or create bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s refactor `CitySearchComponent` to be in the reactive functional programming
    style, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we removed the `OnInit` implementation and implemented
    our filtering logic reactively. The `tap` operator will only get triggered if
    `this.search` is valid.
  prefs: []
  type: TYPE_NORMAL
- en: '`constructor` should only be used when working with properties and events local
    to the class context. In this case, search is initialized when defined, and `valueChanges`
    can only be triggered by a user interacting with the component. So, it’s okay
    to set up the subscribe logic in it.'
  prefs: []
  type: TYPE_NORMAL
- en: However, if you’re referencing any properties within the template, `@Input`
    variables, or registering an external service call, you must use `ngOnInit`. Otherwise,
    you will run into render errors or unpredictable behavior. This is because template
    properties, including `@Input` variables, won’t be accessible until `ngOnInit`
    is called. Further, external service calls may return a response before the component
    is initialized, leading to change detection errors.
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, 99% of the time you should use `ngOnInit`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, `doSearch` is called in a functional context, making it very difficult
    to reference any other class property within the function. This reduces the chances
    of the state of the class impacting the outcome of our function. As a result,
    `doSearch` is a composable and unit-testable function, whereas in the previous
    implementation, it would have been very challenging to unit test `ngOnInit` in
    a straightforward manner.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `subscribe()` must be called on `valueChanges` to activate the observable
    data stream. Otherwise, no event will fire.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that we didn’t need to implement `ngOnInit` reflects the truly asynchronous
    nature of our code, which is independent of the lifecycle or state of the application.
    However, you should stick with `ngOnInit` as a general best practice.
  prefs: []
  type: TYPE_NORMAL
- en: With our refactoring complete, the app should function the same as before but
    with less boilerplate code. Now, let’s look into enhancing our app to handle postal
    codes from any country.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining API calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, our app can only handle 5-digit numerical postal or zip codes from
    the US. A postal code such as `22201` is easy to differentiate from a city name
    with a simplistic conditional such as `typeof search === 'string'`. However, postal
    codes can vary widely from country to country, the UK being a great example, with
    postal codes such as `EC2R 6AB`. Even if we had a perfect understanding of how
    postal codes are formatted for every country, we still couldn’t ensure that the
    user didn’t fat-finger a slightly incorrect postal code. Today’s sophisticated
    users expect web applications to be resilient toward such mistakes. However, as
    web developers, we can’t be expected to code up a universal postal code validation
    service by hand. Instead, we need to leverage an external service before we send
    our request to OpenWeatherMap APIs. Let’s explore how we can chain back-to-back
    API calls that rely on each other.
  prefs: []
  type: TYPE_NORMAL
- en: After the first edition of this book was published, I received some passionate
    reader feedback on their disappointment that the sample app could only support
    US zip codes. I’ve implemented this feature because it demonstrates how simple
    requests can introduce unplanned complexity to your apps. As a bonus, the app
    now works worldwide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a new item, **Support international zip codes**, to the backlog and
    move it to **In progress**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a chat  Description automatically generated with medium confidence](img/B20960_02_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Adding an international zip codes story'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a postal code service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To properly understand whether the user inputs a valid postal code versus the
    name of a city, we must rely on a third-party API call provided by [geonames.org](http://geonames.org).
    Let’s see how we can inject a secondary API call into the search logic of our
    app.
  prefs: []
  type: TYPE_NORMAL
- en: You need to sign up for a free account on [geonames.org](http://geonames.org).
    Afterward, store username as a new parameter in `environment.ts` and `environment.prod.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: You may experiment with the postal code API interactively at [https://www.geonames.org/postal-codes](https://www.geonames.org/postal-codes).
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to implement a service that adheres to the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Declaring an interface for your service is a useful practice when you’re initially
    designing your app. You and your team members can focus on providing the right
    interaction model without being bogged down by implementation details. Once your
    interface is defined, you can quickly stub out functionality and have a walking
    skeleton version of your app in place. Stubbed-out functions help validate design
    choices and encourage early integration between components. Once in place, team
    members will no longer need to guess whether they are coding in the right spot.
    You should always export your interface, so you can use the type information for
    writing unit tests, creating test doubles or fakes.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces are key to practicing **Test-Driven Development** (**TDD**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now implement `PostalCodeService` as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: You may generate the service by executing `npx ng generate service postalCode
    --project=local-weather-app --no-flat`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note the new environment variable, `environment.geonamesApi`. In `environment.ts`,
    set this value to `api` and, in `environment.prod.ts`, to `secure`, so calls over
    HTTPS work correctly to avoid the mixed-content error, as covered in *Chapter
    10*, *Releasing to Production Using CI/CD*.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code segment, we implement a `resolvePostalCode` function that
    calls an API, which is configured to receive the first viable result the API returns.
    The results are then flattened and piped out to the subscriber. With `defaultIfEmpty`,
    we ensure that a null value will be provided if we don’t receive a result from
    the API. If the call is successful, we will get back all the information defined
    in `IpostalCode`, making it possible to leverage `getCurrentWeatherByCoords` using
    coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Observable sequencing with switchMap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s update the weather service so that it can call the `postalCode` service
    to determine whether the user input was a valid postal code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by updating the interface so we only deal with a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inject `PostalCodeService` to the weather service as a private property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Update the method signature for `updateCurrentWeather`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update `getCurrentWeather` to try and resolve `searchText` as a postal code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you run into TypeScript issues when passing the latitude and longitude into
    `getCurrentWeatherByCoords`, you may have to cast the object using the `as` operator.
    So, your code would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code segment, our first call is to the `postalCode` service.
    We then react to postal codes posted on the data stream using `switchMap`. Inside
    `switchMap`, we can observe whether `postalCode` is null and make the appropriate
    follow-up call to either get the current weather by coordinates or by city name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, LocalCast Weather should work with global postal codes, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a weather forecast  Description automatically generated with
    medium confidence](img/B20960_02_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: LocalCast Weather with global postal codes'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are done with implementing international zip code support. Move it to the
    **Done** column on your Kanban board:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B20960_02_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: International zip code support done'
  prefs: []
  type: TYPE_NORMAL
- en: As we complete our implementation of LocalCast Weather, there’s still room for
    improvement. Initially, the app looks broken when it first loads because of the
    dashes and empty fields shown. There are at least two different ways to handle
    this. The first is to hide the entire component at the `AppComponent` level if
    there’s no data to display. For this to work, we must inject `WeatherService`
    into `AppComponent`, ultimately leading to a less flexible solution. Another way
    is to enhance `CurrentWeatherComponent` so that it is better able to handle missing
    data.
  prefs: []
  type: TYPE_NORMAL
- en: You improve the app further by implementing geolocation to get the weather for
    the user’s current location upon launching the app. You can also leverage `window.localStorage`
    to store the city that was last displayed or the last location retrieved from
    `window.geolocation` upon initial launch.
  prefs: []
  type: TYPE_NORMAL
- en: We are done with the LocalCast Weather app until *Chapter 9*, *Recipes – Master/Detail,
    Data Tables, and NgRx*, where I demonstrate how a state store like NgRx compares
    to using `RxJS/BehaviorSubject`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Angular Signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A signal is a reactivity primitive that keeps track of its value changing over
    time. Angular Signals implements this primitive to granularly sync the application
    state with the DOM. By focusing on granular changes in state and only the relevant
    DOM nodes, the number and severity of change detection operations are significantly
    reduced. As covered in *Chapter 1*, *Angular’s Architecture and Concepts*, change
    detection is one of the most expensive operations that the Angular framework performs.
    As an app grows in complexity, change detection operations may be forced to traverse
    or update larger parts of the DOM tree. As the number of interactive elements
    increases in your app, change detection events occur more frequently. App complexity
    combined with the frequency of events can introduce significant performance issues,
    resulting in slow or choppy rendering of the app. Usually, there’s no quick fix
    for a problem like this. So, it is critical to understand how signals work and
    implement them in your app to avoid costly performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of this publication, Angular Signals is in preview. This means that the
    functionality and performance characteristics of the feature set can and likely
    will change. Refer to the following guide for the latest information: [https://angular.dev/guide/signals](https://angular.dev/guide/signals).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular Signals provides a few simple functions to interact with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`signal`: A wrapper around a value. It works like a value getter or setter
    in a class and is conceptually similar to how `BehaviorSubject` works:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`computed`: A computed signal. It utilizes one or more signals to modify the
    outcome:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`effect`: An event that triggers when a signal changes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Signals are a new foundational concept, and they change how we think about observables,
    binding data, and syncing state between components. They are performant, surgical
    in their nature, and best of all, they’re memory safe. No subscriptions to worry
    about here.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by covering a simple example of using signals.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing dark mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our app to be considered cool by techies, we must implement a dark mode
    for it. Let’s use signals to implement this feature and go a step further by remembering
    the user’s selection in `localStorage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If this were production code, I would not use this terse line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here, I wanted to keep the lines of code to a minimum, and the toggle function
    provided by the DOM API contains the logic needed to make this work correctly.
    The line should be refactored to adhere to the single responsibility principle.
  prefs: []
  type: TYPE_NORMAL
- en: Observe the `readonly` property named `toggleState`. This is our signal. It
    holds a Boolean value. We can initialize it by reading a value from `localStorage`;
    if it doesn’t exist, it will default to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: In the toolbar, we define mat-slide-toggle and assign its [`checked`] state
    to `toggleState()`. This binds the value of the signal to the component. By assigning
    `(change)="toggleState.set($event.checked)"`, we ensure that when the user flips
    the toggle, its value will be written back to the signal.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we implement the `effect` method to react to the changes in the value
    of the signal. In the constructor, we can define the behavior we want within the
    `effect` function. First, we update `localStorage` with the current value of `toggleState`,
    and second, we set the `dark-theme` class on the DOM to toggle the dark mode state.
  prefs: []
  type: TYPE_NORMAL
- en: We leverage Angular Material’s built-in dark theme functionality to define a
    dark theme and attach it to a CSS class named `dark-theme`. Refer to `styles.scss`
    to see how this is configured.
  prefs: []
  type: TYPE_NORMAL
- en: We could’ve implemented this functionality at least a half-dozen different ways,
    but signals do offer a very economical way of doing it.
  prefs: []
  type: TYPE_NORMAL
- en: We can build on these concepts and replace the uses of `BehaviorSubject` and
    `[(ngModel)]` throughout our application. Doing so greatly simplifies how our
    Angular app works, while also reducing package size and complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing BehaviorSubject with signals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s see what it looks like to use signals instead of `BehaviorSubject`.
    Implementing a signal means we must change the end-to-end pipeline of how a value
    is retrieved and displayed. A signal is a synchronous pipeline, whereas RxJS is
    asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder, isn’t asynchronous better than synchronous? Yes, but not when
    the synchronous code can run in a non-blocking manner. Asynchronous is expensive,
    and due to the fundamental technologies that are being leveraged under the hood,
    signals are way cheaper and faster. This is due to great features that are now
    built into JavaScript. See [https://www.arrow-js.com](https://www.arrow-js.com)
    by Justin Schroeder as an example of this. Certain kinds and sizes of projects
    no longer need full-fat frameworks like Angular, React, or Vue.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to update `WeatherService`, `CitySearchComponent`, and `CurrentWeatherComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First replace `currentWeather$` with `currentWeatherSignal` in `WeatherService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement a new `getCurrentWeatherAsPromise` function to convert the observable
    to a `Promise` and a new `updateCurrentWeatherSignal` function to await the result
    of the call and assign the result to the signal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we use `firstValueFrom` to make sure the stream completes as intended.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, replace the `current$` property with `currentSignal` in `CurrentWeatherComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the template to use the signal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, update `CitySearchComponent` to trigger the new service call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have transformed our app to use a signal to communicate between components.
    A signal is less sophisticated than `BehaviorSubject`, but most of the time, the
    extra capabilities aren’t used. Signals are memory safe, lightweight, and allow
    novel applications by leveraging computed signals, like the RxJS merge technique
    discussed earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, RxJS and signals are complementary technologies. For example, we
    wouldn’t consider replacing the debounce logic in the search input away from RxJS.
    Angular also ships with `toSignal` and `fromSignal` interoperability functions;
    however, I would caution against mixing paradigms. To get the full benefit of
    signals, always prefer an end-to-end refactor, as this section covers.
  prefs: []
  type: TYPE_NORMAL
- en: With so many options, paradigms, techniques, and gotchas, you may be wondering
    if you can just generate this code using AI. I did just that for you. Read on.
  prefs: []
  type: TYPE_NORMAL
- en: Generating apps with ChatGPT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s see what result we get if we ask ChatGPT to generate a weather app. In
    August 2023, I asked ChatGPT to generate a weather app using GPT-4 with the `CodeInterpreter`
    plugin. I gave it the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: Write an Angular app that displays real-time weather data from openweathermap.org
    APIs, using Angular Material, with a user input that accepts city name, country,
    or postal code as input.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'After making a few minor corrections, this is the result I got:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_02_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11: ChatGPT weather app – August 2023'
  prefs: []
  type: TYPE_NORMAL
- en: ChatGPT created a very simple and straightforward app for me, with a weather-display
    component using two-way binding for the input field. The service call was correctly
    implemented in a dedicated weather service triggered by the **Fetch Weather**
    button. To achieve similar results to the `LocalCast` app we built, we would have
    to provide a prompt with far more technical details. Non-technical people won’t
    know to ask for specific implementation details, and developers may simply find
    it easier to iteratively develop their solution. Nevertheless, the results are
    impressive.
  prefs: []
  type: TYPE_NORMAL
- en: Four months later, I questioned my premise from the paragraph above.
  prefs: []
  type: TYPE_NORMAL
- en: '*What if developers were okay with providing one or two more prompts?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In December 2023, I provided the same prompt from above to ChatGPT using GPT-4
    without using any plugins, and after it generated the code, I provided an additional
    prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: Can you rewrite weather.component.html and style it in a way that looks like
    a professional design on desktop and mobile devices alike?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: And boom, I got a result that looked a lot better!
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_02_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.12: ChatGPT Weather app initial version – December 2023'
  prefs: []
  type: TYPE_NORMAL
- en: Still, this output doesn’t look like my design. Of course, ChatGPT has no idea
    what my design is, and it’s too cumbersome to meticulously describe it in writing.
    Then I remembered I had a hand-drawn mockup of the weather app I created for the
    1^(st) edition in 2018.
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, handwriting, drawing, diagram  Description automatically
    generated](img/B20960_02_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.13: Hand-drawn wireframe for LocalCast'
  prefs: []
  type: TYPE_NORMAL
- en: Yes, I did use a ruler!
  prefs: []
  type: TYPE_NORMAL
- en: In August 2023, ChatGPT couldn’t see, but since then, it has gained computer
    vision. I uploaded the mockup as is and said, “Redesign the UI to follow this
    mockup.” Remember that my mockup has three screens and difficult-to-read handwriting
    in it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Initial result with Sidenav](img/B20960_02_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.14: ChatGPT weather app second version – December 2023'
  prefs: []
  type: TYPE_NORMAL
- en: I’m shocked that it picked up on `SideNav` and incorporated it using proper
    Material components and `FlexLayout` media queries to make it responsive – never
    mind the misinterpretation of my handwriting.
  prefs: []
  type: TYPE_NORMAL
- en: 'I updated the generated UI code to make it interactive and included it as a
    project named `chat-get-dec23` in the repo. Here’s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Initial result with Sidenav](img/B20960_02_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.15: ChatGPT weather app final version – December 2023'
  prefs: []
  type: TYPE_NORMAL
- en: This is beyond impressive. By the time the next edition of this book is published,
    this chapter may be only a few pages long and filled with tips, highlighting the
    crucial need to use a ruler when drawing your mockups.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create search-as-you-type functionality
    using `MatInput`, validators, reactive forms, and data-stream-driven handlers.
    You became aware of two-way binding and template-driven forms. You also learned
    about different strategies to enable inter-component interactions and data sharing.
    You dove into understanding how memory leaks can be created and the importance
    of managing your subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: You can now differentiate between imperative and reactive programming paradigms
    and understand the importance of sticking with reactive programming where possible.
    Finally, you learned how to implement sophisticated functionality by chaining
    multiple API calls together. You learned about the signal primitive and how you
    can use it to build simpler and more performant applications.
  prefs: []
  type: TYPE_NORMAL
- en: LocalCast Weather is a straightforward application that we used to cover the
    basic concepts of Angular. As you saw, Angular is great for building such small
    and dynamic applications while delivering a minimal amount of framework code to
    the end user. You should consider leveraging Angular for quick and dirty projects,
    which is always great practice for building larger applications. You also learned
    you can use GenAI tools like ChatGPT to give yourself a quick start when beginning
    a new project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive into considerations around architecting a
    web application in an enterprise app and learn where all the monsters are hidden.
    We will go over how you can build a **Line-of-Business** (**LOB**) application
    using a router-first approach to designing and architecting scalable Angular applications
    with first-class authentication and authorization, user experience, and numerous
    recipes that cover a vast majority of requirements that you may find in LOB applications.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After completing the **Support international zip codes** feature, did we switch
    coding paradigms here? Is our implementation above imperative, reactive, or a
    combination of both? If our implementation is not entirely reactive, how would
    you implement this function reactively? I’ll leave this as an exercise for the
    reader.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to execute `npm test`, `npm run e2e`, and `npm run test:a11y` before
    moving on. It is left as an exercise for the reader to fix the unit and end-to-end
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Visit GitHub to see the unit tests I implemented for this chapter at [https://github.com/duluca/local-weather-app/tree/master/projects/stage6](https://github.com/duluca/local-weather-app/tree/master/projects/stage6).
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions as best as possible to ensure you’ve understood
    the key concepts from this chapter without googling anything. Do you know if you
    got all the answers right? Visit [https://angularforenterprise.com/self-assessment](https://angularforenterprise.com/self-assessment)
    for more:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the `async` pipe?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain how reactive and imperative programming is different and which technique
    we should prefer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of `BehaviorSubject`, and what is it used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are memory leaks and why should they be avoided?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the best method for managing subscriptions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are Angular signals different than RxJS streams?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are ways you can use Angular Signals to simplify your application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
