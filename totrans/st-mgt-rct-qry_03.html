<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer017">
<h1 class="ch pter-number" id="_idParaDest-39"><a id="_idTextAnchor062"/><a id="_idTextAnchor063"/><a id="_idTextAnchor064"/>3</h1>
<h1 id="_idParaDest-40"><a id="_idTextAnchor065"/>React Query – Introducing, Installing, and Configuring It</h1>
<p>React Query is a library created to make it easier for React developers to manage their server state. It makes <a id="_idIndexMarker072"/>it easier for developers to overcome all the challenges that come with server state while making their applications faster, easier to maintain, and reducing many lines in <span class="No-Break">their code.</span></p>
<p>In this chapter, you will be introduced to React Query and understand why it <span class="No-Break">was created.</span></p>
<p>You will also get to know the main concepts of React Query – <strong class="bold">queries</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="bold">mutations</strong></span><span class="No-Break">.</span></p>
<p>Once you have been introduced to React Query, we’ll install it in our application and identify the initial configurations we need to make in our code to get ready to use <span class="No-Break">it fully.</span></p>
<p>By the end of this chapter, you will know all about React Query Devtools so that you can have a better developer experience while using <span class="No-Break">React Query.</span></p>
<p>In this chapter, we’ll be covering the <span class="No-Break">following topics:</span></p>
<ul>
<li>What is <span class="No-Break">React Query?</span></li>
<li>Installing <span class="No-Break">React Query</span></li>
<li>Configuring <span class="No-Break">React Query</span></li>
<li>Adding React Query Devtools to <span class="No-Break">your application</span></li>
</ul>
<h1 id="_idParaDest-41"><a id="_idTextAnchor066"/>Technical requirements</h1>
<p>In this chapter, we will add React Query v4 to our application. To do so, there are a couple of things <span class="No-Break">we need:</span></p>
<ul>
<li>Your browser needs to be compatible with the <span class="No-Break">following configurations:</span><ul><li>The Google Chrome version needs to be at least <span class="No-Break">version 73</span></li><li>The Mozilla Firefox version needs to be at least <span class="No-Break">version 78</span></li><li>The Microsoft Edge version needs to be at least <span class="No-Break">version 79</span></li><li>The Safari version needs to be at least <span class="No-Break">version 12.0</span></li><li>The Opera version needs to be at least <span class="No-Break">version 53</span></li></ul></li>
<li>A React project after <span class="No-Break">version 16.8</span></li>
</ul>
<p>All the code examples for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_3%0D"><span class="No-Break">https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_3</span></a></p>
<h1 id="_idParaDest-42"><a id="_idTextAnchor067"/>What is React Query?</h1>
<p>React Query is a protocol-agnostic collection of hooks for fetching, caching, and updating <a id="_idIndexMarker073"/>server state <span class="No-Break">in React.</span></p>
<p>It was created by Tanner Linsley and <a id="_idIndexMarker074"/>is part of a collection of open source libraries <span class="No-Break">called TanStack.</span></p>
<p>By default, React Query can also work with React Native out of the box, and it is written in TypeScript so that you can benefit from all its advantages, such as type narrowing and <span class="No-Break">type inference.</span></p>
<p>Since version 4, React Query has <a id="_idIndexMarker075"/>been embedded in a collection of libraries called TanStack Query. TanStack Query made it possible to propagate all the amazing features of React Query to other frameworks and libraries, such as Vue, Solid, <span class="No-Break">and Svelte.</span></p>
<p>React Query leverages queries and mutations to handle your server state. Upon reading this last sentence, you might wonder what queries and mutations are. I’ll show you some code in subsequent chapters so that you can see how React Query handles them, but first, let us learn about queries <span class="No-Break">and mutations.</span></p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor068"/>Query</h2>
<p>A query is a request <a id="_idIndexMarker076"/>you make to an asynchronous source to fetch your data. Queries can <a id="_idIndexMarker077"/>be performed in React Query as long as you have a function that triggers the <span class="No-Break">data-fetching request.</span></p>
<p>By allowing us to wrap our requests inside of promise-returning functions, React Query supports REST, GraphQL, and any other asynchronous <span class="No-Break">data-fetching clients.</span></p>
<p>In React Query, the <strong class="source-inline">useQuery</strong> custom hook allows you to subscribe <span class="No-Break">to queries.</span></p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor069"/>Mutation</h2>
<p>A mutation is an operation <a id="_idIndexMarker078"/>that allows you to create, update, or delete <a id="_idIndexMarker079"/>your <span class="No-Break">server state.</span></p>
<p>Like queries, as long as you have a function that triggers a mutation, React Query supports REST, GraphQL, and any other asynchronous <span class="No-Break">data-fetching clients.</span></p>
<p>In React Query, the <strong class="source-inline">useMutation</strong> custom hook allows you to perform <span class="No-Break">a mutation.</span></p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor070"/>How does React Query solve my server state challenges?</h2>
<p><em class="it lic">What if I told you that all the challenges presented in the previous chapter could be solved by </em><span class="No-Break"><em class="it lic">React Query?</em></span></p>
<p>Out of the <a id="_idIndexMarker080"/>box and with zero configurations, React Query supports all the following <span class="No-Break">amazing features:</span></p>
<ul>
<li><strong class="bold">Caching</strong>: After each query, data will be cached during a configurable time and can be reused throughout <span class="No-Break">your application.</span></li>
<li><strong class="bold">Query cancelation</strong>: Your queries can be canceled, and you can perform an action after <span class="No-Break">this cancelation.</span></li>
<li><strong class="bold">Optimistic updates</strong>: During a <a id="_idIndexMarker081"/>mutation, you can easily update your state so that you can provide a better user experience to your users. You are also able to easily revert to a previous state if the <span class="No-Break">mutation fails.</span></li>
<li><strong class="bold">Parallel queries</strong>: If you need to execute one or more queries simultaneously, you can do so without any difficulty or impacting <span class="No-Break">your cache.</span></li>
<li><strong class="bold">Dependent queries</strong>: Sometimes, we need to execute a query after another one finishes. React Query makes this simple and avoids <span class="No-Break">chaining promises.</span></li>
<li><strong class="bold">Paginated queries</strong>: This UI pattern is made easier with React Query. You’ll find that using a paginated API, changing pages, and rendering the fetched data is <span class="No-Break">super simple.</span></li>
<li><strong class="bold">Infinite queries</strong>: Another UI pattern that is made easier by React Query. You can implement infinite scrolls into your UI and trust React Query to make your life easier when <span class="No-Break">fetching data.</span></li>
<li><strong class="bold">Scroll restoration</strong>: Have you ever navigated from a page and, when navigated back, found that the page was scrolled to the exact point where you were before you navigated away? This is scroll restoration, and as long as your query results are cached, it will work out of <span class="No-Break">the box.</span></li>
<li><strong class="bold">Data refetching</strong>: Need to trigger a refetch for your data? React Query allows you to do this with pretty much a line <span class="No-Break">of code.</span></li>
<li><strong class="bold">Data prefetching</strong>: Sometimes, you can identify ahead of time what the needs and next actions of your <a id="_idIndexMarker082"/>users are. When this happens, you can trust React Query to help you prefetch that data ahead of time and cache it for you. This way, your user experience will be improved, and you will have <span class="No-Break">happier users.</span></li>
<li><strong class="bold">Tracking network mode and offline support</strong>: Have you ever had to deal with scenarios where your user lost their internet connection while using your application? Well, don’t worry because React Query can track the current state of your network, and if a query fails because the user lost connection, it will be retried once the <span class="No-Break">network returns.</span></li>
</ul>
<p>Looking at this list is <span class="No-Break">amazing, right?</span></p>
<p>Just having caching out of the box is a super, great timesaver because it is definitely one of the hardest things to implement when dealing with <span class="No-Break">server state.</span></p>
<p>Before React Query, it was much harder to handle the server state in our applications. We tried, but our solutions ended up growing more complex and with less maintainable code. Often, these implementations would even end up impacting the user experience because our <a id="_idIndexMarker083"/>applications would get <span class="No-Break">less responsive.</span></p>
<p>With React Query, you are now able to greatly reduce the number of lines in your code, make your application much easier to read and simple, and at the same time, make your application faster and much <span class="No-Break">more responsive.</span></p>
<p>I won’t get into more technical details right now because, hopefully, in the following chapters, you will see all these features working and start understanding why React Query makes your life so <span class="No-Break">much easier.</span></p>
<p>For now, let us start by installing React Query in <span class="No-Break">our applications.</span></p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor071"/>Installing React Query</h1>
<p>Now that you are aware <a id="_idIndexMarker084"/>of React Query, you are probably thinking, <em class="it lic">wow, I really need to add this to my project.</em> Wait no more – here is what you need to do to install <span class="No-Break">React Query.</span></p>
<p>Depending on your project type, you can install React Query in <span class="No-Break">several ways.</span></p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor072"/>npm</h2>
<p>If you are <a id="_idIndexMarker085"/>running npm in your project, then this is what you need to do to install <a id="_idIndexMarker086"/><span class="No-Break">React Query.</span></p>
<p>In your terminal, run the <span class="No-Break">following command:</span></p>
<pre class="console">
npm i @tanstack/react-query</pre>
<h2 id="_idParaDest-48"><a id="_idTextAnchor073"/>Yarn</h2>
<p>If Yarn is <a id="_idIndexMarker087"/>what you prefer, then this is what you need to do to install <span class="No-Break">React Query.</span></p>
<p>In your <a id="_idIndexMarker088"/>terminal, run the <span class="No-Break">following command:</span></p>
<pre class="console">
yarn add @tanstack/react-query</pre>
<h2 id="_idParaDest-49"><a id="_idTextAnchor074"/>pnpm</h2>
<p>If you are a fan <a id="_idIndexMarker089"/>of a new package manager, such as pnpm, and <a id="_idIndexMarker090"/>are using it in your project, then this is what you need to do to install <span class="No-Break">React Query.</span></p>
<p>In your terminal, run the <span class="No-Break">following command:</span></p>
<pre class="console">
pnpm add @tanstack/react-query</pre>
<h2 id="_idParaDest-50"><a id="_idTextAnchor075"/>Script tag</h2>
<p>Not using a <a id="_idIndexMarker091"/>package manager? Don’t worry, because React Query can be added to <a id="_idIndexMarker092"/>your application by using a global build that is hosted on a <strong class="bold">content </strong><span class="No-Break"><strong class="bold">delivery network</strong></span><span class="No-Break">.</span></p>
<p class="c llout-he ding">Content delivery network (CDN)</p>
<p class="c llout">A CDN is a geographically <a id="_idIndexMarker093"/>distributed group of servers that work together to allow for faster delivery of content on <span class="No-Break">the internet.</span></p>
<p>To add React Query to your application, add the next <strong class="source-inline">script</strong> tag at the end of your <span class="No-Break">HTML file:</span></p>
<pre class="source-code">
&lt;script src="https://unpkg.com/@tanstack/react-query@4/build/umd/index.production.js"&gt;&lt;/script&gt;</pre>
<p> You should now have React Query installed in <span class="No-Break">your project.</span></p>
<p>Now, we need to do the initial configurations on our projects to be able to use all the core functionalities of <span class="No-Break">React Query.</span></p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor076"/>Configuring React Query</h1>
<p>React Query has a <a id="_idIndexMarker094"/>very fast and simple configuration. This improves the developer experience and can prepare you to start migrating your server state to React Query as soon <span class="No-Break">as possible.</span></p>
<p>To add React Query to your application, there are only two things you need <span class="No-Break">to know:</span></p>
<ul>
<li><span class="No-Break"><strong class="bold">QueryClient</strong></span></li>
<li><span class="No-Break"><strong class="bold">QueryClientProvider</strong></span></li>
</ul>
<h2 id="_idParaDest-52"><a id="_idTextAnchor077"/>QueryClient</h2>
<p>As you should be <a id="_idIndexMarker095"/>aware right now, caching is one of the most important <a id="_idIndexMarker096"/>things React Query makes easier for developers. In React Query, there are two mechanisms used to handle this cache called <strong class="bold">QueryCache</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="bold">MutationCache</strong></span><span class="No-Break">.</span></p>
<p><strong class="source-inline">QueryCache</strong> is responsible <a id="_idIndexMarker097"/>for storing all the data related to your queries. This can be the data of your query as well as its <span class="No-Break">current state.</span></p>
<p><strong class="source-inline">MutationCache</strong> is responsible for storing all the data related to your mutations. This can be the data of <a id="_idIndexMarker098"/>your mutation as well as its <span class="No-Break">current state.</span></p>
<p>To make it easier for a developer to abstract from both caches, React Query created <strong class="source-inline">QueryClient</strong>. This is responsible for being the interface between a developer and <span class="No-Break">a cache.</span></p>
<p>The first thing you should do when setting your application with React Query is to create a <strong class="source-inline">QueryClient</strong> instance. To do so, you need to import it from the <strong class="source-inline">@tanstack/react-query</strong> package and <span class="No-Break">instantiate it:</span></p>
<pre class="source-code">
import {
 QueryClient,
} from '@tanstack/react-query'
const queryClient = new QueryClient()</pre>
<p>In the preceding snippet, we create a new <strong class="source-inline">QueryClient</strong> object. As we don’t pass any argument when instantiating the object, <strong class="source-inline">QueryClient</strong> will assume all <span class="No-Break">the defaults.</span></p>
<p>There are four options we can send as arguments when creating our <strong class="source-inline">QueryClient</strong>. They are <span class="No-Break">as follows:</span></p>
<ul>
<li><strong class="source-inline">queryCache</strong>: The query cache that this client will use throughout <span class="No-Break">our application.</span></li>
<li><strong class="source-inline">mutationCache</strong>: The mutation cache that this client will use throughout <span class="No-Break">our application.</span></li>
<li><strong class="source-inline">logger</strong>: The logger that this client will use to display errors, warnings, and useful information for debugging. When nothing is specified, then React Query will use the <span class="No-Break">console object.</span></li>
<li><strong class="source-inline">defaultOptions</strong>: The default options that all queries and mutations will use throughout <span class="No-Break">our application.</span></li>
</ul>
<p>Now, you might be <a id="_idIndexMarker099"/>wondering when you should manually set each one of these arguments instead <a id="_idIndexMarker100"/>of using the default ones. The following subsections will tell <span class="No-Break">you when.</span></p>
<h3>QueryCache and MutationCache</h3>
<p>Here is a small <a id="_idIndexMarker101"/>spoiler that hopefully you will review and understand <a id="_idIndexMarker102"/>better in the following chapters, but it is essential to understand when you should manually configure either <strong class="source-inline">QueryCache</strong> or <strong class="source-inline">MutationCache</strong> – all queries and mutations can execute some code whenever there is an error, or when its execution succeeds. This code is represented by the <strong class="source-inline">onSuccess</strong> and <strong class="source-inline">onError</strong> functions. Also, in the case of mutations, you can also execute some code before the mutation executes. In this scenario, the function that represents this is <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">onMutate</strong></span><span class="No-Break">.</span></p>
<p>In the case of <strong class="source-inline">QueryCache</strong>, this is how it <span class="No-Break">would look:</span></p>
<pre class="source-code">
import { QueryCache } from '@tanstack/react-query'
const queryCache = new QueryCache({
 <strong class="bold">onError</strong>: error =&gt; {
  // do something on error
 },
 <strong class="bold">onSuccess</strong>: data =&gt; {
  // do something on success
 }
})</pre>
<p>Before explaining the preceding snippet, let’s look at the very <span class="No-Break">similar </span><span class="No-Break"><strong class="source-inline">MutationCache</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
import { MutationCache } from '@tanstack/react-query'
const mutationCache = new MutationCache({
 <strong class="bold">onError</strong>: error =&gt; {
  // do something on error
 },
 <strong class="bold">onSuccess</strong>: data =&gt; {
  // do something on success
 },
 <strong class="bold">onMutate</strong>: newData =&gt; {
  // do something before the mutation
 },
})</pre>
<p>As you can see, both snippets are similar, except for the <strong class="source-inline">onMutate</strong> function <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">MutationCache</strong></span><span class="No-Break">.</span></p>
<p>By default, these <a id="_idIndexMarker103"/>functions don’t have any behavior, but if, for some <a id="_idIndexMarker104"/>reason, you intend on always doing something whenever you perform a mutation or a query, then you can do this configuration inside the respective function of the respective object when instantiating the <span class="No-Break">cache object.</span></p>
<p>Then, you can send this object to <strong class="source-inline">QueryClient</strong> when <span class="No-Break">instantiating it:</span></p>
<pre class="source-code">
const queryClient = new QueryClient({
 <strong class="bold">mutationCache,</strong>
<strong class="bold"> queryCache</strong>
})</pre>
<p>In the preceding <a id="_idIndexMarker105"/>snippet, we instantiated a new <strong class="source-inline">QueryClient</strong> with <a id="_idIndexMarker106"/>our custom <strong class="source-inline">MutationCache</strong> and <span class="No-Break"><strong class="source-inline">QueryCache</strong></span><span class="No-Break"> functions.</span></p>
<h3>Logger</h3>
<p>Are you <a id="_idIndexMarker107"/>using <strong class="source-inline">logger</strong> outside of the <strong class="source-inline">console</strong> object in your project? Then, you might want to configure it in <span class="No-Break">your </span><span class="No-Break"><strong class="source-inline">QueryClient</strong></span><span class="No-Break">.</span></p>
<p>Here is what you need <span class="No-Break">to do:</span></p>
<pre class="source-code">
const logger = {
   log: (...args) =&gt; {
     // here you call your custom log function
   },
   warn: (...args) =&gt; {
     // here you call your custom warn function
   },
   error: (...args) =&gt; {
     // here you call your custom error function
   },
 };</pre>
<p>In the preceding snippet, we created a <strong class="source-inline">logger</strong> object. This object has three functions that React Query will call whenever it needs to <strong class="source-inline">log</strong> an error, <strong class="source-inline">warn</strong> about an error, or display <strong class="source-inline">error</strong>. You can override these functions and add your <span class="No-Break">custom logger.</span></p>
<p>Then, all you need to do is pass this <strong class="source-inline">logger</strong> object to your <strong class="source-inline">QueryClient</strong> when <span class="No-Break">instantiating it:</span></p>
<pre class="source-code">
const queryClient = new QueryClient({
 <strong class="bold">logger</strong>
})</pre>
<p>In the preceding <a id="_idIndexMarker108"/>snippet, we instantiated a new <strong class="source-inline">QueryClient</strong> with our <span class="No-Break">custom logger.</span></p>
<h3>defaultOptions</h3>
<p>There are options that are used as defaults for all the mutations or queries that you execute throughout <a id="_idIndexMarker109"/>your application. <strong class="source-inline">defaultOptions</strong> allows you to override these defaults. There are many defaults, and I’ll avoid showing all of them to avoid spoilers for the next chapters, but don’t worry – I’ll do a callback to these options when the right <span class="No-Break">time arrives.</span></p>
<p>Here is how you override <span class="No-Break">your </span><span class="No-Break"><strong class="source-inline">defaultOptions</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
const defaultOptions = {
   queries: {
     staleTime: Infinity,
   },
 };</pre>
<p>What we did in the preceding snippet was create a <strong class="source-inline">defaultOptions</strong> object and, inside it, a <strong class="source-inline">queries</strong> object. Inside this <strong class="source-inline">queries</strong> object, we specified that <strong class="source-inline">staleTime</strong> for all queries will be <strong class="source-inline">Infinity</strong>. Once again, don’t worry about not having a definition for this yet. You will understand it in the <span class="No-Break">next chapter.</span></p>
<p>Once this setup is done, all you need to do is pass this <strong class="source-inline">defaultOptions</strong> object to your <strong class="source-inline">QueryClient</strong> when instantiating it, and all the queries will have the <strong class="source-inline">staleTime</strong> property set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Infinity</strong></span><span class="No-Break">.</span></p>
<p>Here is how to <span class="No-Break">do it:</span></p>
<pre class="source-code">
const queryClient = new QueryClient({
 <strong class="bold">defaultOptions</strong>
})</pre>
<p>In the preceding snippet, we instantiated a new <strong class="source-inline">QueryClient</strong> with our custom <span class="No-Break"><strong class="source-inline">defaultOptions</strong></span><span class="No-Break"> object.</span></p>
<p>Okay, so now you are aware of <strong class="source-inline">QueryClient</strong> and should understand its role as the brain of <span class="No-Break">React Query.</span></p>
<p>So, you might be thinking, considering that React Query is based on hooks for doing the queries and mutations, do we need to always pass our <strong class="source-inline">QueryClient</strong> to all <span class="No-Break">our hooks?</span></p>
<p>Imagine if this <a id="_idIndexMarker110"/>was the case! We all would be sick and tired of all the prop drilling in our application even before we used our second or <span class="No-Break">third hook.</span></p>
<p>Let us now see the way that React Query saves us some time by <span class="No-Break">introducing </span><span class="No-Break"><strong class="source-inline">QueryClientProvider</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor078"/>QueryClientProvider</h2>
<p>To make the process of sharing our <strong class="source-inline">QueryClient</strong> easier for every developer, React Query resorted <a id="_idIndexMarker111"/>to something we learned about in <a href="B18501_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="it lic">Chapter 1</em></span></a>, and that is React Context. By creating its custom provider called <strong class="source-inline">QueryClientProvider</strong>, React Query allows you to share <strong class="source-inline">QueryClient</strong> with all the <a id="_idTextAnchor079"/>custom hooks it <span class="No-Break">provides automatically.</span></p>
<p>The following sni<a id="_idTextAnchor080"/>ppet shows you how to use React <span class="No-Break">Query’s </span><span class="No-Break"><strong class="source-inline">QueryClientProvider</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
import {
 QueryClient,
 QueryClientProvider,
} from '@tanstack/react-query'
// Create a client
<strong class="bold">const queryClient = new QueryClient()</strong>
const App = () =&gt; {
 return (
<strong class="bold">   &lt;QueryClientProvider client={queryClient}&gt;</strong>
<strong class="bold">     &lt;Counter /&gt;</strong>
<strong class="bold">   &lt;/QueryClientProvider&gt;</strong>
 )
}</pre>
<p>As you can see in the preceding snippet, all you need to do is import your <strong class="source-inline">QueryClientProvider</strong> from the <strong class="source-inline">@tanstack/react-query</strong> package, wrap your main <a id="_idIndexMarker112"/>component with it, and pass it to <strong class="source-inline">queryClient</strong> as <span class="No-Break">a prop.</span></p>
<p>Your application is now ready to start using <span class="No-Break">React Query.</span></p>
<p>Now, let us see how we can add and use React Query-dedicated <span class="No-Break">developer tools.</span></p>
<h1 id="_idParaDest-54"><a id="_idTextAnchor081"/>Adding React Query Devtools</h1>
<p>When debugging <a id="_idIndexMarker113"/>our applications, we often find ourselves thinking how amazing it would be to have a way to visualize what is happening inside our application. Well, with React Query, you don’t have to worry because it has its own developer tools, <span class="No-Break">or devtools.</span></p>
<p>React Query Devtools allows you to see and understand the current state of all your queries and mutations. This will save you a lot of time debugging and avoid polluting all your code with unnecessary log functions, even <span class="No-Break">if temporarily.</span></p>
<p>Depending on the type of project, you can install React Query Devtools in <span class="No-Break">several ways:</span></p>
<ul>
<li>If you are running npm in your project, run the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">npm i @tanstack/react-query-devtools</strong></pre></li>
<li>If you are using Yarn, run the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">yarn add @tanstack/react-query-devtools</strong></pre></li>
<li>If you are using pnpm, run the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">pnpm add @tanstack/react-query-devtools</strong></pre></li>
</ul>
<p>Now, you should have React Query Devtools installed in your application. Let’s now see how we can add them to <span class="No-Break">our code.</span></p>
<p>There are two ways to use Devtools. They are Floating Mode and <span class="No-Break">Embedded Mode.</span></p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor082"/>Floating Mode</h2>
<p>Floating Mode will <a id="_idIndexMarker114"/>render the React Query logo floating in the <a id="_idIndexMarker115"/>corner of your screen. By clicking on it, you can toggle Devtools on <span class="No-Break">or off.</span></p>
<p>The logo that will show up in the corner of your screen is <span class="No-Break">the following:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<img alt="" height="43" src="image/Figure_3.1_B18501.jpg" width="46"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – The React Query Devtools logo</p>
<p>Once you toggle it, then you will <span class="No-Break">see Devtools:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer013">
<img alt="" height="588" src="image/Figure_3.2_B18501.jpg" width="913"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – React Query Devtools’ Floating Mode</p>
<p>Devtools will be rendered in your <strong class="bold">DOM tree</strong> inside a separate <span class="No-Break">HTML element.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer014">
<img alt="" height="77" src="image/Figure_3.3_B18501.jpg" width="662"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – React Query Devtools’ Floating Mode on the DOM</p>
<p>To add Devtools <a id="_idIndexMarker116"/>in Floating Mode to your application, you <a id="_idIndexMarker117"/>need to <span class="No-Break">import it:</span></p>
<pre class="source-code">
import { ReactQueryDevtools } from '@tanstack/
  react-query-devtools'</pre>
<p>Once imported, just add it as close to your <strong class="source-inline">QueryClientProvider</strong> as <span class="No-Break">you can:</span></p>
<pre class="source-code">
   &lt;QueryClientProvider client={queryClient}&gt;
     &lt;ReactQueryDevtools initialIsOpen={false} /&gt;
     &lt;Counter /&gt;
   &lt;/QueryClientProvider&gt;</pre>
<h2 id="_idParaDest-56"><a id="_idTextAnchor083"/>Embedded Mode</h2>
<p>Embedded Mode will add <a id="_idIndexMarker118"/>Devtools embedded as a regular component in <a id="_idIndexMarker119"/><span class="No-Break">your application.</span></p>
<p>Here is how it looks on <span class="No-Break">your application:</span></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><a id="_idIndexMarker120"/></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<img alt="" height="438" src="image/Figure_3.4_B18501.jpg" width="951"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – React Query Devtools’ Embedded Mode</p>
<p>If you look <a id="_idIndexMarker121"/>at your DOM tree, you will see that Devtools is rendered like <a id="_idIndexMarker122"/>a <span class="No-Break">regular component.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<img alt="" height="131" src="image/Figure_3.5_B18501.jpg" width="697"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – React Query Devtools’ Embedded Mode on the DOM</p>
<p>To use Devtools in Embedded Mode in your application, you need to <span class="No-Break">import it:</span></p>
<pre class="source-code">
import { ReactQueryDevtoolsPanel } from '@tanstack/
  react-query-devtools'</pre>
<p>Once they are imported, just add them as close to your <strong class="source-inline">QueryClientProvider</strong> <span class="No-Break">as possible:</span></p>
<pre class="source-code">
   &lt;QueryClientProvider client={queryClient}&gt;
     &lt;ReactQueryDevtoolsPanel /&gt;
     &lt;Counter /&gt;
   &lt;/QueryClientProvider&gt;</pre>
<p>By default, Devtools is <a id="_idIndexMarker123"/>not included in production builds. Nevertheless, you <a id="_idIndexMarker124"/>might want to load them in production to help you debug something. In the next section, we’ll see how to <span class="No-Break">do that.</span></p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor084"/>Enabling Devtools in your production build</h2>
<p>If you decide <a id="_idIndexMarker125"/>to load Devtools in <a id="_idIndexMarker126"/>your production environment, you must delay loading it and instead load it dynamically. This is important to help reduce your application bundle size. It is also important to lazy load Devtools because when using our application in production, we might never want to use it, so we want to avoid adding stuff to our build that we will end up not using at all. To lazy load components in React, we can <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">React.lazy</strong></span><span class="No-Break">.</span></p>
<p>Here is how we can import Devtools <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">React.lazy</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
const ReactQueryDevtoolsProduction = React.lazy(() =&gt;
  import('@tanstack/react-query-devtools/build/lib/
    index.prod.js').then(
    (d) =&gt; ({
      default: d.ReactQueryDevtools,
    }),
  ),
)</pre>
<p>The preceding snippet wraps a <strong class="bold">dynamic import</strong> with <strong class="source-inline">React.lazy</strong> and assigns the return of the promise to <strong class="source-inline">ReactQueryDevtoolsProduction</strong>, so that we can lazily load it in our production environment without increasing our <span class="No-Break">bundle size.</span></p>
<p class="c llout-he ding">What is a dynamic import?</p>
<p class="c llout">A dynamic import allows you <a id="_idIndexMarker127"/>to load a module from any place in your code asynchronously. This import will return a promise that, when fulfilled, returns an object containing the exports from <span class="No-Break">the module.</span></p>
<p>The previous <a id="_idIndexMarker128"/>snippet should work with all <a id="_idIndexMarker129"/>bundlers. If you are using a more modern bundler that supports package exports, then instead you can dynamically import your module <span class="No-Break">like this:</span></p>
<pre class="source-code">
const ReactQueryDevtoolsProduction = React.lazy(() =&gt;
  import('@tanstack/react-query-devtools/production').then(
    (d) =&gt; ({
      default: d.ReactQueryDevtools,
    }),
  ),
)</pre>
<p>In this snippet, we change the path from where we will import our module to one that will work with more <span class="No-Break">modern bundlers.</span></p>
<p>When using <strong class="source-inline">React.lazy</strong> and trying to render the component we just lazy loaded, React requires that the component should be wrapped with a <strong class="bold">Suspense</strong> component. This is important in a scenario where we want to show a fallback while our lazy-loaded component <span class="No-Break">is pending.</span></p>
<p class="c llout-he ding">What is Suspense?</p>
<p class="c llout"><strong class="source-inline">Suspense</strong> allows you to <a id="_idIndexMarker130"/>render a loading indication in your UI while the component inside of it is not ready to be <span class="No-Break">re<a id="_idTextAnchor085"/><a id="_idTextAnchor086"/>ndered yet.</span></p>
<p>Let us see what we need to do to load our <span class="No-Break"><strong class="source-inline">ReactQueryDevtoolsProduction</strong></span><span class="No-Break"> component:</span></p>
<pre class="source-code">
&lt;React.Suspense fallback={null}&gt;
  &lt;ReactQueryDevtoolsProduction /&gt;
&lt;/React.Suspense&gt;</pre>
<p>As you can see in the snippet, we wrap our <strong class="source-inline">ReactQueryDevtoolsProduction</strong> component with <strong class="source-inline">Suspense</strong> so it can be lazy loaded. You can also see that we didn’t provide any fallback since what we are trying to load are Devtools, and we don’t need to add any pending state while the module <span class="No-Break">is loading.</span></p>
<p>Now, we don’t want to automatically load Devtools whenever we render our component. What we want is a way to toggle them in <span class="No-Break">our application.</span></p>
<p>Since this is a <a id="_idIndexMarker131"/>production build, we don’t <a id="_idIndexMarker132"/>want to include a button there that might confuse our users. So, a potential way to handle this is by creating a function inside our <strong class="source-inline">window</strong> object <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">toggleDevtools</strong></span><span class="No-Break">.</span></p>
<p>This is how the React Query documentation suggests we <span class="No-Break">do it:</span></p>
<pre class="source-code">
  const [showDevtools, setShowDevtools] = React.useState
    (false)
  React.useEffect(() =&gt; {
<strong class="bold">    window.toggleDevtools = () =&gt; setShowDevtools</strong>
<strong class="bold">      ((previousState) =&gt; !previousState)</strong>
  }, []<a id="_idTextAnchor087"/><a id="_idTextAnchor088"/>)
  return (
    …
      {showDevtools &amp;&amp; (
        &lt;React.Suspense fallback={null}&gt;
          &lt;ReactQueryDevtoolsProduction /&gt;
        &lt;/React.Suspense&gt;
      )}
    …
  );</pre>
<p>Here is what we <a id="_idIndexMarker133"/>are doing in the <span class="No-Break">preceding </span><span class="No-Break"><a id="_idIndexMarker134"/></span><span class="No-Break">snippet:</span></p>
<ol>
<li>Creating a state variable to hold the current state of the Devtools. This state variable is updated whenever the user toggles the Devtools on <span class="No-Break">or off.</span></li>
<li>Running an effect where we assign the toggle function to <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">window</strong></span><span class="No-Break">.</span></li>
<li>Inside our return, when our <strong class="source-inline">showDevtools</strong> is toggled on, since we are lazy loading our <strong class="source-inline">ReactQueryDevtoolsProduction</strong> component, we need to wrap it with <strong class="source-inline">Suspense</strong> to be able to <span class="No-Break">render it.</span></li>
</ol>
<p>At this point, you have all that you need to start using React Query in <span class="No-Break">your application.</span></p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor089"/>Summary</h1>
<p>In this chapter, we learned about TanStack Query and how React Query fits into it. By now, you should be able to identify the primary way React Query makes server state management easier and how it uses queries <span class="No-Break">and mutations.</span></p>
<p>You learned about <strong class="source-inline">QueryClient</strong> and <strong class="source-inline">QueryClientProvider</strong> and understood how they are fundamental to running React Query in your application. You also learned how you can customize your own <strong class="source-inline">QueryClient</strong> if you need to <span class="No-Break">do so.</span></p>
<p>Finally, you got to meet the React Query Devtools and learned how to configure it in your project. Also, you are now able to load it into production for those special scenarios when you need to do some <span class="No-Break">extra debugging.</span></p>
<p>In <a href="B18501_04.xhtml#_idTextAnchor091"><span class="No-Break"><em class="it lic">Chapter 4</em></span></a>, <em class="it lic">Fetching Data with React Query</em>, you will get to know your best friend for dealing with queries, the <strong class="source-inline">useQuery</strong> custom hook. You’ll understand how it works, how to use it, and how it can cache data. You will also learn the ways you can trigger query refetches and how to build <span class="No-Break">dependent queries.</span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer018">
</div>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer019">
<h1 id="_idParaDest-59"><a id="_idTextAnchor090"/>Part 2: Managing Server State with React Query</h1>
<p>When dealing with server state, many challenges are attached to how we read from it. From caching to pagination, we will understand how the React Query custom hook called <strong class="source-inline">useQuery</strong> makes this work while giving an amazing combined developer and <span class="No-Break">user experience.</span></p>
<p>As well as the challenges of how we read our server state, creating, updating, and deleting it brings about another set of challenges. Luckily, React Query has another custom hook that comes to the rescue <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">useMutation</strong></span><span class="No-Break">.</span></p>
<p>After understanding the pillars of React Query, you might be wondering whether popular server-side frameworks such as Next.js and Remix allow you to use React Query. Spoiler alert – they do, and you will learn <span class="No-Break">how here.</span></p>
<p>To wrap up and make sure that you will be able to sleep well at night, you will learn a set of recipes you can use to test your React Query, using components and custom hooks by levering Mock Service Worker and the React <span class="No-Break">Testing Library.</span></p>
<p>This part includes the <span class="No-Break">following chapters:</span></p>
<ul>
<li><a href="B18501_04.xhtml#_idTextAnchor091"><em class="it lic">Chapter 4</em></a>, <em class="it lic">Fetching Data with React Query</em></li>
<li><a href="B18501_05.xhtml#_idTextAnchor140"><em class="it lic">Chapter 5</em></a>, <em class="it lic">More Data-Fetching Challenges</em></li>
<li><a href="B18501_06.xhtml#_idTextAnchor159"><em class="it lic">Chapter 6</em></a>, <em class="it lic">Performing Data Mutations with React Query</em></li>
<li><a href="B18501_07.xhtml#_idTextAnchor173"><em class="it lic">Chapter 7</em></a>, <em class="it lic">Server-Side Rendering with Next.js or Remix</em></li>
<li><a href="B18501_08.xhtml#_idTextAnchor184"><em class="it lic">Chapter 8</em></a>, <em class="it lic">Testing React Query Hooks and Components</em></li>
</ul>
</div>
<div>
<div id="_idContainer020">
</div>
</div>
</div></body></html>