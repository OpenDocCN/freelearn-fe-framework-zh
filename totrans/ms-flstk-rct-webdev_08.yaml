- en: Docker and the EC2 Container Service
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker和EC2容器服务
- en: We have done all the stuff related to database-as-a-backend with mLab. The publishing
    application should be working 100 percent remotely on the mLab MongoDB instance,
    so you don't need to run the `mongod` command anymore.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了与数据库作为后端的所有相关事宜，使用的是mLab。发布应用程序应该在mLab MongoDB实例上100%远程工作，所以你不再需要运行`mongod`命令了。
- en: It's time to prepare our Docker container and deploy it on EC2 completely with
    the use of ECS (EC2 Container Service) and load balancers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候准备我们的Docker容器，并使用ECS（EC2容器服务）和负载均衡器将其完全部署到EC2上了。
- en: What is Docker? It's a very useful piece of software that is open source and
    helps you pack, ship, and run any app as a light (in comparison to a virtual machine,
    for example) container.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是Docker？它是一个非常实用的开源软件，可以帮助你打包、运输和运行任何应用程序作为一个轻量级的容器（例如，与虚拟机相比）。
- en: A container's goals are similar to virtual machines--the big difference is that
    Docker was created with software development in mind, as opposed to VMs. You need
    to also be aware that a fully virtualized system has its own resources allocated
    to it, which causes minimal resource sharing, which is different for Docker containers.
    Of course, in VMs, you get more isolation, but the cost is that the VMs are much
    heavier (requiring more disk space, RAM, and other resources). Docker's containers
    are lightweight and are able to share more things among different containers in
    comparison to VMs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的目标与虚拟机类似--最大的区别是Docker是为了软件开发而创建的，而不是VM。你还需要意识到，一个完全虚拟化的系统为其分配了自身的资源，这导致了最小资源共享，这与Docker容器不同。当然，在VM中，你得到更多的隔离，但代价是VM要重得多（需要更多的磁盘空间、RAM和其他资源）。Docker的容器轻量级，并且与VM相比，能够在不同的容器之间共享更多东西。
- en: The good part is that Docker's containers are hardware and platform independent,
    so all worries about whether what you are working on will run everywhere are disappearing.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 好的一点是，Docker的容器是硬件和平台无关的，所以关于你正在工作的内容是否能在任何地方运行的担忧都消失了。
- en: Generally, Docker's benefits are that it increases developers' productivity,
    helps them ship software faster, helps move the software from local development
    machines to production deployments on AWS, and so on. Docker also allows versioning
    (similar to Git) of your software, which can be helpful when you need a quick
    rollback on the production server.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Docker的好处是它提高了开发者的生产力，帮助他们更快地发布软件，帮助他们将软件从本地开发机器移动到AWS上的生产部署，等等。Docker还允许对软件进行版本控制（类似于Git），这在需要快速在生产服务器上回滚时非常有帮助。
- en: 'In this chapter, you will learn the following things:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Installing the Docker app on your machine with Docker Toolbox on non-Linux machines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在非Linux机器上使用Docker Toolbox安装Docker应用程序
- en: Testing whether your Docker setup is correct
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试你的Docker设置是否正确
- en: Preparing the publishing app in order to use mLab Mongo for the database
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备发布应用程序以使用mLab Mongo作为数据库
- en: Creating a new Docker container for the publishing app
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为发布应用程序创建一个新的Docker容器
- en: Creating your first Dockerfile, which will deploy the publishing app on Linux
    CentOS
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的第一个Dockerfile，该文件将在Linux CentOS上部署发布应用程序
- en: EC2 Container Service
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EC2容器服务
- en: AWS load balancers
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS负载均衡器
- en: Using Amazon Route 53 for DNS services
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Amazon Route 53进行DNS服务
- en: AWS identity and access management (IAM)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS身份和访问管理（IAM）
- en: Docker installation with Docker Toolbox
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker Toolbox安装Docker
- en: Installing Docker is quite easy. Visit the official installation page at [https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/)
    because it will guide you best depending on your operating system. There are easy-to-follow
    installers for iOS and Windows and a lot of instructions for different Linux distributions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Docker相当简单。访问官方安装页面[https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/)，因为它会根据你的操作系统提供最佳指导。有适用于iOS和Windows的易于遵循的安装程序，以及针对不同Linux发行版的许多说明。
- en: 'If you are using a non-Linux machine, then you also need to install Docker
    Toolbox for Windows or OS X. This is quite simple with its installers, which are
    available at [https://www.docker.com/products/docker-toolbox](https://www.docker.com/products/docker-toolbox),
    as shown in the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是非Linux机器，那么你还需要安装Docker Toolbox for Windows或OS X。这很简单，因为它的安装程序可以在[https://www.docker.com/products/docker-toolbox](https://www.docker.com/products/docker-toolbox)找到，如下面的截图所示：
- en: '![](img/00094.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00094.jpeg)'
- en: 'If you are using Linux, there are some extra steps to be performed as you need
    to turn on virtualization in BIOS:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Linux，你需要执行一些额外的步骤，因为你需要在 BIOS 中开启虚拟化：
- en: Install the Docker machine with instructions from the official docs at [https://docs.docker.com/machine/install-machine/](https://docs.docker.com/machine/install-machine/)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照官方文档中的说明安装 Docker machine，文档链接为 [https://docs.docker.com/machine/install-machine/](https://docs.docker.com/machine/install-machine/)
- en: For Ubuntu, you need to install VirtualBox manually from [https://help.ubuntu.com/community/VirtualBox](https://help.ubuntu.com/community/VirtualBox)[](https://docs.docker.com/machine/install-machine/)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Ubuntu，你需要手动从 [https://help.ubuntu.com/community/VirtualBox](https://help.ubuntu.com/community/VirtualBox)
    安装 VirtualBox
- en: For other Linux distributions visit [https://www.virtualbox.org/wiki/Linux_Downloads](https://www.virtualbox.org/wiki/Linux_Downloads)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于其他 Linux 发行版，请访问 [https://www.virtualbox.org/wiki/Linux_Downloads](https://www.virtualbox.org/wiki/Linux_Downloads)
- en: 'After you have installed Docker (together with Toolbox on OS X and Windows)
    on your local machine, run in the Terminal the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的本地机器上安装 Docker（包括在 OS X 和 Windows 上的 Toolbox）后，请在终端中运行以下命令：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After you run this command, you will be able to see something similar to the
    following screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此命令后，你将能够看到以下类似截图的内容：
- en: '![](img/00095.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00095.jpeg)'
- en: If you can see something like this, then your installation is successful. Let's
    continue with Docker.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到类似的内容，那么你的安装就成功了。让我们继续学习 Docker。
- en: Docker Hub - an hello world example
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Hub - 一个 hello world 示例
- en: Before we start creating the publishing app's Docker container, let's start
    playing with an official Docker *hello world* example that will make you aware
    of how the Docker Hub works.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建发布应用的 Docker 容器之前，让我们先玩一个官方的 Docker *hello world* 示例，这将让你了解 Docker Hub
    的工作方式。
- en: 'Docker Hub is to Docker containers as GitHub is to Git''s repositories. You
    can have public and private containers in Docker. The main page of Docker Hub
    look like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 对于 Docker 容器来说，就像 GitHub 对于 Git 仓库一样。你可以在 Docker 中拥有公共和私有容器。Docker
    Hub 的主页看起来是这样的：
- en: '![](img/00096.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00096.jpeg)'
- en: 'Just to give you a feel for it, if you visit [https://hub.docker.com/explore/](https://hub.docker.com/explore/),
    you can see different containers that are ready for use, like this, for example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了让你有个感觉，如果你访问 [https://hub.docker.com/explore/](https://hub.docker.com/explore/)，你可以看到不同已经准备好使用的容器，比如这个，例如：
- en: '![](img/00097.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00097.jpeg)'
- en: Just for our demo exercise, we will use a container called `hello world`, which
    is publicly available at [https://hub.docker.com/r/library/hello-world/](https://hub.docker.com/r/library/hello-world/).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为了我们的演示练习，我们将使用一个名为 `hello world` 的容器，该容器在 [https://hub.docker.com/r/library/hello-world/](https://hub.docker.com/r/library/hello-world/)
    公开可用。
- en: 'In order to run this `hello-world` example, run the following in your Terminal:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行这个 `hello-world` 示例，请在你的终端中运行以下命令：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After you run this, you will see something similar to the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此命令后，你将看到以下类似的内容：
- en: '![](img/00098.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00098.jpeg)'
- en: 'Let''s understand what''s just happened: we use the `docker run` command in
    order to start the container based on an image (in our example, we have used the
    hello world container image). In this case, we do the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解刚刚发生了什么：我们使用 `docker run` 命令来启动基于镜像的容器（在我们的例子中，我们使用了 hello world 容器镜像）。在这种情况下，我们执行以下操作：
- en: Run the command that tells Docker to start the container named `hello-world`
    with no extra commands.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行命令，告诉 Docker 使用无额外命令启动名为 `hello-world` 的容器。
- en: After you hit Enter, Docker will download Docker Hub.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按 Enter 键后，Docker 将下载 Docker Hub。
- en: Then it will start the container in the VM, using Docker Toolbox on non-Linux
    systems.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它将在虚拟机中使用 Docker Toolbox 在非 Linux 系统上启动容器。
- en: The `hello-world` image comes from the public registry called Docker Hub as
    mentioned before (which you can visit at [https://hub.docker.com/r/library/hello-world/](https://hub.docker.com/r/library/hello-world/)).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`hello-world` 镜像来自名为 Docker Hub 的公共注册表（你可以在 [https://hub.docker.com/r/library/hello-world/](https://hub.docker.com/r/library/hello-world/)
    访问）。
- en: Dockerfile example
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile 示例
- en: 'Every image is composed of a Dockerfile. An example Dockerfile for the `hello-world`
    example looks like the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每个镜像都由一个 Dockerfile 组成。`hello-world` 示例的 Dockerfile 看起来如下所示：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A Dockerfile is a set of instructions that tell Docker how to build a container
    image. We will create our own in a moment. An analogy for a Dockerfile can be
    the Bash language that you can use on any Linux/Unix machine. Of course, it's
    different, but the general idea of writing instructions to create the job is similar.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile是一组指令，告诉Docker如何构建容器镜像。我们将在稍后创建自己的。Dockerfile的一个类比可以在任何Linux/Unix机器上使用的Bash语言。当然，它不同，但编写指令以创建工作的总体思想是相似的。
- en: Modifications to our codebase in order to create it
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为了创建它，我们需要对我们的代码库进行修改
- en: Currently, we are sure that our Docker application's setup is working correctly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们确信我们的Docker应用程序的设置是正确的。
- en: First of all, we need to make some modifications to our current codebase as
    there are small tweaks to make it work properly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要对我们的当前代码库进行一些修改，因为有一些小的调整才能使其正常工作。
- en: Make sure that the following files have the proper content.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 确保以下文件具有适当的内容。
- en: 'The `server/.env` file''s content has to be as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`server/.env`文件的内容必须如下：'
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For now, we will load the environment variables from a file, but later we will
    load them from the AWS panel. It's not really production-secure to keep all that
    secret data on the server. We use it now for the sake of brevity; later, we'll
    delete it in favor of a more secure approach.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从文件中加载环境变量，但稍后我们将从AWS面板加载它们。将所有这些机密数据保留在服务器上并不真正符合生产安全。我们现在是出于简洁的考虑使用它；稍后，我们将删除它，转而采用更安全的方法。
- en: Regarding the Mongo environment variables, we learned them in the previous chapter
    about setting up mLab (get to back to the chapter if you missed any of the details
    required at this point).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Mongo环境变量，我们在上一章关于设置mLab（如果遗漏了此点所需的任何细节，请回到该章节）中学习了它们。
- en: 'The `server/index.js` file''s content has to be as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`server/index.js`文件的内容必须如下：'
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Make sure you are loading `.env` from the file at the beginning of `server/index.js`.
    It will be required in order to load the mLab Mongo details from the environment
    variables (`server/.env`).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你在`server/index.js`的开始处加载`.env`文件。这将是为了从环境变量（`server/.env`）中加载mLab Mongo详细信息所必需的。
- en: 'The `server/configMongoose.js` file''s content has to be replaced. Find the
    following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`server/configMongoose.js`文件的内容必须替换。找到以下代码：'
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The new version of the same improved code has to be as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 同样改进的代码的新版本必须如下：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we have added the ability to connect with a specific DB's user.
    We need it because the localhost on which we were working didn't require any user,
    but when we start using the mLab MongoDB, then specifying our database's user
    is a must. Otherwise, we won't be able to authenticate correctly.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们增加了连接到特定数据库用户的可能性。我们需要它，因为我们之前工作的localhost不需要任何用户，但当我们开始使用mLab MongoDB时，指定我们的数据库用户是必须的。否则，我们无法正确认证。
- en: From this point, you don't need to run the `mongod` process in the background
    of your system, because the app will connect with the mLab MongoDB node that you
    created in the previous chapter. The mLab MongoDB (free version) runs 24/7, but
    if you plan to use it for production-ready apps, then you need to update it and
    start using the replica set feature as well (which was mentioned in the previous
    chapter).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，你不需要在你的系统后台运行`mongod`进程，因为应用程序将连接到你在上一章中创建的mLab MongoDB节点。mLab MongoDB（免费版）全天候运行，但如果计划将其用于生产就绪应用程序，那么你需要更新它并开始使用副本集功能（这在上一章中已提及）。
- en: 'You can try to run the project with this command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试使用以下命令运行项目：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then you should be able to load the app:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你应该能够加载应用程序：
- en: '![](img/00099.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00099.jpeg)'
- en: The important difference now is that all the CRUD operations (read/write via
    our publishing app) are done on our remote MongoDB (not on the local one).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的重要区别是，所有的CRUD操作（通过我们的发布应用程序的读写）都是在我们的远程MongoDB（而不是本地）上完成的。
- en: After the publishing app uses the mLab MongoDB, we are ready to prepare our
    Docker image and then deploy it on several instances of AWS EC2 with AWS Load
    Balancer and EC2 Container Service.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布应用程序使用mLab MongoDB之后，我们就可以准备我们的Docker镜像，然后使用AWS Load Balancer和EC2 Container
    Service在AWS EC2的几个实例上部署它。
- en: Working on the publishing app Docker image
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在发布应用程序的Docker镜像上工作
- en: Before continuing, you should be able to run your project locally by using remote
    mLab MongoDB. It's required because we will start running our publishing app in
    the Docker container. Our app will then connect with Mongo remotely. We won't
    run any MongoDB process in any Docker container. This is why it's so important
    to use mLab in the following steps.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您应该能够通过使用远程mLab MongoDB来在本地运行您的项目。这是必需的，因为我们将在Docker容器中启动我们的发布应用。然后我们的应用将远程连接到Mongo。我们不会在任何一个Docker容器中运行任何MongoDB进程。这就是为什么在以下步骤中使用mLab如此重要的原因。
- en: 'Let''s create the Dockerfile by executing the following command in a terminal/command
    line:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在终端/命令行中执行以下命令来创建Dockerfile：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Enter the following content in your new Dockerfile:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的新Dockerfile中输入以下内容：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s look step by step at the Dockerfile we are going to use in our publishing
    app together with Docker:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地看看我们将要在我们的发布应用中与Docker一起使用的Dockerfile：
- en: '`FROM centos:centos7`: This says that we will use as a starting point the CentOS
    7 Linux distribution from the [https://hub.docker.com/r/_/centos/](https://hub.docker.com/r/_/centos/)
    public Docker repository.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM centos:centos7`：这意味着我们将使用来自[https://hub.docker.com/r/_/centos/](https://hub.docker.com/r/_/centos/)公共Docker仓库的CentOS
    7 Linux发行版作为起点。'
- en: You can use any other package as a starting point, such as Ubuntu, but we are
    using CentOS 7 because it's more lightweight and generally very good for web app
    deployment. You can find further details at [https://www.centos.org/](https://www.centos.org/).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任何其他包作为起点，例如Ubuntu，但我们使用CentOS 7，因为它更轻量级，并且通常非常适合Web应用部署。您可以在[https://www.centos.org/](https://www.centos.org/)找到更多详细信息。
- en: Documentation of all commands is available at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所有命令的文档可在[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)找到。
- en: '`RUN yum update -y`: This updates packages from the command line with `yum--`standard
    for any Linux setup.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN yum update -y`：这通过命令行使用`yum--`更新包，这是任何Linux设置的常规做法。'
- en: '`RUN yum install -y tar wget`: This installs two packages as `tar` (for unpacking
    files) and `wget` (for downloading files).'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN yum install -y tar wget`：这安装了两个包作为`tar`（用于解压文件）和`wget`（用于下载文件）。'
- en: '`RUN wget -q https://nodejs.org/dist/v4.0.0/node-v4.0.0-linux-x64.tar.gz -O
    - | tar xzf - -C /opt/*`: This command downloads `node4.0.0` to our CentOS container,
    unpacks it, and puts all the files into the `/opt/` directory.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN wget -q https://nodejs.org/dist/v4.0.0/node-v4.0.0-linux-x64.tar.gz -O
    - | tar xzf - -C /opt/*`：这个命令将`node4.0.0`下载到我们的CentOS容器中，解压它，并将所有文件放入`/opt/`目录。'
- en: '`RUN mv /opt/node-v /opt/node*`: This renames the folder we just downloaded
    and unpacked (with `node`) to simply `node` without version naming.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN mv /opt/node-v /opt/node*`：这会将我们刚刚下载并解压的文件夹（带有`node`）重命名为不带版本命名的简单`node`。'
- en: '`RUN ln -s /opt/node/bin/node /usr/bin/node`: We are linking the `/opt/node/bin/node`
    location with a `/usr/bin/node` link, so we are able to use a simple `$ node`
    command in the Terminal. This is standard stuff for Linux users.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN ln -s /opt/node/bin/node /usr/bin/node`：我们将`/opt/node/bin/node`位置与`/usr/bin/node`链接链接起来，这样我们就能在终端中使用简单的`$
    node`命令。这是Linux用户的常规做法。'
- en: '`RUN ln -s /opt/node/bin/npm /usr/bin/npm`: The same as with `node`, but with
    `npm`. We are linking it in order to make usage easier and linking it to `$ npm`
    on our CentOS 7.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN ln -s /opt/node/bin/npm /usr/bin/npm`：与`node`相同，但与`npm`。我们将其链接起来，以便更容易使用，并将其链接到我们的CentOS
    7上的`$ npm`。'
- en: '`COPY . /opt/publishing-app/`: This copies all the files in the context (The
    `.` (dot) sign is the location when you start the container build. We will do
    that in a moment.) It copies all the files into the `/opt/publishing-app/` location
    in our container.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY . /opt/publishing-app/`：这会将上下文中的所有文件复制（`.`（点）符号是启动容器构建时的位置。我们将在稍后进行操作。）它将所有文件复制到我们的容器中`/opt/publishing-app/`位置。'
- en: In our case, we have created the Dockerfile in our publishing app's directory,
    so it will copy all the project files in the container to the given location at
    `/opt/publishing-app/`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们在发布应用的目录中创建了Dockerfile，因此它将容器中的所有项目文件复制到指定的位置`/opt/publishing-app/`。
- en: '`WORKDIR /opt/publishing-app`: After we have our publishing app''s files in
    our Docker container, we need to choose the working directory. It''s similar to
    `$ cd /opt/publishing-app` on any Unix/Linux machine.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKDIR /opt/publishing-app`：在我们将发布应用的文件放入我们的Docker容器后，我们需要选择工作目录。它类似于在任何Unix/Linux机器上的`$
    cd /opt/publishing-app`。'
- en: '`RUN npm install`: When we are in our working directory, which is `/opt/publishing-app`,
    then we run the standard `npm install` command.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN npm install`: 当我们在工作目录 `/opt/publishing-app` 中时，我们运行标准的 `npm install`
    命令。'
- en: '`RUN yum clean all`: We clean the `yum` cache.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN yum clean all`: 我们清理 `yum` 缓存。'
- en: '`EXPOSE 80`: We define the port that is using our publishing application.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPOSE 80`: 我们定义了使用我们的发布应用程序的端口。'
- en: '`CMD ["npm", "start"]`: Then, we specify how to run the application in our
    Docker container.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD ["npm", "start"]`: 然后，我们指定如何在 Docker 容器中运行应用程序。'
- en: 'We will also create in the main project directory, a `.dockerignore` file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在主项目目录中创建一个 `.dockerignore` 文件：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The file content will be as following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 文件内容如下：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We don't want to copy over the mentioned files `(.DS_Store` is specific to OS
    X).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想复制提到的文件（`.DS_Store` 是针对 OS X 的特定文件）。
- en: Building the publishing app container
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建发布应用程序容器
- en: Currently, you will be able to build the Docker's container.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你将能够构建 Docker 的容器。
- en: 'In the main directory of the project, you need to run the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目主目录中，你需要运行以下命令：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `login` command will prompt you to insert your Docker username and password.
    After you are authenticated correctly, you can run the `build` command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`login` 命令将提示你输入 Docker 用户名和密码。认证正确后，你可以运行 `build` 命令：'
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Of course, the username and the container name combination has to be yours.
    Replace it with your details.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，用户名和容器名称组合必须是你的。用你的详细信息替换它。
- en: 'That preceding command will build the container with the use of Dockerfile
    commands. This is what you will see (step 1, step 2, and so on):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将使用 Dockerfile 命令构建容器。这是你将看到的内容（步骤 1，步骤 2 等）：
- en: '![](img/00100.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00100.jpeg)'
- en: 'After a successful build, you will see in your Terminal/command line something
    similar to this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 构建成功后，你将在你的终端/命令行中看到类似以下的内容：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see here from the Docker Terminal, we have built a container in a
    successful manner. The next step is to test it locally and then learn a little
    bit more of Docker's basics and finally start working on our AWS deployment.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从 Docker 终端中看到的那样，我们已经成功构建了一个容器。下一步是本地测试它，然后学习一些 Docker 的基础知识，最后开始我们的 AWS
    部署工作。
- en: Running the publishing app container locally
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地运行发布应用程序容器
- en: In order to test whether the container has been built correctly, perform the
    following steps.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试容器是否已正确构建，请执行以下步骤。
- en: 'Run this command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding command will give you output similar to this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将给出类似以下的内容：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We are looking for the `DOCKER_HOST` IP address; in this case, it's `192.168.99.100`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在寻找 `DOCKER_HOST` IP 地址；在这种情况下，它是 `192.168.99.100`。
- en: This Docker host IP will be used to check whether our application is running
    correctly in the container. Note it down.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Docker 主机 IP 将用于检查我们的应用程序是否在容器中正确运行。记下来。
- en: 'The next step is to run our local container with the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用以下命令运行我们的本地容器：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Regarding flags: the `d` flag stands for "detached," so the process will run
    in the background. You can list all running Docker processes with the following
    command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 关于标志：`d` 标志代表 "分离"，因此进程将在后台运行。你可以使用以下命令列出所有正在运行的 Docker 进程：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'An example output would be as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例输出如下：
- en: '![](img/00101.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00101.jpeg)'
- en: The `-p` flag is telling us that the container's port `80` is bound to port
    `80` on the Docker IP host. So if we expose our Node app on port `80` in the container,
    then it will be able to run on a standard port `80` on the IP (in the examples,
    it will be `192.168.99.100:80`; obviously, port `80` is for all HTTP requests).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p` 标志告诉我们容器的端口 `80` 绑定到 Docker IP 主机的端口 `80`。因此，如果我们将在容器中将 Node 应用程序暴露在端口
    `80` 上，那么它将能够在 IP 地址的标准端口 `80` 上运行（在示例中，它将是 `192.168.99.100:80`；显然，端口 `80` 是用于所有
    HTTP 请求的）。'
- en: The `przeor/pub-app-docker` command will specify the name of the container that
    we want to run.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`przeor/pub-app-docker` 命令将指定我们想要运行的容器名称。'
- en: With `npm start`, we tell which command we want to run in the Docker container
    right after starting (otherwise, the container would run and stop immediately).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `npm start`，我们告诉 Docker 容器启动后要运行的命令（否则，容器将立即启动并停止）。
- en: More references about `docker run` are available at [https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `docker run` 的更多参考资料可在 [https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/)
    找到。
- en: 'The preceding command will run the app, as shown in the following screenshot:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将运行应用程序，如下面的截图所示：
- en: '![](img/00102.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00102.jpeg)'
- en: As you can see, the IP address in the browser's URL bar is http://192.168.99.100\.
    It's our Docker host IP.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，浏览器 URL 栏中的 IP 地址是 http://192.168.99.100。这是我们的 Docker 主机 IP。
- en: Debugging a container
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器调试
- en: 'In case the container doesn''t work for you, like in the following screenshot,
    use the following command to debug and find the reason:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器对你不起作用，就像以下截图所示，请使用以下命令进行调试并找出原因：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This command with the `-i -t -p` flags will show you all the logs in the Terminal/command
    line, like in the following screenshot (this is just an example in order to show
    you the ability to debug a Docker container locally):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个带有 `-i -t -p` 标志的命令将在终端/命令行中显示所有日志，如下面的截图所示（这只是一个示例，以展示你可以在本地调试 Docker 容器的能力）：
- en: '![](img/00103.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00103.jpeg)'
- en: Pushing a Docker container to a remote repository
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Docker 容器推送到远程仓库
- en: If a container works for you locally, then it's almost ready for AWS deployment.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器在本地运行正常，那么它几乎就准备好进行 AWS 部署了。
- en: 'Before pushing the container, let''s add the `.env` file to`.dockerignore`,
    because you have in it all the sensitive data that you won''t put into containers.
    So, into the `.dockerignore` file, add the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在推送容器之前，让我们将 `.env` 文件添加到 `.dockerignore`，因为其中包含所有你不会放入容器中的敏感数据。因此，在 `.dockerignore`
    文件中，添加以下内容：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After you add `.env` to `.gitignore`, we need to change the `server/index.js`
    file and add an additional `if` statement:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 `.env` 文件添加到 `.gitignore` 之后，我们需要修改 `server/index.js` 文件并添加一个额外的 `if` 语句：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This `if` statement checks whether we're running the app locally (with an `.env`
    file) or remotely on an AWS instance (then we pass the `env` variables in a more
    secure manner).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `if` 语句检查我们是在本地运行应用程序（带有 `.env` 文件）还是在 AWS 实例上远程运行（然后我们以更安全的方式传递 `env` 变量）。
- en: 'After you have added the `.env` file into `.dockerignore` (and modified `server/index.js`),
    build the container that will be ready for the push:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 `.env` 文件添加到 `.dockerignore`（并修改 `server/index.js`）之后，构建好即将推送的容器：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Regarding the environment variables, we will add them via AWS advanced options.
    You will learn about this later, but to get a general idea of how to add them
    when running them on the localhost, check out the following example (fake data
    provided in the command''s flag):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 关于环境变量，我们将通过 AWS 高级选项添加它们。你将在稍后了解这一点，但为了了解如何在本地运行时添加它们，请查看以下示例（命令标志中提供了假数据）：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Make sure that you have provided your correct `AWS_REGION_NAME`. Mine is `eu-central-1`,
    but yours can be different.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经提供了正确的 `AWS_REGION_NAME`。我的是 `eu-central-1`，但你的可能不同。
- en: 'As you can see, everything from the `server/.env` file has been moved to the
    Docker run command in the Bash terminal:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`server/.env` 文件中的所有内容都已经移动到了 Bash 终端的 Docker 运行命令中：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can find here, the `-e` flag is for an `env` variable. The last thing
    is to push the container to the remote repository hosted by Docker Hub:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这里所示，`-e` 标志是用于 `env` 变量的。最后一步是将容器推送到由 Docker Hub 托管的远程仓库：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then you will be able to find in your Bash/command line something similar to
    the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将在你的 Bash/命令行中找到类似以下的内容：
- en: '![](img/00104.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00104.jpeg)'
- en: 'The link to the pushed repo will be similar to this one:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 推送仓库的链接将与以下类似：
- en: '![](img/00105.jpeg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00105.jpeg)'
- en: The preceding screenshot has been made from the pushed Docker repository.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图是从推送的 Docker 仓库制作的。
- en: A summary of useful Docker commands
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用 Docker 命令的总结
- en: 'The following are a few useful Docker commands:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些有用的 Docker 命令：
- en: 'This command will list all the images, and `docker rm` can delete the repo
    from your local machine in case you want to delete it:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个命令将列出所有镜像，如果需要从你的本地机器删除仓库，可以使用 `docker rm`：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can use just the first three characters from `CONTAINER-ID`. You don't need
    to write down whole container ID. This is a convenience.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `CONTAINER-ID` 的前三个字符。你不需要写下整个容器 ID。这是一个便利。
- en: 'This one is used for stopping a running Docker container:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个命令用于停止正在运行的 Docker 容器：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can use version tag of your containers with the following approach:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用以下方法使用容器的版本标签：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After you have listed the Docker images, you may notice that you have two containers,
    one with the tag `latest` and the other with `0.1`. This is a way to track changes,
    because if you push the container, the tag will also be listed on Docker Hub.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列出 Docker 镜像后，你可能注意到你有两个容器，一个带有 `latest` 标签，另一个带有 `0.1` 标签。这是一种跟踪更改的方式，因为如果你推送容器，标签也会在
    Docker Hub 上列出。
- en: 'Check your container''s local IP:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查容器的本地 IP：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Build your container from a Dockerfile:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Dockerfile构建你的容器：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Run your container in "detached" mode:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以“分离”模式运行你的容器：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run your container to debug it without detaching it so that you can find what
    is going on in the container''s Bash terminal:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行你的容器以调试它，而不将其分离，这样你就可以在容器的Bash终端中找到正在发生的事情：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Introduction to Docker on AWS EC2
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS EC2上的Docker简介
- en: Two chapters ago, we implemented Amazon AWS S3 for static image uploading. You
    should already have an AWS account, so you are ready for the following steps to
    create our deployment on AWS.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在两章之前，我们实现了亚马逊AWS S3用于静态图像上传。你应该已经有了AWS账户，因此你已准备好进行以下步骤以在AWS上创建我们的部署。
- en: In general, you can use the steps with free AWS tiers, but we will use the paid
    version in this tutorial. Read the AWS EC2 pricing before starting this section
    on how to deploy Docker containers on AWS.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以使用免费AWS层级的步骤，但在这个教程中，我们将使用付费版本。在开始本节关于如何在AWS上部署Docker容器的部分之前，请阅读AWS EC2定价。
- en: AWS also has great Docker container support with their service called **EC2
    Container Service** (**ECS**).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: AWS还通过其名为**EC2容器服务**（**ECS**）的服务提供了对Docker容器的强大支持。
- en: If you bought this book, it probably means you haven't been using AWS so far.
    Because of this, we will first deploy Docker manually on EC2 in order to show
    you how the EC2 instances work so that you can get more knowledge from the book.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你购买了这本书，这可能意味着你之前还没有使用过AWS。因此，我们将首先在EC2上手动部署Docker，以便向你展示EC2实例的工作原理，这样你就可以从这本书中获得更多知识。
- en: Our main goal is to make the deployment of our Docker containers automatic,
    but for now, we will start with a manual approach. If you have already used EC2,
    you can skip the next subsection and go straight to ECS.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要目标是使我们的Docker容器部署自动化，但现在是手动方法。如果你已经使用过EC2，你可以跳过下一个子节，直接进入ECS。
- en: Manual approach - Docker on EC2
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动方法 - EC2上的Docker
- en: 'We were running our Docker container locally with the following command (a
    few pages previously):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前（几页之前）使用以下命令在本地运行我们的Docker容器：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We will do the same thing, not locally but on the EC2 instance, 100% manually
    for now; later, we will do it 100% automatically with AWS ECS.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将做同样的事情，但不是在本地，而是在EC2实例上，现在100%手动；稍后，我们将使用AWS ECS 100%自动完成。
- en: Before we continue, let's understand what EC2 is. It's a scalable computing
    capacity located in the Amazon Web Services cloud. In EC2, you don't need to invest
    money upfront in buying any hardware. Everything you pay is for the time spent
    using an EC2 instance. This allows you to deploy applications faster. Very quickly,
    you can add new virtual servers (when there is a bigger web traffic demand). There
    are some mechanisms to scale the number of EC2 instances automatically with the
    use of **AWS CloudWatch**. Amazon EC2 gives you the ability to scale up or down
    to handle changed requirements (such as spikes in popularity)--this feature reduces
    your need to forecast traffic (and saves you time and money).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们了解什么是EC2。它位于亚马逊网络服务云中的可扩展计算能力。在EC2中，你不需要预先投资购买任何硬件。你所支付的一切都是为了使用EC2实例所花费的时间。这允许你更快地部署应用程序。非常快，你就可以添加新的虚拟服务器（当有更大的网络流量需求时）。有一些机制可以自动使用**AWS
    CloudWatch**来扩展EC2实例的数量。亚马逊EC2让你能够根据变化的需求（如流行度的激增）进行扩展或缩减，这个功能减少了你需要预测流量的需求（并为你节省时间和金钱）。
- en: For now, we will use only one EC2 instance (later in the book, we will see more
    EC2 instances with load balancers and ECS).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只将使用一个EC2实例（在本书的后面部分，我们将看到带有负载均衡器和ECS的更多EC2实例）。
- en: Basics - launching an EC2 instance
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础 - 启动EC2实例
- en: We will launch an EC2 instance, then log in to it via SSH (you can use **Putty**
    on Windows OS).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将启动一个EC2实例，然后通过SSH登录到它（在Windows操作系统上，你可以使用**PuTTY**）。
- en: 'Log in to AWS Console by visiting this link: [https://eu-central-1.console.aws.amazon.com/console/home](https://eu-central-1.console.aws.amazon.com/console/home).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问此链接登录AWS控制台：[https://eu-central-1.console.aws.amazon.com/console/home](https://eu-central-1.console.aws.amazon.com/console/home)。
- en: 'Click on the EC2 link: [https://eu-central-1.console.aws.amazon.com/ec2/v2/home](https://eu-central-1.console.aws.amazon.com/ec2/v2/home)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 点击EC2链接：[https://eu-central-1.console.aws.amazon.com/ec2/v2/home](https://eu-central-1.console.aws.amazon.com/ec2/v2/home)
- en: 'Then click on the blue Launch Instance button:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后点击蓝色的“启动实例”按钮：
- en: '![](img/00106.jpeg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00106.jpeg)'
- en: 'The button looks like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮看起来是这样的：
- en: '![](img/00107.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00107.jpeg)'
- en: 'After you click on the button, you will be redirected to the **Amazon Machine
    Image** (**AMI**) page:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮后，你将被重定向到**亚马逊机器镜像**（**AMI**）页面：
- en: '![](img/00108.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00108.jpeg)'
- en: 'The AMI has a list of images that you can run an EC2 instance with. Each image
    has a list of preinstalled software. For example, the most standard image is the
    following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: AMI有一个可以运行EC2实例的镜像列表。每个镜像都有一个预安装软件列表。例如，最标准的镜像如下：
- en: '![](img/00109.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00109.jpeg)'
- en: It has preinstalled software; for example, the Amazon Linux AMI is an EBS-backed,
    AWS-supported image. The default image includes AWS command-line tools, Python,
    Ruby, Perl, and Java. The repositories include Docker, PHP, MySQL, PostgreSQL,
    and other packages.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 它已预安装了软件；例如，Amazon Linux AMI是一个基于EBS、AWS支持的镜像。默认镜像包括AWS命令行工具、Python、Ruby、Perl和Java。仓库包括Docker、PHP、MySQL、PostgreSQL和其他包。
- en: 'On the same page, you can also find other AMIs to buy on the marketplace or
    created and shared by the community for free. You can also filter the images so
    that it will list only the free tier:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一页面上，您还可以找到市场上可购买的或其他社区免费创建和共享的其他AMIs。您还可以过滤镜像，使其仅列出免费层：
- en: '![](img/00110.jpeg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00110.jpeg)'
- en: For the sake of making this step-by-step guide simple, let's choose the image
    that is in the preceding screenshot; its name will be similar to `Amazon Linux
    AMI 2016.03.3 (HVM), SSD Volume Type`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个逐步指南简单，让我们选择前一个截图中的镜像；其名称将与`Amazon Linux AMI 2016.03.3 (HVM), SSD Volume
    Type`类似。
- en: The name of the image may slightly vary; don't worry about it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像的名称可能略有不同；无需担心。
- en: 'Click on the blue Select button. Then you will be transferred to the Step 2:
    Choose an Instance Type page, as shown in the following screenshot:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 点击蓝色选择按钮。然后您将被转到第2步：选择实例类型页面，如下截图所示：
- en: '![](img/00111.jpeg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00111.jpeg)'
- en: 'From this page, select the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从此页面，选择以下内容：
- en: '![](img/00112.jpeg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00112.jpeg)'
- en: 'Then, click on this button:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击此按钮：
- en: '![](img/00113.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00113.jpeg)'
- en: 'The simplest method is to choose the default options:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是选择默认选项：
- en: Review.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查。
- en: Configure security group (we will make some changes in this tab).
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置安全组（我们将在此选项卡中进行一些更改）。
- en: Tag instance (keep the options default).
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标记实例（保持默认选项）。
- en: Add storage (keep the options default).
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加存储（保持默认选项）。
- en: Configure the instance (keep the options default).
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置实例（保持默认选项）。
- en: Choose an instance type.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择实例类型。
- en: Choose an AMI.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个AMI。
- en: Generally, keep clicking on the next button until we get to the Configure security.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，一直点击下一个按钮，直到我们到达配置安全组。
- en: 'An indicator of progress you can find at the top is this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在顶部找到的进度指示器如下：
- en: '![](img/00114.jpeg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00114.jpeg)'
- en: 'Our goal for now is to get to the security configuration page because we need
    to customize slightly the allowed ports. A security group consists of rules that
    control network traffic for an EC2 instance (a.k.a. firewall options). For security,
    set the name to `ssh-and-http-security-group`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的目标是到达安全配置页面，因为我们需要稍微自定义允许的端口。安全组由控制EC2实例（即防火墙选项）网络流量的规则组成。为了安全起见，将名称设置为`ssh-and-http-security-group`：
- en: '![](img/00115.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00115.jpeg)'
- en: As you can find here, you also need to click on the Add Rule button and add
    a new one called HTTP. This will allow our new EC2 instance to be available via
    port 80 for all the IPs.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在此处可以看到，您还需要点击添加规则按钮并添加一个名为HTTP的新规则。这将允许我们的新EC2实例通过端口80对所有IP地址可用。
- en: 'After you have added the name and HTTP port 80 as the new rule, you can click
    on the Review and Launch button:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在您添加了名称并将HTTP端口80作为新规则后，您可以点击审查和启动按钮：
- en: '![](img/00116.jpeg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00116.jpeg)'
- en: 'Then, after you are happy with reviewing the instance, click on the blue button
    called Launch in that view:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在您满意审查实例后，点击该视图中的蓝色按钮“启动”：
- en: '![](img/00117.jpeg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00117.jpeg)'
- en: 'After you click on the Launch button, you will see a modal that says Select
    an existing key pair or create a new key pair:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在您点击启动按钮后，您将看到一个模态窗口，提示选择现有的密钥对或创建新的密钥对：
- en: '![](img/00118.jpeg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00118.jpeg)'
- en: 'Usually, you''ll need to create a new key pair. Give it the name `pubapp-ec2-key-pair`
    and then click on the Download button, as shown in the following screenshot:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您需要创建一个新的密钥对。将其命名为`pubapp-ec2-key-pair`，然后点击下载按钮，如下截图所示：
- en: '![](img/00119.jpeg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00119.jpeg)'
- en: 'After you have downloaded `pubapp-ec2-key-pai`, you will be able to click on
    the blue Launch button. Next, you will see the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在您下载了`pubapp-ec2-key-pai`后，您将能够点击蓝色启动按钮。接下来，您将看到以下内容：
- en: '![](img/00120.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00120.jpeg)'
- en: 'From this screen, you can go directly to the EC2 launch logs (click on the
    View launch log link) so that you will be able to find your instance listed, as
    seen in the following screenshot:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 从此屏幕，您可以直接转到 EC2 启动日志（点击查看启动日志链接），这样您就可以找到您的实例，如下面的截图所示：
- en: '![](img/00121.jpeg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/00121.jpeg)'
- en: Great. Your first EC2 has been launched successfully! We need to log in to it
    and set up the Docker container from there.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了。您的第一个 EC2 已经成功启动！我们需要登录到它，并从那里设置 Docker 容器。
- en: Save the public IP of your EC2 instance. In the preceding launch log, you can
    find that the machine we've just created has the public IP 52.29.107.244.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 保存您 EC2 实例的公网 IP。在之前的启动日志中，您可以找到我们刚刚创建的机器的公网 IP 为 52.29.107.244。
- en: Your IP will be different (of course, this is just an example). Save it somewhere;
    we will use it in a moment as you'll need it to log in via SSH to the server and
    install the Docker app.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 IP 将不同（当然，这只是一个示例）。将其保存在某处；我们将在稍后使用它，因为您需要它通过 SSH 登录到服务器并安装 Docker 应用程序。
- en: SSH access via PuTTy - Windows users only
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PuTTy 通过 SSH 访问 - 仅限 Windows 用户
- en: If you don't work on Windows, you can skip this subsection.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不在 Windows 上工作，您可以跳过本节。
- en: We'll be using PuTTy, which is available for download at [http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html](http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html)
    (`putty.exe`, `pageant.exe`, and `puttygen.exe`).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 PuTTy，它可以在[http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html](http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html)下载（`putty.exe`、`pageant.exe`和`puttygen.exe`）。
- en: 'Download key pairs for the EC2 instance, and convert them to `ppk` using `puttygen.exe`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 下载 EC2 实例的密钥对，并使用`puttygen.exe`将其转换为`ppk`：
- en: '![](img/00122.jpeg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/00122.jpeg)'
- en: Click on the Load button and choose the `pubapp-ec2-key-pair.pem` file, and
    then covert it to `ppk`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“加载”按钮并选择`pubapp-ec2-key-pair.pem`文件，然后将其转换为`ppk`。
- en: 'Then you need to click on the Save private key button. You are done; you can
    close `puttygen.exe` and open `pageant.exe`. From it, do the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您需要点击“保存私钥”按钮。您已经完成了；您可以关闭`puttygen.exe`并打开`pageant.exe`。从它，您需要做以下操作：
- en: Choose Add Key
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择“添加密钥”
- en: Then check whether your key has been added correctly to the Pageant key list
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后检查您的密钥是否已正确添加到 Pageant 密钥列表
- en: If your private key is on the list, you are ready to use `putty.exe`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的私钥在列表中，您就可以使用`putty.exe`了。
- en: '![](img/00123.jpeg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图片5](img/00123.jpeg)'
- en: If you have opened the PuTTy program, you need to log in via SSH by typing your
    EC2 instance IP and clicking on the Open button, as shown in the preceding screenshot.
    PuTTy allows using SSH connections on Windows.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经打开了 PuTTy 程序，您需要通过 SSH 输入您的 EC2 实例 IP 并点击打开按钮，如前面的截图所示。PuTTy 允许在 Windows
    上使用 SSH 连接。
- en: Connecting to an EC2 instance via SSH
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 SSH 连接到 EC2 实例
- en: 'In a previous chapter, after we launched the EC2 instance, we found out our
    public IP (remember that your public IP will be different): `52.29.107.244`. We
    need to connect to the remote EC2 instance with this public IP.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，在我们启动 EC2 实例后，我们找到了我们的公网 IP（记住您的公网 IP 将不同）：`52.29.107.244`。我们需要使用这个公网
    IP 连接到远程 EC2 实例。
- en: 'I''ve saved `pubapp-ec2-key-pair.pem` in my `Downloads` directory, so go to
    the directory where you have downloaded your `.pem` file:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将`pubapp-ec2-key-pair.pem`保存在我的`下载`目录中，所以请转到您下载`.pem`文件的目录：
- en: '[PRE34]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In PuTTy on Windows, it will look similar after this step. You need to provide
    in the PuTTy box the IP and ports in order to correctly log in to the machine.
    When you get a prompt to type a username, use `ec2-user`, as in the SSH example.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 的 PuTTy 中，完成此步骤后，界面将与此类似。您需要在 PuTTy 窗口中提供 IP 和端口，以便正确登录到机器。当您收到输入用户名的提示时，请使用`ec2-user`，就像
    SSH 示例中那样。
- en: 'After a successful login, you will be able to see this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 登录成功后，您将能够看到以下内容：
- en: '![](img/00124.jpeg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图片3](img/00124.jpeg)'
- en: 'The following instructions are for all OS users (OS X, Linux, and Windows)
    as we are logged in to the EC2 instance via SSH. The following commands are required
    next:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下说明适用于所有操作系统用户（OS X、Linux 和 Windows），因为我们是通过 SSH 登录到 EC2 实例的。以下命令是必需的：
- en: '[PRE35]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'These commands will update the `yum` package manager and install and start
    the Docker service in the background:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令将更新`yum`包管理器，并在后台安装和启动 Docker 服务：
- en: '[PRE36]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After you run the `docker info` command, it will show something similar to
    the following output:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在您运行`docker info`命令后，它将显示类似于以下输出的内容：
- en: '![](img/00125.jpeg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片4](img/00125.jpeg)'
- en: 'If you look at the preceding screenshot, you''ll see that everything is all
    right, and we can continue with running the publishing app''s Docker container
    with the following command:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看前面的截图，你会看到一切正常，我们可以继续使用以下命令运行发布应用的Docker容器：
- en: '[PRE37]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Make sure you have provided your correct `AWS_REGION_NAME`. Mine is `eu-central-1`,
    but yours could be different.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经提供了正确的`AWS_REGION_NAME`。我的设置为`eu-central-1`，但你的可能不同。
- en: 'As you can see, everything from the `server/.env` file has been moved to the
    `docker run` command in the Bash terminal:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，从`server/.env`文件中的所有内容都已经移动到了Bash终端中的`docker run`命令中：
- en: '[PRE38]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Also make sure to rename `AWS_BUCKET_NAME`, `AWS_REGION_NAME`, or `MONGO_ENV`
    if you have a different one (if you set it differently than what was suggested
    in the previous chapters).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，如果你有不同的设置，请确保重命名`AWS_BUCKET_NAME`、`AWS_REGION_NAME`或`MONGO_ENV`（如果你设置得与上一章中建议的不同）。
- en: 'Then, in order to check whether everything went well, you can also use the
    following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了检查一切是否顺利进行，你也可以使用以下命令：
- en: '[PRE39]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This command will show you whether the Docker process runs correctly in the
    background as a detached container. And after 10-30 seconds, when `npm start`
    will run the whole project, you can test with this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将显示Docker进程是否作为分离容器在后台正确运行。在10-30秒后，当`npm start`运行整个项目时，你可以用以下命令进行测试：
- en: '[PRE40]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After the application has been bootstraped correctly, you can see output similar
    to the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序正确引导之后，你可以看到类似以下输出：
- en: '![](img/00126.jpeg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00126.jpeg)'
- en: 'After you visit the EC2 instance''s public IP (in our example, it is `52.29.107.244`),
    you will be able to find our publishing app available online as we have set up
    the security group of our EC2 instance with the exposed port `80` to the world.
    The following is the screenshot:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在你访问EC2实例的公网IP（在我们的例子中，它是`52.29.107.244`）之后，你将能够找到我们已在线设置的发布应用。以下是一个截图：
- en: '![](img/00127.jpeg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00127.jpeg)'
- en: If you see our publishing app under a public IP, then you have just deployed
    a Docker container on Amazon AWS EC2 successfully!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到我们的发布应用在公网IP下，那么你就已经成功地在Amazon AWS EC2上部署了一个Docker容器！
- en: The process we just went through is very inefficient and manual, but shows exactly
    what is going on under the hood when we start using ECS.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才经历的过程非常低效且手动，但它确切地展示了当我们开始使用ECS时幕后发生了什么。
- en: 'We are missing the following in our current approach:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在当前的方法中缺少以下内容：
- en: Integration with other Amazon services, such as load balancing, monitoring,
    alerting, crash recovery, and route 53.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他Amazon服务的集成，例如负载均衡、监控、警报、故障恢复和route 53。
- en: Automation, as currently we are unable to efficiently deploy 10 Docker containers
    quickly. This is also important if you want to deploy different Docker containers
    for different services as, for example, you can have separate containers for serving
    the frontend, backend, and even the database (in our case, we use mLab, so we
    don't need one here).
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化，因为我们目前无法高效地快速部署10个Docker容器。如果你想要为不同的服务部署不同的Docker容器，这也同样重要，例如，你可以为前端、后端甚至数据库（在我们的案例中，我们使用mLab，因此这里不需要）分别设置容器。
- en: You've just learned the basics of Amazon Web Services.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学习了Amazon Web Services的基础知识。
- en: Basics of ECS - AWS EC2
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ECS的基础 - AWS EC2
- en: The EC2 Container Service helps you create a cluster of Docker Container instances
    (many copies of the same container on several EC2 instances). Each container is
    deployed automatically--this means you don't need to log in to any of the EC2
    instances via SSH as we did it in the previous chapter (manual approach). The
    whole job is done by the AWS and Docker software, which you will learn to use
    in the future (a more automated approach).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: EC2容器服务可以帮助你创建一个Docker容器实例的集群（在多个EC2实例上运行相同容器的多个副本）。每个容器都会自动部署--这意味着你不需要通过SSH登录到任何EC2实例，就像我们在上一章中做的那样（手动方法）。整个工作都由AWS和Docker软件完成，你将在未来学习如何使用它们（一种更自动化的方法）。
- en: For example, you set that you want to have five different EC2 instances--the
    group of EC2 instances in the exposed port 80 so you are able to find the publishing
    application under the `http://[[EC2_PUBLIC_IP]]` address. Additionally, we are
    adding a load balancer between all the EC2 instances and the rest of the world
    so that in case there is any spike in traffic or any of the EC2 instances break,
    the load balancer will replace the broken EC2 instance with a new one or scale
    down/up the number of EC2 instances based on the traffic.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您设置想要拥有五个不同的EC2实例——在公开端口80上的EC2实例组，这样您就能在`http://[[EC2_PUBLIC_IP]]`地址下找到发布的应用程序。此外，我们在所有EC2实例和外部世界之间添加了一个负载均衡器，以便在流量激增或任何EC2实例出现故障的情况下，负载均衡器将用新的实例替换故障的EC2实例，或根据流量调整EC2实例的数量。
- en: A great feature of the AWS load balancer is that it pings each EC2 instance
    with port 80, and if the pinged instance doesn't respond with the correct code
    (200), then it terminates the broken instance and turns on a fresh new instance
    with the Docker Container that has the image of our publishing app. This helps
    us maintain continuous availability of our application.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: AWS负载均衡器的一个出色功能是它会用端口80对每个EC2实例进行ping操作，如果被ping的实例没有以正确的代码（200）响应，那么它将终止故障实例并启动一个全新的带有我们发布应用镜像的Docker容器。这有助于我们保持应用的持续可用性。
- en: 'Additionally, we will use Amazon Route 53 in order to have a highly available
    and scalable cloud **domain name system** (**DNS**) web service so we will be
    able to set up a top level domain; in our case, I will use a domain I have bought
    specially for the book: `http://reactjs.space`.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将使用Amazon Route 53来拥有一个高度可用和可扩展的云**域名系统**（**DNS**）网络服务，这样我们就能设置一个顶级域名；在我们的案例中，我将使用我为这本书专门购买的域名：`http://reactjs.space`。
- en: That will be our HTTP address, of course. If you build a different service,
    you need to buy your own domain in order to follow the instructions and learn
    how Amazon Route 53 works.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，那将是我们的HTTP地址。如果您构建不同的服务，您需要购买自己的域名，以便遵循说明并了解Amazon Route 53的工作原理。
- en: Working with ECS
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ECS
- en: 'Before we start working on ECS, let''s understand some basic nomenclature:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用ECS之前，让我们了解一些基本术语：
- en: '**Cluster**: This is the main part of our process that will pool underlying
    resources as EC2 instances and any attached storage. It clusters many EC2 instances
    into one containerized application that aims to be scalable.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群**：这是我们流程的主要部分，它将底层资源（EC2实例和任何附加存储）池化。它将许多EC2实例聚合成一个容器化应用程序，旨在可扩展。'
- en: '**Task definition**: This task determines what Docker Containers you are going
    to run on each EC2 instance (that is, the `docker run` command) and it also helps
    you define more advanced options, such as environment variables that you want
    to pass down into a container.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务定义**：此任务确定您将在每个EC2实例上运行哪些Docker容器（即`docker run`命令），它还帮助您定义更高级的选项，例如您想要传递到容器中的环境变量。'
- en: '**Service**: This is a kind of glue between the cluster and a task definition.
    The service handles the login of a running task on our cluster. This also contains
    the management of revisions of the task (combination of a container and its settings)
    you want to run. Every time you change any setting in your task, it creates a
    new revision of your task. In the service, you specify what the task is and its
    revision that you want to run on your EC2 instances in your ECS.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：这是集群和任务定义之间的一种粘合剂。服务处理我们集群中正在运行的任务的登录。这还包括您想要运行的任务（容器及其设置的组合）的版本管理。每次您更改任务中的任何设置时，都会创建您任务的新版本。在服务中，您指定任务及其版本，您希望在您的ECS
    EC2实例上运行。'
- en: 'Visit the AWS Console and find the ECS. Click on the link to go to the EC2
    Container Service Console. There, you will find a blue button named Get started:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 访问AWS控制台并找到ECS。点击链接进入EC2容器服务控制台。在那里，您将找到一个名为“开始”的蓝色按钮：
- en: '![](img/00128.jpeg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00128.jpeg)'
- en: 'After that, you will see an ECS wizard with the following steps:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您将看到一个包含以下步骤的ECS向导：
- en: Create a task definition.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个任务定义。
- en: Configure service.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置服务。
- en: Configure cluster.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置集群。
- en: Review.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查。
- en: Step 1 - creating a task definition
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1步 - 创建任务定义
- en: In ECS, a task definition is a recipe for a container. It's something that helps
    an ECS understand what Docker Container you want to run on the EC2 instances.
    It's a recipe or a blueprint of steps that the ECS has automatically done in order
    to successfully deploy our publishing app's container.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECS中，任务定义是一个容器的配方。这是帮助ECS理解你希望在EC2实例上运行的Docker容器的东西。这是一个ECS自动执行以成功部署我们的发布应用容器的步骤配方或蓝图。
- en: 'The details for this step are shown in the following screenshot:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 本步骤的详细信息如下所示：
- en: '![](img/00129.jpeg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00129.jpeg)'
- en: In the preceding screenshot, you can find that our task definition name is `pubapp-task`.
    The container name is `pubapp-container`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你可以看到我们的任务定义名称是`pubapp-task`，容器名称是`pubapp-container`。
- en: For Image, we use the same argument as when we were running a container locally
    with `docker run`. In the case of `przeor/pub-app-docker`, ECS will know that
    it has to download the container from [https://hub.docker.com/r/przeor/pub-app-docker/](https://hub.docker.com/r/przeor/pub-app-docker/).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 对于镜像，我们使用与本地运行容器时相同的参数`docker run`。在`przeor/pub-app-docker`的情况下，ECS将知道它必须从[https://hub.docker.com/r/przeor/pub-app-docker/](https://hub.docker.com/r/przeor/pub-app-docker/)下载容器。
- en: For now, let's keep the maximum memory at the default value (`300`). Set both
    port mappings to `80`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，让我们将最大内存保持为默认值（`300`）。将端口映射设置为`80`。
- en: At the time of writing this book, there are some problems if your container
    doesn't expose port `80`. It's probably a bug with the ECS wizard; without the
    wizard, any port can be used on the container.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，如果你的容器没有暴露端口`80`，可能会出现一些问题。这可能是ECS向导的bug；没有向导，容器上可以使用任何端口。
- en: 'Click on Advanced options in the task definition view:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在任务定义视图中点击“高级选项”：
- en: '![](img/00130.jpeg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00130.jpeg)'
- en: 'You will see a slide panel with additional options:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个带有附加选项的幻灯片面板：
- en: '![](img/00131.jpeg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00131.jpeg)'
- en: 'We need to specify the following things:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要指定以下事项：
- en: '**Command**: This has to be separated with commas, so we use `npm,start`.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令**：这个命令必须用逗号分隔，所以我们使用`npm,start`。'
- en: '**Working directory**: We use `/opt/publishing-app` (identical path is set
    in the Dockerfile).'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作目录**：我们使用`/opt/publishing-app`（在Dockerfile中设置了相同的路径）。'
- en: '**Env variables**: Here, we specify all values from the `server/.env` file.
    This part is important to set up; the app will not work correctly without the
    correct details provided via the environment variables.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境变量**：在这里，我们指定`server/.env`文件中的所有值。这部分设置很重要；如果没有通过环境变量提供正确的详细信息，应用程序将无法正确运行。'
- en: '**Rest of the values/inputs**: Keep them at the default without changes.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其余的值/输入**：保持默认值不变。'
- en: It's very important to add all the environment variables. We need to be very
    careful as it's easy to make a mistake here that will break the app inside an
    EC2 instance.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 添加所有环境变量非常重要。我们需要非常小心，因为在这里很容易犯错误，这可能会破坏EC2实例内的应用程序。
- en: After all these changes, you can click on the Next button.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行所有这些更改后，你可以点击“下一步”按钮。
- en: Step 2 - configuring the service
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2步 - 配置服务
- en: Generally, a service is a mechanism that keeps a certain amount of EC2 instances
    running while checking their health at the same time (using the **Elastic Load
    Balancing** (**ELB**)).  ELB automatically distributes incoming application traffic
    across multiple Amazon EC2 instances. If a server doesn't respond on port 80 (the
    default but can be changed to more advanced health checks), then the service runs
    a new service while the unhealthy one is being shut down. This helps you maintain
    very high availability for your application.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，服务是一种机制，它保持一定数量的EC2实例运行，同时检查它们的健康状态（使用**弹性负载均衡器**（**ELB**））。ELB自动将传入的应用程序流量分配到多个Amazon
    EC2实例。如果服务器在端口80（默认值，但可以更改为更高级的健康检查）上没有响应，那么服务将运行新的服务，同时关闭不健康的那个。这有助于你保持应用程序非常高的可用性。
- en: '![](img/00132.jpeg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00132.jpeg)'
- en: The service name is `pubapp-service`. In this book, we will set up three different
    EC2 instances (you can set up fewer or more; it's up to you), so this is the number
    for the *desired number of tasks* input.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 服务名称是`pubapp-service`。在这本书中，我们将设置三个不同的EC2实例（你可以设置更少或更多；这取决于你），所以这是“所需任务数”输入的数字。
- en: 'In the same step, we also have to set up the **Elastic Load Balancer** (**ELB**):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的步骤中，我们还需要设置**弹性负载均衡器**（**ELB**）：
- en: '![](img/00133.jpeg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00133.jpeg)'
- en: 'Container name:host port: Choose from the drop-down list `pubapp-container:80`'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器名称：主机端口：从下拉列表中选择`pubapp-container:80`
- en: 'ELB listener protocol*: HTTP'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ELB监听器协议：HTTP
- en: 'ELB listener port*: `80`'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ELB监听端口*：`80`
- en: 'ELB health check: Keep default; you can change it while you are out of the
    wizard (on the specific ELB''s page)'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ELB健康检查：保持默认；你可以在退出向导时更改它（在特定ELB的页面上）
- en: 'Service IAM role: The wizard will create this for us'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务IAM角色：向导将为我们创建此角色
- en: 'After all this, you can click on the Next step button to continue:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些后，你可以点击“下一步”按钮继续：
- en: '![](img/00134.jpeg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00134.jpeg)'
- en: Step 3 - configuring the cluster
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3步 - 配置集群
- en: Now, you'll set up the details of the ECS container agent, called a cluster.
    Here, you specify the name of your cluster, what kind of instances you'd like
    to use, the number of instances (it has to be bigger than the number required
    by the service), and the key pair.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要设置ECS容器代理的详细信息，也就是集群。在这里，你指定集群的名称、你希望使用的实例类型、实例数量（必须大于服务所需数量），以及密钥对。
- en: '![](img/00135.jpeg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00135.jpeg)'
- en: 'Cluster name: Our cluster name is `pubapp-ecs-cluster`.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群名称：我们的集群名称是`pubapp-ecs-cluster`。
- en: 'EC2 instance type: `t2.micro` (in production, use a bigger one).'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EC2实例类型：`t2.micro`（在生产环境中，请使用更大的实例）。
- en: 'Number of instances: Five, and that means the service will keep three instances
    alive and another two instances will be on the bench, waiting for any fatal situations.
    By bench, I mean that at a time (with our setup), we''ll use only three instances,
    whereas another two are ready for use, but not actively used (traffic is not redirected
    to them).'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例数量：五个，这意味着服务将保持三个实例运行，另外两个实例将在备用状态，等待任何致命情况。备用状态意味着（在我们的设置中），我们一次只会使用三个实例，而另外两个准备就绪，但未被积极使用（流量不会被重定向到它们）。
- en: 'Key pair: I specified the key pair called `pubapp-ec2-key-pair` earlier in
    this chapter. Always keep them in a safe place for later use.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥对：我在本章前面指定了名为`pubapp-ec2-key-pair`的密钥对。始终将它们保存在安全的地方以备后用。
- en: 'On the same page, you will also find the security group and container instance
    IAM roles setup, but we''ll keep it at the default for now:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一页面上，你还会找到安全组和容器实例IAM角色的设置，但我们会保持默认设置：
- en: '![](img/00136.jpeg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00136.jpeg)'
- en: Step 4 - reviewing
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4步 - 审查
- en: 'The last thing is to review whether everything looks good:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，检查一切是否正常：
- en: '![](img/00137.jpeg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00137.jpeg)'
- en: 'Then, choose Launch instances & run service:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，选择“启动实例并运行服务”：
- en: '![](img/00138.jpeg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00138.jpeg)'
- en: Launch status
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动状态
- en: 'After you have clicked on the Launch button, you will find a page with the
    status. Keep it open until you get all the boxes green with success indicators:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“启动”按钮后，你会看到一个显示状态的页面。保持打开状态，直到所有框都显示成功指示器为绿色：
- en: '![](img/00139.jpeg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00139.jpeg)'
- en: 'Here''s what it looks like all up and running:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这是所有设置完成后运行的样子：
- en: '![](img/00140.jpeg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00140.jpeg)'
- en: 'After all the boxes have a success indicator, then you will be able to click
    on the View service button that is at the top:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 所有框都显示成功指示器后，你将能够点击顶部的“查看服务”按钮：
- en: '![](img/00141.jpeg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00141.jpeg)'
- en: Click on that button (View service) after it becomes available.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在它可用后，点击该按钮（查看服务）。
- en: Finding your load balancer address
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找你的负载均衡器地址
- en: 'After you click on the View service button, you will see the main dashboard,
    where all your clusters are listed (currently there will only be one):'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“查看服务”按钮后，你会看到主仪表板，其中列出了所有你的集群（目前只有一个）：
- en: '![](img/00142.jpeg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00142.jpeg)'
- en: 'Click on pubapp-ecs-cluster and you will see the following:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 点击pubapp-ecs-cluster，你会看到以下内容：
- en: '![](img/00143.jpeg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00143.jpeg)'
- en: 'On the preceding screen, click on pubapp-service from the list:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕上，从列表中选择pubapp-service：
- en: '![](img/00144.jpeg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00144.jpeg)'
- en: 'Then, you will see the following:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你会看到以下内容：
- en: '![](img/00145.jpeg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00145.jpeg)'
- en: 'From this page, choose the Elastic Balancer:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在此页面上，选择弹性负载均衡器：
- en: '![](img/00146.jpeg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00146.jpeg)'
- en: 'The final view of ELB is as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ELB的最终视图如下：
- en: '![](img/00147.jpeg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00147.jpeg)'
- en: 'In the preceding view, you will find (under the Description Name tab) an elastic
    balancer address like this one:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的视图中，你将在“描述名称”选项卡下找到一个类似这样的弹性负载均衡器地址：
- en: '[PRE41]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If you try to open the address and it doesn't work, then give it more time.
    The EC2 instances may be in progress in terms of running our Docker publishing
    app container. We must be patient during the initial run of our ECS cluster.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试打开地址但无法工作，请给它更多时间。EC2实例可能正在运行我们的Docker发布应用容器。在ECS集群的初始运行期间，我们必须保持耐心。
- en: 'This is the address of your ELB, which you can put into the browser and see
    the publishing app:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你的ELB地址，你可以将其放入浏览器中查看发布应用：
- en: '![](img/00148.jpeg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00148.jpeg)'
- en: AWS Route 53
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS Route 53
- en: The last step left in this chapter is to set up Route 53, which is a highly
    available and scalable cloud DNS web service.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一步是设置Route 53，这是一个高度可用和可扩展的云DNS网络服务。
- en: 'For this step, you have two options:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一步，您有两个选择：
- en: Having your own domain already registered
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经注册了自己的域名
- en: Registering a new domain via Route 53
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Route 53注册新域名
- en: In the following procedure, we will use the first option, so we assume that
    we have already registered the `reactjs.space` domain (of course, you need to
    have your own domain in order to successfully follow these steps).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下过程中，我们将使用第一个选项，因此我们假设我们已经注册了`reactjs.space`域名（当然，您需要拥有自己的域名才能成功执行这些步骤）。
- en: We will route end users to the publishing app by translating the name `http://reactjs.space`
    into the address of our ELB (`EC2Contai-EcsElast-1E4Y3WOGMV6S4-39378274.eu-central-1.elb.amazonaws.com`)
    so that users will be able to visit our application in a more user-friendly manner
    by typing `reactjs.space` into the browser's address bar.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过将名称`http://reactjs.space`转换为我们的ELB（`EC2Contai-EcsElast-1E4Y3WOGMV6S4-39378274.eu-central-1.elb.amazonaws.com`）的地址来路由最终用户，这样用户就可以通过在浏览器的地址栏中输入`reactjs.space`来以更用户友好的方式访问我们的应用程序。
- en: 'Choose Route 53 from the AWS services list:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 从AWS服务列表中选择Route 53：
- en: '![](img/00149.jpeg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00149.jpeg)'
- en: 'You will be able to see a main page like the following:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 您将能够看到一个如下所示的主页：
- en: '![](img/00150.jpeg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00150.jpeg)'
- en: 'The next step is to create a hosted zone on Route 53, so click on the blue
    button called Create Hosted Zone:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在Route 53上创建一个托管区域，因此请点击名为“创建托管区域”的蓝色按钮：
- en: '![](img/00151.jpeg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00151.jpeg)'
- en: 'After this, you won''t see any hosted zones, so click again on the blue button:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，您将看不到任何托管区域，因此请再次点击蓝色按钮：
- en: '![](img/00152.jpeg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00152.jpeg)'
- en: 'The form will have a Domain Name field, where you put your domain name (in
    our case, it''s `reactjs.space`):'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 表单将有一个域名字段，您可以在其中输入您的域名（在我们的情况下，它是`reactjs.space`）：
- en: '![](img/00153.jpeg)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00153.jpeg)'
- en: 'Success! Now you will be able to see your DNS names:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！现在您将能够看到您的DNS名称：
- en: '![](img/00154.jpeg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00154.jpeg)'
- en: 'The next step is to park the DNSes on your domain''s provider. The last step
    is to change DNS settings at your domain registrar; in my case, they''re as follows
    (yours will be different):'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将DNS记录停放在您域名的提供商上。最后一步是在您的域名注册商处更改DNS设置；在我的情况下，如下所示（您的将不同）：
- en: '[PRE42]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Notice the `.` (dots) at the end; you can get rid of them so the final DNSes
    that we have to change are as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后的`.`（点）；您可以去掉它们，这样我们最终要更改的DNS如下所示：
- en: '[PRE43]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: After all these steps, you can visit the `http://reactjs.space` website (the
    DNS change may take up to 48 hours).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些步骤之后，您可以访问`http://reactjs.space`网站（DNS更改可能需要长达48小时）。
- en: 'The last thing is to create an alias of the `reactjs.space` domain that points
    to our Elastic Load Balancer. Click the following button:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事情是创建一个指向我们的弹性负载均衡器的`reactjs.space`域名的别名。点击以下按钮：
- en: '![](img/00155.jpeg)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00155.jpeg)'
- en: 'Then, you''ll have the following view:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将看到以下视图：
- en: '![](img/00156.jpeg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00156.jpeg)'
- en: 'Choose Yes from the alias''s radio button and then select the ELB from the
    list, as shown in the following example:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 从别名单选按钮中选择“是”，然后从列表中选择ELB，如下例所示：
- en: '![](img/00157.jpeg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00157.jpeg)'
- en: Currently, everything will be working after the DNS changes are finished (which
    may take up to 48 hours). To improve the experience with our application, let's
    also make an alias from `www.reactjs.space` to `reactjs.space`, so if anyone types
    `www.` before the domain name, it will work as intended.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在DNS更改完成后（可能需要长达48小时），一切都将正常工作。为了提高我们应用程序的体验，让我们也创建一个从`www.reactjs.space`到`reactjs.space`的别名，这样如果有人在域名名前输入`www.`，它将按预期工作。
- en: 'Click again on the button called Create Record Set, choose an alias, and type
    `www`., after which you will be able to choose the `www.reactjs.space` domain.
    Do so and hit the Create button:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 再次点击名为“创建记录集”的按钮，选择一个别名，并输入`www`，之后您将能够选择`www.reactjs.space`域名。这样做并点击创建按钮：
- en: '![](img/00158.jpeg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00158.jpeg)'
- en: Summary
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We are done with all the AWS/Docker setup. After a successful DNS change, you
    will be able to find our application under the `http://reactjs.space` address:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了所有的AWS/Docker设置。在DNS更改成功后，您将能够在`http://reactjs.space`地址下找到我们的应用程序：
- en: '![](img/00159.jpeg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00159.jpeg)'
- en: The next chapter will talk about the basics of continuous integration and also
    help you wrap up the remaining things in the app before it is 100% production
    ready (minification is missing so far).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论持续集成的基础知识，并帮助你完成应用在达到100%生产就绪前的剩余工作（目前尚未进行代码压缩）。
- en: Let's continue in the next chapter with a more detailed description of the remaining
    topics that are going to be covered in the book.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一章中继续，对书中将要涵盖的剩余主题进行更详细的描述。
