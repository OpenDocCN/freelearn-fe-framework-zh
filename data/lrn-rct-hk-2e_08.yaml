- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Using Hooks and React Suspense for Data Fetching
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Hooks 和 React Suspense 进行数据获取
- en: In the previous chapter, we learned how to use React Context as an alternative
    to manually passing down props. We learned about context providers, consumers
    and the Context Hook.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用 React Context 作为手动传递 props 的替代方案。我们学习了 context providers、consumers
    和 Context Hook。
- en: In this chapter, we are going to first set up a simple backend server from a
    JSON file using the `json-server` tool. Then, we are going to fetch data from
    our server using an Effect Hook in combination with a State Hook. Next, we are
    going to do the same using TanStack Query, a popular data fetching library for
    React that makes use of Hooks. Finally, we will learn about React Suspense, which
    can be used to defer rendering until the content has finished loading.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先使用 `json-server` 工具从 JSON 文件设置一个简单的后端服务器。然后，我们将结合使用 Effect Hook 和
    State Hook 从我们的服务器获取数据。接下来，我们将使用 TanStack Query，这是一个流行的 React 数据获取库，它利用 Hooks，以同样的方式完成。最后，我们将了解
    React Suspense，它可以用来延迟渲染，直到内容加载完成。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Setting up a simple backend server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个简单的后端服务器
- en: Requesting resources using an Effect and a State Hook
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Effect 和 State Hook 请求资源
- en: Using TanStack Query to request resources and make changes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TanStack Query 请求资源并做出更改
- en: Introducing React Suspense and Error Boundaries
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 React Suspense 和错误边界
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'A fairly recent version of Node.js should already be installed. The Node Package
    Manager (`npm`) also needs to be installed (it should come with Node.js). For
    more information on how to install Node.js, please check out their official website:
    [https://nodejs.org/](https://nodejs.org/).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 应该已经安装了相当新的 Node.js 版本。Node 包管理器 (`npm`) 也需要安装（它应该与 Node.js 一起提供）。有关如何安装 Node.js
    的更多信息，请查看他们的官方网站：[https://nodejs.org/](https://nodejs.org/)
- en: 'We are going to use **Visual Studio Code** (**VS Code**) for the guides in
    this book, but everything should work similarly in any other editor. For more
    information on how to install VS Code, please refer to their official website:
    [https://code.visualstudio.com](https://code.visualstudio.com)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的指南将使用 **Visual Studio Code** （**VS Code**），但任何其他编辑器中都应该有类似的工作方式。有关如何安装 VS
    Code 的更多信息，请参阅他们的官方网站：[https://code.visualstudio.com](https://code.visualstudio.com)
- en: 'In this book, we use the following versions:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用以下版本：
- en: Node.js v22.14.0
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js v22.14.0
- en: '`npm` v10.9.2'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm` v10.9.2'
- en: Visual Studio Code v1.97.2
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code v1.97.2
- en: The versions mentioned in the preceding list are the ones used in the book.
    While installing a newer version should not be an issue, please note that certain
    steps might work differently on a newer version. If you are having an issue with
    the code and steps provided in this book, please try using the mentioned versions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 上列出的版本是本书中使用的版本。虽然安装较新版本通常不会有问题，但请注意，某些步骤在较新版本上可能会有所不同。如果您在这本书提供的代码和步骤中遇到问题，请尝试使用提到的版本。
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter06)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的代码：[https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter06)
- en: It is highly recommended that you write the code on your own. Do not simply
    run the code examples that are provided with the book. It is important to write
    the code yourself to be able to learn and understand it properly. However, if
    you run into any issues, you can always refer to the code example.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议您自己编写代码。不要简单地运行书中提供的代码示例。自己编写代码对于正确学习和理解代码非常重要。然而，如果您遇到任何问题，您始终可以参考代码示例。
- en: Setting up a simple backend server
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置一个简单的后端服务器
- en: Before we can implement requests, we need to implement a server. Since we are
    focusing on the user interface in this book, we are going to set up a dummy server,
    which will allow us to test out requests. We are going to use the `json-server`
    tool to create a mock **Representational State Transfer** (**REST**) **Application
    Programming Interface** (**API**) from a JSON file.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以实现请求之前，我们需要实现一个服务器。由于我们在这本书中专注于用户界面，我们将设置一个模拟服务器，这将使我们能够测试请求。我们将使用 `json-server`
    工具从 JSON 文件创建一个模拟的 **表示状态传输** （**REST**） **应用程序编程接口** （**API**）。
- en: Creating the db.json file
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 db.json 文件
- en: 'To be able to use the `json-server` tool, we first need to create a `db.json`
    file, which is going to contain the database for the server. The `json-server`
    tool will then create a REST API that allows us to access and modify the `db.json`
    file, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够使用 `json-server` 工具，我们首先需要创建一个 `db.json` 文件，它将包含服务器的数据库。然后，`json-server`
    工具将创建一个 REST API，允许我们访问和修改 `db.json` 文件，如下所示：
- en: '`GET` requests, to view data from the file'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` 请求，用于从文件中查看数据'
- en: '`POST` requests, to insert new data into the file'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST` 请求，用于将新数据插入文件'
- en: '`PUT` and `PATCH` requests, to adjust existing data in the file'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT` 和 `PATCH` 请求，用于调整文件中的现有数据'
- en: '`DELETE` requests, to remove data from the file'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE` 请求，用于从文件中删除数据'
- en: The structure of the REST API is inferred from a JSON object in the `db.json`
    file. For all modifying actions (`POST`, `PUT`, `PATCH`, and `DELETE`), the updated
    file will be automatically saved by the tool.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 的结构是从 `db.json` 文件中的 JSON 对象推断出来的。对于所有修改操作（`POST`、`PUT`、`PATCH` 和 `DELETE`），工具将自动保存更新后的文件。
- en: We can use our existing structure for posts, which we defined as `defaultPosts`
    in our App component, but we need to provide an additional `id` value, so that
    we can query posts from the database later. Additionally, we give each post a
    `featured` value. This will be important later to distinguish between featured
    and regular posts when we implement the request.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们现有的帖子结构，我们在 App 组件中将其定义为 `defaultPosts`，但我们需要提供一个额外的 `id` 值，这样我们就可以稍后从数据库中查询帖子。此外，我们给每个帖子一个
    `featured` 值。这将在我们实现请求时区分特色帖子和平常帖子变得很重要。
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For the users, we need to come up with a way to store usernames and passwords.
    For simplicity, we just store the password in plain text *(never do this in a
    production environment!)*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户，我们需要想出一个方法来存储用户名和密码。为了简单起见，我们只以纯文本形式存储密码（**永远不要在生产环境中这样做！**）：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now all that is left to do is to combine these two arrays into a single JSON
    object, by storing the posts array under a `posts` key, and the users array under
    a `users` key.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的任务是将这两个数组合并成一个 JSON 对象，通过将帖子数组存储在 `posts` 键下，将用户数组存储在 `users` 键下。
- en: 'Let’s get started creating the JSON file for our backend server now:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在开始创建后端服务器的 JSON 文件：
- en: 'Copy the `Chapter05_2` folder to a new `Chapter06_1` folder by executing the
    following command:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令，将 `Chapter05_2` 文件夹复制到新的 `Chapter06_1` 文件夹：
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Open the new `Chapter06_1` folder in VS Code.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开新的 `Chapter06_1` 文件夹。
- en: Create a new `server/` folder, directly inside the `Chapter06_1` folder.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Chapter06_1` 文件夹内直接创建一个新的 `server/` 文件夹。
- en: 'Create a `server/db.json` file with the following contents:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下内容的 `server/db.json` 文件：
- en: '[PRE3]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That’s all we need to automatically create a simple backend with a REST API
    using the `json-server` tool. Let’s continue by setting up the tool.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们使用 `json-server` 工具自动创建简单后端和 REST API 所需要的一切。让我们继续设置工具。
- en: Installing the json-server tool
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 json-server 工具
- en: 'Now, we are going to install and start our backend server by using the `json-server`
    tool:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 `json-server` 工具安装并启动我们的后端服务器：
- en: 'First, install the `json-server` tool, as follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，按照以下步骤安装 `json-server` 工具：
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, start the backend server by executing the following command:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过执行以下命令启动后端服务器：
- en: '[PRE5]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `npx` command executes commands that were installed locally in a project.
    We need to use `npx` here, because we did not globally install the `json-server`
    tool (via `npm install -g json-server`).
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`npx` 命令执行在项目中本地安装的命令。我们需要在这里使用 `npx`，因为我们没有全局安装 `json-server` 工具（通过 `npm install
    -g json-server`）。'
- en: We executed the `json-server` tool, and it is watching the `server/db.json`
    file that we created earlier.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行了 `json-server` 工具，它正在监视我们之前创建的 `server/db.json` 文件。
- en: 'By default, the `json-server` tool defines the following routes for each `key`
    in the JSON object:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`json-server` 工具为 JSON 对象中的每个 `key` 定义了以下路由：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we can go to `http://localhost:3000/posts/1` in order to see our post
    object:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以访问 `http://localhost:3000/posts/1` 来查看我们的帖子对象：
- en: '![Figure 6.1 – The json-server tool serving a post via its REST API!](img/B31327_06_01.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – json-server 工具通过其 REST API 提供帖子！](img/B31327_06_01.png)'
- en: Figure 6.1 – The json-server tool serving a post via its REST API!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – json-server 工具通过其 REST API 提供帖子！
- en: As we can see, the tool created a full REST API from the database JSON file
    for us! Now, let’s continue by configuring `package.json` scripts so that the
    `json-server` tool is started together with our frontend.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，该工具已为我们从数据库 JSON 文件创建了一个完整的 REST API！现在，让我们继续配置 `package.json` 脚本，以便 `json-server`
    工具与我们的前端一起启动。
- en: Configuring the package.json scripts
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置package.json脚本
- en: 'Let’s get started adjusting the `package.json` file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始调整`package.json`文件：
- en: 'Edit `package.json` and define a new script called `dev:server`, by inserting
    it in the `scripts` section. We also make sure to change the port to be adjacent
    to the Vite default port (which is `5173`):'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`package.json`文件，并在`scripts`部分插入一个新的脚本名为`dev:server`。我们还要确保将端口改为与Vite默认端口（`5173`）相邻：
- en: '[PRE7]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, we rename the `dev` script to `dev:client`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将`dev`脚本重命名为`dev:client`：
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Save the `package.json` file, otherwise running `npm install` later will overwrite
    our changes.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`package.json`文件，否则稍后运行`npm install`将覆盖我们的更改。
- en: If it is still running, quit the `json-server` tool by pressing *Ctrl+C*.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它仍在运行，请按*Ctrl+C*退出`json-server`工具。
- en: 'Next, we install a tool called `concurrently`, which lets us start the server
    and client at the same time:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们安装一个名为`concurrently`的工具，它允许我们同时启动服务器和客户端：
- en: '[PRE9]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we edit `package.json` again and define a new `dev` script by using the
    `concurrently` command and then passing the server and client commands as arguments
    to it:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们再次编辑`package.json`并定义一个新的`dev`脚本，使用`concurrently`命令，然后将其作为参数传递给该命令：
- en: '[PRE10]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Try executing the following command now:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试执行以下命令：
- en: '[PRE11]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You will see that this command is starting both the server and the client:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到这个命令正在启动服务器和客户端：
- en: '![Figure 6.2 – The concurrently tool running our server and client in parallel](img/B31327_06_02.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – concurrently工具并行运行我们的服务器和客户端](img/B31327_06_02.png)'
- en: Figure 6.2 – The concurrently tool running our server and client in parallel
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – concurrently工具并行运行我们的服务器和客户端
- en: Now that we have both the client and the server running, let’s move on to configuring
    a proxy to avoid having to deal with cross-site requests.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经同时运行了客户端和服务器，让我们继续配置代理以避免处理跨站请求。
- en: Configuring a proxy
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置代理
- en: For security reasons, browsers have restrictions on making requests to different
    domains. This restriction is called **cross-origin resource sharing (CORS)** and
    it prevents us from being able to make requests to URLs with a different origin.
    The origin consists of the domain and port. In our case, the domain is the same
    (`localhost`), but the port is different (`5173` vs `5174`). It would be best
    to stay on the same domain and port to make requests from a frontend to a backend.
    So, we need to configure a proxy that will forward requests from `http://localhost:5173/api/`
    to `http://localhost:5174/`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安全原因，浏览器对向不同域发起请求有限制。这种限制称为**跨源资源共享（CORS）**，它阻止我们从具有不同源（域名和端口）的URL发起请求。在我们的例子中，域名是相同的（`localhost`），但端口不同（`5173`与`5174`）。因此，最好保持相同的域名和端口，以便从前端向后端发起请求。所以，我们需要配置一个代理，将`http://localhost:5173/api/`的请求转发到`http://localhost:5174/`。
- en: 'Now, let’s get started configuring the proxy:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始配置代理：
- en: 'Edit `vite.config.js` and define a `proxy` config that will be bound to the
    `/api` path:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`vite.config.js`并定义一个绑定到`/api`路径的`proxy`配置：
- en: '[PRE12]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Set the target to our backend server running at `http://localhost:5174`, and
    rewrite the path to remove the `/api` from it before forwarding the request to
    our server:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目标设置为运行在`http://localhost:5174`的后端服务器，并在将请求转发到我们的服务器之前，重写路径以从其中删除`/api`：
- en: '[PRE13]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This proxy configuration will link `/api` to our backend server.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此代理配置将`/api`链接到我们的后端服务器。
- en: 'Quit the server and client if they are already running. Then, start them again
    with the following command:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果服务器和客户端已经在运行，请退出。然后，使用以下命令重新启动它们：
- en: '[PRE14]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, access the API by opening `http://localhost:5173/api/posts/1` in your browser.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过浏览器打开`http://localhost:5173/api/posts/1`来访问API。
- en: As we can see, the post object is still being served properly, but now from
    the `/api` path through the proxy defined in Vite!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，POST对象仍然被正确地提供服务，但现在是通过Vite中定义的代理从`/api`路径提供的！
- en: '**Example code**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例代码**'
- en: The example code for this section can be found in the `Chapter06/Chapter06_1`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的示例代码可以在`Chapter06/Chapter06_1`文件夹中找到。请检查文件夹内的`README.md`文件，了解如何设置和运行示例。
- en: Now, let’s move on to requesting resources using an Effect and a State/Reducer
    Hook.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续使用Effect和State/Reducer Hook来请求资源。
- en: Requesting resources using an Effect and a State/Reducer Hook
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Effect和State/Reducer Hook请求资源
- en: Before learning how to use a library to implement requests using Hooks, we are
    going to implement them manually, using an Effect Hook to trigger the request,
    and a State/Reducer Hook to store the result.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何使用库通过 Hooks 实现请求之前，我们将手动实现它们，使用 Effect Hook 触发请求，以及使用 State/Reducer Hook
    存储结果。
- en: Fetching posts from the server
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从服务器获取帖子
- en: 'We are now going to implement a way to fetch posts by using an Effect Hook.
    Then, we will store it by extending the already defined Reducer Hook. Let’s get
    started:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现一种使用 Effect Hook 获取帖子的方法。然后，我们将通过扩展已定义的 Reducer Hook 来存储它。让我们开始吧：
- en: 'Copy the `Chapter06_1` folder to a new `Chapter06_2` folder by executing the
    following command:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令将 `Chapter06_1` 文件夹复制到新的 `Chapter06_2` 文件夹：
- en: '[PRE15]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Open the new `Chapter06_2` folder in VS Code.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开新的 `Chapter06_2` 文件夹。
- en: 'First, edit `src/reducers.js` and define a new `FETCH_POSTS` action, which
    is simply going to return the new list of posts from the action:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，编辑 `src/reducers.js` 并定义一个新的 `FETCH_POSTS` 动作，它将简单地从动作返回新的帖子列表：
- en: '[PRE16]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, edit `src/App.jsx` and import the `useEffect` function:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编辑 `src/App.jsx` 并导入 `useEffect` 函数：
- en: '[PRE17]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Remove* the `featuredPosts` and `defaultPosts` arrays.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*删除* `featuredPosts` 和 `defaultPosts` 数组。'
- en: 'Adjust the default value of the Reducer Hook to be an empty array:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整 Reducer Hook 的默认值为一个空数组：
- en: '[PRE18]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, define an Effect Hook in the App component, as follows:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 App 组件中定义一个 Effect Hook，如下所示：
- en: '[PRE19]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Inside the Hook, we call `fetch` to make a request to the `/api/posts` endpoint:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Hook 内部，我们调用 `fetch` 向 `/api/posts` 端点发起请求：
- en: '[PRE20]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Parse the JSON response to get back a `posts` array:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析 JSON 响应以获取 `posts` 数组：
- en: '[PRE21]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, dispatch the `FETCH_POSTS` action with the `posts` array returned from
    the server:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用从服务器返回的 `posts` 数组分发 `FETCH_POSTS` 动作：
- en: '[PRE22]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Pass an empty array to the Effect Hook dependency array to make sure it only
    triggers when the component mounts:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将空数组传递给 Effect Hook 依赖数组，以确保它仅在组件挂载时触发：
- en: '[PRE23]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We still need to separate featured posts from non-featured posts, so let’s
    use `filter` to split up the array into two arrays, as follows:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们仍然需要将特色帖子与非特色帖子分开，所以让我们使用 `filter` 将数组拆分为两个数组，如下所示：
- en: '[PRE24]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We reverse the order here to make sure the newest posts are shown first. If
    we had a `createdAt` property, we could use that instead to sort the posts properly.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里反转顺序以确保显示最新的帖子。如果我们有一个 `createdAt` 属性，我们可以用它来正确地排序帖子。
- en: 'Pass `regularPosts` instead of `posts` to the `PostList` component to ensure
    that featured posts are not rendered twice:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `regularPosts` 而不是 `posts` 传递给 `PostList` 组件，以确保特色帖子不会渲染两次：
- en: '[PRE25]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Start the client and server, as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式启动客户端和服务器：
- en: '[PRE26]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, go to `http://localhost:5173/` in your browser.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在浏览器中转到 `http://localhost:5173/`。
- en: As we can see, the app still works the same way as before! To verify that the
    posts are really coming from our database, make a change to `db.json`, then refresh
    the page. You will see that the change is visible in the app!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，应用程序仍然以之前相同的方式工作！为了验证帖子确实来自我们的数据库，对 `db.json` 进行更改，然后刷新页面。您将看到更改在应用程序中可见！
- en: In development mode, you will see two `GET` requests. This is due to React rendering
    components twice in strict mode to help you spot side effects that may happen
    when re-rendering components (for example, forgetting to clean up timeouts/intervals).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发模式下，您将看到两个 `GET` 请求。这是由于 React 在严格模式下渲染组件两次，以帮助您发现可能在组件重新渲染时发生的副作用（例如，忘记清理超时/间隔）。
- en: In production mode, the component will only be rendered once and thus only one
    `GET` request will be sent.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产模式下，组件只会渲染一次，因此只会发送一个 `GET` 请求。
- en: 'Quick detour: The async/await construct'
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速转换：async/await 构造
- en: '**Regular functions** are defined as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**常规函数**定义如下：'
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Regular anonymous functions** are defined as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**常规匿名函数**定义如下：'
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Asynchronous functions** are defined by adding the `async` keyword:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步函数**通过添加 `async` 关键字来定义：'
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Asynchronous anonymous functions** are also possible:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步匿名函数**也是可能的：'
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Within `async` functions, we can use the `await` keyword to wait for promises
    to resolve before continuing. Instead of having to do the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `async` 函数中，我们可以使用 `await` 关键字等待承诺解决后再继续。而不是必须做以下操作：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can now write the same function like this using `async`/`await`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用 `async`/`await` 以这种方式编写相同的函数：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the previous section, we used the Promise API to work with the result of
    an asynchronous function by using the `.then()` function inside the Effect Hook.
    Effect Hooks do not support passing an async function to them to prevent race
    conditions. However, it would be possible to define an async function inside the
    Hook and then call it immediately. So, we could also define the Hook as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用了 Promise API 通过在 Effect Hook 内部使用 `.then()` 函数来处理异步函数的结果。Effect Hooks
    不支持将异步函数传递给它们，以防止竞态条件。然而，在 Hook 内部定义一个异步函数并在之后立即调用它是可能的。因此，我们也可以将 Hook 定义如下：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `void` operator shows that we did not just accidentally call an `async`
    function without `await`. In this case, we want to call the asynchronous function
    but do not care about waiting for it to finish.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`void` 运算符表明我们并非无意中调用了一个没有 `await` 的 `async` 函数。在这种情况下，我们想要调用异步函数，但并不关心它何时完成。'
- en: As you can see, the `async`/`await` construct can make our code easier to read
    in some cases. You can choose either pattern (`then` or `async`/`await`) depending
    on which one makes the code more readable. However, it is best practice not to
    mix both in the same function. Of course, instead of using `dispatch` and the
    Reducer Hook, we could also call `setPosts` here, if we had a State Hook instead.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`async`/`await` 构造在某些情况下可以使我们的代码更容易阅读。您可以选择任一模式（`then` 或 `async`/`await`），取决于哪一个使代码更易读。然而，在同一个函数中混合两者并不是最佳实践。当然，如果我们有一个
    State Hook 而不是 `dispatch` 和 Reducer Hook，我们也可以在这里调用 `setPosts`。
- en: Now that posts are successfully loaded from the database, let’s implement a
    way to create posts via the backend server.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在帖子已成功从数据库中加载，让我们实现一种通过后端服务器创建帖子的方法。
- en: Creating new posts on the server
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在服务器上创建新帖子
- en: 'For creating posts, we simply need to adjust the submit handler function to
    use `fetch` to perform a POST request. Let’s get started doing that now:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于创建帖子，我们只需调整提交处理函数以使用 `fetch` 执行 POST 请求。现在让我们开始做这件事：
- en: 'Edit `src/components/post/CreatePost.jsx` and make the `handleSubmit` function
    `async`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/components/post/CreatePost.jsx` 并将 `handleSubmit` 函数定义为 `async`：
- en: '[PRE34]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Inside the function, after collecting the values, create a fetch request to
    `/api/posts`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数内部，在收集值之后，创建一个到 `/api/posts` 的 fetch 请求：
- en: '[PRE35]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Make sure this is a POST request and set the header so that our backend server
    knows we will be sending a JSON object:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保这是一个 POST 请求，并设置头信息，以便我们的后端服务器知道我们将发送一个 JSON 对象：
- en: '[PRE36]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we can pass our `post` object as the request body, by turning it into
    a JSON string:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们的 `post` 对象作为请求体传递，通过将其转换为 JSON 字符串：
- en: '[PRE37]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If the response wasn’t a success, throw an error:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果响应不是成功的，抛出一个错误：
- en: '[PRE38]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Otherwise, we dispatch the `CREATE_POST` action to show the new post on the
    client-side and reset the form:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们派发 `CREATE_POST` 动作以在客户端显示新帖子并重置表单：
- en: '[PRE39]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Create a new post using the frontend, and then check the `server/db.json` file.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前端创建一个新的帖子，然后检查 `server/db.json` 文件。
- en: 'As we can see, the new post was successfully inserted into the database:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，新帖子已成功插入到数据库中：
- en: '![Figure 6.3 – We successfully inserted a new post into the database](img/B31327_06_03.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 我们成功地将一个新帖子插入到数据库中](img/B31327_06_03.png)'
- en: Figure 6.3 – We successfully inserted a new post into the database
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 我们成功地将一个新帖子插入到数据库中
- en: '**Example code**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例代码**'
- en: The example code for this section can be found in the `Chapter06/Chapter06_2`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的示例代码可以在 `Chapter06/Chapter06_2` 文件夹中找到。请检查文件夹内的 `README.md` 文件，以获取设置和运行示例的说明。
- en: Now that we have successfully implemented fetching and creating posts by directly
    using the Fetch API and an Effect Hook, we can move on to learning about using
    a library to request resources and make changes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功实现了通过直接使用 Fetch API 和 Effect Hook 来获取和创建帖子，我们可以继续学习如何使用库来请求资源并做出更改。
- en: Using TanStack Query to request resources and make changes
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TanStack Query 请求资源并做出更改
- en: In the previous section, we used an Effect Hook to trigger the request, and
    a Reducer Hook to update the state, using the result from the request. Instead
    of manually implementing requests like this, we can instead use the TanStack Query
    library. This library not only allows us to easily fetch resources, but also caches
    the result for us and provides ways to invalidate the state. Invalidation allows
    us to, for example, re-fetch posts from the server after creating a new post,
    instead of having to manually dispatch an action.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用 Effect 钩子来触发请求，并使用 Reducer 钩子来更新状态，使用请求的结果。我们不必手动实现这样的请求，而是可以使用
    TanStack Query 库。这个库不仅允许我们轻松获取资源，还为我们缓存结果并提供使状态无效的方法。使状态无效允许我们在创建新帖子后从服务器重新获取帖子，而不是必须手动分发一个动作。
- en: Setting up the library
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置库
- en: 'Before we can get started using it, we need to install and set up the library.
    TanStack Query is a library used to manage state of server data. It consists of
    3 parts:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用它之前，我们需要安装和设置库。TanStack Query 是一个用于管理服务器数据状态的库。它由 3 部分组成：
- en: A **Query Client**, which manages the cache and invalidation.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **查询客户端**，它管理缓存和使状态无效。
- en: A **Query Client Provider**, which wraps your application to provide the query
    client to all components.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **查询客户端提供者**，它将应用程序包裹起来，为所有组件提供查询客户端。
- en: A collection of hooks, such as Query and Mutation Hooks. The **Query Hook**
    is used for fetching and subscribing to data, while the **Mutation Hook** is used
    when you need to modify data on the server.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列钩子，如查询和突变钩子。**查询钩子**用于获取和订阅数据，而**突变钩子**用于您需要修改服务器上的数据时使用。
- en: 'Let’s get started setting up TanStack Query now:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始设置 TanStack Query：
- en: 'Copy the `Chapter06_2` folder to a new `Chapter06_3` folder by executing the
    following command:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令将`Chapter06_2`文件夹复制到新的`Chapter06_3`文件夹：
- en: '[PRE40]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Open the new `Chapter06_3` folder in VS Code.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开新的`Chapter06_3`文件夹。
- en: 'Install the TanStack Query library, as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤安装 TanStack Query 库：
- en: '[PRE41]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Additionally, install the ESLint plugin as a dev dependency:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，将 ESLint 插件作为开发依赖项安装：
- en: '[PRE42]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Edit `eslint.config.js` and import the plugin there:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`eslint.config.js`并在其中导入插件：
- en: '[PRE43]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, add the plugin, as follows:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按照以下步骤添加插件：
- en: '[PRE44]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now we can get started setting up TanStack Query itself. First, create a new
    `src/api.js` file, which will contain the Query Client.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以开始设置 TanStack Query 本身了。首先，创建一个新的`src/api.js`文件，其中将包含查询客户端。
- en: 'Edit `src/api.js` and import and create the Query Client:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/api.js`并导入和创建查询客户端：
- en: '[PRE45]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We are creating a single instance of the query client here to ensure that all
    parts of our app use the same query client (and thus the same cache).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建查询客户端的单例实例，以确保我们应用程序的所有部分都使用相同的查询客户端（以及相同的缓存）。
- en: 'Now, edit `src/App.jsx`, *remove* the `useReducer`, `useEffect` and `postsReducer`
    imports:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编辑`src/App.jsx`，*移除* `useReducer`、`useEffect` 和 `postsReducer` 的导入：
- en: '[PRE46]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*Replace* them with imports of the `queryClient` and the `QueryClientProvider`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*替换*它们为`queryClient`和`QueryClientProvider`的导入：'
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Inside the App component, *remove* the Hooks related to fetching posts:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 App 组件内部，*移除*与获取帖子相关的钩子：
- en: '[PRE48]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Wrap the app with a `QueryClientProvider`, as follows:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤将应用程序包裹在`QueryClientProvider`中：
- en: '[PRE49]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '*Remove* the `dispatch` prop from the `CreatePost` component:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*移除* `CreatePost` 组件的 `dispatch` 属性：'
- en: '[PRE50]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: At this point in the chapter, the `featuredPosts` and `regularPosts` arrays
    are not defined anymore, causing ESLint errors. Ignore these errors for now, we
    will be fixing them soon.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，章节中的`featuredPosts`和`regularPosts`数组不再定义，导致 ESLint 错误。现在忽略这些错误，我们很快就会修复它们。
- en: Now we are ready to use TanStack Query!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好使用 TanStack Query 了！
- en: Fetching posts using a Query Hook
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用查询钩子获取帖子
- en: Now that the library is set up, we can start using it. We will start by fetching
    posts using a Query Hook. To do this, we are going to create a new `PostFeed`
    component, which will handle the fetching logic, while keeping `PostList` as a
    UI component that renders a list of components. We are also going to define a
    function that will fetch posts for us in the `src/api.js` file.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在库已经设置好了，我们可以开始使用它了。我们将首先使用查询钩子来获取帖子。为此，我们将创建一个新的`PostFeed`组件，该组件将处理获取逻辑，同时将`PostList`作为一个渲染组件列表的
    UI 组件。我们还将定义一个函数，在`src/api.js`文件中为我们获取帖子。
- en: 'Let’s get started fetching posts using a Query Hook now:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始使用查询钩子获取帖子：
- en: 'Edit `src/api.js` and define a new function that accepts a `featured` prop
    and then fetches posts for us:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/api.js`并定义一个新的函数，该函数接受一个`featured`属性然后为我们获取帖子：
- en: '[PRE51]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We make a call to the API, passing the `featured` prop as a query param. This
    will cause `json-server` to filter the posts by their `featured` value for us:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用 API，将 `featured` 属性作为查询参数传递。这将导致 `json-server` 根据其 `featured` 值为我们过滤帖子：
- en: '[PRE52]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Parse the response as JSON and return it:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将响应解析为 JSON 并返回：
- en: '[PRE53]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Create a new `src/components/post/PostFeed.jsx` file.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `src/components/post/PostFeed.jsx` 文件。
- en: 'Inside it, import the `useQuery` function, the `PostList` component and the
    `fetchPosts` function:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，导入 `useQuery` 函数、`PostList` 组件和 `fetchPosts` 函数：
- en: '[PRE54]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, define the component, which accepts a `featured` prop to toggle whether
    to render featured components or regular components:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义组件，它接受一个 `featured` 属性来切换是否渲染特色组件或常规组件：
- en: '[PRE55]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Define a Query Hook, from which we use the `data` and `isLoading` values:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 Query Hook，从中使用 `data` 和 `isLoading` 值：
- en: '[PRE56]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'For each Query Hook, we need to define a `queryKey`. The `queryKey` is used
    to cache the results of a query:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个 Query Hook，我们需要定义一个 `queryKey`。`queryKey` 用于缓存查询的结果：
- en: '[PRE57]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If we, for example, fetch with the same `queryKey` in another component, we
    will get the cached result instead of making another request. React Query will
    always try to first get the result from the cache (if it exists for a given `queryKey`),
    and if it does not exist in the cache yet, it will make a request in the background
    for us and cache it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们使用相同的 `queryKey` 在另一个组件中获取，我们将得到缓存的而不是另一个请求的结果。React Query 总是会首先尝试从缓存（如果给定
    `queryKey` 存在）中获取结果，如果它尚未存在于缓存中，它将为我们后台发送请求并缓存它。
- en: This is very useful as it allows us to fetch data further down in the component
    tree, directly wherever we need it – avoiding prop drilling without compromising
    performance.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有用，因为它允许我们在组件树中更深入地获取数据，直接在我们需要的地方 – 避免了属性钻取而不影响性能。
- en: The `queryKey` can also be a source of bugs, when it is accidentally reused
    for different requests. For example, we need to add the `featured` prop to the
    `queryKey` here, otherwise only either featured or regular posts would get fetched
    and returned twice. If you are getting weird results or outdated data returned
    from Query Hooks, make sure to check your query keys and ensure that you have
    a unique key for each request and that all parameters passed to the query function
    are also added to the query key.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`queryKey` 也可能成为错误的原因，当它意外地用于不同的请求时。例如，我们需要在这里将 `featured` 属性添加到 `queryKey`
    中，否则只会获取并返回一次特色帖子或常规帖子。如果你从 Query Hooks 获取到奇怪的结果或过时的数据，请确保检查你的查询键，并确保每个请求都有一个唯一的键，并且传递给查询函数的所有参数也都添加到了查询键中。'
- en: 'Next, we define the `queryFn` – a function that will be called when the query
    is executed. In this case, we simply call the `fetchPosts` function with the `featured`
    prop:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义 `queryFn` – 当查询执行时将被调用的函数。在这种情况下，我们简单地使用 `featured` 属性调用 `fetchPosts`
    函数：
- en: '[PRE58]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If the Query Hook is in a loading state, we show a loading message:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Query Hook 处于加载状态，我们显示一个加载消息：
- en: '[PRE59]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Similarly, if fetching the data did not work, we show an error message:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，如果获取数据失败，我们显示一个错误消息：
- en: '[PRE60]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Otherwise, everything is fine, and we can render the `PostList`:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，一切正常，我们可以渲染 `PostList`：
- en: '[PRE61]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Edit `src/App.jsx` and *remove* the following `PostList` import:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/App.jsx` 并 *删除* 以下 `PostList` 导入：
- en: '[PRE62]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '*Replace* it with an import of the `PostFeed` component:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*替换* 为 `PostFeed` 组件的导入：'
- en: '[PRE63]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Inside the `App` component, replace the `PostList` components with `PostFeed`
    components, as follows:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `App` 组件内部，将 `PostList` 组件替换为 `PostFeed` 组件，如下所示：
- en: '[PRE64]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: After implementing a way to fetch posts, let’s continue by using a Mutation
    Hook to create a new post.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现获取帖子方法后，让我们继续使用 Mutation Hook 来创建一个新的帖子。
- en: Creating posts using a Mutation Hook
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Mutation Hook 创建帖子
- en: Fetching posts required us to make a request to get data from the server when
    the component mounts. However, for creating posts, we want to make a request to
    the server when the user presses a button. To implement such a behavior, we need
    a Mutation Hook instead of a Query Hook.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 获取帖子需要我们在组件挂载时向服务器发送请求以获取数据。然而，为了创建帖子，我们希望在用户按下按钮时向服务器发送请求。为了实现这种行为，我们需要一个 Mutation
    Hook 而不是 Query Hook。
- en: 'Let’s get started implementing post creation using a Mutation Hook now:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始使用 Mutation Hook 实现帖子创建：
- en: 'Edit `src/api.js` and define a new function to create a post:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/api.js` 并定义一个新的创建帖子的函数：
- en: '[PRE65]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Inside it, we make a POST request, similarly to what we did before:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，我们发送一个 POST 请求，类似于我们之前所做的那样：
- en: '[PRE66]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If there was a problem with making the request, we throw an error:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果请求过程中出现问题，我们抛出一个错误：
- en: '[PRE67]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Otherwise, if the request was successful, we return the result:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，如果请求成功，我们返回结果：
- en: '[PRE68]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Edit `src/components/post/CreatePost.jsx` and import the `useMutation` and
    `createPost` functions, as well as the `queryClient`:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/components/post/CreatePost.jsx` 并导入 `useMutation` 和 `createPost` 函数，以及
    `queryClient`：
- en: '[PRE69]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '*Remove* the `dispatch` prop from the component, as we will not need it anymore:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*移除* 组件中的 `dispatch` 属性，因为我们不再需要它：'
- en: '[PRE70]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Inside the component, add a new Mutation Hook, passing the `createPost` function
    as the `mutationFn`:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件内部，添加一个新的突变钩子，将 `createPost` 函数作为 `mutationFn` 传递：
- en: '[PRE71]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Add an `onSuccess` handler, which will invalidate all queries that start with
    the `''posts''` query key:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `onSuccess` 处理程序，该程序将使所有以 `'posts'` 查询键开始的查询无效：
- en: '[PRE72]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: When a query key is invalidated, all Query Hooks that use it are automatically
    re-executed to fetch the new data, and the components are re-rendered to show
    it. In this case, we invalidate all query keys that start with `'posts'`, so we
    will be invalidating both `['posts', true]` for the featured posts feed, and `['posts',
    false]` for the regular posts feed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当查询键无效时，所有使用它的查询钩子会自动重新执行以获取新数据，并且组件会重新渲染以显示它。在这种情况下，我们将使所有以 `'posts'` 开头的查询键无效，因此我们将使特色帖子源中的
    `['posts', true]` 和常规帖子源中的 `['posts', false]` 都无效。
- en: '*Replace* the whole `handleSubmit` function with the following:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*替换* 整个 `handleSubmit` 函数，如下所示：'
- en: '[PRE73]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then, call the `mutate` function from the Mutation Hook, and reset the form
    after successfully executing the mutation:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从突变钩子中调用 `mutate` 函数，并在成功执行突变后重置表单：
- en: '[PRE74]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Additionally, we can improve the user experience for the component now. For
    example, we can use the `isPending` state to disable the submit button while the
    mutation is pending:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们现在可以改进组件的用户体验。例如，我们可以使用 `isPending` 状态在突变挂起时禁用提交按钮：
- en: '[PRE75]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'If there is an error during the mutation, we can also show the error message
    in red at the end of the form:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果突变过程中出现错误，我们还可以在表单末尾用红色显示错误消息：
- en: '[PRE76]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Try running the app, and you will see that it still works the same way as before,
    but now using TanStack Query!
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试运行应用程序，你会发现它仍然像以前一样工作，但现在使用 TanStack Query！
- en: When inserting a new post, you may notice that it gets added to the end now.
    Unfortunately, we cannot control how `json-server` inserts new posts into the
    array. If you want to add this behavior again, I suggest adding a `createdAt`
    timestamp to all posts and then use the `_sort` query param provided by the `json-server`
    tool to sort the posts by this timestamp. Doing so is left as an exercise for
    you.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当插入新帖子时，你可能注意到它现在被添加到了末尾。不幸的是，我们无法控制 `json-server` 如何将新帖子插入数组中。如果你想再次添加这种行为，我建议给所有帖子添加一个
    `createdAt` 时间戳，然后使用 `json-server` 工具提供的 `_sort` 查询参数按此时间戳对帖子进行排序。这样做将作为一个练习留给你。
- en: With the new structure of our app, we can further improve it a bit by using
    React Suspense and Error Boundaries!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们应用程序的新结构，我们可以通过使用 React Suspense 和错误边界来进一步改进它！
- en: '**Example code**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例代码**'
- en: The example code for this section can be found in the `Chapter06/Chapter06_3`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的示例代码可以在 `Chapter06/Chapter06_3` 文件夹中找到。请检查文件夹内的 `README.md` 文件，了解如何设置和运行示例。
- en: Introducing React Suspense and Error Boundaries
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 React Suspense 和错误边界
- en: In the previous section, we used the `isLoading` state from TanStack Query to
    show a loading message when the posts are still being fetched. While this works
    fine, handling loading states like that can get a bit messy. A better way to model
    loading states is to use React Suspense. React Suspense is a special component
    that can display a fallback until its children have finished loading. To use React
    Suspense, data fetching frameworks and libraries need to support it. Thankfully,
    TanStack Query supports Suspense. Frameworks like Relay and Next.js support it
    as well.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们使用了 TanStack Query 的 `isLoading` 状态来显示正在获取帖子时的加载消息。虽然这没问题，但处理这样的加载状态可能会有些混乱。更好地建模加载状态的方法是使用
    React Suspense。React Suspense 是一个特殊组件，可以在其子组件完成加载之前显示回退内容。要使用 React Suspense，数据获取框架和库需要支持它。幸运的是，TanStack
    Query 支持 Suspense。像 Relay 和 Next.js 这样的框架也支持它。
- en: Setting up a Suspense Boundary
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Suspense 边界
- en: To use Suspense, we need to define a Suspense Boundary with a fallback. If any
    child component within the boundary is fetching data, the fallback will be rendered
    in place of the boundary, replacing all the child components of it. When all data
    is fetched successfully, all child components will be rendered. This allows us
    to write code that assumes data is always there, and to handle the edge case further
    up in the tree.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Suspense，我们需要定义一个带有回退的Suspense边界。如果边界内的任何子组件正在获取数据，回退将替换边界，并替换其所有子组件。当所有数据成功获取后，所有子组件将被渲染。这允许我们编写假设数据始终存在的代码，并在树的上层进一步处理边缘情况。
- en: 'Let’s now get started setting up a Suspense Boundary for the post feed:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在开始为帖子源设置Suspense边界：
- en: 'Copy the `Chapter06_3` folder to a new `Chapter06_4` folder by executing the
    following command:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令将`Chapter06_3`文件夹复制到新的`Chapter06_4`文件夹：
- en: '[PRE77]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Open the new `Chapter06_4` folder in VS Code.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开新的`Chapter06_4`文件夹。
- en: 'Edit `src/App.jsx` and import `Suspense`:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/App.jsx`并导入`Suspense`：
- en: '[PRE78]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Adjust the `App` component to render the post feed within a Suspense Boundary,
    providing a loading message as fallback:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整`App`组件，使其在Suspense边界内渲染帖子源，提供加载消息作为回退：
- en: '[PRE79]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now, we need to adjust the `PostFeed` component to use the Suspense Query Hook
    instead. Edit `src/components/post/PostFeed.jsx` and adjust the import as follows:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要调整`PostFeed`组件以使用Suspense查询Hook。编辑`src/components/post/PostFeed.jsx`并按照以下方式调整导入：
- en: '[PRE80]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then, adjust the Hook, as follows:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按照以下方式调整Hook：
- en: '[PRE81]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We can now *remove* the following code from the component:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以从组件中*删除*以下代码：
- en: '[PRE82]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Start the app, as follows:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式启动应用：
- en: '[PRE83]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: You will see that instead of getting two loading messages (one for featured
    posts and one for regular posts), we now only see one loading message from the
    Suspense Boundary!
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现，我们不再看到两个加载消息（一个用于特色帖子，一个用于常规帖子），现在我们只看到一个来自Suspense边界的加载消息！
- en: '![Figure 6.4 – Loading messages before and after using React Suspense](img/B31327_06_04.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – 使用React Suspense前后加载消息的对比](img/B31327_06_04.png)'
- en: Figure 6.4 – Loading messages before and after using React Suspense
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 使用React Suspense前后加载消息的对比
- en: 'The loading messages may be disappearing too quickly for you to see, because
    we are running the backend locally, so there is no network delay. This is not
    a realistic scenario. In production, we would have latency on every request that
    we make. We can use the DevTools to simulate a slower network connection; let’s
    do that now:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 加载消息可能消失得太快，以至于你看不见，因为我们正在本地运行后端，所以没有网络延迟。这不是一个现实场景。在生产中，我们会对每个请求都有延迟。我们可以使用DevTools来模拟更慢的网络连接；让我们现在就做：
- en: In Google Chrome, open the inspector by right clicking on the website and pressing
    **Inspect**.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Google Chrome中，通过右键点击网站并按**Inspect**来打开检查器。
- en: The inspector will open, inside it, go to the **Network** tab.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查器将打开，在其内部，转到**网络**标签页。
- en: At the top of the Network tab, click on the **No throttling** dropdown.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网络标签页的顶部，点击**无限制**下拉菜单。
- en: 'Select the **3G** preset. See the following screenshot for reference:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**3G**预设。参见以下截图以供参考：
- en: '![Figure 6.5 – Simulating slow networks in Google Chrome DevTools](img/B31327_06_05.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5 – 在Google Chrome DevTools中模拟慢速网络](img/B31327_06_05.png)'
- en: Figure 6.5 – Simulating slow networks in Google Chrome DevTools
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 在Google Chrome DevTools中模拟慢速网络
- en: Refresh the page. You will now see the app slowly loading the posts.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新页面。你现在会看到应用正在缓慢加载帖子。
- en: Do not forget to set it back to **No throttling** to avoid having to wait so
    long for requests.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记将其设置回**无限制**，以避免请求需要等待很长时间。
- en: Next, let’s move on to setting up an Error Boundary.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续设置错误边界。
- en: Setting up an Error Boundary
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置错误边界
- en: As we have learned, a Suspense Boundary can provide a fallback while components
    are fetching data. However, you may have noticed that we also removed the error
    handling code. To provide a fallback when an error happens in a child component,
    we can use an Error Boundary. Error Boundaries work similar to Suspense Boundaries,
    but they react to error states rather than loading states.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，Suspense边界可以在组件获取数据时提供回退。然而，你可能已经注意到我们还删除了错误处理代码。当子组件发生错误时，我们可以使用错误边界来提供回退。错误边界的工作方式与Suspense边界类似，但它们对错误状态而不是加载状态做出反应。
- en: 'Let’s now get started setting up an Error Boundary:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在开始设置错误边界：
- en: 'First, install the `react-error-boundary` package:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，安装`react-error-boundary`包：
- en: '[PRE84]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Then, we create a component that will be rendered as a fallback when an error
    happens.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个组件，当发生错误时将作为回退渲染。
- en: 'Create a new `src/FetchErrorNotice.jsx` file. Inside it, define a component
    that takes a `resetErrorBoundary` function:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `src/FetchErrorNotice.jsx` 文件。在文件内部，定义一个组件，它接受一个 `resetErrorBoundary`
    函数：
- en: '[PRE85]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `resetErrorBoundary` function can be used to reset the operation that caused
    the error. In our case, it will retry the request to fetch posts.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`resetErrorBoundary` 函数可以用来重置导致错误的操作。在我们的例子中，它将重试获取帖子的请求。'
- en: 'Render an error message and a button that triggers the reset function:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染一个错误信息和触发重置函数的按钮：
- en: '[PRE86]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, edit `src/App.jsx` and import the `ErrorBoundary`, `QueryErrorResetBoundary`
    and `FetchErrorNotice`:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编辑 `src/App.jsx` 并导入 `ErrorBoundary`、`QueryErrorResetBoundary` 和 `FetchErrorNotice`：
- en: '[PRE87]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Inside the `App` component, wrap the Suspense Boundary with an Error Boundary,
    which is in turn wrapped by the `QueryErrorResetBoundary`, which provides the
    `reset` function to retry queries:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `App` 组件内部，将 Suspense Boundary 包裹在错误边界中，该错误边界反过来又包裹在 `QueryErrorResetBoundary`
    中，它提供了 `reset` 函数来重试查询：
- en: '[PRE88]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: If it is currently running, stop the app.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它目前正在运行，停止应用。
- en: 'Then, start only the client, as follows:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，只启动客户端，如下所示：
- en: '[PRE89]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Open the app in your browser, you will see the loading message. Wait a while
    until the request times out. Then, you will see the error message and the retry
    button:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开应用，你会看到加载信息。等待一段时间直到请求超时。然后，你会看到错误信息和重试按钮：
- en: '![Figure 6.6 – The Error Boundary being triggered by a request timeout](img/B31327_06_06.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 由请求超时触发的错误边界](img/B31327_06_06.png)'
- en: Figure 6.6 – The Error Boundary being triggered by a request timeout
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 由请求超时触发的错误边界
- en: 'Now, without quitting the client, additionally start the server, as follows:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，不退出客户端，另外启动服务器，如下所示：
- en: '[PRE90]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Press the **Try again** button. You will see the loading message again and then
    the list of posts!
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **重试** 按钮。你会再次看到加载信息，然后是帖子的列表！
- en: As we can see, Error Boundaries allow us to manage error states by displaying
    a fallback component and functionality to reset the operation that caused the
    error.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，错误边界允许我们通过显示回退组件和重置导致错误的操作的功能来管理错误状态。
- en: '**Example code**'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例代码**'
- en: The example code for this section can be found in the `Chapter06/Chapter06_4`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的示例代码可以在 `Chapter06/Chapter06_4` 文件夹中找到。检查文件夹内的 `README.md` 文件以获取设置和运行示例的说明。
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we first learned how to set up a simple API server from a JSON
    file. Then, we learned how to fetch and create posts using Effect and State/Reducer
    Hooks. Next, we implemented the same functionality using the TanStack Query library,
    which simplified our code and allowed us to leverage its caching abilities. Finally,
    we learned how to deal with loading states using React Suspense and error states
    using Error Boundaries.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先学习了如何从 JSON 文件设置一个简单的 API 服务器。然后，我们学习了如何使用 Effect 和 State/Reducer Hooks
    来获取和创建帖子。接下来，我们使用 TanStack Query 库实现了相同的功能，这简化了我们的代码并使我们能够利用其缓存能力。最后，我们学习了如何使用
    React Suspense 处理加载状态和使用错误边界处理错误状态。
- en: In the next chapter, we are going to learn about form handling in depth, by
    using Form Actions and Hooks, such as the `useActionState` Hook to handle form
    states and the `useOptimistic` Hook to implement optimistic updates.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过使用表单操作和 Hooks（例如 `useActionState` Hooks 来处理表单状态和 `useOptimistic`
    Hooks 来实现乐观更新）来深入学习表单处理。
- en: Questions
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To recap what we have learned in this chapter, try to answer the following
    questions:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾本章所学内容，尝试回答以下问题：
- en: How can we easily create a full REST API from a JSON file for mocking purposes?
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何轻松地从 JSON 文件创建一个完整的 REST API 以进行模拟？
- en: What are the advantages of using a proxy to access our backend server?
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用代理访问我们的后端服务器有哪些优势？
- en: Which combinations of Hooks can be used to implement data fetching?
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些 Hooks 的组合可以用来实现数据获取？
- en: Which advantages does TanStack Query have over our simple data fetching implementation?
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TanStack Query 相比我们简单的数据获取实现有哪些优势？
- en: Which Hook in TanStack Query is used for fetching data?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TanStack Query 中哪个 Hooks 用于获取数据？
- en: Which Hook in TanStack Query is used for making changes to the server?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TanStack Query 中哪个 Hooks 用于对服务器进行更改？
- en: What role does the query key play in the TanStack Query library?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询键在 TanStack Query 库中扮演什么角色？
- en: What is a Suspense Boundary used for?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Suspense Boundary 用于什么？
- en: What are Error Boundaries used for?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Error Boundaries 是用来做什么的？
- en: Further reading
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you are interested in more information about the concepts that we have learned
    in this chapter, take a look at the following links:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对本章学到的概念有更多兴趣，请查看以下链接：
- en: 'Official documentation of the `json-server` tool: [https://github.com/typicode/json-server](https://github.com/typicode/json-server)'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json-server` 工具的官方文档：[https://github.com/typicode/json-server](https://github.com/typicode/json-server)'
- en: 'Official documentation of the `concurrently` tool: [https://github.com/open-cli-tools/concurrently](https://github.com/open-cli-tools/concurrently)'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concurrently` 工具的官方文档：[https://github.com/open-cli-tools/concurrently](https://github.com/open-cli-tools/concurrently)'
- en: 'Official documentation of TanStack Query for React: [https://tanstack.com/query/latest/docs/framework/react/overview](https://tanstack.com/query/latest/docs/framework/react/overview)'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TanStack Query for React 的官方文档：[https://tanstack.com/query/latest/docs/framework/react/overview](https://tanstack.com/query/latest/docs/framework/react/overview)
- en: 'More information on **cross-origin resource sharing** (**CORS**): [https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 **跨源资源共享**（**CORS**）的更多信息：[https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)
- en: 'More information on the proxy setting in the Vite config: [https://vite.dev/config/server-options#server-proxy](https://vite.dev/config/server-options#server-proxy)'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Vite 配置中代理设置的更多信息：[https://vite.dev/config/server-options#server-proxy](https://vite.dev/config/server-options#server-proxy)
- en: 'More information on React strict mode: [https://react.dev/reference/react/StrictMode](https://react.dev/reference/react/StrictMode)'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 React 严格模式的更多信息：[https://react.dev/reference/react/StrictMode](https://react.dev/reference/react/StrictMode)
- en: 'Blog article about fetching data with React Hooks, without a library: [https://www.robinwieruch.de/react-hooks-fetch-data/](https://www.robinwieruch.de/react-hooks-fetch-data/)'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于使用 React Hooks 获取数据的博客文章，无需库：[https://www.robinwieruch.de/react-hooks-fetch-data/](https://www.robinwieruch.de/react-hooks-fetch-data/)
- en: 'More information about Suspense: [https://react.dev/reference/react/Suspense](https://react.dev/reference/react/Suspense)'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Suspense 的更多信息：[https://react.dev/reference/react/Suspense](https://react.dev/reference/react/Suspense)
- en: 'More information about Error Boundaries: [https://github.com/bvaughn/react-error-boundary](https://github.com/bvaughn/react-error-boundary)'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Error Boundaries 的更多信息：[https://github.com/bvaughn/react-error-boundary](https://github.com/bvaughn/react-error-boundary)
- en: Learn more on Discord
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的 Discord 社区——在那里你可以分享反馈，向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/wnXT0](Chapter_06.xhtml)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/wnXT0](Chapter_06.xhtml)'
- en: '![](img/image_%283%29.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_%283%29.png)'
