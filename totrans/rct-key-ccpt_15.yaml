- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Server-side Rendering & Building Fullstack Apps with Next.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Describe the difference between client-side and server-side React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine which kind of React app to build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build fullstack React apps with the help of the Next.js framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain the key features and advantages of Next.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thus far in this book, you have learned a lot about building client-side React
    applications, that is, applications where the (transpiled) React code executes
    in the browsers of your website visitors.
  prefs: []
  type: TYPE_NORMAL
- en: This makes sense because React was originally created to simplify the process
    of building interactive and reactive UIs by running JavaScript code on the client
    side. To this date, most React features, including the ones covered up to this
    point in this book (e.g., state, context, and routing), exist to fulfill this
    purpose.
  prefs: []
  type: TYPE_NORMAL
- en: But, as you will learn in this and the following chapters, you can actually
    also execute React code on the server side. There are certain React features that
    may only be used there—for example, React Server Components, which will be covered
    in great detail in the *Chapter 16,* *React Server Components & Server Actions*
    .
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will get you started with React on the server side, briefly explain
    what **server-side rendering** ( **SSR** ) is, and introduce you to Next.js, a
    popular and feature-rich fullstack framework for React that allows you to blend
    backend and frontend code. You will learn how to create Next.js apps and how to
    use core Next.js features like file-based routing.
  prefs: []
  type: TYPE_NORMAL
- en: What’s the Problem with Client-Side React Apps?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The big advantage of **single-page applications** ( **SPAs** ) and client-side
    React is that you can build highly reactive and interactive web UIs. The UI can
    be updated almost instantly, visible page reloads and switches can be avoided,
    and hence your users benefit from a mobile-app-like user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'But this reliance on client-side code (and, therefore, JavaScript) also has
    potential disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: If users disable JavaScript, the website will be pretty much unusable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initially fetched HTML document is almost empty—data fetching and content
    rendering only take place after that initial HTTP request and response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first point might not matter too much, since only a small subset of all
    users will disable JavaScript and you can show an appropriate warning message
    via the `<noscript>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: But the second point can have significant consequences. Since the initial HTML
    document is almost empty, users won’t see any content until all the JavaScript
    code has been fetched and executed. While most users might not see a notable delay,
    depending on the device and internet connection of a user, this may take up to
    a few seconds for some users.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, search engine crawlers (e.g., Google’s crawler) will not necessarily
    wait for all your client-side JavaScript code to be fetched and executed when
    indexing your page. Therefore, those crawlers may see a mostly empty page and
    hence rank your website badly (or not index it at all).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screen shot of a computer  Description automatically generated](img/B31339_15_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.1: The page content is nowhere to be found in the page source code
    (i.e., the fetched HTML document)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15.1* shows the page source code (which can be inspected by right-clicking
    on the website) of a typical React app. As you can see in that figure, there’s
    almost no content between the `<body>` tags. The title ( `"Hello World!"` ) and
    the text below it are missing in that source code. The content is missing there
    because it’s not part of the initial HTTP response. Instead, it’s rendered by
    the transpiled React code after the page loaded (and after that code was downloaded
    from the server).'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, these disadvantages won’t matter in all cases. If you’re building
    some company-internal application, or a UI that’s hidden behind some login (and
    hence won’t be indexed anyway), or if you’re only targeting users with fast devices
    and internet connections, you might not need to worry about these potential problems.
  prefs: []
  type: TYPE_NORMAL
- en: But if you’re building a public-facing website where search engine indexing
    matters or that may be visited by users with slow devices or internet connections,
    you might want to consider getting rid of these disadvantages. And that’s precisely
    where **SSR** can help out.
  prefs: []
  type: TYPE_NORMAL
- en: Making Sense of Server-side Rendering (SSR)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with React, SSR refers to the process of rendering web pages, and
    therefore your React components, on the server that handles the incoming HTTP
    request when a user visits your website.
  prefs: []
  type: TYPE_NORMAL
- en: With SSR enabled, the server will render your React component tree and hence
    produce the actual HTML code yielded by your components and their JSX instructions.
    It’s this finished HTML code that’s then sent back to the client. As a result,
    website visitors will receive an HTML file that’s not empty anymore but that instead
    contains the actual page content. Search engine crawlers will also see that content
    and index the page accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a software development process  Description automatically generated](img/B31339_15_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.2: React SSR in action'
  prefs: []
  type: TYPE_NORMAL
- en: Best of all, you don’t lose the client-side advantages of React because, when
    enabling SSR, React still works on the client side as it did before! It’ll take
    over control once that initial HTML document has been received and provide users
    with the same SPA experience you were able to deliver without SSR. Though, technically,
    when using SSR, React will be initialized slightly differently on the client.
    Instead of re-rendering the entire DOM there, it’ll **hydrate** the page content
    that was rendered on the server. **Hydration** means that React will connect your
    component structure to the rendered HTML code (which was rendered based on that
    same structure, of course) and make it interactive.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a software development process  Description automatically generated](img/B31339_15_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.3: After receiving the rendered HTML code, React hydrates the code
    on the client side'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, you’ll get the best of both worlds: non-empty, pre-rendered pages
    for the initial HTTP request sent by the browser, and a highly reactive web application
    for the user to enjoy.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding SSR to a React Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is extremely important to understand that SSR-enabled React applications
    need to execute code in two environments (server and browser), whereas client-side
    React applications only rely on the browser. Therefore, to use SSR, a server-side
    environment must be added to the React project—it’s not enough to just adjust
    the React code in a few places.
  prefs: []
  type: TYPE_NORMAL
- en: For example, standard Vite-based projects don’t support SSR out of the box.
    Consequently, if you want to support SSR, you must edit your Vite project setup
    (and some of your project code files) to enable executing React code on both the
    client and server side. For example, you must add some code that handles incoming
    HTTP requests and triggers React code execution on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Manually enabling SSR requires backend development and build process configuration
    knowledge—in addition to the React knowledge you need.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, though, as you’ll learn throughout this chapter, you often don’t
    need to go through that setup process. Instead, you can rely on frameworks like
    Next.js to do the heavy lifting for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re interested in manually configuring SSR in Vite-based projects, the
    official Vite SSR documentation is a great place to learn more: [https://vitejs.dev/guide/ssr](https://vitejs.dev/guide/ssr)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, you can explore the following demo project that was set up according
    to the official Vite SSR instructions: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/02-ssr-enabled](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/02-ssr-enabled)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that manually enabling SSR is a non-trivial process that requires advanced
    Node.js and backend development knowledge is one of the reasons why the official
    React documentation recommends creating new React projects with the help of frameworks
    like Next.js (see [https://react.dev/learn/start-a-new-react-project](https://react.dev/learn/start-a-new-react-project)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: But it’s not the only reason.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side Data Fetching Is Not Trivial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides the non-trivial setup process, SSR-enabled projects also suffer from
    another possible problem: server-side data fetching is difficult.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re building a React app that needs to fetch data in some components (e.g.,
    with the help of `useEffect()` , as shown in *Chapter 8* , *Handling Side Effects*
    ), you’ll find out that the data is not fetched when the component is rendered
    on the server. Instead, the data fetching will only occur on the client side.
    The server-side rendered HTML markup will not contain the content that depends
    on the fetched data.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this behavior is that React component functions are only executed
    on the server once—i.e., it’s only the first component render cycle that’s performed
    on the server. You can think of SSR producing only an initial page snapshot. Subsequent
    state updates are ignored, and effect functions (triggered via `useEffect()` )
    are also therefore not executed on the server side. As a result, data fetching
    that relies on effect functions and subsequent state updates will not work on
    the server side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example, where a `Todos` component function uses `useEffect()`
    to fetch some (dummy) to-dos data from [https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You find the complete example code on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/03-ssr-data-fetching](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/03-ssr-data-fetching)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: When running this code on the server, there won’t be any errors. Instead, the
    app will run as expected and fetch the dummy to-dos from the backend server.
  prefs: []
  type: TYPE_NORMAL
- en: However, the HTML document that’s produced on the server will not contain the
    fetched to-dos. Instead, it will just contain the fallback text ( `"No todos found"`
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![A computer screen with text  Description automatically generated](img/B31339_15_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.4: The rendered HTML does not contain the actual to-dos'
  prefs: []
  type: TYPE_NORMAL
- en: The generated markup does not contain the fetched to-dos because, as explained
    above, React component functions only execute once on the server side (and the
    function passed to `useEffect()` doesn’t execute at all).
  prefs: []
  type: TYPE_NORMAL
- en: Due to this behavior, you can’t easily perform asynchronous operations and,
    for example, fetch data via `useEffect()` in your React components when using
    SSR. Hence, the server-side rendered HTML content will never contain that data.
  prefs: []
  type: TYPE_NORMAL
- en: While you can come up with workarounds to that problem (e.g., perform the data
    fetching operation on the server, before executing the component functions) that’s
    a problem that will be solved by Next.js and a concept called **React Server Components**
    ( **RSC** ).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Next.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next.js is a React framework—i.e., a framework that builds upon React and adds
    extra features and patterns to it. Specifically, Next.js adds features like file-based
    routing, built-in SSR, or automatic caching to improve performance. Though, most
    importantly, it unlocks two crucial React concepts: **React Server Components**
    ( **RSC** ) and **Server Actions** . As you will learn, these features enable
    server-side React code to perform asynchronous operations and, for example, fetch
    and render data on the server.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, Next.js saves you the effort of manually enabling SSR, and, additionally,
    unlocks other powerful features that help with fetching data on the server.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: There are also alternative React frameworks like Remix/React Router (they were
    merged to bring optional fullstack React framework features to React Router) or
    TanStack Start.
  prefs: []
  type: TYPE_NORMAL
- en: Next.js has not only existed for a very long time but it’s also the most popular
    (measured by usage) fullstack framework at the point in time when this book was
    written.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will get you started with Next.js and provide a brief overview
    of its core concepts. The next chapter ( *Chapter 16* , *React Server Components
    & Server Actions* ) will then build upon this knowledge to dive even deeper.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Next.js Projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use Next.js, you must first create a Next.js project. Technically, it’ll
    still be a React project, which means you will be able to use React features like
    components, props, state, Hooks, or JSX. But it’ll be a project that comes with
    the `next` package installed, and that enforces a certain folder structure that’s
    needed by Next.js. You can’t install Next.js into an existing (Vite-based) React
    project and start using it there. Significant adjustments to the project configuration
    and structure would be required. Next.js brings its own build process and does
    not use Vite under the hood. Hence, creating a brand-new project makes more sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with a new Next.js project, you should run the following command
    in your system terminal or command prompt (in a place on your system where you
    want the new project folder to be created):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: After running this command, you’ll have to make a couple of choices in the terminal
    (e.g., if you want to use TypeScript).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can confirm all those choices by simply pressing the *Enter* key, hence
    accepting the default option. However, you should ensure that you choose `No`
    for TypeScript (unless you know how to use it) and `Yes` for **App Router** .
    You can find a (slightly cleaned up) starting project on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/04-nextjs-intro](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/04-nextjs-intro)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the created project folder, a development server can be started via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: While the command is the same as in a Vite project, the server will actually
    target a different port by default. Instead of `localhost:5173` (Vite), Next.js
    projects use `localhost:3000` for the preview development server.
  prefs: []
  type: TYPE_NORMAL
- en: Just as in a Vite-based project, you should keep this process up and running
    while you’re working on the project code. The underlying build process will automatically
    reload and update the preview website as you make changes to your code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Next.js is an established, mature framework that’s never stopped innovating
    and changing.
  prefs: []
  type: TYPE_NORMAL
- en: In late 2022, the so-called **App Router** was introduced as a new way of structuring
    and building Next.js applications (the old approach is now referred to as Pages
    Router). This book, of course, covers the new App Router approach.
  prefs: []
  type: TYPE_NORMAL
- en: As of mid-2024 (when this edition is written), the App Router approach, despite
    being marked as stable, still frequently receives new features and changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, even though unlikely, the concepts and code explained in this book
    may change or break over time. The setup process described above may change, too.
    In such cases, a note (with instructions on how to adjust the code) will be added
    to the Changelog document on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/main/CHANGELOG.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/main/CHANGELOG.md)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'A newly created Next.js project comes with all its dependencies installed (
    `npm install` is automatically executed as part of the project creation process)
    and a project structure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: An `app/` folder that holds route-related files (see the next section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `public/` folder that can be used to store assets that should be served statically
    (i.e., without being changed by the build process)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jsconfig.json` and `nextjs.config.mjs` files for configuring the project and
    Next.js-specific behaviors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package.json` and `package-lock.json` for managing project dependencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hence, except for the `app/` folder, it’s not too different from the structure
    you know from Vite. However, it is worth noting that Next.js, unlike Vite, does
    not enforce `.jsx` as a file extension for JavaScript files that contain JSX code.
    You can use it but you don’t have to. For example, the starting project uses `page.js`
    and `layout.js` , not `page.jsx` and `layout.jsx` , even though these files contain
    JSX code.
  prefs: []
  type: TYPE_NORMAL
- en: Just like Vite-based projects, Next.js projects come with a build workflow that
    processes and transpiles your code files automatically, when running the development
    server or building for production (which you can do via `npm run build` ).
  prefs: []
  type: TYPE_NORMAL
- en: Like pretty much all modern React project setups, Next.js projects therefore
    support importing style files (like `globals.css` ) or images into JavaScript
    files. It also allows you to omit or set file extensions on imports. In addition,
    Next.js has CSS Modules support, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put in other words: you can work in Next.js projects in pretty much the same
    way as you do in Vite-based projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with File-Based Routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Vite-based projects, you have a high degree of flexibility when it comes
    to the project structure. Inside the `src/` folder, you can create any subfolders
    and files of your choice. The names of those files and folders also don’t really
    matter (if they’re valid and use the right extensions).
  prefs: []
  type: TYPE_NORMAL
- en: When working with React Router, you would set up routes in one of your JSX code
    files and load any component stored in any file for any route (see *Chapter 13*
    , *Multipage Apps with React Router* ).
  prefs: []
  type: TYPE_NORMAL
- en: In Next.js projects, that’s a bit different because Next.js uses the file system
    for defining routes—you don’t set up routes in code. As a result, while you still
    have lots of flexibility, there are some routing-related rules regarding the project
    structure and file names that must be followed—otherwise, the app will break and
    not work as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Next.js implements file-based routing via its own built-in router. This router
    analyzes your file system and derives supported routes, their URL paths, and which
    React components to load and render based on the file and folder structure in
    your project.
  prefs: []
  type: TYPE_NORMAL
- en: When using the App Router approach, you therefore must store all components
    that should be loaded as pages inside the `app/` folder (or a nested folder) in
    files named `page.js` . Since all route component files must be named `page.js`
    , it’s the parent folder names that define the route path for which the component
    will get loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you might have a file and folder structure as shown in *Figure
    15.5* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a web site  Description automatically generated](img/B31339_15_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.5: In Next.js, page.js files contain route components. The folder
    names determine the path'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 15.5* , you can see that four routes are defined via the file system:
    a root route ( `/` ) and the `/about` , `/users` , and `/terms/en` routes. For
    each route, the component stored in the respective `page.js` will be loaded and
    rendered onto the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you might have an `app/page.js` file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, a regular React component function is stored in this `page.js`
    file. The name of the component function does not matter—it’s just important that
    it’s a component function that’s exported inside a file named `page.js` . As a
    result, the following content will be visible on the screen if a user visits `<domain>/`
    (or just `<domain>` , without the forward slash):'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_15_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.6: The Next.js router loads the component stored in the app/page.js
    file and renders its content'
  prefs: []
  type: TYPE_NORMAL
- en: You can therefore easily add as many, possibly nested, routes as needed—simply
    by creating folders, subfolders, and `page.js` files.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side Rendering with Next.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides providing a built-in file-based router (and many other features that
    will be explored throughout this and the next chapters), Next.js has one other
    crucial advantage: it implements SSR out of the box. You don’t have to add any
    files, change any configuration, or adjust any code to render React components
    on the server—instead, it works right from the start.'
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, the `app/page.js` file component (the `Home` component in the
    example above), is evaluated and rendered on the server side when a user visits
    `<domain>/` . It’s the finished HTML code that’s sent to the browser. And, just
    as with Vite-based projects with custom SSR, Next.js renders all child components
    that may be used inside of `page.js` on the server, too.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, when building websites with Next.js, you still build React apps.
    That’s why Next.js apps become interactive on the client side once the SSR is
    done. Technically, as you’ll also learn in the next chapter ( *React Server Components
    & Server Actions* ), they’ll be made interactive in a different way than in Vite-based
    SSR-enabled React apps (where React hydrates the server-side rendered markup on
    the client), but ultimately, your website users will have a SPA-like user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, if you want to build a React app that supports SSR, relying on a
    framework like Next.js instead of setting up SSR manually is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you will be able to use other helpful features, like the file-based
    routing system, especially since it doesn’t stop at defining routes via `page.js`
    files. It, for example, also simplifies the process of defining layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned, when it comes to routing, file names and where you store those
    files matter.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you’ll also find a `layout.js` file next to the `page.js` file
    in the `app/` folder from the example above.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a black screen  Description automatically generated](img/B31339_15_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.7: Besides a page.js file, a styling file, and a favicon, a layout.js
    file can be found in the app/ folder'
  prefs: []
  type: TYPE_NORMAL
- en: Just like `page.js` , `layout.js` is a reserved file name—i.e., that file is
    handled by Next.js in a special way.
  prefs: []
  type: TYPE_NORMAL
- en: This `layout.js` file also exports a component function, but the created component
    will not be rendered for one specific path. Instead, it is used as a wrapper around
    all sibling or nested pages. Thus, the `layout.js` file can be used to define
    JSX code that will be shared across multiple pages.
  prefs: []
  type: TYPE_NORMAL
- en: Since it’s meant to be used as a wrapper component, the component function exported
    by `layout.js` must use the special `children` prop (see *Chapter 3* , *Components
    & Props* ) to define the place where the wrapped page content should be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you could use the `app/layout.js` file to define a global layout
    that adds a navigation bar above the `<main>` content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example code snippet, it’s also worth noting that the `RootLayout` component
    renders the `<html>` and `<body>` elements. In Vite-based projects, that’s not
    something you would do. There, you instead define a place in the `index.html`
    file where the rendered HTML should be injected (via the `createRoot()` function
    exposed by the `react-dom` package; see *Chapter 2* , *Understanding React Components
    & JSX* ).
  prefs: []
  type: TYPE_NORMAL
- en: Next.js does not rely on such an `index.html` file; instead, it forces you to
    define a root `layout.js` file at the top level of the `app/` folder. It’s then
    this root layout that must define the general structure of the rendered HTML page.
    However, there is no `<head>` section in that file, since Next.js will manage
    and inject that section behind the scenes. In addition, Next.js will also insert
    JavaScript and CSS imports into the rendered HTML document.
  prefs: []
  type: TYPE_NORMAL
- en: You may add more (nested) `layout.js` files if you want to have nested layouts
    that only wrap some of your pages. Such layouts are optional; the root layout
    ( `app/layout.js` ) is mandatory, however.
  prefs: []
  type: TYPE_NORMAL
- en: With a `layout.js` file like the one shown in the previous code example, in
    a project that contains an `app/page.js` file, and an `app/events/page.js` file,
    website users could visit both pages and see a shared navigation.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_15_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.8: As the user navigates from/to /events, the shared header persists'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 15.8* , the main content (defined by the `page.js` files) changes
    but the shared navigation (set up in `layout.js` ) persists.
  prefs: []
  type: TYPE_NORMAL
- en: 'While sharing JSX markup is the most common use case for using layouts, you
    can also use them to share styles by importing a CSS file into a `layout.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this and the above examples, the component function is named `RootLayout`
    —that name does not matter, but it must be a component that’s exported.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, layouts that are used to share a navigation bar become even more
    useful if you add working links to them…
  prefs: []
  type: TYPE_NORMAL
- en: Managing Internal Navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous code example, the `<a>` element was used for creating links
    between the different Next.js application pages.
  prefs: []
  type: TYPE_NORMAL
- en: However, just like other React apps, Next.js applications become SPAs once the
    initial page load is done. Therefore, creating internal links via `<a>` tags is
    discouraged for the same reasons it was discouraged when using React Router in
    Vite-based React projects (compare *Chapter 13* , *Multipage Apps with React Router*
    ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Like React Router, Next.js (which takes care of routing in Next.js projects)
    provides a special `Link` component that you should use for internal links (instead
    of the `<a>` element):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This `<Link>` component accepts a `href` prop, which is set to the target path.
    Internally, Next.js will capture link clicks and update the browser address bar
    and website UI accordingly by loading and rendering the required `page.js` components.
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting Active Links & Using the “use client” Directive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to style links differently when they lead to the currently active
    page, you won’t find a built-in `NavLink` component as is the case with React
    Router. Instead, you must add your own logic by setting the `Link` component’s
    `className` prop dynamically based on the currently active path.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out which path is currently active, you can use the `usePathname()`
    Hook provided by Next.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, you could adjust the `layout.js` file to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you were to run this code, you’d get an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_15_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.9: Next.js complains about the usage of a Hook in a Server Component'
  prefs: []
  type: TYPE_NORMAL
- en: This error message sounds quite cryptic as it mentions a `Client Component`
    and `Server Components` . Both are crucial React concepts that will be explored
    in the next chapter ( *React Server Components & Server Actions* ).
  prefs: []
  type: TYPE_NORMAL
- en: 'For the current chapter, it’s enough to know the fix for this problem, which
    is to add the `"use client"` directive at the top of the `app/layout.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`"use client"` is a so-called **directive** , i.e., an instruction that “tells”
    React and Next.js that this file must be handled in a special way. Adding it will
    get rid of the error message shown in *Figure 15.9* , thus enabling path-aware
    `Link` styling. As mentioned, the concrete impact of this directive will be explored
    in the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you plan to use a Hook in a component in a Next.js project, the `"use
    client"` directive must be added—no matter if it’s a Hook provided by React or
    Next.js.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder why `"use client"` is required for components that use Hooks.
    After all, this directive was not needed when using SSR in Vite-based projects.
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that Next.js technically doesn’t use SSR, as introduced at the
    beginning of this section. Instead, Next.js (when using the App Router) uses a
    React feature called React Server Components. This crucial feature will be explored
    in great detail in the next chapter. There, you’ll also learn why exactly `"use
    client"` is needed in some components.
  prefs: []
  type: TYPE_NORMAL
- en: Creating & Using Regular Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Link` component mentioned in the previous sections is a component offered
    by Next.js. But, of course, you can also build your own components—it is still
    a React app after all.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the components that are exposed as pages ( `page.js` ) or layouts (
    `layout.js` ), you can create and use component functions in any files (with any
    names) of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can add a `components/` folder next to the `app/` folder and
    add a `MainNavigation.js` file in it. This file can then hold a new `MainNavigation`
    component that returns the navigation-related JSX code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Please note that `"use client"` must be added at the top of this `MainNavigation.js`
    file since the `usePathname()` Hook is used in the component function.
  prefs: []
  type: TYPE_NORMAL
- en: With the code moved into this newly added `MainNavigation` component, inside
    the `layout.js` file, `"use client"` can be removed since the `usePathname()`
    Hook is no longer used in that file. It’s used in a child component (inside `<MainNavigation/>`
    ) but React does not care about this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, the updated `layout.js` file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to building, outsourcing, and using the custom `MainNavigation` component,
    the updated `layout.js` file therefore contains a lean and concise component function
    again.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: With the exception of the route-related files, it is entirely up to you how
    you structure your Next.js project and how you name your files.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, you can store custom (non-page) components in a `components/`
    folder (or a folder with any other name of your choice) in any place of your choice.
    You can put that `components/` folder into the `app/` folder or into the root
    project folder.
  prefs: []
  type: TYPE_NORMAL
- en: You can also not use a `components/` folder at all, and instead store components
    in files that are located next to your `page.js` files. Because if a file is not
    named `page.js` , it won’t be treated as a page—so there is no danger of accidentally
    creating routes you don’t want in your project. If you have an `app/components/MainNavigation.js`
    but no `app/components/page.js` file, there won’t be a `/components` route. Files
    not named `page.js` (or one of the other reserved filenames—see the upcoming section
    *Other Filename Conventions* ) will simply be ignored by Next.js (for routing
    purposes).
  prefs: []
  type: TYPE_NORMAL
- en: 'You find more information and ideas regarding Next.js project organization
    in the official documentation: [https://nextjs.org/docs/app/building-your-application/routing/colocation](https://nextjs.org/docs/app/building-your-application/routing/colocation)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Handling Dynamic Routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you learned in *Chapter 13* , *Multipage Apps with React Router* , in the
    *From Static to Dynamic Routes* section, many React apps need to support dynamic
    routes, too.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you might want to allow your users to visit `/events/e1` to view
    the details for an event with ID `e1` and `/events/e2` for an event with ID `e2`
    (and so on).
  prefs: []
  type: TYPE_NORMAL
- en: This is such a common requirement that Next.js, of course, supports it. You
    can add dynamic routes in a Next.js app by creating a folder (somewhere in the
    `app/` folder) that has its name wrapped by square brackets—for example, `app/events/[eventId]`
    . Of course, you still need a `page.js` file in that folder to actually create
    a route.
  prefs: []
  type: TYPE_NORMAL
- en: The part between the square brackets ( `eventId` , in this example) is entirely
    up to you. But the square brackets tell Next.js that you’re setting up a dynamic
    route.
  prefs: []
  type: TYPE_NORMAL
- en: The folder name between the square brackets acts as an identifier that can be
    used to retrieve the concrete value encoded in the URL (e.g., to retrieve `e1`
    in `/events/e1` ).
  prefs: []
  type: TYPE_NORMAL
- en: Every component that’s used as a page (or layout) receives a `params` prop that’s
    automatically set by Next.js. If it’s a page or layout in a dynamic route folder
    or in some nested child folder, the `params` prop will hold a `Promise` which
    resolves to an object that contains the chosen identifiers (like `eventId` ) as
    keys and the concrete URL path values (like `e1` ) as values for those keys. Since
    `params` holds a `Promise` , `await` must be used on it to get access to the underlying
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `app/events/[eventId]/page.js` file would ensure that the
    component exported inside the `page.js` file gets rendered for visits to `/events/e1`
    , `/events/e2` , etc. This page component can then output event details with the
    help of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the automatically provided `params` prop is used to get access
    to the `eventId` encoded in the URL. If some other identifier than `eventId` would
    be used in the folder name, that alternative name would be used to access the
    path value (e.g., for `[id]/page.js` , you’d access ( `await` `params).id` ).
  prefs: []
  type: TYPE_NORMAL
- en: As a result, users can visit this dynamic route and explore the event details
    for a chosen event ID.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer screen  Description automatically generated](img/B31339_15_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.10: The event details are loaded and displayed for /events/e1'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the complete example code, including the `lib/events.js` file,
    on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/08-nextjs-dynamic-routes](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/08-nextjs-dynamic-routes)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, when working with dynamic routes, you typically also need links
    to those dynamic paths in some parts of your application. Therefore, in this example,
    the `app/events/page.js` file contains code that dynamically renders a list of
    event items, where every item has a link to its detail page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Clicking these links will take users to the event detail page for the specific
    event ID.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Static routes, dynamic routes, and nested routes are the most important route
    types you need to know when working with Next.js. You’ll use them for most of
    your routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, Next.js also offers other (more advanced and niche) route types
    and features that are worth exploring if you decide to dive deeper into Next.js:
    [https://nextjs.org/docs/app/building-your-application/routing](https://nextjs.org/docs/app/building-your-application/routing)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Besides different route types that are enabled by using the proper folder names,
    Next.js also offers additional reserved filenames.
  prefs: []
  type: TYPE_NORMAL
- en: Other Filename Conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next.js does not just offer a variety of route types and routing-related features—it
    also offers more reserved filenames than just `page.js` and `layout.js` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, when working with the Next.js App Router, you should also be aware
    that the following reserved filenames exist, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '`loading.js` files can be added next to or above `page.js` and `layout.js`
    files to define components that should be displayed whilst the page (or layout)
    component is fetching data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error.js` files can be added in the same places as `loading.js` files to render
    error fallback components in case one of the sibling or child pages throws an
    error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`not-found.js` files can be added to display fallback content in case a website
    visitor tries to load a non-existent route or resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`route.js` files can be added to set up routes that do not render components
    but instead return data (e.g., in the JSON format).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can learn more about these file types and even more file name conventions
    in the official documentation: [https://nextjs.org/docs/app/building-your-application/routing#file-conventions](https://nextjs.org/docs/app/building-your-application/routing#file-conventions)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also see some of these file types in action in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Diving Deeper into Next.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you have a solid Next.js foundation but, as mentioned in the
    previous section, you can dive deeper into Next.js with the help of the official
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: There, besides learning more about routing, route types, and filenames, you
    can also explore how Next.js helps with caching, styling, or managing page metadata.
    Since this book is primarily about React itself, and not about Next.js, covering
    all these topics here would quickly bloat this book.
  prefs: []
  type: TYPE_NORMAL
- en: That’s why this chapter focused on setting a solid React SSR and Next.js foundation.
    The essentials covered throughout this chapter will help with understanding more
    advanced React and Next.js features like React Server Components in the next chapter.
    In addition, thanks to these fundamentals, you’ll also be able to quickly learn
    more about Next.js with the help of the official documentation or dedicated Next.js
    books or courses.
  prefs: []
  type: TYPE_NORMAL
- en: Summary and Key Takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Vite-based React apps (like most React apps that don’t use Next.js
    or a similar framework) only support client-side rendering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without SSR, a relatively empty `index.html` file is sent to the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This can lead to bad user experiences (if users see an empty page for a prolonged
    period) or suboptimal search engine ranking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can enable SSR by manually adjusting React projects (code and build process)
    to support component function execution on the server side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To avoid custom SSR setup work and take advantage of many other benefits, you
    can use frameworks like Next.js.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next.js projects come with built-in SSR support and can be created via the `npx
    create-next-app` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modern Next.js uses the App Router approach, which takes advantage of an `app/`
    directory that is used for setting up routes with the help of the file system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside `app/` , you define pages by creating folders that contain `page.js`
    files (e.g., `app/about/page.js` adds support for an `/about` route).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To share JSX code (and logic or styles) across pages, you can add `layout.js`
    files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next.js also offers other reserved filenames to handle fallback content that’s
    shown while loading data or to handle errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can link between pages via Next.js’ `Link` component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using React Hooks (like `useState()` or Next.js’ `useRouter()` ), you must
    add the `"use client"` directive at the top of the file that uses the Hook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides static pages (like `app/events/page.js` or `app/about/page.js` ), you
    can also set up dynamic pages by enclosing a folder name with square brackets
    (e.g., `app/events/[eventId]/page.js` ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic path parameter values can be extracted in the loaded page component
    by using the special `params` prop that’s set on the component by Next.js.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous operations can be problematic when using SSR—or, at least, they
    can’t be executed in components that are rendered on the server, hence forcing
    the client-side code to perform them. At least when not using React Server Components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s Next?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, you have learned a lot about SSR in React apps and about Next.js.
    You’re able to create Next.js projects, define routes, render page components,
    add navigation, and work with dynamic paths.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned that Next.js comes with built-in SSR. Thus, all React components
    (built-in and custom, page and non-page) are rendered on the server when a website
    visitor sends a request.
  prefs: []
  type: TYPE_NORMAL
- en: Modern Next.js does not stop there, though—instead, unlike the custom SSR setup
    introduced at the beginning of this chapter, Next.js projects that use the App
    Router help with asynchronous data fetching on the server side by unlocking React’s
    **React Server Component** feature. It’s that feature, and **Server Actions**
    , that will be explored in great detail in the next chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Test Your Knowledge!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your knowledge of the concepts covered in this chapter by answering the
    following questions. You can then compare your answers to examples that can be
    found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/15-ssr-next-intro/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/15-ssr-next-intro/exercises/questions-answers.md)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: Which two main advantages can SSR offer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some potential disadvantages or weaknesses of SSR?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Next.js help with SSR?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are routes configured in Next.js (when using the “App Router”)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s special about a page component in Next.js?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the purpose of layout components in Next.js?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where can you store non-page (and non-layout) React components in a Next.js
    project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When and where do you need to add the `"use client"` directive?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply What You Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all the newly gained knowledge about Next.js, it’s time to apply it to
    a real demo project—a demo application that will be rendered on the server.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you’ll find an activity that allows you to practice
    working with Next.js. As always, you will also need to employ some of the concepts
    covered in earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 15.1: Migrating a Vite-Based React Router App'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, your job is to build upon the Vite-based app from *Activity
    13.1* . That app was built with Vite and React Router. Your job is to migrate
    it from Vite and React Router to Next.js.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, you should create a new Next.js project (using the App Router) and
    rebuild the same app in that project.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the starting code for this activity at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/activities/practice-1-start)
    . When downloading this code, you’ll always download the entire repository. Make
    sure to then navigate to the subfolder with the starting code ( `activities/practice-1-start`
    , in this case) to use the right code snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since your task is to migrate the project that was built in *Activity 13.1*
    , you might also want to use the finished code from that activity. You can find
    it here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/activities/practice-1)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'After downloading the code and running `npm install` in the project folder
    to install all required dependencies, the solution steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If you created a new Next.js project (i.e., if you’re not using the provided
    starting snapshot), clean up the `layout.js` and `page.js` files to remove everything
    but the component functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create two new routes: a `/products` route and a `/products/<some-id>` route.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Migrate the `data.js` file into the Next.js project (e.g., into a `lib/` folder
    in the root project folder).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the page components to load and display the data provided by the `data.js`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `components/` folder and migrate (copy) the `MainNavigation` component
    into this folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `MainNavigation` component (and any other component that needs it)
    to use Next.js’ `Link` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Highlight active links with the help of the `usePathname()` Hook—don’t forget
    about the `"use client"` directive!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Migrate the styles from the `index.css` file into the `globals.css` file. Make
    sure that the file gets imported into the root layout file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected result should look as shown in the following screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_15_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.11: The home page content'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_15_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.12: The /products page content'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_15_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.13: The /products/<some-id> page content'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find the full code for this activity, and an example solution, here:
    [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/activities/practice-1)
    .'
  prefs: []
  type: TYPE_NORMAL
