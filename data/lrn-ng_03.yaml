- en: Introducing TypeScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍TypeScript
- en: In the previous chapter, we built our very first component and we used TypeScript
    to shape the code scripts, which gave form to it. All the examples included in
    this book use its syntax. As we will see later in this book, writing our scripts
    in TypeScript and leveraging its static typing will give us a remarkable advantage
    over the other scripting languages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了我们的第一个组件，并使用TypeScript来塑造代码脚本，从而赋予其形式。本书中的所有示例都使用其语法。正如我们将在本书中看到的，使用TypeScript编写我们的脚本并利用其静态类型将使我们在其他脚本语言上具有显着优势。
- en: This chapter is not a thorough overview of the TypeScript language. We will
    just focus on the core elements of the language and study them in detail on our
    journey through Angular. The good news is that TypeScript is not all that complex,
    and we will manage to cover most of its relevant parts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不是对TypeScript语言的全面概述。我们将只关注语言的核心元素，并在我们学习Angular的过程中详细研究它们。好消息是，TypeScript并不那么复杂，我们将设法涵盖它的大部分相关部分。
- en: 'In this chapter, we will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Look at the background and rationale behind TypeScript
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看TypeScript背后的背景和原理
- en: Discover online resources to practice while we learn
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现在线资源，练习学习
- en: Recap on the concept of typed values and how to represent them
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾类型化值的概念以及如何表示它们
- en: Build our own types, based on classes and interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建我们自己的类型，基于类和接口
- en: Learn to better organize our application architecture with modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会更好地组织我们的应用架构与模块
- en: Understanding the case for TypeScript
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解TypeScript的案例
- en: The natural evolution of the early JavaScript-driven small web applications
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 早期JavaScript驱动的小型Web应用程序的自然演变
- en: into thick monolithic clients unveiled the shortcomings of the ECMAScript 5
    JavaScript specification. In a nutshell, large-scale JavaScript applications suffered
    from serious maintainability and scalability problems as soon as they grew in
    size and complexity.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将厚重的单片客户端揭示了ECMAScript 5 JavaScript规范的缺陷。简而言之，一旦规模和复杂性增加，大规模JavaScript应用程序就会遭受严重的可维护性和可扩展性问题。
- en: This issue became more relevant as new libraries and modules required seamless
    integration onto our applications. The lack of good mechanisms for interoperability
    led to really cumbersome solutions that never seemed to fit the bill.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新的库和模块需要无缝集成到我们的应用程序中，这个问题变得更加重要。缺乏良好的互操作机制导致了一些非常繁琐的解决方案，似乎从未符合要求。
- en: As a response to these concerns, ECMAScript 6 (also called as ES6 or ES2015)
    promised to solve these maintainability and scalability issues by introducing
    better module loading functionalities, an improved language architecture for better
    handling of scope, and a wide variety of syntactic sugar to better manage types
    and objects. The introduction of class-based programming turned into an opportunity
    to embrace a more OOP approach when building large-scale applications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对这些问题的回应，ECMAScript 6（也称为ES6或ES2015）承诺通过引入更好的模块加载功能、改进的语言架构以更好地处理作用域，并引入各种语法糖来更好地管理类型和对象，来解决这些可维护性和可扩展性问题。基于类的编程的引入成为了在构建大规模应用程序时采用更OOP方法的机会。
- en: Microsoft took on the challenge and spent nearly two years building a superset
    of the language, combining the conventions of ES6 and borrowing some proposals
    from ES7\. The idea was to launch something that helped out with building enterprise
    applications with a lower error footprint by means of static type checking, better
    tooling, and code analysis.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 微软接受了这一挑战，花了近两年的时间构建了一种语言的超集，结合了ES6的约定，并借鉴了ES7的一些提案。其想法是推出一些有助于通过静态类型检查、更好的工具和代码分析来构建企业应用程序的东西，以际降低错误率。
- en: After two years of development led by Anders Hejlsberg, lead architect of C#
    and creator of Delphi and Turbo Pascal, TypeScript 0.8 was finally introduced
    in 2012 and it reached Version 1.0 two years later. TypeScript was not only running
    ahead of ECMAScript 6, but it also implemented the same features and provided
    a solid environment for building large-scale applications by introducing, among
    other features, optional static typing through type annotations, thereby ensuring
    type checking at compile time. This contributes to catching errors in earlier
    stages of the development process. The support for declaration files also gives
    developers the opportunity to describe the interface of their modules, so other
    developers can better integrate them into their code workflow and tooling.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在由C#首席架构师Anders Hejlsberg领导的两年开发之后，TypeScript 0.8终于在2012年推出，并在两年后达到了1.0版本。TypeScript不仅领先于ECMAScript
    6，而且还实现了相同的功能，并通过类型注释引入了可选的静态类型，从而确保了编译时的类型检查。这有助于在开发过程的早期阶段捕获错误。声明文件的支持也为开发人员提供了描述其模块接口的机会，以便其他开发人员可以更好地将其集成到其代码工作流程和工具中。
- en: The benefits of TypeScript
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript的好处
- en: The following infographic provides a bird's eye view of the different features
    that
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下信息图提供了对不同功能的俯视。
- en: distinguish ECMAScript 6 from ECMAScript 5, and then differentiates TypeScript
    from the two.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 区分ECMAScript 6和ECMAScript 5，然后区分TypeScript与这两者。
- en: 'As a superset of ECMAScript 6, one of the main advantages of embracing TypeScript
    in your next project is the low entry barrier. If you know ECMAScript 6, you are
    pretty much all set, since all the additional features in TypeScript are optional.
    You can pick and introduce in your practice the features that help you to achieve
    your goal. All in all, there is a long list of strong arguments for advocating
    for TypeScript in your next project and all of them obviously apply to Angular
    as well. Here is a short rundown of arguments, just to name a few:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 作为ECMAScript 6的超集，采用TypeScript在下一个项目中的主要优势之一是低入门门槛。如果你了解ECMAScript 6，那么你几乎已经具备了一切，因为TypeScript中的所有附加功能都是可选的。你可以选择并引入在实践中帮助你实现目标的功能。总的来说，有很多有力的论点支持在下一个项目中倡导使用TypeScript，所有这些显然也适用于Angular。以下是一些论点的简要概述，仅举几例：
- en: Annotating our code with types ensures a consistent integration of our different
    code units and improves code readability and comprehension.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用类型注释我们的代码可以确保不同代码单元的一致集成，并提高代码的可读性和理解性。
- en: The TypeScript's built-in type-checker will analyze your code at runtime and
    help you prevent errors even before executing your code.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript的内置类型检查器将在运行时分析您的代码，并帮助您在执行代码之前防止错误。
- en: The use of types ensures consistency across your applications. In combination
    with the previous two, the overall code errors footprint gets minimized in the
    long run.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型可以确保应用程序的一致性。与前两者结合使用，从长远来看，整体代码错误的印记得到最小化。
- en: TypeScript extends classes with longtime demanded features such as class fields,
    private members, enums, and so on.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript通过类字段、私有成员、枚举等长期需求的功能扩展了类。
- en: The use of decorators opens the door to extend our classes and implementations
    in unparalleled ways.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用装饰器为我们打开了以前无法企及的方式来扩展我们的类和实现。
- en: Creating interfaces and type definition files (which we will not cover in this
    book) ensures a smooth and seamless integration of our libraries in other systems
    and codebases.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建接口和类型定义文件（本书不涉及）确保了我们的库在其他系统和代码库中的平稳无缝集成。
- en: TypeScript support across the different IDEs on store is terrific, and we can
    benefit from code highlighting, real-time type checking, and automatic compilation
    at no cost.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript在商店中不同IDE的支持非常好，我们可以从代码高亮、实时类型检查和自动编译中受益，而且没有任何成本。
- en: The TypeScript syntax will definitely please developers coming from other backgrounds
    such as Java, C#, C++, and so on.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript的语法肯定会让来自其他背景（如Java、C＃、C ++等）的开发人员感到满意。
- en: Introducing TypeScript resources in the wild
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在野外介绍TypeScript资源
- en: Now, we are going to take a look at where we can get further support to learn
    and test-drive our new knowledge of TypeScript.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看在哪里可以获得更多支持来学习和测试我们对TypeScript的新知识。
- en: The TypeScript official site
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript官方网站
- en: 'Obviously, our first stop is the official site for the language: [http://www.typescriptlang.org](http://www.typescriptlang.org).
    There, we can find a more extensive introduction to the language and links to
    IDEs and corporate supporters of this project. Nevertheless, the most important
    sections that we will definitely revisit more often are the learn section and
    the play sandbox.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们首先要去官方网站了解这门语言：[http://www.typescriptlang.org](http://www.typescriptlang.org)。在那里，我们可以找到更详尽的语言介绍以及IDE和企业支持者的链接。然而，我们肯定会经常回顾的最重要部分是学习部分和play沙盒。
- en: The learn section gives us access to a quick tutorial to get up to speed with
    the language in no time. It might be interesting as a recap on what we discussed
    in the previous chapter, but we would suggest you skip it in favor of the sample
    pages and the language spec, the latter being a direct link to the full extensive
    documentation of the language at GitHub. This is a priceless resource for both
    new and experienced users.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 学习部分为我们提供了快速教程，让我们迅速掌握这门语言。这可能是对我们在上一章讨论的内容的一个回顾，但我们建议您跳过它，转而查看示例页面和语言规范，后者是指向GitHub上语言完整广泛文档的直接链接。这对新用户和有经验的用户都是无价的资源。
- en: The play section offers a convenient sandbox, including some readymade code
    examples, covering some of the most common traits of the language. We encourage
    you to leverage this tool to test out the code examples we will see throughout
    this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: play部分提供了一个方便的沙盒，包括一些现成的代码示例，涵盖了语言的一些最常见特性。我们鼓励您利用这个工具来测试我们在本章中将看到的代码示例。
- en: The TypeScript official wiki
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript官方wiki
- en: We made a reference to the TypeScript wiki in the previous chapter when speaking
    about the most basic parameters we need to know when executing commands with the
    TypeScript compiler API.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，当我们谈到使用TypeScript编译器API执行命令时，我们提到了TypeScript的wiki中最基本的参数。
- en: The code for TypeScript is fully open sourced at GitHub, and the Microsoft team
    has made a good effort at documenting the different facets of the code in the
    wiki available on the repository site. We encourage you to go take a look at it
    any time you have a question or want to delve deeper into any of the language
    features or form aspects of its syntax.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的代码完全开源在GitHub上，微软团队在存储库网站上提供了对代码不同方面的良好文档。我们鼓励您随时查看，如果您有问题或想深入了解语言特性或语法方面的任何内容。
- en: The wiki is located at: [https://github.com/Microsoft/TypeScript/wiki](https://github.com/Microsoft/TypeScript/wiki).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: wiki位于：[https://github.com/Microsoft/TypeScript/wiki](https://github.com/Microsoft/TypeScript/wiki)。
- en: Types in TypeScript
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript中的类型
- en: Working with TypeScript or any other coding language means basically working
    with data, and such data can represent different sorts of content. This is what
    we know as types, a noun used to represent the fact that such data can be a text
    string, an integer value, or an array of these value types, among others. This
    is nothing new to JavaScript, since we have always been working implicitly with
    types, but in a flexible manner. This means that any given variable could assume
    (or return, in the case of functions) any type of value. Sometimes, this leads
    to errors and exceptions in our code because of type collisions between what our
    code returned and what we expected it to return type-wise. While this flexibility
    can still be enforced by means of any type that we will see later on in this chapter,
    statically typing our variables gives us and our IDEs a good picture of what kind
    of data we are supposed to find on each instance of code. This becomes an invaluable
    way to help debug our applications at compile time before it's too late. To investigate
    how a language feature works, I suggest you use a playground for two reasons.
    The first reason is to learn how the feature works. The second reason is to know
    the corresponding ES5 code it produces. I suggest using the following playground
    for this: [https://www.typescriptlang.org/play/.](https://www.typescriptlang.org/play/)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TypeScript或任何其他编程语言基本上意味着使用数据，这些数据可以表示不同类型的内容。这就是我们所知的类型，一个用来表示这样的数据可以是文本字符串、整数值或这些值类型的数组等的名词。这对JavaScript来说并不新鲜，因为我们一直在隐式地使用类型，但是以一种灵活的方式。这意味着任何给定的变量都可以假定（或返回，在函数的情况下）任何类型的值。有时，这会导致我们的代码出现错误和异常，因为我们的代码返回的类型与我们期望的类型发生了冲突。虽然这种灵活性仍然可以通过我们将在本章后面看到的任何类型来强制执行，但是静态地为我们的变量标注类型可以给我们和我们的IDE提供一个很好的图片，说明我们应该在每个代码实例中找到什么样的数据。这成为在编译时帮助我们调试应用程序的无价方式，而不至于为时已晚。要调查语言特性的工作原理，我建议您使用游乐场，有两个原因。第一个原因是学习该功能的工作原理。第二个原因是了解它产生的相应的ES5代码。我建议使用以下游乐场进行此操作：[https://www.typescriptlang.org/play/.](https://www.typescriptlang.org/play/)
- en: String
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Probably one of the most widely used primitive types in our code will be the
    string type, where we populate a variable with a piece of text:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码中可能最广泛使用的原始类型之一将是字符串类型，我们用一段文本填充一个变量。
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Check out the type assignation next to the variable name, which is separated
    by a colon symbol. This is how we annotate types in TypeScript, as we already
    saw in the previous chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 检查变量名称旁边的类型赋值，用冒号符号分隔。这就是我们在TypeScript中注释类型的方式，就像我们在上一章中看到的那样。
- en: 'Back to the string type, we can use either single or double quotes, and it
    is same as ECMAScript6\. We can define multiline text strings with support for
    text interpolation with placeholder variables by using the same type:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 回到字符串类型，我们可以使用单引号或双引号，与ECMAScript6相同。我们可以使用相同类型定义支持文本插值的多行文本字符串，使用占位变量：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Declaring our variables – the ECMAScript 6 way
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明我们的变量 - ECMAScript 6的方式
- en: TypeScript, as a superset of ECMAScript 6, supports expressive declaration nouns
    such as `let`, which informs us that the variable is scoped to the nearest enclosing
    block (either a function `for` loop or any enclosing statement). On the other
    hand, `const` is an indicator that the values declared this way are meant to always
    feature the same type or value once populated. For the rest of this chapter, we
    will enforce the traditional `var` notation for declaring variables, but do remember
    to use`let` and `const` where appropriate.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript作为ECMAScript 6的超集，支持表达性声明名词，比如`let`，它告诉我们变量的作用域是最近的封闭块（函数`for`循环或任何封闭语句）。另一方面，`const`是一个指示，这种方式声明的值一旦被填充就应该始终具有相同的类型或值。在本章的其余部分，我们将强制使用传统的`var`符号来声明变量，但请记住在适当的地方使用`let`和`const`。
- en: The let keyword
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: let关键字
- en: 'In a lot of cases in the code, I have been using `var` to declare objects,
    variables, and other constructs. It is really discouraged when starting with ES6
    or TypeScript. There is a reason for that and it''s because ES5 only have method
    scope. For most developers coming from another language and start using JavaScript,
    this comes as a bit of a shock. So firstly, what do we mean with function scope?
    We mean that a variable is unique within the context of a function, like so:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中的许多情况下，我一直在使用`var`来声明对象、变量和其他构造。但是在ES6或TypeScript中开始时，这是不被鼓励的。这是有原因的，因为ES5只有方法作用域。对于大多数从其他语言转到JavaScript的开发人员来说，这可能有点震惊。首先，我们所说的函数作用域是什么意思？我们的意思是变量在函数的上下文中是唯一的，就像这样：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There can be no other variable `a` in that function. If you do declare more
    of it, then you will effectively redefine it. OK, so that''s good, but when is
    the scoping not there? It is not there in `for`-loops, for example. In Java you
    would write:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在该函数中不能有其他变量`a`。如果你声明了更多的变量，那么你将有效地重新定义它。好的，但是什么时候作用域不起作用呢？例如，在`for`-循环中就没有作用域。在Java中，你会这样写：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In Java, you would know that the variable `i` would never leak outside of the `for`-loop
    and you could write:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，你会知道变量`i`永远不会泄漏到`for`-循环之外，你可以这样写：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And know that the variable `i` outside of the `for`-loop would not affect the
    variable `i` inside the `for`-loop, they would be separated or scoped, as it is
    called. OK, so users of ES5 JavaScript have had this language flaw for a long
    time and recently a fix for this has been added to ES6 and Typescript respectively,
    namely the `let` keyword. Use it like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 并且要知道`for`-循环之外的变量`i`不会影响`for`-循环内的变量`i`，它们会被分隔或作用域化，就像它被称为的那样。好的，所以ES5 JavaScript的用户已经有了这个语言缺陷很长时间了，最近ES6和Typescript分别添加了一个修复这个问题的方法，即`let`关键字。像这样使用它：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The reason this works is that the TypeScript compiler translates this to the
    following ES5 code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这样运行的原因是TypeScript编译器将其转换为以下ES5代码：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The compiler essentially renames the variable within the `for`-loop, so that
    a name collision doesn't happen. So remember, no more `var`, just use the `let` keyword
    when in doubt.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器基本上会在`for`-循环中重新命名变量，以防发生名称冲突。所以记住，不再使用`var`，当有疑问时只需使用`let`关键字。
- en: Const
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Const
- en: 'The `const` keyword is a way for you to convey that this data should never
    be changed. As a code base grows, it is easy that changes happen by mistake; such
    a mistake might be costly. To get compile time support for this, the `const` keyword
    is there to help you. Use it in the following way:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`关键字是一种方式，让你传达这些数据永远不应该被改变。随着代码库的增长，很容易发生错误的更改；这样的错误可能是代价高昂的。为了在编译时支持这一点，`const`关键字可以帮助你。以以下方式使用它：'
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The compiler will even indicate that this is not allowed with the following
    message:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器甚至会指出不允许这样做，并显示以下消息：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A word of caution here: this works only on the top level. You need to be aware
    of this if you declare objects as `const`, like so:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意一点：这仅适用于顶层。如果您将对象声明为`const`，则需要注意这一点：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Declaring the `obj` const does not freeze the entire object from being edited,
    but rather what `obj` points to. So, the following would not be allowed:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 声明`obj`为`const`并不会冻结整个对象，而是`obj`指向的内容。因此，以下内容将不被允许：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we actively change what `obj` points to, not one of its child properties,
    therefore it is not allowed and you get the same compile error as earlier.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们积极改变了`obj`指向的内容，而不是它的一个子属性，因此这是不允许的，你会得到与之前相同的编译错误。
- en: Number
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字
- en: 'Number is probably the other most widespread primitive data type along with
    string and boolean. The same as in JavaScript, number defines a floating point
    number. The number type also defines hexadecimal, decimal, binary, and octal literals:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 数字可能是除了字符串和布尔值之外最常见的原始数据类型。与JavaScript一样，数字定义了浮点数。数字类型还定义了十六进制、十进制、二进制和八进制文字：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Boolean
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'The Boolean type defines data that can be `True` or `False`, representing the
    fulfillment of a condition:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔类型定义了可以是`True`或`False`的数据，表示条件的满足：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Array
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'Assigning wrong member types to arrays and handling exceptions that arise by
    that can be now easily avoided with the `Array` type, where we describe an array
    containing certain types only. The syntax just requires the `postfix []` in the
    type annotation, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将错误的成员类型分配给数组，并处理由此引起的异常，现在可以通过`Array`类型轻松避免，我们在其中描述了仅包含某些类型的数组。语法只需要在类型注释中使用`后缀[]`，如下所示：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we try to add a new member to the `childrenAges` array with a type other
    than number, the runtime type checker will complain, making sure our typed members
    remain consistent and our code is error-free.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试向`childrenAges`数组添加一个类型不是数字的新成员，运行时类型检查器将抱怨，确保我们的类型成员保持一致，我们的代码是无错误的。
- en: Dynamic typing with the any type
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用any类型的动态类型
- en: 'Sometimes, it is hard to infer the data type out of the information we have
    at some point, especially when we are porting legacy code to TypeScript or integrating
    loosely typed third-party libraries and modules. Don''t worry, TypeScript supplies
    us with a convenient type for these cases. The `any` type is compatible with all
    the other existing types, so we can type any data value with it and assign any
    value to it later on. This great power comes with a great responsibility, though.
    If we bypass the convenience of static type checking, we are opening the door
    to type errors when piping data through our modules, and it will be up to us to
    ensure type safety throughout our application:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，很难根据我们在某一时刻拥有的信息推断数据类型，特别是当我们将遗留代码移植到TypeScript或集成松散类型的第三方库和模块时。不用担心，TypeScript为我们提供了一个方便的类型来处理这些情况。`any`类型与所有其他现有类型兼容，因此我们可以使用它对任何数据值进行类型标注，并在以后分配任何值给它。然而，这种强大的功能也伴随着巨大的责任。如果我们绕过静态类型检查的便利，我们就会在通过我们的模块传递数据时打开类型错误的大门，我们将需要确保整个应用程序的类型安全：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The null and undefined JavaScript literals require special mention. In a nutshell,
    they are typed under the `any` type. This makes it possible later on to assign
    these literals to any other variable, regardless of its original type.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 空值和未定义的JavaScript文字需要特别提到。简而言之，它们在`any`类型下进行了类型化。这样以后就可以将这些文字分配给任何其他变量，而不管其原始类型如何。
- en: Custom type
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义类型
- en: 'In Typescript, you are able to come up with your own type if you need to, by
    using the `type` keyword in the following way:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Typescript中，如果需要，您可以使用以下方式使用`type`关键字自定义类型：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'What we have created now is a type with *x* number of allowed values. Let''s
    create a variable from this type:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建的是一个具有*x*个允许值的类型。让我们从这种类型创建一个变量：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is perfectly allowed as `Cheetah` is one of the allowed values, and works
    as intended. The interesting part happens when we give our variable a value it
    does not expect:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完全允许的，因为 `Cheetah` 是允许的值之一，并且按预期工作。有趣的部分发生在我们给变量赋予它不期望的值时：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This results in the following compiler error:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下编译器错误：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Enum
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Enum
- en: Enum is basically a set of unique numeric values that we can represent by assigning
    friendly names to each one of them. The use of enums goes beyond assigning an
    alias to a number. We can use them as a way to list, in a convenient and recognizable
    way, the different variations that a specific type can assume.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Enum 基本上是一组唯一的数值，我们可以通过为每个数值分配友好的名称来表示它们。枚举的用途不仅限于为数字分配别名。我们可以将它们用作以方便和可识别的方式列出特定类型可以假定的不同变化的方法。
- en: 'Enums are declared using the `enum` keyword, without `var` or any other variable
    declaration noun, and they begin numbering members starting at 0 unless explicit
    numeric values are assigned to them:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举使用 `enum` 关键字声明，不使用 `var` 或任何其他变量声明名词，并且它们从 0 开始编号成员，除非为它们分配了显式的数值：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Inspecting the value of `myCar` will return `1` (which is the index held by
    `Cadillac` in the `enum`). As we mentioned already, we can assign custom numeric
    values in the `enum`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `myCar` 的值将返回 `1`（这是 `enum` 中 `Cadillac` 所持有的索引）。正如我们已经提到的，我们可以在 `enum` 中分配自定义数值：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Inspecting `myTruck` will yield `2`, since the first enumerated value was set
    as `1` already. We can extend value assignation to all the `enum` members as long
    as such values are integers:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `myTruck` 将产生 `2`，因为第一个枚举值已经设置为 `1`。只要这些值是整数，我们就可以将值分配给所有的 `enum` 成员：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'One last trick worth mentioning is the possibility to look up the enum member
    mapped to a given numeric value:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后值得一提的一个技巧是查找与给定数值映射的枚举成员的可能性：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It should be mentioned that from TypeScript 2.4 it is possible to assign string
    values to Enums.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 应该提到的是，从 TypeScript 2.4 开始，可以将字符串值分配给枚举。
- en: Void
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Void
- en: 'The `void` type definitely represents the absence of any type and its use is
    constrained to annotating functions that do not return an actual value. Therefore,
    there is no return type either. We already had the chance to see this with an
    actual example in the previous chapter:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`void` 类型确实表示任何类型的缺失，其使用受限于注释不返回实际值的函数。因此，也没有返回类型。我们已经有机会在上一章中通过一个实际例子看到这一点：'
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Type inference
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断
- en: Typing our data is optional since TypeScript is smart enough to infer the data
    type of our variables and function return values out of context with a certain
    level of accuracy. When no type inference is possible, TypeScript will assign
    the dynamic any type to the loosely typed data at the cost of reducing type checking
    to a bare minimum.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们的数据进行类型标注是可选的，因为 TypeScript 足够聪明，可以在上下文中推断出变量和函数返回值的数据类型，并且具有一定的准确性。当无法进行类型推断时，TypeScript
    将以动态的 any 类型分配给松散类型的数据，以减少类型检查的成本。
- en: 'An example of inferring at work can be seen in the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 推断工作的一个例子可以在以下代码中看到：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This holds the same effect, that is, it will lead to a compilation error if
    you try to assign a non-compatible data type to it like so:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这具有相同的效果，也就是说，如果您尝试将不兼容的数据类型分配给它，它将导致编译错误，就像这样：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Functions, lambdas, and execution flow
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数、lambda 和执行流
- en: The same as in JavaScript, functions are the processing machines where we analyze
    input, digest information, and apply the necessary transformations to the data
    provided to either transform the state of our application or return an output
    that will be used to shape our application's business logic or user interactivity.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与JavaScript一样，函数是处理机器，我们在其中分析输入，消化信息，并对提供的数据应用必要的转换，以便转换我们应用程序的状态或返回一个输出，该输出将用于塑造我们应用程序的业务逻辑或用户交互。
- en: Functions in TypeScript are not that different from regular JavaScript, except
    for the fact that functions, just as everything else in TypeScript, can be annotated
    with static types and thus, they better inform the compiler of the information
    they expect in their signature and the data type they aim to return, if any.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript中的函数与普通JavaScript并没有太大的区别，除了函数本身以及TypeScript中的其他所有内容一样，可以用静态类型进行注释，因此，它们更好地通知编译器它们在签名中期望的信息以及它们的返回数据类型（如果有的话）。
- en: Annotating types in our functions
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的函数中注释类型
- en: 'The following example showcases how a regular function is annotated in TypeScript:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了在TypeScript中如何注释常规函数：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can clearly see two main differences from the usual function syntax in regular
    JavaScript. First, we annotate with type information the parameters declared in
    the function signature. This makes sense since the compiler will want to check
    whether the data provided when executing the function holds the correct type.
    In addition to this, we also annotate the type of the returning value by adding
    the postfix string to the function declaration. In these cases, where the given
    function does not return any value, the type annotation void will give the compiler
    the information it requires to provide a proper type checking.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到与普通JavaScript中的常规函数语法有两个主要区别。首先，在函数签名中注释了参数的类型信息。这是有道理的，因为编译器将希望检查在执行函数时提供的数据是否具有正确的类型。除此之外，我们还通过在函数声明中添加后缀字符串来注释返回值的类型。在这些情况下，给定的函数不返回任何值，类型注释void将为编译器提供所需的信息，以进行适当的类型检查。
- en: As we mentioned in the previous section, the TypeScript compiler is smart enough
    to infer types when no annotation is provided. In this case, the compiler will
    look into the arguments provided and the return statements to infer a returning
    type from it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中提到的，TypeScript编译器足够聪明，可以在没有提供注释时推断类型。在这种情况下，编译器将查看提供的参数和返回语句，以推断返回类型。
- en: 'Functions in TypeScript can also be represented as expressions of anonymous
    functions, where we bind the function declaration to a variable:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript中的函数也可以表示为匿名函数的表达式，我们将函数声明绑定到一个变量上：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'However, there is a downside to this syntax. Although typing function expressions
    this way is allowed, thanks to type inference, the compiler is missing the type
    definition in the declared variable. We might assume that the inferred type of
    a variable that points to a function typed as a string is obviously a string.
    Well, it''s not. A variable that points to an anonymous function ought to be annotated
    with a function type. Basically, the function type informs about both the types
    expected in the function payload and the type returned by the function execution,
    if any. This whole block, in the form of `(arguments: type) =>` returned type,
    becomes the type annotation our compiler expects:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，这种语法也有一个缺点。虽然允许以这种方式对函数表达式进行类型化，但由于类型推断，编译器在声明的变量中缺少类型定义。我们可能会假设指向类型为字符串的函数的变量的推断类型显然是字符串。但事实并非如此。指向匿名函数的变量应该用函数类型进行注释。基本上，函数类型通知了函数负载中期望的类型以及函数执行返回的类型（如果有的话）。这整个块，以`(arguments:
    type) =>`返回类型的形式，成为我们的编译器期望的类型注释：'
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Why such a cumbersome syntax, you might ask? Sometimes, we will declare variables
    that might depend on factories or function bindings. Then, it is always a good
    practice to provide as much information to the compiler as we can. This simple
    example might help you to understand better:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问为什么会有这样繁琐的语法？有时，我们会声明可能依赖于工厂或函数绑定的变量。然后，尽可能向编译器提供尽可能多的信息总是一个好习惯。这个简单的例子可能会帮助你更好地理解：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This way, we also ensure that later function assignations conform to the type
    annotations set when declaring variables.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们也确保以后的函数赋值符合在声明变量时设置的类型注解。
- en: Function parameters in Typescript
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript中的函数参数
- en: Due to the type checking performed by the compiler, function parameters require
    special attention in TypeScript.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编译器执行的类型检查，TypeScript中的函数参数需要特别注意。
- en: Optional parameters
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选参数
- en: Parameters are a core part of the type checking applied by the TypeScript compiler.
    TypeScript offers an optional functionality by adding the `?` symbol as a postfix
    to the parameter name we want to make optional. This allows us to leave out the
    second parameter in the function call.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是TypeScript编译器应用的类型检查的核心部分。TypeScript通过在参数名称后面添加`?`符号来提供可选功能，这允许我们在函数调用中省略第二个参数。
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This code will attempt to print out the greeting variable as well as produce
    a proper greeting. Running this code like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将尝试打印出问候变量，并产生一个合适的问候。像这样运行这段代码：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Will give us the following result:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将给我们以下结果：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'So, an optional parameter doesn''t really get set unless you explicitly make
    it so. It is more of a construct so that you can get help with deciding what parameters
    are mandatory and which ones are optional. Let''s exemplify that:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可选参数实际上不会被设置，除非你明确地这样做。这更多是一种构造，让你可以帮助决定哪些参数是必需的，哪些是可选的。让我们举个例子：
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can invoke this function in the following ways:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以以下方式调用这个函数：
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Both versions are allowed. Using optional parameters in your function signature
    forces you to place them last, like the previous example. The following example
    illustrates what not to do:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 两个版本都是允许的。在函数签名中使用可选参数会强制你将它们放在最后，就像前面的例子一样。以下例子说明了什么不应该做：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This would create a situation where both parameters would be mandatory:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建这样一种情况，其中两个参数都是必需的：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Even the compiler would complain and say the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 即使编译器会抱怨并说以下内容：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Remember, optionals are great, but place them last.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，可选参数很好，但要放在最后。
- en: Default parameters
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认参数
- en: 'TypeScript gives us another feature to cope with the scenario depicted earlier
    in the form of default parameters, where we can set a default value that the parameter
    will assume when not explicitly populated upon executing the function. The syntax
    is pretty straightforward, as we can see when we refactor the previous example
    here:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript给了我们另一个功能来应对前面描述的情况，即默认参数，我们可以在执行函数时设置参数的默认值，当没有明确赋值时参数将采用默认值。语法非常简单，我们可以在重构前面的例子时看到：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Just as with optional parameters, default parameters must be put right after
    the non-default parameters in the function signature. There is a very important
    difference, which is that default parameters are always safe to use. Why they
    are safe to use, is indicated by the ES5 code below. The ES5 code below is the
    resulting code from compiling the above TypeScript to ES5\. The following code
    indicates that the compiler adds an IF clause that checks whether the variable `greeting` is
    undefined and if so gives it a starter value:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与可选参数一样，默认参数必须放在函数签名中非默认参数的后面。有一个非常重要的区别，就是默认参数总是安全的。为什么它们是安全的，可以从下面的ES5代码中看出。下面的ES5代码是将上面的TypeScript编译为ES5得到的结果代码。下面的代码表明编译器添加了一个IF子句，检查变量`greeting`是否为undefined，如果是，则给它一个起始值：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, the compiler adds an `if`-clause investigating your value and
    if it is not set, it adds the value you provided earlier.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，编译器添加了一个if子句来检查你的值，如果没有设置，它会添加你之前提供的值。
- en: The type is inferred when you are dealing with default parameters as you assign
    a value to them. In the preceding code snippet, greeting is inferred to be a string
    by it being assigned the string value `'Hello'`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理默认参数时，类型会被推断出来，因为你给它们赋了一个值。在前面的代码片段中，greeting被赋予字符串值'Hello'，因此被推断为字符串类型。
- en: Rest parameters
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 剩余参数
- en: 'One of the big advantages of the flexibility of JavaScript when defining functions
    is the functionality to accept an unlimited non-declared array of parameters in
    the form of the arguments object. In a statically typed context such as TypeScript,
    this might not be possible, but it actually is by means of the REST parameter''s
    object. Here, we can define, at the end of the arguments list, an additional parameter
    prefixed by ellipsis (`...`) and typed as an array:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义函数时，JavaScript的灵活性之一是接受以arguments对象形式的无限数量的未声明的参数。在TypeScript这样的静态类型上下文中，这可能是不可能的，但通过REST参数对象实际上是可能的。在这里，我们可以在参数列表的末尾定义一个额外的参数，前面加上省略号(`...`)并且类型为数组：
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It''s important to note that the Rest parameters must be put at the end of
    the arguments list and can be left out whenever not required. Let''s have a look
    at the resulting ES5 code to understand what the TypeScript compiler produces:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，剩余参数必须放在参数列表的末尾，不需要时可以省略。让我们看一下生成的ES5代码，以了解TypeScript编译器生成了什么：
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'What we can see here is that the built-in arguments array is being used. Also,
    that its content is copied over into the `names` array:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这里使用了内置的arguments数组。而且，它的内容被复制到`names`数组中：
- en: '[PRE42]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It really makes perfect sense when you think about it. So, Rest parameters is
    your friend when you don't know the number of arguments.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想一想的时候，这真的是非常合理的。所以，当你不知道参数的数量时，剩余参数就是你的朋友。
- en: Overloading the function signature
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数签名的重载
- en: 'Method and function overloading is a common pattern in other languages such
    as C#. However, implementing this functionality in TypeScript clashes with the
    fact that JavaScript, which TypeScript is meant to compile to, does not implement
    any elegant way to integrate this functionality out of the box. So, the only workaround
    possibly requires writing function declarations for each of the overloads and
    then writing a general-purpose function that will wrap the actual implementation
    and whose list of typed arguments and returning types are compatible with all
    the others:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 方法和函数的重载在其他语言中是一种常见模式，比如C#。然而，在TypeScript中实现这种功能与JavaScript相冲突，因为JavaScript并没有提供一种优雅的方式来直接集成这种功能。因此，唯一的解决方法可能是为每个重载编写函数声明，然后编写一个通用函数，它将包装实际的实现，并且其类型参数和返回类型与所有其他函数兼容：
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding example, we are exposing three different function signatures
    and each of them feature different type annotations. We could even define different
    returning types if there was a case for that. For doing so, we should have just
    annotated the wrapping function with an any return type.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们暴露了三种不同的函数签名，每个函数签名都具有不同的类型注释。如果有必要，我们甚至可以定义不同的返回类型。为此，我们只需使用任何返回类型注释包裹函数即可。
- en: Better function syntax with and scope handing with lambdas
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好的函数语法和lambda的范围处理
- en: ECMAScript 6 introduced the concept of fat arrow functions (also called lambda
    functions in other languages such as Python, C#, Java, or C++) as a way to both
    simplify the general function syntax and also to provide a bulletproof way to
    handle the scope of the functions that are traditionally handled by the infamous
    scope issues of tackling with the `this` keyword.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6引入了箭头函数的概念（在其他语言中也称为lambda函数，如Python、C＃、Java或C++），旨在简化一般函数语法，并提供一种处理函数范围的可靠方法，传统上由于处理`this`关键字的范围问题而处理。
- en: 'The first impression is its minimalistic syntax, where, most of the time, we
    will see arrow functions as single-line, anonymous expressions:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第一印象是它的极简语法，大多数情况下，我们会看到箭头函数作为单行匿名表达式：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The function computes the double of a given number, `x`, and returns the result,
    although we do not see any function or return statements in the expression. If
    the function signature contains more than one argument, we just need to wrap them
    all between braces:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数计算给定数字`x`的两倍，并返回结果，尽管我们在表达式中没有看到任何函数或返回语句。如果函数签名包含多个参数，我们只需要将它们都包裹在大括号中：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This makes this syntax extremely convenient when developing functional operations
    such as `map`, `reduce`, and others:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得这种语法在开发`map`、`reduce`等功能操作时非常方便：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Arrow functions can also contain statements. In this case, we will want to
    wrap the whole implementation in curly braces:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数也可以包含语句。在这种情况下，我们希望将整个实现包裹在大括号中：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Still, what does this have to do with scope handling? Basically, the value
    of this can point to a different context, depending on where we execute the function.
    This is a big deal for a language that prides itself on an excellent flexibility
    for functional programming, where patterns such as callbacks are paramount. When
    referring to `this` inside a callback, we lose track of the upper context and
    that usually forces us to use conventions such as assigning the value of `this`
    to a variable named self or that, which will be used later on within the callback.
    Statements containing interval or timeout functions make a perfect example of
    this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这与范围处理有什么关系呢？基本上，this的值取决于我们执行函数的上下文。对于一种以出色的功能编程灵活性自豪的语言来说，这是一件大事，其中回调等模式至关重要。在回调函数中引用`this`时，我们失去了上下文的追踪，这通常迫使我们使用约定，例如将`this`的值分配给一个名为self或that的变量，稍后在回调中使用。包含间隔或超时函数的语句是这一点的完美例子：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'When executing the preceding script, we won''t get the expected `Hello Peter`
    alert, but an incomplete string highlighting a pesky greeting to `Mr. Undefined!`Basically,
    this construction screws the lexical scoping of this when evaluating the function
    inside the timeout call. Porting this script to arrow functions will do the trick,
    though:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行上述脚本时，我们不会得到预期的`Hello Peter`警报，而是一个不完整的字符串，突出显示对`Mr. Undefined!`的讨厌的问候。基本上，这种构造在评估超时调用内部的函数时会破坏this的词法作用域。将此脚本转换为箭头函数将解决问题：
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Even if we break down the statement contained in the arrow function into several
    lines of code wrapped by curly braces, the lexical scoping of this will keep pointing
    to the proper context outside the `setTimeout` call, allowing a more elegant and
    clean syntax.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们将箭头函数中的语句拆分为由花括号包裹的几行代码，this的词法作用域仍将指向setTimeout调用外部的适当上下文，从而实现更加优雅和清晰的语法。
- en: General features
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般特性
- en: There are some general features in TypeScript that don't really apply specifically
    to either classes, functions, or parameters, but rather makes coding more efficient
    and fun. The idea is that the fewer lines of code you have to write, the better
    it is. It's not only about fewer lines, but also about making things clearer.
    There are a ton of such features in ES6 that TypeScript has also implemented,
    but here, I will just name a few that are likely to occur in your Angular project.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中有一些一般特性，它们并不特别适用于类、函数或参数，而是使编码更加高效和有趣。这个想法是，你写的代码行数越少，就越好。这不仅仅是关于行数更少，还关乎让事情更清晰。在ES6中有许多这样的特性，TypeScript也实现了这些特性，但在这里，我只会列出一些可能会出现在你的Angular项目中的特性。
- en: Spread parameter
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展开参数
- en: A spread parameter is using the same syntax `...` ellipsis as the REST parameters,
    but it is used differently. It's not used as a parameter inside of a function,
    but rather inside the function body.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 展开参数使用与REST参数相同的语法`...`省略号，但用法不同。它不是作为函数内部的参数使用，而是在函数体内使用。
- en: 'Let''s illustrate what that means:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来说明一下这意味着什么：
- en: '[PRE50]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This would output:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: '[PRE51]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: What we do here is add an item to an existing array without changing the old
    array. The `oldArray` variable still contains `1,2`, but the `newArray` contains
    `1,2,3`. This general principle is called *immutability*, which essentially means
    don't change, but rather create a new state from the old state. It's a principle
    used in functional programming both as a paradigm, but also for performance reasons.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是向现有数组添加一个项目，而不改变旧数组。oldArray变量仍然包含1,2，但newArray包含1,2,3。这个一般原则被称为*不可变性*，它基本上意味着不要改变，而是从旧状态创建一个新状态。这是函数式编程中使用的原则，既作为一种范式，也是出于性能原因。
- en: 'You can also use a REST parameter on objects; yes, really. You would write
    it like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在对象上使用REST参数；是的，真的。你可以这样写：
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The result from running this code is:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码的结果是：
- en: '[PRE53]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'A merge between the two objects. Just like with the example of the list, we
    would not change the previous variable, `oldPerson`. A `newPerson` variable would
    take the information from `oldPerson`, but add its new values to it. Looking at
    the ES5 code you can see why:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 两个对象之间的合并。就像列表的例子一样，我们不会改变先前的变量oldPerson。一个newPerson变量将从oldPerson获取信息，但同时将其新值添加到其中。看看ES5代码，你就会明白为什么：
- en: '[PRE54]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: What's happening here is that an `assign` function is being defined. Said function
    loops the keys of `oldPerson` variables and assigns those to a new object and
    lastly adds the content of the`newPerson` variable. If you look at the preceding
    function, it either defines a function that does this or it uses `Object.assign`,
    which is part of ES6 standard, if available.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的是定义了一个`assign`函数。该函数循环遍历`oldPerson`变量的键，并将其分配给一个新对象，最后添加`newPerson`变量的内容。如果你看一下前面的函数，它要么定义一个执行此操作的函数，要么使用ES6标准中的`Object.assign`（如果可用）。
- en: Template strings
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板字符串
- en: 'Template string is all about making your code clearer. Imagine the following
    scenario:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串的目的是让你的代码更清晰。想象一下以下情景：
- en: '[PRE55]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'So, what''s wrong with this? The answer is readability. It''s hard to imagine
    what the resulting string will look like, but it is also very easy for you to
    edit the previous code by mistake, and suddenly, the result will not be what you
    want. Most languages use a format function for this and that is exactly what template
    strings is, a format function. It is used in the following way:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这有什么问题吗？答案是可读性。很难想象结果字符串会是什么样子，但你也很容易错误地编辑以前的代码，突然间，结果将不是你想要的。大多数语言都使用格式化函数来解决这个问题，这正是模板字符串的作用，一个格式化函数。它的使用方式如下：
- en: '[PRE56]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This is a much more condensed expression and so it is much easier to read, so
    use it, always.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更简洁的表达方式，因此更容易阅读，所以一定要使用它。
- en: Generics
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: 'Generics is an expression for saying that we have a general code behavior that
    we can employ regardless of data type. Generics are very often used to operate
    on collections as collections often have similar behavior regardless of types.
    Generics can however be used on constructs such as methods. The idea is also that
    Generics should indicate if you are about to mix types in a way that isn''t allowed:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是一个表达式，表示我们有一个通用的代码行为，无论数据类型如何，我们都可以使用它。泛型经常用于操作集合，因为集合通常具有类似的行为，无论类型如何。但泛型也可以用于方法等结构。其想法也是，泛型应该指示你是否要以不允许的方式混合类型。
- en: '[PRE57]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the preceding example, the `T` is not decided until you actually use the
    method. As you can see, the type of `T` varies from number to `String` depending
    on how you call it. It also ensures that you are inputting the correct type of
    data. This can be seen in the following row:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`T` 直到你实际使用该方法时才确定。正如你所看到的，`T` 的类型根据你调用它的方式从数字变化到 `String`。它还确保你输入了正确类型的数据。这可以在以下行中看到：
- en: '[PRE58]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, we clearly specify that `T` should be a string, but we insist on feeding
    it a value of type number. The compiler clearly states that this is not OK.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们明确指定 `T` 应该是一个字符串，但我们坚持要输入一个数字类型的值。编译器明确指出这是不允许的。
- en: 'You can, however, be more specific on what `T` should be. By typing the following,
    you ensure that `T` is of type `Array`, so any type of value you input must adhere
    to this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以更具体地指定 `T` 应该是什么类型。通过输入以下内容，你确保 `T` 是 `Array` 类型，因此你输入的任何类型的值都必须遵循这一规定：
- en: '[PRE59]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In this case, we decide that `T` should be either of type `Person` or `A` and
    we also see that the input needs to be of type array:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们决定 `T` 应该是 `Person` 或 `A` 类型，并且我们还看到输入需要是数组类型：
- en: '[PRE60]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: So, inputting a single object is not OK. So why do we do this? In this case,
    we want to ensure that certain methods are available such as `.length` and that
    we, in a given moment, don't care if we operate on something of type `A` or `Person`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，输入单个对象是不允许的。那么我们为什么要这样做呢？在这种情况下，我们希望确保某些方法是可用的，比如 `.length`，并且在某一时刻，我们不在乎我们是在操作
    `A` 类型还是 `Person` 类型的东西。
- en: 'You can also decide that your type `T` should adhere to an interface like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以决定你的类型 `T` 应该遵循这样一个接口：
- en: '[PRE61]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The following line limits what `T` can be:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行限制了 `T` 可以是什么：
- en: '[PRE62]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As you can see, Generics is quite powerful to use if you have a common behavior
    that many different data types can relate to. You most likely won't be writing
    your own generic code, at least not initially, but it's good to know what is going
    on.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，如果你有许多不同数据类型可以关联的共同行为，泛型是非常强大的。你可能最初不会编写自己的泛型代码，但了解正在发生的事情是很好的。
- en: Classes, interfaces, and class inheritance
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类、接口和类继承
- en: Now that we have overviewed the most relevant bits and pieces of TypeScript,
    it's time to see how everything falls into place to build TypeScript classes.
    These classes are the building blocks of TypeScript and Angular applications.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经概述了TypeScript最相关的部分，是时候看看如何将所有内容组合起来构建TypeScript类了。这些类是TypeScript和Angular应用程序的构建模块。
- en: Although the noun class was a reserved word in JavaScript, the language itself
    never had an actual implementation for traditional POO-oriented classes as other
    languages such as Java or C# did. JavaScript developers used to mimic this kind
    of functionality, leveraging the function object as a constructor type, which
    would be later on instanced with the new operator. Other common practices such
    as extending our function objects were implemented by applying prototypal inheritance
    or by using composition.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名词类在JavaScript中是一个保留字，但语言本身从未对传统的面向对象的类有过实际的实现，就像Java或C#等其他语言那样。JavaScript开发人员过去常常模仿这种功能，利用函数对象作为构造函数类型，然后使用new运算符对其进行实例化。其他常见的做法，比如扩展我们的函数对象，是通过应用原型继承或使用组合来实现的。
- en: Now, we have an actual class functionality, which is flexible and powerful enough
    to implement the functionality our applications require. We already had the chance
    to tap into classes in the previous chapter. Let's look at them in more detail
    now.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一个实际的类功能，足够灵活和强大，可以实现我们应用程序所需的功能。我们已经有机会在上一章中了解类。现在让我们更详细地看一下它们。
- en: Anatomy of a class – constructors, properties, methods, getters, and setters
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类的解剖-构造函数、属性、方法、getter和setter
- en: 'The following piece of code illustrates how a class could be. Please note that
    the class property members come first and then we include a constructor and several
    methods and property accessors. None of them features the reserved word function
    and all the members and methods are properly annotated with a type except constructor:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段说明了一个类的结构。请注意，类的属性成员首先出现，然后我们包括一个构造函数和几个方法和属性访问器。它们中没有一个使用保留字function，并且所有成员和方法都正确地用类型进行了注释，除了构造函数：
- en: '[PRE63]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This class layout will probably remind us of the component class we built back
    in [Chapter 1](17474bca-f7f9-41ec-ab4c-5f7ac741c0c9.xhtml), *Creating Our Very
    First Component in Angular*. Basically, the class statement wraps several elements
    that we can break down into:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的布局可能会让我们想起我们在[第1章](17474bca-f7f9-41ec-ab4c-5f7ac741c0c9.xhtml)中构建的组件类，*在Angular中创建我们的第一个组件*。基本上，类语句包含了我们可以分解为的几个元素。
- en: '**Members**: Any instance of the `Car` class will feature two properties -color
    typed as string, and `distanceRun` typed as a number and they will only be accessible
    from within the class itself. If we instance this class, `distanceRun`, or any
    other member or method marked as private, it won''t be publicly exposed as part
    of the object API.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成员**：`Car`类的任何实例都将具有两个属性-color类型为字符串，`distanceRun`类型为数字，它们只能从类内部访问。如果我们实例化这个类，`distanceRun`或任何其他标记为私有的成员或方法，它们将不会作为对象API的一部分公开。'
- en: '**Constructor**: The constructor function is executed right away when an instance
    of the class is created. Usually, we want to initialize the class members here,
    with the data provided in the constructor signature. We can also leverage the
    constructor signature itself to declare class members, as we did with the `isHybrid`
    property. To do so, we just need to prefix the constructor parameter with an access
    modifier such as private or public. Same as we saw when analyzing functions in
    the previous sections, we can define rest, optional, or default parameters as
    depicted in the previous example with the color argument, which fallbacks to red
    when it is not explicitly defined.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数**：构造函数在创建类的实例时立即执行。通常，我们希望在这里使用构造函数签名中提供的数据初始化类成员。我们还可以利用构造函数签名本身来声明类成员，就像我们在`isHybrid`属性中所做的那样。为此，我们只需要使用private或public等访问修饰符作为构造函数参数的前缀。与我们在前面的部分中分析函数时看到的一样，我们可以定义剩余参数、可选参数或默认参数，就像在前面的示例中使用颜色参数时一样，当它没有明确定义时会回退到红色。'
- en: '**Methods**: A method is a special kind of member that represents a function
    and therefore, can return, or not, a typed value. Basically, it is a function
    that becomes part of the object API. Methods can be private as well. In this case,
    they are basically used as helper functions within the internal scope of the class
    to achieve the functionalities required by other class members.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**：方法是一种特殊类型的成员，表示一个函数，因此可以返回或不返回一个类型化的值。基本上，它是对象API的一部分的函数。方法也可以是私有的。在这种情况下，它们基本上用作类的内部范围内的辅助函数，以实现其他类成员所需的功能。'
- en: '**Static members**: Members marked as static are associated with the class
    and not with the object instances of that class. This means that we can consume
    static members directly, without having to instantiate an object first. In fact,
    static members are not accessible from the object instances and thus, they cannot
    access other class members using this. These members are usually included in the
    class definition as helper or factory methods in order to provide a generic functionality
    not related to any specific object instance.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态成员**：标记为静态的成员与类相关联，而不是与该类的对象实例相关联。这意味着我们可以直接使用静态成员，而不必首先实例化对象。事实上，静态成员无法从对象实例中访问，因此它们无法使用this访问其他类成员。这些成员通常作为辅助或工厂方法包含在类定义中，以提供与任何特定对象实例无关的通用功能。'
- en: '**Property accessors**: In ES5, we could define custom setters/getters in a
    very verbose way with `Object.defineProperty`. Now, things have become quite simpler.
    In order to create property accessors (usually pointing to internal private fields
    as in the example provided), we just need to prefix a typed method named as the
    property we want to expose with set (in order to make it writable) and get (in
    order to make it readable).'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性访问器**：在ES5中，我们可以使用`Object.defineProperty`以非常冗长的方式定义自定义setter/getter。现在，事情变得更简单了。为了创建属性访问器（通常指向内部私有字段，如所提供的示例），我们只需要使用以set（使其可写）和get（使其可读）命名的类型化方法前缀作为我们要公开的属性。'
- en: 'As a personal exercise, why don''t you copy the preceding piece of code at
    the playground page ([http://www.typescriptlang.org/Playground](http://www.typescriptlang.org/Playground))
    and execute it? We can even see an instance object of the `Car` class in action
    by appending this snippet right after the class definition and running the code
    and inspecting the output in the browser''s developer tools console:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 作为个人练习，为什么不将前面的代码片段复制到游乐场页面（[http://www.typescriptlang.org/Playground](http://www.typescriptlang.org/Playground)）并执行它呢？我们甚至可以在类定义之后直接附加此片段，运行代码并在浏览器的开发者工具控制台中检查输出，看`Car`类的实例对象如何运行。
- en: '[PRE64]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We can even perform an additional test and append the following illegal statements
    to our code, where we attempt to access the private property `distanceRun` or
    even apply a value through the distance member, which does not have a getter.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以执行一个额外的测试，并在我们的代码中添加以下非法语句，尝试访问私有属性`distanceRun`，甚至通过distance成员应用一个值，而该成员没有getter。
- en: '[PRE65]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Right after inserting these code statements in the playground text field, a
    red underline will remark that we are attempting to do something that is not correct.
    Nevertheless, we can carry on and transpile and run the code, since ES5 will honor
    these practices. All in all, if we attempt to run the `tsc` compiler on this file,
    the runtime will exit with the following error trace:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在将这些代码语句插入到代码编辑器中后，红色的下划线会提示我们正在尝试做一些不正确的事情。尽管如此，我们可以继续转译和运行代码，因为ES5将遵守这些做法。总的来说，如果我们尝试在这个文件上运行`tsc`编译器，运行时将退出并显示以下错误跟踪：
- en: '[PRE66]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Constructor parameters with accessors
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有访问器的构造函数参数
- en: 'Normally, when creating a class, you need to give it a name, define a constructor,
    and create one or more backing fields, like so:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在创建一个类时，你需要给它命名，定义一个构造函数，并创建一个或多个后备字段，就像这样：
- en: '[PRE67]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'For every field you need to add to the class you normally need to:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个你需要添加到类中的字段，通常需要做以下操作：
- en: Add an entry to the constructor
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构造函数中添加一个条目
- en: Add an assignment in the constructor
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构造函数中添加一个赋值
- en: Create the backing field
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建后备字段
- en: 'This is really boring and not very productive. TypeScript have made it so,
    so that you don''t need to type the backing fields by us using accessors on the
    constructor parameters. We can now type:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的很无聊，也不太高效。TypeScript已经做到了，所以我们不需要通过在构造函数参数上使用访问器来输入后备字段。我们现在可以输入：
- en: '[PRE68]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Giving a parameter a public accessor means it will create a public field and
    giving it a private accessor means it creates a private field for us like so:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 给参数添加一个公共访问器意味着它将创建一个公共字段，给它一个私有访问器意味着它将为我们创建一个私有字段，就像这样：
- en: '[PRE69]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'And trying to access said fields would be like so:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试访问这些字段会像这样：
- en: '[PRE70]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In ES5, we don''t have the concept of fields so that disappears, but assignment
    in the constructor is still there:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES5中，我们没有字段的概念，所以它消失了，但是构造函数中的赋值仍然存在：
- en: '[PRE71]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'But, you don''t have to do any of it in TypeScript, ever again. So, the preceding
    code using the constructor accessor approach only becomes:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在TypeScript中，你再也不需要做任何这些事情了。
- en: '[PRE72]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As you can see, more than half of the code disappears; this is really a selling
    point for TypeScript, as it saves you from typing quite a lot of tedious code.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，超过一半的代码消失了；这确实是TypeScript的一个卖点，因为它可以帮你省去输入大量乏味的代码。
- en: Interfaces in TypeScript
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript中的接口
- en: As applications scale and more classes and constructs are created, we need to
    find ways to ensure consistency and rules compliance in our code. One of the best
    ways to address the consistency and type validation issue is to create interfaces.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序规模的扩大，创建更多的类和结构，我们需要找到方法来确保代码的一致性和规则的遵从。解决一致性和类型验证问题的最佳方法之一就是创建接口。
- en: In a nutshell, an interface is a code blueprint defining a certain field's schema
    and any types (either classes, function signatures) implementing these interfaces
    are meant to comply with this schema. This becomes quite useful when we want to
    enforce strict typing on classes generated by factories, when we define function
    signatures to ensure that a certain typed property is found in the payload, or
    other situations.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，接口是一个定义特定字段模式和任何类型（无论是类、函数签名）的代码蓝图，实现这些接口的类型都应该符合这个模式。当我们想要强制对由工厂生成的类进行严格类型检查时，当我们定义函数签名以确保有效载荷中存在某个类型的属性，或者其他情况时，这就变得非常有用。
- en: 'Let''s get down to business! Here, we define the `Vehicle` interface. `Vehicle`
    is not a class, but a contractual schema that any class that implements it must
    comply with:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！在这里，我们定义了“Vehicle”接口。“Vehicle”不是一个类，而是任何实现它的类必须遵守的合同模式：
- en: '[PRE73]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Any class implementing the `Vehicle` interface must feature a member named
    `make`, which must be typed as a string according to this example. Otherwise,
    the TypeScript compiler will complain:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现“Vehicle”接口的类必须具有名为“make”的成员，根据此示例，它必须被定义为字符串类型。否则，TypeScript编译器会抱怨：
- en: '[PRE74]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Interfaces are therefore extremely useful to define the minimum set of members
    any type must fulfill, becoming an invaluable method for ensuring consistency
    throughout our codebase.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，接口非常有用，可以定义任何类型必须满足的最小成员集，成为确保代码库一致性的宝贵方法。
- en: It is important to note that interfaces are not used just to define minimum
    class schemas, but any type out there. This way, we can harness the power of interfaces
    for enforcing the existence of certain fields and methods in classes and properties
    in objects used later on as function parameters, function types, types contained
    in specific arrays, and even variables. An interface may contain optional members
    as well and even members.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，接口不仅用于定义最小的类模式，还用于定义任何类型。这样，我们可以利用接口的力量来强制存在于类中的某些字段和方法以及后来用作函数参数、函数类型、特定数组中包含的类型以及甚至变量的对象属性。接口也可以包含可选成员，甚至成员。
- en: Let's create an example. To do so, we will prefix all our interface types with
    an `I` (uppercase). This way, it will be easier to find its type when referencing
    them with our IDE code autocompletion functionality.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个例子。为此，我们将所有接口类型的前缀都加上“I”（大写）。这样，在引用它们时，使用我们的IDE代码自动完成功能会更容易找到它们的类型。
- en: 'First, we define an `Exception` interface that models a type with a mandatory
    message property member and an optional `id` member:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个“Exception”接口，该接口模拟了一个具有强制消息属性成员和可选“id”成员的类型：
- en: '[PRE75]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We can define interfaces for array elements as well. To do so, we must define
    an interface with a sole member, defining index as either a number or string (for
    dictionary collections) and then the type what we want that array to contain.
    In this case, we want to create an interface for arrays containing `Exception`
    types. This is a type comprising of a string message property and an optional
    ID number member, as we said in the previous example:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以为数组元素定义接口。为此，我们必须定义一个仅有一个成员的接口，定义索引为数字或字符串（用于字典集合），然后定义我们希望该数组包含的类型。在这种情况下，我们希望创建一个包含“Exception”类型的数组的接口。这是一个包含字符串消息属性和可选ID号成员的类型，就像我们在前面的例子中说的那样：
- en: '[PRE76]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, we define the blueprint for our future class, with a typed array and a
    method with its returning type defined as well:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义了未来类的蓝图，其中包括一个带有类型数组和一个返回类型定义的方法：
- en: '[PRE77]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We can also define interfaces for standalone object types. This is quite useful
    when it comes to defining a templated constructor or method signatures, which
    we will see later in this example:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为独立的对象类型定义接口。当定义模板构造函数或方法签名时，这是非常有用的，我们稍后将在本例中看到：
- en: '[PRE78]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Last but not least, in the following class, we will implement all these interface
    types:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，在接下来的课程中，我们将实现所有这些接口类型：
- en: '[PRE79]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Basically, we are defining an error handler class here that will manage an internal
    array of exceptions and expose a method to log new exceptions by saving them into
    the aforementioned array. These two elements are defined by the `ErrorHandler`
    interface and are mandatory. The class constructor expects the parameters defined
    by the `ExceptionHandlerSettings` interface and uses them to populate the exception
    member with items typed as `Exception`. Instancing the `ErrorHandler` class without
    the `logAllExceptions` parameter in the payload will trigger an error.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们在这里定义了一个错误处理程序类，它将管理一组异常并公开一个方法，通过将它们保存到前述数组中来记录新的异常。这两个元素由`ErrorHandler`接口定义，并且是强制性的。类构造函数期望由`ExceptionHandlerSettings`接口定义的参数，并使用它们来填充异常成员，其类型为`Exception`。在不带有有效载荷中的`logAllExceptions`参数的情况下实例化`ErrorHandler`类将触发错误。
- en: 'So far, I''ve been explaining interfaces as we are used to seeing them in other
    high level languages, but interfaces in TypeScript are on steroids; let me exemplify
    that by using the following code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我一直在解释接口，就像我们在其他高级语言中习惯看到的那样，但是TypeScript中的接口是经过增强的；让我通过以下代码来举例说明：
- en: '[PRE80]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here, we declare an interface, but we also create an instance from an interface
    here:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个接口，但同时也在这里从接口创建了一个实例：
- en: '[PRE81]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This is interesting because there are no classes involved here. That means
    writing a mocking library is a piece of cake*.* Let''s explain a bit what we mean
    with a mock library*.* When you are developing code you might think in interfaces
    before your start thinking in concrete classes. This is because you know what
    methods needs to exist but you might not have decided exactly how the methods
    should carry out a task. Imagine that you are building an order module. You have
    logic in your order module and you know that you at some point need to talk to
    a database service that will help you persist your order. You come up with a contract
    for said database service, an interface. You defer implementation of said interface
    until later. At this point a mocking library come in and is able to create a mock
    instance from an interface. Your code at this point might looking something like
    this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣，因为这里没有涉及到类。这意味着编写一个模拟库是小菜一碟。让我们稍微解释一下我们所说的模拟库。当你在开发代码时，你可能会先考虑接口，然后再考虑具体的类。这是因为你知道需要存在哪些方法，但可能还没有确定这些方法应该如何执行任务。想象一下，你正在构建一个订单模块。你的订单模块中有逻辑，你知道在某个时候需要与一个数据库服务进行通信，这将帮助你保存订单。你为所述数据库服务制定了一个合同，一个接口。你推迟了对该接口的实现。在这一点上，一个模拟库可以创建一个从接口生成的模拟实例。你的代码此时可能看起来像这样：
- en: '[PRE82]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'So mocking at this point gives us the ability to defer implementation of `DatabaseService`
    until we are done writing the `OrderProcessor`. It also makes the test experience
    of `OrderProcessor` a whole lot better. Where we in other languages needed to
    bring in mock library as 3rd party dependency we can now utilize a built in construct
    in TypeScript by typing the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，此时的模拟使我们能够推迟对`DatabaseService`的实现，直到我们完成了`OrderProcessor`的编写。它还使`OrderProcessor`的测试体验变得更好。在其他语言中，我们需要引入第三方依赖的模拟库，而现在我们可以利用TypeScript中的内置构造来实现以下类型：
- en: '[PRE83]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This will give us an instance of `DatabaseService`. A word of warning though,
    you are responsible for adding a `process()`method to your instance. Your instance
    starts out as an empty object.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们一个`DatabaseService`的实例。不过，需要警告一下，你需要为你的实例添加一个`process()`方法。你的实例最初是一个空对象。
- en: This would not raise any problems with the compiler; this means that it is a
    powerful feature, but it leaves it to you to verify that what you create is correct.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会引起编译器的任何问题；这意味着这是一个强大的功能，但它留给你来验证你创建的东西是否正确。
- en: Let's emphasize how powerful this TypeScript feature really is by looking at
    some more code cases, where it pays off to be able to mock away things. Let's
    reiterate that the reason for mocking anything in your code is to make it easier
    to test.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们强调一下 TypeScript 功能的强大之处，通过查看一些更多的代码案例，这样能够模拟掉一些东西就会很值得。让我们重申，在代码中模拟任何东西的原因是为了更容易地进行测试。
- en: 'Assume your code looks something like this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的代码看起来像这样：
- en: '[PRE84]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'A better way to test this is to make sure that the `Stuff` class relies on
    abstractions, which means that the `AuthService` should be created elsewhere and
    that we talk to an interface of `AuthService` rather than the concrete implementation.
    So, we would modify our code to look like this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这个的更好方法是确保`Stuff`类依赖于抽象，这意味着`AuthService`应该在其他地方创建，并且我们与`AuthService`的接口而不是具体实现进行交流。因此，我们将修改我们的代码看起来像这样：
- en: '[PRE85]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'To test this class, we would normally need to create a concrete implementation
    of `AuthService` and use that as a parameter in the `Stuff` instance, like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个类，我们通常需要创建`AuthService`的具体实现，并将其作为`Stuff`实例的参数使用，就像这样：
- en: '[PRE86]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'It would, however, become quite tedious to have to write a mock version of
    every dependency that you wanted to mock away. Therefore, mocking frameworks exist
    in most languages. The idea is to give the mocking framework an interface that
    it would create a concrete object from. You would never have to create a mock
    class, as we did previously, but that would be something that would be up to the
    mocking framework to do internally. Using said mock framework it would look something
    like this:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您想要模拟掉每个想要模拟掉的依赖项的话，这将变得相当乏味。因此，大多数语言中都存在模拟框架。其想法是给模拟框架一个接口，它将从中创建一个具体的对象。您永远不需要创建一个模拟类，就像我们之前所做的那样，但这将是模拟框架内部要做的事情。使用所述的模拟框架，它看起来会像这样：
- en: '[PRE87]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We have already stated so far how easy it is to create an instance from an
    interface, like so:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经说过从接口创建实例是多么容易，就像这样：
- en: '[PRE88]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'This means creating a mocking framework is then as easy as typing the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着创建一个模拟框架就像输入以下内容一样容易：
- en: '[PRE89]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'And using it in the following way:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 并且以以下方式使用它：
- en: '[PRE90]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Let's wrap up this section about interfaces by highlighting that classes can
    implement more than one interface, but also that interfaces are supercharged and
    facilitates testing quite a lot.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过强调类可以实现多个接口，但也可以让接口变得更加强大并且大大简化测试来总结一下关于接口的这一部分。
- en: Extending classes with class inheritance
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过类继承扩展类
- en: 'Just like a class can be defined by an interface, it can also extend the members
    and functionality of other classes as if they were its own. We can make a class
    inherit from another by appending the keyword `extends` to the class name, including
    the name of the class we want to inherit its members from:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 就像类可以由接口定义一样，它也可以扩展其他类的成员和功能，就好像它们是自己的一样。我们可以通过在类名后添加关键字`extends`，包括我们想要继承其成员的类的名称，使一个类继承自另一个类。
- en: '[PRE91]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Here, we extend from a parent class, `Car`, which already exposed a make member.
    We can populate the members already defined by the parent class and even execute
    their own constructor by executing the `super()` method, which points to the parent
    constructor. We can also override methods from the parent class by appending a
    method with the same name. Nevertheless, we will still be able to execute the
    original parent's class methods as it will be still accessible from the super
    object. Coming back to the interface, they can also inherit definition from other
    interfaces. Simply put, an interface can inherit from another interface.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从一个父类`Car`扩展，该类已经公开了一个make成员。我们可以填充父类已定义的成员，甚至通过执行`super()`方法执行它们自己的构造函数，该方法指向父构造函数。我们还可以通过附加具有相同名称的方法来覆盖父类的方法。尽管如此，我们仍然能够执行原始父类的方法，因为它仍然可以从super对象中访问。回到接口，它们也可以从其他接口继承定义。简而言之，一个接口可以从另一个接口继承。
- en: As a word of caution, ES6 and TypeScript do not provide support for multiple
    inheritance. So, you may want to use composition or middleman classes instead,
    in case you want to borrow functionalities from different sources.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种谨慎的提醒，ES6和TypeScript不支持多重继承。因此，如果您想从不同的来源借用功能，您可能希望改用组合或中间类。
- en: Decorators in TypeScript
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript中的装饰器
- en: Decorators are a very cool functionality, originally proposed by Google in AtScript
    (a superset of TypeScript that finally got merged into TypeScript back in early
    2015) and also a part of the current standard proposition for ECMAScript 7\. In
    a nutshell, decorators are a way to add metadata to class declarations for use
    by dependency injection or compilation directives ([http://blogs.msdn.com/b/somasegar/archive/2015/03/05/typescript-lt-3-angular.aspx](http://blogs.msdn.com/b/somasegar/archive/2015/03/05/typescript-lt-3-angular.aspx)).
    By creating decorators, we are defining special annotations that may have an impact
    on the way our classes, methods, or functions behave or just simply altering the
    data we define in fields or parameters. In that sense, decorators are a powerful
    way to augment our type's native functionalities without creating subclasses or
    inheriting from other types.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是一种非常酷的功能，最初由Google在AtScript（TypeScript的超集，最终于2015年初合并到TypeScript中）中提出，并且也是ECMAScript
    7当前标准提案的一部分。简而言之，装饰器是一种向类声明添加元数据的方式，供依赖注入或编译指令使用（[http://blogs.msdn.com/b/somasegar/archive/2015/03/05/typescript-lt-3-angular.aspx](http://blogs.msdn.com/b/somasegar/archive/2015/03/05/typescript-lt-3-angular.aspx)）。通过创建装饰器，我们正在定义可能对我们的类、方法或函数的行为产生影响，或者仅仅改变我们在字段或参数中定义的数据的特殊注释。在这个意义上，装饰器是一种强大的方式，可以增强我们类型的本机功能，而不需要创建子类或从其他类型继承。
- en: This is, by far, one of the most interesting features of TypeScript. In fact,
    it is extensively used in Angular when designing directives and components or
    managing dependency injection, as we will see from [Chapter 5](3df2cad2-baa6-4076-a6ab-d84247af7817.xhtml),
    *Enhancing our Components with Pipes and Directives*, onwards.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这是TypeScript最有趣的功能之一。事实上，在Angular中设计指令和组件或管理依赖注入时，它被广泛使用，我们将从[第5章](3df2cad2-baa6-4076-a6ab-d84247af7817.xhtml)
    *使用管道和指令增强我们的组件*开始看到。
- en: Decorators can be easily recognized by the `@` prefix to their name, and they
    are usually located as standalone statements above the element they decorate,
    including a method payload or not.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器可以很容易地通过其名称的`@`前缀来识别，它们通常位于它们装饰的元素的上方，包括方法负载或不包括方法负载。
- en: 'We can define up to four different types of decorators, depending on what element
    each type is meant to decorate:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义最多四种不同类型的装饰器，具体取决于每种类型所要装饰的元素：
- en: Class decorators
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类装饰器
- en: Property decorators
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性装饰器
- en: Method decorators
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法装饰器
- en: Parameter decorators
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数装饰器
- en: Let's take a look at each of them!
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个看一下！
- en: Class decorators
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类装饰器
- en: Class decorators allow us to augment a class or perform operations over any
    of its members, and the decorator statement is executed before the class gets
    instanced.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 类装饰器允许我们增强一个类或对其任何成员执行操作，并且装饰器语句在类被实例化之前执行。
- en: 'Creating a class decorator just requires defining a plain function, whose signature
    is a pointer to the constructor belonging to the class we want to decorate, typed
    as function (or any other type that inherits from the function). The formal declaration
    defines a `ClassDecorator`, as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个类装饰器只需要定义一个普通函数，其签名是指向我们想要装饰的类的构造函数的指针，类型为函数（或任何其他继承自函数的类型）。正式声明定义了一个`ClassDecorator`，如下所示：
- en: '[PRE92]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Yes, it is really difficult to grasp what this gibberish means, right? Let''s
    put everything in context through a simple example, like this:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，很难理解这些胡言乱语的含义，对吧？让我们通过一个简单的例子来把一切放在上下文中，就像这样：
- en: '[PRE93]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'As we can see, we have gained a `banana()` method that was not originally defined
    in the `FruitBasket` class just by properly decorating it with the `Banana` decorator.
    It is worth mentioning though that this won''t actually compile. The compiler
    will complain that `FruitBasket` does not have a `banana()` method, and rightfully
    so. TypeScript is typed. In ES5, we could do anything we wanted and any wrong
    doing would be discovered in runtime. So at this point, we need to tell the compiler
    that this is OK. So, how do we do that? One way is that when we create our basket
    instance, we give it the type any like so:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们通过正确地使用`Banana`装饰器，获得了一个在`FruitBasket`类中原本未定义的`banana()`方法。不过值得一提的是，这实际上不会编译通过。编译器会抱怨`FruitBasket`没有`banana()`方法，这是理所当然的。TypeScript是有类型的。在ES5中，我们可以做任何我们想做的事情，任何错误都会在运行时被发现。所以在这一点上，我们需要告诉编译器这是可以的。那么，我们该如何做呢？一种方法是在创建篮子实例时，像这样给它赋予任意类型：
- en: '[PRE94]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'What we did here is actively give the variable basket the `any` type and thereby
    fight the TypeScript compilers urge to infer the type to be `FruitBasket`. By
    being of type any TypeScript has no idea of knowing whether what we have done
    to it is correct or not. Another way of essentially accomplishing the same effect
    is to type like this instead:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是将变量basket主动赋予`any`类型，从而抵制TypeScript编译器将类型推断为`FruitBasket`的冲动。通过使用any类型，TypeScript无法知道我们对它所做的是否正确。另一种实现相同效果的方法是这样类型：
- en: '[PRE95]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Here, we are doing a conversion on the fly with the `as`-operator and thereby
    we tell the compiler that this is OK.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`as`运算符进行了即时转换，从而告诉编译器这是可以的。
- en: Extending the class decorator function signature
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展类装饰器函数签名
- en: Sometimes, we might need to customize the way our decorator operates upon instancing
    it. No worries! We can design our decorators with custom signatures and then have
    them returning a function with the same signature we defined when designing class
    decorators with no parameters. As a rule of thumb, decorators taking parameters
    just require a function whose signature matches the parameters we want to configure.
    Such a function must return another function, whose signature matches that of
    the decorator we want to define.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能需要在实例化时自定义装饰器的操作方式。别担心！我们可以设计带有自定义签名的装饰器，然后让它们返回一个与我们在设计不带参数的类装饰器时定义的相同签名的函数。作为一个经验法则，带参数的装饰器只需要一个函数，其签名与我们想要配置的参数匹配。这样的函数必须返回另一个函数，其签名与我们想要定义的装饰器的签名匹配。
- en: 'The following piece of code illustrates the same functionality as the previous
    example, but it allows developers to customize the greeting message:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了与前面例子相同的功能，但它允许开发人员自定义问候消息：
- en: '[PRE96]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Property decorators
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性装饰器
- en: 'Property decorators are meant to be applied on class fields and can be easily
    defined by creating a `PropertyDecorator` function, whose signature takes two
    parameters:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 属性装饰器是用于应用于类字段的，并且可以通过创建一个`PropertyDecorator`函数来轻松定义，其签名接受两个参数：
- en: '**Target**: This is the prototype of class we want to decorate'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Target**：这是我们想要装饰的类的原型'
- en: '**Key**: This is the name of the property we want to decorate'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Key**：这是我们想要装饰的属性的名称'
- en: Possible use cases for this specific type of decorator may encompass from logging
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 特定类型的装饰器的可能用例可能包括日志记录
- en: 'the value assigned to class fields when instancing objects of such a class
    and even reacting to data changes on such fields. Let''s see an actual example
    that encompasses both of these behaviors:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化此类的对象的类字段分配的值，甚至对这些字段的数据更改做出反应。让我们看一个实际的例子，涵盖了这两种行为：
- en: '[PRE97]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The same logic for parameterized class decorators applies here, although the
    signature of the returned function is slightly different in order to match that
    of the parameter-less decorator declaration we already saw.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这里适用于带参数的类装饰器的相同逻辑，尽管返回函数的签名略有不同，以匹配我们已经看到的无参数装饰器声明的签名。
- en: 'The following example depicts how we can log changes on a given class property
    and trigger a custom function when this occurs:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例描述了我们如何记录给定类属性的更改，并在发生这种情况时触发自定义函数：
- en: '[PRE98]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Method decorators
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法装饰器
- en: 'These special decorators can detect, log, and intervene in how methods are
    executed. To do so, we just need to define a `MethodDecorator` function whose
    payload takes the following parameters:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特殊的装饰器可以检测、记录并干预方法的执行方式。为此，我们只需要定义一个`MethodDecorator`函数，其有效负载接受以下参数：
- en: '**Target**: This is typed as an object and represents the method being decorated.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Target**：这被定义为一个对象，代表被装饰的方法。'
- en: '**Key**: This is a string that gives the actual name of the method being decorated.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Key**：这是给定方法的实际名称的字符串。'
- en: '**Value**: This is a property descriptor of the given method. In fact, it''s
    a hash object containing, among other things, a property named value with a reference
    to the method itself.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Value**：这是给定方法的属性描述符。实际上，它是一个哈希对象，其中包含了一个名为value的属性，其中包含对方法本身的引用。'
- en: 'Let''s see how we can leverage the `MethodDecorator` function in an actual
    example. The syntax to this has changed in later TypeScript versions. The idea,
    however, is to intercept before and after the execution of the method. So, why
    would you want to do that? Well, there are a couple of interesting cases:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在实际示例中利用`MethodDecorator`函数。在后来的TypeScript版本中，这种语法已经改变。然而，想法是在方法执行之前和之后拦截。那么，为什么你想这样做呢？嗯，有一些有趣的情况：
- en: You want to know more of how a method is called, what `args`, what were the
    results, and so on
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您想了解有关方法如何被调用的更多信息，例如`args`，结果等
- en: You want to know how long it took for a certain method to run
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您想知道某个方法运行了多长时间
- en: 'Let''s create a decorator for each of these cases:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为每种情况创建一个装饰器：
- en: '[PRE99]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Here, we are talking to the `descriptor.value`, which contains our actual function
    and as you can see, we:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在讨论`descriptor.value`，其中包含我们实际的函数，正如你所看到的，我们：
- en: Save a reference to the old method
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存对旧方法的引用
- en: We redefine the method by replacing what `descriptor.value` points to
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过替换`descriptor.value`指向的内容来重新定义方法
- en: Inside of our new function we execute the old method
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的新函数内部执行旧方法
- en: We log to the console what args was used and what the result became
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们记录使用了什么参数以及结果如何变化
- en: 'So far, we have explained how to add logging information to a method, but there
    was another scenario we wanted to describe as well, namely measuring execution
    time. We can use a very similar approach to the previous one, but with some subtle
    differences:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经解释了如何向方法添加日志信息，但还有另一种情况我们也想描述一下，即测量执行时间。我们可以使用与之前类似的方法，但有一些细微的差别：
- en: '[PRE100]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We still do much of the same, but let''s summarize it in a few bullet points:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然做了很多相同的事情，但让我们用几个要点来总结一下：
- en: Save a reference to the old method
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存对旧方法的引用
- en: Redefine `descriptor.value`
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新定义`descriptor.value`
- en: Start a timer before method execution
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法执行前启动计时器
- en: Execute method
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行方法
- en: Stop the timer after method execution
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法执行后停止计时器
- en: Remember that decorator functions are scoped within the class represented in
    the target parameter, so we can take advantage of that for augmenting the class
    with our own custom members. Be careful when doing this, since this might override
    the already existing members. For the sake of this example, we won't apply any
    due diligence over this, but handle this with care in your code in the future.
    Method decorators are quite a powerful thing, but do not use them all the time,
    but rather in cases like the previous where they shine.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，装饰器函数的作用域限定在目标参数中表示的类中，因此我们可以利用这一点来为类增加我们自己的自定义成员。在这样做时要小心，因为这可能会覆盖已经存在的成员。在本例中，我们不会对此进行任何尽职调查，但在将来的代码中要小心处理。方法装饰器是非常强大的，但不要总是使用它们，而是在像前面那样它们发挥作用的情况下使用。
- en: Parameter decorator
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数装饰器
- en: 'Our last round of decorators will cover the `ParameterDecorator` function,
    which taps into parameters located in function signatures. This sort of decorator
    is not intended to alter the parameter information or the function behavior, but
    to look into the parameter value and then perform operations elsewhere, such as,
    for argument''s sake, logging or replicating data. The `ParameterDecorator` function
    takes the following parameters:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后一轮的装饰器将涵盖`ParameterDecorator`函数，该函数可以访问位于函数签名中的参数。这种装饰器并不意图改变参数信息或函数行为，而是查看参数值，然后在其他地方执行操作，例如，记录日志或复制数据。`ParameterDecorator`函数接受以下参数：
- en: '**Target**: This is the object prototype where the function, whose parameters
    are decorated, usually belongs to a class'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Target**：这是包含被装饰参数的函数的对象原型，通常属于一个类'
- en: '**Key**: This is the name of the function whose signature contains the decorated
    parameter'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Key**：这是包含装饰参数的函数签名的函数的名称'
- en: '**Parameter index**: This is the index in the parameters array where this decorator
    has been applied'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数索引**：这是装饰器应用的参数数组中的索引'
- en: 'The following example shows a working example of a parameter decorator:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了参数装饰器的工作示例：
- en: '[PRE101]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: You have probably noticed the weird assignation of the `functionLogged` variable.
    This is because the value of the target parameter will vary depending on the function
    whose parameters are being decorated. Therefore, it is different if we decorate
    a constructor parameter or a method parameter. The former will return a reference
    to the class prototype and the latter will just return the constructor function.
    The same applies for the key parameter, which will be undefined when decorating
    the constructor parameters.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到`functionLogged`变量的奇怪赋值。这是因为目标参数的值将根据被装饰参数的函数而变化。因此，如果我们装饰构造函数参数或方法参数，它是不同的。前者将返回对类原型的引用，后者将只返回构造函数。当装饰构造函数参数时，key参数也将是未定义的。
- en: As we mentioned in the beginning of this section, parameter decorators are not
    meant to modify the value of the parameters decorated or alter the behavior of
    the methods or constructors where these parameters live. Their purpose is usually
    to log or prepare the container object for implementing additional layers of abstraction
    or functionality through higher-level decorators, such as method or class decorators.
    Usual case scenarios for this encompass logging component behavior or managing
    dependency injection, as we will see in [Chapter 5](3df2cad2-baa6-4076-a6ab-d84247af7817.xhtml),
    *Enhancing Our Components with Pipes and Directives*.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节开头提到的，参数装饰器并不意味着修改装饰的参数的值或更改这些参数所在的方法或构造函数的行为。它们的目的通常是记录或准备容器对象，以通过更高级别的装饰器（如方法或类装饰器）实现额外的抽象层或功能。这种情况的典型案例包括记录组件行为或管理依赖注入，正如我们将在[第5章](3df2cad2-baa6-4076-a6ab-d84247af7817.xhtml)中看到的，“通过管道和指令增强我们的组件”。
- en: Organizing our applications with modules
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块组织我们的应用程序
- en: As our applications scale and grow in size, there will be a time when we will
    need to better organize our code to make it sustainable and more reusable. Modules
    are the response for this need, so let's take a look at how they work and how
    we can implement them in our application. Modules can be either internal or external.
    In this book, we will mostly focus on external modules, but it is a good idea
    to overview the two types now.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用规模和规模的增长，总会有一个时候，我们需要更好地组织我们的代码，使其可持续且更具重用性。模块是对这种需求的响应，所以让我们看看它们是如何工作的，以及我们如何在应用程序中实现它们。模块可以是内部的或外部的。在本书中，我们将主要关注外部模块，但现在概述这两种类型是一个好主意。
- en: Internal modules
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部模块
- en: 'In a nutshell, internal modules are singleton wrappers containing a range of
    classes, functions, objects, or variables that are scoped internally, away from
    the global or outer scope. We can publicly expose the contents of a module by
    prefixing the keyword `export` to the element we want to be accessible from the
    outside, like this:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，内部模块是包含一系列类、函数、对象或变量的单例包装器，其范围在内部，远离全局或外部范围。我们可以通过在我们希望从外部访问的元素前加上关键字“export”来公开模块的内容，就像这样：
- en: '[PRE102]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Our `Greetings` module contains two classes that will be accessible from outside
    the module by importing the module and accessing the class we want to use by its
    name:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“问候”模块包含两个类，可以通过导入模块并通过其名称访问要使用的类来从模块外部访问：
- en: '[PRE103]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'After looking at the preceding code, we can conclude that internal modules
    are a good way to group and encapsulate elements in a namespace context. We can
    even split our modules into several files, as long as the module declaration keeps
    the same name across these files. In order to do so, we will want to reference
    the different files where we have scattered objects belonging to this module with
    reference tags:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看前面的代码之后，我们可以得出结论，内部模块是将元素分组和封装在命名空间上下文中的一种好方法。我们甚至可以将我们的模块拆分成几个文件，只要模块声明在这些文件中保持相同的名称。为了做到这一点，我们将希望使用引用标签引用我们散布在这个模块中的不同文件中的对象：
- en: '[PRE104]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The major drawback of internal modules though is that in order to put them
    to work outside the domain of our IDE, we need to have all of them in the same
    file or application scope. We can include all the generated JavaScript files as
    script inserts in our web pages, leverage task runners such as Grunt or Gulp for
    that, or even use the `--outFile` flag in the TypeScript compiler to have all
    the `.ts` files found in your workspace compiled into a single bundle using a
    bootstrap file with reference tags to all the other modules as the starting point
    for our compilation:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，内部模块的主要缺点是，为了使它们在我们的IDE领域之外工作，我们需要将它们全部放在同一个文件或应用程序范围内。我们可以将所有生成的JavaScript文件作为脚本插入到我们的网页中，利用诸如Grunt或Gulp的任务运行器，或者甚至使用TypeScript编译器中的`--outFile`标志，将工作区中找到的所有`.ts`文件编译成一个单独的捆绑包，使用引用标签到所有其他模块作为我们编译的起点的引导文件：
- en: '[PRE105]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: This will compile all the TypeScript files following the trail of dependent
    files referenced with reference tags. If we forget to reference any file this
    way, it will not be included in the final build file, so another option is to
    enlist all the files containing standalone modules in the compiling command or
    just add a `.txt` file containing a comprehensive list of the modules to bundle.
    Alternatively, we can just use external modules instead.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这将编译所有的TypeScript文件，遵循引用标签引用的依赖文件的路径。如果我们忘记以这种方式引用任何文件，它将不会包含在最终的构建文件中，所以另一个选项是在编译命令中列出包含独立模块的所有文件，或者只需添加一个包含模块综合列表的`.txt`文件来捆绑。或者，我们可以只使用外部模块。
- en: External modules
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部模块
- en: 'External modules are pretty much the solution we need when it comes to building
    applications designed to grow. Basically, each external module works at a file
    level, where each file is the module itself and the module name will match the
    filename without the .js extension. We do not use the module keyword anymore and
    each member marked with the export prefix will become part of the external module
    API. The internal module depicted in the previous example would turn into this
    once conveniently saved in the `Greetings.ts` file:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 外部模块基本上是我们在构建旨在增长的应用程序时所需要的解决方案。基本上，每个外部模块都在文件级别上工作，其中每个文件都是模块本身，模块名称将与没有`.js`扩展名的文件名匹配。我们不再使用模块关键字，每个标有导出前缀的成员将成为外部模块API的一部分。在上一个示例中描述的内部模块一旦方便地保存在`Greetings.ts`文件中，将变成这样：
- en: '[PRE106]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Importing this module and using its exported classes would require the following
    code:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 导入此模块并使用其导出的类需要以下代码：
- en: '[PRE107]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Obviously, the require function is not supported by traditional JavaScript,
    so we need to instruct the compiler about how we want that functionality to be
    implemented in our target JavaScript files. Fortunately, the TypeScript compiler
    includes the `--module` parameter in its API, so we can configure the dependency
    loader of choice for our project: `commonjs` for node-style imports, `amd` for RequireJS-based
    imports, `umd` for a loader implementing the Universal Module Definition specification,
    or system for SystemJS-based imports. We will focus on the SystemJS module loader
    throughout this book:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，传统JavaScript不支持require函数，因此我们需要告诉编译器我们希望在目标JavaScript文件中实现该功能。幸运的是，TypeScript编译器在其API中包含了`--module`参数，因此我们可以为我们的项目配置所选择的依赖加载器：`commonjs`用于基于node的导入，`amd`用于基于RequireJS的导入，`umd`用于实现通用模块定义规范的加载器，或者system用于基于SystemJS的导入。我们将在本书中重点介绍SystemJS模块加载器：
- en: '[PRE108]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The resulting file will be properly shimmed, so modules can load dependencies
    across files using our module loader of choice.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的文件将被适当地填充，因此模块可以使用我们选择的模块加载器跨文件加载依赖项。
- en: ES6 like modules per TypeScript > 1.5
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript > 1.5的ES6模块
- en: 'The way you will be using modules in your Angular projects is by using external
    modules with ES6 syntax, so let''s go through the basics of what that means. As
    mentioned before in this section, there is one file per module and we can export
    it by using the export keyword. How you consume dependencies, however, differs
    syntactically; let''s illustrate this by creating an ES6 module `service.ts` and
    another module `consumer.ts`, which is meant to consume the former:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Angular项目中使用模块的方式是使用ES6语法的外部模块，所以让我们了解一下这意味着什么的基础知识。如本节前面提到的，每个模块一个文件，我们可以使用`export`关键字导出它。然而，你如何消费依赖在语法上有所不同；让我们通过创建一个ES6模块`service.ts`和另一个模块`consumer.ts`来说明这一点，后者旨在消费前者：
- en: '[PRE109]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Two things to notice here is in the `consumer.ts` file:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两件事要注意，在`consumer.ts`文件中：
- en: Importing with curly brackets `{}`
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用大括号`{}`导入
- en: Using the from keyword to find our file
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用from关键字来找到我们的文件
- en: 'The curly bracket `{}` gives us the opportunity to pick and choose what construct
    we actually want to import. Imagine if `service.ts` was more complicated like
    this:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号`{}`给了我们选择想要导入的构造的机会。想象一下如果`service.ts`更复杂，像这样：
- en: '[PRE110]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'As a consumer, we could now choose to import `Service` and/or `PI` like so:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 作为消费者，我们现在可以选择这样导入`Service`和/或`PI`：
- en: '[PRE111]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'It is however possible to use an alternate syntax to export your constructs.
    So far, we have been typing `export` for each thing we wanted to export; we could
    type it like this instead in the third installment of our `service.ts` called
    `service-v3.ts`:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也可以使用另一种语法来导出你的构造。到目前为止，我们一直在为每个想要导出的东西输入`export`；在我们的`service.ts`的第三部分`service-v3.ts`中，我们可以这样输入它：
- en: '[PRE112]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The third way of doing exports is default `export`. There is such a thing as
    a `default` keyword, which means we don''t have to use the curly braces `{}` when
    importing it:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 进行导出的第三种方式是默认的`export`。有一个`default`关键字，这意味着我们在导入时不必使用大括号`{}`：
- en: '[PRE113]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Summary
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This was definitely a long read, but this introduction to TypeScript was absolutely
    necessary in order to understand the logic behind many of the most brilliant parts
    of Angular. It gave us the chance to not only introduce the language syntax, but
    also explain the rationale behind its success as the syntax of choice for building
    the Angular framework. We reviewed its type architecture and how we can create
    advanced business logic designing functions with a wide range of alternatives
    for parameterized signatures, and we even discovered how to bypass issues related
    to scope by using the powerful new arrow functions. Probably the most relevant
    part of this chapter encompassed the overview of classes, methods, properties,
    and accessors and how we can handle inheritance and better application design
    through interfaces. Modules and decorators were some other major features explored
    in this chapter and, as we will see very soon, having a sound knowledge of these
    mechanisms is paramount to understand how dependency injection works in Angular.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是一篇长篇大论，但这篇关于TypeScript的介绍绝对是必要的，以便理解Angular许多最精彩部分背后的逻辑。它让我们有机会不仅介绍语言语法，还解释了它作为构建Angular框架的首选语法成功背后的原因。我们审查了它的类型架构，以及如何使用各种参数化签名的高级业务逻辑设计函数，甚至发现了如何通过使用强大的新箭头函数来绕过与作用域相关的问题。这一章最相关的部分可能是类、方法、属性和访问器的概述，以及我们如何通过接口处理继承和更好的应用程序设计。模块和装饰器是本章探讨的其他重要特性，正如我们很快将看到的那样，对这些机制的充分了解对于理解Angular中的依赖注入是至关重要的。
- en: With all this knowledge at our disposal, we can now resume our investigation
    of Angular and confront the relevant parts of component creation, such as style
    encapsulation, output formatting, and so on with confidence. [Chapter 4](41335dde-9066-4998-a0a9-3c42f97cdd9e.xhtml),
    *Implementing Properties and Events in Our Components*, will expose us to advanced
    template creation techniques, data-binding techniques, directives, and pipes.
    All these features will allow us to put into practice all this newly gained knowledge
    of TypeScript.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，我们现在可以恢复对Angular的调查，并自信地面对组件创建的相关部分，比如样式封装、输出格式化等等。[第4章](41335dde-9066-4998-a0a9-3c42f97cdd9e.xhtml)，*在我们的组件中实现属性和事件*，将使我们接触到高级模板创建技术、数据绑定技术、指令和管道。所有这些特性将使我们能够将新获得的TypeScript知识付诸实践。
