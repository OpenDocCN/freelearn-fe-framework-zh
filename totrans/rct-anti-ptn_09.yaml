- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying Design Principles in React
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design principles are like the cardinal rules that guide software development,
    ensuring that code remains maintainable, scalable, and readable over time. In
    the ever-changing landscape of technology, adhering to these principles can be
    the difference between a project’s long-term success and its descent into “code
    hell,” where changes become increasingly arduous and bugs frequent.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: For React applications, the importance of design principles escalates due to
    the library’s declarative nature and component-based architecture. React empowers
    developers to build complex UIs from small, isolated pieces of code known as components.
    While this modular approach is one of React’s strongest features, it can also
    lead to a messy and unmanageable code base if design principles are ignored.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In a typical React project, components often share state and behavior, get nested
    within each other, and are reused across different parts of an application. Without
    following design principles, you might find yourself entangled in a web of dependencies,
    making it difficult to change or even understand the code. For instance, neglecting
    the **Single Responsibility Principle** (**SRP**) could result in components that
    are difficult to test and refactor, while ignoring the **Interface Segregation
    Principle** (**ISP**) could make your components less reusable and more coupled
    to specific use cases.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, as React continues to evolve, with new features such as Hooks and
    concurrent mode, having a design principle-centered approach ensures that you
    can adapt to these changes without significant rewrites. This allows you to focus
    on building features, fixing bugs, and delivering value, instead of grappling
    with technical debt.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Adhering to design principles in React development is not just a best practice
    but a necessity. It serves as a proactive measure to counteract complexity, making
    your React code easier to read, test, and maintain.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we commence by revisiting the SRP, a core concept that often
    serves as the bedrock of clean, maintainable code. From the humble beginnings
    of a simple string-transforming function, we’ll explore how this principle scales
    up to the complexities of render props, enriching the structure and readability
    of your React components.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning from there, we introduce the **Dependency Inversion Principle**
    (**DIP**), a transformative approach to component design. This section emphasizes
    that focusing on the interface – not the nitty-gritty details of implementation
    – is the pathway to reusable and easily understandable components.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Concluding the chapter, we delve into **Command and Query** **Responsibility
    Segregation** (**CQRS**), a pattern that gains importance as your React applications
    grow in size and complexity. Through a discussion on CQRS, you’ll discover strategies
    to separate your application’s command and query responsibilities, thereby making
    it more manageable and scalable.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: This chapter aims to equip you with a holistic understanding of key design principles,
    which in turn will lay a strong foundation for the rest of your journey in mastering
    React.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the Single Responsibility Principle
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embracing the Dependency Inversion Principle
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Command and Query Responsibility Segregation in React
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A GitHub repository has been created to host all the code we discuss in the
    book. For this chapter, you can find the recommended structure at [https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch9](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch9).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the Single Responsibility Principle
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B21103_04.xhtml#_idTextAnchor111), we delved into the SRP within
    the context of designing React components. Yet this principle is more universal,
    acting as the bedrock for various other programming tenets. To bring this idea
    to life, let’s work through some hands-on examples.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the core responsibility of a component is key to adhering to the
    SRP. Once you isolate what the component is fundamentally meant to do, it becomes
    easier to refactor and abstract out auxiliary functionalities.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The SRP, being a high-level guideline, is advantageous when applied directly
    at the code level. There are numerous ways to implement this principle, but recognizing
    when to apply it is crucial, especially as complexity increases.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The most common two techniques we’ll use are *render props* and *composition*.
    Render props refer to a technique in React for sharing code between components
    using a prop whose value is a function. A component with a render prop takes a
    function that returns a React element and calls it instead of implementing its
    own render logic. On the other hand, composition in React is a development pattern
    where you build components as small, reusable pieces and then compose them together
    to create more complex UIs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we’ll explore two specific examples, demonstrating
    how we use render props and composition respectively to adhere to this principle
    in practice.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the render props pattern
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start simple with a basic function component called `Title`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As it stands, this component merely outputs a static string. To give it the
    ability to render different titles, we introduce a `title` prop:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With this change, the component becomes more versatile, appending a fixed prefix,
    `Title |`, to any title we pass in. But what if we want to further manipulate
    the title, perhaps to capitalize it?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'By utilizing a higher-order function – the `transformer` parameter in the following
    code snippet – we can modify our `Title` component as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: In many programming languages (including JavaScript), a `map`, `filter`, and
    `reduce` on arrays, function composition, currying, and event handling. Higher-order
    functions simplify code structure, improve maintainability, and allow for more
    advanced programming techniques.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多编程语言（包括JavaScript）中，数组的`map`、`filter`和`reduce`、函数组合、柯里化和事件处理。高阶函数简化了代码结构，提高了可维护性，并允许使用更高级的编程技术。
- en: 'Great – our title is now fully customizable. But let’s stretch this even further.
    What if we want the title to be inside an `h3` tag rather than a simple `div`
    tag? React has got us covered – we can pass a function that returns JSX elements:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了——我们的标题现在可以完全自定义。但让我们更进一步。如果我们想将标题放在`h3`标签内而不是简单的`div`标签中怎么办？React已经为我们解决了这个问题——我们可以传递一个返回JSX元素的函数：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice the use of the render prop – we call it as a function and pass in `title`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意渲染属性的使用——我们将其作为一个函数调用，并传递`title`。
- en: 'To use the render prop, we can pass an anonymous function (inside the curly
    braces) into it, as in the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用渲染属性，我们可以将一个匿名函数（在大括号内）传递给它，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In React, this higher-order function doesn’t necessarily have to be named `render`.
    We could just as easily use the `children` prop for a more intuitive design, like
    so:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，这个高阶函数不一定必须命名为`render`。我们同样可以使用`children`属性进行更直观的设计，如下所示：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This allows us to invoke `children` as if it were a regular function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们像调用常规函数一样调用`children`：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Title` component receives a `title` prop and a child function (the latter
    of which is called a `s`, converts it to uppercase, and renders it within an `h3`
    tag. The `Title` component calls this child function with the provided title prop
    for custom rendering.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Title`组件接收一个`title`属性和一个子函数（后者被称为`s`，将其转换为大写，并在`h3`标签内渲染。`Title`组件使用提供的标题属性调用这个子函数以进行自定义渲染。'
- en: In React, the render prop pattern involves passing a function as a prop to a
    component. This function returns JSX that the component will render as part of
    its output. The pattern allows for more flexible and reusable components by giving
    the parent component control over a part of the child component’s rendering logic.
    It’s particularly useful for sharing behavior across multiple components.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，渲染属性模式涉及将一个函数作为属性传递给组件。这个函数返回组件将作为其输出的一部分渲染的JSX。这种模式通过让父组件控制子组件渲染逻辑的一部分，使得组件更加灵活和可重用。这对于在多个组件之间共享行为特别有用。
- en: 'Take note of the overarching pattern at play here: abstraction. Initially,
    we might think of `h2` or `h3` as specific instances of headings. However, upon
    zooming out a bit, we start to understand that they’re part of a broader abstraction:
    a React component or, more technically, `ReactNode`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里起主导作用的模式：抽象。最初，我们可能会将`h2`或`h3`视为标题的具体实例。然而，当我们稍微放大视角时，我们开始理解它们是更广泛抽象的一部分：一个React组件，或者更技术性地，`ReactNode`。
- en: This realization allows us to see the utility of using render props or children
    as higher-order functions. They’re not just features; they represent the level
    of abstraction we’ve achieved. Now, instead of being limited to a specific HTML
    tag such as `h3`, we can pass any JSX element as an argument, from headings to
    fully styled components.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这一认识使我们能够看到使用渲染属性或子组件作为高阶函数的实用性。它们不仅仅是特性；它们代表了我们所达到的抽象层次。现在，我们不再局限于特定的HTML标签，如`h3`，我们可以传递任何JSX元素作为参数，从标题到完全样式化的组件。
- en: With our newly crafted generic component that uses a render prop, we’ve essentially
    created a reusable framework. The beauty lies in the fact that we only need to
    write this general-purpose code once.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们新创建的通用组件，它使用渲染属性，我们实际上创建了一个可重用的框架。其美妙之处在于我们只需要编写一次这种通用代码。
- en: Render props and composition are excellent techniques for this. They allow you
    to extend or customize the behavior of a component without altering its core logic.
    This keeps your components clean, modular, and easy to test, as each component
    does one thing and does it well. We have already seen how render props work in
    the evolution of `Title`, so let’s now have a look at composition.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染属性和组合是处理此类问题的优秀技术。它们允许你在不改变组件核心逻辑的情况下扩展或自定义组件的行为。这使你的组件保持整洁、模块化，并且易于测试，因为每个组件只做一件事，并且做得很好。我们已经看到了在`Title`组件演变过程中渲染属性是如何工作的，现在让我们看看组合。
- en: Using composition to apply the SRP
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用组合来应用SRP（单一责任原则）
- en: '**Composition** is a term we have used in many places throughout the book,
    and at its core is the SRP. If each part of the system can do its job well, it’s
    then possible to compose them together. Let’s inspect a concrete example of this.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合**是我们全书多次使用的一个术语，其核心是SRP。如果系统的每个部分都能很好地完成其工作，那么就可以将它们组合在一起。让我们检查一个具体的例子。'
- en: 'Assume we have an `Avatar` component in a design system with a handy feature:
    if a user passes in a `name` prop to the component, then when the mouse hovers
    over the avatar, a tooltip will show up at the bottom of the avatar with the name
    as its content:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含便捷功能的`Avatar`组件的设计系统：如果用户将`name`属性传递给组件，那么当鼠标悬停在头像上时，一个包含名字内容的提示框会出现在头像底部：
- en: '![Figure 9.1: Avatar component with Tooltip](img/B31103_09_01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1：带有Tooltip的Avatar组件](img/B31103_09_01.jpg)'
- en: 'Figure 9.1: Avatar component with Tooltip'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：带有Tooltip的Avatar组件
- en: 'Internally, `Avatar` utilizes another component, `Tooltip`, to make it happen:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`Avatar`组件利用另一个组件`Tooltip`来实现这一功能：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Avatar` component takes two optional props, `name` and `url`, and displays
    an image using the URL provided. If the `name` prop is also provided, it wraps
    the image in a `Tooltip` component that shows the name when hovered over. The
    `div` tag is styled with a `rounded` class, which will present the avatar in a
    circle.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Avatar`组件接受两个可选属性`name`和`url`，并使用提供的URL显示图像。如果提供了`name`属性，它将图像包裹在一个`Tooltip`组件中，当鼠标悬停时显示名字。`div`标签使用了`rounded`类，这将使头像以圆形呈现。'
- en: 'The original code for the `Avatar` component tightly coupled it to a `Tooltip`
    feature. As users demanded more customization options for the tooltip, maintaining
    this coupling became challenging. Adding more props to handle tooltip customization
    can bloat the `Avatar` component and create a ripple effect: any change in `Tooltip`
    may necessitate changes in `Avatar`, making it hard to manage.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Avatar`组件的原始代码将其紧密耦合到`Tooltip`功能上。随着用户对tooltip的定制选项需求增加，保持这种耦合变得具有挑战性。添加更多属性来处理tooltip定制可能会使`Avatar`组件膨胀，并产生连锁反应：任何对`Tooltip`的改变都可能需要修改`Avatar`，这使得管理变得困难。'
- en: 'Instead of forcing `Tooltip` into `Avatar`, we can simplify `Avatar` to focus
    solely on its primary function—displaying an image. This stripped-down version
    excludes the tooltip, reducing its bundle size and making it more maintainable.
    Here’s how the simplified `Avatar` component looks:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是将`Tooltip`强加到`Avatar`中，而是可以将`Avatar`简化，仅关注其主要功能——显示图像。这个简化版的`Avatar`排除了tooltip，减少了其包的大小，并使其更易于维护。以下是简化后的`Avatar`组件的示例：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'By doing so, we make the `Avatar` and `Tooltip` components composable, meaning
    they can work independently of each other. The consumer can then choose to wrap
    `Avatar` with `Tooltip` if desired, as shown in the following code snippet:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们使得`Avatar`和`Tooltip`组件可以组合使用，这意味着它们可以独立工作。消费者可以选择将`Tooltip`包裹在`Avatar`中，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code imports `Avatar` and `Tooltip` components from the `"@xui"` library.
    It then defines a `MyAvatar` component that displays an avatar for `"Juntao Qiu"`
    (if there isn’t a name needed here, we don’t use the `Tooltip` component). When
    you hover over the avatar, a tooltip appears on top with the name **Juntao Qiu**
    in a design customized with a white font color on a blue background.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从`"@xui"`库中导入`Avatar`和`Tooltip`组件。然后定义了一个`MyAvatar`组件，用于显示`"Juntao Qiu"`的头像（如果这里不需要名字，我们则不使用`Tooltip`组件）。当你鼠标悬停在头像上时，一个包含**Juntao
    Qiu**名字的提示框会出现在顶部，背景为蓝色，字体颜色为白色。
- en: 'The benefit of this approach is twofold:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是双重的：
- en: The `Avatar` component remains lean, reducing its bundle size
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Avatar`组件保持精简，减少了其包的大小。'
- en: The consumer has the freedom to customize `Tooltip` or even use different tooltip
    libraries without affecting `Avatar`
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者有自由定制`Tooltip`或使用不同的tooltip库，而不会影响`Avatar`。
- en: In short, the separation makes the code more modular, and users only have to
    “pay” in terms of code and complexity for the features they actually use.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这种分离使得代码更加模块化，用户只需为他们实际使用的功能“付费”，即支付代码和复杂度。
- en: In both the render props and composition examples, we underlined the essence
    of the SRP in modern web development. The SRP advocates for building components
    that do one thing and do it well, making them more maintainable, reusable, and
    flexible.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染属性和组合的示例中，我们强调了现代Web开发中SRP（单一职责原则）的本质。SRP主张构建只做一件事并且做得好的组件，使它们更易于维护、重用和灵活。
- en: Next, let’s pivot to discussing the DIP, another crucial perspective that complements
    these design principles.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们转向讨论 DIP，这是补充这些设计原则的另一个关键视角。
- en: Embracing the Dependency Inversion Principle
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接受依赖倒置原则
- en: The **DIP** is one of the five principles that make up SOLID, a set of guidelines
    aimed at helping developers create more maintainable, flexible, and scalable software.
    Specifically, the DIP encourages developers to depend on abstractions, not on
    concrete implementations.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**DIP** 是构成 SOLID 的五个原则之一，SOLID 是一套旨在帮助开发者创建更易于维护、灵活和可扩展的软件的指南。具体来说，DIP 鼓励开发者依赖于抽象，而不是具体实现。'
- en: Note
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The five principles of SOLID are the Single Responsibility Principle, Open-Closed
    Principle, Liskov Substitution Principle, Interface Segregation Principle, and
    Dependency Inversion Principle.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID 的五个原则是单一职责原则、开闭原则、里氏替换原则、接口隔离原则和依赖倒置原则。
- en: The DIP addresses several challenges that developers face when building and
    maintaining large systems. One such problem is the rigidity that comes from tightly
    coupled modules. When high-level modules are dependent on low-level modules, even
    small changes to the low-level code can have a broad impact, necessitating changes
    across the system.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: DIP 解决了开发者在构建和维护大型系统时面临的几个挑战。其中一个问题是紧密耦合模块带来的刚性。当高级模块依赖于低级模块时，即使是低级代码的微小更改也可能产生广泛的影响，需要整个系统进行更改。
- en: Understanding how the DIP works
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 DIP 的工作原理
- en: 'In terms of high-level modules and low-level modules, let’s think of a notification
    feature in a system. Here, we want to send out a notification in a form that the
    user prefers, either an email, an SMS message, or both:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在高级模块和低级模块的术语中，让我们考虑一个系统中的通知功能。在这里，我们希望以用户偏好的形式发送通知，无论是电子邮件、短信还是两者兼而有之：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the code, the `EmailNotification` class has a method called `send` that takes
    `message` and `type` as parameters. It then prints out a log to indicate that
    an email with this `message` and `type` is being sent. The `Application` class,
    on the other hand, has a `process` method that simulates some kind of user interaction.
    Inside this method, `Application` uses an instance of `EmailNotification` to send
    an email whenever `process` is invoked.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，`EmailNotification` 类有一个名为 `send` 的方法，该方法接受 `message` 和 `type` 作为参数。然后它打印一条日志，表明正在发送一个具有此
    `message` 和 `type` 的电子邮件。另一方面，`Application` 类有一个 `process` 方法，该方法模拟某种用户交互。在这个方法内部，`Application`
    使用 `EmailNotification` 的一个实例在调用 `process` 时发送电子邮件。
- en: One important thing to note here is that `Application` is tightly coupled to
    `EmailNotification`. This means that if you wanted to change how notifications
    are sent, perhaps by using SMS instead of email, you’d have to modify the `Application`
    class directly, thereby violating the SRP and making the system less flexible.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意的一个重要事项是，`Application` 与 `EmailNotification` 是紧密耦合的。这意味着，如果你想要改变通知的发送方式，比如使用短信而不是电子邮件，你将不得不直接修改
    `Application` 类，从而违反了单一职责原则（SRP），使系统变得不那么灵活。
- en: 'So, to resolve the problem, we can introduce a `Notification` interface and
    let `EmailNotification` implement the interface. That means we could have multiple
    implementations of the interface. Plus, instead of `Application` depending on
    the `EmailNotification` class, `Application` depends on the `Notification` interface.
    Because we rely on the interface, from `Application`’s view, it doesn’t matter
    which concrete implementation is passed in, as long as it implements the `Notification`
    interface – that means we could easily swap it to an `SMSNotification` class if
    we like. Here’s what the code for all of this will look like:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了解决这个问题，我们可以引入一个 `Notification` 接口，并让 `EmailNotification` 实现该接口。这意味着我们可以有多个接口的实现。此外，`Application`
    不再依赖于 `EmailNotification` 类，而是依赖于 `Notification` 接口。因为我们依赖于接口，从 `Application`
    的角度来看，传入的具体实现是哪一个并不重要，只要它实现了 `Notification` 接口——这意味着我们可以轻松地将其更改为 `SMSNotification`
    类。以下是所有这些代码的示例：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The code defines a `Notification` interface with a `send` method, which is then
    implemented by the `EmailNotification` class. The `Application` class is now constructed
    with any object that adheres to the `Notification` interface. Within its `process`
    method, `Application` uses this object to send a notification. This setup decouples
    the `Application` class from the specific notification mechanism, making it more
    flexible and easier to change or extend.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we decide to replace `EmailNotification` with `SMSNotification`,
    the `Application` class won’t need any modifications; we would simply provide
    a different instance that implements the `Notification` interface:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: All right – that’s briefly about how the DIP works. Let’s look at another example
    to find out how to apply the same principle inside a React application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Applying the DIP in an analytics button
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, imagine you have a generic button component that’s used across various
    parts of your application. You want to send analytics events when the button is
    clicked, but how exactly those events are sent should be abstracted away from
    the button component itself.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that generic buttons are widely used in many products already,
    and not all of them need the analytics functionality. So, if you simply change
    the `onClick` handler in the shared `Button` component, it will annoy many innocent
    users.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the current `Button` implementation:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Instead, we could define a new component that wraps the original button around
    and hijacks the click handler for the analysis:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The new code defines a `FancyButton` component that wraps around a basic `Button`
    component. When clicked, `FancyButton` first sends an analytics event to a remote
    server and then proceeds to execute the original `onClick` function passed to
    it. All other props are passed down directly to the underlying `Button` component.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The issue here is that many instances where the `Button` component is used might
    contain similar analytics code, leading to repetitive logic across the code base.
    This redundancy is undesirable, as any changes to the analytics logic would require
    updates in multiple locations, increasing the risk of errors.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s consider the DIP. We will make some changes in the original `Button`
    component, but instead of sending analytics events directly, we’ll first extract
    an interface and make the button rely on the interface (keep in mind there could
    be multiple implementations of that interface).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Just as with the previous `Notification` example, `EmailNotification` is one
    of the notification channels that send email. In this button example, one of the
    implementations sends an event, whereas for products that don’t use analytics
    at all, they just pass in an empty implementation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the change, we’ll need to define a new interface type, and we need
    a context for the implementation of the interface to live in:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This code creates a React context named `InteractionMeasurement` with an interface
    that specifies a `measure` method. This method takes a name (either a string or
    undefined) and an optional timestamp, while the context is initialized as `null`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `Button` component, we can use `useContext` to access the context
    we defined:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The code defines a `Button` component that uses `InteractionContext` to track
    clicks. When the button is clicked, it calls the `measure` method from the context,
    passing in the button’s name and the click event’s timestamp. Then, it proceeds
    to execute any additional `onClick` logic provided. This way, click tracking is
    abstracted away into the context, making the `Button` component more reusable
    and maintainable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: If `interactionContext` is `null`, the `measure` function won’t be called, and
    the component will proceed to execute only the `providedOnClick` function passed
    in as a prop. This allows for optional analytics tracking based on the availability
    of `InteractionContext`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: That would perfectly resolve the problem we have – if a product wants to enable
    the analytics, they can use `Button` within a context that contains an `InteractionMeasurement`
    implementation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Having said that, let’s say we have a `FormApp` application that uses `Button`
    inside an `InteractionContext` instance:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `FormApp` component defines its own analytics logic in the `measure` function
    inside the `context` object. It then passes this function to child components
    through `InteractionContext.Provider`. When a button inside the form is clicked,
    not only will the button’s specific `onClick` logic be executed, but the `measure`
    function will also send event and timestamp data to a remote server for analytics.
    This setup allows for context-based analytics without tying the `Button` component
    to a specific implementation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'For users who don’t want the analytics functionality, they can just use the
    `Button` component as usual:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This methodology offers exceptional flexibility and dynamism, making it invaluable
    for designing common components. It enhances both code reusability and system
    maintainability while also reducing the overall bundle size.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that adding an extra `context` object in such scenarios may initially
    seem excessive. However, in large code bases where different teams work on distinct
    parts, this approach becomes more relevant. For instance, a product team focused
    on analysis might have different objectives compared to a design system team,
    whose aim is to develop generic and atomic components. The design system team
    may not be concerned with analytical aspects. Consequently, directly modifying
    the `Button` component in this environment can be impractical or challenging.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Having that said, I would like to introduce another design principle I constantly
    use in my code; you can think of it as a special form of the SRP at its core.
    This principle is CQRS.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Command and Query Responsibility Segregation in React
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Command and Query Responsibility Segregation** (**CQRS**) principle (also
    known as the **Separation of Command and Query Principle**) is a software design
    principle that suggests that methods or functions should either be commands that
    modify the system’s state or queries that return information about the system’s
    state, but not both.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令和查询责任分离**（**CQRS**）原则（也称为 **命令和查询分离原则**）是一种软件设计原则，它建议方法或函数应该是修改系统状态的命令或返回系统状态信息的查询，但不能两者兼具。'
- en: '**Commands** (or **modifiers**) are methods that perform an action or change
    the state of an object without returning a value. **Queries**, on the other hand,
    are methods to read an object’s state without any changes. Separating commands
    and queries can help reduce coupling between components, making testing, maintaining,
    and modifying code easier. It also makes it easier to reason about the behavior
    of code and can improve the overall design of a system.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令**（或 **修饰符**）是执行操作或改变对象状态但不返回值的方法。另一方面，**查询**是读取对象状态而不进行任何更改的方法。将命令和查询分开可以帮助减少组件之间的耦合，使测试、维护和修改代码变得更加容易。它还使推理代码的行为变得更加容易，并可以改善系统的整体设计。'
- en: 'Although this pattern is widely used on a large scale, such as in designing
    the architecture of systems, it works well at the code level as well. I will demonstrate
    this in a `ShoppingCart` component:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种模式在大型项目中广泛使用，例如在设计系统架构时，它同样在代码层面上也表现良好。我将在 `ShoppingCart` 组件中演示这一点：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `ShoppingApplication` component maintains a shopping cart using the `useState`
    Hook with an array of items of type `Item`. The `addItemToCart` function adds
    new items to the cart, and `removeItemFromCart` removes items based on their `id`
    value. `totalPrice` is calculated as the sum of all item prices in the cart.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShoppingApplication` 组件使用 `useState` Hook 和一个类型为 `Item` 的项目数组来维护购物车。`addItemToCart`
    函数向购物车添加新项目，而 `removeItemFromCart` 函数则根据其 `id` 值移除项目。`totalPrice` 是购物车中所有项目价格的累加。'
- en: The component renders a list of items in the cart, along with their total price.
    Each item has a `removeItemFromCart` when clicked. A `ProductList` component is
    also rendered, and it receives `addItemToCart` as a prop for adding products to
    the cart.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 组件渲染购物车中的项目列表及其总价。每个项目都有一个在点击时移除项目的 `removeItemFromCart`。同时渲染一个 `ProductList`
    组件，它接收 `addItemToCart` 作为属性以添加产品到购物车。
- en: The previous code appears to be okay at first glance, but it contains some subtle
    issues. One problem is that when multiple identical products are added to the
    cart, the keys will overlap, triggering React’s warning about unique keys. Additionally,
    if you click the **Remove** button in this situation, it will delete all instances
    of that product from the cart, which is far from ideal and leads to a poor user
    experience.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之前的代码似乎没问题，但它包含一些微妙的问题。一个问题是在购物车中添加多个相同的产品时，键值会重叠，从而触发 React 关于唯一键的警告。此外，如果你在这种情况下点击
    **移除** 按钮，它将删除购物车中该产品的所有实例，这远远不是理想的，并且会导致糟糕的用户体验。
- en: 'To fix these issues, we need to introduce a new `uniqKey` field to the `Item`
    type. We also need to generate a unique key before an item is inserted into the
    `cart` array. With that unique ID, we are finally able to remove items by `uniqKey`
    instead of by `id`. This is what the code will look like:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这些问题，我们需要向 `Item` 类型引入一个新的 `uniqKey` 字段。我们还需要在将项目插入 `cart` 数组之前生成一个唯一的键。有了这个唯一的
    ID，我们最终能够通过 `uniqKey` 而不是 `id` 来移除项目。代码将如下所示：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We also need to update how the cart is rendered in JSX:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新在 JSX 中渲染购物车的方式：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: While the code is technically sound and sufficiently straightforward for its
    current scope, as we expand the `ShoppingApplication` component with more states
    and calculations, applying the CQRS principle could provide a structured way to
    keep everything organized.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码在技术上听起来合理，并且对于当前的范围来说足够直接，但随着我们向 `ShoppingApplication` 组件添加更多状态和计算，应用 CQRS
    原则可以提供一种结构化的方式来保持一切井然有序。
- en: We’ll use the React Context API and the `useReducer` Hook to implement CQRS
    for the `ShoppingApplication` component. Let’s take a look at them now.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 React Context API 和 `useReducer` Hook 来为 `ShoppingApplication` 组件实现 CQRS。现在让我们来看看它们。
- en: Introducing useReducer
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入 useReducer
- en: 'The `useReducer` Hook in React is used for state management in functional components;
    it is particularly useful when the next state depends on the previous one or when
    you have complex state logic. The `useReducer` Hook takes two arguments: a reducer
    function and an initial state, and it returns the current state and a `dispatch`
    method to trigger updates.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: For the first parameter, a reducer function receives the current state and an
    `action` object, which contains information on how to update the state. The function
    should return the new state based on the action type and payload. The second parameter
    is the initial state you want to pass in and will be used as the default value
    when invoked.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define a reducer function for our `ShoppingApplication` component:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So, `shoppingCartReducer` is a function that takes two arguments – the current
    state and an action:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The state is of type `ShoppingCartState`, which includes an array of items and
    `totalPrice`
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The action is of type `ActionType`, which includes a `string` type to identify
    the action and a payload containing an `Item` object
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the reducer function, a `switch` statement is used to determine which
    action is being dispatched. The `"ADD_ITEM"` case adds a new item to the state’s
    `items` array. This item is given a unique key, `uniqKey`, to differentiate it
    from identical items. The `"REMOVE_ITEM"` case removes an item from the `items`
    array based on this unique key.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'By using this structure, the reducer function provides a predictable way to
    manage the shopping cart’s state in response to different actions. Note there
    is nothing fancy here in this reducer function; it’s just a regular JavaScript
    function. To see how it works, we could test the reducer function with the following
    code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And we would get something like this (obviously, your `uniqKey` value would
    be different from mine as it’s generated by the time an item is added):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: All right – that should give a taste of what a reducer function is and how it
    works with any given input. Now, let’s see how we can connect it with our application.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Using a reducer function in a context
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s see how we can use a reducer function to implement CQRS to simplify our
    shopping cart example. Firstly, we’ll need a context to manage the cart state,
    and also expose query functions for components to use:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code creates a React context for managing a shopping cart. Inside `ShoppingCartProvider`,
    it uses the `useReducer` Hook to handle cart actions. Two functions, `addItem`
    and `removeItem`, dispatch actions to modify the cart. The `Provider` component
    makes the cart state and these functions available to its child components via
    `ShoppingCartContext`. This allows any nested components to interact with the
    shopping cart.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `addItem` and `removeItem` are two command functions in the CQRS
    principle that only change the state without returning any data. If we want to
    get the data, we can define a query function, like so:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we define a custom Hook called `useTotalPrice` that calculates the total
    price of items in a shopping cart. It uses the React `useContext` Hook to access
    the shopping cart data from `ShoppingCartContext`. It then uses the `reduce` method
    to sum up the prices of all items in the cart, starting with an initial value
    of `0`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `ShoppingApplication` component, we can simply wrap `ProductList` and
    `ShoppingCart` inside the `ShoppingCartContext` instance we just created:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `ShoppingApplication` component serves as the main interface for the shopping
    application. It uses React’s `useContext` Hook to access the shopping cart context,
    which provides a list of items in the cart (`items`), a function to add items
    (`addItem`), and a function to remove items (`removeItem`). The component also
    uses a `useTotalPrice` custom Hook to calculate the total price of items in the
    cart.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'And in the outmost `App` component, we can encapsulate the `ShoppingApplication`
    component:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: So, CQRS is a design pattern that separates the modification and query aspects
    of a system to enhance scalability, maintainability, and simplicity. We demonstrated
    this principle by implementing a shopping cart feature – commands to modify the
    cart’s state, such as adding or removing items, were segregated from the queries,
    which included fetching a list of items and calculating the total price; this
    separation was made clear through the use of React’s Context API and custom Hooks,
    which isolated each responsibility effectively. This not only improves code readability
    but also makes it easier to manage and scale the application in the future.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’ve unpacked three crucial design principles: the SRP for
    focused, easy-to-understand components, the DIP for modular, testable code, and
    CQRS for a distinct separation between commands and queries, enhancing maintainability.
    These principles offer a robust foundation for building scalable and high-quality
    software.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll dive deeper into composition principles to further
    refine our approach to React application design.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
