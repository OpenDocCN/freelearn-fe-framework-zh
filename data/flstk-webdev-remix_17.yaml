- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Migration and Upgrade Strategies
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移和升级策略
- en: Throughout this book, we’ve explored many aspects of web development with Remix.
    You learned how to use Remix to unlock the full potential of the web platform,
    and you thoroughly practiced developing full stack applications by building BeeRich.
    In this last chapter, we will talk about migration and upgrade strategies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们探讨了使用 Remix 的许多网络开发方面。您学习了如何使用 Remix 来释放网络平台的全部潜力，并通过构建 BeeRich 完成了全栈应用程序的开发实践。在本章的最后，我们将讨论迁移和升级策略。
- en: 'The chapter is split into two sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为两个部分：
- en: Migrating to Remix
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移到 Remix
- en: Keeping Remix apps up to date
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持 Remix 应用程序更新
- en: First, we will discuss how to migrate to Remix. Different applications may require
    different migration strategies with varying efforts. We will look at non-React,
    React, and React Router apps and create a migration strategy for each. Next, we
    will learn how major version upgrades are rolled out in Remix. We will introduce
    you to Remix’s future flags and discuss how future flags enable us to gradually
    upgrade Remix apps.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论如何迁移到 Remix。不同的应用程序可能需要不同的迁移策略，工作量也各不相同。我们将查看非 React、React 和 React Router
    应用程序，并为每个创建一个迁移策略。接下来，我们将学习 Remix 中主要版本升级的推出方式。我们将向您介绍 Remix 的未来标志，并讨论未来标志如何使我们能够逐步升级
    Remix 应用程序。
- en: After reading this chapter, you will know different migration strategies for
    Remix. You will understand how to run Remix side by side with an existing legacy
    application and how React Router can be used to prepare your code base for a migration.
    Further, you will know how Remix can be integrated within a wider system architecture.
    Finally, you will learn how to gradually upgrade your Remix application with future
    flags.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，您将了解 Remix 的不同迁移策略。您将了解如何与现有的遗留应用程序并行运行 Remix，以及如何使用 React Router 为迁移准备代码库。此外，您将了解
    Remix 如何集成到更广泛的系统架构中。最后，您将学习如何通过未来的标志逐步升级您的 Remix 应用程序。
- en: Migrating to Remix
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移到 Remix
- en: Migrations are never easy. Moving an existing code base to a new framework comes
    with difficulties and may involve a lot of refactoring. Remix is no exception,
    but some strategies may make a migration less painful, depending on the existing
    application architecture. In this section, we will discuss different migration
    strategies for Remix. Let’s start by reviewing a migration from a non-React app.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移永远不会容易。将现有代码库迁移到新框架会带来困难，可能涉及大量的重构。Remix 也不例外，但某些策略可能会根据现有应用程序架构使迁移不那么痛苦。在本节中，我们将讨论
    Remix 的不同迁移策略。让我们首先回顾从非 React 应用程序迁移的案例。
- en: Migrating non-React apps to Remix
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将非 React 应用程序迁移到 Remix
- en: Migrating from a non-React app to Remix is a challenging task and may be very
    time-consuming, depending on the size of the existing application. The complexity
    of a migration usually increases with ongoing feature development. Most of the
    time, we may be unable to freeze feature development and bug fixes while migrating.
    This results in having to migrate existing code and features to Remix while also
    having to implement new features in both the old and new applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从非 React 应用程序迁移到 Remix 是一项具有挑战性的任务，可能非常耗时，具体取决于现有应用程序的大小。迁移的复杂性通常随着持续的功能开发而增加。大多数时候，我们可能无法在迁移时冻结功能开发和错误修复。这导致在迁移现有代码和功能的同时，还必须在旧的和新的应用程序中实现新功能。
- en: One solution may be to run the new and old applications side by side. By doing
    so, we can keep our legacy application alive while ramping up our Remix application.
    Step by step, we may be able to move more and more code to Remix.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案可能是并行运行新旧应用程序。通过这样做，我们可以在提高 Remix 应用程序的同时保持我们的遗留应用程序活跃。逐步地，我们可能能够将越来越多的代码迁移到
    Remix。
- en: For instance, we can host the new Remix application on a subdomain and implement
    new pages and flows in Remix. Using a subdomain, we can share existing cookies
    between the two applications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在子域上托管新的 Remix 应用程序，并在 Remix 中实现新的页面和流程。使用子域，我们可以在两个应用程序之间共享现有的 cookie。
- en: 'The migration process could look like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移过程可能看起来像这样：
- en: Create a new Remix application.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Remix 应用程序。
- en: Register the Remix application on a subdomain to share cookies.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在子域上注册 Remix 应用程序以共享 cookie。
- en: Re-implement reusable components in React.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 React 中重新实现可重用组件。
- en: Recreate the page layout, footer, and navbar in Remix.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Remix 中重新创建页面布局、页脚和导航栏。
- en: Develop new pages and flows in Remix.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Remix 中开发新的页面和流程。
- en: Migrate existing pages incrementally to Remix.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有页面逐步迁移到 Remix。
- en: By developing new pages in Remix, we avoid having to implement new features
    in both the old and new applications. Instead, we can route users back and forth
    between the two applications. We can use cookies and the URL to share application
    states.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 Remix 中开发新页面，我们避免了在旧应用和新应用中实现新功能的需求。相反，我们可以通过两个应用之间路由用户来回。我们可以使用 cookie
    和 URL 来共享应用程序状态。
- en: Running both applications side by side still requires us to do some work up
    front, such as re-implementing reusable components and page layout in React, but
    we can avoid having to make a complete switch before being able to run Remix in
    production.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 同时运行两个应用仍需要我们在前期做一些工作，例如在 React 中重新实现可重用组件和页面布局，但我们可以避免在能够在生产环境中运行 Remix 之前进行完全切换。
- en: If we already use React, then the migration should be easier.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经在使用 React，那么迁移应该会更容易。
- en: Migrating from a React app
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 React 应用迁移
- en: We can reuse bigger parts of our existing code base if we maintain a React application.
    However, if we are currently using a different React framework, such as Gatsby
    or Next.js, then migrating may still require us to run the legacy app and Remix
    app side by side in production.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们维护 React 应用，我们可以重用现有代码库的更大部分。然而，如果我们目前使用的是不同的 React 框架，例如 Gatsby 或 Next.js，那么迁移可能仍然需要在生产环境中同时运行遗留应用和
    Remix 应用。
- en: Migrating from another React meta framework
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从另一个 React 元框架迁移
- en: Different React frameworks utilize different routing conventions, primitives,
    and component APIs. Migrating from another meta framework may allow us to reuse
    existing React components but may still require refactoring.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的 React 框架使用不同的路由约定、原语和组件 API。从另一个元框架迁移可能允许我们重用现有的 React 组件，但仍可能需要重构。
- en: 'The migration process from a different React framework could look like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从不同的 React 框架迁移的过程可能如下所示：
- en: Create a new Remix application.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Remix 应用程序。
- en: Register the Remix application on a subdomain to share cookies.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在子域上注册 Remix 应用程序以共享 cookie。
- en: Copy, paste, and adapt reusable components.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制、粘贴并适应可重用组件。
- en: Copy, paste, and adapt the page layout, footer, and navbar.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制、粘贴并适应页面布局、页脚和导航栏。
- en: Develop new pages and flows in Remix.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Remix 中开发新页面和流程。
- en: Migrate existing pages incrementally to Remix.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有页面逐步迁移到 Remix。
- en: We may need to refactor existing components to use Remix’s primitives and utilities.
    For instance, we want to refactor existing anchor tags to use Remix’s `Link` and
    `NavLink` components. Conclusively, it may be best to copy code to Remix and refactor
    it from there. This requires us to maintain duplicate code across the legacy and
    Remix apps.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要重构现有组件以使用 Remix 的原语和实用工具。例如，我们希望重构现有的锚点标签以使用 Remix 的 `Link` 和 `NavLink`
    组件。最终，最好是将代码复制到 Remix 中并从那里进行重构。这要求我们在遗留应用和 Remix 应用之间维护重复的代码。
- en: It becomes easier if we run a client-side-only React application without a framework.
    Let’s review how to migrate a client-only React app to Remix.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行没有框架的仅客户端 React 应用程序，那么会更容易。让我们回顾如何将仅客户端的 React 应用迁移到 Remix。
- en: Migrating from a client-only React app
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从仅客户端的 React 应用迁移
- en: If we maintain Create React App or a Vite React app (client-only), we might
    have an easier time migrating to Remix, especially if the application already
    utilizes React Router.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们维护 Create React App 或 Vite React 应用（仅客户端），我们可能更容易迁移到 Remix，特别是如果应用程序已经使用了
    React Router。
- en: On the client, Remix runs a client-side React application, and most of the React
    code and client-side fetch requests will work the same way in Remix as they did
    before. Hence, we can run the existing app on the client side inside Remix. From
    there, we can incrementally refactor pieces from the client-side-only app to Remix
    routes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，Remix 运行客户端 React 应用程序，并且大多数 React 代码和客户端请求将像之前一样在 Remix 中工作。因此，我们可以在 Remix
    内部运行现有应用。从那里，我们可以逐步重构客户端仅应用的部分到 Remix 路由。
- en: 'The migration process from a client-only React app could look like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从仅客户端的 React 应用迁移的过程可能如下所示：
- en: Create a new Remix application.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Remix 应用程序。
- en: Move the existing app inside the new Remix app.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有应用移入新的 Remix 应用程序中。
- en: Render the existing app in the `index` route.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `index` 路由中渲染现有应用。
- en: Copy and adapt the page layout, footer, and navbar.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制并适应页面布局、页脚和导航栏。
- en: Develop new pages and flows in Remix.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Remix 中开发新页面和流程。
- en: Migrate existing pages incrementally to Remix.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有页面逐步迁移到 Remix。
- en: We may still need to copy and paste existing components to create Remix-compatible
    versions. However, at least for now, we can do so in the same code base.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能仍然需要复制和粘贴现有的组件来创建与 Remix 兼容的版本。然而，至少目前，我们可以在同一个代码库中这样做。
- en: Migrating becomes much easier if we use React Router as the client-side routing
    solution.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 React Router 作为客户端路由解决方案，迁移将变得容易得多。
- en: Migrating from React Router
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 React Router 迁移
- en: Remix was created by Michael Jackson and Ryan Florence, the creators of React
    Router. Remix has been heavily inspired and influenced by the development and
    maintenance of React Router over the years.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 是由 Michael Jackson 和 Ryan Florence 创建的，他们是 React Router 的创造者。多年来，Remix
    一直受到 React Router 开发和维护的深刻影响和启发。
- en: React Router is a library for client-side routing in React. Since Remix’s development,
    the Remix team has also worked on releasing React Router version 6, which aligns
    React Router’s API with that of Remix. Remix and React Router have since been
    refactored to build upon the same baseline router package.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 是一个用于 React 客户端路由的库。自从 Remix 开发以来，Remix 团队还致力于发布 React Router 6
    版本，使 React Router 的 API 与 Remix 保持一致。自那时起，Remix 和 React Router 都已重构，以建立在相同的基线路由包之上。
- en: When looking through the API documentation of React Router version 6, you may
    notice many familiar concepts such as the `loader` and `action` functions, many
    familiar hooks such as `useLoaderData`, `useActionData`, `useNavigation`, `useSearchParams`,
    `useFetcher` and `useLocation`, and familiar components such as `Form` and `Link`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看 React Router 6 版本的 API 文档时，你可能会注意到许多熟悉的概念，如 `loader` 和 `action` 函数，许多熟悉的钩子，如
    `useLoaderData`、`useActionData`、`useNavigation`、`useSearchParams`、`useFetcher`
    和 `useLocation`，以及熟悉的组件，如 `Form` 和 `Link`。
- en: React Router’s `loader` and `action` functions are executed on the client, not
    the server, as React Router is a client-side routing solution. However, React
    Router uses the same navigation, data loading, and revalidation flow as Remix,
    which allows us to build React Router apps with the same mental model, conventions,
    and primitives. This makes migrating from React Router version 6 to Remix easier.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 React Router 是一个客户端路由解决方案，因此其 `loader` 和 `action` 函数在客户端执行，而不是在服务器上。然而，React
    Router 使用与 Remix 相同的导航、数据加载和重新验证流程，这允许我们以相同的思维模型、约定和原语构建 React Router 应用程序。这使得从
    React Router 6 版本迁移到 Remix 更加容易。
- en: 'We can derive the following migration process for client-only React applications:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为仅使用 React 的应用程序推导出以下迁移过程：
- en: Migrate to React Router version 6.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迁移到 React Router 6 版本。
- en: Iteratively refactor code to use React Router’s primitives and conventions,
    most importantly the `loader` and `action` functions.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐步重构代码以使用 React Router 的原语和约定，最重要的是 `loader` 和 `action` 函数。
- en: Migrate from React Router version 6 to Remix.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 React Router 6 版本迁移到 Remix。
- en: First, we need to migrate to React Router version 6\. We can follow the existing
    migration guides on the React Router documentation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要迁移到 React Router 6 版本。我们可以遵循 React Router 文档中的现有迁移指南。
- en: Once we use React Router version 6, we can refactor the code iteratively over
    time. We will refactor existing fetch requests to React Router’s `loader` and
    `action` functions and utilize React Router’s `Link` and `Form` components to
    implement navigations and mutations – just like with Remix. This also allows us
    to utilize React Router’s life cycle hooks, such as `useNavigation` and `useFetcher`,
    to implement pending states and optimistic UI.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使用 React Router 6 版本，我们就可以随着时间的推移迭代地重构代码。我们将重构现有的 fetch 请求到 React Router
    的 `loader` 和 `action` 函数，并利用 React Router 的 `Link` 和 `Form` 组件来实现导航和突变——就像在 Remix
    中一样。这也允许我们利用 React Router 的生命周期钩子，如 `useNavigation` 和 `useFetcher`，来实现挂起状态和乐观
    UI。
- en: In contrast to Remix, React Router does not use a file-based routing convention.
    If we want to utilize Remix’s file-based routing convention – or any other routing
    convention – then we might want to start defining it already in the client-side
    application. For instance, it may be helpful to move route components into a new
    `routes/` folder and to co-locate the `loader` and `action` functions together
    with the React Router route components, matching Remix’s route file convention.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Remix 相比，React Router 不使用基于文件的路由约定。如果我们想利用 Remix 的基于文件的路由约定——或者任何其他路由约定——那么我们可能需要在客户端应用程序中开始定义它。例如，将路由组件移动到新的
    `routes/` 文件夹，并将 `loader` 和 `action` 函数与 React Router 路由组件一起放置，以匹配 Remix 的路由文件约定。
- en: At some point, we will have to make the switch and move the app over to Remix.
    The closer we bring the application to Remix’s routing convention and data flow,
    the better. However, there is no need to refactor everything to the `loader` and
    `action` functions before making the migration, even though it would be helpful.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，我们不得不切换并迁移应用程序到 Remix。我们将应用程序与 Remix 的路由约定和数据流越接近，效果就越好。然而，在迁移之前，没有必要将所有内容重构为
    `loader` 和 `action` 函数，尽管这样做可能会有所帮助。
- en: We can render the client-side React Router routes within Remix, as discussed
    in the previous section. Naturally, this is not as effective as moving the routes
    over to Remix, but for bigger applications, this may be a valid option to ensure
    a timely migration.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Remix 中渲染客户端 React Router 路由，正如前文所述。自然地，这并不像将路由迁移到 Remix 那样有效，但对于大型应用程序来说，这可能是一个有效的选项，以确保及时迁移。
- en: 'You can read more about an incremental migration from React Router version
    6 to Remix in the Remix documentation: [https://remix.run/docs/en/main/guides/migrating-react-router-app](https://remix.run/docs/en/main/guides/migrating-react-router-app).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Remix 文档中了解更多关于从 React Router 版本 6 到 Remix 的增量迁移信息：[https://remix.run/docs/en/main/guides/migrating-react-router-app](https://remix.run/docs/en/main/guides/migrating-react-router-app)。
- en: Now that we have discussed a strategy to migrate the client-side code, let’s
    review the backend code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了迁移客户端代码的策略，让我们回顾一下后端代码。
- en: Working with a backend application
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与后端应用程序一起工作
- en: Remix’s `loader` and `action` functions run on the server. We can use them to
    read and write directly from and to a database and implement webhooks and server-sent
    event endpoints with resource routes. We can use Remix to implement standalone
    full stack applications that do not require additional backend applications. In
    this section, we will discuss how Remix fits into a bigger system architecture
    and how we can utilize Remix when there are downstream backend applications.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 的 `loader` 和 `action` 函数在服务器上运行。我们可以使用它们直接从数据库中读取和写入，并使用资源路由实现 webhooks
    和服务器端发送事件端点。我们可以使用 Remix 来实现不需要额外后端应用程序的独立全栈应用程序。在本节中，我们将讨论 Remix 如何适应更大的系统架构，以及当存在下游后端应用程序时如何利用
    Remix。
- en: In bigger application architectures, there might be more systems between a frontend
    application and a database. In this case, Remix will serve as the web server for
    our frontend.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型应用程序架构中，可能存在更多系统在客户端应用程序和数据库之间。在这种情况下，Remix 将作为我们前端的服务器。
- en: 'Let’s review the code example from [*Chapter 1*](B17399_01.xhtml#_idTextAnchor013):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 [*第一章*](B17399_01.xhtml#_idTextAnchor013) 中的代码示例：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: On incoming requests, the `loader` function fetches a list of expenses. The
    route component renders both an expense list and an expense form, which on submit
    posts to the same route’s `action` function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收到的请求中，`loader` 函数获取一个支出列表。路由组件渲染支出列表和支出表单，提交时将数据发送到同一路由的 `action` 函数。
- en: Note how we call the `createExpense` and `getExpense` helper functions in the
    `loader` and `action` functions. We could implement these functions to read and
    write from and to a database. However, we could also implement the functions to
    `fetch` from downstream backend services.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在 `loader` 和 `action` 函数中如何调用 `createExpense` 和 `getExpense` 辅助函数。我们可以实现这些函数以从数据库中读取和写入。然而，我们也可以实现这些函数以从下游后端服务中
    `fetch`。
- en: Similarly, we could implement `requireUserSession` to send a request to a downstream
    authentication service, instead of implementing the authentication code within
    our Remix app. Conclusively, Remix can also be used to forward requests to backend
    applications and implement the **Backend for Frontend** (**BFF**) pattern.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以实现 `requireUserSession` 来向下游认证服务发送请求，而不是在我们的 Remix 应用程序中实现认证代码。最终，Remix
    也可以用来将请求转发到后端应用程序并实现 **Backend for Frontend** （**BFF**）模式。
- en: Backend for Frontend
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Backend for Frontend
- en: The BFF pattern specifies a software architecture where each frontend has a
    dedicated backend that is used to tailor content for the specific needs of the
    frontend application. The backend then forwards or orchestrates requests to more
    generic downstream services.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: BFF 模式指定了一种软件架构，其中每个前端都有一个专用的后端，用于为前端应用程序的特定需求定制内容。然后后端将请求转发或协调到更通用的下游服务。
- en: We don’t need to migrate our backend application to Remix simultaneously with
    our frontend application. Instead, we can forward requests from the frontend to
    the legacy backend application. We can then gradually migrate the backend code
    into Remix’s `loader` and `action` functions. Alternatively, we can also maintain
    the backend application together with the Remix app. In bigger system architectures,
    it may be desirable to use Remix only as a web server and use generic backend
    services to implement REST APIs that can be reused across different clients.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要将我们的后端应用程序与前端应用程序同时迁移到Remix。相反，我们可以将前端请求转发到遗留的后端应用程序。然后我们可以逐步将后端代码迁移到Remix的`loader`和`action`函数中。或者，我们也可以与Remix应用程序一起维护后端应用程序。在更大的系统架构中，可能希望仅使用Remix作为Web服务器，并使用通用的后端服务来实现可跨不同客户端重用的REST
    API。
- en: In this section, you learned how to migrate different applications to Remix.
    You now understand how to use Remix as a BFF. In the next section, you will learn
    how to keep your Remix app up to date.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何将不同的应用程序迁移到Remix。你现在理解了如何将Remix用作BFF。在下一节中，你将学习如何保持你的Remix应用程序更新。
- en: Keeping Remix apps up to date
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持Remix应用程序更新
- en: Remix, like every framework, undergoes constant maintenance and development.
    Bigger updates are introduced as major releases that can include breaking changes.
    Upgrading to a newer major version can require refactoring, and especially for
    bigger applications, this can be a painful chore. Remix aims to make upgrading
    to major versions as painless as possible. In this section, we will see how we
    can gradually migrate to newer major versions in Remix.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Remix，就像每个框架一样，经历着持续的维护和开发。较大的更新以包含重大更改的主要版本的形式引入。升级到较新的主要版本可能需要重构，特别是对于大型应用程序，这可能是一项痛苦的任务。Remix旨在使升级到主要版本尽可能无痛。在本节中，我们将了解如何在Remix中逐步迁移到较新的主要版本。
- en: 'Like most open source projects, Remix uses semantic versioning to denote its
    patches and updates. Semantic versioning provides a way to document three different
    kinds of changes in a definitive hierarchy:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 就像大多数开源项目一样，Remix使用语义版本控制来表示其补丁和更新。语义版本控制提供了一种在确定性的层次结构中记录三种不同类型更改的方法：
- en: '`2.x.x`: Changes that increment the first digit are major releases that include
    breaking changes'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`2.x.x`：增加第一个数字的更改是包含重大更改的主要版本。'
- en: '`x.1.x`: Changes incrementing the middle digit are minor releases that introduce
    new features but remain backward-compatible'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x.1.x`：增加中间数字的更改是引入新功能但保持向后兼容的次要版本。'
- en: '`x.x.1`: Changes that increment the last digit are bug fixes and dependency
    patches that remain backward-compatible'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x.x.1`：增加最后一个数字的更改是向后兼容的错误修复和依赖项补丁。'
- en: A new major release breaks backward compatibility, meaning you must update existing
    code to upgrade to the major version. This can be a painful process. Luckily,
    the Remix team provides future flags to avoid all-at-once upgrade processes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的主要版本破坏了向后兼容性，这意味着你必须更新现有代码才能升级到该主要版本。这可能是一个痛苦的过程。幸运的是，Remix团队提供了未来标志来避免一次性升级过程。
- en: 'Future flags are Boolean flags that we can specify in the `remix.config.js`
    file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 未来标志是可以在`remix.config.js`文件中指定的布尔标志：
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Whenever the Remix team finalizes a feature of a new major version, it also
    releases the feature in the previous major version, hidden behind a future flag.
    This means we can start using the new features in the previous version before
    the next major version is released. By utilizing the future flags, we can gradually
    (feature by feature) refactor our code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当Remix团队完成新主要版本的某个功能时，它也会在之前的主要版本中发布该功能，但隐藏在未来的标志后面。这意味着我们可以在下一个主要版本发布之前开始使用之前版本的新功能。通过利用未来标志，我们可以逐步（逐个功能）重构我们的代码。
- en: 'The Remix team distinguishes two kinds of future flags:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Remix团队区分两种类型的未来标志：
- en: Unstable flags
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不稳定标志
- en: Version flags
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本标志
- en: Unstable future flags (`unstable_`) are used for features where the API is still
    under active development and may be up to change. These features are unstable,
    and the API might be removed or changed in future releases.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 不稳定的未来标志（`unstable_`）用于API仍在积极开发且可能发生变化的特性。这些特性是不稳定的，API可能在未来的版本中被移除或更改。
- en: Once an unstable feature is stable, the feature may either be introduced in
    a minor version update or transformed into a version future flag (`vX_`). Version-based
    feature flags enable stable API changes in the current Remix version. Enabling
    a version-based feature flag allows developers to prepare for the next major version
    update. For instance, the `v2_meta` future flag is used to enable the updated
    meta-function API of Remix v2 in Remix v1.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个不稳定的功能变得稳定，该功能可能被引入到小版本更新中，或者转换为一个版本未来标志（`vX_`）。基于版本的特性标志允许在当前的Remix版本中实现稳定的API更改。启用基于版本的特性标志允许开发者为下一个主要版本更新做准备。例如，`v2_meta`未来标志用于在Remix
    v1中启用Remix v2的更新元函数API。
- en: Future flags allow the Remix team to iterate on Remix’s primitives and conventions
    and release new features, one by one, in the current major version. This also
    allows the team to receive early feedback and identify potential issues and bugs
    as early as possible.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 未来标志允许Remix团队对Remix的原语和约定进行迭代，并逐个发布新功能，在当前的主要版本中。这也允许团队尽早收到反馈，并尽早识别潜在的问题和错误。
- en: Future flags do not remove the need to refactor existing code on existing changes,
    but they allow gradual refactoring that can be stretched out over time.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 未来标志并不消除在现有更改中对现有代码进行重构的需要，但它们允许逐步重构，这些重构可以随着时间的推移而扩展。
- en: Summary
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed different migration strategies for Remix. You
    learned strategies to migrate a non-React, React, and React Router application
    to Remix.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Remix的不同迁移策略。你学习了将非React、React和React Router应用程序迁移到Remix的策略。
- en: For bigger migrations, you can run the new Remix app and the old legacy application
    side by side in production. You can build new pages in Remix while incrementally
    moving features from the old application to Remix. Using a subdomain for your
    new Remix app, you can share UI state using cookies.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更大的迁移，你可以在生产环境中并行运行新的Remix应用程序和旧的遗留应用程序。你可以在Remix中构建新页面，同时逐步将功能从旧应用程序迁移到Remix。使用子域名为你新的Remix应用程序，你可以使用cookies共享UI状态。
- en: You now understand that React Router and Remix use the same baseline routing
    implementation. Thus, migration from React Router applications to Remix is easier,
    as you can incrementally prepare your React Router app by taking advantage of
    the shared primitives and conventions. This allows you to reuse much of the code
    between a React Router and Remix app without further refactoring.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你理解了React Router和Remix使用相同的基线路由实现。因此，从React Router应用程序迁移到Remix更容易，因为你可以通过利用共享的原语和约定来逐步准备你的React
    Router应用程序。这允许你在React Router和Remix应用程序之间重用大量代码，而无需进一步重构。
- en: After reading this chapter, you now understand how to use Remix as a BFF to
    forward and orchestrate requests to downstream services. You know that Remix can
    be used independently and as a part of a wider system architecture. When migrating
    to Remix, you can focus on migrating your frontend code while forwarding all requests
    from Remix’s `action` and `loader` functions to the existing backend applications.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，你现在理解了如何将Remix用作BFF（后端前端）来转发和编排对下游服务的请求。你知道Remix可以独立使用，也可以作为更广泛系统架构的一部分。在迁移到Remix时，你可以专注于迁移你的前端代码，同时将所有请求从Remix的`action`和`loader`函数转发到现有的后端应用程序。
- en: Finally, you learned about Remix’s future flags system. Remix offers future
    flags to unlock features of upcoming major versions in the current ones. This
    allows gradual upgrades on a per-feature basis and avoids painful migrations that
    require updating all code at once.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你学习了Remix的未来标志系统。Remix提供未来标志来解锁当前版本中即将到来的主要版本的功能。这允许基于每个功能的逐步升级，并避免了需要一次性更新所有代码的痛苦迁移。
- en: Over the last 17 chapters, you studied many concepts to build full stack applications
    with Remix. As a React developer, Remix provides a lot of great primitives, conventions,
    and levers to let you unlock the full potential of the web platform. Due to Remix’s
    philosophy of embracing the web platform, you not only practiced how to work with
    Remix but also learned about many web standards and concepts, such as the web
    Fetch API, progressive enhancement, HTTP caching headers, and HTTP cookies.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的17章中，你学习了构建全栈应用程序所需的许多概念，以使用Remix。作为React开发者，Remix提供了许多优秀的原语、约定和杠杆，让你能够释放Web平台的全潜能。由于Remix拥抱Web平台的理念，你不仅练习了如何使用Remix，还了解了许多Web标准和概念，例如Web
    Fetch API、渐进增强、HTTP缓存头和HTTP cookies。
- en: Remix is truly a full stack framework for the web, and by following the exercises
    in this book, you were introduced to many aspects of full stack web development,
    such as request-response flows, user authentication, session management, data
    revalidation, and implementing progressive, optimistic, and real-time UIs. I am
    excited to see what you will build next. Happy coding!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Remix确实是一个全栈Web框架，通过遵循本书中的练习，你了解了全栈Web开发的许多方面，例如请求-响应流程、用户认证、会话管理、数据验证，以及实现渐进式、乐观式和实时UI。我很期待看到你接下来会构建什么。快乐编码！
- en: Further reading
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The Remix documentation includes a guide on how to migrate from React Router
    to Remix: [https://remix.run/docs/en/main/guides/migrating-react-router-app](https://remix.run/docs/en/main/guides/migrating-react-router-app).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Remix文档还包括一篇关于如何从React Router迁移到Remix的指南：[https://remix.run/docs/en/main/guides/migrating-react-router-app](https://remix.run/docs/en/main/guides/migrating-react-router-app).
- en: 'The Remix documentation further includes an article by Pedro Cattori that documents
    how to migrate from webpack to Remix: [https://remix.run/blog/migrate-from-webpack](https://remix.run/blog/migrate-from-webpack).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Remix文档还包括Pedro Cattori撰写的一篇文章，记录了如何从webpack迁移到Remix的过程：[https://remix.run/blog/migrate-from-webpack](https://remix.run/blog/migrate-from-webpack).
- en: 'Refer to Remix’s release log to stay up to date with Remix’s releases: [https://github.com/remix-run/remix/releases](https://github.com/remix-run/remix/releases).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看Remix的发布日志，你可以了解Remix的最新发布情况：[https://github.com/remix-run/remix/releases](https://github.com/remix-run/remix/releases).
- en: 'Sergio Xalambrí wrote an article on how to run Next.js side by side with Remix
    for an incremental migration: [https://sergiodxa.com/articles/run-next-and-remix-on-the-same-server](https://sergiodxa.com/articles/run-next-and-remix-on-the-same-server).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Sergio Xalambrí撰写了一篇文章，介绍了如何在同一服务器上同时运行Next.js和Remix以进行增量迁移：[https://sergiodxa.com/articles/run-next-and-remix-on-the-same-server](https://sergiodxa.com/articles/run-next-and-remix-on-the-same-server).
- en: 'You can find Remix’s roadmap on GitHub: [https://github.com/orgs/remix-run/projects/5](https://github.com/orgs/remix-run/projects/5).
    You can also find roadmap planning meetings on YouTube: [https://www.youtube.com/c/Remix-Run/videos](https://www.youtube.com/c/Remix-Run/videos).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到Remix的路线图：[https://github.com/orgs/remix-run/projects/5](https://github.com/orgs/remix-run/projects/5)。你还可以在YouTube上找到路线图规划会议：[https://www.youtube.com/c/Remix-Run/videos](https://www.youtube.com/c/Remix-Run/videos).
- en: 'You can find more information about semantic versioning here: [https://semver.org/](https://semver.org/).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到有关语义化版本控制的信息：[https://semver.org/](https://semver.org/).
- en: 'Learn more about Remix’s future flag approach in this blog post by Matt Brophy:
    [https://remix.run/blog/future-flags](https://remix.run/blog/future-flags).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在Matt Brophy的这篇博客文章中了解更多关于Remix未来标志的方法：[https://remix.run/blog/future-flags](https://remix.run/blog/future-flags).
- en: 'You can read more about Remix as a BFF in the Remix documentation: [https://remix.run/docs/en/main/guides/bff](https://remix.run/docs/en/main/guides/bff).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Remix文档中了解更多关于Remix作为BFF的信息：[https://remix.run/docs/en/main/guides/bff](https://remix.run/docs/en/main/guides/bff).
