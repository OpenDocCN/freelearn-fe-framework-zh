- en: Customizing the Media Player and Improving SEO
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义媒体播放器并改进SEO
- en: Users visit a media-streaming application mainly to play media and explore other
    related media. This makes the media player—and the view that renders the related
    media details—crucial to a streaming application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 用户访问媒体流应用主要是为了播放媒体和探索其他相关媒体。这使得媒体播放器——以及渲染相关媒体详情的视图——对于流应用至关重要。
- en: 'In this chapter, we will focus on developing the play media page for the MERN Mediastream
    application that we started building in the previous chapter, [Chapter 11](d3f14062-4c41-497c-9627-dc22075fb8fb.xhtml),
    *Building a Media Streaming Application*. We will address the following topics
    to bolster the media-playing functionalities and to help boost the presence of
    the media content across the web so that it reaches more users:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于开发我们在上一章（[第11章](d3f14062-4c41-497c-9627-dc22075fb8fb.xhtml)，构建媒体流应用）开始构建的MERN
    Mediastream应用程序的播放媒体页面。我们将解决以下问题，以增强媒体播放功能，并帮助提升媒体内容在网上的影响力，使其触及更多用户：
- en: Customizing player controls on `ReactPlayer`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`ReactPlayer`上自定义播放器控件
- en: Playing the next video from a list of related videos
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从相关视频列表中播放下一个视频
- en: Autoplaying a list of related media
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动播放相关媒体列表
- en: '**Server-side rendering** (**SSR**) of the `PlayMedia` view with data to improve
    **search engine optimization** (**SEO**)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端渲染**（**SSR**）的`PlayMedia`视图，以数据改进**搜索引擎优化**（**SEO**）'
- en: After completing these topics, you will be more adept at designing complex interactions
    between React components in a frontend user interface, and also at improving SEO
    across your full-stack React applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些主题后，您将更擅长设计前端用户界面中React组件之间的复杂交互，并提高您的全栈React应用程序的SEO。
- en: Adding a custom media player to MERN Mediastream
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将自定义媒体播放器添加到MERN Mediastream
- en: 'The MERN Mediastream application developed in the previous chapter implemented
    a simple media player with default browser controls that played one video at a
    time. In this chapter, we will update the view that plays media with a customized
    `ReactPlayer` and a related media list that can be set to play automatically when
    the current video ends. The updated view with the custom player and related playlist
    will resemble the following screenshot:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章中开发的MERN Mediastream应用程序实现了一个简单的媒体播放器，带有默认浏览器控件，一次播放一个视频。在本章中，我们将使用定制的`ReactPlayer`和相关媒体列表更新播放媒体视图，该列表可以在当前视频结束时自动播放。带有自定义播放器和相关播放列表的更新视图将类似于以下截图：
- en: '![](img/630604d3-93f9-4f02-baaa-248ca5940adf.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/630604d3-93f9-4f02-baaa-248ca5940adf.png)'
- en: The code for the complete MERN Mediastream application is available on GitHub
    at [https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter11%20and%2012/mern-mediastream](https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter11%20and%2012/mern-mediastream). You
    can clone this code and run the application as you go through the code explanations
    for the rest of this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的MERN Mediastream应用程序代码可在GitHub上找到，网址为[https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter11%20and%2012/mern-mediastream](https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter11%20and%2012/mern-mediastream)。您可以将此代码克隆并运行，以便在阅读本章剩余部分的代码解释时运行应用程序。
- en: 'The following component tree diagram shows all the custom components that make
    up the MERN Mediastream frontend, including the components that will be improved
    or added in this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的组件树图显示了构成MERN Mediastream前端的所有自定义组件，包括本章中将改进或添加的组件：
- en: '![](img/73c7dd59-4cba-4d9c-96da-8e44f3063c1f.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/73c7dd59-4cba-4d9c-96da-8e44f3063c1f.png)'
- en: Modified components and new components added in this chapter include the `PlayMedia`
    component, which houses all the media player functionalities; the `MediaPlayer`
    component, which adds a `ReactPlayer` with custom controls; and a `RelatedMedia`
    component, which contains a list of related videos. In the following section,
    we will discuss the play media page structure, and how it will accommodate all
    the media viewing and interaction features to be extended in the MERN Mediastream
    application throughout this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中修改的组件和新添加的组件包括`PlayMedia`组件，它包含所有媒体播放器功能；`MediaPlayer`组件，它添加了一个带有自定义控件的`ReactPlayer`；以及`RelatedMedia`组件，它包含一个相关视频列表。在下一节中，我们将讨论播放媒体页面的结构，以及它将如何容纳本章中将在MERN
    Mediastream应用程序中扩展的所有媒体观看和交互功能。
- en: The play media page
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放媒体页面
- en: When visitors want to view specific media on MERN Mediastream, they will be
    taken to the play media page, which will contain the media details, a media player
    to stream the video, and a list of related media that can be played next. We will
    implement this `PlayMedia` view in a React component named `PlayMedia`. In the
    following section, we discuss how this component will be structured to enable
    these functionalities.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当访客想在 MERN Mediastream 上查看特定媒体时，他们将被带到播放媒体页面，该页面将包含媒体详情、用于流式传输视频的媒体播放器以及可以播放的相关媒体列表。我们将使用名为
    `PlayMedia` 的 React 组件实现此 `PlayMedia` 视图。在下一节中，我们将讨论如何构建此组件以实现这些功能。
- en: The component structure
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件结构
- en: 'We will compose the component structure in the play media page in a way that
    allows the media data to trickle down to the inner components from the parent
    component. In this case, the `PlayMedia` component will be the parent component,
    containing the `RelatedMedia` component and also the `Media` component, which
    will have a nested `MediaPlayer` component, as sectioned and highlighted in the
    following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在播放媒体页面中构建组件结构，以便将媒体数据从父组件逐级传递到内部组件。在这种情况下，`PlayMedia` 组件将是父组件，包含 `RelatedMedia`
    组件，还包含 `Media` 组件，该组件将包含嵌套的 `MediaPlayer` 组件，如下面的截图所示：
- en: '![](img/6fffc2bf-bea3-481b-bbb3-5310a6ba7106.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6fffc2bf-bea3-481b-bbb3-5310a6ba7106.png)'
- en: When individual media links are accessed in the frontend of the application,
    the `PlayMedia` component will retrieve and load the corresponding media data
    and list of related media from the server. Then, the relevant details will be passed as
    props to the `Media` and `RelatedMedia` child components.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当在应用程序的前端访问单个媒体链接时，`PlayMedia` 组件将从服务器检索并加载相应的媒体数据和相关媒体列表。然后，相关细节将通过 props 传递给
    `Media` 和 `RelatedMedia` 子组件。
- en: The `RelatedMedia` component will list and link other related media, and clicking
    any media in this list will re-render the `PlayMedia` component and its inner
    components with the new data.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`RelatedMedia` 组件将列出并链接其他相关媒体，点击列表中的任何媒体将重新渲染 `PlayMedia` 组件及其内部组件，并使用新数据。'
- en: We will update the `Media` component we developed in Chapter 11, *Building a
    Media-Streaming Application*, to add a customized media player as a child component.
    This customized `MediaPlayer` component will also utilize the data passed from
    `PlayMedia` to stream the current video and link to the next video in the related
    media list.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新第 11 章 `Building a Media-Streaming Application` 中开发的 `Media` 组件，以添加一个自定义媒体播放器作为子组件。这个定制的
    `MediaPlayer` 组件也将利用从 `PlayMedia` 传递过来的数据来流式传输当前视频并链接到相关媒体列表中的下一个视频。
- en: In the `PlayMedia` component, we will add an autoplay toggle that will let users
    choose to autoplay the videos in the related media list, one after the other.
    The autoplay state will be managed from the `PlayMedia` component, but this feature
    will require the data available in the parent component's state to re-render when
    a video ends in the `MediaPlayer` nested child component, so it can be ensured
    that the next video starts playing automatically while keeping track of the related
    list.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PlayMedia` 组件中，我们将添加一个自动播放切换功能，允许用户选择是否自动播放相关媒体列表中的视频，一个接一个。自动播放状态将由 `PlayMedia`
    组件管理，但此功能需要在 `MediaPlayer` 嵌套子组件中视频结束时重新渲染父组件状态中的数据，以确保下一视频能够自动播放，同时跟踪相关列表。
- en: To achieve this, the `PlayMedia` component will need to provide a state updating
    method as a prop that will be used in the `MediaPlayer` component to update the
    shared and interdependent state values across these components.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，`PlayMedia` 组件需要提供一个状态更新方法作为 prop，该 prop 将在 `MediaPlayer` 组件中使用，以更新这些组件之间的共享和相互依赖的状态值。
- en: Taking this component structure into consideration, we will extend and update
    the MERN Mediastream application to implement a functional play media page. In
    the next section, we will start by adding the feature that provides a list of
    related media to the user in this `PlayMedia` view.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这个组件结构，我们将扩展并更新 MERN Mediastream 应用程序，以实现一个功能齐全的播放媒体页面。在下一节中，我们将首先添加一个功能，在
    `PlayMedia` 视图中向用户提供相关媒体列表。
- en: Listing related media
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出相关媒体
- en: When a user is viewing an individual media on the application, they will also
    see a list of related media on the same page. The related media list will consist
    of other media records that belong to the same genre as the given video and is
    sorted by the highest number of views. For this feature, we will need to integrate
    a full-stack slice that retrieves the relevant list from the Media collection
    in the backend and renders it in the frontend. In the following sections, we will
    add a related media list API in the backend, along with a way to fetch this API
    in the frontend, and a React component that renders the list of media retrieved
    by this API.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在应用程序中查看单个媒体时，他们将在同一页面上看到相关媒体列表。相关媒体列表将包括属于与给定视频相同类型的其他媒体记录，并按观看次数最高的顺序排序。为了实现此功能，我们需要集成一个全栈切片，从后端的媒体集合中检索相关列表并在前端渲染它。在接下来的几节中，我们将在后端添加一个相关媒体列表API，以及在前端获取此API的方法和一个React组件，用于渲染通过此API检索到的媒体列表。
- en: The related media list API
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关媒体列表API
- en: 'We will implement an API endpoint in the backend to retrieve the list of related
    media from the database. The API will receive a `GET` request at `''/api/media/related/:mediaId''`,
    and the route will be declared with the other media routes, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后端实现一个API端点来从数据库中检索相关媒体的列表。该API将在`'/api/media/related/:mediaId'`接收`GET`请求，并且该路由将与其他媒体路由一起声明，如下所示：
- en: '`mern-mediastream/server/routes/media.routes.js`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/routes/media.routes.js`'
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `:mediaId` parameter in the route path will be processed by the `mediaByID`
    method implemented in *The video API* section of [Chapter 11](d3f14062-4c41-497c-9627-dc22075fb8fb.xhtml), *Building
    a Media Streaming Application*. It retrieves the media corresponding to this ID
    from the database and attaches it to the `request` object, so it can be accessed
    in the next method. The `listRelated` controller method is the next method invoked
    for the `GET` request at this API route. This method will query the Media collection
    to find records with the same genre as the media provided, and also exclude this
    given media record from the results returned. The `listRelated` controller method
    is defined as shown in the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 路径中的`:mediaId`参数将由[第11章](d3f14062-4c41-497c-9627-dc22075fb8fb.xhtml)中“视频API”部分实现的`mediaByID`方法处理，该部分是构建媒体流应用。它从数据库中检索与该ID对应的媒体，并将其附加到`request`对象中，以便在下一种方法中访问。`listRelated`控制器方法是调用此API路由的`GET`请求的下一个方法。此方法将查询媒体集合以找到与提供的媒体具有相同类型的记录，并排除返回结果中的给定媒体记录。`listRelated`控制器方法定义如下所示：
- en: '`mern-mediastream/server/controllers/media.controller.js`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/controllers/media.controller.js`'
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The results returned from the query will be sorted by the highest number of
    views and limited to the top four media records. Each `media` object in the returned
    results will also contain the name and ID of the user who posted the media, as
    specified in the `populate` method.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 查询返回的结果将按观看次数最高的顺序排序，并限制为前四个媒体记录。返回结果中的每个`media`对象也将包含发布媒体的用户的名称和ID，如`populate`方法中指定。
- en: 'On the client side, we will set up a corresponding `fetch` method that will
    be used in the `PlayMedia` component to retrieve the related list of media using
    this API. This method will be defined as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，我们将设置一个相应的`fetch`方法，该方法将在`PlayMedia`组件中使用，以使用此API检索相关媒体列表。此方法定义如下：
- en: '`mern-mediastream/client/media/api-media.js`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/api-media.js`'
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This `listRelated` fetch method will take a media ID and make a `GET` request
    to the related media list API in the backend. We will use this method in the `PlayMedia`
    component to retrieve a list of media related to the current media loaded in the
    media player. Then this list will be rendered in the `RelatedMedia` component.
    In the next section, we will look at the implementation of this `RelatedMedia`
    component.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`listRelated`获取方法将接受一个媒体ID，并向后端的相关媒体列表API发起一个`GET`请求。我们将在`PlayMedia`组件中使用此方法来检索与当前媒体播放器中加载的媒体相关的媒体列表。然后，这个列表将在`RelatedMedia`组件中显示。在下一节中，我们将探讨这个`RelatedMedia`组件的实现。
- en: The RelatedMedia component
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关媒体组件
- en: 'In the play media page, beside the media loaded in the player, we will load
    a list of related media in the `RelatedMedia` component. The `RelatedMedia` component
    will take the list of related media as a prop from the `PlayMedia` component and
    render the details along with a video snapshot of each video in the list, as pictured
    in the following screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在播放媒体页面上，除了在播放器中加载的媒体外，我们将在`RelatedMedia`组件中加载相关媒体列表。`RelatedMedia`组件将从`PlayMedia`组件接收相关媒体列表作为prop，并渲染列表中每个视频的详细信息以及视频快照，如图所示：
- en: '![](img/f0422916-b6e8-43d1-bcec-3d100fed2f54.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0422916-b6e8-43d1-bcec-3d100fed2f54.png)'
- en: 'In the implementation of the `RelatedMedia` view, we iterate through the media
    array received in the props using the `map` function and render each media item''s
    details and video snapshot, as shown in the following code structure:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RelatedMedia`视图的实现中，我们使用`map`函数遍历从props接收到的媒体数组，并按以下代码结构渲染每个媒体的详细信息以及视频快照：
- en: '`mern-mediastream/client/media/RelatedMedia.js`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/RelatedMedia.js`'
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this structure, to render the video snapshot for each media item, we will
    use a basic `ReactPlayer` without the controls, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在此结构中，为了渲染每个媒体项目的视频快照，我们将使用不带控件的基本`ReactPlayer`，如下所示：
- en: '`mern-mediastream/client/media/RelatedMedia.js`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/RelatedMedia.js`'
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We wrap the `ReactPlayer` with a link to the individual view of this media.
    So, clicking on the given video snapshot will re-render the `PlayMedia` view to
    load the linked media''s details. Beside the snapshot, we will display the details
    of each video including title, genre, created date, and the number of views, with
    the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`ReactPlayer`包装在一个链接中，以访问此媒体的单独视图。因此，点击给定的视频快照将重新渲染`PlayMedia`视图以加载链接媒体的详细信息。在快照旁边，我们将显示每个视频的详细信息，包括标题、类型、创建日期和观看次数，以下代码所示：
- en: '`mern-mediastream/client/media/RelatedMedia.js`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/RelatedMedia.js`'
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will render the details next to the video snapshot for each media in the
    related media list that is received in the props.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为接收到的props中每个相关媒体列表中的媒体渲染视频快照旁边的详细信息。
- en: To render this `RelatedMedia` component in the play media page, we have to add
    it to the `PlayMedia` component. The `PlayMedia` component will use the related
    media list API implemented earlier in this section to retrieve the related media
    from the backend, and then pass it in the props to the `RelatedMedia` component.
    In the next section, we will discuss the implementation of this `PlayMedia` component.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要在播放媒体页面上渲染此`RelatedMedia`组件，我们必须将其添加到`PlayMedia`组件中。`PlayMedia`组件将使用本节中较早实现的关联媒体列表API从后端检索相关媒体，并将其作为props传递给`RelatedMedia`组件。在下一节中，我们将讨论此`PlayMedia`组件的实现。
- en: The PlayMedia component
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`PlayMedia`组件'
- en: The `PlayMedia` component will render the play media page. This component consists
    of the `Media` and `RelatedMedia` child components along with an autoplay toggle,
    and it provides data to these components when it loads in the view.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayMedia`组件将渲染播放媒体页面。此组件由`Media`和`RelatedMedia`子组件以及自动播放切换组成，并在加载到视图中时为这些组件提供数据。'
- en: 'To render the `PlayMedia` component when individual media links are accessed
    by the user, we will add a `Route` in `MainRouter` and mount `PlayMedia` at `''/media/:mediaId''`,
    as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户访问单个媒体链接时，我们将向`MainRouter`中添加一个`Route`，并在`'/media/:mediaId'`处挂载`PlayMedia`，如下所示：
- en: '`mern-mediastream/client/MainRouter.js`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/MainRouter.js`'
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When the `PlayMedia` component mounts, it will fetch the media data and the
    related media list from the server with `useEffect` hooks based on the `mediaId` parameter
    in the route link.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当`PlayMedia`组件挂载时，它将根据路由链接中的`mediaId`参数使用`useEffect`钩子从服务器获取媒体数据和相关媒体列表。
- en: 'In one `useEffect` hook, it will fetch the media to be loaded in the media
    player, as shown in the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个`useEffect`钩子中，它将获取要在媒体播放器中加载的媒体，如下所示：
- en: '`mern-mediastream/client/media/PlayMedia.js`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/PlayMedia.js`'
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The media ID from the route path is accessed in the `props.match` received from
    the React Router components. It is used in the call to the `read` API fetch method
    to retrieve the media details from the server. The received `media` object is
    set in the state so that it can be rendered in the `Media` component.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从React Router组件接收到的`props.match`中访问路由路径中的媒体ID。它在调用`read` API获取方法时用于从服务器检索媒体详细信息。接收到的`media`对象被设置在状态中，以便可以在`Media`组件中渲染。
- en: In another `useEffect` hook, we use the same media ID to call the `listRelated`
    API fetch method, as shown in the following code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个 `useEffect` 钩子中，我们使用相同的媒体 ID 调用 `listRelated` API 获取方法，如下面的代码所示。
- en: '`mern-mediastream/client/media/PlayMedia.js`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/PlayMedia.js`'
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `listRelated` API fetch method retrieves the related media list from the
    server and sets the values to the state so that it can be rendered in the `RelatedMedia`
    component.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`listRelated` API 获取方法从服务器检索相关媒体列表，并将值设置到状态中，以便在 `RelatedMedia` 组件中渲染。'
- en: 'The media and related media list values stored in the state are used to pass
    relevant props to these child components that are added in the view. For example,
    in the following code, the `RelatedMedia` component is only rendered if the list
    of related media contains any media, and the list is passed to it as a prop:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在状态中的媒体和相关媒体列表值用于将这些属性传递给在视图中添加的子组件。例如，在以下代码中，只有当相关媒体列表包含任何媒体时，`RelatedMedia`
    组件才会被渲染，并将列表作为属性传递给它：
- en: '`mern-mediastream/client/media/PlayMedia.js`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/PlayMedia.js`'
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Later in the chapter, in the *Autoplaying related media* section, we will add
    the `Autoplay` toggle component above the `RelatedMedia` component only if the
    length of the related media list is greater than `0`. We will also discuss the implementation
    of the `handleAutoPlay` method that will be passed as a prop to the `Media` component.
    It will also receive the `media` detail object, and the video URL for the first
    item in the related media list, which will be treated as the next URL to play.
    The `Media` component is added to `PlayMedia`, along with these props, as shown
    in the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，在 *自动播放相关媒体* 部分中，我们将在相关媒体列表长度大于 `0` 的情况下，仅在 `RelatedMedia` 组件上方添加 `Autoplay`
    切换组件。我们还将讨论将作为属性传递给 `Media` 组件的 `handleAutoPlay` 方法的实现。它还将接收 `media` 详细对象，以及相关媒体列表中第一项的视频
    URL，这将被视为下一个要播放的 URL。`Media` 组件被添加到 `PlayMedia` 中，并带有这些属性，如下面的代码所示：
- en: '`mern-mediastream/client/media/PlayMedia.js`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/PlayMedia.js`'
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This `Media` component renders the media details on the play media page, and
    also a customized media player that allows viewers to control the streaming of
    the video. In the next section, we will discuss the implementation of this customized
    media player and complete this core feature of the play media page.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `Media` 组件在播放媒体页面上渲染媒体详情，以及一个定制的媒体播放器，允许观众控制视频的流。在下一节中，我们将讨论此定制媒体播放器的实现，并完成播放媒体页面的核心功能。
- en: Customizing the media player
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制媒体播放器
- en: 'In MERN Mediastream, we want to provide users with a media player with more
    controls than those available in the default browser options, and with a look
    that matches the rest of the application. We will customize the player controls
    on `ReactPlayer` to replace these default controls with a custom look and functionality,
    as seen in the following screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MERN Mediastream 中，我们希望为用户提供一个比默认浏览器选项更多的控件，并且外观与应用程序的其他部分相匹配。我们将定制 `ReactPlayer`
    上的播放器控件，用自定义的外观和功能替换这些默认控件，如下面的截图所示：
- en: '![](img/1c92cc00-464d-4493-9dc3-2a059ef9bdfa.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c92cc00-464d-4493-9dc3-2a059ef9bdfa.png)'
- en: The controls will be added below the video and will include the progress seeking
    bar; the play, pause, next, volume, loop, and fullscreen options; and will also
    display full duration of the video and the amount that's been played. In the following
    sections, we will first update the `Media` component discussed in the previous
    chapter, [Chapter 11](d3f14062-4c41-497c-9627-dc22075fb8fb.xhtml), *Building a
    Media Streaming Application*, to accommodate the new player features. Then, we
    will initialize a `MediaPlayer` component that will contain the new player, before
    implementing functionality for the custom media controls in this player.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 控件将被添加到视频下方，包括进度搜索栏；播放、暂停、下一曲、音量、循环和全屏选项；还将显示视频的总时长和已播放的量。在以下章节中，我们首先更新上一章中讨论的
    `Media` 组件，[第 11 章](d3f14062-4c41-497c-9627-dc22075fb8fb.xhtml)，*构建媒体流应用*，以适应新的播放器功能。然后，在实现此播放器中自定义媒体控件的功能之前，我们将初始化一个包含新播放器的
    `MediaPlayer` 组件。
- en: Updating the Media component
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新媒体组件
- en: 'The existing `Media` component contains a basic `ReactPlayer` with default
    browser controls for playing a given video. We will replace this `ReactPlayer`
    with a new `MediaPlayer` component that we will begin implementing in the next
    section. The `MediaPlayer` component will contain a customized `ReactPlayer`,
    and it will be added to the `Media` component code as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的`Media`组件包含一个基本的`ReactPlayer`，它具有默认的浏览器控件，用于播放指定的视频。我们将用一个新的`MediaPlayer`组件替换这个`ReactPlayer`，我们将在下一节开始实现它。`MediaPlayer`组件将包含一个定制的`ReactPlayer`，并且它将被添加到`Media`组件代码中，如下所示：
- en: '`mern-mediastream/client/media/Media.js`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/Media.js`'
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: While adding this `MediaPlayer` component to the `Media` component, it will
    be passed the current video's source URL, the next video's source URL, and the `handleAutoPlay` method,
    which are received as `props` in the `Media` component from the `PlayMedia` component.
    These URL values and the autoplay handling method will be used in the `MediaPlayer`
    component to add various video-playing options. In the next section, we will begin
    implementing this `MediaPlayer` component by initializing the different values
    needed for adding functional controls to the custom media player.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当将此`MediaPlayer`组件添加到`Media`组件时，它将传递当前视频的源URL、下一视频的源URL以及`handleAutoPlay`方法，这些作为`props`在`Media`组件中从`PlayMedia`组件接收。这些URL值和自动播放处理方法将在`MediaPlayer`组件中用于添加各种视频播放选项。在下一节中，我们将开始实现这个`MediaPlayer`组件，通过初始化添加到自定义媒体播放器中所需的不同值来添加功能控制。
- en: Initializing the media player
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化媒体播放器
- en: We will implement the customized media player in the `MediaPlayer` component.
    This player will render the video streamed from the backend and provide the user
    with different control options. We will incorporate this media-playing functionality
    and the custom control options in the `MediaPlayer` using a `ReactPlayer` component.
    The `ReactPlayer` component, as discussed in the previous chapter, provides a
    range of customizations that we will leverage for the media player features to
    be added in this application.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`MediaPlayer`组件中实现定制的媒体播放器。这个播放器将渲染从后端流出的视频，并为用户提供不同的控制选项。我们将使用`ReactPlayer`组件将此媒体播放功能以及自定义控制选项集成到`MediaPlayer`中。正如前一章所讨论的，`ReactPlayer`组件提供了一系列的自定义选项，我们将利用这些选项来实现本应用程序中要添加的媒体播放器功能。
- en: While defining the `MediaPlayer` component, we will begin by initializing the `ReactPlayer`
    component with starting values for the controls, before we add the custom functionalities
    and corresponding user-action handling code for each control.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义`MediaPlayer`组件时，我们将在添加自定义功能及其对应的用户操作处理代码之前，首先初始化`ReactPlayer`组件的控制起始值。
- en: The control values we customize will correspond to the props allowed in the
    `ReactPlayer` component. To see a list of available props and an explanation of
    each, visit [github.com/CookPete/react-player#props](https://github.com/CookPete/react-player#props).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自定义的控制值将对应于`ReactPlayer`组件中允许的属性。要查看可用属性列表及其解释，请访问 [github.com/CookPete/react-player#props](https://github.com/CookPete/react-player#props)。
- en: 'First, we need to set the initial control values in the component''s state.
    We will start with control values that correspond to the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在组件的状态中设置初始的控制值。我们将从以下对应于以下控制值的控制值开始：
- en: The playing state of the media
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体的播放状态
- en: The volume of the audio
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频的音量
- en: The muted state
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静音状态
- en: The duration of the video
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频的时长
- en: The seeking state
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索状态
- en: The playback rate of the video
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频的播放速率
- en: The loop value
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环值
- en: The fullscreen value
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全屏值
- en: Video errors
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频错误
- en: The played, loaded, and ended states of the video getting streamed
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在流媒体的视频的播放、加载和结束状态
- en: 'The code to initialize these values in the component will be added as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化这些值的代码将添加如下：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These values set in the state will allow us to customize the functionalities
    of the corresponding controls in the `ReactPlayer` component, which we discuss
    in detail in the next section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态中设置的这些值将允许我们自定义`ReactPlayer`组件中相应控制的功能，我们将在下一节中详细讨论。
- en: 'In the `MediaPlayer` component''s view code, we will add this  `ReactPlayer`
    with these control values and source URL, using the prop sent from the `Media`
    component, as shown in the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MediaPlayer`组件的视图代码中，我们将添加这个`ReactPlayer`，并使用从`Media`组件发送的prop，使用这些控制值和源URL，如下面的代码所示：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Besides setting the control values, we will also add styling to the player,
    depending on whether it is in fullscreen mode. We also need to get a reference
    to this player element rendered in the browser so that it can be used in the change-handling
    code for the custom controls. We will use the `useRef` React hook to initialize
    the reference to `null` and then set it to the corresponding player element using
    the `ref` method, as defined in the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置控件值外，我们还将根据播放器是否处于全屏模式添加样式。我们还需要获取浏览器中渲染的此播放器元素的引用，以便可以在自定义控件的代码中使用它。我们将使用`useRef`
    React钩子将引用初始化为`null`，然后使用`ref`方法将其设置为相应的播放器元素，如下面的代码所示：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The value in `playerRef` will give access to the player element rendered in
    the browser. We will use this reference to manipulate the player as required,
    to make the custom controls functional.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`playerRef`中的值将提供对浏览器中渲染的播放器元素的访问权限。我们将使用此引用按需操作播放器，以使自定义控件功能化。'
- en: 'As a final step for initializing the media player, we will add code for handling
    errors thrown by the player if the specified video source cannot be loaded for
    any reason. We will define a `showVideoError` method that will be invoked when
    a video error occurs. The `showVideoError` method will be defined as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 作为初始化媒体播放器的最后一步，我们将添加处理播放器抛出的错误代码，如果由于任何原因指定的视频源无法加载。我们将定义一个`showVideoError`方法，当发生视频错误时将被调用。`showVideoError`方法将定义如下：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This method will render an error message in the view above the media player.
    We can show this error message conditionally by adding the following code in the
    view above the `ReactPlayer`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将在媒体播放器上方的视图中渲染错误消息。我们可以通过在`ReactPlayer`上方的视图中添加以下代码有条件地显示此错误消息：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will render the video error message when an error occurs. As we will allow
    users to play another video in the player from the related media list, we will
    reset the error message if a new video is loaded. We can hide the error message when
    a new video loads with a `useEffect` hook, by ensuring the `useEffect` only runs
    when the video source URL changes, as shown in the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生错误时，这将渲染视频错误消息。由于我们将允许用户从相关媒体列表中在播放器中播放另一个视频，因此如果加载了新视频，我们将重置错误消息。我们可以通过确保`useEffect`仅在视频源URL更改时运行，使用`useEffect`钩子来隐藏新视频加载时的错误消息，如下面的代码所示：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will ensure the error message isn't shown when a new video is loaded and
    streaming correctly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保在新的视频加载并正确流式传输时不会显示错误消息。
- en: With these initial control values set and the `ReactPlayer` added to the component, in
    the next section, we can begin customizing how these controls will appear and
    function in our application.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置了这些初始控件值并将`ReactPlayer`添加到组件后，在下一节中，我们可以开始自定义这些控件在我们应用程序中的外观和功能。
- en: Custom media controls
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义媒体控件
- en: We will add custom player control elements below the video rendered in the `MediaPlayer`
    component and manipulate their functionality using the options and events provided
    by the `ReactPlayer` library. In the following sections, we will implement the
    play, pause, and replay controls; the play next control; the loop functionality;
    volume control options; progress control options; fullscreen option, and also
    display full duration of the video and the amount that's been played.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`MediaPlayer`组件中渲染的视频下方添加自定义播放器控件元素，并使用`ReactPlayer`库提供的选项和事件操作其功能。在以下章节中，我们将实现播放、暂停和重放控件；播放下一个控件；循环功能；音量控制选项；进度控制选项；全屏选项，并显示视频的总时长和已播放的量。
- en: Play, pause, and replay
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放、暂停和重放
- en: 'Users will be able to play, pause, and replay the current video. We will implement
    these three options using `Material-UI` components bound to `ReactPlayer` attributes
    and events. The play, pause, and replay options will render as shown in the following
    screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将能够播放、暂停和重放当前视频。我们将使用绑定到`ReactPlayer`属性和事件的`Material-UI`组件实现这三个选项。播放、暂停和重放选项将渲染如下截图所示：
- en: '![](img/5af8e3ab-a683-446a-835a-cb00744750c8.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5af8e3ab-a683-446a-835a-cb00744750c8.png)'
- en: 'To implement the play, pause, and replay functionality, we will add a play,
    pause, or replay icon button conditionally depending on whether the video is playing,
    is paused, or has ended, as shown in the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现播放、暂停和重播功能，我们将根据视频是否正在播放、是否已暂停或已结束，有条件地添加播放、暂停或重播图标按钮，如下面的代码所示：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The play, pause, or replay icons are rendered in this `IconButton` based on
    the outcome of the ternary operator.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 根据三元运算符的结果，在此 `IconButton` 中渲染播放、暂停或重播图标。
- en: 'When the user clicks the button, we will update the `playing` value in the
    state, so the `ReactPlayer` is also updated. We achieve this by invoking the `playPause`
    method when this button is clicked. The `playPause` method is defined as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击按钮时，我们将更新状态中的 `playing` 值，以便更新 `ReactPlayer`。我们通过在按钮点击时调用 `playPause` 方法来实现这一点。`playPause`
    方法如下定义：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The updated value of `playing` in the state will play or pause the video in
    the `ReactPlayer` component accordingly. In the next section, we will see how
    we can add a control option that will allow us to play the next video from the
    list of related media.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 状态中 `playing` 的更新值将根据 `ReactPlayer` 组件相应地播放或暂停视频。在下一节中，我们将看到如何添加一个控制选项，允许我们从相关媒体列表中播放下一个视频。
- en: Play next
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一个播放
- en: 'Users will be able to play the next video in the related media list using a
    play next button, which will render depending on whether the next video is available
    or not. The two versions of this play next button will display as shown in the
    following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以使用下一个播放按钮播放相关媒体列表中的下一个视频，该按钮将根据下一个视频是否可用而渲染。此下一个播放按钮的两个版本如下截图所示：
- en: '![](img/7cc4eac6-e97b-4698-abff-0219052c85f0.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7cc4eac6-e97b-4698-abff-0219052c85f0.png)'
- en: 'The play next button will be disabled if the related list does not contain
    any media. The play next icon will basically link to the next URL value passed
    in as a prop from `PlayMedia`. This play next button will be added to the `MediaPlayer`
    view, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相关列表不包含任何媒体，则下一个播放按钮将被禁用。下一个播放图标将基本链接到从 `PlayMedia` 传递的作为属性的下一个 URL 值。此下一个播放按钮将被添加到
    `MediaPlayer` 视图中，如下所示：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Clicking on this play next button will reload the `PlayMedia` component with
    the new media details and start playing the video. In the next section, we will
    add a control option that will allow the current video to be played in a loop.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 点击此下一个播放按钮将重新加载带有新媒体详情的 `PlayMedia` 组件并开始播放视频。在下一节中，我们将添加一个控制选项，允许当前视频循环播放。
- en: Loop when a video ends
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视频结束时循环
- en: 'Users will be able to set the current video to keep playing in a loop, using
    a loop button. The loop button will render in two states, set and unset, as shown
    in the following screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以使用循环按钮设置当前视频循环播放。循环按钮将以两种状态渲染，即设置和取消设置，如下面的截图所示：
- en: '![](img/403de211-6868-4820-ad12-9a04ba0594b1.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/403de211-6868-4820-ad12-9a04ba0594b1.png)'
- en: 'This loop icon button will display in a different color to indicate whether
    it has been set or unset by the user. The code for rendering this loop button
    will be added to the `MediaPlayer`, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此循环图标按钮将以不同的颜色显示，以指示它是否已被用户设置或取消设置。渲染此循环按钮的代码将被添加到 `MediaPlayer` 中，如下所示：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The loop icon color will change based on the value of `loop` in the state.
    When this loop icon button is clicked, we will update the `loop` value in the
    state by invoking the `onLoop` method, which is defined as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 循环图标颜色将根据状态中 `loop` 的值而改变。当点击此循环图标按钮时，我们将通过调用以下定义的 `onLoop` 方法来更新状态中的 `loop`
    值：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The video will play on loop when this `loop` value is set to `true`. We will
    need to catch the `onEnded` event, to check whether `loop` has been set to `true`,
    so the `playing` value can be updated accordingly. When a video reaches the end,
    the `onEnded` method will be invoked. This `onEnded` method will be defined as
    follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当此 `loop` 值设置为 `true` 时，视频将循环播放。我们需要捕获 `onEnded` 事件，以检查 `loop` 是否已设置为 `true`，以便相应地更新
    `playing` 值。当视频到达结束时，将调用 `onEnded` 方法。此 `onEnded` 方法如下定义：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So, if the `loop` value is set to `true`, when the video ends it will start
    playing again; otherwise, it will stop playing and render the replay button. In
    the next section, we will add controls for setting the volume of the video.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果将`loop`值设置为`true`，当视频结束时，它将再次开始播放；否则，它将停止播放并渲染重播按钮。在下一节中，我们将添加设置视频音量的控件。
- en: Volume control
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音量控制
- en: 'In order to control the volume of the video being played, users will have the
    option to increase or decrease the volume, as well as to mute or unmute. The rendered
    volume controls will be updated based on the user action and current value of
    the volume. The different states of the volume controls will be as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制正在播放的视频的音量，用户可以选择增加或降低音量，以及静音或取消静音。渲染的音量控件将根据用户操作和当前音量值进行更新。音量控件的不同状态如下：
- en: 'A volume-up icon will be rendered if the volume is raised, as shown in the
    following screenshot:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果音量提高，将渲染一个音量增加图标，如下所示截图：
- en: '![](img/22206b2a-35d7-497c-aa01-48aca0e8d71f.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22206b2a-35d7-497c-aa01-48aca0e8d71f.png)'
- en: 'A volume-off icon will be rendered if the user decreases the volume to zero,
    as pictured next:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户将音量降低到零，将渲染一个音量关闭图标，如下所示：
- en: '![](img/8495d831-b880-40d1-b4fb-27618760c109.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8495d831-b880-40d1-b4fb-27618760c109.png)'
- en: 'A volume-mute icon button will be shown if the user clicks the icon to mute
    the volume, as shown next:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户点击图标以静音音量，将显示一个音量静音图标按钮，如下所示：
- en: '![](img/faff96a6-8595-43c1-aa3b-22a71517126a.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/faff96a6-8595-43c1-aa3b-22a71517126a.png)'
- en: 'To implement this, we will conditionally render the different icons in an `IconButton`,
    based on the `volume`, `muted`, `volume_up`, and `volume_off` values, as shown
    in the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将根据`volume`、`muted`、`volume_up`和`volume_off`值有条件地渲染`IconButton`中的不同图标，如下所示代码：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When this `IconButton` is clicked, it will either mute or unmute the volume
    by invoking the `toggleMuted` method, which is defined as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击此 `IconButton` 时，将通过调用`toggleMuted`方法来静音或取消静音音量，该方法定义如下：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The volume will be muted or unmuted, depending on the current value of `muted`
    in the state. To allow users to increase or decrease the volume, we will add an
    input element of type `range` that will allow users to set a volume value between
    `0` and `1`. This input element will be added to the code, as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 根据状态中`muted`的当前值，音量将被静音或取消静音。为了允许用户增加或降低音量，我们将添加一个类型为`range`的输入元素，允许用户设置介于`0`和`1`之间的音量值。此输入元素将添加到代码中，如下所示：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Changing the `value` on the input range will set the `volume` value in the
    state accordingly by invoking the `changeVolume` method. This `changeVolume` method
    will be defined as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入范围上更改`value`将通过调用`changeVolume`方法相应地设置状态中的`volume`值。此`changeVolume`方法定义如下：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `volume` value changed in the state will be applied to the `ReactPlayer`,
    and this will set the volume of the current media being played. In the next section,
    we will add options to control the progression of the video being played.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 状态中`volume`值的变化将应用于`ReactPlayer`，这将设置当前播放媒体的音量。在下一节中，我们将添加控制正在播放的视频进度的选项。
- en: Progress control
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进度控制
- en: In the media player, users will see how much of the video has been loaded and
    played in a progress bar. To implement this feature, we will use a Material-UI
    `LinearProgress` component to indicate how much of the video has buffered, and
    how much has been played already. Then, we'll combine this component with an input element
    of type `range` to give users the ability to move the time slider to a different
    part of the video and play from there.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在媒体播放器中，用户将看到视频已加载和播放的部分，并在进度条中显示。为了实现此功能，我们将使用Material-UI的`LinearProgress`组件来指示视频已缓冲的部分以及已播放的部分。然后，我们将结合此组件与类型为`range`的输入元素，使用户能够将时间滑块移动到视频的不同部分并从那里播放。
- en: 'This time slider and progress bar will render as shown in the following screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这次时间滑块和进度条将渲染如下截图所示：
- en: '![](img/d00bcb88-028b-41be-8992-1f5c6f04412f.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d00bcb88-028b-41be-8992-1f5c6f04412f.png)'
- en: 'The `LinearProgress` component will use the `played` and `loaded` values in
    the state to render these bars. It will take the `played` and `loaded` values
    to show each in a different color, as shown in the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinearProgress`组件将使用状态中的`played`和`loaded`值来渲染这些条形。它将使用`played`和`loaded`值来显示不同的颜色，如下面的代码所示：'
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The look and color for each progress bar will be determined by the styles you
    define for the `primaryColor`, `dashedColorPrimary`, and `dashed` classes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进度条的外观和颜色将由您为`primaryColor`、`dashedColorPrimary`和`dashed`类定义的样式决定。
- en: 'To update the `LinearProgress` component when the video is playing or loading,
    we will use the `onProgress` event listener to set the current values for `played`
    and `loaded`. The `onProgress` method will be defined as shown in the following
    code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在视频播放或加载时更新`LinearProgress`组件，我们将使用`onProgress`事件监听器来设置`played`和`loaded`的当前值。`onProgress`方法将定义如下所示：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We only want to update the time slider if we are not currently seeking, so we
    first check the `seeking` value in the state before setting the `played` and `loaded`
    values.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想在当前未搜索时更新时间滑块，因此我们首先在设置`played`和`loaded`值之前检查状态中的`seeking`值。
- en: 'For time-sliding control, we will add the range input element and define styles,
    as highlighted in the following code, to place it over the `LinearProgress` component.
    The current value of the range will update as the `played` value changes, so the
    range value seems to be moving with the progression of the video. This input element
    representing the time slider will be added to the media player, as shown in the
    following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于时间滑动控制，我们将添加范围输入元素并定义样式，如下面的代码所示，将其放置在`LinearProgress`组件之上。范围值将随着`played`值的变化而更新，因此范围值看起来会随着视频的进度而移动。这个代表时间滑块的输入元素将被添加到媒体播放器中，如下面的代码所示：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the case where the user drags and sets the range picker on their own, we
    will add code to handle the `onMouseDown`, `onMouseUp`, and `onChange` events
    to start the video from the desired position.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户自己拖动并设置范围选择器的情况下，我们将添加代码来处理`onMouseDown`、`onMouseUp`和`onChange`事件，以便从所需位置开始播放视频。
- en: 'When the user starts dragging by holding the mouse down, we will set `seeking`
    to `true` so that the progress values are not set in `played` and `loaded`. This
    will be achieved with the `onSeekMouseDown` method, which is defined as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下鼠标开始拖动时，我们将`seeking`设置为`true`，这样就不会在`played`和`loaded`中设置进度值。这将通过定义如下所示的`onSeekMouseDown`方法来实现：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As the range value change occurs, we will invoke the `onSeekChange` method
    to set the `played` value and also the `ended` value, after checking whether the
    user dragged the time slider to the end of the video. This `onSeekChange` method
    will be defined as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当范围值发生变化时，我们将调用`onSeekChange`方法来设置`played`值，并在检查用户是否将时间滑块拖动到视频末尾后设置`ended`值。此`onSeekChange`方法将定义如下：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When the user is done dragging and lifts their click on the mouse, we will
    set `seeking` to `false`, and set the `seekTo` value for the media player to the
    current value set in the input range. The `onSeekMouseUp` method will be executed
    when the user is done seeking, and it is defined as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户完成拖动并抬起鼠标点击时，我们将`seeking`设置为`false`，并将媒体播放器的`seekTo`值设置为输入范围中当前设置的值。当用户完成搜索后，将执行`onSeekMouseUp`方法，其定义如下：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This way, the user will be able to select any part of the video to play from,
    and also get visual information on the time progress of the video being streamed.
    In the next section, we will add a control that will allow the user to view the
    video in fullscreen mode.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，用户将能够选择视频的任何部分进行播放，并获得正在流式传输的视频的时间进度视觉信息。在下一节中，我们将添加一个控件，允许用户以全屏模式查看视频。
- en: Fullscreen
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全屏
- en: 'Users will be able to view the video in fullscreen mode by clicking the fullscreen
    button in the controls. The fullscreen button for the player will be rendered
    as shown in the following screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过点击控制栏中的全屏按钮以全屏模式查看视频。播放器的全屏按钮将渲染如下截图所示：
- en: '![](img/872dafe3-3d9a-4cda-9b0f-a188110d13a3.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/872dafe3-3d9a-4cda-9b0f-a188110d13a3.png)'
- en: In order to implement a fullscreen option for the video, we will use the `screenfull` Node
    module to track when the view is in fullscreen, and `findDOMNode` from `react-dom`
    to specify which **Document Object Model** (**DOM**) element will be made fullscreen
    with `screenfull`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为视频实现全屏选项，我们将使用`screenfull`节点模块来跟踪视图是否处于全屏状态，并使用`react-dom`中的`findDOMNode`来指定哪个**文档对象模型**（**DOM**）元素将通过`screenfull`实现全屏。
- en: 'To set up the `fullscreen` code, we first install `screenfull`, by running
    the following command from the command line:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置`fullscreen`代码，我们首先通过在命令行中运行以下命令来安装`screenfull`：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we will import `screenfull` and `findDOMNode` into the `MediaPlayer`
    component, as shown in the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将导入`screenfull`和`findDOMNode`到`MediaPlayer`组件中，如下面的代码所示：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When the `MediaPlayer` component mounts, we will use a `useEffect` hook to
    add a `screenfull` change event listener that will update the `fullscreen` value
    in the state to indicate whether the screen is in fullscreen or not. The `useEffect`
    hook will be added as follows, with the `screenfull` change listener code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当`MediaPlayer`组件挂载时，我们将使用`useEffect`钩子添加一个`screenfull`更改事件监听器，该监听器将更新状态中的`fullscreen`值以指示屏幕是否处于全屏状态。`useEffect`钩子将添加如下，带有`screenfull`更改监听器代码：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This `fullscreen` value set in the state will be updated when the user interacts
    with the button for rendering the video in fullscreen mode. In the view, we will
    add an `icon` button for `fullscreen` with the other control buttons, as shown
    in the following code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态中设置的此`fullscreen`值将在用户与按钮交互以全屏模式渲染视频时更新。在视图中，我们将添加一个`icon`按钮用于`fullscreen`，与其他控制按钮一起，如下面的代码所示：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When the user clicks this button, we will use `screenfull` and `findDOMNode`
    to make the video player fullscreen by invoking the `onClickFullscreen` method,
    which is defined as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击此按钮时，我们将使用`screenfull`和`findDOMNode`通过调用定义如下所示的`onClickFullscreen`方法来使视频播放器全屏：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We access the element that renders the media player in the browser by using
    the `playerRef` reference in `findDOMNode` and make it fullscreen by using `screenfull.request`.
    The user can then watch the video in fullscreen, where they can press *Esc* at
    any time to exit fullscreen and get back to the `PlayMedia` view. In the next
    section, we will implement the final customization in the media player controls
    to display the total length of the video, and how much of it was already played.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`findDOMNode`中的`playerRef`引用来访问浏览器中渲染媒体播放器的元素，并使用`screenfull.request`使其全屏。用户可以全屏观看视频，在任何时候按*Esc*键退出全屏并返回到`PlayMedia`视图。在下一节中，我们将实现媒体播放器控制中的最终定制，以显示视频的总长度以及已经播放的部分。
- en: Played duration
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放时长
- en: 'In the custom media controls section of the media player, we want to show the
    time that has already passed and the total duration of the video in a readable
    time format, as shown in the following screenshot:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在媒体播放器的自定义媒体控制部分，我们希望在可读的时间格式中显示已经过去的时间和视频的总时长，如下面的截图所示：
- en: '![](img/65044ac0-2632-46a7-ab82-0b093bf2227b.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65044ac0-2632-46a7-ab82-0b093bf2227b.png)'
- en: 'To show the time, we can utilize the HTML `time` element, which takes a `datetime`
    value, and add it to the view code in `MediaPlayer`, as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示时间，我们可以利用HTML的`time`元素，它接受一个`datetime`值，并将其添加到`MediaPlayer`的视图代码中，如下所示：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE39]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the `dateTime` attribute for these `time` elements, we provide the total
    rounded-off seconds that represent the played duration or the total duration of
    the video. We will get this total `duration` value for a video by using the `onDuration`
    event and then set it to the state, so it can be rendered in the `time` element.
    The `onDuration` method is defined as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些`time`元素的`dateTime`属性中，我们提供了表示播放时长或视频总时长的总舍入秒数。我们将通过使用`onDuration`事件获取视频的总`duration`值，并将其设置到状态中，以便在`time`元素中渲染。`onDuration`方法定义如下：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To make the duration and already played time values readable, we will use the
    following `format` function:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使时长和已播放时间值可读，我们将使用以下 `format` 函数：
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE41]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This `format` function takes the duration value in seconds and converts it to
    the `hh/mm/ss` format, using methods from the JavaScript Date API.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `format` 函数将秒数转换为 `hh/mm/ss` 格式，使用 JavaScript 日期 API 中的方法。
- en: The controls added to this custom media player are all mostly based on some
    of the available functionality provided in the `ReactPlayer` module, and its examples
    in the official documentation. While implementing the custom media player for
    this application, we updated and added the associated playing controls, looping
    option, volume controls, progress seeking control, fullscreen viewing option,
    and a display of the video duration. There are more options available for further
    customizations and extensions in `ReactPlayer` that may be explored depending
    on specific feature requirements. With the different functionalities of the customized
    media player implemented, in the next section, we can start discussing the implementation
    of autoplaying videos in this player from a list of available media.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到这个自定义媒体播放器的控件大多基于 `ReactPlayer` 模块中提供的一些可用功能及其官方文档中的示例。在为这个应用程序实现自定义媒体播放器时，我们更新并添加了相关的播放控件、循环选项、音量控件、进度搜索控件、全屏观看选项以及视频时长的显示。`ReactPlayer`
    中还有更多选项可用于进一步的定制和扩展，具体取决于特定的功能需求。在实现了自定义媒体播放器的不同功能后，在下一节中，我们可以开始讨论如何从可用的媒体列表中实现播放器的自动播放视频。
- en: Autoplaying related media
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动播放相关媒体
- en: In the play media page, users will have the option to autoplay one video after
    the other from the related media list. To make this feature possible, the `PlayMedia`
    component will manage the autoplay state, which will determine the data and how
    it will be rendered next in the `MediaPlayer` and `RelatedMedia` components after
    the current video finishes streaming in the player. In the following sections,
    we will complete this autoplay functionality by adding a toggle in the `PlayMedia` component
    and implementing the `handleAutoplay` method, which needs to be called when a
    video ends in the `MediaPlayer` component.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在播放媒体页面，用户将可以选择从相关媒体列表中自动播放一个视频接一个视频。为了实现这一功能，`PlayMedia` 组件将管理自动播放状态，这将决定在当前视频在播放器中流式传输结束后，`MediaPlayer`
    和 `RelatedMedia` 组件将如何渲染数据和数据。在接下来的章节中，我们将通过在 `PlayMedia` 组件中添加一个切换按钮并实现 `handleAutoplay`
    方法来完成这个自动播放功能，该方法需要在 `MediaPlayer` 组件中视频结束时被调用。
- en: Toggling autoplay
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切换自动播放
- en: 'On the play media page, we will add an autoplay toggle option above the related
    media list. Besides letting the user set autoplay, the toggle will also indicate
    whether it is currently set or not, as shown in the following screenshot:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在播放媒体页面上，我们将在相关媒体列表上方添加一个自动播放切换选项。除了让用户设置自动播放外，切换按钮还将指示它是否当前已设置，如下面的截图所示：
- en: '![](img/9a49efbd-9bdd-4004-8eea-1c0df87803ca.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a49efbd-9bdd-4004-8eea-1c0df87803ca.png)'
- en: 'To add the autoplay toggle option, we will use a Material-UI `Switch` component
    along with a `FormControlLabel`, and add it to the `PlayMedia` component over
    the `RelatedMedia` component. It will only be rendered when there are media in
    the related media list. We will add this `Switch` component representing the autoplay
    toggle as shown in the following code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加自动播放切换选项，我们将使用 Material-UI 的 `Switch` 组件和 `FormControlLabel`，并将其添加到 `PlayMedia`
    组件上方的 `RelatedMedia` 组件中。它只会在相关媒体列表中有媒体时渲染。我们将添加如下代码所示的表示自动播放切换的 `Switch` 组件：
- en: '`mern-mediastream/client/media/PlayMedia.js`'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/PlayMedia.js`'
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The autoplay toggle label will render according to the current value of `autoPlay`
    in the state. To handle the change to the toggle when the user interacts with
    it, and to reflect this change in the state''s `autoPlay` value, we will use the
    following `onChange` handler function:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 自动播放切换标签将根据状态中 `autoPlay` 的当前值进行渲染。为了处理用户与之交互时的切换变化，并在状态 `autoPlay` 值中反映这种变化，我们将使用以下
    `onChange` 处理函数：
- en: '`mern-mediastream/client/media/PlayMedia.js`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/PlayMedia.js`'
- en: '[PRE43]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This `autoPlay` value, which represents whether the user chose to autoplay all
    the media, will determine what happens when the current video finishes streaming.
    In the next section, we will discuss how the autoplay behavior will be integrated
    with the child components in `PlayMedia`, depending on the toggled value set for
    `autoPlay` by the user.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`autoPlay`值表示用户是否选择了自动播放所有媒体，这将决定当前视频流结束时会发生什么。在下一节中，我们将讨论自动播放行为将如何根据用户设置的`autoPlay`切换值与`PlayMedia`中的子组件集成。
- en: Handling autoplay across components
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在组件间处理自动播放
- en: When a user selects to set the Autoplay toggle to ON, the functionality desired
    here is that when a video ends, if `autoPlay` is set to `true` and the current
    related list of media is not empty, `PlayMedia` should load the media details
    of the first video in the related list.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择将自动播放切换设置为开启时，这里期望的功能是当视频结束时，如果`autoPlay`设置为`true`并且当前相关媒体列表不为空，`PlayMedia`应加载相关列表中第一个视频的媒体详情。
- en: In turn, the `Media` and `MediaPlayer` components should update with the new
    media details, start playing the new video, and render the controls on the player
    appropriately. The list in the `RelatedMedia` component should also update with
    the current media removed from the list, so only the remaining playlist items
    are visible.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，`Media`和`MediaPlayer`组件应该更新为新媒体详情，开始播放新视频，并适当地在播放器上渲染控件。`RelatedMedia`组件中的列表也应该更新，移除列表中的当前媒体，以便只显示剩余的播放列表项目。
- en: 'In order to handle this autoplay behavior across the `PlayMedia` component
    and its child components, `PlayMedia` passes a `handleAutoPlay` method to the
    `Media` component as a prop to be used by the `MediaPlayer` component when a video
    ends. The `handleAutoPlay` method is defined as shown in the following code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理`PlayMedia`组件及其子组件之间的自动播放行为，`PlayMedia`将一个`handleAutoPlay`方法作为属性传递给`Media`组件，以便在视频结束时由`MediaPlayer`组件使用。`handleAutoPlay`方法定义如下代码所示：
- en: '`mern-mediastream/client/media/PlayMedia.js`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/PlayMedia.js`'
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This `handleAutoplay` method takes care of the following when a video ends
    in the `MediaPlayer` component:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当`MediaPlayer`组件中的视频结束时，此`handleAutoplay`方法会处理以下情况：
- en: It takes a callback function from the `onEnded` event listener in the `MediaPlayer`
    component. This callback will be executed if autoplay is not set or the related
    media list is empty so that the controls on the `MediaPlayer` are rendered to
    show that the video has ended.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它接收来自`MediaPlayer`组件中`onEnded`事件监听器的回调函数。如果未设置自动播放或相关媒体列表为空，则此回调函数将被执行，以便在`MediaPlayer`上渲染控件以显示视频已结束。
- en: 'If autoplay is set and there are more than one related media in the list, then:'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果设置了自动播放并且列表中有多个相关媒体，那么：
- en: The first item in the related media list is set as the current `media` object
    in the state so it can be rendered.
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将相关媒体列表中的第一个项目设置为状态中的当前`media`对象，以便可以渲染。
- en: The related media list is updated by removing this first item, which will now
    start playing in the view.
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过移除这个第一个项目来更新相关媒体列表，这个项目现在将在视图中开始播放。
- en: If autoplay is set and there is only one item in the related media list, this
    last item is set to `media` so it can start playing, and the `listRelated` fetch
    method is called to repopulate the `RelatedMedia` view with the related media
    for this last item.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果设置了自动播放并且相关媒体列表中只有一个项目，则此最后一个项目被设置为`media`以便开始播放，并且调用`listRelated`获取方法以重新填充`RelatedMedia`视图，包含此最后一个项目的相关媒体。
- en: With these steps covered within this `handleAutoplay` method, all the aspects
    of the play media page can be updated accordingly at the end of a video, if autoplay
    is set to `true`. In the next section, we will see how the `MediaPlayer` component
    utilizes this `handleAutoplay` method when the current video ends, in order to
    make the autoplay feature functional.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在`handleAutoplay`方法中完成这些步骤后，如果将自动播放设置为`true`，则可以在视频结束时相应地更新播放媒体页面的所有方面。在下一节中，我们将看到`MediaPlayer`组件如何在当前视频结束时利用此`handleAutoplay`方法，以便使自动播放功能生效。
- en: Updating the state when a video ends in MediaPlayer
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在MediaPlayer中更新视频结束时状态
- en: 'The `MediaPlayer` component receives the `handleAutoplay` method as a prop
    from `PlayMedia`. This method will be utilized when the current video finishes
    playing in the player. Hence, we will update the listener code for the `onEnded`
    event to execute this method only when the `loop` is set to `false` for the current
    video. We don''t want to play the next video if the user has decided to loop the
    current video. The `onEnded` method in `MediaPlayer` will be updated with the
    highlighted code shown in the following block:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`MediaPlayer`组件从`PlayMedia`接收`handleAutoplay`方法作为属性。当当前视频在播放器中播放完毕时，将使用此方法。因此，我们将更新`onEnded`事件的监听器代码，仅在当前视频的`loop`设置为`false`时执行此方法。我们不希望播放下一个视频，如果用户决定循环当前视频。`MediaPlayer`中的`onEnded`方法将更新为以下代码块中显示的突出代码：'
- en: '`mern-mediastream/client/media/MediaPlayer.js`'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaPlayer.js`'
- en: '[PRE45]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this code, a callback function is passed to the `handleAutoplay` method,
    in order to set the `playing` value to `false` and render the replay icon button
    instead of the play or pause icon button, after it is determined in `PlayMedia`
    that the autoplay has not been set or that the related media list is empty.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，一个回调函数被传递给`handleAutoplay`方法，以便在`PlayMedia`确定自动播放未设置或相关媒体列表为空后，将`playing`值设置为`false`并渲染重播图标按钮，而不是播放或暂停图标按钮。
- en: The autoplay functionality will continue playing the related videos one after
    the other with this implementation. This implementation demonstrates another way
    to update the state across the components when the values are interdependent.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现将自动播放相关视频，一个接一个。这个实现演示了在组件之间值相互依赖时更新状态的另一种方式。
- en: With this autoplay functionality implemented, we have a complete play media
    page with a customized media player and a related media list that the user can
    choose to autoplay through like a playlist. In the next section, we will make
    this page SEO-friendly by SSR of this view with the media data populated in the
    backend.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现这个自动播放功能，我们拥有了一个完整的播放媒体页面，其中包括一个定制的媒体播放器和用户可以选择自动播放的媒体列表，就像播放列表一样。在下一节中，我们将通过在后端填充媒体数据来使用SSR（服务器端渲染）使这个页面SEO（搜索引擎优化）友好。
- en: Server-side rendering with data
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带数据的服务器端渲染
- en: SEO is important for any web application that delivers content to its users
    and wants to make the content easy to find. Generally, content on any web page
    will have a better chance of getting more viewers if the content is easily readable
    to search engines. When a search-engine bot accesses a web URL, it will get the
    SSR output. Hence, to make the content discoverable, the content should be part
    of the SSR output.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何向用户交付内容并希望使内容易于查找的Web应用程序来说，SEO（搜索引擎优化）非常重要。通常，如果网页上的内容易于搜索引擎阅读，那么内容获得更多观众的机会会更大。当一个搜索引擎机器人访问一个Web
    URL时，它将获取SSR输出。因此，为了使内容可被发现，内容应该是SSR输出的一部分。
- en: In MERN Mediastream, we will use the case of making media details popular across
    search engine results, to demonstrate how to inject data into an SSR view in a
    MERN-based application. We will focus on implementing SSR with data injected for
    the `PlayMedia` component that is returned at the `'/media/:mediaId'` path. The
    general implementation steps outlined here can be used to implement SSR with data
    for other views.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在MERN Mediastream中，我们将使用使媒体详情在搜索引擎结果中流行的案例，来演示如何在基于MERN的应用程序中将数据注入到SSR视图中。我们将专注于实现为在`'/media/:mediaId'`路径返回的`PlayMedia`组件注入数据的SSR。这里概述的一般实现步骤可以用来实现其他视图的SSR和数据注入。
- en: In the following sections, we will extend the SSR implementation discussed in
    [Chapter 4](6f2ca10a-8079-4e3a-9d42-a3db8e85b9d9.xhtml), *Adding a React Frontend
    to Complete MERN*. We will first define a static route configuration file and
    use it to update the existing SSR code in the backend to inject the necessary
    media data from the database. Then, we will update the frontend code to render
    this server-injected data in the view, and, finally, check if this SSR implementation
    works as expected.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将扩展在第4章中讨论的SSR实现，即*添加React前端以完成MERN*。我们首先定义一个静态路由配置文件，并使用它来更新后端现有的SSR代码，以从数据库中注入必要的媒体数据。然后，我们将更新前端代码以在视图中渲染这些服务器注入的数据，最后检查这个SSR实现是否按预期工作。
- en: Adding a route configuration file
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加路由配置文件
- en: In order to load data for the React views when these are rendered on the server,
    we will need to list the frontend routes in a route configuration file. This file
    may then be used with the `react-router-config` module, which provides static
    route configuration helpers for React Router.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在服务器上渲染这些React视图时加载数据，我们需要在路由配置文件中列出前端路由。然后，这个文件可以与`react-router-config`模块一起使用，该模块为React
    Router提供静态路由配置助手。
- en: 'We will first install the module by running the following command from the
    command line:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过在命令行运行以下命令来安装该模块：
- en: '[PRE46]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Next, we will create a route configuration file that will list frontend React
    Router routes. This configuration will be used on the server to match these routes
    with incoming request URLs, to check whether data must be injected before the
    server returns the rendered markup in response to this request.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个路由配置文件，该文件将列出前端React Router路由。此配置将在服务器上用于将这些路由与传入的请求URL匹配，以检查在服务器返回针对此请求渲染的标记之前是否需要注入数据。
- en: 'For the route configuration in MERN Mediastream, we will only list the route
    that renders the `PlayMedia` component and demonstrate how to server-render a
    specific component with data injected from the backend. The route configuration
    will be defined as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MERN Mediastream的路由配置，我们只列出渲染`PlayMedia`组件的路由，并演示如何使用从后端注入的数据来服务器端渲染特定组件。路由配置将定义如下：
- en: '`mern-mediastream/client/routeConfig.js`'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/routeConfig.js`'
- en: '[PRE47]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: For this frontend route and `PlayMedia` component, we specify the `read` fetch
    method from `api-media.js` as the `loadData` method. This can then be used to
    retrieve and inject the data into the `PlayMedia` view when the server generates
    the markup for this component, after receiving a request at `/media/:mediaId`.
    In the next section, we will use this route configuration to update the existing
    SSR code on the backend.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个前端路由和`PlayMedia`组件，我们指定`api-media.js`中的`read`获取方法作为`loadData`方法。然后，可以使用它来检索并将数据注入到`PlayMedia`视图，当服务器生成此组件的标记后，在收到`/media/:mediaId`的请求时。在下文中，我们将使用此路由配置来更新后端现有的SSR代码。
- en: Updating SSR code for the Express server
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新Express服务器的SSR代码
- en: We will update the existing basic SSR code in `server/express.js` to add the
    data-loading functionality for the React views that will get rendered server-side.
    In the following sections, we will first see how to use the route configuration
    to load the data that needs to be injected when the server renders React components.
    Then, we will integrate `isomorphic-fetch` so the server is able to make the `read`
    fetch call to retrieve the necessary data, using the same API fetching code from
    the frontend. Finally, we will inject this retrieved data into the markup generated
    by the server.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新`server/express.js`中现有的基本SSR代码，以添加为将在服务器端渲染的React视图添加数据加载功能。在接下来的章节中，我们将首先了解如何使用路由配置来加载服务器渲染React组件时需要注入的数据。然后，我们将集成`isomorphic-fetch`，以便服务器能够使用来自前端相同的API获取代码进行`read`获取调用以检索必要的数据。最后，我们将将这些检索到的数据注入到服务器生成的标记中。
- en: Using route configuration to load data
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路由配置加载数据
- en: 'We will use the routes defined in the route configuration file to look for
    a matching route when the server receives any request. If a match is found, we
    will use the corresponding `loadData` method declared for this route in the configuration
    to retrieve the necessary data, before it is injected into the server-rendered
    markup representing the React frontend. We will perform these route-matching and
    data-loading actions in a method called `loadBranchData`, which is defined as
    follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器收到任何请求时，我们将使用路由配置文件中定义的路由来查找匹配的路由。如果找到匹配项，我们将使用配置中为该路由声明的相应`loadData`方法来检索必要的数据，在将其注入到代表React前端的服务器端渲染的标记之前。我们将在名为`loadBranchData`的方法中执行这些路由匹配和数据加载操作，该方法定义如下：
- en: '`mern-mediastream/server/express.js`'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/express.js`'
- en: '[PRE48]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This method uses `matchRoutes` from `react-router-config`, and the routes defined
    in the route configuration file, to look for a route matching the incoming request
    URL, which is passed as the `location` argument. If a matching route is found,
    then any associated `loadData` method will be executed to return a `Promise` containing
    the fetched data, or `null` if there were no `loadData` methods. The `loadBranchData`
    defined here will need to be called whenever the server receives a request, so
    if any matching route is found, we can fetch the relevant data and inject it into
    the React components while rendering server side. In the next section, we will
    ensure the fetch methods defined in the frontend code also work on the server
    side, so these same methods also load the corresponding data from the server side.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Isomorphic-fetch
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will ensure that any fetch method we defined for the client code can also
    be used on the server by using the `isomorphic-fetch` Node module. We will first
    install the module by running the following command from the command line:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, we will simply import `isomorphic-fetch` in `express.js`, as shown in
    the following code, to ensure fetch methods now work isomorphically both on the
    client and the server side:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/express.js`'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This `isomorphic-fetch` integration will make sure that the `read` fetch method,
    or any other fetch method that we defined for the client, can now be used on the
    server as well. Before this integration becomes functional, we need to ensure
    the fetch methods use absolute URLs, as discussed in the next section.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Absolute URLs
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One issue with using `isomorphic-fetch` is that it currently requires the fetch
    URLs to be absolute. So, we need to update the URL used in the `read` fetch method,
    defined in `api-media.js`, into an absolute URL.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of hardcoding a server address in the code, we will set a `config`
    variable in `config.js`, as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/config/config.js`'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This will allow us to define and use separate absolute URLs for the API routes
    in development and in production.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we will update the `read` method in `api-media.js` to make sure it uses
    an absolute URL to call the `read` API on the server, as highlighted in the following
    code:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/api-media.js`'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This will make the `read` fetch call compatible with `isomorphic-fetch`, so
    it can be used without a problem on the server side to retrieve the media data
    while server-rendering the `PlayMedia` component with data. In the next section,
    we will discuss how to inject this retrieved data into the server-generated markup
    representing the rendered React frontend.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Injecting data into the React app
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the existing SSR code in the backend, we use `ReactDOMServer` to convert
    the React app to markup. We will update this code in `express.js` to inject the
    retrieved data into the `MainRouter`, as shown in the following code:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/express.js`'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We utilize the `loadBranchData` method to retrieve the relevant data for the
    requested view, then pass this data as a prop to the `MainRouter` component. For
    this data to be added correctly in the rendered `PlayMedia` component when the
    server generates the markup, we need to update the client-side code to consider
    this server-injected data, as discussed in the next section.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`loadBranchData`方法检索请求视图的相关数据，然后将这些数据作为属性传递给`MainRouter`组件。为了在服务器生成标记时正确地将这些数据添加到渲染的`PlayMedia`组件中，我们需要更新客户端代码以考虑此服务器注入的数据，如下一节所述。
- en: Applying server-injected data to client code
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将服务器注入的数据应用于客户端代码
- en: We will update the React code in the frontend to add considerations for the
    data that may be injected from the server if the view is being rendered server-side.
    For this MERN Mediastream application, on the client side, we will access the
    media data passed from the server, and add it to the `PlayMedia` view when the
    server receives a direct request to render this component. In the following sections,
    we will see how to pass the data received in the `MainRouter` to the `PlayMedia`
    component, and render it accordingly.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新前端中的React代码，以添加对可能从服务器注入的数据的考虑，如果视图正在服务器端渲染。对于这个MERN Mediastream应用程序，在客户端，我们将访问从服务器传递的媒体数据，并在服务器接收到直接请求以渲染此组件时将其添加到`PlayMedia`视图中。在接下来的章节中，我们将看到如何将`MainRouter`接收到的数据传递给`PlayMedia`组件，并相应地渲染它。
- en: Passing data props to PlayMedia from MainRouter
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从MainRouter传递数据属性到PlayMedia
- en: 'While generating markup with `ReactDOMServer.renderToString`, we pass the preloaded
    data to `MainRouter` as a prop. We can access this data prop in the `MainRouter` component
    definition, as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`ReactDOMServer.renderToString`生成标记时，我们将预加载数据作为属性传递给`MainRouter`。我们可以在`MainRouter`组件定义中访问此数据属性，如下所示：
- en: '`mern-mediastream/client/MainRouter.js`'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/MainRouter.js`'
- en: '[PRE54]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To give `PlayMedia` access to this data from the `MainRouter`, we will change
    the `Route` component added originally to declare the route for `PlayMedia`, and
    pass this data as a prop, as shown in the following code:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让`PlayMedia`能够访问从`MainRouter`的这些数据，我们将更改最初添加的`Route`组件来声明`PlayMedia`的路由，并将此数据作为属性传递，如下所示：
- en: '`mern-mediastream/client/MainRouter.js`'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/MainRouter.js`'
- en: '[PRE55]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The data prop sent to `PlayMedia` will need to be rendered in the view, as discussed
    next.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到`PlayMedia`的数据属性需要在视图中渲染，如下一节所述。
- en: Rendering received data in PlayMedia
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PlayMedia中渲染接收到的数据
- en: 'In the `PlayMedia` component, we will check for data passed from the server
    and set the values to the state so the media details are rendered in the view
    when the server is generating the corresponding markup. We will do this checking
    and assignment as shown in the following code:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PlayMedia`组件中，我们将检查从服务器传递的数据，并将值设置到状态中，以便在服务器生成相应的标记时，在视图中渲染媒体详情。我们将像以下代码所示进行此检查和分配：
- en: '`mern-mediastream/client/media/PlayMedia.js`'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/PlayMedia.js`'
- en: '[PRE56]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If media data is received in the props from the server, we assign it to the
    `media` value in the state. We also set the `relatedMedia` value to an empty array,
    as we do not intend to render the related media list in the server-generated version.
    This implementation will produce server-generated markup with media data injected
    in the `PlayMedia` view when the corresponding frontend route request is received
    directly on the server. In the next section, we will see how to ensure this implementation
    is actually working and successfully rendering server-generated markup with the
    data populated.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从服务器接收到的媒体数据包含在props中，我们将它分配给状态中的`media`值。我们还将`relatedMedia`值设置为空数组，因为我们不打算在服务器生成的版本中渲染相关媒体列表。这种实现将在服务器直接接收到相应的前端路由请求时，在`PlayMedia`视图中注入媒体数据生成服务器生成的标记。在下一节中，我们将看到如何确保此实现实际上正在工作并且成功渲染了包含数据的服务器生成的标记。
- en: Checking the implementation of SSR with data
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查使用数据的SSR实现
- en: For MERN Mediastream, any of the links that render `PlayMedia` should now generate
    markup on the server side with media details preloaded. We can verify that the
    implementation for SSR with data is working properly by opening the app URL in
    a browser, with JavaScript turned off. In the following section, we will look
    into how to achieve this check in the Chrome browser, and what the resulting view
    should show to the user and to a search engine.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Testing in Chrome
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing this implementation in Chrome just requires updating the Chrome settings
    and loading the application in a tab, with JavaScript blocked. In the following
    sections, we will go over the steps to check whether the `PlayMedia` view renders
    with data when it is just server-generated markup.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Loading a page with JavaScript enabled
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, open the MERN Mediastream application in Chrome, then browse to any media
    link and let it render normally with JavaScript enabled. This should show the
    implemented `PlayMedia` view with the functioning media player and the related
    media list. Leave this tab open as we move on to the next step, to disable JavaScript
    in Chrome.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Disabling JavaScript from settings
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test how the server-generated markup is rendered in the view, we need to
    disable JavaScript on Chrome. For this, you can go to the advanced settings at
    `chrome://settings/content/javascript`, and use the toggle to block JavaScript,
    as shown in the following screenshot:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f60e09a3-e532-4a03-a84b-b43dcdab701e.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
- en: 'Now, refresh the media link in the MERN Mediastream tab, and there should be
    an icon next to the address URL, as shown in the following screenshot, indicating
    that JavaScript is indeed disabled:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b727426e-3006-417b-b8ae-863f5ed033d1.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
- en: The view that will be displayed in the browser at this point will only render
    the server-generated markup received from the backend. In the next section, we
    will discuss what the expected view is when JavaScript is blocked on the browser.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: PlayMedia view with JavaScript blocked
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When JavaScript is blocked in the browser, the `PlayMedia` view should render
    with only the media details populated. But the user interface is no longer interactive
    as JavaScript is blocked, and only the default browser controls are operational,
    as shown in the following screenshot:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7726da83-d4db-4ace-a46a-0970824d4ebb.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
- en: This is the markup that a search-engine bot will read for media content, and
    also what a user will see when no JavaScript loads on the browser. If this implementation
    for SSR with data was not added to the application, then this view would render
    without the associated media details in this scenario, and hence the media information
    would not be read and indexed by search engines.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: MERN Mediastream now has fully operational media-playing tools that will allow
    users to browse and play videos with ease. In addition, the media views that display
    individual media content items are now search-engine-optimized because of SSR
    with preloaded data.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we completely upgraded the play media page on MERN Mediastream.
    We first added custom media player controls, utilizing options available in the `ReactPlayer` component.
    Then, we incorporated the autoplay functionality for a related media playlist,
    after retrieving the related media from the database. Finally, we made the media
    details search-engine-readable by injecting data from the server when the view
    is rendered on the server.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对MERN Mediastream的播放媒体页面进行了全面升级。我们首先添加了自定义媒体播放器控件，利用了`ReactPlayer`组件中可用的选项。然后，在从数据库中检索相关媒体后，我们为相关媒体播放列表集成了自动播放功能。最后，通过在服务器上渲染视图时从服务器注入数据，我们使媒体详细信息可由搜索引擎读取。
- en: You can apply the techniques explored in this chapter to build the play media
    page, to compose and build your own complex user interface with React components
    that are interdependent, and to add SSR with data for views that need to be SEO-friendly
    in your applications.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将本章中探索的技术应用于构建播放媒体页面，使用相互依赖的React组件构建和组合您自己的复杂用户界面，以及为需要SEO友好的视图添加SSR（服务器端渲染）和数据。
- en: We have now explored advanced capabilities, such as streaming and SEO, with the
    MERN stack technologies. In the next two chapters, we will test the potential
    of this stack further by incorporating **virtual reality** (**VR**) elements into
    a full-stack web application using React 360.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经探索了MERN堆栈技术的先进功能，如流式传输和SEO。在接下来的两个章节中，我们将通过将**虚拟现实**（**VR**）元素集成到使用React
    360的全栈Web应用程序中，进一步测试这个堆栈的潜力。
