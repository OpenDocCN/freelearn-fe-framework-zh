- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deployment Targets, Adapters, and Stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During runtime, Remix runs on an underlying web server and handles incoming
    HTTP requests. Starting a new Remix project also means selecting a web server
    and JavaScript runtime. The Remix team and its community maintain starter templates
    and adapters for many popular deployment targets. In this chapter, we will review
    different deployment targets, templates, and Remix stacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Picking a deployment target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching between adapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Remix Stacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with BeeRich
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, we will provide an overview of popular templates, deployment targets,
    JavaScript runtimes, and hosting environments. Next, will practice switching adapters
    and introduce you to Remix Stacks. At the end of this chapter, we will bootstrap
    a new Remix application using the custom template for this book.
  prefs: []
  type: TYPE_NORMAL
- en: After working through this chapter, you will know what to consider when picking
    a deployment target and template for a new Remix app. You will also learn more
    about different JavaScript runtimes and understand the main differences between
    long-running server, serverless, and edge environments. Additionally, you will
    gain practical experience switching between adapters and learn how to work with
    Remix Stacks.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this chapter, you will need a computer that can run Node.js. All
    popular operating systems should suffice. Please install both Node.js and npm
    on your machine. An editor such as VS Code is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download Node.js and npm here: [https://nodejs.org/en/download/](https://nodejs.org/en/download/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/03-deployment-targets-adapters-and-stacks](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/03-deployment-targets-adapters-and-stacks).'
  prefs: []
  type: TYPE_NORMAL
- en: Picking a deployment target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of Remix’s most significant features is its flexibility. Remix supports
    many different web servers and runtime environments, including serverless and
    edge environments. Selecting a template also means choosing a JavaScript runtime,
    a hosting environment (server, serverless, edge), and potentially a hosting provider
    platform. To decide which template to pick for a project, we need to know the
    pros and cons of the different deployment targets to make an informed decision.
    In this section, we provide an overview of popular templates and adapters and
    review their differences.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we created a new Remix application using the `create-remix`
    CLI script. In the process, we had to specify a template or use Remix’s basic
    template. The Remix team and community maintain adapters and templates for many
    different deployment targets. A template bootstraps a new Remix app with the required
    web server code. The web server code is not part of the Remix framework but is
    shipped with a Remix application to ease the development journey.
  prefs: []
  type: TYPE_NORMAL
- en: In the following, we provide an overview of popular deployment targets for Remix.
    *Table 3.1* lists templates that are maintained by the Remix team and community
    or by hosting provider companies. If a template is not set up for a specific hosting
    provider, then the **Hosting provider** column will show **Generic**.
  prefs: []
  type: TYPE_NORMAL
- en: 'All referenced templates are also listed in the Remix documentation: [https://remix.run/docs/en/dev/other-api/adapter](https://remix.run/docs/en/dev/other-api/adapter).
    Additionally, you can find all templates maintained by the Remix team on GitHub
    in the Remix repository: [https://github.com/remix-run/remix/tree/main/templates](https://github.com/remix-run/remix/tree/main/templates).'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Deployment target** | **Hosting provider** | **JavaScript runtime** | **Hosting
    environment** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Architect (Arc) | AWS | Node.js | Serverless |'
  prefs: []
  type: TYPE_TB
- en: '| Cloudflare Pages | Cloudflare | **Workers runtime** | Edge **Isolate** |'
  prefs: []
  type: TYPE_TB
- en: '| Cloudflare Workers | Cloudflare | **Workers runtime** | Edge **Isolate**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Deno | **Generic** | Deno | Edge **Isolate** |'
  prefs: []
  type: TYPE_TB
- en: '| Express.js | **Generic** | Node.js | Server |'
  prefs: []
  type: TYPE_TB
- en: '| Fastify | **Generic** | Node.js | Server |'
  prefs: []
  type: TYPE_TB
- en: '| Fastly Compute@Edge | Fastly | Wasmtime | Edge **Isolate** |'
  prefs: []
  type: TYPE_TB
- en: '| Fly.io | Fly.io | Node.js | **Distributed Server** |'
  prefs: []
  type: TYPE_TB
- en: '| Netlify | Netlify | Node.js | Serverless |'
  prefs: []
  type: TYPE_TB
- en: '| Remix App Server | **Generic** | Node.js | Server |'
  prefs: []
  type: TYPE_TB
- en: '| Vercel | Vercel | Node.js | Serverless |'
  prefs: []
  type: TYPE_TB
- en: Table 3.1 – Remix’s deployment targets
  prefs: []
  type: TYPE_NORMAL
- en: As visible in the preceding table, many of the deployment targets are tied to
    specific hosting providers. The great thing about hosting service-specific adapters
    is the ease of deployment. You will find that you can get up and running with
    most of these services in a matter of minutes.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of generic adapters is the additional flexibility. For example,
    selecting the Express.js deployment target creates an Express.js server that can
    be hosted anywhere where Node.js server can run. This includes cloud computing
    platforms such as AWS, Azure, and Google Cloud Platform and popular hosting platforms
    such as Railway.app and Render.com.
  prefs: []
  type: TYPE_NORMAL
- en: Note that *Table 3.1* is incomplete, as the number of available deployment targets,
    templates, and adapters changes over time. The goal of this chapter is to help
    you effectively pick a deployment target by learning how to categorize and characterize
    them. First, let’s see what is different between the various JavaScript runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: Picking a JavaScript runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript can be executed in different runtime environments. In this section,
    we list popular JavaScript runtimes and discuss what to consider when selecting
    a runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some popular JavaScript runtime environments are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Browser environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deno
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Workers runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bun
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The browser is JavaScript’s most native environment. However, different browsers
    use different engines to execute JavaScript. Hence, they are technically different
    runtime environments. Luckily, they mostly adhere to the Open Web Platform and
    support the standard JavaScript APIs and runtime behavior. Since we are trying
    to pick a server-side deployment target, we are currently more interested in server-side
    runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: The most prominent server-side runtime for JavaScript is Node.js. Node.js has
    a rich ecosystem of packages and libraries and is widely used and supported. However,
    there are also other server-side JavaScript runtimes, such as Bun, Deno, and Cloudflare’s
    Workers runtime (workerd).
  prefs: []
  type: TYPE_NORMAL
- en: As visible in *Table 3.1*, some deployment targets use Deno or workerd under
    the hood. It is important to understand what this entails for your application
    development. If you are interested in starting a project with Deno or workerd,
    make sure to first familiarize yourself with the underlying runtime.
  prefs: []
  type: TYPE_NORMAL
- en: When comparing JavaScript runtimes, we must ensure they support the APIs and
    functionality we require for our application. For instance, workerd is an edge
    runtime that powers Cloudflare Workers. workerd does not support the execution
    of Node.js standard libraries. Consequently, you can use npm packages only if
    these packages do not use Node.js standard libraries. In contrast, most Node.js
    packages work in Deno as Deno aims to be Node.js compatible. You will also be
    able to use most Node.js standard libraries in Deno. However, this requires a
    special import syntax.
  prefs: []
  type: TYPE_NORMAL
- en: As a Remix developer, it is important to understand that some deployment targets
    are based on different JavaScript runtimes than Node.js. Each runtime comes with
    limitations and considerations. Next, we will investigate the differences between
    different hosting environments.
  prefs: []
  type: TYPE_NORMAL
- en: Picking a hosting environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way we host web applications has changed over time. Deploying can be as
    easy as pointing to a GitHub repository and branch or providing a Docker image.
    We rarely manage the underlying server infrastructure ourselves anymore. Instead,
    hosting providers and cloud platforms manage the infrastructure for us and provide
    the environment for our applications to run in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cloud platforms and hosting providers offer different hosting environments.
    These provide various advantages and disadvantages. As visible in *Table 3.1*,
    the different deployment targets each fit into one of the following three hosting
    environment categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serverless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see how the three different hosting environments differ. The following
    table provides an overview of the most important differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Trait** | **Server** | **Serverless** | **Edge** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Long-running | Yes | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| Filesystem access | Yes (depends) | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| Isolated requests | No | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Scale by default | No | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Distributed by default | No | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: Table 3.2 – Traits of different hosting environments
  prefs: []
  type: TYPE_NORMAL
- en: Web servers are considered long-running environments. A web server is usually
    started once and only stops running in case of an upgrade, re-deployment, or when
    the service is sunset. Depending on the hosting provider, web servers have access
    to the filesystem. Long-running servers do not isolate individual requests. This
    means requests share global application states.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless environments are fundamentally different from long-running servers.
    Serverless is a cloud computing model in which an application is treated as a
    function and orchestrated by the cloud platform provider. A serverless function
    is started specifically for an incoming request. After a designated timeout, the
    serverless function is terminated, and any application context, such as closures,
    cached application state, and global variables, is lost.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless environments usually offer pay-per-use pricing. We are only charged
    for the time when our function is handling requests. Since the infrastructure
    provider can spawn multiple duplicate serverless functions in parallel, serverless
    is also inherently highly scalable.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that serverless environments come with a very different
    set of requirements than web servers. Some things that are easily solved on long-running
    servers require more involvement on serverless. However, the solutions provided
    by serverless are designed to be scalable.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, web servers create database connections during startup and share
    these connections across all incoming requests. Serverless functions must create
    a new database connection for every incoming request. Creating a new database
    connection can become a bottleneck for incoming requests and may lead to delays
    or timeouts. Additionally, database servers only support a limited number of open
    connections at a time. Opening a new connection per serverless function may exceed
    the maximum number of connections.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless offers connection pooling as one way to counteract these issues.
    Connection pooling allows different functions to share connections across different
    instances. This is a common pattern with serverless. Things that work with long-running
    servers require more consideration with serverless. Serverless is designed to
    scale, but scaling also introduces complexity as a byproduct.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling inevitably introduces complexity. Once you need to think about scaling
    long-running servers, you may run into many problems that serverless already solves
    for you. For instance, serverless environments implement load balancing out of
    the box.
  prefs: []
  type: TYPE_NORMAL
- en: Where serverless focus lies on scalability, edge computing focuses on providing
    geographic proximity. Most edge environments are serverless and share the same
    advantages, such as scalability and pay-per-use pricing. What makes edge environments
    special is their proximity to the end users. Edge functions are regionally distributed
    – for instance, on the servers of a CDN. The created proximity can significantly
    decrease response times.
  prefs: []
  type: TYPE_NORMAL
- en: Most server and serverless environments do not automatically distribute your
    application across different regions, at least not without additional configuration
    overhead and additional costs. Edge computing allows you to distribute your web
    application across the globe out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Edge environments come with their own limitations and considerations. In general,
    edge functions are the most limiting regarding their runtime capabilities. One
    limitation is that deploying on the edge requires a distributed database solution.
    Otherwise, response times will be delayed by the communication between the edge
    functions and your database server.
  prefs: []
  type: TYPE_NORMAL
- en: Different runtime environments also use different container technologies to
    deploy and run your code. Long-running servers can run directly on a physical
    or virtual machine. However, most cloud providers use lightweight container technologies
    to run your app. It's important to note that the container landscape is diverse.
    There are several different container technologies and standards, such as V8 isolates.
  prefs: []
  type: TYPE_NORMAL
- en: V8 is the JavaScript engine that powers Chrome and is also used by Node.js and
    Deno. V8 isolates are isolated V8 instances that reuse the same language runtime,
    avoiding the slow cold start of starting a new language runtime on an incoming
    request. Because they're lighter than most container technologies, V8 isolates
    are used in edge environments where computing is sparse in comparison to centralized
    cloud data centers.
  prefs: []
  type: TYPE_NORMAL
- en: When choosing a hosting provider and runtime, research the restrictions tied
    to their container technologies. These limitations could affect your app’s size
    or the maximum running time before timing out.
  prefs: []
  type: TYPE_NORMAL
- en: There are many trade-offs to consider. Each environment comes with its own set
    of considerations. Next, we will connect the dots and conclude how to select the
    right deployment target for a given use case.
  prefs: []
  type: TYPE_NORMAL
- en: Making the final decision
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will conclude how to pick a deployment target based on what
    we learned about JavaScript runtimes and different hosting environments (server,
    serverless, edge).
  prefs: []
  type: TYPE_NORMAL
- en: In my experience, a long-running server environment provides a great amount
    of flexibility and introduces less complexity than its alternatives. That said,
    hosting providers such as Netlify and Vercel offer a great developer experience
    and complementary services for their serverless and edge offerings. If you are
    looking for a provider that can regionally distribute both your long-running web
    server and database, then maybe Fly.io could be a great fit.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless provides many advantages but also introduces complexity. Edge computing
    may significantly improve response times but introduces further complexity. The
    additional complexity of serverless and edge environments is a byproduct of scale
    and regional distribution. Once you think about scale and regional distribution
    for your long-running web server, you will face similar challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, picking the right deployment target is more about avoiding unnecessary
    obstacles than anything else. The deployment target must fit the use case and
    fulfill the system requirements. Let’s go over some examples.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to utilize Node.js libraries or reuse Node.js code, you probably
    want to stick with a Node-based environment. The Express.js deployment target
    is an obvious choice. But what about serverless environments? If you use a conventional
    database without built-in solutions for serverless environments, then you will
    have to create a new database connection for every new incoming request. This
    might lead to longer response times or even timeouts. However, if you are already
    using a serverless-first database and are looking for scalability, then picking
    a serverless environment might be a great idea.
  prefs: []
  type: TYPE_NORMAL
- en: If you have one single database server in Oregon, then having your web app deployed
    all over the world won’t bring you much benefit. Each instance of your app will
    have to request data from your database server in Oregon. In that case, you should
    pick a web server or serverless environment that is located as close as possible
    to your database.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to build a blog you are likely looking for easy access to your blog
    posts. Blog posts are usually stored as files. Using a hosting provider and enviroment
    that lets you access the filesystem allows you to host your blog posts together
    with your code. Unless you run into issues with this approach (there are disadvantages
    to any approach), you might want to start with a simple web server architecture.
    In that case, you could pick the Express.js template. This will grant you access
    to the underlying filesystem with most hosting providers.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, you might find that some serverless providers offer attractive
    free tiers and competitive pay-as-you-go pricing. Selecting the right runtime
    depends on your priorities and requirements. Picking a hosting environment without
    access to the filesystem doesn’t mean that you won’t be able to work with files.
    It just means you must store files somewhere else – such as in a file storage
    service. Therefore, it’s more about making an informed decision to avoid obstacles
    down the road.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, deciding on a deployment target also means deciding on a hosting provider.
    Each deployment provider comes with its own advantages and disadvantages. For
    instance, Fly.io hosts long-running Node.js servers but offers distribution to
    different regions. Fly.io might be a great alternative to serverless edge deployment.
    On the other hand, AWS and Cloudflare each provide rich ecosystems of services
    that can be used together with their serverless and edge offerings. For complex
    applications, hosting on AWS or Cloudflare might be the right call.
  prefs: []
  type: TYPE_NORMAL
- en: The line between long-running servers, serverless, and edge environments is
    blurry. Different providers further offer geographical distribution for both serverless
    and server environments that achieve edge-like proximity to users. Some may provide
    the best of both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: Picking a deployment target heavily depends on your application’s use case.
    Luckily, Remix is flexible enough to support a wide variety of different use cases.
    After all, Remix can run anywhere where JavaScript can be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, it is straightforward to swap the underlying server environment
    and adapter in your Remix project if needed. In the next section, we will practice
    how to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Switching between adapters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We sometimes have to migrate from one template to another one. To do so, we
    must switch our Remix app’s setup. In this chapter, we will walk through the process
    of switching templates and adapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of switching between templates and adapters can be summarized as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate your Remix project and open it in an editor or file explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Remix project using the new template and adapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the new Remix project side by side with your old project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the `app` folder in the new project to `temp`. Move the `app` folder
    from your old project to the new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the code in `app/entry.client.tsx` with the code in `temp/entry.client.tsx`
    and integrate any custom code previously added to the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the code in `app/entry.server.tsx` with the code in `temp/entry.server.tsx`
    and integrate any custom code previously added to the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For every Remix-specific file and folder in the root of your old project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Investigate whether you made any changes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy-paste any changes over to the new project.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Resolve any conflicts (if any).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the instructions in the new project’s `README.md` file to run, build,
    and deploy the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Troubleshoot any remaining issues using the troubleshooting process from [*Chapter
    2*](B17399_02.xhtml#_idTextAnchor030), *Creating a New* *Remix App*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s practice the described process using the "Hello World!" Remix app that
    we created in [*Chapter 2*](B17399_02.xhtml#_idTextAnchor030), *Creating a New
    Remix App*. If you are looking for a challenge, see whether you can figure it
    out by yourself by following the nine steps listed before. Otherwise, let’s walk
    through it together:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your “Hello World!” Remix app in an editor or file explorer. You can also
    find the code here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/02-creating-a-new-remix-app/hello-world](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/02-creating-a-new-remix-app/hello-world).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B17399_02.xhtml#_idTextAnchor030), we used the basic template,
    but this process works for other templates as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run `npm install` and `npm run dev` to ensure that the project is running locally
    without any issues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create a new Remix project using the `create-remix` CLI script. Run the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After finishing the `create-remix` CLI script, we run `npm install` and `npm
    run dev` to ensure that the new project runs locally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After asserting that both projects run without errors, we open the new Remix
    app in an editor or file explorer. It is easiest to have both editors/file explorers
    open side by side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s rename the `app` folder in the new project to `temp`. Next, copy the `app`
    folder from your old “Hello World!” project to the new project. This allows us
    to inspect both `temp` and `app` side by side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run `npm run dev` in the new project. Remix will attempt to build and run the
    project using the “Hello World!” `app` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compare the code in `app/entry.server.tsx` with the code in `temp/entry.server.tsx`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Express.js template used in the “Hello World!” app uses Remix’s node adapter
    (`@remix-run/node`), while the Cloudflare Worker template uses the `@``remix-run/cloudflare`
    adapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Cloudflare Workers environment runs on workerd, which does not support Node.js
    libraries. To run on Node.js and workerd, Remix needs to set up two different
    entry point implementations and use different adapters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since we have no custom code in `entry.server.tsx`, replace the code in `app/entry.server.tsx`
    with the code in `temp/entry.server.tsx`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sure there is no other usage of `@remix-run/node`. Search for the package name
    in your editor’s code search.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should find two matches: `app/root.tsx` and `app/routes/_index.tsx`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Make sure to find and replace the imports with `@remix-run/cloudflare`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remix exposes its server-side types and primitives through the different adapter
    packages. When switching adapters, we must find and replace all imports of the
    old adapter with the new one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, compare and then replace the code in `app/entry.client.tsx` with the code
    in `temp/entry.client.tsx` as well. Different templates may use different versions
    of React or implement additional logic in the client entry file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `npm run dev` again. It should now successfully build and run the new project!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s investigate the root folder of the old application. Are there any files
    that we did create or adapt? We should move all custom files and folders over
    to the new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the `package.json` file. We did not install any additional packages for
    our “Hello World!” app, but usually, we would now move any app dependencies over
    and install them in our new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should also compare the scripts of both `package.json` files. We have to
    make sure that any custom or adapted scripts are merged with the new scripts of
    our new project. In our case, there is nothing to do. We did not add any custom
    logic, which we would need to take over.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We did it! We moved from **Remix App Server** to **Cloudflare Workers** – a
    long-running server to an edge environment!
  prefs: []
  type: TYPE_NORMAL
- en: The two entry files in the `app` folder are bootstrapped by Remix and custom
    for each deployment target. Hence, we must make sure to update the code in these
    files. We also must merge our custom dependencies with the dependencies of the
    new project. This requires us to manually review the `package.json` files. Finally,
    we have to take over any other changes made to files and folders in the project.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we successfully moved from one adapter to another. In the next
    section, we will learn about Remix Stacks to bootstrap a production-ready Remix
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Using Remix Stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn about Remix Stacks. First, we will have a look
    at Remix’s official stacks and how to use them. Next, you will learn how to use
    community templates.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Remix official stacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remix also offers pre-configured templates ready for production. These templates
    are referred to as Remix Stacks. As of now, Remix provides three official stacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Stack** | **Deployment target** | **Comes with** | **Use case** |'
  prefs: []
  type: TYPE_TB
- en: '| Blues | Fly.io | PostgreSQL database | Large-scale applications and regional
    distribution |'
  prefs: []
  type: TYPE_TB
- en: '| Indie | Express.js | SQLite database | Small-scale projects with dynamic
    data |'
  prefs: []
  type: TYPE_TB
- en: '| Grunge | Architect (AWS Lambda) | DynamoDB database | Large-scale applications
    on AWS infrastructure |'
  prefs: []
  type: TYPE_TB
- en: Table 3.3 – Official Remix stacks
  prefs: []
  type: TYPE_NORMAL
- en: Stacks are opinionated project starters. They are more complex than Remix’s
    basic templates but also have more features. As visible in *Table 3.3*, the starters
    are built with different use cases in mind and utilize different deployment targets.
  prefs: []
  type: TYPE_NORMAL
- en: The **Blues stack** runs on Fly.io. From *Table 3.1*, you can infer that Fly.io
    hosts long-running servers. Fly.io offers regional distribution of long-running
    servers to achieve edge-like proximity. The Blues stack also ships with code to
    set up a PostgreSQL database. The stack is designed to scale and enable regional
    distribution out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: The **Indie stack** uses the Express.js adapter and does not target a specific
    hosting provider. It ships with an SQLite database. The Indie stack is perfect
    for starting projects that work with smaller amounts of dynamic data. From *Table
    3.2*, you can infer that this stack – depending on the hosting provider – can
    access the filesystem and will be able to share application states across different
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: The **Grunge stack** serves similar use cases to the Blues stack but is set
    up using Architect, an AWS Lambda-based framework. From *Table 3.1*, you can derive
    that Architect runs on a serverless environment. AWS infrastructure is intended
    to support large-scale applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try out one of the Remix Stacks Run the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We again use `create-remix` to bootstrap a new Remix app. This time, we refer
    to one of Remix’s three official stack templates: the Indie stack. Feel free to
    select another stack based on your personal preferences.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we point to a GitHub repository named `indie-stack` in the `@remix-run`
    GitHub organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Investigate the bootstrapped folder structure and refer to the `README.md`
    file to get an overview of all the technologies and packages in use. A few noteworthy
    things come with the Indie stack:'
  prefs: []
  type: TYPE_NORMAL
- en: A registration and login setup (`app/session.server.ts`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A convention for where to place your database logic (`app/models/`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A route for health checks (`app/routes/healthcheck.tsx`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remix Stacks implement styling, testing, authentication, and additional features
    out of the box. Where Remix’s basic templates provide simple server and adapter
    setups, Remix Stacks are production-ready applications that ship with an opinionated
    setup. On top of that, Remix also supports the creation of custom templates. In
    the next section, we will learn how to use and create custom templates.
  prefs: []
  type: TYPE_NORMAL
- en: Working with custom templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can utilize community-developed templates or create our own to get up and
    running quickly with our preferred stack. Custom templates are also a great way
    to develop opinionated templates for an organization.
  prefs: []
  type: TYPE_NORMAL
- en: Any Remix project can be used as a template. The only limitation is that the
    template must be a valid Remix project with a `package.json` file in the root
    folder. The easiest way to access a template is via GitHub, but Remix can also
    access a template via a URL, a local path on your machine, a subfolder in a GitHub
    repository, or a local or remote tarball.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try out the custom template from this book’s GitHub repository. Run the
    `create-remix` command with the template flag in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Make sure to select `remix.init` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the `init` script, you should see a short message in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This message originates from the `remix.init/index.js` script in the project’s
    root folder. The script allows template authors to implement custom setup steps.
    You can also run the script again by calling `npx remix init` in the project root.
  prefs: []
  type: TYPE_NORMAL
- en: Conveniently, I just sneaked you into setting up the BeeRich application, which
    will be used as a demo application for the rest of this book. Next, we will kick
    off our development journey with BeeRich.
  prefs: []
  type: TYPE_NORMAL
- en: Working with BeeRich
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to BeeRich! BeeRich is a dashboard-like application that mimics both
    personal and enterprise use cases. BeeRich is a personal finance management application
    that helps you stay on top of your bee – pardon me – bookkeeping. Well, at least
    that’s the goal. There is nothing much there yet. In every chapter, we will add
    more code to this application. In this section, we will run BeeRich locally and
    review the folder structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We bootstrapped BeeRich in the preceding section using the `create-remix` script.
    BeeRich is nothing more than a simple skeleton application on top of Remix’s Express.js
    template that we tried out in [*Chapter 2*](B17399_02.xhtml#_idTextAnchor030),
    *Creating a New Remix App*. You can also find the BeeRich Remix template in this
    book’s GitHub repository: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run BeeRich locally. Open the terminal and navigate to the project''s
    root folder. Then execute the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The application should now be running on port `3000`: `http://localhost:3000/`.
    Welcome to BeeRich!'
  prefs: []
  type: TYPE_NORMAL
- en: The `npm run dev` command starts Remix's development server to build and watch
    the development environment. You can find a list of all available scripts in the
    `package.json` file. Also, review the `README.md` file in the root of the BeeRich
    project for additional information about BeeRich.
  prefs: []
  type: TYPE_NORMAL
- en: Tailwind CSS has been included so we can quickly add some styling without the
    need to leave our JavaScript modules. You can also find some styled reusable components
    in `app/components`. Visit the `/demo` route to inspect some of the reusable components
    ([http://localhost:3000/demo](http://localhost:3000/demo)).
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to deviate from the lessons in this book and explore alternative solutions.
    If you get stuck, you can always reset your application and use the application
    in the current chapter’s folder on GitHub as a baseline.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will add pages and routes to BeeRich.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned what to consider when selecting a deployment target
    for your Remix application. You learned more about different hosting providers,
    environments, and runtimes. You now understand that Remix runs on long-running
    servers, serverless environments, and edge runtimes. Each environment has advantages
    and disadvantages that you must consider when selecting a template and deployment
    target.
  prefs: []
  type: TYPE_NORMAL
- en: Remix’s different deployment targets operate on different JavaScript runtimes,
    such as Node.js, workerd, and Deno. Different JavaScript runtimes support different
    web standards and either support or do not support Node.js standard libraries.
    When picking a template, you must consider what JavaScript runtime you want to
    work with.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces you to a nine-step process to migrate from one adapter
    to another. Switching out adapters enables you to try out different hosting providers
    and environments and to stay agile in case your requirements change over time.
  prefs: []
  type: TYPE_NORMAL
- en: Remix offers basic templates for different deployment targets that set up Remix’s
    adapters. However, Remix also offers production-ready stacks. In this chapter,
    you practiced using the `create-remix` script to bootstrap a new Remix app using
    Remix’s Indie Stack.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we utilized a custom template to bootstrap the demo application, BeeRich,
    which we will use in the following chapters to practice our Remix skills. In the
    next chapter, we will learn about routing in Remix and add pages to BeeRich.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find a list of available adapters in the Remix documentation: [https://remix.run/docs/en/2/other-api/adapter](https://remix.run/docs/en/2/other-api/adapter).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Remix documentation also provides more explanations about available templates
    here: [https://remix.run/docs/en/2/discussion/runtimes](https://remix.run/docs/en/2/discussion/runtimes).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The official announcement post for Remix stacks can be found here: [https://remix.run/blog/remix-stacks](https://remix.run/blog/remix-stacks).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listen to Wes Bos and Scott Tolinski talk about the limitations of serverless
    on Syntax.fm: [https://syntax.fm/show/542/serverless-limitations](https://syntax.fm/show/542/serverless-limitations).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Learn more about the distinction between serverless computing and containers
    here: [https://www.cloudflare.com/learning/serverless/serverless-vs-containers/](https://www.cloudflare.com/en-gb/learning/serverless/serverless-vs-containers/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information about V8 isolates here: [https://developers.cloudflare.com/workers/learning/how-workers-works/#isolates](https://developers.cloudflare.com/workers/learning/how-workers-works/#isolates).'
  prefs: []
  type: TYPE_NORMAL
