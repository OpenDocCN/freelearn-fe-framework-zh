- en: 1\. Starting Your First Vue Project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 开始你的第一个Vue项目
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn the key concepts of Vue.js and why you should
    consider Vue.js for your next project. You will learn how to run Vue projects
    from the command line; describe the Vue.js project architecture; create Vue single
    file components using various styling and HTML syntax flavors; and also write
    Vue methods and data objects and control HTML templates competently.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习Vue.js的关键概念以及为什么你应该考虑Vue.js作为你的下一个项目。你将学习如何从命令行运行Vue项目；描述Vue.js项目的架构；使用各种样式和HTML语法风格创建Vue单文件组件；并且能够熟练地编写Vue方法和数据对象以及控制HTML模板。
- en: By the end of this first chapter, you will be able to describe the basics of
    Vue lifecycle hooks and expressions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够描述Vue生命周期钩子和表达式的基础知识。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Developers in the industry are required to resolve frontend development problems
    quickly with minimal impact on existing workflows or backend architecture. In
    many cases, the UI is overlooked completely until the end of a project, which
    can happen because of a lack of resources, ever-evolving product requirements,
    or the existing attitude that the frontend is the easy bit. However, companies
    such as Apple and Google have proven that design thinking on the frontend is key
    to a solid product or platform that will excite and engage users leading to a
    higher return on investment and a more successful business.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 行业中的开发者需要快速解决前端开发问题，同时尽量减少对现有工作流程或后端架构的影响。在许多情况下，UI直到项目结束时才被完全忽视，这可能是由于资源不足、不断变化的产品需求或现有的前端是简单部分的态度。然而，像苹果和谷歌这样的公司已经证明，前端的设计思维对于打造一个能够激发和吸引用户、带来更高投资回报和更成功业务的产品或平台至关重要。
- en: If you have found Vue.js, you may have also come across other frontend frameworks
    that, at face value, solve the same problems such as Ember, Angular, or React.
    At the surface level, they all attempt to make reactive frontend development more
    reliable and introduce patterns that make this easier to do. However, there are
    some critical differences in how a Vue project might play out compared to an Angular
    or React project. Let's look into them.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经发现了Vue.js，你可能也遇到了其他前端框架，如Ember、Angular或React，它们表面上似乎解决了相同的问题。在表面层面上，它们都试图使响应式前端开发更加可靠，并引入使这更容易做的模式。然而，与Angular或React项目相比，Vue项目可能会有一些关键的不同之处。让我们来看看它们。
- en: Angular versus Vue
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular与Vue的比较
- en: Angular is a **Model-View-ViewModel** (**MVVM**) framework built by Google that,
    generally, enterprise companies in the past tended to favor because of Google's
    backing and the fact that from the ground up, Angular was created to be used alongside
    TypeScript. The ecosystem supporting Angular includes **Ahead of Time** (**AoT**)
    rendering, and router and CLI management, but fails to deliver a simplified global
    state management system; developers would need to learn and use **Flux** or adopt
    **NgRx**. Vue takes Angular's core ideas of robustness and reliability and improves
    the development experience with its agnostic approach to development by removing
    the restrictiveness of an enforced code style for developers. Simplifying familiar
    Angular patterns such as HTML directives and dependency injection for modularity
    with Vue's single-file component system benefits developers by removing the necessity
    to learn and remember a variety of structures (injectables, components, pipes,
    modules, and so on). Vue has excellent support for TypeScript and typing without
    the drawbacks that Angular can have with its enforced coding language and development
    style. React and Vue share a focus on component-driven development, which reduces
    the amount of time and effort needed to uptake a new framework.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是由谷歌构建的**模型-视图-视图模型**（**MVVM**）框架，过去，由于谷歌的支持以及Angular从一开始就是为与TypeScript一起使用而创建的事实，因此，企业公司通常更倾向于选择Angular。支持Angular的生态系统包括**预编译**（**AoT**）渲染、路由和CLI管理，但未能提供简化的全局状态管理系统；开发者需要学习和使用**Flux**或采用**NgRx**。Vue采用了Angular的稳健性和可靠性核心思想，并通过其无差别的开发方法改善了开发体验，通过移除对开发者强制执行的代码风格限制。通过Vue的单文件组件系统简化了熟悉的Angular模式，如HTML指令和依赖注入，以实现模块化，这使开发者受益于无需学习和记住各种结构（注入器、组件、管道、模块等）。Vue对TypeScript和类型支持出色，且没有Angular可能具有的强制编码语言和开发风格的缺点。React和Vue都专注于组件驱动开发，这减少了学习新框架所需的时间和精力。
- en: React versus Vue
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React与Vue的比较
- en: The driving force behind React's popularity and large development community
    is attributed to Facebook's dedicated engineers and its 2013 open source release
    at a time when Angular 2+ was nowhere to be seen. React's JSX pattern (a way of
    writing HTML and CSS in JavaScript) introduces with it a heightened learning curve
    for new developers who are both required to learn another language and also wrap
    their heads around component-based architecture. Components allow developers to
    build applications in a modular way; individual components describe their own
    piece of functionality and lifecycle, where they can be instantiated when they
    are required and destroyed when they are not used. Vue takes these core concepts
    of modular coding and enables developers to build these components using either
    JSX or writing HTML, CSS, and JavaScript as you would a traditional web application
    in a single file. Vue's separation of concerns in a single-file component simplifies
    this modular structure for developers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: React的流行和庞大的开发者社区背后的动力归功于Facebook的专职工程师以及它在2013年开源发布，当时Angular 2+还无处可寻。React的JSX模式（一种在JavaScript中编写HTML和CSS的方式）为新手开发者带来了更高的学习曲线，他们不仅需要学习另一种语言，还需要理解基于组件的架构。组件允许开发者以模块化的方式构建应用程序；单个组件描述其自己的功能部分和生命周期，当需要时可以实例化，当不再使用时可以销毁。Vue将这些模块化编码的核心概念结合起来，使开发者能够使用JSX或像传统单文件Web应用程序一样编写HTML、CSS和JavaScript来构建这些组件。Vue在单文件组件中的关注点分离简化了开发者的模块化结构。
- en: Advantages of Using Vue for Your Project
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Vue进行项目的优势
- en: Vue has a gentle learning curve and a vibrant ecosystem. This benefits teams
    of any size by not requiring a huge amount of overhead to educate teams of developers
    on how to use the Vue.js framework.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Vue的学习曲线平缓，生态系统活跃。这使任何规模的团队能够受益，因为它不需要大量的开销来教育开发者如何使用Vue.js框架。
- en: Vue.js is another example of a pattern in development that is easy to learn
    but hard to master. A key benefit of Vue is its *approachability for both new
    and veteran developers*.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue.js是开发中一个易于学习但难以掌握的模式的另一个例子。Vue的一个关键优势是其对新老开发者都**易于接近**。
- en: Out of the box, developers can use a *well-optimized* and performant framework
    on which to build dynamic frontend applications of any size.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开箱即用，开发者可以使用一个**优化良好且性能出色**的框架来构建任何规模的动态前端应用程序。
- en: The **single-file component (SFC)** pattern offers a modular and flexible blueprint
    to simplify the development process and provides an *enjoyable experience* for
    developers of all levels, bringing order to component chaos. Single-file components
    allow Vue to be genuinely *versatile*, where you can implement basic functionality
    and incrementally adopt pieces of a static site into Vue rather than overhauling
    your entire website.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单文件组件（SFC）**模式提供了一个模块化和灵活的蓝图，简化了开发过程，并为所有级别的开发者提供了**愉快的体验**，为组件混乱带来了秩序。单文件组件使Vue真正**多功能**，你可以实现基本功能，并逐步将静态站点的部分内容集成到Vue中，而不是彻底改造整个网站。'
- en: Official global state management support should come as a relief to any developer
    who is familiar with the **Redux** and **NgRx** patterns. As powerful as these
    libraries can be when used well, **Vuex** is a great middle-ground for creating
    *robust global state patterns* that are flexible to meet most development needs.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于熟悉**Redux**和**NgRx**模式的任何开发者来说，官方的全局状态管理支持应该是一种安慰。尽管这些库在正确使用时非常强大，但**Vuex**是创建**健壮的全局状态模式**的绝佳中间方案，这些模式具有灵活性，可以满足大多数开发需求。
- en: For those developers who are looking to get off the ground quickly, do not reinvent
    the wheel by building a custom reactive pattern unless individual use cases require
    it. You can save time and money by using Vue as a framework because it is already
    performant and officially supports libraries that are necessary to build an end-to-end
    app, which include `vue-router`, Vuex state management, dev tools, and more.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些希望快速上手的开发者来说，除非个别用例确实需要，否则不要重新发明轮子，构建自定义的响应式模式。你可以通过使用Vue作为框架来节省时间和金钱，因为它已经性能出色，并且官方支持构建端到端应用程序所需的库，包括`vue-router`、Vuex状态管理、开发工具等。
- en: In this chapter, we will start by introducing the Vue architecture before familiarizing
    you with Vue's unique SFC pattern and HTML template syntax sugar. You will learn
    how to work with the Vue-specific template syntax and coding patterns that include
    Vue bindings, directives, lifecycle hooks, scopes, and the local state. Out of
    the Vue ecosystem of official plugins, we will primarily be focusing on the core
    Vue libraries. First, let's look at Vue's project architecture.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先介绍Vue架构，然后让你熟悉Vue独特的SFC模式和HTML模板语法糖。你将学习如何使用Vue特定的模板语法和编码模式，包括Vue绑定、指令、生命周期钩子、作用域和局部状态。在Vue官方插件生态系统中，我们将主要关注核心Vue库。首先，让我们看看Vue的项目架构。
- en: The Vue Instance in a Simple Vue Application
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单Vue应用中的Vue实例
- en: 'One of the easiest ways to get started with Vue is to import the Vue package
    through a `Vue` function. Each Vue application consists of one root Vue instance
    that is created using the `new Vue` function. All corresponding Vue components
    that are created are also defined using the same syntax, however, are considered
    as nested Vue instances that can contain their own options and properties:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用Vue的一种最简单的方法是通过`Vue`函数导入Vue包。每个Vue应用都由一个根Vue实例组成，该实例是通过`new Vue`函数创建的。所有创建的相应Vue组件也使用相同的语法定义，然而，它们被视为嵌套Vue实例，可以包含它们自己的选项和属性：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`vm` is a term commonly used to refer to a `vm` helps you to keep track of
    your Vue instance in a block of code.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`vm`是一个常用术语，用来指代`vm`，它可以帮助你在代码块中跟踪你的Vue实例。'
- en: 'In this example, we import Vue using the `jsdelivr` CDN, which will allow you
    to utilize the Vue functions:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`jsdelivr` CDN导入Vue，这将允许你使用Vue函数：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Declare an element in the `<body>` tag using a class, ID, or data attribute.
    Vue is known for its ability to declaratively render data to the DOM using simple
    template syntax such as double curly braces to specify reactive content, for example,
    `{{ text }}`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类、ID或数据属性在`<body>`标签中声明一个元素。Vue因其能够使用简单的模板语法（如双大括号）声明性地将数据渲染到DOM中而闻名，例如，`{{
    text }}`：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `<head>` tag, we see some vanilla JavaScript code that fires off when
    the DOM loads. This constructs a Vue component bound to the element with `class
    .reactive-text`. The data property labeled `text` will replace the curly brace
    placeholder with the string defined as `Start using Vue.js today!`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<head>`标签中，我们看到一些在DOM加载时触发的原生JavaScript代码。它构建了一个与带有`class .reactive-text`的元素绑定的Vue组件。标记为`text`的数据属性将替换大括号占位符，并用字符串`Start
    using Vue.js today!`定义：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding script, you bind the `<p>` element with the `reactive-text`
    class to the new Vue instance. So, now that Vue understands this HTML element
    you can use the `{{ text }}` syntax to output the data property `text` inside
    of the `<p>` element.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的脚本中，你将带有`reactive-text`类的`<p>`元素绑定到新的Vue实例。因此，现在Vue理解了这个HTML元素，你可以使用`{{
    text }}`语法在`<p>`元素内部输出数据属性`text`。
- en: 'The output of the preceding code will be as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出将如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'While a CDN is a very portable way to start including Vue.js in your projects,
    using package managers is the recommended installation method for Vue, which is
    compiled by webpack, because it allows you to control third-party library versions
    easily. You can access it here: [https://vuejs.org/v2/guide/installation.html](https://vuejs.org/v2/guide/installation.html).
    We will explore what a webpack example looks like next.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然CDN是一种非常便携的方式来开始在你的项目中包含Vue.js，但使用包管理器是Vue推荐的安装方法，因为Vue是通过webpack编译的，这允许你轻松控制第三方库版本。你可以在这里访问它：[https://vuejs.org/v2/guide/installation.html](https://vuejs.org/v2/guide/installation.html)。接下来，我们将探索webpack示例的样子。
- en: A Webpack Vue Application
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Webpack Vue应用
- en: 'Vue projects are structured similarly to a lot of modern node-based apps that
    contain a `package.json` file and a `node_modules` folder in the root of your
    project. Various other configuration files are usually contained at the root level,
    such as `babel.config.js` and `.eslintrc.js`, since they will generally have an
    effect across your whole project. The following screenshot displays a default
    Vue app folder structure:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Vue项目结构与许多现代基于node的应用类似，这些应用在项目的根目录下包含一个`package.json`文件和一个`node_modules`文件夹。通常，其他配置文件也位于根目录级别，例如`babel.config.js`和`.eslintrc.js`，因为它们通常会对整个项目产生影响。以下截图显示了默认的Vue应用文件夹结构：
- en: '![Figure 1.1: Default Vue application folder structure'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1：默认Vue应用文件夹结构]'
- en: '](img/B15218_01_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15218_01_01.jpg]'
- en: 'Figure 1.1: Default Vue application folder structure'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：默认Vue应用程序文件夹结构
- en: 'The Vue project structure follows a pattern where most of your source code
    is managed within the `/src` directory. You can subdivide your Vue files into
    various folders, for example, using a `components` folder to store reusable Vue
    components. By default, Vue will create assets and a `components` folder to code
    split the default files. For beginners, it is good to follow this pattern until
    you get more comfortable with splitting up your code in ways that make sense for
    your application:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Vue项目结构遵循一种模式，其中大部分源代码都管理在`/src`目录中。你可以将Vue文件细分为各种文件夹，例如，使用`components`文件夹来存储可复用的Vue组件。默认情况下，Vue将创建资产和一个`components`文件夹来拆分默认文件。对于初学者来说，遵循这种模式直到你更熟悉以对应用程序有意义的任何方式拆分代码是很好的：
- en: '![Figure 1.2: Default Vue application src folder structure'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2：默认Vue应用程序src文件夹结构'
- en: '](img/B15218_01_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_01_02.jpg)'
- en: 'Figure 1.2: Default Vue application src folder structure'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：默认Vue应用程序src文件夹结构
- en: 'The `public` folder is a special directory for containing files that need to
    be transferred directly to the output location. The following screenshot displays
    how this folder will look:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`文件夹是一个特殊目录，用于包含需要直接传输到输出位置的文件。以下截图显示了此文件夹的外观：'
- en: '![Figure 1.3: Default Vue application public folder'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3：默认Vue应用程序public文件夹'
- en: '](img/B15218_01_03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_01_03.jpg)'
- en: 'Figure 1.3: Default Vue application public folder'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：默认Vue应用程序public文件夹
- en: By default, the `public` folder will contain an `index.html` file that serves
    as a placeholder for loading the Vue application. The `index.html` file can be
    modified to include header and footer scripts as required, such as Google Fonts
    or third-party JavaScript libraries that are not included as a part of your webpack
    bundle.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`public`文件夹将包含一个`index.html`文件，该文件作为加载Vue应用程序的占位符。`index.html`文件可以被修改以包含所需的头部和尾部脚本，例如Google字体或作为webpack包一部分之外的第三方JavaScript库。
- en: Vue Single-Page Components
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vue单页组件
- en: 'Components are the building blocks of most modern frameworks. Generally splitting
    your work into smaller chunks not only makes your code much easier to interpret
    but functionally follows the principles of **Don''t Repeat Yourself** (**DRY**).
    One of the most unique patterns for Vue users with arguably one of the most benefits
    is the **Single File Component** (**SFC**) pattern. SFCs centralize the responsibility
    of both appearance and behavior into a single file, often simplifying the architecture
    of your project and making the development process simpler being able to refer
    to your HTML, CSS, and JavaScript logic without switching files. Your default
    .vue file structure will be as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是大多数现代框架的构建块。通常将工作拆分成更小的块不仅使代码更容易理解，而且从功能上遵循了**不要重复自己**（**DRY**）的原则。对于Vue用户来说，最具独特性的模式之一，也是最有益的模式之一，是**单文件组件**（**SFC**）模式。SFC将外观和行为的责任集中到一个文件中，通常简化了项目架构，使开发过程更简单，能够在不切换文件的情况下引用HTML、CSS和JavaScript逻辑。你的默认.vue文件结构如下：
- en: '![Figure 1.4: Default .vue file structure'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.4：默认.vue文件结构'
- en: '](img/B15218_01_04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_01_04.jpg)'
- en: 'Figure 1.4: Default .vue file structure'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：默认.vue文件结构
- en: A trap that a lot of new Vue developers fall into is writing mega Vue files
    of over 500 lines of code, just for the HTML itself. Usually, what this means
    is that you could break this long component down into some smaller ones; however,
    we will cover file importing and code splitting in future chapters.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 许多新Vue开发者容易陷入的一个陷阱是编写超过500行代码的巨大型Vue文件，仅为了HTML本身。通常这意味着你可以将这个长组件拆分成一些更小的组件；然而，我们将在未来的章节中介绍文件导入和代码拆分。
- en: 'For example, in the header of your application, you may have a reusable logo
    element that needs to remain consistent on other pages. You would create a component
    such as `logo.vue`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在应用程序的头部，你可能有一个需要在不同页面上保持一致的复用logo元素。你将创建一个如`logo.vue`的组件：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can import it into your header component named `header.vue`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其导入到名为`header.vue`的头部组件中：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Very soon, you will have lots of these semantically structured files, which
    use these small chunks of reusable syntax that your team can implement across
    various areas of your application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，你将拥有大量这些语义化结构的文件，它们使用这些小块的可复用语法，你的团队可以在应用程序的各个区域实现。
- en: In the next section, we will gain an understanding of data properties.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解数据属性。
- en: Data Properties (Props)
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据属性（Props）
- en: 'One of the most used terms and reactive elements used when constructing Vue
    components is data property. These manifest themselves within the data function
    of a Vue instance:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建 Vue 组件时，最常用且具有响应性的术语之一是数据属性。这些在 Vue 实例的数据函数中体现出来：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can use data property to essentially store any information you want to use
    within your Vue templates. When this data property is updated or is changed, it
    will reactively update in the corresponding template.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用数据属性来存储您想在 Vue 模板中使用的基本信息。当这个数据属性更新或更改时，它将在相应的模板中响应式地更新。
- en: 'Exercise 1.01: Building Your First Component'
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.01：构建您的第一个组件
- en: In this exercise, we are going to build our first component inside of a Vue
    project. In this context, components are imported using `yarn` to be installed.
    These will be covered in the *Preface*. By the end of the exercise, you will be
    able to confidently create new Vue components using Vetur and import them into
    your project.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将在 Vue 项目内部构建我们的第一个组件。在这种情况下，组件是通过 `yarn` 导入并安装的。这些将在 *前言* 中介绍。到练习结束时，您将能够自信地使用
    Vetur 创建新的 Vue 组件并将它们导入到项目中。
- en: To access the code files for this exercise, refer to [https://packt.live/35Lhycl](https://packt.live/35Lhycl).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅 [https://packt.live/35Lhycl](https://packt.live/35Lhycl)。
- en: 'Open a command-line terminal and navigate into the `Exercise 1.01` folder and
    run the following commands in order:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行终端，导航到 `Exercise 1.01` 文件夹，并按顺序运行以下命令：
- en: '[PRE8]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Go to `https://localhost:8080`.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前往 `https://localhost:8080`。
- en: Note
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Your app will hot reload when you save new changes, so you can see them instantly.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当您保存新的更改时，您的应用程序将进行热重载，因此您可以立即看到它们。
- en: In `code .` command), go into the `src/App.vue` directory and delete everything
    in that file and save.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `code .` 命令中，进入 `src/App.vue` 目录，并删除该文件中的所有内容并保存。
- en: In your browser, everything should be blank a clean slate to start working from.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中，一切应该是空白的，作为开始工作的清洁画布。
- en: 'The three primary components that make up a single-file component are the `<template>`,
    `<script>`, and `<style>` blocks. If you installed the Vetur extension from the
    *Preface*, write `vue` and press *Tab* to choose the first selection of the prompt.
    This is the quickest way to set up your default code blocks as displayed in the
    following screenshot:![Figure 1.5: VSCode Vetur'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构成一个单文件组件的三个主要组成部分是 `<template>`、`<script>` 和 `<style>` 块。如果您已从 *前言* 中安装了 Vetur
    扩展，请输入 `vue` 并按 *Tab* 键选择提示的第一项。这是设置默认代码块的最快方式，如下面的截图所示：![图 1.5：VSCode Vetur
- en: '](img/B15218_01_05.jpg)'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_01_05.jpg)'
- en: '[PRE9]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create another file in the `components` folder called `Exercise1-01.vue` and
    repeat the same step for scaffolding the Vue blocks using Vetur:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `components` 文件夹中创建另一个名为 `Exercise1-01.vue` 的文件，并重复相同的步骤，使用 Vetur 搭建 Vue 块：
- en: '[PRE10]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Within our `Exercise1-01.vue` component, compose a set of `<div>` tags, with
    an `<h1>` element and a heading inside the `<template>` tags:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `Exercise1-01.vue` 组件中，编写一组 `<div>` 标签，并在 `<template>` 标签内包含一个 `<h1>` 元素和标题：
- en: '[PRE11]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Inside the `<style>` block, add some styling as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<style>` 块内添加以下样式：
- en: '[PRE12]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Import our component into the `App.vue` by using the ES6 `import` method and
    defining the component inside the `components` object in the `<script>` block.
    We can now reference this component inside the HTML by using its name in `camelCase`
    or `kebab-case` (both will work):'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 ES6 `import` 方法将我们的组件导入到 `App.vue` 中，并在 `<script>` 块中的 `components` 对象内定义组件。现在我们可以通过使用其名称在
    `camelCase` 或 `kebab-case`（两者都有效）来在 HTML 中引用此组件：
- en: '[PRE13]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When you press `Save`, `https://localhost:8080` should reload and display the
    following output:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当您点击 `保存` 时，`https://localhost:8080` 应该重新加载并显示以下输出：
- en: '![Figure 1.6: Localhost output for Exercise 1.01'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.6：Exercise 1.01 的本地主机输出'
- en: '](img/B15218_01_06.jpg)'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_01_06.jpg)'
- en: 'Figure 1.6: Localhost output for Exercise 1.01'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6：Exercise 1.01 的本地主机输出
- en: In this exercise, we saw how to structure Vue components using template tags,
    scaffold basic Vue components using `Vetur`, output HTML, and use ES6 syntax to
    import the `Exercise1-01` component into `App.vue`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何使用模板标签构建 Vue 组件，使用 `Vetur` 搭建基本 Vue 组件，输出 HTML，以及使用 ES6 语法将 `Exercise1-01`
    组件导入到 `App.vue` 中。
- en: Note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can only have one root HTML element inside `<template>` tags. Complex components
    should be wrapped in a containing HTML tag of your choice. `<div>`, `<article>`,
    and `<section>` are all semantic HTML component wrappers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`<template>` 标签内只能有一个根 HTML 元素。复杂组件应该被您选择的包含 HTML 标签包裹。`<div>`、`<article>`
    和 `<section>` 都是语义化的 HTML 组件包装器。'
- en: Data Binding Syntax Using Interpolation
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内联插值的数据绑定语法
- en: Interpolation is the insertion of something of a different nature into something
    else. In the Vue.js context, this is where you would use *mustache* syntax (double
    curly braces) to define an area where you can inject data into a component's HTML template.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 内联插值是将不同性质的东西插入到其他东西中的过程。在Vue.js的上下文中，这就是你将使用*mustache*语法（双花括号）来定义可以注入数据到组件HTML模板中的区域的地方。
- en: 'Consider the following example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The data property `title` is bound to Vue.js reactive data and will update on
    the fly depending on state changes to the UI and its data. We will go into more
    depth about how to use interpolation and how to bind it to data properties in
    the next exercise.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 数据属性`title`绑定到Vue.js响应式数据，并且会根据UI及其数据的状态变化实时更新。我们将在下一个练习中更深入地探讨如何使用内联插值以及如何将其绑定到数据属性。
- en: 'Exercise 1.02: Interpolation with Conditionals'
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.02：使用条件语句的内联插值
- en: When you want to output data into your template or make elements on a page be
    reactive, interpolate data into the template by using curly braces. Vue can understand
    and replace that placeholder with data.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想将数据输出到模板中或使页面上的元素具有响应性时，可以通过使用花括号将数据内联到模板中。Vue可以理解并替换这些占位符为数据。
- en: To access the code files for this exercise, refer to [https://packt.live/3feLsJ3](https://packt.live/3feLsJ3).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/3feLsJ3](https://packt.live/3feLsJ3)。
- en: 'Open a command-line terminal and navigate into the `Exercise 1.02` folder and
    run the following commands in order:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行终端，导航到`Exercise 1.02`文件夹，并按顺序运行以下命令：
- en: '[PRE15]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Go to `https://localhost:8080`.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 访问`https://localhost:8080`。
- en: 'Inside of the `Exercise1-02.vue` component, let''s add data within the `<script>`
    tags by adding a function called `data()` and return a key called `title` with
    your heading string as the value:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Exercise1-02.vue`组件内部，让我们通过添加一个名为`data()`的函数并在其中返回一个名为`title`的键，其值为你的标题字符串，来在`<script>`标签内添加数据：
- en: '[PRE16]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Reference the data `title` by replacing your `<h1>` text with the interpolated
    value `{{ title }}`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`<h1>`文本替换为内联值`{{ title }}`来引用数据`title`：
- en: '[PRE17]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When you save this document, the data title will now appear inside your `h1`
    tag.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你保存此文档时，数据标题现在将出现在你的`h1`标签内。
- en: 'In Vue, interpolation will resolve any JavaScript inside curly braces. For
    example, you can transform your text inside the curly braces using the `toUpperCase()` method:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Vue中，内联将解析花括号内的任何JavaScript。例如，你可以使用`toUpperCase()`方法在花括号内转换你的文本：
- en: '[PRE18]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You should see an output like the following screenshot:'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该看到以下截图所示的输出：
- en: '![Figure 1.7: Save the file—you should now have an uppercased title'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.7：保存文件——你现在应该有一个大写标题]'
- en: '](img/B15218_01_07.jpg)'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_01_07.jpg]'
- en: 'Figure 1.7: Save the file—you should now have an uppercased title'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图1.7：保存文件——你现在应该有一个大写标题
- en: 'In addition to parsing JavaScript methods, interpolation can handle conditional
    logic. Inside the data object, add a Boolean key-value pair `isUppercase: false`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '除了解析JavaScript方法外，内联也可以处理条件逻辑。在数据对象内部，添加一个布尔键值对`isUppercase: false`：'
- en: '[PRE19]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code will generate the following output:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码将生成以下输出：
- en: '![Figure 1.8: Exercise 1.02 output after including the inline conditional statement'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.8：包含内联条件语句的练习1.02输出]'
- en: '](img/B15218_01_08.jpg)'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_01_08.jpg]'
- en: 'Figure 1.8: Exercise 1.02 output after including the inline conditional statement'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图1.8：包含内联条件语句的练习1.02输出
- en: 'Add this condition to the curly braces, and when you save you should see the
    non-uppercased title. Play around with this value by changing `isUppercase` to `true`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此条件添加到花括号中，当你保存时，你应该看到非大写标题。通过将`isUppercase`更改为`true`来玩转这个值：
- en: '[PRE20]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following screenshot displays the final output generated upon running the
    preceding code:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了运行前面代码后生成的最终输出：
- en: '![Figure 1.9: Final Exercise 1.02 output'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.9：最终练习1.02输出]'
- en: '](img/B15218_01_09.jpg)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_01_09.jpg]'
- en: 'Figure 1.9: Final Exercise 1.02 output'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9：最终练习1.02输出
- en: In this exercise, we were able to use inline conditionals inside the interpolated
    tags (curly braces) by using a Boolean variable. This allows us to modify what
    data is displayed inside of our component without overly complicated conditions,
    which can be useful in certain use cases.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们能够通过使用布尔变量在内联标签（花括号）内使用内联条件来使用内联条件。这允许我们在不过度复杂的条件下修改组件内部显示的数据，这在某些用例中可能很有用。
- en: We will now learn about how to style components using a variety of methods.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将学习如何使用各种方法来设置组件样式。
- en: Styling Components
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件样式
- en: When using Vue components, the webpack compiler allows you to use almost any
    frontend templating language style you prefer. For example, there are several
    ways to compose CSS, either directly or with pre-processing. The easiest way to
    enable these expressive languages in your Vue templates is to install them when
    you set up your project ahead of time using the Vue CLI.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Vue 组件时，webpack 编译器允许你使用你喜欢的几乎所有前端模板语言风格。例如，有几种方法可以组合 CSS，无论是直接还是通过预处理。在
    Vue 模板中启用这些表达性语言的最简单方法是在使用 Vue CLI 设置项目之前安装它们。
- en: When using the `style` tag inside of a Vue component, you have the option to
    specify a language, provided you have installed the appropriate webpack loader.
    In `Exercise 1.01`, if you chose to install the SCSS preprocessor, you can add
    the `lang="scss"` attribute to the `style` tag to begin using SCSS.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Vue 组件中使用 `style` 标签时，如果你已安装适当的 webpack 加载器，你可以指定一个语言。在 `Exercise 1.01`
    中，如果你选择安装 SCSS 预处理器，你可以在 `style` 标签中添加 `lang="scss"` 属性以开始使用 SCSS。
- en: 'For example, if you chose to install the Stylus preprocessor, you can add the
    `lang="stylus"` attribute to the `style` tag to begin using Stylus:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你选择安装 Stylus 预处理器，你可以在 `style` 标签中添加 `lang="stylus"` 属性以开始使用 Stylus：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Vue scoping is a handy way to stop individual components from inheriting styles
    from the virtual DOM head. Add the scoped attribute to your `style` tag and write
    some component-specific styles that will override any other CSS rules from the
    global sheet. The general rule is to not scope global styles. A common method
    for defining global styling is to separate these styles into another style sheet
    and import them into your `App.vue`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 作用域是一个方便的方法，可以阻止单个组件从虚拟 DOM 头继承样式。将 `scoped` 属性添加到你的 `style` 标签中，并编写一些特定于组件的样式，这些样式将覆盖全局样式表中的任何其他
    CSS 规则。一般规则是不作用域全局样式。定义全局样式的常见方法是将这些样式分离到另一个样式表中，并将其导入到你的 `App.vue` 中。
- en: 'Exercise 1.03: Importing SCSS into a Scoped Component'
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.03：将 SCSS 导入到作用域组件中
- en: In this exercise, we will be utilizing the `style` tag to add SCSS preprocessed
    styles to a component and importing external stylesheets.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在此练习中，我们将利用 `style` 标签将 SCSS 预处理样式添加到组件中，并导入外部样式表。
- en: To access the code files for this exercise, refer to [https://packt.live/3nBBZyl](https://packt.live/3nBBZyl).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅 [https://packt.live/3nBBZyl](https://packt.live/3nBBZyl)。
- en: 'Open a command-line terminal and navigate into the `Exercise1.03` folder and
    run the following commands in order:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行终端，导航到 `Exercise1.03` 文件夹，并按顺序运行以下命令：
- en: '[PRE22]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Go to `https://localhost:8080`.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前往 `https://localhost:8080`。
- en: 'Inside of the exercise file, let''s write some HTML that can be styled using
    SCSS. Let''s keep practicing the interpolation method:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在练习文件内部，让我们编写一些可以使用 SCSS 样式的 HTML。让我们继续练习插值方法：
- en: '[PRE23]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add the `lang` property to the `style` tag and add the value `scss` to enable
    SCSS syntax inside the `style` block:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `lang` 属性添加到 `style` 标签中，并将值设置为 `scss` 以在 `style` 块内启用 SCSS 语法：
- en: '[PRE24]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create a folder inside the `src/` directory called `styles`. Inside this new
    folder create a file called `typography.scss`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/` 目录下创建一个名为 `styles` 的文件夹。在这个新文件夹中创建一个名为 `typography.scss` 的文件：
- en: '[PRE25]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Inside `typography.scss`, add some styling for the template you composed in
    your component:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `typography.scss` 内部，为你在组件中编写的模板添加一些样式：
- en: '[PRE26]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In SCSS, the same code can be represented as follows:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 SCSS 中，相同的代码可以表示如下：
- en: '[PRE27]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In your component, import these styles by using the SCSS `@import` method:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的组件中，通过使用 SCSS 的 `@import` 方法导入这些样式：
- en: '[PRE28]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will generate an output as follows:'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '![Figure 1.10: When you save and reload, your project should have the style
    imported'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.10：当你保存并重新加载时，你的项目应该已经导入了样式'
- en: '](img/B15218_01_10.jpg)'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_01_10.jpg)'
- en: 'Figure 1.10: When you save and reload, your project should have the style imported'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.10：当你保存并重新加载时，你的项目应该已经导入了样式
- en: 'Add the `scoped` attribute to your `<style>` tag to only apply these styles
    to this component instance. Use the variable from the imported stylesheet `$color-blue`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `scoped` 属性添加到你的 `<style>` 标签中，以便只将这些样式应用于此组件实例。使用从导入的样式表中导入的变量 `$color-blue`：
- en: '[PRE29]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![Figure 1.11: The outcome of scoping styles'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.11：作用域样式的结果'
- en: '](img/B15218_01_11.jpg)'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_01_11.jpg)'
- en: 'Figure 1.11: The outcome of scoping styles'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.11：作用域样式的结果
- en: Inspect the DOM and you will notice that at run-time, that scoping has applied
    `v-data-*` attributes to your DOM elements specifying these specific rules. Our
    `typography.scss`, which we are scoping to our component, references an HTML tag
    that does not live within the scope of our component. When Vue adds data attributes
    to the scoped component, it generates the style if the `<body>` tag exists within
    the component. In our case, it does not.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查 DOM，您将注意到在运行时，作用域已将 `v-data-*` 属性应用于您的 DOM 元素，指定了这些特定规则。我们针对组件作用域的 `typography.scss`
    引用了一个不在组件作用域内的 HTML 标签。当 Vue 向作用域组件添加数据属性时，如果 `<body>` 标签存在于组件中，它将生成样式。在我们的例子中，它不存在。
- en: 'The `Elements` tab of your browser dev tools will show the following after
    expanding the `<head>` and `<style>` tags:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在浏览器开发者工具的 `Elements` 选项卡中展开 `<head>` 和 `<style>` 标签后，将显示以下内容：
- en: '![Figure 1.12: Observe how the virtual DOM uses data attributes to assign scoped
    styles'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.12：观察虚拟 DOM 如何使用数据属性来分配作用域样式'
- en: '](img/B15218_01_12.jpg)'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_01_12.jpg)'
- en: 'Figure 1.12: Observe how the virtual DOM uses data attributes to assign scoped
    styles'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.12：观察虚拟 DOM 如何使用数据属性来分配作用域样式
- en: 'Create a new style sheet called `global.scss` in the `styles` folder:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `styles` 文件夹中创建一个新的样式表 `global.scss`：
- en: '[PRE30]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Import this stylesheet into your `App.vue`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此样式表导入到您的 `App.vue` 中：
- en: '[PRE31]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Our app should now be back to normal, with a mixture of globally defined styling
    and properly scoped styles for this component, as follows:'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们的应用应该恢复正常，具有全局定义的样式和此组件的正确作用域样式，如下所示：
- en: '![Figure 1.13: Properly scoped styles for Exercise 1.03'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.13：练习 1.03 的正确作用域样式'
- en: '](img/B15218_01_13.jpg)'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_01_13.jpg)'
- en: 'Figure 1.13: Properly scoped styles for Exercise 1.03'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13：练习 1.03 的正确作用域样式
- en: In this exercise, we interpolated data that originated from an array, then styled
    our component using forms of scoped SCSS, which can both exist inside the `<style>`
    tag or be imported from another directory in our project.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们插值了来自数组的原始数据，然后使用作用域 SCSS 的形式来样式化我们的组件，这些样式可以存在于 `<style>` 标签内部，或者从我们的项目中的另一个目录导入。
- en: CSS Modules
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS 模块
- en: A recent pattern that has become popular in the reactive framework world is
    CSS modules. Frontend development has always had to face the issue of conflicting
    CSS class names, ill-structured BEM code, and confusing CSS file structures. Vue
    components help to solve this by being modular and allowing you to compose CSS
    that, at compile time, will generate unique class names for the specific component
    that it was composed for. You can even have the exact same class names across
    components; however, they will be uniquely identified using a randomly generated
    string attached to the end.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式框架领域最近流行的一种模式是 CSS 模块。前端开发一直必须面对 CSS 类名冲突、结构不良的 BEM 代码和混乱的 CSS 文件结构等问题。Vue
    组件通过模块化并允许您组合 CSS 来帮助解决这个问题，在编译时，将为特定组件生成唯一的类名。您甚至可以在组件之间使用完全相同的类名；然而，它们将通过附加在末尾的随机生成的字符串来唯一标识。
- en: 'To enable this feature in Vue, you will need to add the module attribute to
    the `style` block, and reference classes using JavaScript syntax:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Vue 中启用此功能，您需要将模块属性添加到 `style` 块中，并使用 JavaScript 语法引用类：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding example, if you inspected the DOM tree that class will be called
    something like `.container_ABC123`. If you were to create multiple components
    that had a semantic class name like `.container` but used CSS modules, you would
    never run into style conflicts again.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，如果您检查 DOM 树，该类将被命名为类似 `.container_ABC123` 的名称。如果您创建多个具有语义类名如 `.container`
    的组件，但使用 CSS 模块，您将永远不会再次遇到样式冲突。
- en: 'Exercise 1.04: Style Vue Components Using CSS Modules'
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.04：使用 CSS 模块样式化 Vue 组件
- en: In this exercise, you will utilize CSS modules to style a `.vue` component.
    By using the `$style` syntax inside of a `:class` bind, you refer to the Vue instance's
    `this.$style` scope. Vue will generate random class names based on the components
    at run or build time ensuring the style will not overlap with any other classes
    in your project.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将利用 CSS 模块来样式化一个 `.vue` 组件。通过在 `:class` 绑定中使用 `$style` 语法，您引用了 Vue 实例的
    `this.$style` 作用域。Vue 将根据运行或构建时的组件生成随机类名，确保样式不会与您的项目中的任何其他类冲突。
- en: To access the code files for this exercise, refer to [https://packt.live/36PPYdd](https://packt.live/36PPYdd).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅 [https://packt.live/36PPYdd](https://packt.live/36PPYdd)。
- en: 'Open a command-line terminal, navigate into the `Exercise1.04` folder, and
    run the following commands in order:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行终端，导航到 `Exercise1.04` 文件夹，并按顺序运行以下命令：
- en: '[PRE33]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Go to `https://localhost:8080`.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前往 `https://localhost:8080`。
- en: 'Inside of `Exercise1-04.vue`, compose the following code:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Exercise1-04.vue` 内部，编写以下代码：
- en: '[PRE34]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add the `<style>` block with the SCSS language and add `module` as an attribute
    instead of `scoped`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加带有 SCSS 语言的 `<style>` 块，并将 `module` 作为属性而不是 `scoped`：
- en: '[PRE35]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To use CSS modules in your template, you need to bind them to your HTML elements
    by using `:class` syntax, which is the same as the `v-bind:class` directive:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在模板中使用 CSS 模块，您需要通过使用 `:class` 语法将它们绑定到您的 HTML 元素上，这与 `v-bind:class` 指令相同：
- en: '[PRE36]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When you save, your project should look something like this:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保存时，您的项目应该看起来像这样：
- en: '![Figure 1.14: Exercise 1.04 output using CSS modules'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.14：使用 CSS 模块实现的练习 1.04 输出'
- en: '](img/B15218_01_14.jpg)'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_01_14.jpg)'
- en: 'Figure 1.14: Exercise 1.04 output using CSS modules'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.14：使用 CSS 模块实现的练习 1.04 输出
- en: 'If you inspect the virtual DOM, you will see how it has applied unique class
    names to the bound elements:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果检查虚拟 DOM，您将看到它如何为绑定元素应用了唯一的类名：
- en: '![Figure 1.15: The virtual DOM tree''s generated CSS module class'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.15：虚拟 DOM 树生成的 CSS 模块类'
- en: '](img/B15218_01_15.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_01_15.jpg)'
- en: 'Figure 1.15: The virtual DOM tree''s generated CSS module class'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.15：虚拟 DOM 树生成的 CSS 模块类
- en: In this exercise, we saw how to use CSS modules in your Vue components and how
    it works differently to CSS scoping. In the next exercise, we will learn how to
    write a template in **PUG (HAML)**.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何在 Vue 组件中使用 CSS 模块以及它是如何与 CSS 作用域不同的。在下一个练习中，我们将学习如何用 **PUG (HAML)**
    编写模板。
- en: Note
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In combination with file splitting and importing SCSS, CSS modules are the preferred
    method of scoping component styling here. This safely ensures that individual
    component styles and business rules do not risk overriding each other and do not
    pollute global styling and variables with component-specific styling requirements.
    Readability is important. The class name also hints to the component name as opposed
    to the `v-data` attribute, which can be good when debugging large projects.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 结合文件拆分和导入 SCSS，CSS 模块是这里作用域组件样式的首选方法。这安全地确保了单个组件样式和业务规则不会相互覆盖，并且不会因组件特定的样式要求而污染全局样式和变量。可读性很重要。类名也暗示了组件名称，而不是
    `v-data` 属性，这在调试大型项目时可能是有益的。
- en: 'Exercise 1.05: Writing a Component Template in PUG (HAML)'
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.05：在 PUG (HAML) 中编写组件模板
- en: With the right loader enabled you can use HTML abstractions such as PUG and
    HAML to template your Vue components instead of writing HTML.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 启用正确的加载器后，您可以使用 HTML 抽象，如 PUG 和 HAML，来模板化您的 Vue 组件，而不是编写 HTML。
- en: To access the code files for this exercise, refer to [https://packt.live/2IOrHvN](https://packt.live/2IOrHvN).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅 [https://packt.live/2IOrHvN](https://packt.live/2IOrHvN)。
- en: 'Open a command-line terminal and navigate into the `Exercise1.05` folder and
    run the following commands in order:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行终端，导航到 `Exercise1.05` 文件夹，并按顺序运行以下命令：
- en: '[PRE37]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Go to `https://localhost:8080`.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前往 `https://localhost:8080`。
- en: 'If Vue is running in the command line, press *Ctrl* + *C* to stop the instance.
    Then run the following command:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Vue 在命令行中运行，请按 *Ctrl* + *C* 停止实例。然后运行以下命令：
- en: '[PRE38]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Inside of `Exercise1-05.vue`, compose the following code and specify the `lang`
    attribute `pug` on the `<template>` tag:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Exercise1-05.vue` 内部，编写以下代码，并在 `<template>` 标签上指定 `lang` 属性 `pug`：
- en: '[PRE39]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The preceding code will generate the following output:'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码将生成以下输出：
- en: '![Figure 1.16: Output for the PUG exercise'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.16：PUG 练习的输出'
- en: '](img/B15218_01_16.jpg)'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_01_16.jpg)'
- en: 'Figure 1.16: Output for the PUG exercise'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16：PUG 练习的输出
- en: In this exercise, we saw how to use other HTML languages for templating and
    to interpolate data in `PUG` format. After installing the Vue.js `PUG` plugin
    you can write your component syntax inside of these template tags using `PUG`
    by adding the `lang` attribute with the value `pug`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何使用其他 HTML 语言进行模板化，并在 `PUG` 格式中插值数据。在安装 Vue.js `PUG` 插件后，您可以在这些模板标签内使用
    `PUG` 编写组件语法，通过添加具有值 `pug` 的 `lang` 属性。
- en: Vue Directives
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue 指令
- en: 'Vue''s templating language allows you to interpolate the HTML code with JavaScript
    expressions and Vue directives. This templating pattern is often referred to as
    syntax sugar because it does not change how the code itself works, just how you
    use it. Syntax sugar allows you to clearly define template-specific logic inside
    of your HTML without the need to abstract this logic elsewhere in your project
    or return copious amounts of HTML directly from your JavaScript code. All Vue
    based directives are prefixed with `v-*`, which indicates that it is a Vue specific
    attribute:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 的模板语言允许您将 HTML 代码与 JavaScript 表达式和 Vue 指令进行插值。这种模板模式通常被称为语法糖，因为它不会改变代码本身的工作方式，只是改变了您使用它的方式。语法糖允许您在
    HTML 中清晰地定义特定于模板的逻辑，而无需在项目的其他地方抽象此逻辑或直接从 JavaScript 代码中返回大量的 HTML。所有基于 Vue 的指令都以
    `v-*` 前缀开头，这表明它是一个 Vue 特定的属性：
- en: '`v-text`: The `v-text` directive has the same reactivity interpolation does,
    except you reference the same piece of data inside of a directive. Interpolation
    (curly braces) `{{ }}` is more performant than the `v-text` directive; however,
    you may find yourself in situations where you have pre-rendered text from a server
    and want to override it once your Vue application has loaded. For example, you
    can predefine static placeholder text while the DOM waits for the `data` and `v-text`
    attributes to eventually replace it.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v-text`: `v-text` 指令具有与反应性插值相同的特性，除了您在指令内部引用相同的数据片段。插值（花括号）`{{ }}` 比指令 `v-text`
    更高效；然而，您可能会发现自己处于这样的情况，即您从服务器预先渲染了文本，并希望在 Vue 应用程序加载后覆盖它。例如，您可以在 DOM 等待 `data`
    和 `v-text` 属性最终替换它时预先定义静态占位文本。'
- en: '`v-once`: As a directive, this is unique in that you pair it with other directives
    to augment how they function. Passing data via `v-text` or interpolated curly
    braces into the HTML element this attribute is added to will stop the Vue instance
    from reloading the element with new data, removing the reactivity of the element.
    This is handy for situations where you want to render decorative elements using
    data, but do not want them to update when the data changes after the initial render.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v-once`: 作为指令，这是独一无二的，因为它可以与其他指令配对以增强其功能。通过 `v-text` 或插入花括号将数据传递到添加了此属性的 HTML
    元素中，将阻止 Vue 实例重新加载元素以新的数据，从而移除元素的反应性。这在您想要使用数据渲染装饰性元素，但又不希望它们在初始渲染后数据更改时更新时非常有用。'
- en: '`v-html`: This directive will render valid HTML in your data string inside
    of the HTML element it has been bound to. This directive is a heavier operation
    than the other directives, so limited usage is recommended when other options
    are not otherwise available.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v-html`: 这个指令将在绑定到其上的 HTML 元素内的数据字符串中渲染有效的 HTML。与其他指令相比，这个指令的操作更重，因此当其他选项不可用时应限制使用。'
- en: Note
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: '`<script>` tags can be run in this directive. Only render content originating
    from secure or trusted sources.'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<script>` 标签可以在这个指令中运行。仅渲染来自安全或可信来源的内容。'
- en: '`v-bind`: This directive is one of the most widely used directives in Vue.
    Throughout Vue, you will be binding reactive data to HTML attributes and passing
    data into props using this directive''s `:attr` shortcut instead of `v-bind:attr`.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v-bind`: 这个指令是 Vue 中使用最广泛的指令之一。在 Vue 的整个框架中，您将通过这个指令的 `:attr` 快捷方式将响应式数据绑定到
    HTML 属性，并使用它将数据传递给 props，而不是使用 `v-bind:attr`。'
- en: '`v-if`: To control the display state of HTML elements inside the template,
    you will often use `v-if` to completely remove elements from the DOM tree. So
    far, you have seen how to interpolate conditionals like this `{{ isTrue ? ''Show
    this'': ''Not this'' }}`. With the `v-if` directive, you can control entire blocks
    of HTML syntax. `v-else-if` can be used like `else if` statements and finish with
    `v-else`, which is the equivalent to the `catch { ... }` declaration of an `else
    { ... }` statement in traditional JavaScript.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v-if`: 为了控制模板中 HTML 元素的显示状态，您通常会使用 `v-if` 完全从 DOM 树中移除元素。到目前为止，您已经看到了如何插入条件，例如
    `{{ isTrue ? ''Show this'': ''Not this'' }}`。使用 `v-if` 指令，您可以控制整个 HTML 语法块。`v-else-if`
    可以像 `else if` 语句一样使用，并以 `v-else` 结尾，它是传统 JavaScript 中 `else { ... }` 语句的 `catch
    { ... }` 声明的等价物。'
- en: '`v-show`: You can control the visible state of HTML elements by using `v-show`,
    which, instead of removing the element from the DOM tree, will apply a `display:
    none` style. The difference between a `v-if` and `v-show` is that `v-show` will
    remain as a block element in the DOM tree but will be hidden with `css` instead
    of being removed from the DOM tree. You also cannot chain `v-show` with `v-else`
    or `v-else-if`.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v-show`：您可以通过使用 `v-show` 来控制 HTML 元素的可见状态，它不会从 DOM 树中删除元素，而是应用 `display: none`
    样式。`v-if` 和 `v-show` 之间的区别在于 `v-show` 将作为块元素保留在 DOM 树中，但将通过 `css` 隐藏而不是从 DOM 树中删除。您也不能将
    `v-show` 与 `v-else` 或 `v-else-if` 连接。'
- en: '`v-for`: Apply this to an element you want to repeat or iterate on. This directive
    requires an additional prop called `:key` to allow it to properly reactively render;
    it can be as simple as a unique number.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v-for`：将此指令应用于您想要重复或迭代的元素。此指令需要一个额外的属性 `:key`，以便它可以正确地响应式渲染；它可以是简单的唯一数字。'
- en: 'Consider an example where we iterate over the list element five times. Each
    list item will render its count (1, 2… 5):'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑一个例子，其中我们迭代列表元素五次。每个列表项将渲染其计数（1，2… 5）：
- en: '[PRE40]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now let's look at how some of the basic directives work.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些基本指令是如何工作的。
- en: 'Exercise 1.06: Basic Directives (v-text, v-once, v-html, v-bind, v-if, v-show)'
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.06：基本指令（v-text、v-once、v-html、v-bind、v-if、v-show）
- en: More complicated components will use multiple directives to achieve the desired
    outcome. In this exercise, we will construct a component that uses several directives
    to bind, manipulate, and output data to a template view.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的组件将使用多个指令来实现所需的输出。在这个练习中，我们将构建一个组件，该组件使用多个指令来绑定、操作并将数据输出到模板视图。
- en: To access the code files for this exercise, refer to [https://packt.live/3fdCNqa](https://packt.live/3fdCNqa).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅 [https://packt.live/3fdCNqa](https://packt.live/3fdCNqa)。
- en: 'Open a command-line terminal, navigate into the `Exercise1.06` folder, and
    run the following commands in order:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行终端，导航到 `Exercise1.06` 文件夹，并按顺序运行以下命令：
- en: '[PRE41]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Go to `https://localhost:8080`.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 访问 `https://localhost:8080`。
- en: 'Compose the following syntax inside of `Exercise1-06.vue`. This uses the interpolation
    method that we have used in previous exercises and that will be very familiar
    by this point:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Exercise1-06.vue` 内部编写以下语法。这使用了我们在之前的练习中使用的插值方法，并且到这一点上应该非常熟悉：
- en: '[PRE42]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Replace the interpolation with the `v-text` attribute. You will notice the
    output will not change:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将插值替换为 `v-text` 属性。您将注意到输出不会改变：
- en: '[PRE43]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Figure 1.17* displays the output of the preceding code:'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 1.17* 展示了前面代码的输出：'
- en: '![Figure 1.17: The v-text directive output works very similarly to the interpolation
    method'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.17：v-text 指令的输出与插值方法非常相似'
- en: '](img/B15218_01_17.jpg)'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_01_17.jpg](img/B15218_01_17.jpg)'
- en: 'Figure 1.17: The v-text directive output works very similarly to the interpolation
    method'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.17：v-text 指令的输出与插值方法非常相似
- en: 'Add the `v-once` directive on the same element. This will force this DOM element
    to only load the `v-text` data once for as long as it exists in the page:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一元素上添加 `v-once` 指令。这将强制此 DOM 元素在页面存在期间只加载一次 `v-text` 数据：
- en: '[PRE44]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Underneath the `h1` element, include a new `h2` element, which uses the `v-html`
    attribute. Add a new data key called `html`, which contains a string with HTML
    formatting in it like the following:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `h1` 元素下方，包含一个新的 `h2` 元素，该元素使用 `v-html` 属性。添加一个新的数据键 `html`，其中包含如下格式的字符串：
- en: '[PRE45]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Running the preceding code will generate an output as follows:'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的代码将生成如下输出：
- en: '![Figure 1.18: Output on rendering the HTML elements'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.18：渲染 HTML 元素后的输出'
- en: '](img/B15218_01_18.jpg)'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_01_18.jpg](img/B15218_01_18.jpg)'
- en: 'Figure 1.18: Output on rendering the HTML elements'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.18：渲染 HTML 元素后的输出
- en: 'Add a new `link` object to the `data` object that contains a bunch of information
    such as URL, target, title, and tab index. Inside the template, add a new anchor
    HTML element and bind the `link data` object to the HTML element using the colon
    syntax, for example, `:href="link.url"`:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `data` 对象中添加一个新的 `link` 对象，其中包含诸如 URL、目标、标题和标签索引等信息。在模板内部，添加一个新的锚点 HTML 元素，并使用冒号语法将
    `link data` 对象绑定到 HTML 元素上，例如，`:href="link.url"`：
- en: '[PRE46]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following screenshot displays the output:'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了输出：
- en: '![Figure 1.19: Output on binding the reactive data from'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.19：将 Vue 实例的响应式数据绑定到'
- en: the Vue instance to any HTML attribute](img/B15218_01_19.jpg)
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 Vue 实例绑定到任何 HTML 属性](img/B15218_01_19.jpg)
- en: 'Figure 1.19: Output on binding the reactive data from the Vue instance to any
    HTML attribute'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.19：将 Vue 实例的响应式数据绑定到任何 HTML 属性的输出
- en: 'Apply `v-if="false"` to the `h1` element, `v-else-if="false"` to `h2`, and
    `v-else` to the `a` tag like this:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You should only see the `<a>` tag in the page since we have set the conditional
    statements to `false`.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `v-else` condition will display as follows:'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.20: False v-if statements hiding the whole HTML element from the
    DOM'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_01_20.jpg)'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 1.20: False v-if statements hiding the whole HTML element from the DOM'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change the template to use `v-show` instead of the `v-if` statements:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output of the preceding code will be as follows:'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.21: Changing v-show to true will display the element'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_01_21.jpg)'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 1.21: Changing v-show to true will display the element'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'When you open the `Elements` tab of your browser dev tools, you should be able
    to observe the `h2` display state set to `none`, as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.22: h2 displaying "display: none" for false condition'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_01_22.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.22: h2 displaying "display: none" for false condition'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'If `v-show` results in a `true` Boolean, it will leave the DOM element as is.
    If it resolves as `false`, it will apply `display: none` styling to the element.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we learned about the core Vue directives to control, bind,
    show, and hide HTML template elements without requiring any JavaScript outside
    of adding new data objects to your local state.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to achieve a two-way binding with the
    help of Vue's `v-model`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Two-Way Binding Using v-model
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue has simplified the way to achieve two-way data binding by creating a directive
    that specifically watches a data property inside of your Vue component. The Vue
    directive `v-model` will reactively change when the bound data property that Vue
    is watching changes. This directive is usually useful for HTML form elements that
    need to both display the data and modify it reactively, for example, input, textarea,
    radio buttons, and so on.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'Two-way binding is achieved by adding the `v-model` directive to the element
    you want bound and referring to a data prop:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '*Figure 1.23* represents the output generated by running the preceding code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.23: Output for the v-model example'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_01_23.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.23: Output for the v-model example'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Be careful using this directive as binding a huge amount of data in this way
    can affect the performance of your application. Consider your UI and split these
    into different Vue components or views. Vue data in the local state is not immutable
    and can be redefined anywhere in the template.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.07: Two-Way Binding Using v-model'
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to build a component using Vue's two-way data binding attribute
    v-model. Consider what it means to bind a piece of data in two ways. The context
    for this form of data model is usually forms, or where you expect both input and
    output data. By the end of the exercise, we should be able to utilize the v-model
    attribute in a form context.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: To access the code files for this exercise, refer to [https://packt.live/2IILld8](https://packt.live/2IILld8).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/2IILld8](https://packt.live/2IILld8)。
- en: 'Open a command-line terminal, navigate into the `Exercise1.07` folder, and
    run the following commands in order:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行终端，导航到`Exercise1.07`文件夹，并按顺序运行以下命令：
- en: '[PRE50]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Go to `https://localhost:8080`.
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 访问`https://localhost:8080`。
- en: 'Start by composing an HTML label and input element bound to the `name` data
    prop using `v-model` inside the template area:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在模板区域使用`v-model`组合一个HTML标签和输入元素，并将其绑定到`name`数据属性：
- en: '[PRE51]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finish binding the text input by returning a reactive data prop called `name`
    in the `<script>` tag:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`<script>`标签中返回一个名为`name`的响应式数据属性来完成文本输入的绑定：
- en: '[PRE52]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Compose a label and selectable HTML list bound to the data prop `language`
    using `v-model` inside of the template area:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用模板区域内的`v-model`组合一个标签和可选择的HTML列表，并将其绑定到数据属性`language`：
- en: '[PRE53]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finish binding the select input by returning a reactive data prop called `language`
    in the `<script>` tag:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`<script>`标签中返回一个名为`language`的响应式数据属性来完成选择输入的绑定：
- en: '[PRE54]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Below the form fields, output the name and language inside of an unordered
    list structure (`<ul>` and `<li>`) by using curly braces, for example, `{{ name
    }}`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表单字段下方，使用花括号（例如，`{{ name }}`）在无序列表结构（`<ul>`和`<li>`）中输出名称和语言：
- en: '[PRE55]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Add styling inside the `<style>` tag at the bottom of the component, and set
    the `lang` attribute to `scss`:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件底部的`<style>`标签内添加样式，并将`lang`属性设置为`scss`：
- en: '[PRE56]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Your output should look as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 您的输出应该如下所示：
- en: '![Figure 1.24: Displaying the final form after the data is updated'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.24：数据更新后的最终表单显示'
- en: '](img/B15218_01_24.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_01_24.jpg)'
- en: 'Figure 1.24: Displaying the final form after the data is updated'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.24：数据更新后的最终表单显示
- en: Your form should look something like this. When you update the data in the form,
    it should also update the overview area synchronously.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 您的表单应该看起来像这样。当您更新表单中的数据时，它也应该同步更新概览区域。
- en: In this exercise, we used the `v-model` directive to bind the name and JavaScript-style
    drop-down selection to our local state's data. When you change the data, it will
    reactively update the DOM elements we output this bound data to.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用了`v-model`指令来绑定名称和JavaScript风格的下拉选择到我们本地状态的数据。当您更改数据时，它将响应式地更新我们输出此绑定数据的DOM元素。
- en: Anonymous Loops
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名循环
- en: To loop over HTML elements in Vue, you utilize the `v-for` loop directive. When
    Vue renders the component, it will iterate the HTML element you have added the
    directive to in order to use the data being parsed into the directive. `:key`.
    When the key or the content bound to the key changes, Vue knows that it needs
    to reload the content inside the loop. If you have multiple loops in one component,
    randomize the key with extra characters or context-related strings to avoid `:key`
    duplication conflicts.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Vue中遍历HTML元素，您将使用`v-for`循环指令。当Vue渲染组件时，它将迭代您添加指令的HTML元素，以使用解析到指令中的数据。`:key`。当键或绑定到键的内容发生变化时，Vue知道它需要重新加载循环内的内容。如果您在一个组件中有多个循环，请使用额外的字符或与上下文相关的字符串随机化键，以避免`:key`重复冲突。
- en: 'Anonymous loops are demonstrated below; note that you can use quotation marks
    or backticks (`) to describe strings:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名循环的示例如下；请注意，您可以使用引号或反引号（`）来描述字符串：
- en: '[PRE57]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The output of the preceding code should look as follows.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出应该如下所示。
- en: '![Figure 1.25: Output of anonymous loops example'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.25：匿名循环示例的输出'
- en: '](img/B15218_01_25.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_01_25.jpg)'
- en: 'Figure 1.25: Output of anonymous loops example'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.25：匿名循环示例的输出
- en: Understanding loops is key to not only working with Vue but also with JavaScript
    in general. Now that we have covered how to handle loops by using the `v-for`
    syntax and the importance of binding the `:key` property to add reactivity to
    the content being looped, we will utilize this function in the next exercise.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 理解循环对于不仅使用Vue，而且一般使用JavaScript都是关键。现在我们已经介绍了如何使用`v-for`语法处理循环以及绑定`:key`属性以向循环内容添加响应性的重要性，我们将在下一个练习中利用这个功能。
- en: 'Exercise 1.08: Using v-for to Loop Over an Array of Strings'
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.08：使用v-for遍历字符串数组
- en: In this exercise, we are going to perform an anonymous loop using Vue's `v-for`
    directive. This will be familiar to those who have used `for` or `foreach` loops
    in JavaScript before.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用Vue的`v-for`指令执行匿名循环。这将对那些之前在JavaScript中使用过`for`或`foreach`循环的人很熟悉。
- en: To access the code files for this exercise, refer to [https://packt.live/390SO1J](https://packt.live/390SO1J).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅 [https://packt.live/390SO1J](https://packt.live/390SO1J)。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: 'Open a command-line terminal, navigate into the `Exercise1.08` folder, and
    run the following commands in order:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行终端，导航到 `Exercise1.08` 文件夹，并按顺序运行以下命令：
- en: '[PRE58]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Go to `https://localhost:8080`.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前往 `https://localhost:8080`。
- en: 'Compose the following syntax inside of `Exercise1-08.vue` by adding an `<h1>`
    title to your component and a `<ul>` element with an `<li>` tag which will have
    the `v-for` directive, which has the value of `n` as `5`:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在组件中添加 `<h1>` 标题和一个 `<ul>` 元素（其中包含一个 `<li>` 标签，该标签具有 `v-for` 指令，其值为 `n` 为
    `5`）来在 `Exercise1-08.vue` 内部编写以下语法：
- en: '[PRE59]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This will generate an output as follows:'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '![Figure 1.26: Iterating over arbitrary numbers will also allow you to output
    the index'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.26：遍历任意数字也将允许你输出索引'
- en: '](img/B15218_01_26.jpg)'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_01_26.jpg)'
- en: 'Figure 1.26: Iterating over arbitrary numbers will also allow you to output
    the index'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.26：遍历任意数字也将允许你输出索引
- en: 'Now let''s loop through an array of strings and count the iteration of our
    array with `n`. Prepare an array of your personal interests in the `data()` function.
    By looking for (`item, n`) inside the `interests` array, `item` outputs the string
    of the array, and `n` is the loop index:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们遍历一个字符串数组，并使用 `n` 计算数组的迭代次数。在 `data()` 函数中准备一个包含你个人兴趣的数组。通过在 `interests`
    数组中查找 (`item, n`)，`item` 输出数组的字符串，而 `n` 是循环索引：
- en: '[PRE60]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The following output is generated upon running the preceding code:'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行上述代码将生成以下输出：
- en: '![Figure 1.27: Iterating over an array of strings'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.27：遍历字符串数组'
- en: '](img/B15218_01_27.jpg)'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_01_27.jpg)'
- en: 'Figure 1.27: Iterating over an array of strings'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.27：遍历字符串数组
- en: In this exercise, we learned how to iterate over both an arbitrary number and
    a specific array of strings, outputting the string value or index of an array.
    We also learned that the key attribute needs to be unique to avoid DOM conflicts
    and forces the DOM to re-render the component properly.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何遍历任意数字和特定的字符串数组，输出数组的字符串值或索引。我们还了解到，键属性需要是唯一的，以避免 DOM 冲突并强制 DOM
    正确重新渲染组件。
- en: Iterating over Objects
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历对象
- en: When requesting data from an API, you will often be iterating over an array
    of objects that contains both logic and raw content. Vue makes it easy to control
    the data's various states through its directive syntax. Conditional directives
    control the display state of DOM elements in Vue. The HTML syntax provides clear
    visibility when it comes to the display rules set in your component.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 API 请求数据时，你通常会遍历包含逻辑和原始内容的对象数组。Vue 通过其指令语法使控制数据的各种状态变得简单。条件指令控制 Vue 中 DOM
    元素的显示状态。HTML 语法在你的组件中设置显示规则时提供了清晰的可见性。
- en: 'Exercise 1.09: Using a v-for Loop over an Array of Objects and Using Their
    Properties for v-if Conditions'
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.09：使用 v-for 循环遍历对象数组并使用它们的属性进行 v-if 条件
- en: In this exercise, we will be controlling a Vue data array and iterating over
    the objects inside of it.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将控制 Vue 数据数组，并遍历其内部的对象。
- en: To access the code files for this exercise, refer to [https://packt.live/32YokKa](https://packt.live/32YokKa).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅 [https://packt.live/32YokKa](https://packt.live/32YokKa)。
- en: 'Open a command-line terminal, navigate into the `Exercise1.09` folder, and
    run the following commands in order:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行终端，导航到 `Exercise1.09` 文件夹，并按顺序运行以下命令：
- en: '[PRE61]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Go to `https://localhost:8080`.
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前往 `https://localhost:8080`。
- en: 'Compose the following syntax inside `Exercise1-09.vue` and create a data object
    that contains a `title` string, and a `favorite` array of strings. We will loop
    over the `interests` object similarly to the array of strings; however, you will
    need to refer to the `title` key inside the `interests` object:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Exercise1-09.vue` 内部编写以下语法，并创建一个包含 `title` 字符串和 `favorite` 字符串数组的对象。我们将像遍历字符串数组一样遍历
    `interests` 对象；然而，你需要引用 `interests` 对象内的 `title` 键：
- en: '[PRE62]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The output of the preceding code will be as follows:'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行上述代码的输出将如下所示：
- en: '![Figure 1.28: You should see a list of titles now in the frontend'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.28：现在你应该在前端看到一系列标题'
- en: '](img/B15218_01_28.jpg)'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_01_28.jpg)'
- en: 'Figure 1.28: You should see a list of titles now in the frontend'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.28：现在你应该在前端看到一系列标题
- en: 'Let''s create a second `v-for` loop to iterate over your favorites list. Note
    that we use different keys— `fav` and `m`—for our nested loop. This is because
    you can still use the values `item` and `n` inside the nested loop context:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建第二个`v-for`循环来遍历你的收藏列表。注意，我们在嵌套循环中使用不同的键——`fav`和`m`——这是因为你仍然可以在嵌套循环的上下文中使用`item`和`n`的值：
- en: '[PRE63]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '*Figure 1.29* displays an output where looping is performed through an array
    of objects:'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图1.29* 显示了通过对象数组执行循环的输出：'
- en: '![Figure 1.29: Nested ordered list detailing your favorites'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.29：嵌套有序列表详细说明你的收藏'
- en: '](img/B15218_01_29.jpg)'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_01_29.jpg)'
- en: 'Figure 1.29: Nested ordered list detailing your favorites'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图1.29：嵌套有序列表详细说明你的收藏
- en: 'To optimize the DOM tree, we can use the `v-if` conditional directive from
    `Exercise 1.09` to hide unnecessary DOM elements:![Figure 1.30: Displaying empty
    DOM elements in your virtual DOM'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了优化DOM树，我们可以使用`Exercise 1.09`中的`v-if`条件指令来隐藏不必要的DOM元素：![图1.30：在虚拟DOM中显示空DOM元素
- en: '](img/B15218_01_30.jpg)'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_01_30.jpg)'
- en: 'Figure 1.30: Displaying empty DOM elements in your virtual DOM'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图1.30：在虚拟DOM中显示空DOM元素
- en: 'We will check whether there are more than `0` items in the array to display
    the ordered list HTML element. Add a `v-if` directive to the `<ol>` with the condition
    `item.favorite.length > 0`:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将检查数组中是否有超过`0`个元素以显示有序列表HTML元素。向`<ol>`添加一个`v-if`指令，条件为`item.favorite.length
    > 0`：
- en: '[PRE64]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This won't make a difference in the visuals of your page, but when you inspect
    the virtual DOM tree in your browser, you'll notice an HTML comment in dev mode
    allowing you to understand where a `v-if` statement might be `false`. When you
    build for production, these HTML comments won't be in your DOM.
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这不会影响你页面的视觉效果，但当你检查浏览器中的虚拟DOM树时，你会注意到在开发模式下有一个HTML注释，这允许你理解`v-if`语句可能为`false`的位置。当你为生产构建时，这些HTML注释不会出现在你的DOM中。
- en: '![Figure 1.31: Output displaying no HTML comment in production builds'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.31：显示生产构建中没有HTML注释的输出'
- en: '](img/B15218_01_31.jpg)'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_01_31.jpg)'
- en: 'Figure 1.31: Output displaying no HTML comment in production builds'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.31：显示生产构建中没有HTML注释的输出
- en: By using the `v-if` directive in dev mode, you will see an HTML comment. These
    will not exist in production builds.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在开发模式下使用`v-if`指令，你会看到一个HTML注释。这些在产品构建中不会存在。
- en: In this exercise we have been able to iterate over complex arrays of objects,
    outputting these objects' nested keys and controlling the view state of DOM elements
    based on length conditions.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们能够遍历复杂对象的数组，输出这些对象的嵌套键，并根据长度条件控制DOM元素的状态。
- en: Methods in Vue
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vue中的方法
- en: Vue methods are defined inside the `methods` object within the Vue instance
    and can be written like normal JavaScript functions where you define a piece of
    logic that is executed. When you use JavaScript functions, normally, you would
    either return a value or simply perform a global action. The primary difference
    between writing functions and Vue methods is that the Vue method is scoped to
    your Vue component and can be run from anywhere inside the component it was written
    inside. Since the methods are scoped to your component's Vue instance, you can
    reference them inside of event directives easily in the HTML template. When binding
    events to HTML elements in Vue, you would use the `@` symbol; for example, `v-on:click`
    is equivalent to `@click`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: Vue方法是在Vue实例内的`methods`对象中定义的，可以像正常的JavaScript函数一样编写，其中定义了一段要执行的逻辑。当你使用JavaScript函数时，通常你会返回一个值或者简单地执行一个全局操作。编写函数和Vue方法的主要区别在于Vue方法的作用域限定在你的Vue组件内，并且可以在组件内部任何位置运行。由于方法的作用域限定在组件的Vue实例内，你可以在HTML模板中轻松地通过事件指令引用它们。在Vue中绑定HTML元素的事件时，你会使用`@`符号；例如，`v-on:click`等同于`@click`。
- en: 'Exercise 1.10: Triggering Methods'
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.10：触发方法
- en: In this exercise, we are going to build a component that uses Vue's methods
    API. Consider how similar these Vue methods can be written like your own named
    functions in JavaScript, as they behave in a very similar way. By the end of the
    exercise, we should be able to use methods and trigger them from the HTML template.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将构建一个使用Vue方法API的组件。考虑这些Vue方法可以像你自己的命名函数一样编写，因为它们的行为非常相似。通过练习的结束，我们应该能够使用方法并在HTML模板中触发它们。
- en: To access the code files for this exercise, refer to [https://packt.live/3kMTWs5](https://packt.live/3kMTWs5).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/3kMTWs5](https://packt.live/3kMTWs5)。
- en: 'Open a command-line terminal and navigate into the `Exercise1.10` folder and
    run the following commands in order:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行终端，导航到 `Exercise1.10` 文件夹，并按顺序运行以下命令：
- en: '[PRE65]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Go to `https://localhost:8080`.
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 访问 `https://localhost:8080`。
- en: 'Let''s loop over a method trigger and pass its number to a method. Set up an
    anonymous `v-for` loop on an HTML list and add an anchor element inside of the
    list element. Set the loop to iterate `5` times:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们遍历一个方法触发器，并将它的数字传递给一个方法。在 HTML 列表上设置一个匿名 `v-for` 循环，并在列表元素内部添加一个锚元素。将循环设置为迭代
    `5` 次：
- en: '[PRE66]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Add the `@click` directive referencing a method called `triggerAlert` and pass
    the value of `n` as an argument. Output the value `n` into the anchor element
    using curly braces:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `triggerAlert` 的方法，并使用 `@click` 指令引用它，将 `n` 的值作为参数传递。使用花括号将值 `n` 输出到锚元素中：
- en: '[PRE67]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Inside the `methods` object, add the `triggerAlert(n)` key with the `n` argument.
    Inside this method, add an `alert` function, which will output the value `n` plus
    some static text:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `methods` 对象内部，添加一个带有 `n` 参数的 `triggerAlert(n)` 键。在这个方法内部，添加一个 `alert` 函数，它将输出值
    `n` 加上一些静态文本：
- en: '[PRE68]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Add styling inside the `<style>` tag at the bottom of the component, and set
    the `lang` attribute to `scss`:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件底部的 `<style>` 标签内添加样式，并将 `lang` 属性设置为 `scss`：
- en: '[PRE69]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Your page should feature a list of buttons that when clicked, trigger an alert
    with a message that contains the button number you clicked as follows:![Figure
    1.32: Output a list of triggers'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的页面应该包含一个按钮列表，当点击按钮时，会触发一个包含您点击的按钮编号的消息的警告，如下所示：![图 1.32：输出触发器列表]
- en: '](img/B15218_01_32.jpg)'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_01_32.jpg]'
- en: 'Figure 1.32: Output a list of triggers'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.32：输出触发器列表]'
- en: 'The following prompt is displayed when a trigger is clicked:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击触发器时，会显示以下提示：
- en: '![Figure 1.33: Displaying a browser alert with the index number in it'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.33：显示包含索引数字的浏览器警告]'
- en: '](img/B15218_01_33.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_01_33.jpg]'
- en: 'Figure 1.33: Displaying a browser alert with the index number in it'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.33：显示包含索引数字的浏览器警告]'
- en: Note
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While you can add an event directive to any HTML element, a suggestion would
    be applying them to native HTML interactive elements such as anchor tags, form
    input, or buttons to help with browser accessibility.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以将事件指令添加到任何 HTML 元素中，但建议将它们应用于原生 HTML 交互元素，如锚标签、表单输入或按钮，以帮助提高浏览器可访问性。
- en: In this exercise, we were able to utilize the Vue methods API to define and
    trigger methods from the HTML template, and parse arguments into each method dynamically.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们能够利用 Vue 方法 API 定义和从 HTML 模板触发方法，并将参数动态地解析到每个方法中。
- en: 'Exercise 1.11: Returning Data Using Vue Methods'
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.11：使用 Vue 方法返回数据
- en: In this exercise, we are going to learn how to use Vue methods as a function
    to return data in the Vue instance and inside of the template.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将学习如何将 Vue 方法作为一个函数在 Vue 实例和模板内部返回数据。
- en: Often in a web application, we want elements to appear on the page depending
    on whether a condition is met or not. For instance, if our product is not in stock,
    our page should display the fact that it is out of stock.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在 web 应用程序中，我们通常希望元素根据条件是否满足而出现在页面上。例如，如果我们的产品缺货，我们的页面应该显示缺货的事实。
- en: So, let's figure out how could we conditionally render these elements, depending
    on whether our product is in stock or not.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们弄清楚我们如何根据我们的产品是否有库存来有条件地渲染这些元素。
- en: To access the code files for this exercise, refer to [https://packt.live/3pHWCeh](https://packt.live/3pHWCeh).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅 [https://packt.live/3pHWCeh](https://packt.live/3pHWCeh)。
- en: 'Open a command-line terminal, navigate into the `Exercise1.11` folder, and
    run the following commands in order:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行终端，导航到 `Exercise1.11` 文件夹，并按顺序运行以下命令：
- en: '[PRE70]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Go to `https://localhost:8080`.
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 访问 `https://localhost:8080`。
- en: 'Let''s iterate over a random amount and trigger an `addToCart` method. Set
    up two data objects, `totalItems` and `totalCost`, which will be updated when
    a user clicks on our shop buttons. Next, refer to data objects inside the `script`
    block of Vue by specifying `this`. For example, in the `template` block, we refer
    to `totalItems` as `{{ totalItems }}`, but in the `script` block, we will refer
    to it as `this.totalItems`. The same pattern is used for methods where `addToCart`
    would be referred to as `this.addToCart` within another method:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们遍历一个随机金额并触发`addToCart`方法。设置两个数据对象`totalItems`和`totalCost`，当用户点击我们的购物按钮时，这些对象将被更新。接下来，通过指定`this`在Vue的`script`块中引用数据对象。例如，在`template`块中，我们将`totalItems`引用为`{{
    totalItems }}`，但在`script`块中，我们将它引用为`this.totalItems`。对于方法，使用相同的模式，其中`addToCart`将在另一个方法中引用为`this.addToCart`：
- en: '[PRE71]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This will generate an output as follows:'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '![Figure 1.34: Pressing any of the buttons will demonstrate the cart logic'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.34：按下任意按钮将演示购物车逻辑'
- en: '](img/B15218_01_34.jpg)'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_01_34.jpg)'
- en: 'Figure 1.34: Pressing any of the buttons will demonstrate the cart logic'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图1.34：按下任意按钮将演示购物车逻辑
- en: 'When you click the buttons, the items counter should increment by `1`, but
    the cost will increment by the `n` value, which should demonstrate normal cart
    functionality (clicking `Add 2`, then `Add 5`):'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你点击按钮时，项目计数器应该增加`1`，但成本将增加`n`值，这应该展示正常的购物车功能（点击`加2`，然后`加5`）：
- en: '![Figure 1.35: Output displaying Returning Methods after increments'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.35：显示递增后的返回方法的输出'
- en: '](img/B15218_01_35.jpg)'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_01_35.jpg)'
- en: 'Figure 1.35: Output displaying Returning Methods after increments'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图1.35：显示递增后的返回方法的输出
- en: 'Let''s talk money. We can use methods to perform logical operations that augment
    or format strings based on events. Create a method called `formatCurrency`, which
    accepts one argument. We will return the same value after giving it two decimal
    points and a `$` symbol. To use this method in the template, simply add it to
    the interpolated curly braces and pass the value that was there as an argument
    inside the method instead:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们谈谈金钱。我们可以使用方法来执行逻辑操作，根据事件增强或格式化字符串。创建一个名为`formatCurrency`的方法，它接受一个参数。我们将返回相同的值，在它后面加上两位小数和一个`$`符号。要在模板中使用此方法，只需将其添加到插值大括号中，并将方法内的值作为参数传递：
- en: '[PRE72]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The following screenshot displays the output of the preceding code:'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了前面代码的输出：
- en: '![Figure 1.36: Now all the values are expected to look like currency,'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.36：现在所有值都应看起来像货币，'
- en: while retaining the cart counter
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同时保留购物车计数器
- en: '](img/B15218_01_36.jpg)'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_01_36.jpg)'
- en: 'Figure 1.36: Now all the values are expected to look like currency, while retaining
    the cart counter'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.36：现在所有值都应看起来像货币，同时保留购物车计数器
- en: In this exercise, we were able to utilize Vue's methods API to parse arguments
    into methods, return modified values, and use methods to update the local data
    state in a life-like scenario.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们能够利用Vue的方法API将参数解析为方法，返回修改后的值，并在一个逼真的场景中使用方法来更新本地数据状态。
- en: Vue Lifecycle Hooks
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue生命周期钩子
- en: 'The Vue component lifecycle events include the following:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: Vue组件生命周期事件包括以下内容：
- en: '`beforeCreate`: Runs when your component has been initialized. `data` has not
    been made reactive and events are not set up in your DOM.'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeCreate`: 当你的组件被初始化时运行。`data`尚未变为响应式，DOM中的事件也没有设置。'
- en: '`created`: You will be able to access reactive data and events, but the templates
    and DOM are not mounted or rendered. This hook is generally good to use when requesting
    asynchronous data from a server since you will more than likely want this information
    as early as you can before the virtual DOM is mounted.'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created`: 你将能够访问响应式数据和事件，但模板和DOM尚未挂载或渲染。这个钩子通常在从服务器请求异步数据时很好用，因为你很可能希望在虚拟DOM挂载之前尽可能早地获取这些信息。'
- en: '`beforeMount`: A very uncommon hook as it runs directly before the first render
    of your component and is not called in **Server-Side Rendering**.'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeMount`: 这是一个非常不常见的钩子，因为它直接在组件首次渲染之前运行，并且在**服务器端渲染**中不会被调用。'
- en: '`mounted`: Mounting hooks are among the most common hooks you will use since
    they allow you to access your DOM elements so non-Vue libraries can be integrated.'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mounted`: 挂载钩子是你将最常使用的钩子之一，因为它们允许你访问你的DOM元素，以便集成非Vue库。'
- en: '`beforeUpdate`: Runs immediately after a change to your component occurs, and
    before it has been re-rendered. Useful for acquiring the state of reactive data
    before it has been rendered.'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeUpdate`：在组件发生变化后立即运行，在它被重新渲染之前。在渲染之前获取响应式数据的状态很有用。'
- en: '`updated`: Runs immediately after the `beforeUpdate` hook and re-renders your
    component with new data changes.'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updated`：在 `beforeUpdate` 钩子之后立即运行，并使用新的数据更改重新渲染你的组件。'
- en: '`beforeDestroy`: Fired directly before destroying your component instance.
    The component will still be functional until the destroyed hook is called, allowing
    you to stop event listeners and subscriptions to data to avoid memory leaks.'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeDestroy`：在销毁组件实例之前直接触发。组件在 destroyed 钩子被调用之前仍然可以正常工作，这允许你停止事件监听器和数据订阅以避免内存泄漏。'
- en: '`destroyed`: All the virtual DOM elements and event listeners have been cleaned
    up from your Vue instance. This hook allows you to communicate that to anyone
    or any element that needs to know this was completed.'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destroyed`：所有虚拟 DOM 元素和事件监听器都已从你的 Vue 实例中清理。此钩子允许你向任何需要知道此操作已完成的人或元素传达这一信息。'
- en: 'Exercise 1.12: Using Vue Lifecycles for Controlling Data'
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.12：使用 Vue 生命周期控制数据
- en: In this exercise, we will be learning how and when to use Vue's lifecycle hooks,
    and when they trigger by using JavaScript alerts. By the end of the exercise,
    we will be able to understand and use multiple Vue lifecycle hooks.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将学习如何以及何时使用 Vue 的生命周期钩子，以及它们通过 JavaScript alerts 触发的情况。到练习结束时，我们将能够理解和使用多个
    Vue 生命周期钩子。
- en: To access the code files for this exercise, refer to [https://packt.live/36N42nT](https://packt.live/36N42nT).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅 [https://packt.live/36N42nT](https://packt.live/36N42nT)。
- en: 'Open a command-line terminal, navigate into the `Exercise1.12` folder, and
    run the following commands in order:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行终端，导航到 `Exercise1.12` 文件夹，并按顺序运行以下命令：
- en: '[PRE73]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Go to `https://localhost:8080`.
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前往 `https://localhost:8080`。
- en: Note
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Feel free to swap the alert for `console.log()`.
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 随意将 alert 替换为 `console.log()`。
- en: 'Start by creating an array of data to iterate over in a list element, set the
    key to `n`, and output the value `{{item}}` inside of the `<li>` element using
    curly braces:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个数组来在列表元素中迭代，将键设置为 `n`，并在 `<li>` 元素内部使用花括号输出值 `{{item}}`：
- en: '[PRE74]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Add `beforeCreated()` and `created()` as functions below the `data()` function.
    Set an alert or console log inside these hooks so that you can see when they are
    being triggered:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 data() 函数下方添加 `beforeCreated()` 和 `created()` 作为函数。在这些钩子内部设置一个 alert 或 console
    log，以便你可以看到它们何时被触发：
- en: '[PRE75]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'When you refresh your browser, you should see both alerts before you can see
    your list load on the page:'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你刷新浏览器时，你应该在看到你的列表在页面上加载之前看到这两个 alert：
- en: '![Figure 1.37: Observe the beforeCreate() hook alert first'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.37：首先观察 beforeCreate() 钩子 alert]'
- en: '](img/B15218_01_37.jpg)'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_01_37.jpg)'
- en: 'Figure 1.37: Observe the beforeCreate() hook alert first'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.37：首先观察 beforeCreate() 钩子 alert
- en: 'The following screenshot displays the `created()` hook alert after the `beforeCreate()`
    hook:'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了在 beforeCreate() 钩子之后的 created() 钩子 alert：
- en: '![Figure 1.38: Observe the before() hook alert after the beforeCreate() hook'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.38：在 beforeCreate() 钩子之后观察 before() 钩子 alert]'
- en: '](img/B15218_01_38.jpg)'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_01_38.jpg)'
- en: 'Figure 1.38: Observe the before() hook alert after the beforeCreate() hook'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.38：在 beforeCreate() 钩子之后观察 before() 钩子 alert
- en: 'Add `beforeMount()` and `mounted()` as functions below the `created()` hook.
    Set an alert or console log inside of these hooks so you can see when they are
    being triggered:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 created() 钩子下方添加 `beforeMount()` 和 `mounted()` 作为函数。在这些钩子内部设置一个 alert 或 console
    log，以便你可以看到它们何时被触发：
- en: '[PRE76]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'When you refresh your browser, you should also see these alerts before you
    can see your list load on the page:'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你刷新浏览器时，你也应该在看到你的列表在页面上加载之前看到这些 alerts：
- en: '![Figure 1.39: Observe the beforeMount() hook alert after the create() hook'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.39：在 create() 钩子之后观察 beforeMount() 钩子 alert]'
- en: '](img/B15218_01_39.jpg)'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_01_39.jpg)'
- en: 'Figure 1.39: Observe the beforeMount() hook alert after the create() hook'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.39：在 create() 钩子之后观察 beforeMount() 钩子 alert
- en: 'The following screenshot displays the `mounted()` hook alert after the `beforeMount()`
    hook:'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了在 beforeMount() 钩子之后的 mounted() 钩子 alert：
- en: '![Figure 1.40: Observe alert mounted() hook alert after the beforeMount() hook'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.40：观察在 beforeMount() 钩子之后的 mounted() 钩子 alert]'
- en: '](img/B15218_01_40.jpg)'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_01_40.jpg)'
- en: 'Figure 1.40: Observe alert mounted() hook alert after the beforeMount() hook'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.40：观察在 beforeMount() 钩子之后的 mounted() 钩子 alert
- en: 'Add a new anchor element inside your `<li>` element that sits next to the item
    output. Use a `@click` directive to bind this button to a method called `deleteItem`
    and pass the `item` value as an argument:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`<li>`元素内部添加一个新的锚点元素，它位于项目输出旁边。使用`@click`指令将此按钮绑定到名为`deleteItem`的方法，并将`item`值作为参数传递：
- en: '[PRE77]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Add a method called `deleteItem` into a `methods` object above your hooks,
    but below the `data()` function. Inside this function, pass `value` as an argument
    and filter out items from the list array that do not match the value, then replace
    the existing list with the new list:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`hooks`下方添加一个名为`deleteItem`的方法到`methods`对象中，但位于`data()`函数下方。在这个函数中，将`value`作为参数传递，并从列表数组中过滤出与值不匹配的项，然后用新列表替换现有列表：
- en: '[PRE78]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Add styling inside the `<style>` tag at the bottom of the component, and set
    the `lang` attribute to `scss`:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件底部的`<style>`标签内添加样式，并将`lang`属性设置为`scss`：
- en: '[PRE79]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Add `beforeUpdate()` and `updated()` as functions below the `mounted()` hook
    and set an alert or console log inside these hooks so that you can see when they
    are being triggered:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mounted()`钩子下方添加`beforeUpdate()`和`updated()`作为函数，并在这些钩子内部设置一个警告或控制台日志，以便您可以查看它们何时被触发：
- en: '[PRE80]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: When you delete a list item by clicking the delete button in your browser, you
    should see these alerts.
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当您通过在浏览器中点击删除按钮删除列表项时，您应该看到这些警告。
- en: 'Add `beforeDestroy()` and `destroyed()` as functions below the `updated()`
    hook. Set an alert or console log inside these hooks so that you can see when
    they are being triggered:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`updated()`钩子下方添加`beforeDestroy()`和`destroyed()`作为函数。在这些钩子内部设置一个警告或控制台日志，以便您可以查看它们何时被触发：
- en: '[PRE81]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Add a new item to your `list` array:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向您的`list`数组添加一个新项：
- en: '[PRE82]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'You should also see the destroy alerts after the update alerts are shown in
    your browser after you have saved this change with localhost running. This will
    generate the following output:'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在您使用localhost运行并保存此更改后，在浏览器中显示更新警告之后，您还应该看到销毁警告。这将生成以下输出：
- en: '![Figure 1.41: Output displaying Vue Lifecycle hooks'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.41：显示Vue生命周期钩子的输出]'
- en: '](img/B15218_01_41.jpg)'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_01_41.jpg]'
- en: 'Figure 1.41: Output displaying Vue Lifecycle hooks'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图1.41：显示Vue生命周期钩子的输出
- en: 'Alerts will run at each lifecycle hook. Try deleting elements, adding new ones
    in the list array, and refreshing the page to see when each of these hooks occurs.
    This will generate an output as follows:![Figure 1.42: Displaying a message on
    every trigger'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个生命周期钩子都会运行警告。尝试删除元素，在列表数组中添加新元素，并刷新页面以查看每个这些钩子何时发生。这将生成以下输出：![图1.42：在每次触发时显示消息]
- en: '](img/B15218_01_42.jpg)'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_01_42.jpg]'
- en: 'Figure 1.42: Displaying a message on every trigger'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.42：在每次触发时显示消息
- en: An alert will trigger every time you manipulate something on the page, demonstrating
    each available Vue lifecycle.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 每次您在页面上操作某个元素时，都会触发一个警告，演示每个可用的Vue生命周期。
- en: Note
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`Mounted` and `created` lifecycle hooks will run every time a component loads.
    If this is not the desired effect, consider running the code you want to run once
    from the parent component or view, such as the `App.vue` file.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mounted`和`created`生命周期钩子将在组件每次加载时运行。如果这不是您期望的效果，请考虑在父组件或视图中运行您想要运行的代码一次，例如`App.vue`文件。'
- en: In this exercise, we learned what Vue lifecycle hooks are and when they trigger.
    This will be useful in combination with triggering methods and controlling data
    within your Vue components.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了Vue生命周期钩子是什么以及它们何时触发。这将与触发方法和控制Vue组件中的数据相结合非常有用。
- en: 'Activity 1.01: Building a Dynamic Shopping List App Using Vue.js'
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动一.01：使用Vue.js构建动态购物清单应用程序
- en: In this activity, we will build a dynamic shopping list app that will test your
    knowledge of Vue by using all the basic functions of an SFC, such as expressions,
    loops, two-way binding, and event handling.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将构建一个动态购物清单应用程序，通过使用SFC的所有基本功能来测试您对Vue的了解，例如表达式、循环、双向绑定和事件处理。
- en: This application should let users create and delete individual list items and
    clear the total list in one click.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序应允许用户创建和删除单个列表项，并一键清除整个列表。
- en: 'The following steps will help you complete the activity:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成活动：
- en: Build an interactive form in one component using an input bound to `v-model`.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用绑定到`v-model`的输入在一个组件中构建一个交互式表单。
- en: Add one input field that you can add shopping list items to. Allow users to
    add items by using the *Enter* key by binding a method to the `@keyup.enter` event.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个输入字段，您可以将购物清单项添加到其中。通过将方法绑定到`@keyup.enter`事件，允许用户使用*Enter*键添加项。
- en: Users can expect to clear the list by deleting all the items or removing them
    one at a time. To do so, you can use a `delete` method that can pass the array
    position as an argument, or simply overwrite the whole shopping list data prop
    to be an empty array `[]`.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户可以通过删除所有项目或逐个删除它们来清除列表。为此，你可以使用一个可以传递数组位置作为参数的 `delete` 方法，或者简单地覆盖整个购物清单数据属性，使其成为一个空数组
    `[]`。
- en: 'The expected outcome is as follows:'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的结果如下：
- en: '![](img/1.jpg)'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/1.jpg)'
- en: '![Figure 1.43: Final output'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.43：最终输出'
- en: '](img/B15218_01_43.jpg)'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_01_43.jpg)'
- en: 'Figure 1.43: Final output'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.43：最终输出
- en: Note
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor381).
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以通过[这个链接](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor381)找到。
- en: Summary
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned how to run a Vue project using the command
    prompt and to create basic Vue components. Within these Vue components, you can
    scaffold template that use Vue's unique directives and HTML syntax sugar to loop
    over data or control DOM states with conditional statements. Key concepts of reactive
    data through the use of data props and the `v-model` binding were explored and
    made useful in real-life examples that utilized Vue.js methods and lifecycles.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用命令提示符运行 Vue 项目以及如何创建基本的 Vue 组件。在这些 Vue 组件中，你可以构建模板，使用 Vue 的独特指令和
    HTML 语法糖来遍历数据或使用条件语句控制 DOM 状态。通过使用数据属性和 `v-model` 绑定，我们探讨了响应式数据的关键概念，并在利用 Vue.js
    方法和生命周期的实际示例中使其变得有用。
- en: 'In the next chapter, we will learn about more advanced reactive data concepts
    that will build upon this first chapter: using computed props and watchers and
    fetching asynchronous data from an external source.'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多高级的响应式数据概念，这些概念将建立在第一章的基础上：使用计算属性和监听器以及从外部源获取异步数据。
