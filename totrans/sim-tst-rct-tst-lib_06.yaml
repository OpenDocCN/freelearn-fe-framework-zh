- en: '*Chapter 6*: Implementing Additional Tools and Plugins for Testing'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：实现测试的额外工具和插件'
- en: In the previous chapters, we learned the basics of React Testing Library and
    how to test from simple to complex components using the tool. In this chapter,
    we will learn how to increase our productivity by using additional tools. We will
    install and use a few plugins to help our ability to write tests by avoiding common
    mistakes and following React Testing Library's best practices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了React Testing Library的基础知识以及如何使用该工具测试从简单到复杂的组件。在本章中，我们将学习如何通过使用额外的工具来提高我们的生产力。我们将安装并使用一些插件，以帮助我们避免常见错误并遵循React
    Testing Library的最佳实践。
- en: We will add a library to audit and increase application accessibility. We'll
    ensure we select the best React Testing Library query method with Testing Playground.
    Finally, we will increase our productivity by using Wallaby.js to receive rapid
    feedback on our tests' status from our code editor.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个库来审计并提高应用程序的可访问性。我们将确保我们使用Testing Playground选择最佳的React Testing Library查询方法。最后，我们将通过使用Wallaby.js从代码编辑器快速获取测试状态反馈来提高我们的生产力。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Using `eslint-plugin-testing-library` to follow best practices and avoid common
    mistakes when using React Testing Library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`eslint-plugin-testing-library`来遵循最佳实践，避免在使用React Testing Library时犯常见错误
- en: Using `eslint-plugin-jest-dom` to follow best practices and avoid common mistakes
    when using `jest-dom`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`eslint-plugin-jest-dom`来遵循最佳实践，避免在使用`jest-dom`时犯常见错误
- en: Using `jest-axe` to increase application accessibility
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`jest-axe`来提高应用程序的可访问性
- en: Selecting the Testing Library-recommended queries with Testing Playground
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Testing Playground选择Testing Library推荐的查询
- en: Increasing our testing productivity with Wallaby.js
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Wallaby.js提高我们的测试生产力
- en: The skills in this chapter will increase your productivity and enhance your
    ability to test React applications using Testing Library's best practices.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的技能将提高你的生产力，并增强你使用Testing Library最佳实践测试React应用程序的能力。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For the examples in this chapter, you will need to have Node.js installed on
    your machine. We will be using the `create-react-app` CLI tool for all code examples.
    Please familiarize yourself with the tool before starting this chapter, if required.
    Code snippets will be provided throughout the chapter to understand the code under
    test, but the objective is to understand how to test the code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的示例，你需要在你的机器上安装Node.js。我们将使用`create-react-app` CLI工具来展示所有代码示例。如果需要，请在开始本章之前熟悉这个工具。本章将提供代码片段来理解要测试的代码，但目标是理解如何测试代码。
- en: You can find code examples for this chapter at [https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter06](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter06).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter06](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter06)找到本章的代码示例。
- en: Implementing best practices with Testing Library ESLint plugins
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Testing Library ESLint插件实现最佳实践
- en: In this section, you will learn how to install and use `eslint-plugin-testing-library`
    and `eslint-plugin-jest-dom`. The purpose of these plugins is to audit your test
    code and help you to write tests that follow the best practices of `jest-dom`.
    The plugins work by highlighting areas that can be improved and providing recommendations
    to refactor your code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何安装和使用`eslint-plugin-testing-library`和`eslint-plugin-jest-dom`。这些插件的目的是对你的测试代码进行审计，并帮助你编写遵循`jest-dom`最佳实践的测试。插件通过突出可以改进的区域并提供重构代码的建议来工作。
- en: 'Before installing the plugins, we need to have **ESLint** installed in our
    project. ESLint is a tool that statistically analyzes and informs you of problems
    in your code. You can think of ESLint as having someone look over your shoulder
    to point out issues you might otherwise take longer to debug on your own. For
    example, you could create the following function:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装插件之前，我们需要在我们的项目中安装**ESLint**。ESLint是一个统计分析并通知你代码中问题的工具。你可以把ESLint想象成有人在你的肩膀上查看，指出你可能需要更长的时间自己调试的问题。例如，你可以创建以下函数：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, we have a `reverseWord` function that reverses a passed-in
    string. If we invoke the function with the word `packt`, we get the following
    result:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个`reverseWord`函数，该函数反转传入的字符串。如果我们用单词`packt`调用该函数，我们得到以下结果：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding code, we get a result of `tkcap` when we pass in `packt` as
    a parameter to the function. However, if we mistakenly misspell the function name
    and run the code, we get the following result:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，当我们将 `packt` 作为参数传递给函数时，我们得到的结果是 `tkcap`。然而，如果我们错误地拼写函数名称并运行代码，我们会得到以下结果：
- en: '![Figure 6.1 – The reverseWord function name typo](img/Figure_6.1_B16887.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – reverseWord 函数名称拼写错误](img/Figure_6.1_B16887.jpg)'
- en: Figure 6.1 – The reverseWord function name typo
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – reverseWord 函数名称拼写错误
- en: In the previous code, the console output indicates `ReferenceError`. The error
    refers to the interpreter not locating a defined function, called `reverseeWord`,
    in the file. The problem was that the user mistakenly added an extra `e` in the
    function name. We could create a better workflow by installing and configuring
    ESLint in our project to help debug issues.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，控制台输出指示 `ReferenceError`。错误指的是解释器没有在文件中找到定义的函数，名为 `reverseeWord`。问题在于用户错误地多加了一个
    `e` 在函数名称中。我们可以通过在我们的项目中安装和配置 ESLint 来创建一个更好的工作流程，以帮助调试问题。
- en: 'If you are using `create-react-app` for your project, then ESLint should automatically
    be installed for you. For projects that don''t already have ESLint installed,
    use the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 `create-react-app` 为你的项目，那么 ESLint 应该会自动为你安装。对于尚未安装 ESLint 的项目，请使用以下命令：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The previous command will install ESLint as a development dependency to your
    project.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将 ESLint 作为开发依赖项安装到你的项目中。
- en: 'Next, we can create a configuration file to tell ESLint how we want it to lint
    our files:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以创建一个配置文件来告诉 ESLint 我们希望它如何检查我们的文件：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The configuration file that was created in `json` format, in the previous code,
    has a few settings that tell ESLint how to lint our files. The `"extends"` key
    is set to `"eslint:recommended"`. This means that we want to use ESLint's recommended
    linting rules. The `"parserOptions"` key is set to an object with two keys. The
    `"ecmaVersion"` key is set to `"sourceType"` key is set to `"module"`, meaning
    our code will support ES modules. There are numerous ways ESLint can be configured
    to lint your project files.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中创建的以 `json` 格式的配置文件包含一些设置，告诉 ESLint 如何检查我们的文件。`"extends"` 键设置为 `"eslint:recommended"`。这意味着我们希望使用
    ESLint 推荐的检查规则。`"parserOptions"` 键设置为包含两个键的对象。`"ecmaVersion"` 键设置为 `"sourceType"`，`"module"`
    键设置为 `"module"`，这意味着我们的代码将支持 ES 模块。ESLint 可以以多种方式配置来检查你的项目文件。
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please refer to *Configuring ESLint* ([https://eslint.org/docs/user-guide/configuring/](https://eslint.org/docs/user-guide/configuring/))
    for more details.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 *配置 ESLint* ([https://eslint.org/docs/user-guide/configuring/](https://eslint.org/docs/user-guide/configuring/))
    获取更多详细信息。
- en: 'Use the following command to run ESLint against your project files:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令来运行 ESLint 检查你的项目文件：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the previous command, we use the `npx` command to run ESLint against all
    of the project files. Note that `npx` allows you to quickly execute `npm` packages
    regardless of whether the package is installed locally or globally on your machine
    or not installed at all. We receive the following output in the console after
    running the command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的命令中，我们使用 `npx` 命令来运行 ESLint 检查所有项目文件。请注意，`npx` 允许你快速执行 `npm` 包，无论该包是否已在本地的机器上本地或全局安装，或者根本未安装。在运行命令后，我们在控制台中收到以下输出：
- en: '![Figure 6.2 – ESLint output'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.2 – ESLint 输出](img/Figure_6.2_B16887.jpg)'
- en: '](img/Figure_6.2_B16887.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.2 – ESLint 输出](img/Figure_6.2_B16887.jpg)'
- en: Figure 6.2 – ESLint output
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – ESLint 输出
- en: In the previous command, ESLint informs us of two errors in our code. The first
    error says that the `reverseWord` function was never used on line `1`, referencing
    the `no-unused-vars` ESLint rule. The second error says that `reverseeWord` on
    line `3` is not defined anywhere in the file, referencing the `no-undef` ESLint
    rule. We can also enhance our ESLint workflow by displaying the output directly
    in our code editor to learn about any potential issues before running our code.
    For example, the VSCode and Atom code editors have third-party tools that we can
    install to display problems directly in the editor.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的命令中，ESLint 通知我们代码中有两个错误。第一个错误说 `reverseWord` 函数从未在行 `1` 上使用，引用了 ESLint 的
    `no-unused-vars` 规则。第二个错误说行 `3` 上的 `reverseeWord` 在文件中任何地方都没有定义，引用了 ESLint 的 `no-undef`
    规则。我们还可以通过在代码编辑器中直接显示输出来增强我们的 ESLint 工作流程，以在学习代码运行之前了解任何潜在的问题。例如，VSCode 和 Atom
    代码编辑器都有第三方工具，我们可以安装这些工具以在编辑器中直接显示问题。
- en: Note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please refer to *ESLint* ([https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint))
    for the VSCode editor extension. Alternatively, you can refer to *linter-eslint*
    ([https://atom.io/packages/linter-eslint](https://atom.io/packages/linter-eslint))
    for the Atom editor plugin for installation and configuration details.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅*ESLint*([https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint))以获取VSCode编辑器扩展的详细信息。或者，你可以查阅*linter-eslint*([https://atom.io/packages/linter-eslint](https://atom.io/packages/linter-eslint))以获取Atom编辑器插件的安装和配置细节。
- en: Displaying the linter output directly in the code editor provides faster feedback
    than manually running ESLint via the command line. Now that you understand how
    to get ESLint up and running, we will install and configure `eslint-plugin-testing-library`
    in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将lint输出直接显示在代码编辑器中比手动通过命令行运行ESLint提供更快的反馈。现在你已经了解了如何启动ESLint，我们将在下一节中安装和配置`eslint-plugin-testing-library`。
- en: Installing and configuring eslint-plugin-testing-library
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置eslint-plugin-testing-library
- en: 'In this section, we will learn how to install and configure `eslint-plugin-testing-library`
    inside our application. Install the plugin using the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在我们的应用程序中安装和配置`eslint-plugin-testing-library`。使用以下命令安装插件：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding command installs `eslint-plugin-testing-library` as a development
    dependency in your project. Now that the plugin is installed, we can add it to
    our ESLint configuration file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将`eslint-plugin-testing-library`作为开发依赖项安装到你的项目中。现在插件已安装，我们可以将其添加到我们的ESLint配置文件中：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the previous code, we created an `"overrides"` section in our ESLint configuration
    to target any files ending in `.test.js`. Then, we added `plugin:testing-library/react`
    to the `extends` array in the configuration file. We added the React version of
    the plugin to gain React-specific rules and the rules we get from DOM Testing
    Library's base rules. The plugin applies a particular set of linting rules that
    are specific to React applications. For example, the `no-dom-import` rule, which
    doesn't allow direct imports from DOM Testing Library, is useful because React
    Testing Library re-exports everything from DOM Testing Library, eliminating the
    need for direct imports.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在ESLint配置中创建了一个`"overrides"`部分，以针对以`.test.js`结尾的任何文件。然后，我们在配置文件中的`extends`数组中添加了`plugin:testing-library/react`。我们添加了插件的React版本以获得React特定的规则和来自DOM
    Testing Library的基本规则。该插件应用了一组特定的linting规则，这些规则专门针对React应用程序。例如，`no-dom-import`规则不允许直接从DOM
    Testing Library导入，这很有用，因为React Testing Library重新导出DOM Testing Library的所有内容，消除了直接导入的需要。
- en: Note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please refer to *Supported Rules* ([https://github.com/testing-library/eslint-plugin-testing-library#supported-rules](https://github.com/testing-library/eslint-plugin-testing-library#supported-rules))
    for a complete list of React-specific applied rules.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅*支持规则*([https://github.com/testing-library/eslint-plugin-testing-library#supported-rules](https://github.com/testing-library/eslint-plugin-testing-library#supported-rules))以获取React特定应用的规则完整列表。
- en: 'Note that the `react-app` entry is also included in the array. The `react-app`
    entry adds ESLint rules that have been set up by `create-react-app`. Now that
    we have the plugin set up in the project, we can write tests. We will test a drop-down
    component that allows a user to select a programming language:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`react-app`入口也被包含在数组中。`react-app`入口添加了由`create-react-app`设置的ESLint规则。现在我们在项目中设置了插件，我们可以编写测试。我们将测试一个允许用户选择编程语言的下拉组件：
- en: '![Figure 6.3 – The drop-down component'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 – 下拉组件'
- en: '](img/Figure_6.3_B16887.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.3_B16887.jpg)'
- en: Figure 6.3 – The drop-down component
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 下拉组件
- en: 'In the preceding screenshot, you can see a dropdown that lists four programing
    languages that a user can click on to choose. When a user selects a language,
    we get the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你可以看到一个下拉列表，列出了用户可以点击以选择四种编程语言。当用户选择一种语言时，我们会得到以下内容：
- en: '![Figure 6.4 – The selected drop-down option](img/Figure_6.4_B16887.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – 选定的下拉选项](img/Figure_6.4_B16887.jpg)'
- en: Figure 6.4 – The selected drop-down option
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 选定的下拉选项
- en: 'Here, you can view the text **You selected: JavaScript**, which appears when
    a user selects the **JavaScript** option. We can write a test to verify that the
    selected language displays on the screen:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以查看文本**你选择了：JavaScript**，这是当用户选择**JavaScript**选项时出现的。我们可以编写一个测试来验证所选语言是否显示在屏幕上：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, first, we render the `LanguageDropdown` component in
    the DOM. Next, we click on the **Programming Language** button. Then, we select
    **JavaScript** from the menu options. Next, we will verify that the selected option
    is displayed on the screen:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们在DOM中渲染了`LanguageDropdown`组件。接下来，我们点击了**编程语言**按钮。然后，我们从菜单选项中选择**JavaScript**。接下来，我们将验证所选选项是否显示在屏幕上：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, we use the `waitFor` method from React Testing Library
    to get the element with the text that includes the selected option. The `waitFor`
    method can be used when you need to wait for an element in the DOM. However, according
    to `eslint-plugin-testing-library`, `waitFor` is not the best way to select an
    element in this situation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用React Testing Library的`waitFor`方法来获取包含所选选项的文本的元素。当需要等待DOM中的元素时，可以使用`waitFor`方法。然而，根据`eslint-plugin-testing-library`，在这种情况下使用`waitFor`并不是选择元素的最佳方式：
- en: '![Figure 6.5 – The findByRole linter suggestion'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5 – findByRole代码检查建议](img/Figure_6.5_B16887.jpg)'
- en: '](img/Figure_6.5_B16887.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5 – findByRole代码检查建议](img/Figure_6.5_B16887.jpg)'
- en: Figure 6.5 – The findByRole linter suggestion
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – findByRole代码检查建议
- en: In the previous screenshot, the code that includes the `waitFor` method is underlined
    by ESLint, drawing our attention to the code issue. When we hover over the `waitFor`
    method code, we get feedback indicating that the preferred query is `findByRole`
    via the `prefer-find-by` rule of `eslint-plugin-testing-library`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的屏幕截图中，包含`waitFor`方法的代码被ESLint下划线标注，引起了我们的注意。当我们悬停在`waitFor`方法代码上时，我们得到反馈，表明首选的查询是`findByRole`，这是通过`eslint-plugin-testing-library`的`prefer-find-by`规则实现的。
- en: In [*Chapter 5*](B16887_05_Final_PG_ePub.xhtml#_idTextAnchor083), *Refactoring
    Legacy Applications with React Testing Library*, we learned how to use the `findByRole`
    query to select elements that need time to appear on the screen. The `prefer-find-by`
    rule is a `fixable` rule; this means that we can select to have the problem code
    automatically fixed for us.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B16887_05_Final_PG_ePub.xhtml#_idTextAnchor083)，“使用React Testing Library重构遗留应用程序”，我们学习了如何使用`findByRole`查询来选择需要时间出现在屏幕上的元素。`prefer-find-by`规则是一个可修复的规则；这意味着我们可以选择让问题代码自动为我们修复。
- en: 'One easy way to automatically fix issues is by setting up your code editor
    to automatically resolve any fixable issues when saving a file. Please refer to
    the documentation of your respective code editor for instructions. If, for some
    reason, your editor does not have a *fix on save* feature, you can run `eslint
    --fix` in the command line or use pre-commit hooks via `git`. As a last resort,
    you always have the option of referring to the `eslint-plugin-testing-library`
    documentation, which is related to the `prefer-find-by` rule and others, for suggestions.
    Once we refactor the problem code, we get the following output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 自动修复问题的简单方法是将代码编辑器设置为在保存文件时自动解决任何可修复的问题。请参阅您各自代码编辑器的文档以获取说明。如果由于某种原因，您的编辑器没有“保存时修复”功能，您可以在命令行中运行`eslint
    --fix`或通过`git`使用预提交钩子。作为最后的手段，您始终可以选择参考与`eslint-plugin-testing-library`相关的文档，其中包括`prefer-find-by`规则和其他规则的建议。一旦我们重构了问题代码，我们得到以下输出：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, the `waitFor` code is replaced with the `findByRole`
    query method. The code has a cleaner syntax that behaves similarly to the `waitFor`
    code and satisfies the linter rules. Finally, we assert that the selected code
    is in the document.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，将`waitFor`代码替换为`findByRole`查询方法。该代码具有更简洁的语法，其行为类似于`waitFor`代码，并满足代码检查规则。最后，我们断言所选代码在文档中。
- en: 'Some rules are not automatically enabled with the React version of `eslint-plugin-testing-library`.
    For example, in previous versions of React Testing Library, it was common to see
    selectors written as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一些规则在`eslint-plugin-testing-library`的React版本中不是自动启用的。例如，在React Testing Library的先前版本中，常见的选择器编写方式如下：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, we access the query methods by destructuring them off
    the rendered component. The latest React Testing Library versions suggest using
    the `screen` object to access query methods for a better user experience. The
    `screen` object allows you to access query methods using your editor''s autocomplete
    feature rather than undergoing explicit destructuring via the rendered component.
    We can add the `prefer-screen-queries` rule to our ESLint configuration file to
    enforce this way of selecting query methods:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过解构渲染的组件来访问查询方法。最新的 React Testing Library 版本建议使用 `screen` 对象来访问查询方法，以获得更好的用户体验。`screen`
    对象允许您使用编辑器的自动完成功能来访问查询方法，而不是通过渲染组件进行显式的解构。我们可以将 `prefer-screen-queries` 规则添加到我们的
    ESLint 配置文件中，以强制执行这种选择查询方法的方式：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we added a `"rules"` key to the configuration file. The
    `"rules"` key is used when we want to add specific rules to enforce our code.
    Inside the `"rules"` key, we add the `"testing-library/prefer-screen-queries"`
    key, which is set to `"error"`. If we had our project set up with a linting script
    to run ESLint across our files, the error would trigger an exit code to stop file
    execution, making it clear that the current code is not acceptable for use.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在配置文件中添加了一个 `"rules"` 键。当我们要添加特定的规则来强制执行我们的代码时，会使用 `"rules"` 键。在 `"rules"`
    键内部，我们添加了 `"testing-library/prefer-screen-queries"` 键，并将其设置为 `"error"`。如果我们有一个项目设置了一个运行
    ESLint 的 linting 脚本来跨文件运行，错误将触发一个退出代码来停止文件执行，从而清楚地表明当前代码不适合使用。
- en: 'Now, with this rule in place, the previous code using destructuring will be
    flagged by ESLint:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了这个规则，使用解构的先前代码将被 ESLint 标记：
- en: '![Figure 6.6 – The prefer-screen-queries linter suggestion'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.6 – prefer-screen-queries 检查器建议'
- en: '](img/Figure_6.6_B16887.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.6_B16887.jpg)'
- en: Figure 6.6 – The prefer-screen-queries linter suggestion
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – prefer-screen-queries 检查器建议
- en: In the previous screenshot, `getByRole` is underlined by ESLint to draw our
    attention to the query issue. When we hover over the query, we get feedback indicating
    that the preferred approach uses `screen` to query DOM elements via the `prefer-screen-queries`
    rule of `eslint-plugin-testing-library`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，`getByRole` 被 ESLint 下划线标记，以引起我们对查询问题的注意。当我们悬停在查询上时，我们会得到反馈，表明首选的方法使用
    `screen` 通过 `eslint-plugin-testing-library` 的 `prefer-screen-queries` 规则来查询 DOM
    元素。
- en: 'Unlike the `prefer-find-by` rule in the previous example, `prefer-screen-queries`
    is not a *fixable* rule. This means that we will need to fix the code manually.
    When we refactor the code, we get the following result:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个示例中的 `prefer-find-by` 规则不同，`prefer-screen-queries` 不是一个可修复的规则。这意味着我们需要手动修复代码。当我们重构代码时，我们会得到以下结果：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The DOM selectors have been refactored to use the `screen` object in the preceding
    code, satisfying the `prefer-screen-queries` rule. The code also looks cleaner
    compared to the version using destructured query methods.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，DOM 选择器已经被重构为使用 `screen` 对象，满足了 `prefer-screen-queries` 规则。与使用解构查询方法的版本相比，代码看起来也更简洁。
- en: 'In some situations, we might want rules that provide a warning compared to
    an error when ESLint runs across project files. The warning won''t stop code execution;
    however, instead, it will serve as a reminder to the user to remove the file''s
    highlighted code before committing the code. For example, it is common to use
    the `debug` method to view the current state of the DOM as we build tests:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能希望规则在 ESLint 在项目文件中运行时提供警告而不是错误。警告不会停止代码执行；然而，它将作为对用户的一个提醒，在提交代码之前移除文件中突出显示的代码。例如，在构建测试时，使用
    `debug` 方法查看当前 DOM 的状态是很常见的：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the previous code, the `debug` method is used for logging the current DOM
    output to the console after rendering the `LanguageDropdown` component. The `debug`
    method will be highlighted in the editor, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`debug` 方法用于在渲染 `LanguageDropdown` 组件后，将当前 DOM 输出记录到控制台。`debug` 方法将在编辑器中突出显示，如下所示：
- en: '![Figure 6.7 – The no-debug linter suggestion'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.7 – no-debug 检查器建议'
- en: '](img/Figure_6.7_B16887.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.7_B16887.jpg)'
- en: Figure 6.7 – The no-debug linter suggestion
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – no-debug 检查器建议
- en: In the preceding screenshot, `debug` is underlined by ESLint to draw our attention
    to an issue with the query. When we hover over the query, we get feedback indicating
    the method should be removed via the `no-debug` rule of `eslint-plugin-testing-library`.
    We often forget to remove the console's logging code before committing work, so
    the `no-debug` rule serves as a helpful reminder to remove it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Now you know how to install and configure ESLint with `eslint-plugin-testing-library`
    to help avoid issues and follow best practices while writing tests.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will go a step further by installing another plugin
    that is specific to `jest-dom`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring eslint-plugin-jest-dom
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we installed and configured ESLint and `eslint-plugin-testing-library`.
    In this section, we will teach you how to install and configure `eslint-plugin-jest-dom`,
    ensuring we follow the best practices using `jest-dom`. Use the following command
    to install the plugin:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The previous command installs `eslint-plugin-jest-dom` as a development dependency
    inside the project. Now that the plugin is installed, we can add it to our ESLint
    configuration file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the previous code, we added `plugin:jest-dom/recommended` to the `extends`
    array in the configuration file. The `recommended` configuration for the plugin
    is used to automatically include a set of standard rules to enforce `jest-dom`
    best practices. We will test a `checkbox` component that allows the user to select
    their preferred programming languages:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – The languages checkbox component'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.8_B16887.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 – The languages checkbox component
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, you can see that there are four checkboxes for
    programming languages that a user can select from. When a user selects a language,
    we get the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – The selected language checkbox'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.9_B16887.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9 – The selected language checkbox
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, the user selects **JavaScript**, which results
    in the associated checkbox being selected, the text color changing to *green,*
    and the font-weight changing to *bold*. We can write a test to verify that the
    checkbox for the selected language is selected and has the expected classes associated
    with the color and font-weight of the text the user sees on the screen:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding code, we render the `LanguageCheckBox` component to the DOM.
    Next, we get the `jsCheckbox` variable, and click on it. Next, we will make assertions
    on the expected output. First, we try using the `toHaveAttribute` Jest matcher:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code, we use `toHaveAttribute` to verify that the checkbox
    has the `checked` attribute after being clicked. However, our test will fail with
    this matcher because it only looks for an explicit `checked` attribute that is
    added to the elements commonly used in situations where we want a prechecked checkbox.
    In our case, we''re testing the result of a user clicking on the checkbox in the
    resulting DOM, so we need a different matcher. Next, we try using the `toHaveProperty`
    Jest matcher:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding code, we use the `toHaveProperty` Jest matcher to verify that
    the checkbox has the `checked` property set to `true`. This matcher works in a
    technical sense, but it doesn''t read very clearly. Additionally, when we hover
    over the matcher, we get the following output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – The prefer-checked linter suggestion'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.10_B16887.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.10 – The prefer-checked linter suggestion
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, the `toHaveProperty` matcher is underlined by
    ESLint to draw our attention to the matcher''s issue. When we hover over the matcher,
    we get feedback indicating it should be replaced with the `jest-dom` `toBeChecked`
    matcher via the `prefer-checked` rule of `eslint-plugin-jest-dom`. The rule is
    automatically fixable and will refactor the matcher for us if we have our code
    editor set up. When we refactor our matcher, we get the following output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, we use the `toBeChecked` `jest-dom` matcher to verify
    that the checkbox is checked. Now we have a matcher that eliminates any issues
    with previous matcher versions and also reads a lot better. Next, we will assert
    the expected classes:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding code, we access the `className` property inside the element
    with the `javascript` text to verify that it contains the `text-success` and `font-weight-bold`
    classes. However, when we hover over `toContain`, we get the following feedback:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – The prefer-to-have-class linter suggestion'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.11_B16887.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.11 – The prefer-to-have-class linter suggestion
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, the `toContain` matcher is underlined by ESLint
    to draw our attention to the matcher''s issue. When we hover over the matcher,
    we get feedback indicating that it should be replaced with the `jest-dom` `toHaveClass`
    matcher via the `prefer-to-have-class` rule of `eslint-plugin-jest-dom`. Similar
    to the previous example, the `prefer-to-have-class` rule is automatically fixable
    and will refactor the matcher for us if we have our code editor set up to do so.
    When we refactor the code, we get the following output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, we refactored our code to use the `jest-dom` `toHaveClass`
    matcher. Now we have a matcher that is easier to implement and read compared to
    our original example.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Now you understand how to install and use the `eslint-plugin-jest-dom` plugin
    to use assertion matchers that follow the `jest-dom` best practices. In the next
    section, we will learn how to install and use a package to increase the accessibility
    of our component's source code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何安装和使用 `eslint-plugin-jest-dom` 插件来使用遵循 `jest-dom` 最佳实践的断言匹配器。在下一节中，我们将学习如何安装和使用一个包来提高我们组件源代码的易访问性。
- en: Testing accessibility with jest-axe
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 jest-axe 测试易访问性
- en: 'In this section, we will learn how to use a tool that is designed to help improve
    the accessibility of our features. There are many tools available that can help
    increase accessibility by automating the process of auditing and reporting issues,
    such as Wave ([https://wave.webaim.org/](https://wave.webaim.org/)) and Lighthouse
    ([https://developers.google.com/web/tools/lighthouse](https://developers.google.com/web/tools/lighthouse)).
    However, there is no single tool that can guarantee accessibility across an entire
    application. Accessibility auditing tools are helpful, but they do not replace
    the need for manual accessibility auditing done by a human. For example, when
    an abbreviation is used for the first time in a line of text, the related expanded
    version should be included:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用一个旨在帮助我们改进功能易访问性的工具。有许多工具可以帮助通过自动化审计和报告问题的过程来提高易访问性，例如 Wave ([https://wave.webaim.org/](https://wave.webaim.org/))
    和 Lighthouse ([https://developers.google.com/web/tools/lighthouse](https://developers.google.com/web/tools/lighthouse))。然而，没有单个工具可以保证整个应用程序的易访问性。易访问性审计工具是有帮助的，但它们不能取代由人类进行的手动易访问性审计的需求。例如，当在文本行中首次使用缩写时，应包括相关的扩展版本：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding sentence, the expanded version, `Structured Query Language`,
    is included with its abbreviated form, `SQL`. The sentence would need to be manually
    checked to verify accessibility. We will learn how to use `jest-axe`, which is
    a tool that adds a custom matcher for Jest and behaves in ways that are similar
    to ESLint. The tool helps find and report common accessibility issues in your
    code, such as image buttons with no alternate text or `inputs` with no associated
    labels. Use the following command to install the tool:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的句子中，扩展版本 `结构化查询语言` 与其缩写形式 `SQL` 一起包含。该句子需要手动检查以验证易访问性。我们将学习如何使用 `jest-axe`，这是一个为
    Jest 添加自定义匹配器并具有与 ESLint 类似行为的工具。该工具有助于在您的代码中查找和报告常见的易访问性问题，例如没有替代文本的图像按钮或没有相关标签的
    `inputs`。使用以下命令安装此工具：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The previous command installs `jest-axe` as a development dependency inside
    the project. Now that the tool is installed, we can use it in our tests. First,
    we will test the accessibility of an image button:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令在项目中安装了 `jest-axe` 作为开发依赖。现在工具已安装，我们可以在测试中使用它。首先，我们将测试图像按钮的易访问性：
- en: '![Figure 6.12 – An inaccessible image button](img/Figure_6.12_B16887.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.12 – 一个不可访问的图像按钮](img/Figure_6.12_B16887.jpg)'
- en: Figure 6.12 – An inaccessible image button
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – 一个不可访问的图像按钮
- en: 'In the preceding screenshot, we have an image that behaves as a **Submit**
    button. The following is the source code for the image button:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们有一个作为 **提交** 按钮行为的图像。以下是该图像按钮的源代码：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding code, we will import an image and pass it as `source` for
    an input of the `image` type. Now we will write a test to verify that the element
    is accessible to users:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将导入一个图像并将其作为 `image` 类型的输入的 `source`。现在我们将编写一个测试来验证该元素对用户是可访问的：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding code, first, we import the `render` method from React Testing
    Library. Then, we import the `axe` method from `jest-axe`. The `axe` method is
    what we will use to audit the accessibility of our component. Next, we import
    `jest-axe/extend-expect`, which adds a special matcher to Jest to report the audit
    outcome in a readable format. Finally, we import the `NoAccessibility` component
    to test. Next, we will write the main test code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们从 React Testing Library 中导入 `render` 方法。然后，我们从 `jest-axe` 中导入 `axe`
    方法。`axe` 方法是我们将用来审计我们组件的易访问性的方法。接下来，我们导入 `jest-axe/extend-expect`，它为 Jest 添加了一个特殊的匹配器，以便以可读的格式报告审计结果。最后，我们导入
    `NoAccessibility` 组件进行测试。接下来，我们将编写主要的测试代码：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, first, we destructure `container` off the rendered component.
    Unlike query methods, we can destructure `container` off the rendered component
    without violating DOM Testing Library's best practices because it is not available
    on the `screen` object. `container` is the `div` element that wraps your React
    component under test.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Next, we pass `container` as an argument to the `axe` method and store it in
    the `results` variable. The `axe` method will run an accessibility audit across
    our component under test. Finally, we assert that the results have no accessibility
    issues using the `toHaveNoViolations` matcher. The test will pass if no violations
    are found.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if violations are found, the test will fail and provide feedback to
    resolve those issues. When we run the test, we get the following output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Inaccessible image button test output'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.13_B16887.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.13 – Inaccessible image button test output
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screenshot shows that accessibility violations were found in
    the `NoAccessibility` component, which resulted in a test failure with feedback.
    First, the feedback indicates that an `input` element is the source of the issue.
    Next, we see the entire element printed on the screen. Then, we get the `"Image
    buttons must have alternate text (input-image-alt)"` message, informing us why
    the element failed the audit. Next, we get several suggestions that we can implement
    to resolve the issue. Finally, we get a hyperlink that we can follow to gain a
    deeper understanding of the issue. We will resolve the issue by providing an `alt`
    attribute:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding code, we added an `alt` attribute with the value of `login`.
    Now, when we rerun our test, we get the following result:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Accessible image button test output'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.14_B16887.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.14 – Accessible image button test output
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, the test results indicate that `NoAccessibility,
    given accessibility audit, returns no violations` passes with no violations. Next,
    we will test the accessibility of a list that includes an image:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – An inaccessible list'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.15_B16887.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.15 – An inaccessible list
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, we have an unordered list that includes an `image`
    element. The following is the source code for the list:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding code, we have an unordered list element with two `list item`
    child elements and one `image` child element. Our test code will be the same as
    the previous test for the image button. The only difference here is the component
    that we pass into the `render` method. So, for this example, we will only focus
    on the test results:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – Inaccessible list test results](img/Figure_6.16_B16887.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – Inaccessible list test results
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows that accessibility violations were found in the
    unordered list component, which resulted in a test failure with feedback. First,
    the feedback indicates that a `ul` element is the source of the issue. Next, we
    see the entire element printed on the screen. Then, we get the `"<ul> and <ol>
    must only directly contain <li>, <script> or <template> elements (list)"` message,
    which helps us to understand why the element failed the audit.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we get a suggestion regarding how to resolve the issue. Finally, we get
    a hyperlink that we can follow to gain a deeper understanding of the issue. We
    will resolve the issue by moving the image inside an `li` element:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the previous code, we wrapped the `image` element inside an `li` element.
    When we rerun our test, the test will pass and return results that are similar
    to what we saw in the image button's previous test. Now you know how to use `jest-axe`
    to increase the accessibility of applications using React with Jest. It is important
    to reiterate that automated accessibility tools help increase our applications'
    ability to work for various end users. However, they cannot catch all issues and
    are not a replacement for manual audits.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how to use a tool to speed up our element selections with
    React Testing Library.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the best queries with Testing Playground
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to use **Testing Playground**. This is a
    tool that makes it easier for you to determine the right DOM Testing Library query
    selector. Testing Playground allows you to paste HTML into an interactive website,
    which allows you to click on elements as they appear rendered in the browser.
    This enables you to learn which DOM Testing Library queries can be used to select
    a particular element.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'The tool always suggests queries in order, based on the DOM Testing Library
    query recommendations for elements that offer multiple ways of selection. Furthermore,
    the tool allows you to copy the selector to use in your test code. We will look
    at two ways of using Testing Playground: first, via the website, and second, via
    a Chrome extension.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Selecting queries using the Testing Playground website
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will learn how to use Testing Playground via its website.
    In previous examples throughout the book, we used the `debug` method to log the
    resulting HTML of components to the console while writing tests. One limitation
    of the `debug` method is that it has no feature that enables you to log the output
    to the browser and test out different query methods to select elements.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `logTestingPlaygroundURL` method inside a test file to log the
    resulting HTML to a browser via *Testing Playground* ([https://testing-playground.com/](https://testing-playground.com/))
    and utilize the site''s query selector features. For example, we could be in the
    process of selecting elements in a test for the following `MoreInfoPopover` component:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – The Popover component'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.17_B16887.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.17 – The Popover component
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, we have a `button` element with the text `button`
    element using DOM Testing Library queries, so we start our test as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We import the `render` and `screen` methods from React Testing Library and
    the component under test in the preceding code. Inside the main test code, first,
    we render the component in the DOM. Next, we call the `logTestingPlaygroundURL`
    method. When we run the test, we get the following output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18 – The Testing Playground link](img/Figure_6.18_B16887.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: Figure 6.18 – The Testing Playground link
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, we have a unique link to the Testing Playground
    website to follow and view our component''s rendered HTML. When we follow the
    link, we should see something similar to the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19 – The Testing Playground HTML structure'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.19_B16887.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.19 – The Testing Playground HTML structure
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, the link navigated us to the Testing Playground
    website. First, we see a section that includes the HTML structure for our component.
    Next, we see the rendered browser output, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.20 – The Testing Playground browser output](img/Figure_6.20_B16887.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: Figure 6.20 – The Testing Playground browser output
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, we can see a section with the browser output for
    our component. Notice that we don''t see the complete result with associated styles
    included. The Testing Playground website only displays the HTML content. Next,
    we see a **suggested query** section, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.21 – Testing Playground suggested query'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.21_B16887.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.21 – Testing Playground suggested query
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we get a `button` element we clicked on in the
    browser output section. The `getByRole` query is the best way to select the button
    based on its HTML structure. Additionally, we can see the **This is great. Ship
    it!** message, which suggests that we should use this query further.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also other options available, as shown in the following screenshot,
    to select the element:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.22 – Testing Playground query priority options'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.22_B16887.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.22 – Testing Playground query priority options
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, we can see multiple options to select the element in
    order of priority. Based on the HTML structure of the `button` element, there
    are two ways we could choose the element – *by its role* and *by its text value*.
    The other listed queries are not available for the button and, therefore, display
    **n/a**. If we decide to select the **Text** query option, we should see something
    similar to the following screenshot:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.23 – The Testing Playground text query option'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.23_B16887.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.23 – The Testing Playground text query option
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we can see the text `getByText` to select the button,
    it is not the best query for the selected element. Once we decide on the query
    we want to grab the element, we can click on the icon displayed on the far right
    of the **suggested query** box to copy the code needed to select the element within
    our test.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Now you know how to use the `logTestingPlaygroundURL` method to select elements
    using the Testing Playground website. There is one notable limitation to using
    the Testing Playground website. When we click on the **More Info** button, we
    should see a popup appear beneath the button. We cannot use the Testing Playground
    website to perform this action since it only copies the HTML and not the associated
    JavaScript to render the result of clicking on the button.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to use the Testing Playground Chrome
    extension to overcome this limitation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Selecting queries using the Testing Playground Chrome extension
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will install and use the Testing Playground Chrome extension
    to overcome the limitations of using the Testing Playground website. This extension
    provides the benefit of allowing you to use Testing Playground features locally,
    in the same browser that is used to run your application. The extension is currently
    only available for the Google Chrome browser, so be sure to install it if necessary.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Install the *Testing Playground Chrome extension* ([https://chrome.google.com/webstore/detail/testing-playground/hejbmebodbijjdhflfknehhcgaklhano](https://chrome.google.com/webstore/detail/testing-playground/hejbmebodbijjdhflfknehhcgaklhano))
    via the Chrome Web Store. Once the extension is installed, a new **Testing Playground**
    tab is added to your **Chrome Developer Tools**.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the `MoreInfoPopover` component from the previous section, we
    can write a test to verify that the popover is displayed when a user clicks on
    the **More Info** button:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding code, we render `MoreInfoPopover` in the DOM. Next, we will
    use the Testing Playground extension to find the preferred query selector for
    the button:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.24 – The Testing Playground Chrome extension'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.24_B16887.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.24 – The Testing Playground Chrome extension
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous screenshot, we can see a tab added for the `getByRole` query
    selector. When we copy the selector, we get the query code to add to our test:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding code, we copied the `getByRole` selector to access the **More
    Info** button. Next, we will use the extension to help select the popover, which
    is displayed after clicking on the button:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.25 – The popover query selector](img/Figure_6.25_B16887.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: Figure 6.25 – The popover query selector
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, `getByRole` is the suggested query for the `popover`
    element after selecting it in the browser. Now we have all the selectors that
    we need to write the remaining test code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the preceding code, first, we click on the `popover` element by its heading
    and store it in a variable. Notice that we used `findByRole` instead of the `getByRole`
    query. Testing Playground only provides `getBy*` queries, so it might be necessary
    to modify the copied query based on the situation. Finally, we assert that the
    `popover` element is in the DOM. When we run the test, we get the following result:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.26 – The popover test results'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.26_B16887.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.26 – The popover test results
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: In the previous screenshot, the results indicate that the `MoreInfoPopover,
    given clicked button, displays popover` test passes as expected. Now you know
    how to install and use the Testing Playground Chrome extension to enhance your
    workflow when writing tests. The Testing Playground website and extension are
    great supporting tools to utilize when working with DOM Testing Library.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to use a tool that will speed up the
    results feedback from beginning to completion when writing tests.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Increasing our testing productivity with Wallaby.js
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to increase our productivity by using the
    Wallaby.js productivity tool. Wallaby.js works by automatically running your tests
    behind the scenes via a Headless Chrome browser. There is also the option to run
    tests in other environments, such as Node.js or Phantom.js, with a custom configuration
    file. Wallaby.js helps to speed up your workflow by providing immediate test results
    inside your code editor, so you can type without needing to save and run a test
    script to view the results.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Wallaby.js provides many features, such as the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '**Time Travel Debugging**: This allows you to navigate through your code to
    pinpoint bug sources easily.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test Story Viewer**: This provides the ability to view the code associated
    with your test on one compact screen.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inline Code Coverage**: This informs you of the test coverage for each line
    of code inside the code editor.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Please refer to the *Features* section ([https://wallabyjs.com/#features](https://wallabyjs.com/#features))
    on the Wallaby.js documentation website for a complete list of features.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Installing and configuring Wallaby.js
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will learn how to install and set up Wallaby.js for the
    Visual Studio Code editor. Please refer to the *Install* section ([https://wallabyjs.com/download/](https://wallabyjs.com/download/))
    on the Wallaby.js documentation website for a complete list of installation options.
    To get started, add the Wallaby.js VSCode extension to your editor via the *VSCode
    Marketplace* ([https://marketplace.visualstudio.com/items?itemName=WallabyJs.wallaby-vscode](https://marketplace.visualstudio.com/items?itemName=WallabyJs.wallaby-vscode)).
    Once the extension has been installed, we can configure it to work in our project.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The quickest and easiest way to configure Wallaby.js is with automatic configuration.
    Projects using specific versions of tools such as `create-react-app version 3`
    or greater, or `Jest version 24` or greater, qualify for automatic configuration.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: For projects that do not qualify for automatic configuration, please refer to
    the *Configuration File* section ([https://wallabyjs.com/docs/intro/config.html?editor=vsc#configuration-file](https://wallabyjs.com/docs/intro/config.html?editor=vsc#configuration-file))
    in the Wallaby.js documentation for specific configurations based on your project
    setup.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Start Wallaby.js in VSCode with automatic configuration using the command palette:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.27 – Select Configuration'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.27_B16887.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.27 – Select Configuration
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, `wallaby` is entered into the command palette
    to bring up the available Wallaby.js commands. We will click on the **Wallaby.js:
    Select Configuration** option:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.28 – The Automatic Configuration option'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.28_B16887.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.28 – The Automatic Configuration option
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, we have selected the **Automatic Configuration
    <project directory>** and **Automatic Configuration <custom directory>** options.
    We will select **<project directory>** to use the directory of our current project.
    Once we select the configuration, Wallaby.js will start and run our tests to provide
    feedback directly inside the test files of the code editor, as shown in the following
    screenshot:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.29 – Wallaby.js enhanced test output'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.29_B16887.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.29 – Wallaby.js enhanced test output
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we can see a test that we created earlier, in the
    *Selecting the best queries with Testing Playground* section of this chapter,
    enhanced with Wallaby.js' features. First, we see green-colored square shapes
    to the left of the line numbers indicating that all the test lines have passed.
    Next, we see links for the Wallaby.js **Debug**, **View Story**, **Profile**,
    and **Focus** features, which we can click on to analyze the test from the perspective
    of that particular feature.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we see the test runtime, `45ms`, logged next to the test. Now you understand
    how to install and configure Wallaby.js. You should also understand the basic
    enhancements that Wallaby.js adds directly inside the test files.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will walk through how to write a test utilizing Wallaby.js's
    Interactive Test Output feature.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests with Interactive Test Output
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Selecting the best queries with Testing Playground* section of this
    chapter, we wrote the `MoreInfoPopover, given clicked button, displays popover`
    test for a `MoreInfoPopover` component. Let's walk through how to create the same
    test utilizing Wallaby.js.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will render the component under test in the DOM and use the `debug`
    method to log the current state of the HTML output:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.30 – The Wallaby.js inline debug output'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.30_B16887.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.30 – The Wallaby.js inline debug output
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we used the `//?` command from Wallaby.js to log
    the results of `debug` directly inside the code editor. The output is automatically
    displayed horizontally to the right of `debug` when we hover over the method.
    This feature speeds up our workflow because, normally, we would have to execute
    our test runner from the command line to see the output.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will add queries to select the DOM elements:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.31 – A query error'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.31_B16887.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.31 – A query error
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we have a test failure resulting from React Testing
    Library not finding a `heading` element named `lorem ipsum`. Wallaby.js increases
    our ability to discover the error in two ways. First, we see a red-colored square
    shape to the left of the test name and, specifically, the line number where the
    error occurred. The inline code notifications help us to quickly identify where
    we should focus on pinpointing the cause of the error. Second, when we hover over
    the `test` method, React Testing Library's test result output is displayed directly
    in the code editor.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'This feature speeds up our workflow because Wallaby.js reruns our test and
    provides feedback any time we add new code to the test. Furthermore, we don''t
    even have to save our test file to gain feedback. We can also view test feedback
    in the **Wallaby.js Tests** console:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.32 – The Wallaby.js Tests console](img/Figure_6.32_B16887.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: Figure 6.32 – The Wallaby.js Tests console
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we can see similar React Testing Library feedback
    to what we see directly in the editor anytime code is updated in the test file,
    but now it is in an expanded view. Additionally, we can see the number of failing
    tests compared to passing tests, and clickable links for `Launch Coverage & Test
    Explorer`, which is a feature that allows you to see visualized test coverage
    for each file, and `Search Test`, which is a feature that allows you to quickly
    search for any test in the project.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'After debugging the failure with the help of Wallaby.js'' in-editor features,
    we learned that the `heading` element with the name of `lorem ipsum` is not immediately
    displayed. Using our knowledge of Testing Library queries, we can determine that
    the element should be selected using an asynchronous `findBy*` query:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the preceding code, we update the selector to `findByRole`. Immediately
    after updating the selector, we get feedback within the editor:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.33 – Query refactor'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.33_B16887.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.33 – Query refactor
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we see green-colored square shapes to the left
    of all of the line numbers. This indicates that we have successfully refactored
    the test code to a working state. We have also written an assertion to verify
    that the test passes as expected. Now you know how to use Wallaby.js to gain instant
    editor feedback and test debugging capabilities. Using Wallaby.js is a great tool
    to have when you need to save time running and debugging tests.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has taught you the benefits of using ESLint plugins to follow the
    DOM Testing Library and `jest-dom` best practices. You have gained an understanding
    of accessible code and used `jest-axe` to increase the accessibility of your applications.
    You have learned how to speed up the process of determining the best query method
    with Testing Playground. Finally, you have learned how to increase test writing
    productivity with Wallaby.js.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about end-to-end UI testing using the popular
    Cypress framework.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Install and configure the React-specific version of `eslint-plugin-testing-library`
    into a project and add additional rules.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create examples of `jest` assertions using matchers that don't use `jest-dom`
    best practices. Then, install and configure `eslint-plugin-jest-dom` inside a
    project and use it as a guide to correct highlighted issues.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a few components with accessibility issues, install and run `jest-axe`
    against the components and use the feedback to fix them.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit three of your favorite websites and use Testing Playground to see how
    many elements you can select using DOM Testing Library's preferred `byRole*` queries.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Wallaby.js and log how quickly you can write a test using its in-editor
    features.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
