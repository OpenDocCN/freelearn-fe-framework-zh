["```js\n<h1 contenteditable>I'm an editable title</h1>\n<p>I can't be edited</p>\n```", "```js\nconst h1 = document.querySelector('h1');\nh1.addEventListener('input',(event)=>console.log(h1.textContent);\n```", "```js\nimport {Component, ViewChild, Input, Output, ViewEncapsulation, EventEmitter, HostBinding, HostListener} from '@angular/core';\nimport template from './editor.html!text';\n\n@Component({\n  selector: 'ngc-editor',\n  host: {\n    class: 'editor'\n  },\n  template,\n  encapsulation: ViewEncapsulation.None\n})\nexport class Editor {\n  // Using view child reference with local view variable name\n  @ViewChild('editableContentElement') editableContentElement;\n  // Content that will be edited and displayed\n  @Input() content;\n  // Creating a host element class attribute binding from the \n  // editMode property\n  @Input() @HostBinding('class.editor--edit-mode') editMode;\n  @Input() showControls;\n  @Output() editSaved = new EventEmitter();\n  @Output() editableInput = new EventEmitter();\n\n  // We need to make sure to reflect to our editable element if \n  // content gets updated from outside\n  ngOnChanges() {\n    if (this.editableContentElement && this.content) {\n      this.setEditableContent(this.content);\n    }\n  }\n\n  ngAfterViewInit() {\n    this.setEditableContent(this.content);\n  }\n\n  // This returns the content of our content editable\n  getEditableContent() {\n    return this.editableContentElement.nativeElement.textContent;\n  }\n\n  // This sets the content of our content editable\n  setEditableContent(content) {\n    this.editableContentElement.nativeElement.textContent = \n      content;\n  }\n\n  // This annotation will create a click event listener on the \n  // host element that will invoke the underlying method\n  @HostListener('click')\n  focusEditableContent() {\n    if (this.editMode) {\n      this.editableContentElement.nativeElement.focus();\n    }\n  }\n\n  // Method that will be invoked if our editable element is \n  // changed\n  onInput() {\n    // Emit a editableInput event with the edited content\n    this.editableInput.next(this.getEditableContent());\n  }\n\n  // On save we reflect the content of the editable element into \n  // the content field and emit an event\n  save() {\n    this.editSaved.next(this.getEditableContent());\n    this.setEditableContent(this.content);\n    // Setting editMode to false to switch the editor back to \n    // viewing mode\n    this.editMode = false;\n  }\n\n  // Canceling the edit will not reflect the edited content and \n  // switch back to viewing mode\n  cancel() {\n    this.setEditableContent(this.content);\n    this.editableInput.next(this.getEditableContent());\n    this.editMode = false;\n  }\n\n  // The edit method will initialize the editable element and set \n  // the component into edit mode\n  edit() {\n    this.editMode = true;\n  }\n}\n```", "```js\n@ViewChild('editableContentElement') editableContentElement;\n```", "```js\n@Input() content;\n@Input() @HostBinding('class.editor--edit-mode') editMode;\n@Input() showControls;\n\n```", "```js\n@Output() editSaved = new EventEmitter();\n@Output() editableInput = new EventEmitter();\n\n```", "```js\ngetEditableContent() {\n  return this.editableContentElement.nativeElement.textContent;\n   }\n\nsetEditableContent(content) {\n  this.editableContentElement.nativeElement.textContent = \n    content;\n}\n```", "```js\nngOnChanges() {\n if (this.editableContentElement && this.content) {\n this.setEditableContent(this.content);\n }\n}\n\n```", "```js\nsave() {\n this.editSaved.next(this.getEditableContent());\n this.setEditableContent(this.content);\n  this.editMode = false;\n}\n\ncancel() {\n this.setEditableContent(this.content);\n this.editableInput.next(this.getEditableContent());\n  this.editMode = false;\n}\n```", "```js\nedit() {\n this.editMode = true;\n}\n```", "```js\n@HostListener('click')\nfocusEditableContent() {\n  if (this.editMode) {\n this.editableContentElement.nativeElement.focus();\n  }\n}\n```", "```js\n<div (input)=\"onInput($event)\"\n     class=\"editor__editable-content\"\n     contenteditable=\"true\"\n #editableContentElement></div>\n<div class=\"editor__output\">{{content}}</div>\n<div *ngIf=\"showControls && !editMode\" class=\"editor__controls\">\n  <button (click)=\"edit()\" class=\"editor__icon-edit\"></button>\n</div>\n<div *ngIf=\"showControls && editMode\" class=\"editor__controls\">\n  <button (click)=\"save()\" class=\"editor__icon-save\"></button>\n  <button (click)=\"cancel()\" class=\"editor__icon-cancel\"></button>\n</div>\n```", "```js\nimport {Pipe} from '@angular/core';\n// We use the Moment.js library to convert dates to relative times\nimport Moment from 'moment';\n\n@Pipe({\n  // Specifying the name to be used within templates\n name: 'fromNow'\n})\n// Our pipe will transform dates and timestamps to relative times \n// using Moment.js\nexport class FromNowPipe {\n  // The transform method will be called when the pipe is used \n  // within a template\n  transform(value) {\n if (value && (value instanceof Date || \n typeof value === 'number')) {\n return new Moment(value).fromNow();\n }\n }\n}\n```", "```js\n<div class=\"comment__l-meta\">\n  <div class=\"comment__user-picture\">\n    <img [attr.src]=\"user.pictureDataUri\" src=\"\">\n  </div>\n  <div class=\"comment__user-name\">{{user.name}}</div>\n  <div class=\"comment__time\">\n {{time | fromNow}}\n  </div>\n</div>\n<div class=\"comment__l-main\">\n  <div class=\"comment__message\">\n <ngc-editor [content]=\"content\"\n [showControls]=\"true\"\n (editSaved)=\"onContentSaved($event)\">\n </ngc-editor>\n  </div>\n</div>\n```", "```js\nimport {Component, Input, Output, ViewEncapsulation, EventEmitter} from '@angular/core';\nimport {Editor} from '../../ui/editor/editor';\nimport template from './comment.html!text';\n// We use our fromNow pipe that converts timestamps to relative \n// times\nimport {FromNowPipe} from '../../pipes/from-now';\n\n@Component({\n  selector: 'ngc-comment',\n  host: {\n    class: 'comment'\n  },\n  template,\n  encapsulation: ViewEncapsulation.None,\n directives: [Editor],\n pipes: [FromNowPipe]\n})\nexport class Comment {\n  // The time of the comment as a timestamp\n  @Input() time;\n  // The user object of the user who created the comment\n  @Input() user;\n  // The comment content\n  @Input() content;\n  // If a comment was edited this event will be emitted\n @Output() commentEdited = new EventEmitter();\n\n onContentSaved(content) {\n this.commentEdited.next(content);\n }\n}\n```", "```js\n<div class=\"comments__title\">Add new comment</div>\n<div class=\"comments__add-comment-section\">\n  <div class=\"comments__add-comment-box\">\n <ngc-editor [editMode]=\"true\"\n [showControls]= \"false\"></ngc-editor>\n  </div>\n  <button (click)=\"addNewComment()\"\n          class=\"button\" >Add comment</button>\n</div>\n\n<div *ngIf=\"comments?.length > 0\">\n  <div class=\"comments__title\">All comments</div>\n  <ul class=\"comments__list\">\n    <li *ngFor=\"let comment of comments\">\n      <ngc-comment [content]=\"comment.content\"\n [time]=\"comment.time\"\n [user]=\"comment.user\"\n (commentEdited)=\"onCommentEdited(comment, $event)\">\n </ngc-comment>\n    </li>\n  </ul>\n</div>\n```", "```js\nimport {Component, Inject, Input, Output, ViewEncapsulation, ViewChild, EventEmitter} from '@angular/core';\nimport template from './comments.html!text';\nimport {Editor} from '../ui/editor/editor';\nimport {Comment} from './comment/comment';\nimport {UserService} from '../user/user-service/user-service';\n\n@Component({\n  selector: 'ngc-comments',\n  host: {\n    class: 'comments'\n  },\n  template,\n  encapsulation: ViewEncapsulation.None,\n directives: [Comment, Editor]\n})\nexport class Comments {\n  // A list of comment objects\n @Input() comments;\n  // Event when the list of comments have been updated\n @Output() commentsUpdated = new EventEmitter();\n  // We are using an editor for adding new comments and control it \n  // directly using a reference\n @ViewChild(Editor) newCommentEditor;\n\n  // We're using the user service to obtain the currently logged \n  // in user\n  constructor(@Inject(UserService) userService) {\n    this.userService = userService;\n  }\n\n  // We use input change tracking to prevent dealing with \n  // undefined comment list\n ngOnChanges(changes) {\n if (changes.comments && \n changes.comments.currentValue === undefined) {\n this.comments = [];\n }\n }\n\n  // Adding a new comment from the newCommentContent field that is \n  // bound to the editor content\n  addNewComment() {\n    const comments = this.comments.slice();\n    comments.splice(0, 0, {\n user: this.userService.currentUser,\n      time: +new Date(),\n content: this.newCommentEditor.getEditableContent()\n    });\n    // Emit event so the updated comment list can be persisted \n    // outside the component\n this.commentsUpdated.next(comments);\n    // We reset the content of the editor\n this.newCommentEditor.setEditableContent('');\n  }\n\n  // This method deals with edited comments\n  onCommentEdited(comment, content) {\n    const comments = this.comments.slice();\n    // If the comment was edited with e zero length content, we \n    // will delete the comment from the list\n    if (content.length === 0) {\n      comments.splice(comments.indexOf(comment), 1);\n    } else {\n      // Otherwise we're replacing the existing comment\n      comments.splice(comments.indexOf(comment), 1, {\n        user: comment.user,\n        time: comment.time,\n        content\n      });\n    }\n    // Emit event so the updated comment list can be persisted \n    // outside the component\n this.commentsUpdated.next(comments);\n  }\n}\n```", "```js\n@Input() comments;\n\n```", "```js\n@Output() commentsUpdated = new EventEmitter();\n\n```", "```js\n@ViewChild(Editor) newCommentEditor;\n\n```", "```js\nconstructor(@Inject(UserService) userService) {\n this.userService = userService;\n}\n\n```", "```js\nngOnChanges(changes) {\n  if (changes.comments && \n          changes.comments.currentValue === undefined) {\n    this.comments = [];\n  }\n}\n```", "```js\naddNewComment() {\n  const comments = this.comments.slice();\n  comments.splice(0, 0, {\n user: this.userService.currentUser,\n    time: +new Date(),\n content: this.newCommentEditor.getEditableContent()\n  });\n this.commentsUpdated.next(comments);\n this.newCommentEditor.setEditableContent('');\n}\n```", "```js\nonCommentEdited(comment, content) {\n  const comments = this.comments.slice();\n  if (content.length === 0) {\n    comments.splice(comments.indexOf(comment), 1);\n  } else {\n    comments.splice(comments.indexOf(comment), 1, {\n      user: comment.user,\n      time: comment.time,\n      content\n    });\n  }\n  this.commentsUpdated.next(comments);\n}\n```", "```js\n...\n<ngc-tabs>\n  <ngc-tab name=\"Tasks\">...</ngc-tab>\n  <ngc-tab name=\"Comments\">\n <ngc-comments [comments]=\"comments\"\n (commentsUpdated)=\"updateComments($event)\">\n </ngc-comments>\n  </ngc-tab>\n  <ngc-tab name=\"Activities\"></ngc-tab>\n</ngc-tabs>\n```", "```js\nexport class Project {\n  ...\n @Input() comments;\n  ...\n updateComments(comments) {\n this.projectUpdated.next({\n comments\n });\n }\n}\n```"]