["```js\n    $ npm install --save-dev @cucumber/cucumber puppeteer \n    $ npm install --save-dev @babel/register\n    ```", "```js\n    {\n      \"default\": {\n        \"publishQuiet\": true,\n        \"requireModule\": [\n          \"@babel/register\"\n        ]\n      }\n    }\n    ```", "```js\n$ npx cucumber-js\n```", "```js\n0 scenarios\n0 steps\n0m00.000s\n```", "```js\n$ npx cucumber-js features/drawing.feature:5\n```", "```js\n    Feature: Sharing\n      A user can choose to present their session to any \n      number of other users, who observe what the \n      presenter is doing via their own browser.\n      Scenario: Observer joins a session\n        Given the presenter navigated to the application page\n        And the presenter clicked the button 'startSharing'\n        When the observer navigates to the presenter's sharing link\n        Then the observer should see a message saying 'You are now watching the session'\n    ```", "```js\n    ? Given the presenter navigated to the application page\n       Undefined. Implement with the following snippet:\n         Given('the presenter navigated to the application page', function () {\n           // Write code here that turns the phrase above\n           // into concrete actions\n           return 'pending';\n         });\n    ```", "```js\n    import {\n      Given, When, Then\n    } from \"@cucumber/cucumber\";\n    import puppeteer from \"puppeteer\";\n    const port = process.env.PORT || 3000;\n    const appPage = `http://localhost:${port}/index.xhtml`;\n    Given(\n      \"the presenter navigated to the application page\",\n      async function () {\n        const browser = await puppeteer.launch();\n        const page = await browser.newPage();\n        await page.goto(appPage);\n      }\n    );\n    ```", "```js\n    import {\n      setWorldConstructor\n    } from \"@cucumber/cucumber\";\n    class World {\n      constructor() {\n        this.pages = {};\n      }\n      setPage(name, page) {\n        this.pages[name] = page;\n      }\n      getPage(name) {\n        return this.pages[name];\n      }\n    };\n    setWorldConstructor(World);\n    ```", "```js\n    Given(\n      \"the presenter navigated to the application page\",\n      async function () {\n        const browser = await puppeteer.launch();\n        const page = await browser.newPage();\n        await page.goto(appPage);\n        this.setPage(\"presenter\", page);\n      }\n    );\n    ```", "```js\n    Given(\n      \"the presenter clicked the button {string}\",\n      async function (buttonId) {\n        await this.getPage(\n          \"presenter\"\n        ).click(`button#${buttonId}`);\n      }\n    );\n    ```", "```js\n    When(\n      \"the observer navigates to the presenter's sharing link\",\n      async function () {\n        await this.getPage(\n          \"presenter\"\n        ).waitForSelector(\"a\");\n        const link = await this.getPage(\n          \"presenter\"\n        ).$eval(\"a\", a => a.getAttribute(\"href\"));\n        const url = new URL(link);\n        const browser = await puppeteer.launch();\n        const page = await browser.newPage();\n        await page.goto(url);\n        this.setPage(\"observer\", page);\n      }\n    );\n    ```", "```js\n    import expect from \"expect\";\n    ...\n    Then(\n      \"the observer should see a message saying {string}\",\n      async function (message) {\n        const pageText = await this.getPage(\n          \"observer\"\n        ).$eval(\"body\", e => e.outerHTML);\n        expect(pageText).toContain(message);\n      }\n    );\n    ```", "```js\n    1) Scenario: Observer joins a session\n       ✖ Given the presenter navigated to the application page\n            Error: net::ERR_CONNECTION_REFUSED at http://localhost:3000/index.xhtml\n    ```", "```js\nimport { app } from \"../../server/src/app\";\nclass World {\n  ...\n  startServer() {\n    const port = process.env.PORT || 3000;\n    this.server = app.listen(port);\n  }\n  closeServer() {\n    Object.keys(this.pages).forEach(name =>\n      this.pages[name].browser().close()\n    );\n    this.server.close();\n  }\n}\n```", "```js\n    import { Before, After } from \"@cucumber/cucumber\";\n    Before(function() {\n      this.startServer();\n    });\n    After(function() {\n      this.closeServer();\n    });\n    ```", "```js\n    > npx cucumber-js\n    ......\n    1 scenario (1 passed)\n    4 steps (4 passed)\n    0m00.848s\n    ```", "```js\n    async browseToPageFor(role, url) {\n      const browser = await puppeteer.launch();\n      const page = await browser.newPage();\n      await page.goto(url);\n      this.setPage(role, page);\n    }\n    ```", "```js\n    import puppeteer from \"puppeteer\";\n    ```", "```js\n    Given(\n      \"the presenter navigated to the application page\",\n      async function () {\n        await this.browseToPageFor(\"presenter\", appPage);\n      }\n    );\n    When(\n      \"the observer navigates to the presenter's sharing link\",\n      async function () {\n        await this.getPage(\n          \"presenter\"\n        ).waitForSelector(\"a\");\n        const link = await this.getPage(\n          \"presenter\"\n        ).$eval(\"a\", a => a.getAttribute(\"href\"));\n        const url = new URL(link);\n        await this.browseToPageFor(\"observer\", url);\n      }\n    );\n    ```", "```js\n    Feature: Drawing\n      A user can draw shapes by entering commands\n      at the prompt.\n      Scenario: Drawing functions\n        Given the user navigated to the application page\n        When the user enters the following instructions at the prompt:\n          | to drawsquare |\n          |   repeat 4 [ forward 10 right 90 ] |\n          | end |\n          | drawsquare |\n        Then these lines should have been drawn:\n          | x1 | y1 | x2 | y2 |\n          | 0  | 0  | 10 | 0  |\n          | 10 | 0  | 10 | 10 |\n          | 10 | 10 | 0  | 10 |\n          | 0  | 10 | 0  | 0  |\n    ```", "```js\n    const port = process.env.PORT || 3000;\n    ```", "```js\n    appPage() {\n      return `http://localhost:${port}/index.xhtml`;\n    }\n    ```", "```js\n    Given(\n      \"the presenter navigated to the application page\",\n      async function () {\n        await this.browseToPageFor(\n          \"presenter\",\n          this.appPage()\n        );\n      }\n    );\n    ```", "```js\n    import {\n      Given,\n      When,\n      Then\n    } from \"@cucumber/cucumber\";\n    import expect from \"expect\";\n    Given(\"the user navigated to the application page\",\n      async function () {\n        await this.browseToPageFor(\n          \"user\",\n          this.appPage()\n        );\n      }\n    );\n    ```", "```js\n    1) Scenario: Drawing functions\n      ✔ Before # features/support/sharing.steps.js:5\n      ✔ Given the user navigated to the application page\n      ? When the user enters the following instructions at the prompt:\n        | to drawsquare |\n        |   repeat 4 [ forward 10 right 90 ] |\n        | end |\n        | drawsquare |\n      Undefined. Implement with the following snippet:\n      When('the user enters the following instructions at the prompt:',\n        function (dataTable) {\n          // Write code here that turns the phrase above\n          // into concrete actions\n          return 'pending';\n        }\n      );\n    ```", "```js\n    When(\n      \"the user enters the following instructions at the prompt:\",\n      function (dataTable) {\n        // Write code here that turns the phrase above\n        //into concrete actions\n        return \"pending\";\n      }\n    );\n    ```", "```js\n    When(\n      \"the user enters the following instructions at the prompt:\",\n      async function (dataTable) {\n        for (let instruction of dataTable.raw()) {\n          await this.getPage(\"user\").type(\n            \"textarea\",\n            `${instruction}\\n`\n          );\n        }\n      }\n    );\n    ```", "```js\n    Then(\"these lines should have been drawn:\",\n      async function(dataTable) {\n        await this.getPage(\"user\").waitForTimeout(2000);\n        const lines = await this.getPage(\"user\").$$eval(\n          \"line\",\n          lines => lines.map(line => {\n            return {\n              x1: parseFloat(line.getAttribute(\"x1\")),\n              y1: parseFloat(line.getAttribute(\"y1\")),\n              x2: parseFloat(line.getAttribute(\"x2\")),\n              y2: parseFloat(line.getAttribute(\"y2\"))\n            };\n          })\n        );\n        for (let i = 0; i < lines.length; ++i) {\n          expect(lines[i].x1).toBeCloseTo(\n            parseInt(dataTable.hashes()[i].x1)\n          );\n          expect(lines[i].y1).toBeCloseTo(\n            parseInt(dataTable.hashes()[i].y1)\n          );\n          expect(lines[i].x2).toBeCloseTo(\n            parseInt(dataTable.hashes()[i].x2)\n          );\n          expect(lines[i].y2).toBeCloseTo(\n            parseInt(dataTable.hashes()[i].y2)\n          );\n        }\n      }\n    });\n    ```"]