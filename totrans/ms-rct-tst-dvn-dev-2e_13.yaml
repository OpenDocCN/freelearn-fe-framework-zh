- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test-Driving GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**GraphQL** offers an alternative to HTTP requests for fetching data. It offers
    a whole bunch of additional features that can be added to data requests.'
  prefs: []
  type: TYPE_NORMAL
- en: As with Redux, GraphQL systems can seem complicated, but TDD helps to provide
    an approach to understanding and learning.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll use the `CustomerHistory` component that displays details
    of a single customer and their appointment history.
  prefs: []
  type: TYPE_NORMAL
- en: This is a bare-bones GraphQL implementation that shows the fundamentals of test-driving
    the technology. If you’re using other GraphQL libraries instead of Relay, the
    techniques we’ll explore in this chapter will also apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the new `CustomerHistory` component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – The new CustomerHistory component ](img/Figure_13.01_B18423.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – The new CustomerHistory component
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Compiling the schema before you begin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test-driving the Relay environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching GraphQL data from within a component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you’ll have explored the test-driven approach to
    GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter13)'
  prefs: []
  type: TYPE_NORMAL
- en: Compiling the schema before you begin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code samples for this chapter already contain some additions:'
  prefs: []
  type: TYPE_NORMAL
- en: The `react-relay`, `relay-compiler`, and `babel-plugin-relay` packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Babel configuration to ensure your build understands the new GraphQL syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relay configuration in the `relay.config.json` file. The primary piece of configuration
    is the location of the schema.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A GraphQL schema in the file `src/schema.graphql`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A server endpoint at `POST/graphql`, which services incoming GraphQL requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s beyond the scope of this book to go into each of these, but you will need
    to compile the schema before you begin, which can be done by typing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `npm run build` command has also been modified to run this command for you,
    just in case you forget. Once everything is compiled, you’re ready to write some
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Relay environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few different ways to approach the integration of Relay into a React
    application. The method we’ll use in this book is the `fetchQuery` function, which
    is analogous to the `global.fetch` function we’ve already used for standard HTTP
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: However, Relay’s `fetchQuery` function has a much more complicated setup than
    `global.fetch`.
  prefs: []
  type: TYPE_NORMAL
- en: One of the parameters of the `fetchQuery` function is the *environment*, and
    in this section, we’ll see what that is and how to construct it.
  prefs: []
  type: TYPE_NORMAL
- en: Why Do We Need to Construct an Environment?
  prefs: []
  type: TYPE_NORMAL
- en: The Relay environment is an extension point where all manner of functionality
    can be added. Data caching is one example. If you’re interested in how to do that,
    check out the *Further reading* section at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will build a function named `buildEnvironment`, and then another named `getEnvironment`
    that provides a singleton instance of this environment so that the initialization
    only needs to be done once. Both functions return an object of type `Environment`.
  prefs: []
  type: TYPE_NORMAL
- en: One of the arguments that the `Environment` constructor requires is a function
    named `performFetch`. This function, unsurprisingly, is the bit that actually
    fetches data – in our case, from the `POST /graphql` server endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: In a separate test, we'll check whether `performFetch` is passed to the new
    `Environment` object. We need to treat `performFetch` as its own unit because
    we’re not going to be testing the behavior of the resulting environment, only
    its construction.
  prefs: []
  type: TYPE_NORMAL
- en: Building a performFetch function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s begin by creating our own `performFetch` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `test/relayEnvironment.test.js`, and add the following setup.
    This sets up our `global.fetch` spy in the same way as usual. There are two new
    constants here, `text` and `variables`, which we’ll use soon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the first test, checking that we make the appropriate HTTP request.
    The call to `performFetch` takes two parameters that contain `text` (wrapped in
    an object) and `variables`. This mimics how the Relay environment will call the
    `performFetch` function for each request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new file, `src/relayEnvironment.js`, and make the test pass with the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the second of our tests for the HTTP request dance, which ensures we pass
    the correct request configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass by adding the two lines highlighted here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the third and final test of our HTTP request dance. This one checks
    that we pass the right request data – the required `text` query and the `variables`
    argument included within it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass by defining the `body` property for the `fetch` request, as
    shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Understanding Operation, Text, and Variables
  prefs: []
  type: TYPE_NORMAL
- en: The `text` property of the `operation` argument is a static piece of data that
    defines the query, and the `variables` argument will be the piece that is relevant
    to this specific request.
  prefs: []
  type: TYPE_NORMAL
- en: The tests we’re writing in this chapter do not go as far as checking the *behavior*
    of this Relay plumbing code. When writing this type of unit test, which doesn’t
    exercise behavior, it’s important to note that some kind of **end-to-end test**
    will be necessary. That will ensure your unit tests have the right specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next test checks that we return the right data from the function. Relay
    expects our `performFetch` function to return a promise that will either resolve
    or reject. In this case, we’re resolving it to the `fetch` response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to handle the error cases. We need the promise to reject if an
    HTTP error occurred. We use a new form of the `expect` function that we haven’t
    seen before; it takes a promise and expects it to reject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our production code, we’ll test whether the fetch response’s `ok` property
    is `false`, and reject the promise if it is. Add the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call that function within your promise chain. After this, our `performFetch`
    function is complete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You’ve now learned how to specify and test the `performFetch` function required
    for the `Environment` constructor. Now, we’re ready to do that construction.
  prefs: []
  type: TYPE_NORMAL
- en: Test-driving the Environment object construction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re going to build a function named `buildEnvironment`, that takes all the
    various pieces we need to build an `Environment` object. The reason there are
    so many pieces is that they are all extension points that enable the configuration
    of the Relay connection.
  prefs: []
  type: TYPE_NORMAL
- en: These pieces are our `performFetch` function and a bunch of other Relay types
    that come directly from the `relay-runtime` package. We’ll use `jest.mock` to
    mock all these out in one fell swoop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same test file, `test/relayEnvironment.test.js`, update your import
    to include the new function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, it’s time to import all the relevant pieces we need from the `relay-runtime`
    package and mock them out. Add the following to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For our first test, we need to test that the `Environment` constructor was
    called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start by adding all the imports in the production code in `src/relayEnvironment.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make the test pass by adding this code at the bottom of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second test makes sure we pass the right arguments to `Environment`. Its
    first argument is the result of calling `Network.create`, and the second argument
    is the result of constructing a `Store` object. The tests need to mock those out
    and then check the return values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Mocking Constructors
  prefs: []
  type: TYPE_NORMAL
- en: Note the difference in how we mock out constructors and function calls. To mock
    out a new `Store` and a new `Environment`, we need to use `mockImplementation(fn)`.
    To mock out `Network.create`, we need to use `mockReturnValue(returnValue)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the test pass by updating the function to pass those arguments to the
    `Environment` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next up, we need to ensure that `Network.create` gets a reference to our `performFetch`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass by passing `performFetch` to the `Network.create` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Store` constructor needs a `RecordSource` object. Add a new mock implementation
    for `RecordSource` in your test setup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following test to specify the behavior we want:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass by constructing a new `RecordSource` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And that, would you believe, is it for `buildEnvironment`! At this stage, you
    will have a valid `Environment` object.
  prefs: []
  type: TYPE_NORMAL
- en: Test-driving a singleton instance of Environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because creating `Environment` takes a substantial amount of plumbing, it’s
    common to construct it once and then use that value for the rest of the application.
  prefs: []
  type: TYPE_NORMAL
- en: An Alternative Approach Using RelayEnvironmentProvider
  prefs: []
  type: TYPE_NORMAL
- en: There is an alternative approach to using the singleton instance shown here,
    which is to use React Context. The `RelayEnvironmentProvider` component provided
    by Relay can help you with that. For more information, see the *Further reading*
    section at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s build the `getEnvironment` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the new function at the top of `test/relayEnvironment.test.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the bottom of the file, add a third `describe` block with the one and only
    one test for this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `src/relayEnvironment.js`, make that pass by introducing a top-level variable
    that stores the result of `getEnvironment` if it hasn’t yet been called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s all for the environment boilerplate. We now have a shiny `getEnvironment`
    function that we can use within our React components.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll start on the `CustomerHistory` component.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching GraphQL data from within a component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a Relay environment, we can begin to build out our feature.
    Recall from the introduction that we’re building a new `CustomerHistory` component
    that displays customer details and a list of the customer’s appointments. A GraphQL
    query to return this information already exists in our server, so we just need
    to call it in the right way. The query looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This says we get a customer record for a given customer ID (specified by the
    `$id` parameter), together with a list of their appointments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our component will perform this query when it’s mounted. We’ll jump right in
    with that functionality, by testing the call to `fetchQuery`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `test/CustomerHistory.test.js`, and add the following setup.
    We’re going to break this setup into parts, as it’s long! First up is our import,
    and the call to mock `relay-runtime` again, so that we can stub `fetchQuery`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s define some sample data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s get `beforeEach` in place. This stubs out `fetchQuery` with a special
    `sendCustomer` fake, mimicking the return value of a `fetchQuery` request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Return Value of fetchQuery
  prefs: []
  type: TYPE_NORMAL
- en: This function has a relatively complex usage pattern. A call to `fetchQuery`
    returns an object with `subscribe` and `unsubscribe` function properties We call
    `subscribe` with an object with a `next` callback property. That callback is called
    by Relay’s `fetchQuery` each time the query returns a result set. We can use that
    callback to set our component state. Finally, the `unsubscribe` function is returned
    from the `useEffect` block so that it’s called when the component is unmounted
    or the relevant props change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the test, which checks that we call `fetchQuery` in the expected
    way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s make that pass. Create a new file, `src/CustomerHistory.js`, and start
    it off with the imports and the exported `query` definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the component, together with a `useEffect` Hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you run tests now, you might see an error, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To fix this, run the following command to compile your GraphQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can add a test to show what happens when we pull out some data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, update the `useEffect` block to return the `unsubscribe`
    function property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, update your component to render that data, pulling in the customer data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, update your component to include a new state variable, `customer`. This
    is set by calling `setCustomer` in our definition of the next callback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make the test pass by extending your JSX to render the customer data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add a test to also render the customer’s phone number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass with the change shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s get started on rendering the appointments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That’s a quick one to fix; add in the `h3` element, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll render a table for each of the appointments available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add that table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the next set of tests, we’ll use a `columnValues` helper, which will find
    a rendered table element and pull out an array of all the values in a column.
    We can use this to test that our code displays data for a list of appointments,
    rather than just one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new `tbody` element here, just below `thead`. This makes a reference
    to a new `AppointmentRow` component, which we haven’t built yet, but we will do
    so in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s define `AppointmentRow`. Add this above the `CustomerHistory` definition.
    After this, your test should pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s add in the other columns, starting with the stylist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add that as the next column in `AppointmentRow`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next is the `service` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Again, that involves simply adding a further `td` element to `AppointmentRow`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, for rendering information, we’ll show the `notes` field too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Complete the `AppointmentRow` component, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’re almost done. Let’s display a `describe` block, just below the test that
    we’ve just completed. It uses a `noSend` fake that does nothing; there’s no call
    to `next`. This can be used to mimic the scenario when data is still loading:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, introduce a conditional just before the JSX:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s handle the case when there’s an error fetching data. This uses
    another fake, `errorSend`, that invokes the error callback. It’s like the `next`
    callback and can be used to set state, which we’ll see in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, you’ll need to introduce a new `status` state variable.
    Initially, this has the `loading` value. When successful, it changes to `loaded`,
    and when an error occurs, it changes to `failed`. For the `failed` state, we render
    the specified error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That completes the new `CustomerHistory` component. You have now learned how
    to test-drive the use of Relay’s `fetchQuery` function in your application, and
    this component is now ready to integrate with `App`. This is left as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has explored how to test-drive the integration of a GraphQL endpoint
    using Relay. You have seen how to test-drive the building of the Relay environment,
    and how to build a component that uses the `fetchQuery` API.
  prefs: []
  type: TYPE_NORMAL
- en: In *Part 3*, *Interactivity*, we’ll begin work in a new code base that will
    allow us to explore more complex use cases involving undo/redo, animation, and
    WebSocket manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 14*](B18423_14.xhtml#_idTextAnchor277), *Building a Logo Interpreter*,
    we’ll begin by writing new Redux middleware to handle undo/redo behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Integrate the `CustomerHistory` component into the rest of your application
    by taking the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new route at `/viewHistory?customer=<customer id>` that displays the `CustomerHistory`
    component, using a new intermediate `CustomerHistoryRoute` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new `Link` to the search actions on the `CustomerSearch` screen, titled
    **View history**, that, when pressed, navigates to the new route.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `RelayEnvironmentProvider` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://relay.dev/docs/api-reference/relay-environment-provider/](https://relay.dev/docs/api-reference/relay-environment-provider/)'
  prefs: []
  type: TYPE_NORMAL
- en: Part 3 – Interactivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part introduces a new code base that allows us to explore more complex
    scenarios where TDD can be applied. You’ll take a deep dive into Redux middleware,
    animation, and WebSockets. The goal is to show how complex tasks are approached
    using the TDD workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B18423_14.xhtml#_idTextAnchor277), *Building a Logo Interpreter*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B18423_15.xhtml#_idTextAnchor306), *Adding Animation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 16*](B18423_16.xhtml#_idTextAnchor322), *Working with WebSockets*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
