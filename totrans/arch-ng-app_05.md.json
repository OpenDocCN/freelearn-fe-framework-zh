["```js\n// observer-subject/subject.ts\n\nimport { Observer } from \"./observer\";\n\nexport class Subject {\n  observers: Array<Observer>;\n\n  constructor() {\n    this.observers = new Array<Observer>();\n  }\n\n  attach(observer: Observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer);\n    }\n  }\n\n  detach(observer) {\n    let index = this.observers.indexOf(observer);\n    if (index !== -1) {\n      this.observers = this.observers.slice(index, 1);\n    }\n  }\n\n  notify() {\n    this.observers.forEach(observer => observer.update());\n  }\n}\n```", "```js\n// observer-subject/observer.ts\nexport interface Observer {\n  update();\n}\n```", "```js\n// observer-subject/app.ts\n\nimport { Subject } from \"./subject\";\nimport { Observer } from \"./observer\";\n\nconst subject = new Subject();\nconst observer = <Observer>{\n  update: () => console.log(\"First Observer Updated\")\n};\n\nconst observer2 = <Observer>{\n  update: () => console.log(\"Second Observer updated\")\n};\n\nsubject.attach(observer);\nsubject.attach(observer2);\nsubject.notify();\n\n// should emit:\n// First Observer Updated\n// Second Observer updated\n```", "```js\n// product-model/product.model.ts\n\nimport { Subject } from \"./subject\";\n\nexport class ProductModel extends Subject {\n  private titleValue = \"\";\n  private makeValue = \"\";\n\n  get title(){ \n    return this.titleValue;\n  }\n\n  set title(value) {\n    this.titleValue = value;\n    this.notify();\n  }\n\n  get make() {\n    return this.makeValue;\n  }\n\n  set make(value) {\n    this.makeValue = value;\n    this.notify();\n  }\n}\n```", "```js\n// product-model/product.ui.ts\n\nimport { Observer } from \"./observer\";\nimport { ProductModel } from \"./product.model\";\n\nexport class ProductUI implements Observer {\n  constructor(private model: ProductModel) {\n    this.model.attach(this); // add ProductUI to the observer list\n    this.renderUI();\n  }\n\n  renderUI() {\n    console.log(\"calling renderUI\");\n    this.draw();\n  }\n\n  draw() {\n    // implement\n    console.log(\"calling draw\");\n  }\n\n  update() {\n    console.log(\"calling update\");\n    this.renderUI(); // rerender the UI when update() is called\n  }\n}\n```", "```js\nlet stream$ = Rx.Observable.create(observer => observer.next(1));\n```", "```js\nlet stream$ = Rx.Observable.create(observer => observer.next(1));\nstream$.subscribe(data => console.log('data',data) ) // write data, 1 to the console\n```", "```js\n// rxjs-example/producer.js\n\nconst Rx = require(\"rxjs/Rx\");\n\nclass Producer {\n  constructor() {\n    this.counterMax = 5;\n    this.current = 0;\n  }\n\n  hasValues() {\n    return this.current < this.counterMax;\n  }\n\n  next() {\n    return this.current++;\n  }\n}\n\nlet stream$ = Rx.Observable.create(observer => {\n  let producer = new Producer();\n\n  while (producer.hasValues()) {\n    observer.next(producer.next());\n  }\n});\n\nstream$.subscribe(data => console.log(\"data\", data));\n// data 0, data 1, data 2, data 3, data 4\n```", "```js\nlet stream$ = Rx.Observable.create(observer => {\n  observer.error('we have an error');\n});\n```", "```js\n// rxjs-example/error.js \n\nconst Rx = require(\"rxjs/Rx\");\n\nlet stream$ = Rx.Observable.create(observer => {\n  observer.error(\"we have an error\");\n});\n\nstream$.subscribe(\n  data => console.log(\"data\", data),\n  error => console.error(\"err\", error)\n)\n```", "```js\n// rxjs-example/completion.js\n\nconst Rx = require(\"rxjs/Rx\");\n\nlet stream$ = Rx.Observable.create(observer => {\n  observer.next(1);\n  observer.complete();\n});\n\nstream$.subscribe( \n  data => console.log(\"data\", data), // 1\n  error => console.error(\"err\", error), // never hit\n  () => console.log(\"complete\") ); // will be hit\n```", "```js\nlet stream$ = Rx.Observable.of(1,2)\n .map( x => x +1 )\n .filter( x > 2 );\n\nstream$.subscribe( data => console.log('data', data)) \n// data 3\n```", "```js\nlet stream$ = Rx.Observable.of(1, 2, 3, 4);\nstream$.subscribe( data => console.log(data)) // 1, 2, 3 ,4\n```", "```js\nlet stream$ = Rx.Observable.interval(1000)\n  .take(3); // 1s delay between values, starting at 0\n\nstream$.subscribe(data => console.log(data)) \n// 0, 1, 2\n```", "```js\nlet stream$ = Rx.Observable.from(new Promise(resolve, reject) => {\n  resolve('some data');\n});\n\nstream$.subscribe( data => console.log(data)); // some data\n\nlet stream2$ = Rx.Observable.from([1,2,3,4]);\nstream2$.subscribe( data => console.log(data)); // 1,2,3,4\n```", "```js\nlet elem = document.getElementById('input'); \n// we assume we have a <input id=\"input\"> in our markup\n\nlet keyStream$ = Rx.Observable.fromEvent(elem, 'keyUp'); \n// listens to the keyUp event\n```", "```js\nfunction fnWithCallback(cb) {\n  setTimeout(() => cb('data'), 3000);\n}\n\nlet fnWithCallbackBinded = Rx.Observable.bindCallback(fnWithCallback);\nlet source$ = fnWithCallbackBinded();\n\nsource$.subscribe(data => console.log('callback', data));\n\n```", "```js\n// rxjs-creation-operators/bind-callback.ts\n\nclass Observable {\n  behaviorFn;\n  constructor(behaviorFn) {\n    this.behaviorFn = behaviorFn;\n  }\n\n  static bindCallback(behaviorFn): Function {\n    return (): Observable => {\n      return new Observable(behaviorFn);\n    };\n  }\n\n  subscribe(dataCb) {\n    this.behaviorFn(dataCb);\n  }\n}\n\nlet fn = Observable.bindCallback(cb => {\n  setTimeout(() => cb(\"data\"), 3000);\n});\n\nconst stream$ = fn();\nstream$.subscribe(data => console.log(\"data\", data));\n// outputs: data data\n```", "```js\nlet stream$ = Rx.Observable.create(observer => {\n  let counter = 0;\n  let id = setInterval(() => observer.next(counter++), 1000);\n\n  return function cleanUpFn() { clearInterval(id); }\n});\n```", "```js\nlet stream$ = Rx.Observable.create(observer => {\n  let counter = 0;\n  let id = setInterval(() => observer.next(counter++), 1000);\n return function cleanUpFn() { clearInterval(id); }\n});\n\nlet subscription = stream$.subscribe((data) => console.log('data'));\nsetTimeout(() => subscription.unsubscribe(), 2000);\n```", "```js\nlet stream$ = Rx.Observable.create( observer => observer.next(1));\nstream$.subscribe( data => console.log(data));\n```", "```js\nclass MyObservable {\n  static create(behaviourFn): MyObservable {}\n  constructor() {}\n  subscribe(dataFn) {}\n}\n```", "```js\nclass MyObservable {\n  static create(behaviourFn): MyObservable {\n    return new Observable(behaviourFn);\n  }\n  constructor(private behaviourFn) {}\n  subscribe(dataFn) {}\n}\n```", "```js\nclass MyObservable {\n  static create(private behaviourFn): MyObservable { \n    return new MyObservable(behaviourFn);\n  }\n  constructor(behaviourFn) { this.behaviourFn = behaviourFn; }\n  subscribe(dataFn) {\n    this.behaviourFn(observer);\n  }\n}\n```", "```js\nclass Observer {\n  constructor(private dataFn) {}\n  next(value) { this.dataFn(val) }\n}\n```", "```js\n// rxjs-core/Observable.ts\n\nclass Observer {\n  constructor(private dataFn) {}\n  next(value) { this.dataFn(value) }\n}\n\nclass MyObservable {\n  behaviourFn;\n  static create(behaviourFn): MyObservable {\n    return new Observable(behaviourFn);\n  }\n  constructor(behaviourFn) { this.behaviourFn = behaviourFn; }\n  subscribe(dataFn) {\n    let observer = new Observer(dataFn);\n    this.behaviourFn( observer );\n  }\n}\n\nlet stream$ = MyObservable.create( observer => observer.next(1)); // 1\n```", "```js\n// rxjs-core/Observer-with-subscription.ts\n\ninterface Subscription {\n  unsubscribe();\n}\n\nclass MyObservableWithSubscription {\n  static create(behaviourFn): MyObservableWithSubscription {\n    return new MyObservableWithSubscription(behaviourFn);\n  }\n\n  constructor(private behaviourFn) {}\n\n  subscribe(dataFn): Subscription {\n    let observer = new MyObserver(dataFn);\n    let cleanUpFn = this.behaviourFn(observer);\n    return {\n      unsubscribe: cleanUpFn\n    };\n  }\n}\n\nlet streamWithSubscription$ = MyObservableWithSubscription.create(observer => {\n  let counter = 0;\n  let id = setInterval(() => observer.next(counter++), 1000);\n  return function cleanUpFn() {\n    clearInterval(id);\n  };\n});\n\nconst subscription = streamWithSubscription$.subscribe(data =>\n  console.log(\"data\", data)\n);\n\nsubscription.unsubscribe();\n```", "```js\nlet stream$ = Observable.of(1,2,3)\n  .filter( x => x > 1 );\n\nstream$.subscribe( data => console.log(data)) \n// will emit 2,3\n```", "```js\n// rxjs-core/operator/Observable.ts, starting off with MyObservable, more to come\n\nimport { MyObserver } from \"./Observer\";\n\nclass MyObservable {\n  behaviorFn;\n\n  static create(behaviourFn): MyObservable {\n    return new MyObservable(behaviourFn);\n  }\n\n constructor(behaviorFn) {\n   this.behaviorFn = behaviorFn;\n }\n\n filter(filterFn): FilterableObservable {\n   /* implement */\n }\n\n subscribe(dataFn) {\n   let observer = new MyObserver(dataFn);\n   let cleanUpFn = this.behaviorFn(observer);\n\n   return {\n     unsubscribe: cleanUpFn\n   };\n }\n}\n```", "```js\n// rxjs-core/operator/Observable.ts, starting off with MyObservable, more to come\n\nimport { MyObserver } from \"./Observer\";\n\nclass MyObservable {\n  behaviorFn;\n\n  static create(behaviourFn): MyObservable {\n    return new MyObservable(behaviourFn);\n  }\n\n constructor(behaviorFn) {\n   this.behaviorFn = behaviorFn;\n }\n\n filter(filterFn): FilterableObservable {\n   return new FilterableObservable(filterFn, this.behaviorFn);\n }\n\n subscribe(dataFn) {\n   let observer = new MyObserver(dataFn);\n   let cleanUpFn = this.behaviorFn(observer);\n\n   return {\n     unsubscribe: cleanUpFn\n   };\n }\n}\n```", "```js\n// rxjs-core/operator/Observable.ts\n\nimport { MyObserver } from \"./Observer\";\n\nclass MyObservable {\n  behaviorFn;\n\n  static create(behaviourFn): MyObservable {\n    return new MyObservable(behaviourFn);\n  }\n\n  constructor(behaviorFn) {\n    this.behaviorFn = behaviorFn;\n  }\n\n  filter(filterFn): FilterableObservable {\n    return new FilterableObservable(filterFn, this.behaviorFn);\n  }\n\n  subscribe(dataFn) {\n    let observer = new MyObserver(dataFn);\n    let cleanUpFn = this.behaviorFn(observer);\n\n     return {\n      unsubscribe: cleanUpFn\n     };\n  }\n}\n\nexport class FilterableObservable extends MyObservable {\n  constructor(private filterFn, behaviourFn) {\n    super(behaviourFn);\n  }\n\n  subscribe(dataFn) {\n    let observer = new MyObserver(dataFn);\n\n    observer.next = value => {\n      if (this.filterFn(value)) {\n        dataFn(value);\n }\n };\n\n    let cleanUpFn = this.behaviorFn(observer);\n    return {\n      unsubscribe: cleanUpFn\n    };\n  }\n}\n\nconst stream$ = new MyObservable(observer => {\n  observer.next(1);\n  observer.next(2);\n  observer.next(3);\n}).filter(x => x > 2);\n\nstream$.subscribe(data => console.log(\"data\", data));\n\n// prints 3\n```", "```js\nlet stream$ = Rx.Observable.of(1,2,3);\nstream$.subscribe(\n  data => console.log(data),\n err => console.error(err),\n () => console.log('complete');  \n)\n```", "```js\nlet stream$ = Rx.Observable.create( observer => {\n  observer.next(1);\n  observer.error('err');\n  observer.next(2); \n});\n\nstream$.subscribe( \n  data => console.log(data),\n  err => console.error(err)\n);  \n// should emit 1, err\n```", "```js\nclass Observer {\n  hasError: boolean;\n  constructor(private dataFn, private errorFn) {}\n  next(value) { \n if (!this.hasError) { \n      this.dataFn(value); \n } \n  }\n\n  error(err) { \n    this.errorFn(err); \n    this.hasError = true; \n  }\n}\n```", "```js\n\nclass Observable {\n  behaviourFn;\n  static create(behaviourFn): Observable {\n    return new Observable(behaviourFn);\n  }\n\n  constructor(behaviourFn) { \n    this.behaviourFn = behaviourFn; \n  }\n\n  subscribe(dataFn, errorFn) {\n    let observer = new Observer(dataFn, errorFn);\n    let cleanUpFn = this.behaviourFn(observer);\n\n    return { \n      unsubscribe: cleanUpFn \n    };\n  }\n}\n\n```", "```js\n// rxjs-core/error-complete/Observer.ts\n\nclass Observer {\n  hasError: boolean;\n  isCompleted: boolean; \n  constructor(\n    private dataFn, \n    private errorFn, \n private completeFn  ) {}\n\n  next(value) { \n    if(!this.hasError && !this.isCompleted) { \n      this.dataFn(value); \n } \n  }\n\n  error(err) { \n    this.errorFn(err); \n    this.hasError = true; \n  }\n  complete() { \n    this.completeFn(); \n    this.isCompleted = true; \n  }\n}\n```", "```js\n// rxjs-core/error-complete/Observable.ts\n\nimport { Observer } from './Observer';\n\nclass Observable {\n  behaviourFn; \n  static create(behaviourFn): Observable {\n    return new Observable(behaviourFn);\n  }\n\n  constructor(behaviourFn) { \n    this.behaviourFn = behaviourFn; \n  }\n\n  filter(filterFn):Observable {\n    return new FilterableObservable(\n      filterFn, \n      this.behaviourFn\n    );\n  }\n\n  subscribe(dataFn, errorFn, completeFn) {\n    let observer = new Observer(dataFn, errorFn, completeFn);\n    let cleanUpFn = this.behaviourFn( observer );\n\n    return { \n      unsubscribe: cleanUpFn \n    };\n  }\n}\n\nconst stream$ = new Observable(observer => {\n  observer.next(1);\n  observer.error(\"error\");\n  observer.next(2);\n});\n\nstream$.subscribe(\n  data => console.log(\"data\", data),\n  err => console.log(\"error\", err),\n  () => console.log(\"completed\")\n);\n\n// prints 1, error, no more is emitted after that\n```"]