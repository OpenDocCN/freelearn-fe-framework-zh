- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling API Data and Managing Async Components with Vue.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B21130_06.xhtml#_idTextAnchor074), we focused on how components
    can communicate with each other with the use of properties, which are used for
    parent-to-child communications and events to handle messages sent from a child
    to a parent.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will stay on the topic of communication by showing how to
    communicate with an external source, such as an API. External communication is
    a very common method when developing a dynamic website that cannot make use of
    static data, and learning how to manage asynchronous operations will not only
    result in a clean user experience but also help keep the application performant.
  prefs: []
  type: TYPE_NORMAL
- en: Loading data from an external source such as an API makes data handling more
    complicated. In fact, when the data is hardcoded, we do not have to worry about
    anything, as the information is immediately available, while when working with
    data that comes from an external source, we need to not only think about the empty
    state that the app will be while the data is loaded but also consider the possibility
    of the data failing to load.
  prefs: []
  type: TYPE_NORMAL
- en: We will start the chapter by removing the hardcoded posts and loading them dynamically;
    we will then do the same with the comments by making the data on-demand. We will
    then enhance our application to automatically load more posts, using `watch`.
    Finally, we will learn how to define and use asynchronous components using `<Suspense>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading data from an API using the Vue.js life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Watching for changes in components using `watch` functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling asynchronous components with Suspense
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have learned how to load data and components
    dynamically. You will know how to create components that load data on demand and
    what benefits this brings to our application. You will also be able to handle
    side effects using `watch` and, finally, define and take care of asynchronous
    components to ensure your application is rendered correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the branch is called `CH07`. To pull this branch, run the
    following command or use your GUI of choice to support you in this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As part of this chapter, we are also going to use an external resource called
    Dummyapi.io. This website will provide a dummy API that we will use to load our
    post dynamically. To be able to use the API, you need to register and generate
    an **APP ID**. Creating an **APP ID** is completely free and can be obtained by
    creating an account on the following link ([https://dummyapi.io/sign-in](https://dummyapi.io/sign-in)).
  prefs: []
  type: TYPE_NORMAL
- en: This new branch, `CH07`, includes just a couple of style changes and the replacement
    of the native button with the custom button component that we created in the last
    chapter, `TheButton.vue`.
  prefs: []
  type: TYPE_NORMAL
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners).
  prefs: []
  type: TYPE_NORMAL
- en: Loading data from an API using the Vue.js life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is common for most of the applications that are built for the web to expose
    a level of dynamic content. Providing the ability to load information on the fly
    has been one of the most important factors that led to the growth of JavaScript
    frameworks, such as Vue.js.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, the Companion App has been built using static data that is loaded
    directly within the components. Hardcoded values are not very common in real applications,
    and the posts and comments used within the application were just a stopgap to
    help us focus on the basic features of Vue.js, but it is now time to learn how
    to load data dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to successfully handle asynchronous data load is very important.
    No matter how big or small your next application will be, it is very likely that
    you will be required to handle external data.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to update two parts of our application. First,
    we are going to update `SocialPosts.vue` to load the post from an external source,
    and then we are going to change `SocialPostComments.vue` to also load comments
    dynamically but with a little twist, as we will implement something called “loading
    data on demand.” We will then briefly discuss the implications that dynamic loading
    can have on performance and the user experience of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Loading social posts from an API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until now, the posts that our application displayed were always the same due
    to the hardcoded array of `posts` defined in `SocialPosts.vue`. In this section,
    we are going to use a public API offered by **DummyAPI** ([https://dummyapi.io/](https://dummyapi.io/))
    to make our post dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: Services such as **DummyAPI** are very useful to develop application scaffolding
    and to help you practice your skills. There are plenty of free services like this
    one available on the internet, and they can easily be found using a search engine.
  prefs: []
  type: TYPE_NORMAL
- en: Research is part of development
  prefs: []
  type: TYPE_NORMAL
- en: Spend a couple of minutes navigating through the **DummyAPI** website and try
    to understand how we will use the API and what endpoints we will use. Learning
    external resources is a very important part of web development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading external data will be achieved using Vue.js methods, the native Fetch
    API, and Vue.js life cycles. First, we are going to remove the old, hardcoded
    data from `SocialPosts.vue`. This file can be found in the `molecules` folder,
    as it is a component that renders a big section of our Companion App homepage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the same file, we are going to create a method that calls the external
    API to fetch our new posts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses the native JavaScript `fetch` method ([https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API))
    to send a `GET` request to the [dummyapi.io](http://dummyapi.io) API. Due to the
    API requirements, we need to pass `app-id` with the request. This can be obtained
    for free, as mentioned in the *Technical* *requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: We then fetch the result in the `json` format using `response.json()` and, finally,
    append the returned data to the post’s `Reactive` property.
  prefs: []
  type: TYPE_NORMAL
- en: After the method has been defined, it is time to “call” it. When triggering
    an `async` request like in this case, we take advantage of the Vue.js life cycle
    to ensure that our request is triggered at the correct time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 2*](B21130_02.xhtml#_idTextAnchor028), we introduced the different
    life cycles and mentioned that the `created` life cycle is the correct one for
    asynchronous data. Our description of it was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: “[The `created` life cycle] is the perfect stage to trigger asynchronous calls
    to gather some data. Triggering slow requests now will help us save some time,
    as this request will continue behind the scenes while our component is being rendered.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go and call our newly created method, `fetchPosts`, during the created
    life cycle. In contrast to other life cycles such as `mounted`, `created` does
    not need to be explicitly defined. The explanation from the official documentation
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: “Because `setup` is run around the `beforeCreate` and `created` lifecycle hooks,
    you do not need to explicitly define them. In other words, any code that would
    be written inside those hooks should be written directly in the `setup` function.”
  prefs: []
  type: TYPE_NORMAL
- en: 'This simplifies our requirement, meaning that all we need to do is call the
    method after it is defined within the body of our component’s JavaScript logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage, our posts should be dynamically loaded from the API, but the
    work is not done yet; in fact, the application displays the posts incorrectly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: The Companion App displaying a broken UI](img/B21130_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: The Companion App displaying a broken UI'
  prefs: []
  type: TYPE_NORMAL
- en: What caused the preceding error?
  prefs: []
  type: TYPE_NORMAL
- en: Before reading the answer, why don’t you try to investigate what could have
    caused the issue with the rendering displayed in *Figure 7**.1*? How would you
    go about fixing it?
  prefs: []
  type: TYPE_NORMAL
- en: The data fetched by the API is loaded and applied to our “posts” successfully,
    but the structure of the data does not match the one that we previously had set.
    This problem is related to the advanced properties settings that we just learned
    about in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the SocialPost.vue properties’ misalignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Misaligned props are something that is very common in real applications, but
    they can be avoided. In fact, the reason why the app is rendering a broken UI
    is that we have not specified which properties are expected to be “required” in
    `SocialPost.vue`, and as a result, Vue.js tries to render the app with the data
    it has, resulting in the missing data being set as `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s compare the previous hardcoded structure of the posts array with the
    new structure received by the API to see how the two structures compare and what
    changes are required to ensure the Companion App can correctly render the post
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: The transition between the previous structure of posts and the
    new one provided by the API](img/B21130_07_02_BW.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: The transition between the previous structure of posts and the
    new one provided by the API'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.2* displays the changes we are going to make in our application
    to align with the new data. Some of the fields need to change to match the new
    object properties, and comments and retweets have been removed altogether. Calling
    the `<SocialPost>` component will now be changed to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding highlighted code shows the difference between the old and new
    component instances. Note that we had to replace `userId` with just `id`, which
    will be required later. It is now time to modify the child component to make sure
    it can function with the new data. This will involve a couple of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove `UserId` from the UI, as it is too long:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove `comments` and `retweets` from the `props` declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Refactor `interactions` and `commentsNumber` from the UI and replace them with
    just `likes`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove the logic associated with `interactions` and `commentsNumber`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <TheButton
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: v-show="hasComments"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@click="onShowCommentClick"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: value="Show comment"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: width="auto"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: theme="dark"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: />
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding changes may seem quite complicated when reading them out, but
    they follow a logical pattern. They are all connected to each other, a modification
    in one component may result in a change in another and so on. For example, removing
    the `retweet` props in the parent would then result in the props being removed
    from the child component within `defineProps`, and consequently, the removal of
    any code logic attached to those props, and finally, any use of the props in the
    component template.
  prefs: []
  type: TYPE_NORMAL
- en: As you get more familiar with the framework, the preceding changes will feel
    trivial, but I have added them here and covered them step by step on purpose to
    give you some idea of how to logically think about a component and its data flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, the application should render correctly, and the home page should
    display posts coming from the dummy API we have implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: The Companion App displaying posts from the external API](img/B21130_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: The Companion App displaying posts from the external API'
  prefs: []
  type: TYPE_NORMAL
- en: The Companion App displays the post correctly again, but something is still
    missing. The logic that was used to display the comment does not work correctly
    anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move forward, you should improve the component that we just made to
    make it more reliable, by improving its properties.
  prefs: []
  type: TYPE_NORMAL
- en: Your turn – improve the properties set in SocialPost.vue
  prefs: []
  type: TYPE_NORMAL
- en: Spend a few minutes to enhance the props set in `SocialPost.vue`. Look at each
    props and decide if they should be required, by using the `required` attribute
    on props or if they could be set to optional by defining a `default` value.
  prefs: []
  type: TYPE_NORMAL
- en: Load comments on demand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the `posts` data was hardcoded, the comments associated with the individual
    post were available on the first render, and we were able to pass them immediately
    between the parent and child components. But now that the information is loaded
    dynamically, we can change our logic to just load the comments on demand.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine an application where all the data is loaded on the main page and has
    to be passed around between tens of components. No matter how hard you would work,
    the code would be quite hard to maintain. Passing properties through many layers
    of components is known in the industry as “props drilling.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Props drilling can be avoided using two techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading data on demand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using state management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we are going to cover the first technique, loading data on
    demand, while state management will be covered later in [*Chapter 11*](B21130_11.xhtml#_idTextAnchor153).
  prefs: []
  type: TYPE_NORMAL
- en: Making a change like the one we just performed prevents some data from being
    loaded immediately, with it just being fetched on demand. This is a very good
    practice to improve both performance and code structure.
  prefs: []
  type: TYPE_NORMAL
- en: When analyzing how comments behave in our application, we can see that it would
    be quite wasteful to load all comments associated with the posts immediately,
    when we know that the application will just display them on user interaction (a
    button click).
  prefs: []
  type: TYPE_NORMAL
- en: We are going to work on two files. First, we are going to replace the `comments`
    property from `SocialPost.vue` with the post ID. Then, we will create the functionality
    required to load the comments on demand in `SocialPostComments.vue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you should have enough knowledge to remove the `comments` property
    from the component and replace it with another property, called `post-id`. This
    will be used later to request the correct comments from the dummy API, and the
    code changes should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Because the `comments` property was already removed from `defineProps` in the
    previous section of this chapter, all that was left to do was to ensure that we
    removed the prop from the `<SocialPostComments>` component declaration and replaced
    it with one called `post-id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step requires us to rewrite the logic that handles the load of the
    comments. We will start by modifying the properties, by removing the `comments`
    one and replacing it with the newly passed `post-id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The ID of the post is required for us to be able to fetch the correct comments
    from the API. It is very common when passing IDs around to prefix them with the
    actual context. So, in our case, instead of naming our prop ID, we named it `postId.`
    Small improvements such as this can really help keep your code clean and readable.
  prefs: []
  type: TYPE_NORMAL
- en: Defining multiword props using kebab case
  prefs: []
  type: TYPE_NORMAL
- en: Did you notice that the property we just defined is called `postId` in the component
    declaration but is passed in the component using kebab case, `post-id`? HTML is
    not case-sensitive, so using `postId` would just mean the same as `postid`. Therefore,
    to ensure that we better define the multiword props, we use kebab case – that
    is, “word-word.”
  prefs: []
  type: TYPE_NORMAL
- en: It is now time to make the necessary changes to ensure that `SocialPostComments.vue`
    works correctly with the new posts structure and create the logic required to
    load the comments on demand.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use the following path from the API, `/post/{postId}/comment`.
    This is going to return us the comment from a given `postId`, where `postId` is
    the actual ID of the post selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down all the changes required:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import `reactive`from `vue` and use it to define a new array for
    `comments`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Second, we create a new method called `fetchComments` that accepts a parameter
    of `postId`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create a fetch request in the body of the newly created method and
    use `postId` to create the correct request URL. Just like before, we make sure
    to pass the correct `app-id`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we fetch the response JSON and assign it to the `comments` reactive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we call this function when the component loads. As mentioned before,
    calling a function within the script setup body is equivalent to calling it on
    the created life cycle. The function will receive the `postId` property as its
    argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this stage, our Companion App will render the `comments` body that is currently
    received from the API request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: The comments body displayed in the Companion App](img/B21130_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: The comments body displayed in the Companion App'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the screenshot displayed in *Figure 7**.4*, we can deduce that there are
    two main changes that we need to implement in the component:'
  prefs: []
  type: TYPE_NORMAL
- en: Improve the UI when no comments are available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Format the body of the comments to just show the author’s name and the message,
    instead of the raw object received by the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To improve the user experience and show a different message if there is a post
    with no comments, we can use the built-in `v-if` and `v-else` directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Just like a simple `if`/`else` statement, when a Vue.js component receives elements
    that include a `v-if` and `v-else` directives, it will just render one of the
    two, depending on the condition received. In our case, the first block will be
    rendered if the comments array is empty and has a length of zero, while the second
    block will render if comments are available.
  prefs: []
  type: TYPE_NORMAL
- en: Use <template> to avoid unused HTML elements
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we used an element called `<template>` when introducing
    the `v-if`/`v-else` code block. The `<template>` element is a special Vue.js element
    that allows you to add logic without the need to add an HTML element. In fact,
    if the template element was not available, we would have had to add `<span>` or
    `<div>` just to allow us to add our logic. Every time you use the `<template>`
    element, it will disappear and will not render anything within the DOM. It is
    very useful in logic that uses `v-if`, `v-else`, `v-if-else`, or `v-for`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s fill in the code blocks that we just created with the correct HTML. The
    first block will just show a static message for the empty state, while for the
    second, we need to analyze the object received by the API and understand what
    we want to display.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is now time to focus on the structure of the comments. The `comment` object
    seems to include multiple properties, but the only ones we should use are the
    name of the user and the message, therefore `owner.firstName` and `message`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `v-if` statement includes a simple static message, while `v-else` contains
    a loop created using the `v-for` directives, `<div v-for="{owner, message} in
    comments" class="comment">`, that includes two mustache templates to format our
    string, `<p>{{ owner.firstName }}: <strong>{{` `message }}</strong></p>`.'
  prefs: []
  type: TYPE_NORMAL
- en: After the latest modification, our Companion App should display a nicely formatted
    layout for our comments.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: The Companion App’s formatted comments](img/B21130_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: The Companion App’s formatted comments'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to load information asynchronously using an
    external API; we then walked through the changes necessary to ensure our application
    can work with the new dynamic data. The section also included a few tips to help
    you improve your Vue.js skills, such as the use of `<template>` to keep the HTML
    clean, the need to declare multi-word properties with kebab case, and the defining
    good properties to ensure that our components will not render incorrectly if any
    of the values are missing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to learn how to trigger side effects, such
    as API requests, when watching for components’ data changes.
  prefs: []
  type: TYPE_NORMAL
- en: Watching for changes in components using watch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to load our data dynamically by triggering
    an API request during the component rendering cycle. In this section, we will
    see another aspect of asynchronous data loading by describing how to handle API
    requests, triggered as a side effect when watching for data changes.
  prefs: []
  type: TYPE_NORMAL
- en: As we learned in [*Chapter 5*](B21130_05.xhtml#_idTextAnchor060)*,* computed
    properties are a great asset to watch other properties and internal data to create
    new variables, but they are not handy when we need to trigger a side effect, such
    as a DOM change or an API call.
  prefs: []
  type: TYPE_NORMAL
- en: This is where a Vue.js feature called `watch` comes to the rescue. `watch`,
    just like `computed`, allows you to listen to any changes that occur to properties,
    reactive data, or another computed property, but it also provides you the ability
    to trigger a callback when data changes.
  prefs: []
  type: TYPE_NORMAL
- en: watch is just for edge cases, not everyday use
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself using `watch` often during your development, it means that
    you are using `methods` and `computed` incorrectly. It is very common for inexperienced
    Vue.js developers to overuse `watch`. I have personally used it just a handful
    of times in years of development.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to change our application to automatically load more posts if there
    are fewer than four posts shown on screen. As mentioned previously, we are going
    to watch for a component variable (in our case, the `posts` array), and we are
    then going to trigger a side effect (in our case, another API call) when a certain
    condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s develop this together. First, we need to update our `fetch` method to
    accept a page parameter to ensure that we fetch new posts and not always the same
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The `fetchPosts` method now accepts a parameter of `page` and appends it to
    the request query parameter, `` `${baseUrl}/post?limit=5&page=${page}` ``.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are then going to create a new ref called `page` that will hold the current
    page value. To accomplish this, we are going to import `ref` from Vue.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define and initialize the variable. Because the first page of the
    posts is going to be 0, we are going to use this number as the initialization
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we are going to pass this `ref` when calling `fetchPosts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Remember that because we used `ref` to define our page variable, we need to
    use the `.value` notation to access its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is time to create our `watch`. Just like `computed`, `watch` will depend
    on one or more other reactive values, like `Ref` and `Reactive`, and will include
    a callback value. The syntax is `watch( dependentData, callback(newValue, oldValue))`.
    So, in our case, the code would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '`watch` is meant to observe variable changes and trigger a callback. In our
    example, the application observes the variable called `posts` and triggers a callback
    that will change the `page` variable and fetch new posts, using our API. The callback
    triggered by `watch` offers two values; the first is the new value that the observed
    variable has received, and the second is the old value.'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, you will probably just use the first value (therefore, the
    new value of the observed data), but having access to both values is very useful
    when the effect triggered is dependent on the “change” of the variable. For example,
    this may be needed if you have an animation that shows different effects, depending
    on whether the value increases or decreases. This would only be possible if you
    have both the old and the new values to compare.
  prefs: []
  type: TYPE_NORMAL
- en: Our Companion App should now be ready to be tested. To test our new functionality,
    delete a couple of posts by clicking the delete icon next to them, and then see
    the new posts load dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few more options available with `watch`, such as the ability to
    trigger it after the effect has taken place in the DOM, or the possibility to
    trigger it immediately when the component renders. However, these are out of the
    scope of this book, as they are for more advanced use and would just be confusing
    at this stage.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that using `watch` has a cost. In fact, there is a cost to be paid
    for an application observing a value, but there is an even greater performance
    cost in triggering a callback on every change of a value. For this reason, it
    is recommended to use `watch` only when needed and to ensure that the body of
    the callback is not too resource-intensive.
  prefs: []
  type: TYPE_NORMAL
- en: Use computed to minimize watch callbacks
  prefs: []
  type: TYPE_NORMAL
- en: If you are observing a variable that changes too often and want to try and improve
    on performance, you can use `computed` to create a new variable. This new computer
    property can then be watched instead. Because computed properties are cached,
    this approach is more performant.
  prefs: []
  type: TYPE_NORMAL
- en: That completes our introduction to `watch`. This is a useful feature that, when
    used correctly, can help you create clean and readable components.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned what `watch` is and how using it improves our component,
    giving us a chance to trigger side effects from our application, such as an API
    request or DOM modification. We then made changes in the Companion App to better
    understand this topic. Finally, we explained the drawbacks of using `watch` and
    discussed when and how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to introduce a built-in component called `<Suspense>`.
    This feature simplifies how we handle the loading state of asynchronous components.
  prefs: []
  type: TYPE_NORMAL
- en: Handling asynchronous components with <Suspense>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling dynamic data loading is never easy. In fact, when data is static and
    hardcoded, displaying the information takes no effort, as the data is available
    on first render, but when the data needs to come from an outside source, such
    as a database or a third-party API, then the complexity increases. When loading
    information asynchronously, the data is not available on the first load, forcing
    us to handle a “loading state” until the data is available, or having to display
    an error state if the loading event has failed to complete.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent having to handle state changes in multiple components and code duplication,
    Vue.js introduced a globally available built-in component called `<Suspense>`.
  prefs: []
  type: TYPE_NORMAL
- en: With `<Suspense>`, we can orchestrate all loading states at once with very clean
    syntax. In the following section, we are going to first understand what makes
    a component asynchronous and then understand how this can be used to simplify
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: An experimental feature
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, `<Suspense>` is still an experimental feature, and there
    is no set date on when and if it will become a core part of the Vue.js framework.
    The team is fixing a few bugs with it and more importantly, developing server-side
    support before it is turned into a full feature.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding asynchronous components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding introduction, we discussed an async component by using the
    example of a component that needs to load data dynamically, but that is not the
    actual definition of an async component.
  prefs: []
  type: TYPE_NORMAL
- en: An async component is “*a component that requires an asynchronous function to
    be performed and completed before the rendering can* *be initialized*.”
  prefs: []
  type: TYPE_NORMAL
- en: The important takeaway from the preceding definition is the words `async` operation
    and the need for it to be completed are requirements for a component to be defined
    as an asynchronous component.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, if we look at our current application, we can see that we already have
    dynamic data that is loaded in `SocialPosts.vue`, but this does not make it an
    async component, as the component is rendered immediately and does not wait for
    the `fetch` operation to be completed.
  prefs: []
  type: TYPE_NORMAL
- en: An asynchronous component is characterized by the presence of a top-level `<script
    setup>` code block.
  prefs: []
  type: TYPE_NORMAL
- en: An asynchronous component affects the page rendering
  prefs: []
  type: TYPE_NORMAL
- en: An asynchronous component will stop the rendering itself and all of its children
    until the data is fully loaded. This should just be used if the component has
    no reason to render without the data being available.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at our Companion App and try to find a good candidate to turn into
    an async component. Currently, only two components have asynchronous operations
    between them, `SocialPosts.vue` and `SocialPostComments.vue`.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the logic within the `SocialPostComments.vue`, we can see that
    the component does not currently function properly. The current component logic
    displays a message when the comments array is empty, `"<p>There are no comments
    for this post!</p>"`, but this message is also displayed when the component first
    renders. This is because the component renders immediately, even if the `fetch`
    request is still active.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very good candidate to be turned into an async component. In fact,
    this component has both an “async operation” and the “need for it to be completed,”
    as mentioned in the definition of an async component.
  prefs: []
  type: TYPE_NORMAL
- en: Turning a component into an asynchronous component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vue.js provides a very simple way to define a component as an asynchronous component.
    In fact, all we need to do is ensure that the component includes one or more `await`
    functions within its body.
  prefs: []
  type: TYPE_NORMAL
- en: When the Vue.js framework sees an await function, it automatically defines the
    component as async.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify `SocialPostComments.vue` to await the `fetch` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Our component logic required just two small changes to turn the component into
    a dynamic one. First, we made sure that our `fetchComments` method returned a
    promise by adding `return` before the `fetch` method. Then, we added `await` when
    calling the method. These two changes were all that was needed to ensure the component
    would turn into an async component.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that is left to do now is learn how to use asynchronous components. In
    fact, at this stage, the Companion App is unable to load comments, and clicking
    on the “Load comment” button would log the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: An error message triggered by Vue.js when trying to incorrectly
    load an async component](img/B21130_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: An error message triggered by Vue.js when trying to incorrectly
    load an async component'
  prefs: []
  type: TYPE_NORMAL
- en: The error message mentions the need for the async component to be nested in
    `<Suspense>` in order to be rendered. Let’s learn what this `<Supense>` is and
    how it can be used to load async components.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering async components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we made the `SocialPostComments.vue` file asynchronous,
    and it is now time to learn how to handle this component to ensure that it is
    loaded correctly.
  prefs: []
  type: TYPE_NORMAL
- en: As we previously mentioned, when a component is turned into an asynchronous
    one, it then requires us to handle its loading state. Loading this component normally,
    as we are currently doing in the application, would not work, as the component
    is not immediately available, so we need to find a way to handle its load gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: As always, the Vue.js core team has worked hard to provide us with all the tools
    we need to quickly accomplish complex operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component is defined on the official Vue.js documentation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: “`<Suspense>` is a built-in component for orchestrating async dependencies in
    a component tree. It can render a loading state while waiting for multiple nested
    async dependencies down the component tree to be resolved.”
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping one or multiple components within `<Suspense>` prevents them from rendering
    until all the async operations are completed. Furthermore, `<Suspense>` also allows
    you to display a “loading” component while the async operations are completed.
  prefs: []
  type: TYPE_NORMAL
- en: '`<Suspense>` is already preloaded in the application, and it does not need
    to be imported. Let’s open `SocialPost.vue` and change our code to correctly load
    our async component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The use of this built-in component is very simple. In fact, all we need to do
    is wrap `SocialPostComments` within `<Suspense>`, as highlighted in the previous
    code block, and move the `v-if` directive, `v-if="showComments"`, from `SocialPostComments`
    to the built-in `Suspense` component. After these changes, `SocialPostComments`
    will simply render after the async operation within the component resolves.
  prefs: []
  type: TYPE_NORMAL
- en: There are cases in which you may be required to display a loading indicator
    while the async operation completes. `<Suspense>` provides a named slot called
    **fallback** that can handle this. Let’s learn how to use this feature by adding
    a fallback message while the post comments load.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement a fallback message, our code would require the following modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a message while the comments are fetched, we use the `SocialPostComments`.
    This slot is going to be defined using the `<template #fallback>` syntax. The
    content of this slot will just be displayed while the async operation within `SocialPostComments`
    is run, and it will disappear as soon as the component is rendered.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom error handling
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, error handling is not handled by `<Suspense>`, and this needs
    to be handled manually using `onErrorCapture()` hooks. Explaining this is beyond
    the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now completed everything we had to learn about async data and component
    loading. We started the chapter by removing the hardcoded `posts` and replacing
    them with dummy data that is loaded dynamically. We then fixed the property mismatch
    caused by the data change, learning how to prevent this in the future by improving
    the use of property typing and validations.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we learned how to change our data flow to load comments on demand and
    defined when this should be used, as well as the performance and user experience
    benefits that this brings. We then introduced another feature related to async
    operations, `watch`. We used this feature to trigger a side effect and automatically
    load more posts when the number of posts reaches a certain number.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we learned how to create and handle asynchronous components. We described
    what makes an async component and changed our Companion App to ensure our comments
    were fetched before loading the component. We concluded the chapter by introducing
    the `<Suspense>` built-in component, using it to correctly load our asynchronous
    component, and we also examined a fallback feature that shows text while the component
    loads.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, you should be able to fully handle asynchronous data loading,
    side effects, and components that require JavaScript promises to be fulfilled
    before being displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to move our focus away from Vue.js and focus
    on testing our application. We will learn the basics of end-to-end testing with
    **Cypress** and unit testing with **Vitest**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Expanding Your Knowledge with Vue.js and Its Core Libraries'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this stage in our journey, it is time to introduce the external libraries
    that are part of the Vue.js ecosystem that are required to build production-ready
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B21130_08.xhtml#_idTextAnchor103)*, Testing Your App with Vitest
    and Cypress*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B21130_09.xhtml#_idTextAnchor120)*, Introduction to Advanced
    Vue.js Techniques – Slots, Lifecycle, and* *Template Refs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B21130_10.xhtml#_idTextAnchor135)*, Handling Routing with* *Vue
    Router*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B21130_11.xhtml#_idTextAnchor153)*, Managing Your Application’s
    State with Pinia*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B21130_12.xhtml#_idTextAnchor163)*, Achieving Client-Side Validation
    with VeeValidate*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
