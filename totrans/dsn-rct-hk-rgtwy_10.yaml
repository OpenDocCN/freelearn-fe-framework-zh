- en: '*Chapter 10*: Building a Website with React'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last chapter of this book, we will talk about *React* in general, especially
    the role that *React* plays in web development. We will approach this topic from
    three aspects to see how *React* puts resources together to build a site. First,
    we will take a look at how *React* embraces new *JavaScript ES6* features, such
    as arrow function and template strings. Then, we will walk through how a component
    can be styled using a *CSS-in-JS* approach via libraries such as `styled-JSX`
    and `styled-components`. Last, but not least, we will also get to know JSX code
    and how it is used to transform the *HTML*-like lines into *JavaScript* expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The function of *React*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embracing *JavaScript* *ES6*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adopting CSS-in-JS approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going from *HTML* to JSX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions and answers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring functions of React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will start with an exploration of the function React serves
    in the website development field. By doing that we hope to get a more accurate
    description about how React can help us.
  prefs: []
  type: TYPE_NORMAL
- en: The book has been dedicated to introducing a state into a function component
    under *React*, especially the hook mechanism. We hope that by reading this book,
    you get to know how to design hooks in the right way.
  prefs: []
  type: TYPE_NORMAL
- en: 'When comparing *React* to other UI frameworks, have you heard that sometimes
    people refer to it as a utility rather than a framework? There''s no clear definition
    of what should be called a framework and what shouldn''t. Judging by the amount
    of *React* source code and how it wires with other systems, we can hardly treat
    it as a utility library. But at the same time, we also should remember the goal
    that *React* established with in the first place, because knowing this will help
    you to use this technology in the right way. Let''s take a look at the usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is how we start all *React* projects. It searches for a *DOM*
    element and renders a component under it. Moreover, afterward, the screen under
    that element gets "managed" by *React*. This means that *React* overwrites everything
    under that element and refreshes upon any state change inside the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the preceding `ReactDOM.render` method is the line to integrate
    *React* with your project. As you see, this line is powerful. In fact, it can
    be used multiple times for one project. Consider the following *HTML* page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of controlling the whole site, we want to replace each `slider` instance
    with something more feature-rich:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can go through the elements matching the `slider` instance in the *HTML*.
    For each element found, we take its `value` attribute and send it to a component
    with `ReactDOM.render`. Wow! All sliders are managed by *React*.
  prefs: []
  type: TYPE_NORMAL
- en: Although having multiple `render` instances is not a typical approach, we build
    a **Single Page Application** (**SPA**). This does give us one important message;
    that is, from the technical aspect, the goal of *React* is to replace and manage
    *DOM* elements on the screen. To make this happen, a new root fiber is created
    internally for each element so the engine knows where to start updating when a
    dispatch arrives.
  prefs: []
  type: TYPE_NORMAL
- en: We know by now what *React* is designed to do. Let's take a quick look at how
    much effort it takes to do this â€“ for instance, what are all the dependencies
    to invoke the `render` statement?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To kick off the engine, we need a `render` function provided by the `react-dom`
    package. The component can be designed somewhere else, which requires the utilities
    of the `react` package, such as `createElement` and `useState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Other than `react-dom` and `react` packages, it's the `document` object that
    we need to locate and manipulate the *DOM* element. But normally, as long as we
    have a browser session, we assume the `document` is available.
  prefs: []
  type: TYPE_NORMAL
- en: In short, there are two dependency packages. The `react` package is used for
    defining a component. With it, the component definition can be output into a format
    that the engine can understand. The `react-dom` package is used to render and
    manage the component to the screen. This means that before you kick off the engine,
    you don't need `react-dom`. Most of the development time is spent using the `react`
    package to define our components. From this exercise, we should clearly see the
    function of *React* as a utility library.
  prefs: []
  type: TYPE_NORMAL
- en: To build a website with *React*, we need to do all the things that a web developer
    needs to do, that is, designing the site layout with *HTML*, making the site look
    beautiful with *CSS*, and adding business logic and interaction to engage the
    user with *JavaScript*. So, the question becomes how all these building blocks
    fit in the new component ecosystem. Let's take a look at them one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Embracing JavaScript ES6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*React* is written in the *JavaScript* language. *JavaScript* has been evolving
    for the past 20 years. With usage in frameworks such as jQuery, Angular, *React*,
    and Node.js, *JavaScript* is one of the most popular and influential programming
    languages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The latest *JavaScript* is based on ECMAScript 2015, which is also known as
    *ES6*. This brought a few important features to *JavaScript*, and *React* has
    quickly adopted these features quite nicely. The following are just a few of the
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrow function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spread and rest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object enhancement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destructuring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let and const
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are considering using *JavaScript* as your main language, it's recommended
    that in your free time, you go over all the preceding materials because they are
    commonly used by *React* apps. We'll go over each of these features in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The arrow function is a new syntax for function expressions. A typical function
    can be defined with a `function` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*ES6* introduces a more compact way of defining the preceding function with
    an arrow (`=>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding arrow version omits the word `function` and makes a function
    look more like an object. The arrow function is often used as a callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code returns a new array with each element doubled. When we make
    a dispatch in *React*, we also tend to use the arrow syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `return` statement can be omitted if the arrow function returns
    a single expression. We can compare the preceding line with the regular function
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s apparent that the arrow function tends to be compact while working as
    an object. Being an object implies that we can pass it freely to anywhere via
    a function input argument. Sometimes, you also see a chained version, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You may find the arrow function quite expressive. The book basically uses this
    format solely. Only in one case does the book revert to the regular function format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can invoke the function before the declaration in general, the compiler
    wouldn''t complain. However, this wouldn''t work for the arrow function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is because `fn` needs to be declared first before it can be referenced.
  prefs: []
  type: TYPE_NORMAL
- en: 'The arrow function, though more compact and expressive, does carry some caveats
    compared to the regular function:'
  prefs: []
  type: TYPE_NORMAL
- en: It sets the `this` object upon creation instead of invocation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not set the `arguments` object after invocation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It cannot be used as a `constructor` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spread and rest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pretty new to the *Javascript* language, spread is a way to express all the
    parts of an item, and rest is a way to express the rest of the part of an item
    apart from the first few parts.
  prefs: []
  type: TYPE_NORMAL
- en: '*ES6* introduces quite a few features to allow our code to be more expressive.
    One of the features is to use a `...` keyword, as hardly anybody bothers to remember
    the exact feature name. Let''s take a look at one example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the `b` variable gets all the elements from the `a`
    array, spreads them into five elements, and then appends the new element so that
    the new array carries six elements in total. You can use this with an object as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `b` variable gets all the properties from the `a`
    object, spreads them, and then adds the new `age` property so that the new object
    carries three properties in total.
  prefs: []
  type: TYPE_NORMAL
- en: Note that both usages of the spread operator create a new variable, either an
    array or an object. When it comes to quickly creating another variable out of
    an existing variable, this new syntax becomes quite popular.
  prefs: []
  type: TYPE_NORMAL
- en: '*React* uses this feature quite often in component design:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding component uses the `props` object to capture a list of props
    other than `title`. This becomes useful for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: We do not have to care about the number of other props present in the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can send this list further down into the children component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There''s another similar *ES6* feature called the `rest` operator which behaves
    similarly to the `spread` operator. This is when `...` is applied to a function''s
    input argument list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `abc` function, we used a `...` rest operator to obtain additional
    arguments.. The `rest` variable holds an array, and when we invoke the function
    with more than two arguments, the additional arguments get populated into this
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Object enhancement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With *ES6*, an object is extended to support quite a few features. Let''s take
    a look at some of them. One of the features is that we can use a shorthand version
    while making an assignment to a property under an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we write the preceding code in the old way, it would be equivalent to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If the property name matches the assignment variable name, *ES6* allows us
    to write the property name only once. This becomes handy in practice, and because
    of this, it''s common to see people take advantage of it by creating a temporary
    variable to match with the property name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Another enhancement to an object is to support an expression as the property
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is what we write to support a form submission. Don''t confuse
    the last line of that code with the following version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the difference between these two is the bracket around `name`. Without
    the bracket, `name` would assign the value to the "`name`" property. However,
    in the `[name]` version, it would assign the value to a property with a name stored
    in a `name` variable. If `name` carries a "`first`" word, then the `[name]` version
    would become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, this enables us to use any *JavaScript* expression as the property
    key. This was not possible before, so we used to write the following to remedy
    the issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Template strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It used to be cumbersome to construct a long string in *JavaScript* without
    sacrificing the raw format of the string. To address this problem, *ES6* added
    the template strings, which allow a string to be enclosed by the back-tick (`''`),
    a strange character that we use often when working with *Markdown* files. With
    this syntax, a string can be written in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s interesting about the template, beyond the regular quoted string using
    `"` or `''`, is that it supports a paragraph of text written across multiple lines
    while preserving the line breaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes it useful when we want to introduce a paragraph of long text without
    formatting its content. The template strings also work with any *JavaScript* expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we replaced the incidence of `${what}` with the `"This"`
    string in the template. Essentially, what's written inside `${}` can be any *JavaScript*
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common usage of the template strings is to convert another format into
    a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You can see in the preceding code that this becomes handy when we need to assemble
    a string such as a dynamic `url`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can apply the preceding code to a more complex version, such as the *CSS*
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code uses a different form called tagged templates, and `css`
    is what''s referred to as a tagged function. Here''s another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defines an `image` tagged function, which transforms `strings`
    into another format â€“ in our case, an image element statement. From this, you
    can see that tagged templates can be useful as a utility to alleviate the pain
    of generating strings. In the *Adopting CSS-in-JS* approach section that follows,
    we shall see more examples of this.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The word "destructuring" is an awkward word to say and maybe we can't even find
    it in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you might have used this feature quite a few times in the past:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Essentially, destructuring allows you to destruct an object and assign the
    dissembled elements to variables. The preceding code is destructuring usage applied
    to an array, which is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that during the destructuring process, we follow the given structure
    to select the needed elements. Similarly, it can be applied to an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding statement translates to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Although we can continue to use the old method, destructuring is much easier
    and quicker to use. Keep in mind that the element you select has to exist; otherwise,
    you can get an `undefined`, as shown in the following case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful feature with destructuring is that you can rename a property
    if you want to store it under another name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line translates to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, the `firstName` variable is used for the assignment instead of
    `first`, even though `first` is the property name under the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quite often, destructuring is used in combination with other *ES6* features,
    such as the spread operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We see this preceding statement quite often in *React* code, so let me explain
    each part of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`...name` is to spread all properties of the `name` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`last` is the enhanced object syntax to add the `last` property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{ ...name, last }` creates a new object out of the existing one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`first` is destructuring the `first` property out of the new object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wow, there''s a lot going on! Maybe we can write it in an equivalent version
    using the old method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, the new syntax takes only one line instead of three lines, but
    shockingly the outcome is much more accurate and expressive.
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to this feature, don't hesitate in slowing down a bit while composing
    each part. The reason for that is, you will not only gain knowledge on what the
    new syntax provides but also you won't miss any logic accidentally.
  prefs: []
  type: TYPE_NORMAL
- en: let and const
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using *JavaScript* in the past, you may have been confused by the `var`, `let`,
    and `const` keywords. Which one are you supposed to use to declare a variable?
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to first get out of way is that `var` isn''t used often anymore;
    it''s there mostly for backward compatibility because it uses a strange scope
    rule. Instead, we should all use `let` and `const` because they are based on block
    scopes that developers are more comfortable using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `a` variable lives in the scope of the function and
    the `b` variable lives in the scope of the condition statement. Both references
    are valid in the scope specified by the `{}` parent enclosing block. If you try
    to reference either `a` or `b` outside of their defined scope, the compiler now
    throws an error. The same applies to the `i` variable, defined using `let` under
    the loop. If we had used `var`, it would make `i` accessible within the entire
    function body.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the names imply, you use `let` for a variable that needs to change later
    on and `const` for things you don''t expect to change. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, if you change `x` to `6` later on, it's totally fine.
    But the compiler will raise an error if you try to change `n` to `"def"`. This
    applies to any primitive value, such as a number or a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to a non-primitive value, such as an object or an array, it gets
    a bit complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Can you differentiate what the difference is between the preceding two lines?
    What is a variable object and what is a constant object?
  prefs: []
  type: TYPE_NORMAL
- en: 'If an object is declared with `const`, it means only the object itself can''t
    be used to point to another memory space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we defined an `obj` constant. Later on, if we attempt
    to overwrite `obj`, the compiler will throw an error. However, if we modify its
    content via a key, it''s still valid. Similarly, we can expect this behavior from
    an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You might find this behavior a bit strange, but it actually is designed pretty
    consistently for all objects and arrays when it comes to their initialization,
    comparison, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you see an array or object defined with a `let` statement, it should tell
    you that they can be overwritten later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This is the main difference between the `let` and `const` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There''s one thing a developer can''t live without these days, which is code
    imported from another file. However, *JavaScript* didn''t support this until *ES6*
    finally introduced a module system similar to what module loaders such as *AMD*
    or *CommonJS* provide. The idea is that we can export something from a file for
    reuse, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is quite common in a *React* application. Basically, it
    defines a `Title` component in a separate file and exports it as a default. From
    another file, we can import it and use it through an `import`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This is the main mechanism for pulling all the files together and compiling
    them into a single `index.js` file because it actually imports all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we also want to export other materials along with `default`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we exported `Title` as `default`, and we also exported
    `TitleType` as a non-default. This means that we can cherry-pick things and import
    them individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This capability becomes handy when we store a bunch of related utility functionalities
    in a single file and export them one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid the name collision, upon import, we can use the aliasing import via
    the `as` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Symbol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Symbol is a new *JavaScript* feature that sounds like a game term. In fact,
    it is a special primitive type. Normally, we could have a string as a property
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Anyone who writes the preceding line can access the value stored under the
    `name` property. But what if we want to restrict access to only people who know
    a key? You may ask, "what do you mean by that? Isn''t the `"name"` string public
    to anyone?" That is the point â€“ we want to create a key that not everyone can
    recreate easily. Here''s what we will do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, a `Symbol` with the "`name`" string is created to serve
    as a key. We can still access this symbolized property under `obj` if we have
    the exact key. But it won''t work if you create another key like that and try
    to access the property, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Hmm, aren''t we using the same code again? Why can''t we access the same key?
    The answer lies in the following comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding comparison between two `Symbol(''name'')statements` returns `false`!
    This means you can''t expect to recreate the `"name"` key by writing it again;
    you can only have the original key you create in the first place or query through
    it from all registered keys in the system via `Symbol.for`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we find the key in the system, we can then access the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Ahh. This is interesting, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: A symbol is a primitive that cannot be recreated and is guaranteed to be unique!
    This means that it can serve as a unique key to a door. If the key is not present,
    then the door can't be opened.
  prefs: []
  type: TYPE_NORMAL
- en: This becomes useful when we don't want any developer to mistakenly access some
    memory or assign a value. It also becomes useful to transfer this key to another
    project or repository in a unique way. I will show you an example of how *React*
    uses it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have gone over a couple of topics from *ES6*, including arrow functions,
    object enhancement, template strings, destructuring, `let` and `const`, modules,
    and symbols. But there's actually more to *ES6*, such as promise, proxy, generators,
    and weak map. We used promise when we referred to an API and used proxy in [*Chapter
    9*](B17963_09_Epub.xhtml#_idTextAnchor314), *Use Custom* *Hooks to Reuse Logic*.
  prefs: []
  type: TYPE_NORMAL
- en: One thing for sure is that *React* really takes advantage of the latest *JavaScript*
    language. If you practice them often, one thing you will find is that code becomes
    more expressive without losing its accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll see how *React* uses materials from non-*JavaScript*
    languages, such as *CSS*.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting CSS-in-JS approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we build an application in *React*, at one point, we need to find a way
    to apply *CSS* styles to our code, right? If you have *CSS* experience in the
    past, one approach we''re familiar with is to use *CSS* classes to style styles.
    Consider the following *CSS* snippet stored in a file with a .`css` extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We can apply this style to a *React* element via a prop called `className`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`class` is a reserved keyword for *JavaScript* and therefore can''t be used.
    Instead, *React* chooses to use a different word, `className`.'
  prefs: []
  type: TYPE_NORMAL
- en: Though this old method continues to work, there's one issue about the uniqueness
    of the `title` class. *CSS* can be applied to all the `title` elements on the
    screen, but it can't skip an element inside a component that we don't want to
    be styled. From the *CSS* perspective, the `title` class is exposed to be styled
    globally.
  prefs: []
  type: TYPE_NORMAL
- en: Using a component design, it's just natural that we would want to apply the
    style to this component only! For example, the `title` style we defined can be
    only valid inside the `Title` component. Believe it or not, having a scope is
    the foundation of the component design.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to make the style unique to the component is to bake the style inline
    along with the element using a `style` prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'But the problem of the preceding hardcoded approach is also quite obvious.
    It''s just not feasible to write a large amount of styles inline. This is where
    the *CSS-in-JS* approach comes into play. The idea is to utilize a template string
    to write the *CSS* using the old method. Okay, we just introduced the template
    strings from one of the *ES6* features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: There's almost no learning curve to use the preceding string. Thus, this approach
    has been adopted by the community quickly and implemented by a couple of libraries,
    such as `styled-JSX` and `styled-components`. We will introduce both in this section,
    so let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: styled-SX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`styled-JSX` is a *CSS-in-JS* library that allows us to write scoped *CSS*
    for a component where the style doesn''t affect other components, thus allowing
    us to amend styles without worrying about making changes to other components on
    the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the same `Title` component and see how it''s done with `styled-JSX`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: It introduces a special `style` tag with a `jsx` prop, and underneath it, the
    styles can be written as *CSS* code. The styles are only injected once, even if
    the `Title` component is used more than once.
  prefs: []
  type: TYPE_NORMAL
- en: 'This semi-inline approach of styles can be quite efficient when it comes to
    prototyping an application. Instead of putting the *CSS* inline with the component,
    we can put the styles in a separate file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We can import it into the `Title` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This gives us some freedom to write the CSS either inline or in a separate file.
  prefs: []
  type: TYPE_NORMAL
- en: 'One important thing to note is that the styles we wrote so far do not apply
    to child components by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code wouldn''t make any `span` element displayed with a green
    color. To get it working, we can use a `global` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '`styled-JSX` is quite a unique library that makes styling easy in *React*.
    Moreover, since the styles are actually written in a *JavaScript* string, it can
    be manipulated at runtime. We''ll demonstrate this feature in the next package,
    `styled-components`, since this feature works for both packages.'
  prefs: []
  type: TYPE_NORMAL
- en: styled-components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There''s another library implementing the *CSS-in-JS* strategy called `styled-components`.
    This book has adopted this approach for all examples requiring styles. Instead
    of using a `style` tag, it actually allows us to define the *CSS* in a separate
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `styled.h1` is a tagged template function that outputs
    a component with an embedded `h1` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, `styled-components` allows *CSS* to apply to the children by default,
    which is very different from the `styled-JSX` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code sets the `span` element with a green color. This reminds
    us of Sass or SCSS code.
  prefs: []
  type: TYPE_NORMAL
- en: 'One interesting benefit that the *CSS-in-JS* solution provides is that the
    *JavaScript* string can be blended with other *JavaScript* expressions to support
    dynamic styles at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defines a `big` prop that can be sent to the `TitleStyle`
    component where, based on the `big` value, `fontSize` can be switched between
    `3em` and `1.5em`.
  prefs: []
  type: TYPE_NORMAL
- en: The dynamic *CSS* support makes it possible to create themeable components quite
    easily in *React*, and also opens the door for animating components that require
    a value change over time.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how *React* brings *CSS* into *JavaScript* to blend the
    two technologies together, let's move on to *HTML* and see how it can be brought
    into *React*.
  prefs: []
  type: TYPE_NORMAL
- en: Going from HTML to JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One barrier for a developer adopting *React*, especially if they are used to
    working with other web technologies, is that *HTML* isn''t imported into the project
    anymore. There''s not a file with a `.html` extension, except the entry `index.html`
    file, which most of the time only has one line of *HTML* inside, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: But that's it. If there was a project manager that liked to review *HTML* or
    even work on it, they can't do that anymore. This missing *HTML* file could be
    one of the reasons why teams are hesitant to adopt *React*.
  prefs: []
  type: TYPE_NORMAL
- en: However, *HTML* has a similar problem to *CSS.* They don't have scopes that
    we have in programming languages. Even worse, a piece of *HTML*, once written,
    is almost turned into *DOM* elements instantly. So, a component-based system has
    to come up with a way to add a layer in between.
  prefs: []
  type: TYPE_NORMAL
- en: 'How did *React* solve this problem? It chose to take the *HTML* in â€“ no surprise.
    But one amazing job that *React* did is that it kept the experience of writing
    these statements as close as possible to *HTML*. Technically, *React* made the
    smooth transformation from a piece of *HTML* to a piece of *JavaScript* code possible.
    Sometimes, we don''t notice this, nor can we tell the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is what we use inside a function component. The format does
    look like a piece of *HTML*. What''s seen by the compiler is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: After the compiler transformation, it becomes a *JavaScript* expression of a
    `createElement` function, taking three input arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The magic of how this transformation happens is done through a compiler with
    a *Babel* plugin. When the compiler builds the code, Babel converts the code into
    an abstract syntax tree, a token format, and then stitches them back together
    and puts them into the *JavaScript* format.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in knowing what a compiler does, you can visit [https://babeljs.io/repl](https://babeljs.io/repl)
    and try it out yourself.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to take a look at this `createElement` function closely now. The
    first input argument of the `createElement` function is the `type` of the element,
    which is taken from the element tag `h1`. The second one is the `props`, which
    is an object containing the `title` property. Last, but not least, the third one
    is the `children`; in our case, it's a string containing `"Hello World"`. Let's
    walk through these input arguments in more detail, since each of them is an essential
    part of *React*!
  prefs: []
  type: TYPE_NORMAL
- en: Props
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `props` input argument is one of the most important *React* mechanisms.
    We have been talking about props all the time, and this is where they receive
    their first-hand values. It''s because `createElement` is a *JavaScript* function
    that we can wire any *JavaScript* expression to the props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, it's apparent now how a `title` prop and a `count` state
    are sent to `createElement` as part of the props.
  prefs: []
  type: TYPE_NORMAL
- en: 'This also explains why we can''t use the `class` reserved word as the prop
    to style the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code would raise a compiler error due to the `class` key.
  prefs: []
  type: TYPE_NORMAL
- en: Children
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `children` input argument is the reason that we can nest one element under
    another element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'What the compiler sees is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Note from the preceding output that there are two usages of `createElement`,
    one for the `h1` element and one for the child `span` element. The second `createElement`
    function is used as the `children` argument of the first `createElement` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's not too difficult to see a long list of elements nested and returned
    from a component via `createElement` functions. Technically, even without the
    compiler's help, you can code your component manually with this nested writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though a single element can be nested under, there can be cases where more
    than one element needs to be nested under another one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'For the preceding *JavaScript* expression involving an array, the array would
    be sent to the `children` of `createElement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Essentially, the `children` input argument can support the following formats:'
  prefs: []
  type: TYPE_NORMAL
- en: A `"Hello World"` string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single element via `createElement`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array of elements with either of the preceding format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*React* also allows you to add any number of children in another way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can stack the children in the input argument list,
    starting from the third input argument.
  prefs: []
  type: TYPE_NORMAL
- en: Element type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An element type, the first input argument to `createElement`, can be a simple
    string representing an *HTML* tag, such as `h1` and `span`. However, it can also
    take other formats, such as a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'What the compiler sees of the preceding code is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Note `Child` in the preceding code â€“ the function itself is sent to `createElement`
    as the element type! This is how *React* allows you to create an element out of
    a custom component. Because of this, it means we can support a dynamic element
    type at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, instead of returning either `<Child1 />` or `<Child2
    />`, we first determine the type of `Child` component at the runtime and then
    return the instance from this `<Child />` component. This is all possible because
    the component type is a *JavaScript* variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code confirms what the compiler sees. The `Child` component type
    is determined at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen the `createElement` function and its three input arguments,
    let's take a close look at what it returns.
  prefs: []
  type: TYPE_NORMAL
- en: React element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the `createElement` name indicates, the function returns a root element with
    a tree of elements under it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Is the element a *DOM* element? No, it''s called a *React* element. Though
    the *React* documentation doesn''t talk too much about it, we''ll reveal it a
    bit briefly here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a short definition of the *React* element definition.
    As you can see, it's basically an object. We've been introduced to `type` and
    `props`, but what the heck is `$$typeof`? Apparently, this is not something that
    *React* wants anyone to tamper with.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out *React* supports various categories of elements. For the lack of
    a better word, let's call `$$typeof` another type, an internal type. The one we
    used most often was `react.element`, and it's defined as a `Symbol`. We just introduced
    `Symbol` in the previous section. Basically, `react.element` is a unique primitive
    value that, once created, can be used but not changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may ask, "what are other types are there?" Actually, there are two dozen
    of them; here are just a few that might interest you:'
  prefs: []
  type: TYPE_NORMAL
- en: '`react.element`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react.portal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react.fragment`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react.provider`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react.suspense`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react.memo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react.lazy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we need all these different types?
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the application implementation is more or less around updating a `react.element`,
    but when it comes to special cases, it requires a different updating algorithm.
    Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `Provider` creates an element with a `react.provider`
    type. Under it, `<>` creates an element with a `react.fragment` type, and under
    it, `div` creates two elements with a `react.element` type. The entire component
    is wrapped in a `memo` element with a `react.memo` type. This gives you a rough
    idea of where different *React* elements are used.
  prefs: []
  type: TYPE_NORMAL
- en: In short, what returns from the JSX code block are *React* elements. These *React*
    elements are what is fed into the *React* engine.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started with the function of *React* in web development.
    We went into three aspects of it. First, we went through the latest *ES6* features
    of *JavaScript*, such as the arrow function and template strings. Next, we learned
    the *CSS-in-JS* approach to bring *CSS* into *JavaScript*, using libraries such
    as `styled-JSX` and `styled-components`. Last, but not least, we learned how *HTML*-like
    JSX code is transformed and returned as *React* elements. All in all, we saw how
    *React* pulls all these resources together, including *JavaScript*, *CSS*, and
    *HTML*, to help us build a site.
  prefs: []
  type: TYPE_NORMAL
- en: Questions and answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some questions and answers to refresh your knowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: What is *React*?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's a tool that allows us to design a component and manage its update with
    a render engine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What is *JavaScript ES6*?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*JavaScript* has all the latest features published as *ES6*. *React* takes
    advantage of them, using features such as the arrow function, template strings,
    and destructuring. Using them in your project would make your code more efficient,
    expressive, and maintainable.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What's *CSS-in-JS*?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*CSS-in-JS* refers to one opinionated but popular way to apply styles to a
    *React* component. The styles applied are localized to the component and don''t
    collide with any other components. Moreover, the styles can be wired with any
    *JavaScript* expression to support dynamic styles at runtime.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What is JSX code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*React* allows us to use JSX code to write *HTML*-like code. Practically, they
    look quite similar, except JSX allows us to transform these statements into native
    *JavaScript* expressions that accept element types, props, and children from the
    input argument and return *React* elements that the engine can put into effect.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
