- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Data Flow Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据流管理
- en: 'In previous chapters, we have focused on understanding the Vue 3 framework
    and providing a context to create web applications. In this chapter, we will focus
    on the way our components communicate with each other and share information to
    make our application happen. We have touched on this topic briefly previously,
    but now we will dive deep into some patterns by implementing them alongside each
    other. Applying an appropriate information workflow is an important skill that
    can make or break an application. In particular, we will see the following approaches
    and code examples:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们专注于理解Vue 3框架，并为创建Web应用程序提供上下文。在本章中，我们将关注我们的组件之间如何相互通信以及共享信息，以使我们的应用程序得以运行。我们之前已经简要地触及了这个话题，但现在我们将通过同时实现这些模式来深入探讨一些模式。应用适当的信息工作流程是一项重要的技能，它可以使应用程序成功或失败。特别是，我们将看到以下方法和代码示例：
- en: Parent-child-sibling communication
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父子兄弟通信
- en: Implementing a message bus using the **Singleton** and **Observer** patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**单例**和**观察者**模式实现消息总线
- en: Implementing a basic reactive state with composable components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可组合组件实现基本反应式状态
- en: Implementing a centralized data repository with the powerful Pinia reactive
    store
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用功能强大的Pinia反应式存储实现集中式数据仓库
- en: Reviewing browser-provided alternatives to share and store information
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查浏览器提供的替代方案以共享和存储信息
- en: Experimenting with reactivity, composables, and proxy patterns in action
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行动中实验反应性、可组合组件和代理模式
- en: As we have done previously, we will be building one concept at a time, incrementing
    in complexity. By the end of this chapter, you will have seen clear examples of
    implementation so that you can decide when to apply each one based on the needs
    of your application. Some of these are more suitable for small applications, and
    others for large, complex ones. You will be better prepared to control the workflow
    of information for your application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所做的那样，我们将一次构建一个概念，逐步增加复杂性。到本章结束时，你将看到清晰的实现示例，这样你就可以根据你应用程序的需求决定何时应用每一个。其中一些更适合小型应用程序，而另一些则更适合大型、复杂的应用程序。你将更好地准备控制你应用程序的信息工作流程。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter will approach concepts and apply patterns to control the communication
    and flow of information between components. You should be able to follow through
    with the code presented in this text, but for a better understanding and context
    experience, you would benefit from inspecting the full application code for this
    chapter, available in the repository for this book: [https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter07](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter07).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨概念，并将模式应用于控制组件之间的通信和信息流。你应该能够跟随本文本中展示的代码，但要更好地理解和体验上下文，你将受益于检查本章的完整应用程序代码，该代码可在本书的存储库中找到：[https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter07](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter07)。
- en: If you are starting a new project, just follow the instructions for scaffolding
    one, as seen in [*Chapter 3*](B18602_03.xhtml#_idTextAnchor079), *Setting Up a*
    *Working Project*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在启动一个新的项目，只需遵循[第3章](B18602_03.xhtml#_idTextAnchor079)中设置工作项目的说明，如*设置一个*
    *工作项目*。
- en: 'Check out the following video to see the Code in Action: [https://packt.link/ZKTBJ](https://packt.link/ZKTBJ)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码在行动：[https://packt.link/ZKTBJ](https://packt.link/ZKTBJ)
- en: Components’ basic communication
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件的基本通信
- en: We have seen previously that a parent component and its children have a rather
    simple and straightforward way to communicate. Parents pass data as `props` to
    their children, and these raise events (`emits`) to capture the attention of the
    parent. Much like the comparability of parameters and arguments in functions,
    `props` receive simple data by copy, and complex types (objects, arrays, and so
    on) by reference. We could pass, then, a plain object with member functions from
    the parent to the child, and have the child run the functions to access the parent’s
    data. Even though this “works”, it is sort of a dark pattern or anti-pattern,
    as it hides the relationship and makes it difficult to understand the data flow.
    The proper way to pass data upward in the component tree is through events (`emits`).
    Having said this, we must point out that child components are “ignorant” of each
    other, meaning that they do not have a direct way to communicate among themselves.
    We could pass a reactive variable and have each component involved access it,
    and this is certainly a working alternative, if not a clean one. In some cases,
    this would provide a simple solution, but again, it can lead to hidden side effects.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到，父组件及其子组件有相当简单直接的方式进行通信。父组件通过`props`将数据传递给子组件，而子组件通过触发事件（`emits`）来吸引父组件的注意。就像函数中参数和参数的可比性一样，`props`通过复制接收简单数据，并通过引用接收复杂类型（对象、数组等）。然后，我们可以传递一个包含成员函数的普通对象，从父组件传递给子组件，并让子组件运行这些函数来访问父组件的数据。尽管“这样做”是可行的，但这更像是一种暗模式或反模式，因为它隐藏了关系，使得理解数据流变得困难。在组件树中向上传递数据的正确方式是通过事件（`emits`）。话虽如此，我们必须指出，子组件之间是“无知”的，这意味着它们没有直接相互通信的方式。我们可以传递一个反应性变量，让每个涉及的组件访问它，这当然是一个可行的替代方案，如果不是一个干净的方案。在某些情况下，这可以提供一个简单的解决方案，但同样，它可能导致隐藏的副作用。
- en: 'To manage in a clean way the workflow of data, we have several alternatives
    that follow good practices and design patterns. As a general rule and principle,
    the component that declares the variable is the owner of it, and it should be
    the one that manipulates it. With this in mind, in the most basic communication,
    the information needs to be maintained and manipulated by the parent component
    and shared among the children. We can leverage Vue’s reactive system to spread
    the information. The key here is that only the parent component will manipulate
    it. Let’s see how this works in practice with an example, implementing a small
    trivial application, as shown in *Figure 7**.1*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以干净的方式管理数据的工作流程，我们有几种遵循良好实践和设计模式的替代方案。作为一个一般规则和原则，声明变量的组件是它的所有者，并且应该是操作它的组件。考虑到这一点，在最基本的通信中，信息需要由父组件维护和处理，并在子组件之间共享。我们可以利用Vue的反应性系统来传播信息。关键在于只有父组件会操作它。让我们通过一个例子来看看这在实践中是如何工作的，实现一个小型的简单应用程序，如图*图7**.1*所示：
- en: '![Figure 7.1 – Direct basic communication and reactivity](img/Figure_7.01_B18602.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 直接基本通信和反应性](img/Figure_7.01_B18602.jpg)'
- en: Figure 7.1 – Direct basic communication and reactivity
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 直接基本通信和反应性
- en: 'In this application, the parent component has three direct children and shares
    with them a reactive counter. All the components display a label with the value
    of the counter and have a button to trigger an increment... but only the father
    component performs the actual manipulation of the data. Vue handles the reactivity,
    meaning that when the parent modifies the value, the child components also receive
    them. Simple enough—let’s see the important parts of how this is implemented:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，父组件有三个直接子组件，并与它们共享一个反应性计数器。所有组件都显示一个带有计数器值的标签，并有一个按钮来触发增加...但是只有父组件执行实际的数据操作。Vue处理反应性，这意味着当父组件修改值时，子组件也会接收到它们。这很简单——让我们看看实现这一点的关键部分：
- en: /basic/ParentBasic.vue
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: /basic/ParentBasic.vue
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this component, we declare a `_counter` reactive variable (line `//1`) and
    an `incrementCounter()` function to manipulate its value (line `//2`). We trigger
    this function in the parent button, on the click event, as seen in line `//3`.
    Now, to see this pattern implemented, we just pass our reactive `_counter` variable
    as a prop to each child component, and we link our `incrementCounter()` function
    to each child’s increment event (line `//4`). Simple enough—let’s see how each
    child implements its part:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组件中，我们声明了一个 `_counter` 响应式变量（第 `//1` 行）和一个 `incrementCounter()` 函数来操作其值（第
    `//2` 行）。我们像在第 `//3` 行看到的那样，在父按钮的点击事件中触发这个函数。现在，为了看到这个模式的实现，我们只需将我们的响应式 `_counter`
    变量作为属性传递给每个子组件，并将我们的 `incrementCounter()` 函数链接到每个子组件的增量事件（第 `//4` 行）。足够简单——让我们看看每个子组件是如何实现其部分的：
- en: /basic/Child.vue
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: /basic/Child.vue
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our child implementation is simple as well. We start by defining the props to
    receive the counter variable in line `//1`, and also our `increment` custom event
    so that we can notify the parent. In order to do that, we create a function in
    line `//2`. In our template, we display our prop in line `//3` and trigger our
    increment function in line `//4`. Notice that our child component does not modify
    the counter. That is the responsibility of the father component, so we respect
    the pattern.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们子组件的实现同样简单。我们首先在第 `//1` 行定义了接收计数器变量的属性，还定义了我们的 `increment` 自定义事件，以便我们可以通知父组件。为了做到这一点，我们在第
    `//2` 行创建了一个函数。在我们的模板中，我们在第 `//3` 行显示我们的属性，并在第 `//4` 行触发我们的增量函数。请注意，我们的子组件并没有修改计数器。这是父组件的责任，所以我们尊重这个模式。
- en: This pattern is one that we will use quite often, but it does have some limitations.
    For example, what happens when the data needs to reach a parent, sibling, or grandchild?
    Do we pass data up and down the tree, even though components don’t use it? We
    could, but again, that is messy, verbose, and not the best way. We have better
    tools for that.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我们将非常频繁使用的模式，但它确实有一些限制。例如，当数据需要达到父组件、兄弟组件或孙组件时会发生什么？我们是否需要向上和向下传递数据，即使组件没有使用它？我们可以这样做，但同样，这很混乱，冗长，并不是最好的方法。我们有更好的工具来做这件事。
- en: 'In [*Chapter 4*](B18602_04.xhtml#_idTextAnchor102), *User Interface Composition
    with Components*, we saw that a parent can pass data and functionality to any
    of their children down the tree, by using `provide` and `inject`. Since the example
    presented there was quite comprehensive, we will not repeat it here. I encourage
    you to review how the provision was created and injected. Instead of repeating
    ourselves, let’s move ahead with the next item in our agenda to share information
    anywhere in the component tree: implement a **message bus** (also called an **event
    bus**).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 4 章*](B18602_04.xhtml#_idTextAnchor102) “使用组件的用户界面组合”中，我们看到了父组件可以通过使用
    `provide` 和 `inject` 将数据和功能传递给树中的任何子组件。由于那里提供的例子相当全面，我们在这里不再重复。我鼓励您回顾如何创建和注入提供。我们不再重复，让我们继续我们的议程中的下一个项目，以便在组件树中的任何地方共享信息：实现一个
    **消息总线**（也称为 **事件总线**）。
- en: Implementing an event bus with the Singleton and Observer patterns
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单例和观察者模式实现事件总线
- en: 'A message bus is an implementation of the *Observer pattern* that we saw in
    [*Chapter 2*](B18602_02.xhtml#_idTextAnchor040), *Software Design Principles and
    Patterns*. As a short refreshment of the main concept, we seek to create an object
    or structure that receives and emits events that our components can subscribe
    and react to. This pattern runs independently of the component tree structure,
    so any *component and service* can make use of it. Visually, we can represent
    the resulting relationship as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 消息总线是我们在 [*第 2 章*](B18602_02.xhtml#_idTextAnchor040) “软件设计原则与模式”中看到的 *观察者模式*
    的一个实现。为了简要回顾主要概念，我们试图创建一个对象或结构，它可以接收和发出事件，我们的组件可以订阅并对其做出反应。这个模式独立于组件树结构运行，因此任何
    *组件和服务* 都可以加以利用。从视觉上，我们可以将这种关系表示如下：
- en: '![Figure 7.2 – A simplified view of a message bus relationship with components](img/Figure_7.02_B18602.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 组件与消息总线关系的简化视图](img/Figure_7.02_B18602.jpg)'
- en: Figure 7.2 – A simplified view of a message bus relationship with components
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 组件与消息总线关系的简化视图
- en: From the preceding diagram, we can immediately see that each component is treated
    equally by the message bus. Each component subscribes one or more of its methods
    to a specific event, and at the same time has the same possibility to publish
    an event. This makes it very flexible, as events can also transport data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中，我们可以立即看出消息总线对每个组件都是平等对待的。每个组件将其一个或多个方法订阅到特定的事件，同时也有相同的发布事件的权限。这使得它非常灵活，因为事件也可以传输数据。
- en: Let’s bring down to code these concepts with an implementation example. We start
    by creating a service, using the Singleton pattern, that provides us with a message
    bus. In our case, we will just wrap the `mitt` package, which gives us this functionality
    (see https://github.com/developit/mitt#usage).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个实现示例将这些概念转化为代码。我们首先创建一个服务，使用单例模式，为我们提供一个消息总线。在我们的例子中，我们只是包装了`mitt`包，它提供了这个功能（参见
    https://github.com/developit/mitt#usage）。
- en: 'The `mitt` package can be installed in our application with the following command
    in the terminal:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下终端命令在我们的应用程序中安装`mitt`包：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our service then looks like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务看起来如下：
- en: /services/MessageBus.js
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: /services/MessageBus.js
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will give us a singleton for an event emitter and dispatcher, meaning
    our message bus. In our example, we will dispatch text messages through it, and
    each receiving component will display it. Our components will then look something
    like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们一个事件发射器和调度器的单例，即我们的消息总线。在我们的例子中，我们将通过它发送文本消息，每个接收组件将显示它。我们的组件将看起来像这样：
- en: /bus/Child.vue
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: /bus/Child.vue
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, we start in line `//1` by importing our `messageBus` object
    (check the right path in your implementation) and declare a `message` reactive
    variable initialized to an empty string. Notice how we also import and use the
    `onMounted()` and `onBeforeUnmount()` methods from the component’s life cycle
    to subscribe and unsubscribe to the `message` event starting in line `//3`. The
    function that we register is in line `//4`, and it receives from the event a value
    that we pass to our internal variable to display in the template. We also need
    a function to publish the event to notify others, and that can be found in line
    `//5`. In this case, we publish the title of the component. This function is triggered
    by a button, as shown in line `//6`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从第`//1`行开始导入我们的`messageBus`对象（检查你的实现中的正确路径），并声明一个初始化为空字符串的`message`响应式变量。注意我们如何也导入并使用组件的生命周期中的`onMounted()`和`onBeforeUnmount()`方法，从第`//3`行开始订阅和取消订阅`message`事件。我们注册的函数在第`//4`行，它从事件接收一个值，我们将其传递给我们的内部变量以在模板中显示。我们还需要一个函数来发布事件以通知他人，这个函数可以在第`//5`行找到。在这种情况下，我们发布组件的标题。这个函数由按钮触发，如第`//6`行所示。
- en: 'If you run the application example with some additional minimal styling, this
    code will result in something like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用一些额外的最小化样式运行应用程序示例，这段代码将产生类似以下的结果：
- en: '![Figure 7.3 – A simple implementation of data sharing through the Observer
    pattern](img/Figure_7.03_B18602.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 通过观察者模式实现的数据共享](img/Figure_7.03_B18602.jpg)'
- en: Figure 7.3 – A simple implementation of data sharing through the Observer pattern
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 通过观察者模式实现的数据共享
- en: 'This approach to handling the workflow of data is quite effective in what it
    does, but also has limitations. Events are a good way to notify multiple components
    simultaneously to trigger actions, independently of their place in the organization
    tree. When an application has multiple sub-systems that need to react to an application
    state change, this is a good pattern to apply. However, when dealing mainly with
    application data, this pattern has an important drawback: each component keeps
    an internal copy of the information. This makes the handling of memory quite inefficient,
    as the propagation of data means copying into different parts of our application.
    There are cases when this is necessary or desired, but certainly not for every
    case. If we have 50, 100, or 1,000 components subscribed to the same event, will
    all of them have the same copy of the data? If each component needs to handle
    and possibly modify the data independently of the others, this works fine... but
    if we want to make better use of Vue’s reactivity and improve our memory handling,
    we need to use a different approach. This is what we will see next with a basic
    reactive application state.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种处理数据工作流程的方法在它所做的事情上相当有效，但也有局限性。事件是通知多个组件同时触发动作的好方法，而不管它们在组织树中的位置。当一个应用程序有多个子系统需要响应应用程序状态变化时，这是一个很好的模式。然而，当主要处理应用程序数据时，这种模式有一个重要的缺点：每个组件都保留信息的内部副本。这使得内存处理效率相当低，因为数据的传播意味着在我们的应用程序的不同部分进行复制。有些情况下这是必要的或期望的，但绝对不是每个情况都如此。如果我们有
    50、100 或 1,000 个组件订阅了同一个事件，它们都会拥有相同的数据副本吗？如果每个组件需要独立于其他组件处理和可能修改数据，这可以正常工作...但如果我们想更好地利用
    Vue 的响应式并提高我们的内存处理，我们需要使用不同的方法。这就是我们接下来将要看到的基本响应式应用程序状态。
- en: Implementing a basic reactive state
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现基本响应式状态
- en: As mentioned before, a drawback of using a message bus to share data is the
    multiplicity of copies of the same data, including the overhead for the handling
    of the events. Instead, we can leverage Vue’s reactivity engine and, in particular,
    the `reactive()` helper constructor to create a single entity to hold our application
    state. Just like before, we can wrap this reactive object in a Singleton pattern
    to share it among components and plain JavaScript functions, objects, and classes.
    It's worth mentioning that this is one of the great advantages of Vue 3 and the
    new Composition API.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用消息总线共享数据的一个缺点是相同数据的多个副本，包括处理事件的额外开销。相反，我们可以利用 Vue 的响应式引擎，特别是 `reactive()`
    辅助构造函数来创建一个单一实体来保存我们的应用程序状态。就像之前一样，我们可以用单例模式包装这个响应式对象，以便在组件和纯 JavaScript 函数、对象和类之间共享。值得一提的是，这是
    Vue 3 和新组合 API 的一个重大优势。
- en: 'From the example code, we will end with a basic example like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从示例代码中，我们将得到一个基本的例子，如下所示：
- en: '![Figure 7.4 – A shared reactive object for state management](img/Figure_7.04_B18602.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 用于状态管理的共享响应式对象](img/Figure_7.04_B18602.jpg)'
- en: Figure 7.4 – A shared reactive object for state management
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 用于状态管理的共享响应式对象
- en: 'As you can see in the previous screenshot, the state in this case is shared
    (or accessed) by all the components of this example. Any of the child components
    can modify any of its values, and the change is reflected immediately across the
    application. In contrast with the previous examples, the implementation of this
    pattern is both simple and straightforward. Let’s dive into it by first creating
    a service with our reactive state:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的屏幕截图中所看到的，在这个例子中，状态是由这个示例的所有组件共享（或访问）的。任何子组件都可以修改其任何值，并且变化会立即在整个应用程序中反映出来。与之前的例子相比，这种模式的实现既简单又直接。让我们首先通过创建一个包含我们的响应式状态的服务来深入了解它：
- en: /service/SimpleState.js
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: /service/SimpleState.js
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If this code seems simple, it is because indeed it is. We create a JavaScript
    file and import the `reactive` constructor from Vue (line `//1`). Then, we declare
    a reactive constant with an initial object (line `//2`). This will be the application
    state that we return through a `useState()` function, named following the model
    of composable components (line `//3`). This function is our module exports.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这段代码看起来很简单，那是因为它确实很简单。我们创建一个 JavaScript 文件，并从 Vue 中导入 `reactive` 构造函数（行 `//1`）。然后，我们声明一个带有初始对象的响应式常量（行
    `//2`）。这将是我们通过 `useState()` 函数返回的应用程序状态，该函数遵循组合组件的模式（行 `//3`）。这个函数是我们的模块导出。
- en: 'Making use of this centralized state is also very simple, as we can see here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这种集中式状态也非常简单，正如我们在这里可以看到的：
- en: /simple/ChildSimple.vue
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: /simple/ChildSimple.vue
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We start our component by importing the `useState` factory function, and we
    declare a reactive constant using it (line `//1`). We use this reactive variable
    in our template just like any other (line `//2`), and in the same way, we can
    access directly the member fields of the object to modify them as with any other
    object, as you can see in line `//3`. Having done this, as one would expect, once
    a component modifies any value, the change gets propagated across the application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过导入 `useState` 工厂函数开始我们的组件，并使用它声明一个响应式常量（行 `//1`）。我们就像使用任何其他变量一样在我们的模板中使用这个响应式变量（行
    `//2`），同样地，我们可以直接访问对象的成员字段来修改它们，就像修改任何其他对象一样，正如你在行 `//3` 中所看到的。完成这些后，正如预期的那样，一旦组件修改了任何值，这个变化就会在整个应用程序中传播。
- en: 'This simple approach is very useful and fit for small to even medium-sized
    applications. It has many benefits, such as the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的方法非常有用，适用于从小型到中型甚至更大的应用程序。它有许多好处，例如以下这些：
- en: It is easy to implement and understand.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和理解都很简单。
- en: It leverages Vue’s reactivity system.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它利用了 Vue 的响应性系统。
- en: It is flexible, as we can add new reactive members after initialization.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是灵活的，因为我们可以在初始化后添加新的响应式成员。
- en: It establishes a single source of truth meaning that our state is the centralized
    repository of the application data. There's no need to keep internal or private
    variables synchronized.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它建立了一个单一的真实来源，意味着我们的状态是应用程序数据的集中存储库。没有必要保持内部或私有变量同步。
- en: 'If you consider the options we have seen until now, this is a giant leap forward.
    However, there are some situations when these falls short:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果考虑我们至今为止所看到的选项，这无疑是一个巨大的进步。然而，在某些情况下，这些选项可能还不够：
- en: What happens when a function modifies its value in an asynchronous manner if
    other components made changes before it was resolved?
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在函数修改其值之前其他组件已经进行了修改，会发生什么？
- en: This approach does not allow us to handle computed data that needs to be implemented
    in each component
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法不允许我们处理需要在每个组件中实现的计算数据
- en: Debugging could be hard as there is no specific support for developer tools
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试可能很困难，因为没有针对开发者工具的具体支持
- en: 'As mentioned, this approach is suitable for simple needs. For a more robust
    approach, we will dig into the official central state management solution by the
    Vue project: **Pinia**.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，这种方法适合简单的需求。对于更稳健的方法，我们将深入研究 Vue 项目提供的官方中央状态管理解决方案：**Pinia**。
- en: Implementing a powerful reactive store with Pinia
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Pinia 实现一个强大的响应式存储
- en: 'Central state management is not a concept private only to Vue, and the same
    pattern can be found in other libraries and frameworks. Just as in our basic reactive
    example, **Pinia** is a central state management tool that provides us with a
    single source of truth, meaning that a change in one of its values will propagate
    reactively to the entire application wherever is used. This state is shared among
    components in the application and gives us access to the full range of reactive
    tools Vue provides through a well-defined interface. It is easier to understand
    Pinia if first we build an example to show the results of using it. Running the
    code example will give us something like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 中央状态管理不仅仅是一个属于 Vue 的概念，同样的模式也可以在其他库和框架中找到。就像我们基本的响应式示例一样，**Pinia** 是一个中央状态管理工具，它为我们提供了一个单一的真实来源，这意味着其值的变化会以响应式的方式传播到整个应用程序的任何使用位置。这种状态在应用程序的组件之间是共享的，并使我们能够通过一个定义良好的接口访问
    Vue 提供的完整范围的响应式工具。如果我们首先构建一个示例来展示使用它的结果，那么理解 Pinia 会更容易。运行代码示例将给我们类似以下的结果：
- en: '![Figure 7.5 – Central state management with Pinia](img/Figure_7.05_B18602.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 使用 Pinia 的中央状态管理](img/Figure_7.05_B18602.jpg)'
- en: Figure 7.5 – Central state management with Pinia
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 使用 Pinia 的中央状态管理
- en: 'In this example, we build a store that not only exposes a reactive state but
    also implements computed values. As an officially supported project, Pinia also
    exposes implementations of the Options and Composition APIs. To use Pinia, we
    need to first include it in our project with the following command in the project’s
    root directory:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们构建了一个商店，它不仅暴露了响应式状态，还实现了计算值。作为一个官方支持的项目，Pinia 还公开了 Options 和 Composition
    APIs 的实现。要使用 Pinia，我们首先需要在项目的根目录中用以下命令将其包含到我们的项目中：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After the installation, we should create a store and then attach it to our
    application so that it can be used by all the components. A store is like our
    reactive singleton from the previous section, meaning an object that will have
    reactive fields to be shared in our application, but also the related business
    logic. So, each store will have the following items: `data`, computed properties
    known as `getters`, and methods known as `actions`. We define each store in its
    own file as a module, defining each item. Using the Options API, a store would
    look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们应该创建一个存储并将其附加到我们的应用程序中，以便所有组件都可以使用。存储就像我们上一节中的响应式单例，意味着一个将具有要在我们的应用程序中共享的响应式字段的对象，以及相关的业务逻辑。因此，每个存储将包含以下项目：`data`、称为`getters`的计算属性和称为`actions`的方法。我们将其定义在自己的文件中作为一个模块，定义每个项目。使用选项API，存储将看起来像这样：
- en: Options API basic store
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 选项API基本存储
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this store, we start by importing the `defineStore` constructor from the
    `Pinia` package (line `//1`) and use it to create a store in line `//2`. This
    constructor receives two arguments:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个存储中，我们首先从`Pinia`包中导入`defineStore`构造函数（第`//1`行），并使用它来创建存储（第`//2`行）。此构造函数接收两个参数：
- en: The name of the store, as a string. This has to be unique among the stores,
    as it is used internally as an ID.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储的名称，作为一个字符串。这必须在存储中是唯一的，因为它在内部用作ID。
- en: 'An object with the store definition with the following members:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有以下成员的存储定义的对象：
- en: '`state` (line `//3`): This is a function that returns an object. Notice that
    we do not declare it to be reactive. Pinia will take care of that.'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`（第`//3`行）：这是一个返回对象的函数。请注意，我们没有声明它为响应式。Pinia将负责这一点。'
- en: '`getters` (line `//4`): This is an object whose members will become computed
    properties. Each member receives as the first argument the state of the store,
    as a reactive object.'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getters`（第`//4`行）：这是一个对象，其成员将成为计算属性。每个成员将状态作为第一个参数接收，作为一个响应式对象。'
- en: '`actions` (line `//5`): This is, again, an object whose members are functions
    that can access and modify the state but must do so by accessing it through the
    `this` keyword.'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actions`（第`//5`行）：这同样是一个对象，其成员是函数，可以访问和修改状态，但必须通过使用`this`关键字来访问它。'
- en: 'Using the Options API to define the store is a good way to understand the parts
    that make it up. However, the change of syntax between `getters` and `actions`
    could be confusing and lead to involuntary mistakes, as one accesses the state
    through an argument and the other by using the `this` reference. However, if we
    take a moment to look at the constructor, we can see that `getters` and `actions`
    are analogous to *computed properties and component methods* (functions). With
    that in mind, let’s see how to rewrite this store using the Composition API, and
    this is the one we will use in our example code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用选项API定义存储是理解其组成部分的好方法。然而，`getters`和`actions`之间的语法变化可能会令人困惑，并导致无意中的错误，因为一个通过参数访问状态，而另一个通过使用`this`引用来访问。然而，如果我们花点时间看看构造函数，我们可以看到`getters`和`actions`类似于*计算属性和组件方法*（函数）。有了这个想法，让我们看看如何使用组合API重写这个存储，这是我们将在示例代码中使用的：
- en: /stores/counter.js
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: /stores/counter.js
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using the Composition API makes the store look more like the rest of our application,
    as we apply the same approach. We start by importing from Vue the constructors
    we need in line `//1`, as with components using the same API. This time, when
    we use the `defineStore` constructor, instead of passing an object we pass a function
    (or arrow function) that will return the reactive properties and methods that
    make up the store. You can see this in line `//2`, and then the `return` object
    in line `//6`. As you can expect, inside that function we declare our reactive
    properties (line `//3`) and computed properties (line `//4`), and methods (line
    `//5`). Reactive properties will become, well, reactive properties. Computed properties
    will become our getters, and the functions will become the actions. This far,
    this syntax does not have the syntactic sugar we are used to using the `<script
    setup>` tag, but the body of the function is the same approach (state of mind)
    that we use with components.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组合 API 使得存储看起来更像我们的应用程序的其他部分，因为我们采用了相同的方法。我们首先从 Vue 中导入所需的构造函数，就像使用相同 API
    的组件一样，在第 `//1` 行。这次，当我们使用 `defineStore` 构造函数时，我们传递一个函数（或箭头函数），该函数将返回构成存储的响应式属性和方法。您可以在第
    `//2` 行中看到这一点，然后在第 `//6` 行的 `return` 对象。正如您所预期的，在该函数内部，我们声明我们的响应式属性（第 `//3` 行）和计算属性（第
    `//4` 行），以及方法（第 `//5` 行）。响应式属性将成为响应式属性。计算属性将成为我们的获取器，函数将成为动作。到目前为止，这种语法没有我们习惯使用的
    `<script setup>` 标签的语法糖，但函数体是相同的（心态）方法，我们与组件一起使用。
- en: 'Now that we have a store (and we could have many), before we can actually use
    it, we need to implement Pinia in our application. For that, in our `main.js`
    file, include the following highlighted lines:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了存储（并且我们可以有多个），在我们实际上可以使用它之前，我们需要在我们的应用程序中实现 Pinia。为此，在我们的 `main.js` 文件中，包括以下突出显示的行：
- en: ./main.js
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ./main.js
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This step is necessary to enable the Pinia engine for the entire application.
    What is left now is to import the store we want to use in our components that
    need it. For example, if you look into the example repository, you will find this
    file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤是启用整个应用程序的 Pinia 引擎所必需的。现在剩下的就是导入我们组件中需要的存储。例如，如果您查看示例存储库，您将找到此文件：
- en: /pinia/ChildPinia.vue
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: /pinia/ChildPinia.vue
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We import the store constructor in line `//1`, and we create our reactive object
    in line `//2`. To use their values or execute their methods, we use them directly
    as if they were regular objects using the dot (`.`) notation. Notice in line `//3`
    how we access the value of `in_range`, and later, in line `//4`, we execute the
    `increment()` function. As we would expect, any modification of the store values
    will be synchronized automatically across our application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 `//1` 行导入存储构造函数，并在第 `//2` 行创建我们的响应式对象。要使用它们的值或执行它们的方法，我们直接使用点（`.`）符号，就像它们是普通对象一样。注意在第
    `//3` 行我们如何访问 `in_range` 的值，稍后，在第 `//4` 行，我们执行 `increment()` 函数。正如我们所期望的，任何对存储值的修改都将自动同步到我们的应用程序中。
- en: Unlike previous methods, Pinia stores and states are traceable and show up on
    the developer tools. For applications of medium size and above, using Pinia is
    almost a requirement when a central state is necessary.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的方法不同，Pinia 存储和状态是可追踪的，并显示在开发者工具中。对于中等大小以上的应用程序，当需要集中状态时，使用 Pinia 几乎是必需的。
- en: 'Pinia is Vue 3’s official solution for central state management, replacing
    Vuex from the Vue 2 branch. In practice, they accomplish the same functionality,
    but the former has some advantages that made the Vue team select it and sponsor
    it. A deep review is not a topic for our purposes, but here is a short list of
    changes or advantages of Pinia:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Pinia 是 Vue 3 的官方解决方案，用于集中状态管理，取代了 Vue 2 分支的 Vuex。在实践中，它们实现了相同的功能，但前者有一些优势，这使得
    Vue 团队选择了它并赞助它。深入审查不是我们目的的主题，但以下是一个简短的变更或 Pinia 的优势列表：
- en: Different approach to stores. In Pinia, each store is its own module, and they
    are all dynamic. Vuex instead had one single store, with partitions in modules.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对存储的不同方法。在 Pinia 中，每个存储都是其自己的模块，并且它们都是动态的。Vuex 则有一个单一的存储，模块以分区形式存在。
- en: The syntax and API for Pinia are simpler and less verbose than Vuex.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pinia 的语法和 API 比 Vuex 简单且不那么冗长。
- en: Better support for TypeScript and discoverability for the IDE’s autocomplete
    features.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的 TypeScript 支持，以及 IDE 自动完成功能的可发现性。
- en: Support for both Options and Composition APIs.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持选项和组合 API。
- en: Better internal use of Vue’s new reactive models.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好地利用 Vue 的新响应式模型。
- en: Developer tools support.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者工具支持。
- en: A plugin architecture to extend Pinia.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于扩展 Pinia 的插件架构。
- en: 'The change from Vuex to Pinia makes it difficult to make a one-step replacement
    upgrade for projects that were using it. However, the Pinia team has published
    a nice migration guide on the official website that you can find here: [https://pinia.vuejs.org/cookbook/migration-vuex.html](
    https://pinia.vuejs.org/cookbook/migration-vuex.html). For a complete reference
    of all the options available with Pinia, I recommend reading the official documentation
    at [https://pinia.vuejs.org](https://pinia.vuejs.org).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Vuex 到 Pinia 的转变使得对使用它的项目进行一步替换升级变得困难。然而，Pinia 团队在官方网站上发布了一个很好的迁移指南，您可以通过以下链接找到：[https://pinia.vuejs.org/cookbook/migration-vuex.html](https://pinia.vuejs.org/cookbook/migration-vuex.html)。对于
    Pinia 中所有可用选项的完整参考，我建议阅读官方文档在 [https://pinia.vuejs.org](https://pinia.vuejs.org)。
- en: With Pinia, we have seen now the most common and relevant patterns to control
    the flow of data between components (and services!), but these are not the only
    ones available to us. We will see next the stores provided by default in modern
    web browsers, and how to use them.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Pinia，我们已经看到了控制组件（和服务！）之间数据流的最常见和相关的模式，但这些并非我们唯一可用的选项。我们将看到现代网络浏览器提供的默认存储库，以及如何使用它们。
- en: Browser data stores – session, local, and IndexedDB
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器数据存储 – 会话、本地和 IndexedDB
- en: 'Browsers provide other features to store data locally, which can be read not
    only by any other component but also by any script running on the same page. We
    will not talk about cookies, but the new methods provided as key-value stores:
    `SessionStore` and `LocalStore`. But these are not the only options, as browsers
    also provide a database called `IndexedDB` that offers much more storage space
    and can be accessed also outside the scope of our application’s window in a different
    thread. We will see how in [*Chapter 8*](B18602_08.xhtml#_idTextAnchor186), *Multithreading
    with Web Workers*, in more detail, while here, we will focus first on understanding
    the basic concept and limitations of each one.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器提供其他功能来本地存储数据，这些数据不仅可以被任何其他组件读取，也可以被同一页面上运行的任何脚本读取。我们不会讨论 cookies，但新提供作为键值存储的方法：`SessionStore`
    和 `LocalStore`。但这些并非唯一选项，因为浏览器还提供了一个名为 `IndexedDB` 的数据库，它提供了更多的存储空间，并且可以在我们应用程序窗口的不同线程中访问到。我们将在
    [*第8章*](B18602_08.xhtml#_idTextAnchor186) 中更详细地了解，即 *使用 Web Workers 的多线程*，而在这里，我们首先将专注于理解每个的基本概念和限制。
- en: '`SessionStorage` is a read-only object created for each page origin. It stores
    only string data that can be accessed and retrieved using a simple interface.
    This data exists only through the duration of the *browser tab* and persists during
    refreshes. A clear example of this use is to persist form data. The object is
    attached to the `window` object (`window.sessionStorage`) and can be accessed
    by any script on the page.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`SessionStorage` 是为每个页面来源创建的一个只读对象。它只存储可以通过简单接口访问和检索的字符串数据。这些数据仅在 *浏览器标签页*
    的持续时间存在，并且在刷新期间持续存在。这种用途的一个明显例子是持久化表单数据。该对象附加到 `window` 对象（`window.sessionStorage`）上，并且可以被页面上的任何脚本访问。'
- en: '`LocalStorage` is similar to `SessionStorage` in capabilities and data storage.
    It has the same interface and is restricted also to the same origin of the page.
    The main difference is that it persists beyond the life of the page and is shared
    among all the open pages of the same origin. Websites and applications can use
    it to store data and retrieve it throughout multiple sessions on the same browser.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalStorage` 在功能和数据存储方面与 `SessionStorage` 类似。它具有相同的接口，并且也限制在页面的相同来源。主要区别在于它超越了页面的生命周期，并且在同一来源的所有打开页面上共享。网站和应用可以使用它来存储数据并在同一浏览器的多个会话中检索数据。'
- en: '`SessionStorage` and `LocalStorage` share the same interface:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`SessionStorage` 和 `LocalStorage` 具有相同的接口：'
- en: '`.setItem(item_name, item_data)`: Here, `item_name` is a string that uniquely
    identifies `item_data`, which is also a string'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.setItem(item_name, item_data)`: 在这里，`item_name` 是一个字符串，它唯一标识 `item_data`，它也是一个字符串'
- en: '`.getItem(item_name)`: Retrieves the string data stored under `item-_name`,
    or null if not found'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.getItem(item_name)`: 获取存储在 `item-_name` 下的字符串数据，如果未找到则返回 null'
- en: '`.removeItem(item_name)`: Deletes the data by `item_name` from the store'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.removeItem(item_name)`: 通过 `item_name` 从存储中删除数据'
- en: '`.clear()`: Removes all data from the store'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.clear()`: 从存储中删除所有数据'
- en: 'The preceding methods represent the totality of API endpoints for both storages.
    Simple enough—we can serialize data to record it in these stores. For example,
    to store a JSON object, we would use the following (we can omit the `window` object
    reference, as it is considered a global object):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法代表了这两个存储的API端点的全部。很简单——我们可以将数据序列化以记录在这些存储中。例如，要存储一个JSON对象，我们会使用以下方法（我们可以省略`window`对象引用，因为它被认为是一个全局对象）：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And then, to retrieve it, we would use the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了检索它，我们会使用以下方法：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Both stores have some limitations and a few caveats:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 两个存储库都有一些限制和一些注意事项：
- en: There is no standard limit set among browsers for how many characters each store
    can hold. Strings are stored in UTF-16, so each character can take from 2 bytes
    or more (see [https://en.wikipedia.org/wiki/UTF-16](https://en.wikipedia.org/wiki/UTF-16)),
    which makes calculation hard. The specifications recommend at least 5 MB for each
    storage.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器之间没有为每个存储库可以存储多少字符设置标准限制。字符串以UTF-16格式存储，因此每个字符可能占用2个字节或更多（见[https://en.wikipedia.org/wiki/UTF-16](https://en.wikipedia.org/wiki/UTF-16)），这使得计算变得困难。规范建议每个存储至少5
    MB。
- en: When these storages run out of space, some browsers crash the page, while others
    prompt the user for consent to expand the storage.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当这些存储空间耗尽时，一些浏览器会崩溃页面，而另一些则会提示用户同意扩展存储空间。
- en: Access to store and retrieve data is sequential, possibly blocking the render
    process and making the page/application look irresponsive... But this only happens
    in long operations.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储和检索数据的访问是顺序的，可能会阻塞渲染过程，使页面/应用程序看起来无响应...但这只发生在长时间操作中。
- en: For `sessionStorage`, duplicating tabs will also duplicate the storage. Instead,
    for `localStorage`, both tabs will access the same information.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`sessionStorage`，复制标签页也会复制存储。相反，对于`localStorage`，两个标签页将访问相同的信息。
- en: Neither localStorage nor sessionStorage is reactive or provides listeners to
    watch when a value changes.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论是localStorage还是sessionStorage，都不是响应式的，也不提供监听值变化的监听器。
- en: The preceding limitations are in no way a threat or a suggestion not to use
    them. Instead, they are the boundaries and limits to using them, since all data
    is stored locally on the user’s browser, and nothing is sent back to the server
    (as cookies do).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的限制绝不是威胁或建议不要使用它们的理由。相反，它们是使用它们的边界和限制，因为所有数据都存储在用户的浏览器本地，并且没有任何东西被发送回服务器（如cookies所做的那样）。
- en: In contrast to these web storage objects, `IndexedDB` is a different system
    altogether. It is a full implementation of a transactional database that stores
    JavaScript objects under a unique key. We can open multiple databases, create
    connections to them, and define schemas, and all operations are asynchronous,
    so there is no application blocking. The size limit has also been extended, with
    a soft limit of 50 MB. If a database grows more than that, the user is prompted
    to consent to expand it, and more space is given. In theory, depending on the
    implementation in each browser, it could occupy as much space as available. In
    practice, each browser has its own way to negotiate available space with the local
    operating system, so no hard number can be given about its limits that would hold
    true in every case.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与这些Web存储对象相比，`IndexedDB`是一个完全不同的系统。它是一个事务型数据库的完整实现，在唯一键下存储JavaScript对象。我们可以打开多个数据库，与它们建立连接，并定义模式，所有操作都是异步的，因此没有应用程序阻塞。大小限制也已扩展，软限制为50
    MB。如果数据库增长超过这个限制，用户将被提示同意扩展它，并给予更多空间。理论上，根据每个浏览器的实现，它可以占用与可用空间一样多的空间。实际上，每个浏览器都有自己与本地操作系统协商可用空间的方式，因此无法给出适用于所有情况的硬性数字。
- en: Curiosity
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 好奇心
- en: The Chrome engine provides a flag to build the engine without limits to `IndexedDB`,
    save for the available disk space. This flag can also be activated in hybrid frameworks
    such as NW.js or when building the browser from source.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome引擎提供了一个标志，可以在没有限制的情况下构建`IndexedDB`引擎，除了可用的磁盘空间。这个标志也可以在混合框架如NW.js或从源构建浏览器时激活。
- en: There is a major issue with `IndexedDB`, which is that its API is complicated
    and cumbersome, so it is very rare that an application would access it directly.
    Instead, since `IndexedDB` is so flexible and fast, there is a fair number of
    libraries that create their own database implementation on top of it or facilitate
    a simpler interface (using the Façade pattern, for example). A curated list of
    these libraries and frameworks can be found in the **Mozilla Developer Network**
    documentation (https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API#see_also).
    In our implementation examples for [*Chapter 8*](B18602_08.xhtml#_idTextAnchor186),
    *Multithreading with Web Workers*, we will use one of these libraries. For the
    purposes of this chapter, just keep in mind that each browser provides you with
    a powerful database for your application, and you can access it through a variety
    of patterns and approaches.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`IndexedDB`存在一个主要问题，那就是它的API复杂且繁琐，因此很少有应用程序会直接访问它。相反，由于`IndexedDB`非常灵活且快速，有许多库在其之上创建了自己的数据库实现，或者提供了一个更简单的接口（例如使用外观模式）。这些库和框架的精选列表可以在**Mozilla开发者网络**文档中找到（https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API#see_also）。在我们的[*第八章*](B18602_08.xhtml#_idTextAnchor186)“使用Web
    Workers的多线程”的实现示例中，我们将使用这些库之一。为了本章的目的，只需记住每个浏览器都为你提供了一个强大的数据库，你可以通过各种模式和途径访问它。'
- en: Experimenting with reactivity and Proxies patterns
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试使用反应性和代理模式
- en: It is time to put into practice what we have learned in this chapter under the
    light of patterns we saw in [*Chapter 2*](B18602_02.xhtml#_idTextAnchor040), *Software
    Design Principles and Patterns*, with a small experimental project. We want to
    create an option to make `sessionStorage` data behave like a reactive central
    state manager so that we can use it in our components. Possible uses for this
    approach could be to persist user-entered data during refreshes, alert components
    of data changes, and so on.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候在[*第二章*](B18602_02.xhtml#_idTextAnchor040)“软件设计原则与模式”中看到的模式的光照下，将本章学到的知识付诸实践了，通过一个小型的实验项目。我们希望创建一个选项，使`sessionStorage`数据表现得像一个反应式中央状态管理器，这样我们就可以在组件中使用它。这种方法的可能用途包括在刷新期间持久化用户输入的数据、通知组件数据变化等等。
- en: 'Since `SessionStorage` does not provide an API we can listen to, our approach
    will be to create a Proxy handler using the Decorator pattern, to match and keep
    synchronized the values in the store with an internal and private reactive property.
    We will wrap this in a *singleton* and use the *Central State* manager approach
    to share it in our application. Let’s start by creating our core service:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`SessionStorage`没有提供我们可以监听的API，我们的方法将是使用装饰器模式创建一个代理处理程序，以匹配并保持存储中的值与内部和私有反应属性同步。我们将将其封装在*单例*中，并使用*中央状态*管理器方法在应用程序中共享它。让我们首先创建我们的核心服务：
- en: /services/sessionStorage.js
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: /services/sessionStorage.js
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this `service` module, we will use the native JavaScript implementation
    of a `Proxy` object to capture specific calls to the API of the `window.sessionStorage`
    object. The use of Proxy objects is rather advanced in JavaScript, so I recommend
    that you look at the documentation on MDN here: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy).
    We start by importing the `reactive()` constructor from Vue and then creating
    a plain object named `handler` (line `//1`), that will act as our proxy/decorator.
    This object will be placed to intercept the calls to the original `sessionStorage`.
    Inside it, we declare a `prop` property as reactive (line `//2)`), initializing
    it with an empty object. This object will be synchronized with the storage. Then,
    we create two traps (or interceptors): one for get or read operations (line `//3`),
    and another for set or write operations (line `//4`).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`service`模块中，我们将使用`Proxy`对象的本地JavaScript实现来捕获对`window.sessionStorage`对象API的特定调用。在JavaScript中，Proxy对象的使用相当高级，所以我建议你查看MDN上的文档：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)。我们首先从Vue导入`reactive()`构造函数，然后创建一个名为`handler`的普通对象（行`//1`），它将充当我们的代理/装饰器。这个对象将被放置以拦截对原始`sessionStorage`的调用。在它内部，我们声明一个`prop`属性作为反应式（行`//2`），并用一个空对象初始化它。这个对象将与存储同步。然后，我们创建两个陷阱（或拦截器）：一个用于获取或读取操作（行`//3`），另一个用于设置或写入操作（行`//4`）。
- en: The `get()` function receives three arguments, of which we will use only two.
    The target refers to `sessionStorage`, and `prop` is the name of the method or
    attribute requested. Because `prop` can be either one, we test if it is a function
    with an `if` statement, and if so, we return a function that takes in all the
    arguments and returns the original function call with them. If it is not a function,
    then we retrieve the item from the store, test if it is part of our internal reactive
    property, and finally, return the value. This makes sure that our internal `props`
    object is in sync with values created before the decorator was implemented.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()` 函数接收三个参数，其中我们只使用两个。目标指的是 `sessionStorage`，而 `prop` 是请求的方法或属性的名称。因为
    `prop` 可以是任一者，所以我们用 `if` 语句测试它是否是函数，如果是，我们返回一个接收所有参数并返回带有它们的原始函数调用的函数。如果不是函数，则从存储库中检索项目，测试它是否是我们内部反应性属性的一部分，并最终返回值。这确保了我们的内部
    `props` 对象与装饰器实现之前创建的值保持同步。'
- en: 'The `set()` function is simpler, as we just take the value passed and store
    it in both places: our internal props and the store.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`set()` 函数比较简单，因为我们只需取传递的值并将其存储在两个地方：我们的内部属性和存储库中。'
- en: With our handler ready, in line `//5`, we create a `Decorator` proxy object
    using a native JavaScript constructor and provide a `useSessionStorage()` function
    in line `//6` so that we can export it as a singleton.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的处理程序准备好后，在行 `//5` 中，我们使用原生 JavaScript 构造函数创建一个 `Decorator` 代理对象，并在行 `//6`
    中提供一个 `useSessionStorage()` 函数，以便我们可以将其作为单例导出。
- en: 'With our Decorator created, now we can use it in our components, with the same
    approach as is standard in Vue 3:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的装饰器后，现在我们可以在组件中使用它，与 Vue 3 中的标准方法相同：
- en: /session_storage/ChildSession.vue
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: /session_storage/ChildSession.vue
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Notice that now we can use this object as a Pinia store or a simple reactive
    object, and the value of `sessionStorage` will always be synchronized and persist
    even if we refresh the page. To view the full example, please check the implementation
    of the code example in the GitHub repository. When you run it, you will see a
    section like this one:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在我们可以将此对象用作 Pinia 存储或简单的反应性对象，并且 `sessionStorage` 的值将始终同步并持久化，即使我们刷新页面。要查看完整示例，请检查
    GitHub 仓库中代码示例的实现。当你运行它时，你会看到一个类似这样的部分：
- en: '![Figure 7.6 – Example of our reactive $sessionStorage object](img/Figure_7.06_B18602.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 我们的反应式 $sessionStorage 对象示例](img/Figure_7.06_B18602.jpg)'
- en: Figure 7.6 – Example of our reactive $sessionStorage object
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 我们的反应式 $sessionStorage 对象示例
- en: 'In this example, we also implemented a parent component with an input element.
    When you modify the value, it is automatically synchronized and reflected in the
    children component, but also in `sessionStorage`. If you open the browser’s developer
    tools and navigate to the **Web Storage** section, you will see this reflected.
    Here is a screenshot of how this looks in Chrome, on an Ubuntu system:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们还实现了一个带有输入元素的父组件。当你修改值时，它会自动同步并反映在子组件中，同时也在 `sessionStorage` 中。如果你打开浏览器的开发者工具并导航到
    **Web Storage** 部分，你会看到这种反映。以下是 Chrome 在 Ubuntu 系统上的截图：
- en: '![Figure 7.7 – Session Storage showing the item from the example](img/Figure_7.07_B18602.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 示例中的会话存储项](img/Figure_7.07_B18602.jpg)'
- en: Figure 7.7 – Session Storage showing the item from the example
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 示例中的会话存储项
- en: In the same way we implemented this pattern for the session storage, we could
    also, with a few changes, apply it to local storage.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，我们为会话存储实现了这种模式，我们也可以通过一些修改将其应用于本地存储。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen in detail the different approaches and methods
    to control the flow of data between our components, services, and persistent storage
    provided by modern browsers. We also took time to integrate our knowledge by experimenting
    with session storage and the Decorator pattern to create a reactive/persistent
    central state. We took time to differentiate between approaches, and we have seen
    code for the implementation of each method. All these new skills are used daily
    in the development of Vue 3 applications.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了控制我们组件、服务和现代浏览器提供的持久存储之间数据流的不同方法和方法。我们还花时间通过实验会话存储和装饰器模式来整合我们的知识，创建一个反应式/持久中央状态。我们花了时间区分方法，并看到了每种方法的实现代码。所有这些新技能都用于
    Vue 3 应用程序的开发中。
- en: 'In the next chapter, we will investigate improving the performance of our application
    by using advanced JavaScript tools: web workers.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨通过使用高级 JavaScript 工具（如 web workers）来提高我们应用程序的性能。
- en: Review questions
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习问题
- en: 'Use these questions to review what you have learned in this chapter:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些问题来复习你在本章中学到的内容：
- en: Which methods do we have available to share data between sibling components?
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有哪些方法可以用来在兄弟组件之间共享数据？
- en: What is a message/event bus, and when is it most useful?
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息/事件总线是什么，它何时最有用？
- en: What is a central state management approach, and how can we implement it?
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中心状态管理方法是什么，我们如何实现它？
- en: What is the difference between session and local storage?
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话存储和本地存储之间有什么区别？
- en: How can we see what information is stored in session or local storage?
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何查看在会话或本地存储中存储了哪些信息？
