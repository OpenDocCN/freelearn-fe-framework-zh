<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer077">
<h1 class="chapterNumber">10</h1>
<h1 class="chapterTitle" id="_idParaDest-143">React 18 New Features</h1>
<p class="normal">React 18, the latest version of the popular JavaScript library for building user interfaces, introduces a host of new features and enhancements that aim to improve performance and enhance the developer experience. As a part of the ever-evolving React ecosystem, it is crucial to stay up to date with these advancements. In this chapter, we will provide a succinct overview of the most notable additions in React 18, followed by a brief explanation of the latest features in Node.js 19.</p>
<p class="normal">The new features in React 18 include:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Automatic Batching of State Updates</strong>: React 18 automatically batches multiple state updates into a single update, which results in improved performance and smoother animations. This automatic batching eliminates the need for manual batching.</li>
<li class="bulletList"><strong class="keyWord">Concurrent Rendering</strong>: This feature enables React to prioritize the rendering of certain components, leading to faster load times, smoother animations, and better user experiences.</li>
<li class="bulletList"><strong class="keyWord">Suspense for Data Fetching</strong>: Suspense enables developers to suspend the rendering of a component until the required data is loaded, providing a seamless user experience and improved error handling.</li>
<li class="bulletList"><strong class="keyWord">Improved Error Handling</strong>: React 18 simplifies error handling by offering more information about errors such as the component and code location where the error occurred, streamlining the debugging process.</li>
<li class="bulletList"><strong class="keyWord">New Component Types</strong>: React 18 introduces two new component types – portals and components with side effects. Portals enable rendering components outside of their parent components, while components with side effects allow performing side effects without a separate function.</li>
<li class="bulletList"><strong class="keyWord">No Support for Internet Explorer 11</strong>: To leverage modern web standards and enhance performance, React 18 no longer supports Internet Explorer 11. Developers must ensure their users employ a modern, supported browser like Google Chrome, Mozilla Firefox, Apple Safari, or Microsoft Edge.</li>
</ul>
<p class="normal">We’re going to cover the following main topics: </p>
<ul>
<li class="bulletList">Concurrent mode </li>
<li class="bulletList">Automatic batching</li>
<li class="bulletList">Suspense on the server</li>
<li class="bulletList">New APIs</li>
<li class="bulletList">New hooks</li>
<li class="bulletList">Strict mode</li>
<li class="bulletList">Node.js latest features</li>
</ul>
<h1 class="heading-1" id="_idParaDest-144">Concurrent mode</h1>
<p class="normal">React <strong class="keyWord">concurrent mode</strong> is a set of new features in React 18 that enable faster and more responsive user interfaces by<a id="_idIndexMarker353"/> allowing React to work on multiple tasks simultaneously. </p>
<p class="normal">In traditional React, the rendering process is synchronous, which means that React updates the user interface in a single pass. This can sometimes lead to performance issues, especially when rendering large, complex applications or handling real-time updates.</p>
<p class="normal">Concurrent mode allows React to split the rendering process into smaller units of work that can be executed independently and in parallel. This means that React can prioritize certain tasks, such as updating the user interface, while still allowing other tasks to run in the background, such as handling user input or fetching data.</p>
<p class="normal">Here are some of the key features of React concurrent mode:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Time slicing</strong>: Time slicing is a technique that allows React to break up large chunks of work into smaller pieces and prioritize the most important tasks first. This<a id="_idIndexMarker354"/> can help to reduce the perceived latency of an application and make it feel more responsive.</li>
<li class="bulletList"><strong class="keyWord">Suspense</strong>: Suspense is a new feature in React that allows developers to suspend the rendering of a<a id="_idIndexMarker355"/> component until the necessary data has been loaded. This can help to improve the perceived performance of an application and provide a better user experience.</li>
<li class="bulletList"><strong class="keyWord">Concurrent rendering</strong>: Concurrent rendering is a new rendering mode in React that allows React to<a id="_idIndexMarker356"/> update the user interface more frequently, resulting in smoother animations and transitions.</li>
</ul>
<p class="normal">Overall, React concurrent mode is a powerful new set of features that can help developers create faster and more responsive user interfaces. While it may require some adjustments to existing code, adopting concurrent mode can help to improve the user experience of your applications and keep them competitive in a fast-paced digital landscape. Here’s an example that demonstrates the use of time slicing and concurrent rendering in React 18:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> <span class="hljs-title">React</span>, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>() {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title">useState</span>(<span class="hljs-number">0</span>)
  
  <span class="hljs-keyword">function</span> <span class="hljs-title">handleClick</span>() {
    <span class="hljs-title">setCount</span>(count + <span class="hljs-number">1</span>)
  } 
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{handleClick}</span><span class="hljs-tag">&gt;</span>
      {count}
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
  )
}
<span class="hljs-keyword">function</span> <span class="hljs-title">App</span>() {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">React.Suspense</span><span class="hljs-tag"> </span><span class="hljs-attr">fallback</span><span class="hljs-tag">=</span><span class="hljs-string">{</span><span class="hljs-tag">&lt;</span><span class="hljs-attr">div</span><span class="hljs-tag">&gt;</span>Loading...<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>}&gt;
      <span class="hljs-tag">&lt;</span><span class="hljs-name">Counter</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">React.Suspense</span><span class="hljs-tag">&gt;</span>
  )
}
<span class="hljs-title">ReactDOM</span>.<span class="hljs-title">createRoot</span>(<span class="hljs-variable">document</span>.<span class="hljs-title">getElementById</span>(<span class="hljs-string">'root'</span>)).<span class="hljs-title">render</span>(<span class="hljs-tag">&lt;</span><span class="hljs-name">App</span><span class="hljs-tag"> /&gt;</span>)
</code></pre>
<h1 class="heading-1" id="_idParaDest-145">Automatic batching</h1>
<p class="normal">Automatic batching is a new feature in React 18 that improves the performance of updates by automatically batching multiple updates into a single render pass. In traditional React, updates to the <a id="_idIndexMarker357"/>user interface are typically processed synchronously, which means that each update triggers a new render pass. </p>
<p class="normal">This can be inefficient, especially when multiple updates occur in rapid succession. Automatic batching solves this problem by grouping multiple updates together and processing them in a single render pass.</p>
<p class="normal">Here’s an example to illustrate how automatic batching works:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>() {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title">useState</span>(<span class="hljs-number">0</span>)
  <span class="hljs-keyword">function</span> <span class="hljs-title">handleClick</span>() {
    <span class="hljs-title">setCount</span>(count + <span class="hljs-number">1</span>)
    <span class="hljs-title">setCount</span>(count + <span class="hljs-number">1</span>)
    <span class="hljs-title">setCount</span>(count + <span class="hljs-number">1</span>)
  }
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Count: {count}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{handleClick}</span><span class="hljs-tag">&gt;</span>Increment<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  )
}
</code></pre>
<p class="normal">In this example, we have a <code class="inlineCode">MyComponent</code> component that uses the <code class="inlineCode">useState</code> hook to manage a <code class="inlineCode">count</code> state variable. When the user clicks the <code class="inlineCode">Increment</code> button, we call the <code class="inlineCode">setCount</code> function three times in rapid succession, each time incrementing the count by 1.</p>
<p class="normal">In traditional React, each call to <code class="inlineCode">setCount</code> would trigger a new render pass, resulting in three separate updates to the user interface. However, with automatic batching in React 18, these updates are automatically grouped together and processed in a single render pass. This can result in significant performance improvements, especially when handling user input or real-time updates.</p>
<p class="normal">Overall, automatic batching is a powerful new feature in React 18 that can help to improve the performance and responsiveness of your applications. By automatically batching multiple updates together, React can optimize the rendering process and<a id="_idIndexMarker358"/> reduce unnecessary render passes, resulting in faster and more efficient updates to the user interface.</p>
<h1 class="heading-1" id="_idParaDest-146">Transitions</h1>
<p class="normal">React 18 introduces a new feature called <strong class="keyWord">transitions</strong> that allows developers to create smooth, declarative <a id="_idIndexMarker359"/>animations and transitions in their applications. </p>
<p class="normal">Transitions build on the existing capabilities of React’s declarative programming model to provide a simple and intuitive way to animate elements and components.</p>
<p class="normal">Here’s a simple example to illustrate how transitions work:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">Transition</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-transition-group'</span>
<span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>() {
  <span class="hljs-keyword">const</span> [show, setShow] = <span class="hljs-title">useState</span>(<span class="hljs-literal">false</span>)
  <span class="hljs-keyword">function</span> <span class="hljs-title">handleClick</span>() {
    <span class="hljs-title">setShow</span>(!show)
  }
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{handleClick}</span><span class="hljs-tag">&gt;</span>
        {show ? 'Hide' : 'Show'}
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">Transition</span><span class="hljs-tag"> </span><span class="hljs-attr">in</span><span class="hljs-tag">=</span><span class="hljs-string">{show}</span><span class="hljs-tag"> </span><span class="hljs-attr">timeout</span><span class="hljs-tag">=</span><span class="hljs-string">{300}</span><span class="hljs-tag">&gt;</span>
        {(state) =&gt; (
          <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span>
<span class="hljs-tag">            </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{{</span>
<span class="hljs-tag">              </span><span class="hljs-attr">transition:</span><span class="hljs-tag"> '</span><span class="hljs-attr">opacity</span><span class="hljs-tag"> </span><span class="hljs-attr">300ms</span><span class="hljs-tag"> </span><span class="hljs-attr">ease-out</span><span class="hljs-tag">',</span>
<span class="hljs-tag">              </span><span class="hljs-attr">opacity:</span><span class="hljs-tag"> </span><span class="hljs-attr">state</span><span class="hljs-tag"> === </span><span class="hljs-string">'entered'</span><span class="hljs-tag"> ? </span><span class="hljs-attr">1</span><span class="hljs-tag"> </span><span class="hljs-attr">:</span><span class="hljs-tag"> </span><span class="hljs-attr">0</span><span class="hljs-tag">,</span>
<span class="hljs-tag">            }}</span>
<span class="hljs-tag">          &gt;</span>
            {show &amp;&amp; <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Hello, world!<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>}
          <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
        )}
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">Transition</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  )
}
</code></pre>
<p class="normal">In this example, we use the <code class="inlineCode">Transition</code> component from the <code class="inlineCode">react-transition-group</code> library to animate the appearance and disappearance of a <code class="inlineCode">p</code> element. The <code class="inlineCode">Transitio</code>n component takes an <code class="inlineCode">in</code> prop that determines whether the element should be shown or hidden, and a <code class="inlineCode">timeout</code> prop that specifies the duration of the transition in milliseconds.</p>
<p class="normal">Inside the <code class="inlineCode">Transition</code> component, we define a function that takes a state argument and returns the contents of the transitioned element. The state argument is a string that <a id="_idIndexMarker360"/>represents the current state of the transition, which can be one of <code class="inlineCode">entering</code>, <code class="inlineCode">entered</code>, <code class="inlineCode">exiting</code>, or <code class="inlineCode">exited</code>.</p>
<p class="normal">In our example, we use the state argument to set the opacity of the <code class="inlineCode">div</code> element based on the current state of the transition. When the state is <code class="inlineCode">entered</code>, we set the opacity to <code class="inlineCode">1</code> to make the element fully visible. When the state is <code class="inlineCode">exiting</code> or <code class="inlineCode">exited</code>, we set the opacity to <code class="inlineCode">0</code> to make the element fade out smoothly.</p>
<p class="normal">By using the <code class="inlineCode">Transition</code> component and the state argument, we can create a smooth, declarative animation that responds to changes in the application state. This can be a powerful way to create engaging and dynamic user interfaces that feel alive and responsive.</p>
<p class="normal">Overall, transitions are a powerful new feature in React 18 that allow developers to create declarative animations and transitions with ease. By leveraging the power of React’s declarative programming model, developers can create complex animations and transitions with a few lines of code, making it easier than ever to create engaging and dynamic user interfaces.</p>
<h1 class="heading-1" id="_idParaDest-147">Suspense on the server</h1>
<p class="normal">React 18 introduces some<a id="_idIndexMarker361"/> improvements to <strong class="keyWord">server-side rendering</strong> (<strong class="keyWord">SSR</strong>) with <strong class="keyWord">Suspense</strong> that<a id="_idIndexMarker362"/> allow developers to create more efficient and scalable server-rendered applications.</p>
<p class="normal">Before React 18, Suspense was primarily used in client-side rendering to manage asynchronous data loading and code splitting. However, with React 18, Suspense can also be used on the server to optimize the rendering of server-rendered components.</p>
<p class="normal">Here’s a high-level overview of how Suspense works on the server:</p>
<ul>
<li class="bulletList">During the initial render of a server-rendered component, any Suspense boundaries are registered, and their fallback content is rendered instead of the main content.</li>
<li class="bulletList">When data loading or code splitting is required, the server can return a “placeholder” HTML response that contains the fallback content for the Suspense<a id="_idIndexMarker363"/> boundaries.</li>
<li class="bulletList">Once the asynchronous data or code has loaded, the client can hydrate the Suspense boundaries with the actual content, replacing the fallback content with the final content.</li>
</ul>
<p class="normal">This approach allows the server to avoid the expensive rendering of component trees that may be blocked by data loading or code splitting. Instead, the server can return a simple HTML response with fallback content, which can be quickly and easily rendered by the client. This can significantly improve the performance and scalability of server-rendered applications.</p>
<p class="normal">Here’s an example to illustrate how Suspense can be used on the server:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { <span class="hljs-title">Suspense</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> { fetchUserData } <span class="hljs-keyword">from</span> <span class="hljs-string">'./api'</span>
<span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>() {
  <span class="hljs-keyword">const</span> userData = <span class="hljs-title">fetchUserData</span>();
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Name: {userData.name}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">Suspense</span><span class="hljs-tag"> </span><span class="hljs-attr">fallback</span><span class="hljs-tag">=</span><span class="hljs-string">{</span><span class="hljs-tag">&lt;</span><span class="hljs-attr">p</span><span class="hljs-tag">&gt;</span>Loading...<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>}&gt;
        <span class="hljs-tag">&lt;</span><span class="hljs-name">UserProfile</span><span class="hljs-tag"> </span><span class="hljs-attr">userId</span><span class="hljs-tag">=</span><span class="hljs-string">{userData.id}</span><span class="hljs-tag"> /&gt;</span>
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">Suspense</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  )
}
</code></pre>
<p class="normal">In this example, we have a <code class="inlineCode">MyComponent</code> component that fetches user data from an API and renders it alongside a <code class="inlineCode">UserProfile</code> component that requires additional data loading. By wrapping the <code class="inlineCode">UserProfile</code> component in a <code class="inlineCode">Suspense</code> boundary, we can ensure that the fallback content is displayed until the additional data has been loaded.</p>
<p class="normal">When rendering on the server, the server can return a simple HTML response with the fallback content for the Suspense boundary, allowing the client to render the fallback content quickly and easily. Once the data has been loaded, the client can hydrate the Suspense boundary with the actual content, replacing the fallback content with the final content.</p>
<p class="normal">Overall, the improvements to SSR with Suspense in React 18 can help to improve the performance and <a id="_idIndexMarker364"/>scalability of server-rendered applications, making it easier to create fast and responsive web experiences for users.</p>
<h1 class="heading-1" id="_idParaDest-148">New APIs</h1>
<p class="normal">React 18 has introduced a variety of new APIs that are focused on enhancing the user interface, improving application performance, and providing a better developer experience. Notably, significant additions include <code class="inlineCode">createRoot</code>, <code class="inlineCode">hydrateRoot</code>, and <code class="inlineCode">renderToPipeableStream</code>.</p>
<h2 class="heading-2" id="_idParaDest-149">createRoot</h2>
<p class="normal">React 18 introduces a new API called <code class="inlineCode">createRoot</code>, which provides a simpler and more explicit way to render React<a id="_idIndexMarker365"/> components into the DOM.</p>
<p class="normal">Traditionally, when rendering a React application into the DOM, you would use the <code class="inlineCode">ReactDOM.render</code> method to specify the root element and the React component to render into it. For example:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> <span class="hljs-title">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>
<span class="hljs-keyword">const</span> <span class="hljs-title">App</span> = () =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>Hello, world!<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
}
<span class="hljs-title">ReactDOM</span>.<span class="hljs-title">render</span>(<span class="hljs-tag">&lt;</span><span class="hljs-name">App</span><span class="hljs-tag"> /&gt;</span>, <span class="hljs-variable">document</span>.<span class="hljs-title">getElementById</span>(<span class="hljs-string">'root'</span>))
</code></pre>
<p class="normal">With <code class="inlineCode">createRoot</code>, you can create a root element that can be used to <strong class="keyWord">render multiple components</strong>, instead <a id="_idIndexMarker366"/>of specifying the root element for each component. Here’s an example:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">App</span> = () =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>Hello, world!<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
}
<span class="hljs-keyword">const</span> root = <span class="hljs-title">ReactDOM</span>.<span class="hljs-title">createRoot</span>(<span class="hljs-variable">document</span>.<span class="hljs-title">getElementById</span>(<span class="hljs-string">'root'</span>))
root.<span class="hljs-title">render</span>(<span class="hljs-tag">&lt;</span><span class="hljs-name">App</span><span class="hljs-tag"> /&gt;</span>)
</code></pre>
<p class="normal">In this example, we first create a root element using <code class="inlineCode">createRoot</code>, passing in the DOM element that we want to render our React application into. We then use the <code class="inlineCode">render</code> method on the <code class="inlineCode">root</code> element to specify the React component to render.</p>
<p class="normal">The <code class="inlineCode">createRoot</code> API also supports concurrent mode, which allows React to update the UI in a more efficient <a id="_idIndexMarker367"/>and responsive way by breaking up large<a id="_idIndexMarker368"/> updates into smaller chunks. To use concurrent mode with <code class="inlineCode">createRoot</code>, you can pass a <code class="inlineCode">mode</code> option:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> root = <span class="hljs-title">ReactDOM</span>.<span class="hljs-title">createRoot</span>(<span class="hljs-variable">document</span>.<span class="hljs-title">getElementById</span>(<span class="hljs-string">'root'</span>), { <span class="hljs-attr">mode</span>: <span class="hljs-string">'concurrent'</span> })
root.<span class="hljs-title">render</span>(<span class="hljs-tag">&lt;</span><span class="hljs-name">App</span><span class="hljs-tag"> /&gt;</span>)
</code></pre>
<p class="normal">In this example, we pass the <code class="inlineCode">mod</code>e option with a value of <code class="inlineCode">'concurrent'</code>, indicating that we want to use concurrent mode when rendering our React components.</p>
<p class="normal">Overall, the <code class="inlineCode">createRoot</code> API provides a simpler and more flexible way to render React components into the DOM and supports the new features introduced in React 18, such as concurrent mode and the improved server-side rendering with Suspense.</p>
<h2 class="heading-2" id="_idParaDest-150">hydrateRoot</h2>
<p class="normal"><code class="inlineCode">hydrateRoot</code> is another<a id="_idIndexMarker369"/> new API introduced in React 18 that works in conjunction with <code class="inlineCode">createRoot</code>.</p>
<p class="normal">In the traditional React <a id="_idIndexMarker370"/>rendering model, the server would render a static HTML document and send it to the client, which would then create a new React root and render the app on the client side. However, with SSR, React can render the initial HTML on the server and send it to the client, which can then “hydrate” the HTML into a fully functional React app.</p>
<p class="normal"><code class="inlineCode">hydrateRoot</code> is used for this process of hydrating the initial HTML sent by the server into a React component tree. It allows React to reuse the server-rendered markup so that the initial page load is faster and there’s less work for the client to do.</p>
<p class="normal">Here’s an example of how you can use <code class="inlineCode">hydrateRoot</code> to hydrate the initial HTML on the client:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> <span class="hljs-title">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> { createRoot, hydrateRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>
<span class="hljs-keyword">const</span> <span class="hljs-title">App</span> = () =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>Hello, world!<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
}
<span class="hljs-keyword">const</span> root = <span class="hljs-title">createRoot</span>(<span class="hljs-variable">document</span>.<span class="hljs-title">getElementById</span>(<span class="hljs-string">'root'</span>))
<span class="hljs-keyword">if</span> (root.<span class="hljs-title">isMounted</span>()) {
  <span class="hljs-title">hydrateRoot</span>(<span class="hljs-variable">document</span>.<span class="hljs-title">getElementById</span>(<span class="hljs-string">'root'</span>), <span class="hljs-tag">&lt;</span><span class="hljs-name">App</span><span class="hljs-tag"> /&gt;</span>)
} <span class="hljs-keyword">else</span> {
  root.<span class="hljs-title">render</span>(<span class="hljs-tag">&lt;</span><span class="hljs-name">App</span><span class="hljs-tag"> /&gt;</span>)
}
</code></pre>
<p class="normal">In this example, we first create a root element using <code class="inlineCode">createRoot</code> as we did in the previous example. We then <a id="_idIndexMarker371"/>check if the root is already mounted by calling <code class="inlineCode">root.isMounted()</code>. If it is, we use <code class="inlineCode">hydrateRoot</code> to hydrate the existing HTML on the page. If not, we use <code class="inlineCode">root.render</code> to render the React component as usual.</p>
<p class="normal">Note that you need to ensure that the server and client render the same HTML structure, otherwise, hydration <a id="_idIndexMarker372"/>may fail, and you may end up with a mismatch between the server-rendered markup and the hydrated React component tree. To avoid this, you can use the Suspense component to handle asynchronous rendering and data fetching on both the server and client and ensure that the HTML structure remains the same.</p>
<h2 class="heading-2" id="_idParaDest-151">renderToPipeableStream</h2>
<p class="normal"><code class="inlineCode">renderToPipeableStream</code> is another<a id="_idIndexMarker373"/> new API introduced in React 18 that allows you to render a React component tree to a <strong class="keyWord">Node.js</strong> stream. This can be <a id="_idIndexMarker374"/>useful for server-side rendering in scenarios where you need to send the rendered content over a network or to a file.</p>
<p class="normal">Here’s an example of how you can use <code class="inlineCode">renderToPipeableStream</code> to render a React component to a stream:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> <span class="hljs-title">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> { renderToPipeableStream } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom/server'</span>
<span class="hljs-keyword">import</span> { createServer } <span class="hljs-keyword">from</span> <span class="hljs-string">'http'</span>
<span class="hljs-keyword">const</span> <span class="hljs-title">App</span> = () =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>Hello, world!<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
}
<span class="hljs-keyword">const</span> server = <span class="hljs-title">createServer</span>(<span class="hljs-function">(</span><span class="hljs-params">req, res</span><span class="hljs-function">) =&gt;</span> {
  <span class="hljs-keyword">const</span> stream = <span class="hljs-title">renderToPipeableStream</span>(<span class="hljs-tag">&lt;</span><span class="hljs-name">App</span><span class="hljs-tag"> /&gt;</span>)
  stream.<span class="hljs-title">pipe</span>(res)
})
server.<span class="hljs-title">listen</span>(<span class="hljs-number">3000</span>)
</code></pre>
<p class="normal">In this example, we first create a simple React component called <code class="inlineCode">App</code>. We then create a Node.js HTTP server using the <code class="inlineCode">createServer</code> method. When a request is made to the server, we use <code class="inlineCode">renderToPipeableStream</code> to render the <code class="inlineCode">App</code> component to a Node.js stream. We<a id="_idIndexMarker375"/> then pipe the stream to the response object using the <code class="inlineCode">pipe</code> method.</p>
<p class="normal">Note that <code class="inlineCode">renderToPipeableStream</code> returns a Node.js stream that you can pipe to other streams or write<a id="_idIndexMarker376"/> to a file. This allows you to easily generate server-rendered content and send it over a network or save it to disk without having to buffer the entire HTML in memory.</p>
<p class="normal">Also note that <code class="inlineCode">renderToPipeableStream</code> is asynchronous, so it returns a Promise that resolves to the stream. This means that you can use it with <code class="inlineCode">await</code> to wait for the rendering to complete before sending the response.</p>
<p class="normal">Overall, <code class="inlineCode">renderToPipeableStream</code> is a useful API for SSR in Node.js environments and can help improve the performance and scalability of your server-rendered applications.</p>
<h1 class="heading-1" id="_idParaDest-152">New Hooks</h1>
<p class="normal">In React 18, a set of innovative <a id="_idIndexMarker377"/>hooks has been introduced, which provide enhanced techniques for managing IDs, transitions, and optimizing performance. These hooks include <code class="inlineCode">useId</code>, <code class="inlineCode">useTransition</code>, <code class="inlineCode">useDeferredValue</code>, and <code class="inlineCode">useInsertionEffect</code>.</p>
<h2 class="heading-2" id="_idParaDest-153">useId</h2>
<p class="normal"><code class="inlineCode">useId</code> is a new built-in hook in React 18 that can be <a id="_idIndexMarker378"/>used to generate a unique ID. This can be useful in<a id="_idIndexMarker379"/> scenarios where you need to generate unique identifiers for elements in a React component, for example, when building forms.</p>
<p class="normal">Here’s an example of how you can use <code class="inlineCode">useId</code> to generate a unique ID:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { useId } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">const</span> <span class="hljs-title">MyComponent</span> = () =&gt; {
  <span class="hljs-keyword">const</span> id = <span class="hljs-title">useId</span>()
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> </span><span class="hljs-attr">id</span><span class="hljs-tag">=</span><span class="hljs-string">{id}</span><span class="hljs-tag">&gt;</span>Hello, world!<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
}
</code></pre>
<p class="normal">In this example, we use the <code class="inlineCode">useId</code> hook to generate a unique ID, which we then use as the <code class="inlineCode">id</code> attribute of a <code class="inlineCode">&lt;div&gt;</code> element.</p>
<p class="normal"><code class="inlineCode">useId</code> generates a unique ID that is <a id="_idIndexMarker380"/>guaranteed to be different on each render. It takes an optional parameter that can be used to specify a prefix for the generated ID, which <a id="_idIndexMarker381"/>can be useful for naming elements in a consistent way.</p>
<p class="normal">Here’s an example of how you can use the <code class="inlineCode">prefix</code> parameter to specify a prefix for the generated ID:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { useId } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">const</span> <span class="hljs-title">MyComponent</span> = () =&gt; {
  <span class="hljs-keyword">const</span> id = <span class="hljs-title">useId</span>(<span class="hljs-string">'my-prefix'</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> </span><span class="hljs-attr">id</span><span class="hljs-tag">=</span><span class="hljs-string">{id}</span><span class="hljs-tag">&gt;</span>Hello, world!<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
}
</code></pre>
<p class="normal">In this example, we use the <code class="inlineCode">useId</code> hook with the <code class="inlineCode">'my-prefix'</code> prefix, which generates an ID that starts with the string <code class="inlineCode">'my-prefix'</code>. This can be useful for naming elements in a way that is consistent with your application’s naming conventions.</p>
<p class="normal">Overall, <code class="inlineCode">useId</code> is a useful addition to React 18 and can simplify the process of generating unique identifiers for elements in a React component.</p>
<p class="normal">Although the <code class="inlineCode">useId</code> hook in React 18 offers unique benefits, it’s essential to be aware of certain caveats to avoid potential issues. Firstly, it’s not recommended to use <code class="inlineCode">useId</code> for generating keys in a list. The preferred approach is to derive keys directly from your data. Secondly, the <code class="inlineCode">useId</code> Hook requires a perfect match between the component trees on the server and the client side during server rendering. Any discrepancies between the server and client-rendered trees could lead to inconsistent IDs.</p>
<h2 class="heading-2" id="_idParaDest-154">useTransition</h2>
<p class="normal"><code class="inlineCode">useTransition</code> is a new built-in hook in React 18 that allows you to add smooth transitions to your application. It’s<a id="_idIndexMarker382"/> part of the new concurrent mode feature <a id="_idIndexMarker383"/>and is designed to work with Suspense to create loading states and fallbacks for data fetching.</p>
<p class="normal">Here’s an example of how you can use <code class="inlineCode">useTransition</code> to add a loading spinner while data is being fetched:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> <span class="hljs-title">React</span>, { useState, useTransition } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">const</span> <span class="hljs-title">MyComponent</span> = () =&gt; {
  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title">useState</span>(<span class="hljs-literal">null</span>)
  <span class="hljs-keyword">const</span> [startTransition, isPending] = <span class="hljs-title">useTransition</span>({ <span class="hljs-attr">timeoutMs</span>: <span class="hljs-number">3000</span> })
  <span class="hljs-keyword">const</span> <span class="hljs-title">handleClick</span> = () =&gt; {
    <span class="hljs-title">startTransition</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> newData = <span class="hljs-title">fetchData</span>()
      <span class="hljs-title">setData</span>(newData)
    })
  }
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      {isPending &amp;&amp; <span class="hljs-tag">&lt;</span><span class="hljs-name">LoadingSpinner</span><span class="hljs-tag"> /&gt;</span>}
      <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{handleClick}</span><span class="hljs-tag">&gt;</span>Fetch Data<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
      {data &amp;&amp; <span class="hljs-tag">&lt;</span><span class="hljs-name">DataDisplay</span><span class="hljs-tag"> </span><span class="hljs-attr">data</span><span class="hljs-tag">=</span><span class="hljs-string">{data}</span><span class="hljs-tag"> /&gt;</span>}
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  )
}
</code></pre>
<p class="normal">In this example, we use <code class="inlineCode">useState</code> to store the fetched data and <code class="inlineCode">useTransition</code> to handle the loading state while the data is <a id="_idIndexMarker384"/>being fetched. When the <strong class="screenText">Fetch Data</strong> button is clicked, the <code class="inlineCode">startTransition</code> function is called with a callback that fetches the data and updates the state. The <code class="inlineCode">isPending</code> value returned from <code class="inlineCode">useTransition</code> is used to conditionally render a loading spinner.</p>
<p class="normal"><code class="inlineCode">useTransition</code> takes an optional configuration object with a <code class="inlineCode">timeoutMs</code> property that specifies the maximum amount of time to spend in the pending state before showing the loading spinner. If the data is fetched before the timeout expires, the loading spinner is not displayed.</p>
<p class="normal">Overall, <code class="inlineCode">useTransition</code> is a powerful new feature in React 18 that can help you create smoother, more responsive applications with better user experiences.</p>
<h2 class="heading-2" id="_idParaDest-155">useDeferredValue</h2>
<p class="normal"><code class="inlineCode">useDeferredValue</code> is a new built-in<a id="_idIndexMarker385"/> hook in React 18 that allows you to defer updates to a value until the next frame. This can be useful when working with<a id="_idIndexMarker386"/> performance-intensive operations like animations.</p>
<p class="normal">Here’s an example of how you can use <code class="inlineCode">useDeferredValue</code> to animate a component:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { useState, useDeferredValue } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>() {
  <span class="hljs-keyword">const</span> [x, setX] = <span class="hljs-title">useState</span>(<span class="hljs-number">0</span>)
  <span class="hljs-keyword">const</span> deferredX = <span class="hljs-title">useDeferredValue</span>(x, { <span class="hljs-attr">timeoutMs</span>: <span class="hljs-number">100</span> })
  <span class="hljs-keyword">function</span> <span class="hljs-title">handleClick</span>() {
    <span class="hljs-title">setX</span>(<span class="hljs-params">x</span><span class="hljs-function"> =&gt;</span> x + <span class="hljs-number">100</span>)
  }
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{{</span><span class="hljs-tag"> </span><span class="hljs-attr">transform:</span><span class="hljs-tag"> `</span><span class="hljs-attr">translateX</span><span class="hljs-tag">(${</span><span class="hljs-attr">deferredX</span><span class="hljs-tag">}</span><span class="hljs-attr">px</span><span class="hljs-tag">)` }} </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{handleClick}</span><span class="hljs-tag">&gt;</span>
      Click me!
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  )
}
</code></pre>
<p class="normal">In this example, we use <code class="inlineCode">useState</code> to store the current position of the component, and <code class="inlineCode">useDeferredValue</code> to defer updates to the position until the next frame. When the component is clicked, the<a id="_idIndexMarker387"/> position is updated using <code class="inlineCode">setX</code>. The deferred value is used to render the component with a transition effect using CSS transforms.</p>
<p class="normal"><code class="inlineCode">useDeferredValue</code> takes two arguments: the value to defer and an optional configuration object. The configuration object can be used to specify a <code class="inlineCode">timeoutMs</code> property that determines the maximum time to defer updates. By default, updates are deferred until the next frame.</p>
<p class="normal">Note that <code class="inlineCode">useDeferredValue</code> only works in conjunction with the <code class="inlineCode">useTransition</code> hook, which provides the timing information necessary to defer updates to the next frame.</p>
<h2 class="heading-2" id="_idParaDest-156">useInsertionEffect</h2>
<p class="normal"><code class="inlineCode">useInsertionEffect</code> is a variation of the existing <code class="inlineCode">useEffect</code> hook that allows you to perform actions after a DOM node<a id="_idIndexMarker388"/> has been inserted into the page. This can be useful for integrating with third-party libraries or for performing actions that<a id="_idIndexMarker389"/> require the presence of a DOM node.</p>
<p class="normal">Here’s an example of how to use <code class="inlineCode">useInsertionEffect</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { useInsertionEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>() {
  <span class="hljs-title">useInsertionEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable">document</span>.<span class="hljs-title">createElement</span>(<span class="hljs-string">'canvas'</span>)
    canvas.<span class="hljs-property">width</span> = <span class="hljs-number">300</span>
    canvas.<span class="hljs-property">height</span> = <span class="hljs-number">200</span>
    canvas.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">'red'</span>
    <span class="hljs-variable">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title">appendChild</span>(canvas)
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title">removeChild</span>(canvas)
    }
  }, [])
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>Hello, world!<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>This is my React component.<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  )
}
</code></pre>
<p class="normal">In this example, we use <code class="inlineCode">useInsertionEffect</code> to create a new <code class="inlineCode">canvas</code> element and add it to the DOM when the component is mounted. The cleanup function returned by the hook removes the <a id="_idIndexMarker390"/>canvas element when the component is unmounted.</p>
<p class="normal">Note that the second argument to <code class="inlineCode">useInsertionEffect</code> is an empty array. This is because we only want to perform the insertion action once the component is mounted. If we included any dependencies in the array, the insertion action would be performed every time those dependencies changed.</p>
<h1 class="heading-1" id="_idParaDest-157">Strict mode</h1>
<p class="normal">React 18 introduces a new feature called <strong class="keyWord">Strict Mode,</strong> which allows you to opt in to a stricter set of checks and warnings for your React application. The goal of Strict Mode is to catch potential <a id="_idIndexMarker391"/>problems early in development and to encourage best practices that make your code more performant and easier to debug.</p>
<p class="normal">Here’s an example of how to use Strict Mode:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> <span class="hljs-title">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>() {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">React.StrictMode</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>Hello, world!<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>This is my React component.<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">React.StrictMode</span><span class="hljs-tag">&gt;</span>
  )
}
</code></pre>
<p class="normal">In this example, we wrap our component tree with the <code class="inlineCode">React.StrictMode</code> component. This enables several additional checks and warnings during development, such as detecting unsafe lifecycle methods, identifying potential side effects, and highlighting potential performance issues.</p>
<p class="normal">Strict Mode does not <a id="_idIndexMarker392"/>affect the behavior of your application in production and should only be used during development. Once you are confident that your code is free of any issues highlighted by Strict Mode, you can remove the <code class="inlineCode">React.StrictMode</code> component from your code.</p>
<p class="normal">It’s worth noting that while Strict Mode can be useful for catching potential issues early in development, it is not a replacement for thorough testing and debugging. Always test your code thoroughly before deploying to production and use tools like React’s built-in debugging tools to identify and fix any issues that arise.</p>
<h1 class="heading-1" id="_idParaDest-158">Node.js latest features</h1>
<p class="normal">There are some relevant <a id="_idIndexMarker393"/>new features in the latest versions of Node (18 and 19); let’s see what is new in those versions.</p>
<h2 class="heading-2" id="_idParaDest-159">Experimental Fetch API</h2>
<p class="normal">Node.js 18 (also in version 19) includes an experimental global <strong class="keyWord">Fetch API</strong> that is now available by default. The <a id="_idIndexMarker394"/>API’s implementation is inspired by <strong class="keyWord">node-fetch</strong>, which is originally based on <strong class="keyWord">undici-fetch</strong> and <a id="_idIndexMarker395"/>comes <a id="_idIndexMarker396"/>from <strong class="keyWord">undici</strong>. The API’s developers aim to make it as close to the specification as possible, but some features require a browser environment and are thus omitted.</p>
<p class="normal">Here is an example that hits the Pokémon API:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">getPokemons</span> = <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title">fetch</span>(<span class="hljs-string">'https://pokeapi.co/api/v2/pokemon'</span>)
  <span class="hljs-keyword">if</span> (response.<span class="hljs-property">ok</span>) {
    <span class="hljs-keyword">const</span> pokemons = <span class="hljs-keyword">await</span> response.<span class="hljs-title">json</span>()
    <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(pokemons)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-variable">console</span>.<span class="hljs-title">error</span>(<span class="hljs-string">`</span><span class="hljs-subst">${response.status}</span><span class="hljs-string"> </span><span class="hljs-subst">${response.statusText}</span><span class="hljs-string">`</span>)
  }
}
<span class="hljs-title">getPokemons</span>()
</code></pre>
<p class="normal">This addition to Node.js 18 (also included in version 19) makes the following global variables <a id="_idIndexMarker397"/>available: <code class="inlineCode">fetch</code>, <code class="inlineCode">FormData</code>, <code class="inlineCode">Headers</code>, <code class="inlineCode">Request</code>, and <code class="inlineCode">Response</code>. Users can disable the API by specifying the <code class="inlineCode">--no-experimental-fetch</code> command-line flag.</p>
<h2 class="heading-2" id="_idParaDest-160">Experimental test runner module</h2>
<p class="normal">It’s important to note that the<a id="_idIndexMarker398"/> test runner module is still in its experimental phase. To write unit tests and generate<a id="_idIndexMarker399"/> reports in <strong class="keyWord">Test Anything Protocol</strong> (<strong class="keyWord">TAP</strong>) format, we can import the <code class="inlineCode">node:test</code> module. In this section, we’ll provide a few examples to illustrate how it works. This testing approach bears some similarity to Jest, a widely used JavaScript testing framework.</p>
<p class="normal">The <code class="inlineCode">node:test</code> module simplifies the process of writing JavaScript tests that generate reports in <strong class="keyWord">TAP</strong> format. To access it, simply use the following code:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> test <span class="hljs-keyword">from</span> <span class="hljs-string">'node:test'</span>
<span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">'node:assert'</span>
</code></pre>
<p class="normal">To provide an example, here’s a demonstration of a parent test with two subtests:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> test <span class="hljs-keyword">from</span> <span class="hljs-string">'node:test'</span>
<span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">'node:assert'</span>
<span class="hljs-title">test</span>(<span class="hljs-string">'Math tests'</span>, <span class="hljs-keyword">async</span> (t) =&gt; {
  <span class="hljs-keyword">await</span> t.<span class="hljs-title">test</span>(<span class="hljs-string">'Multiply test'</span>, <span class="hljs-function">(</span><span class="hljs-params">t</span><span class="hljs-function">) =&gt;</span> {
    <span class="hljs-keyword">const</span> n = <span class="hljs-number">2</span> * <span class="hljs-number">2</span>
    assert.<span class="hljs-title">equal</span>(n, <span class="hljs-number">4</span>)
  })
  <span class="hljs-keyword">await</span> t.<span class="hljs-title">test</span>(<span class="hljs-string">'Sum test'</span>, <span class="hljs-function">(</span><span class="hljs-params">t</span><span class="hljs-function">) =&gt;</span> {
    <span class="hljs-keyword">const</span> n = <span class="hljs-number">5</span> + <span class="hljs-number">3</span>
    assert.<span class="hljs-title">equal</span>(n, <span class="hljs-number">8</span>)
  })
})
</code></pre>
<p class="normal">If everything works fine, you should see something like this:</p>
<figure class="mediaobject"><img alt="Text  Description automatically generated" height="361" src="../Images/B18414_10_01.png" width="825"/></figure>
<p class="packt_figref">Figure 10.1: Experimental test runner module</p>
<h2 class="heading-2" id="_idParaDest-161">Experimental node watch</h2>
<p class="normal"><code class="inlineCode">Node --watch</code> was introduced as a direct competitor to <code class="inlineCode">nodemon</code>, and is a popular tool used for watching<a id="_idIndexMarker400"/> anything, although it has primarily been used for Node.js projects. However, with the code snippet provided below, you can now use it more easily:</p>
<pre class="programlisting code"><code class="hljs-code">node --watch &lt;file or directory to observe&gt;
</code></pre>
<p class="normal">This code will automatically detect any changes made to the specified file or directory and restart the server or script accordingly. This feature is available in versions 19.0.0 and 18.11.0+ of Node.js.</p>
<h2 class="heading-2" id="_idParaDest-162">Node 18 is now Long-Term Support (LTS)</h2>
<p class="normal">Following the release of<a id="_idIndexMarker401"/> Node.js 19, Node.js 18 became a <strong class="keyWord">LTS</strong> version on October 25, 2022, with the codename <em class="italic">Hydrogen</em>. This transition marks the end of the active development phase of Node.js 18.x.</p>
<p class="normal">The current Node.js 18.x release has moved to <strong class="keyWord">Active LTS</strong> status and will remain so until October 2023. After<a id="_idIndexMarker402"/> that, it will enter the <strong class="keyWord">Maintenance</strong> phase and continue to receive necessary security fixes and updates until the end of April 2025.</p>
<h1 class="heading-1" id="_idParaDest-163">Summary</h1>
<p class="normal">In React 18, a wide array of new features and enhancements are introduced, which simplify the development of high-quality and interactive applications. These include automatic batching of state updates, concurrent rendering, the inclusion of Suspense for data fetching, improved error handling, and the addition of new component types. As a result, developers now have the ability to create more responsive and engaging user interfaces. For React developers, considering an upgrade to React 18 holds significant value. Additionally, we have also explored key features in Node.js 18 and 19, which are crucial for enhancing our web projects.</p>
<p class="normal">In the next chapter, we will learn how to handle data properly by using React Context API, React Suspense, and <strong class="keyWord">stale-while-revalidate</strong> (<strong class="keyWord">SWR</strong>).</p>
</div>
</div></body></html>