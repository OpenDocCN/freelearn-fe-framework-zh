- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enhancing the User Experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remix enables us to build applications with progressive enhancement in mind.
    In Remix, enhancing the user experience can be achieved by making additive changes.
    This allows us to follow a simple step-by-step process to build our applications.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B17399_05.xhtml#_idTextAnchor078), *Fetching and Mutating Data*,
    we added data loading and mutations to our BeeRich application. When building
    out the create expense form, we first implemented the UI to work without JavaScript
    and then enhanced the browser’s default behavior with JavaScript. By doing so,
    we progressively enhanced the experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding progressive enhancement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefetching data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with action data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling concurrent mutations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, we will formalize how progressive enhancement works in Remix. After that,
    we will focus on advanced data loading and mutation topics, including how to prefetch
    loader data and assets. Next, we will learn how to access action data to display
    mutation feedback. Finally, we will learn how to support concurrent mutations
    in Remix.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you will understand the benefits of working with
    progressive enhancement in mind. You will also learn how to prefetch data, work
    with action data, and handle multiple form submissions simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you start this chapter, follow the instructions in the `README.md` file
    in this chapter’s folder on GitHub. You can find the code for this chapter here:
    [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/06-enhancing-the-user-experience](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/06-enhancing-the-user-experience).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding progressive enhancement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn more about the motivation behind progressive
    enhancement and introduce best practices for working with progressive enhancement
    in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Progressive enhancement is a design philosophy that aims to create a baseline
    user experience for users on older devices and browsers. Building with progressive
    enhancement in mind is like designing mobile first; you start with a minimal UI
    for small screens and progress from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'A less frequently used term is **graceful degradation**. Graceful degradation
    describes a similar idea: striving for the best experience possible while supporting
    older browsers and devices. Progressive enhancement works upward, while graceful
    degradation works downward.'
  prefs: []
  type: TYPE_NORMAL
- en: Progressive enhancement in Remix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remix allows us to build highly dynamic user experiences by utilizing web standards.
    Remix, by default, works without JavaScript. When working with progressive enhancement
    in mind, we can enhance the experience upward but still keep it accessible and
    usable when JavaScript is still loading, fails to load, or is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B17399_04.xhtml#_idTextAnchor057), *Routing in Remix*, we learned
    about Remix’s `Link` and `NavLink` components. These components enhance the browser’s
    default behavior with JavaScript. Without JavaScript, Remix’s `Link` and `NavLink`
    components still render an anchor tag that the browser can work with.
  prefs: []
  type: TYPE_NORMAL
- en: If JavaScript is available, `Link` and `NavLink` perform client-side navigations
    and fetch loader data and assets from the server without re-requesting the full
    HTML document. Client-side navigations aim to reduce response times by avoiding
    downloading the entire HTML document repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: Remix also supports progressive enhancement for data mutations. When using Remix’s
    `Form` component, we again let Remix enhance the experience. If JavaScript is
    available, Remix prevents the browser’s default behavior and initiates a fetch
    request to the specified action. However, without JavaScript, we still render
    a form element that the browser can work with. Remix is capable of falling back
    to native form submissions.
  prefs: []
  type: TYPE_NORMAL
- en: Remix provides the tools to create highly dynamic but progressively enhanced
    experiences. When working with progressive enhancement in mind, the first step
    is to make it work without JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Making it work without JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Making it work without JavaScript lets us keep things simple and take advantage
    of the browser’s default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several reasons why JavaScript might not be available on the client:'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is still loading, or React is still hydrating when the user interacts
    with the page. This frequently happens on slower network connections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript failed to load due to a network error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript failed to be interpreted, executed, or hydrated due to an error in
    the bundle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript is disabled on the browser by the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript is not supported in the user’s environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When our application works without JavaScript, we may be able to reach more
    people on slower networks or further away from our server locations. We may also
    be able to better serve assistive technologies that rely on the browser’s default
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Starting without JavaScript also ensures that our application logic lives on
    the server whenever possible, reducing our client bundle size and keeping our
    client application simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to disable JavaScript in a Remix app to emulate such
    an environment. For one, we can disable JavaScript in the browser’s developer
    tools. Alternatively, we can open the `app/root.tsx` file in an editor and remove
    the `Scripts` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Removing the `Scripts` component removes all script tags from the server-side
    rendered HTML document. By disabling JavaScript or not loading any JavaScript,
    we are forced to move logic from the client to our server-side `actions` and `loader`
    functions. Working with progressive enhancement in mind is a great way to reduce
    client-side code complexity for the baseline user experience. Once the baseline
    experience is implemented, we can add client-side JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Making it worse before making it better
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we make it work without JavaScript, we can think about further enhancing
    the experience with JavaScript. One thing to note is that enabling JavaScript
    will make the experience worse, not better. By default, the browser indicates
    page loads by showing a loading spinner in the browser window’s title tab. Full
    page reloads also reset client-side states such as form inputs and revalidate
    the UI with the latest server data. By preventing the browser’s default behavior,
    we get rid of these features.
  prefs: []
  type: TYPE_NORMAL
- en: If we skip refreshing client-side states, resetting forms, and showing loading
    indicators during transitions or submissions, the user experience suffers. Therefore,
    we need to add these features back using JavaScript when we stop the browser from
    doing its default actions.
  prefs: []
  type: TYPE_NORMAL
- en: We already added custom loading indications in [*Chapter 4*](B17399_04.xhtml#_idTextAnchor057),
    *Routing in Remix*. However, whenever we add a new form to our application, we
    should investigate the experience and see whether additional pending indications
    are necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Testing on slow networks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing on slow networks is a great way to check an application’s user experience.
    It is especially helpful when testing pending states. Take the expense creation
    form as an example; you might not have noticed the missing loading indication
    with the application running on your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: Your browser’s developer tools offer a toggle to throttle your connection to
    a preset or custom bandwidth. Setting throttling to **Slow 3G** allows you to
    test your application in a way not possible when developing on fast Wi-Fi.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test BeeRich on a slow 3G connection:'
  prefs: []
  type: TYPE_NORMAL
- en: Run BeeRich by executing `npm run dev` in the project’s root folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure JavaScript is enabled in case it was previously disabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the application in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the developer tools and navigate to the **Network** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look for the throttling functionality and select **Slow 3G**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the expense form in your browser window (`http://localhost:3000/dashboard/expense/`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill out the form and click **Submit**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the **Submit** button remains active and can be clicked again. It
    is not perfectly clear to the user that the form is currently being submitted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the `dashboard.expenses._index.tsx` route module in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the route component so that it uses the `useNavigation` hook to derive
    the current transition state of our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Test the new pending UI with the throttled network connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice how our changes to the **Submit** button enhance the experience. Submitting
    the expense creation form on a slow connection may take a few moments. Now, we
    have a clear loading indication.
  prefs: []
  type: TYPE_NORMAL
- en: Progressive enhancement is about making an application accessible to as many
    users as possible. Working with progressive enhancement in mind ensures that the
    baseline user experience stays simple enough to be used on older browsers and
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that building with progressive enhancement in mind creates a simpler
    mental model for building great user interfaces. First, we create the baseline
    implementation without JavaScript. Once the baseline implementation works, we
    focus on enhancing the experience with JavaScript. We test the application by
    throttling the network. This forces us to build a resilient user experience that
    scales up and down. Remix supports us by providing primitives and conventions
    that let us make additive changes to enhance the experience until we are satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: We’re just getting started! Remix can scale up to highly dynamic experiences.
    Next, we’ll learn how to prefetch data with Remix to reduce page transition times.
  prefs: []
  type: TYPE_NORMAL
- en: Prefetching data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to prefetch assets and loader data in Remix
    and how to utilize prefetching to speed up transition times.
  prefs: []
  type: TYPE_NORMAL
- en: Remix compiles the `routes` folder into a routing hierarchy at build time. The
    hierarchy information is stored in an asset manifest in the `public` folder. This
    asset manifest is used by both Remix’s frontend and backend applications.
  prefs: []
  type: TYPE_NORMAL
- en: Since Remix has access to the asset manifest on the client, Remix knows in advance
    which `loader` functions to call to transition to a route. This allows Remix to
    prefetch loader data (and route assets) before the transition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enabling prefetching in Remix is as easy as setting a prop on the link we want
    to prefetch data for:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `/app/routes/dashboard.tsx` file in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `prefetch` property to the **Income** and **Expenses** navigation links:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Visit the income overview page ([http://localhost:3000/dashboard/income](http://localhost:3000/dashboard/income))
    in your browser window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Network** tab of your developer tools.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clear the list of requests and filter for **All** requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, hover over the **Expenses** link in the navigation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inspect the **Network** tab. It should now list four prefetch requests, as
    visible in *Figure 6**.1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Inspecting prefetch requests](img/Figure_6.01_B17399.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Inspecting prefetch requests
  prefs: []
  type: TYPE_NORMAL
- en: 'A transition to `/dashboard/expenses/$id` from the income route matches the
    following route modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dashboard.tsx`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dashboard.expenses.tsx`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dashboard.expenses.$id.tsx`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `dashboard.tsx` route module is already active on the page, and there is
    no need to reload it. Remix only loads assets and loader data for the other two
    route modules. We can see four prefetch requests in *Figure 6**.1*. There are
    two requests of the JSON content type to fetch the required loader data and two
    requests to fetch the code-split JavaScript bundles of the two new route modules.
  prefs: []
  type: TYPE_NORMAL
- en: Inspect the requests by clicking on them in the **Network** tab. This should
    open a request detail view. Inspect the nested **Preview** and **Response** tabs.
    The JSON responses contain the loader data of the two route modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prefetching data is optional. With prefetching, we pull a lever to reduce request
    times but introduce a risk of fetching unnecessary data if the user does not visit
    the link.
  prefs: []
  type: TYPE_NORMAL
- en: Prefetching on render is the most aggressive strategy while prefetching on intent
    is based on the user’s actions on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Remix provides levers
  prefs: []
  type: TYPE_NORMAL
- en: Prefetching is a lever we can pull. Using prefetching reduces response times
    by increasing the risk of downloading unnecessary data over the network. Remix
    allows us to optimize our application for our use cases and requirements by providing
    levers.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve learned about prefetching, let’s dive deeper into mutations.
  prefs: []
  type: TYPE_NORMAL
- en: Working with action data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `loader` and `action` functions contain most of the business logic of our
    Remix application. This is where we fetch, filter, and update data. Both functions
    must return a `Response` object. You know about the `redirect` and `json` helper
    functions, which let us create specific `Response` objects, and you have already
    practiced working with loader data. In this section, we will learn how to work
    with action data. For that, we will update the expense details view and implement
    an edit expense form:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `dashboard.expenses.$id.tsx` route module in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the current code from `dashboard.expenses._index.tsx`. Can you modify the
    code to edit an existing expense? Give it a try!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final code for this chapter is available in the `/bee-rich/solution` folder
    on GitHub for this chapter. As we move forward, we'll help you align your work
    with this final solution.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Make sure to update the form''s `action` property using the `expense` object
    from the loader data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you haven''t already, update the `isSubmitting` constant''s `formAction`
    check:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We again use the `useNavigation` hook to compute whether we should add pending
    indications to the form. Note that, again, we ensure that the submitted form action
    matches this form’s `action` property.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, update the route component’s form fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add React’s `key` property to the `Form` component to ensure that React
    reconstructs the content of the form every time we transition between different
    expense details pages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following `action` function to the route module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the missing `updateExpense` function to the route module file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the `useActionData` hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: typeof operator. Note that action data – unlike loader data – can be undefined.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the action data to display a success message below the **Submit** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the app and test out the updated expense form!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Awesome! Just like that, we can leverage `action` data to communicate successful
    mutations. Make sure you implement the same functionality on the `income` routes.
    Try to adapt the income route modules without looking at the instructions. This
    will help you better understand the lessons of this chapter. If you get stuck,
    review the instructions of this chapter. You can also find the solution code for
    this chapter on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Use useActionData only within the same route module
  prefs: []
  type: TYPE_NORMAL
- en: Note that a form submission creates a navigation to the location of the `action`
    function. `useLoaderData` can only access loader data of the same route’s loader.
    Similarly, `useActionData` must be used in the route module of the `action` function
    that the form submits to.
  prefs: []
  type: TYPE_NORMAL
- en: Remix also provides advanced data mutation utilities. Next, we’ll add the ability
    to delete expenses and learn how to handle concurrent mutations in Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Handling concurrent mutations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have created expense creation and edit forms. Both forms are standalone
    on their respective pages. This section will teach you how to manage multiple
    form submissions simultaneously. Let’s start by adding a deletion form to every
    item in the expense overview list.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a form to a list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The goal of this section is to add a deletion form to every list item in the
    expense overview list. Clicking the item should delete the associated expense.
    Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t already, follow the instructions in the `README.md` file of
    this chapter on GitHub: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/06-enhancing-the-user-experience/bee-rich/README.md](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/06-enhancing-the-user-experience/bee-rich/README.md).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `README.md` file includes instructions for how to update the `ListLinkItem`
    component for this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, open the `dashboard.expenses.$id.tsx` route module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `deleteExpense` function to the route module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the newly created `deleteExpense` function in the `action` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, open the `dashboard.expenses.tsx` file in your editor and pass the `deleteProps`
    property to the `ListLinkItem` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: import { Outlet, useLoaderData, useNavigation, useParams } from '@remix-run/react';
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `useParams` hook in the route module component to access the `id` route
    parameter of the expense details page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `isActive` property to the `ListLinkItem` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let’s try out our implementation. Run the app locally, visit the expense overview
    page, and delete an expense object by clicking the `action` function handles the
    submission and redirects the user back to the current page or the expense overview
    page. After the mutation, Remix refetches the loader data, which triggers a re-render.
    The expense object disappears from the expenses list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Great! Each list item in the expenses list now contains a form to delete an
    expense. Next, let’s indicate pending states on deletion.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting multiple pending states
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already know that we can use the `useNavigation` hook to access the global
    navigation object. The navigation object’s state property indicates the current
    transition state of our app. Let’s use the `useNavigation` hook to indicate pending
    deletion for the deletion forms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `useNavigation` in `/app/components/links.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: const navigation = useNavigation();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Derive whether the form is currently submitting or loading:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we are playing extra safe here. We check whether there is currently
    a page navigation happening and whether `formAction` matches this form’s `action`
    function. Finally, we also make sure that the form’s `intent` value matches this
    form’s submit button’s `intent` value. This ensures that we only show the pending
    state if this delete button is clicked.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, use `isSubmitting` to disable the **Submit** button and indicate the
    pending submission conditionally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the application in development mode and open [http://localhost:3000/dashboard/expenses](http://localhost:3000/dashboard/expenses)
    in a browser window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Network** tab of the browser developer tools and set throttling to
    **Slow 3G**. This helps us experience the pending UI for longer. Also, make sure
    to filter by **Fetch/XHR** requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try deleting several expenses at once to see whether you spot any issues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may notice a flaw in the current implementation: deleting an expense seems
    to cancel all other ongoing deletions.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Can you reason why this is the case? Remix’s navigation object captures the
    global navigation state of our application. There can only be one page navigation
    at a time. If the user submits a second form, then Remix cancels the first navigation,
    as visible in *Figure 6**.2*. The navigation object is updated, reflecting the
    second form submission:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Canceling fetch requests](img/Figure_6.02_B17399.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Canceling fetch requests
  prefs: []
  type: TYPE_NORMAL
- en: Note that the deletions are not aborted; we only lose the pending indications.
    On the client, Remix cancels the current submission and updates the navigation
    object accordingly. However, the fetch request to delete the expense still reaches
    the server, and the action is performed. Remix also ensures that the loader data
    is only revalidated after every submission has been executed to avoid stale data
    in case the latest submission finishes faster than previous submissions.
  prefs: []
  type: TYPE_NORMAL
- en: Remix tracks all ongoing submissions but only handles the last navigation
  prefs: []
  type: TYPE_NORMAL
- en: Remember that Remix aims to emulate the browser’s default behavior. There can
    only ever be one page navigation. On concurrent form submissions, the last user
    action determines the final page navigation. In the background, Remix keeps track
    of all ongoing submissions to manage loader data revalidation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s fix the lost pending indications. We want to show the pending UI for
    every currently pending deletion. Luckily, Remix provides us with another way
    to declare a form. Remix’s `useFetcher` hook can declare a `Form` component with
    an isolated submission state:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `useFetcher`, replacing the `useNavigation` and `Form` imports, in in
    `/app/components/links.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: const fetcher = useFetcher();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, update the assignment of the `isSubmitting` constant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The fetcher object that’s returned from `useFetcher` has an isolated submission
    lifecycle and navigation state. The state is unaffected by other submissions or
    loading activities in the app.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that a `useFetcher` form submission still triggers all active `loader`
    functions to reload after mutation. This sets the global navigation state to `loading`.
    However, a `useFetcher` form submission does not set the global navigation object’s
    state to `submitting`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Replace `Form` with `fetcher.Form`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, create a few expenses using the expense creation form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the developer tools and navigate to the **Network** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Throttle to **Slow 3G**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filter for **Fetch/XHR** requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, click the delete (`useFetcher`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loading and mutating data without page navigations with `useFetcher`
  prefs: []
  type: TYPE_NORMAL
- en: Data mutations through the `Form` component navigate the user to the `action`
    function’s location. This is the browser’s default behavior for form submissions.
  prefs: []
  type: TYPE_NORMAL
- en: The `useFetcher` hook allows us to load and mutate data without triggering page
    navigations; `useFetcher` has an isolated navigation state and does not trigger
    page navigations if JavaScript is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note is that `useFetcher` still honors redirect responses from
    `action` functions. Also, in case JavaScript is not available, `useFetcher.Form`
    falls back to the native form element’s behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are plenty of use cases for `useFetcher`. You can read more about `useFetcher`
    in the Remix documentation: [https://remix.run/docs/en/2/hooks/use-fetcher](https://remix.run/docs/en/2/hooks/use-fetcher).'
  prefs: []
  type: TYPE_NORMAL
- en: Next, practice what you’ve learned and use the updated `ListLinkItem` component
    for the `income` routes. This will help you study this section’s newly introduced
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Amazing! We’ve covered much ground in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that we are currently facing an issue with our user experience.
    If you are on an expense details page (`dashboard/expenses/$id`) and quickly delete
    all expenses in one go, you may end up on a not found page. We will address this
    issue together in the next chapter, [*Chapter 7*](B17399_07.xhtml#_idTextAnchor105),
    *Error Handling* *in Remix*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about progressive enhancement. Progressive enhancement
    is a design philosophy that aims to create a baseline user experience for users
    on older devices and browsers.
  prefs: []
  type: TYPE_NORMAL
- en: You learned that Remix’s primitives work with and without JavaScript. This allows
    us to progressively enhance the experience and make our application accessible
    to more users. By building with progressive enhancement in mind, we ensure a simple
    but resilient experience for as many devices and browsers as possible. Once we
    ensure a baseline experience, we can enhance the experience with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you learned that Remix can scale both up and down. We can start simple
    and even disable JavaScript, but by making additive changes, we can create highly
    dynamic experiences with concurrent mutations, data revalidation, and prefetching.
  prefs: []
  type: TYPE_NORMAL
- en: Remix provides levers to optimize the experience for what is important to us.
    We can decide how aggressively we want to prefetch data by setting the `prefetch`
    property to `render`, `viewport`, `intent`, or `none`. You further learned about
    action data, which can be used to communicate error or success states after a
    mutation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned how Remix manages concurrent form submissions. You know
    that there can only ever be one active page navigation. Remix cancels all pending
    navigations and updates the global navigation object accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to manage concurrent pending indications and isolated action data,
    then we can use Remix’s `useFetcher` hook. This can be used to programmatically
    submit forms, but also offers a `useFetcher.Form` component that does not trigger
    a page navigation if JavaScript is available.
  prefs: []
  type: TYPE_NORMAL
- en: The `useFetcher` hook is especially useful to allow the submission of several
    forms concurrently while communicating the pending state of each of them in parallel.
    This is usually the case when rendering a list of forms, as we saw with the expense
    overview list in BeeRich.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on handling errors and see how we can use
    Remix to provide a great user experience, even when something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Remix team has created an amazing video series called Remix Singles that
    goes in depth into how to work with data in Remix. I recommend that you watch
    the entire series. Most notably for this chapter, the series has a video about
    concurrent mutations with `useFetcher` that you can find here: [https://www.youtube.com/watch?v=vTzNpiOk668&list=PLXoynULbYuEDG2wBFSZ66b85EIspy3fy6](https://www.youtube.com/watch?v=vTzNpiOk668&list=PLXoynULbYuEDG2wBFSZ66b85EIspy3fy6).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Remix documentation includes a page about progressive enhancement: [https://remix.run/docs/en/2/discussion/progressive-enhancement](https://remix.run/docs/en/2/discussion/progressive-enhancement)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also read more about progressive enhancement in the MDN Web Docs: [https://developer.mozilla.org/en-US/docs/Glossary/Progressive_Enhancement](https://developer.mozilla.org/en-US/docs/Glossary/Progressive_Enhancement).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information about the `useFetcher` hook in the Remix documentation:
    [https://remix.run/docs/en/2/hooks/use-fetcher](https://remix.run/docs/en/2/hooks/use-fetcher).'
  prefs: []
  type: TYPE_NORMAL
