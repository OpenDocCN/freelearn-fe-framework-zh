- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Test-Driving Data Input
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动数据输入
- en: In this chapter, you’ll explore React forms and controlled components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将探索React表单和受控组件。
- en: Forms are an essential part of building web applications, being the primary
    way that users enter data. If we want to ensure our application works, then invariably,
    that’ll mean we need to write automated tests for our forms. What’s more, there’s
    a lot of plumbing required to get forms working in React, making it even more
    important that they’re well-tested.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 表单是构建Web应用程序的重要组成部分，是用户输入数据的主要方式。如果我们想确保我们的应用程序正常工作，那么不可避免地，这意味着我们需要为我们的表单编写自动化测试。更重要的是，在React中使表单工作需要大量的配置，这使得它们得到良好的测试变得尤为重要。
- en: 'Automated tests for forms are all about the user’s behavior: entering text,
    clicking buttons, and submitting the form when complete.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 表单的自动化测试全部关于用户的行为：输入文本、点击按钮，以及表单完成时提交。
- en: 'We will build out a new component, `CustomerForm`, which we will use when adding
    or modifying customers. It will have three text fields: first name, last name,
    and phone number.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个新的组件，`CustomerForm`，当添加或修改客户时我们将使用它。它将包含三个文本字段：名字、姓氏和电话号码。
- en: In the process of building this form, you’ll dig deeper into testing complex
    DOM element trees. You’ll learn how to use parameterized tests to repeat a group
    of tests without duplicating code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建这个表单的过程中，你将更深入地了解测试复杂的DOM元素树。你将学习如何使用参数化测试重复一组测试而不重复代码。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Adding a form element
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加表单元素
- en: Accepting text input
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受文本输入
- en: Submitting a form
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交表单
- en: Duplicating tests for multiple form fields
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为多个表单字段复制测试
- en: By the end of this chapter, you’ll have a decent understanding of test-driving
    HTML forms with React.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够理解使用React进行HTML表单的测试驱动开发。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter04).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter04)。
- en: Adding a form element
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加表单元素
- en: An HTML form is a bunch of fields wrapped in a `form` element. Even though we’re
    mostly interested in the fields, we need to start with the `form` element itself.
    That’s what we’ll build in this section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: HTML表单是一系列字段，被包裹在 `form` 元素中。尽管我们主要对字段感兴趣，但我们仍需要从 `form` 元素本身开始。这就是本节我们将要构建的内容。
- en: 'Let’s create our first form by following these steps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤创建我们的第一个表单：
- en: 'Create a new file called `test/CustomerForm.test.js` and add the following
    scaffold. It contains all the usual imports and component test initialization
    that you’ve seen in the previous chapters:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `test/CustomerForm.test.js` 的新文件，并添加以下脚手架。它包含你在前几章中看到的所有常用导入和组件测试初始化：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now you’re ready to create your first test. Add the following test to the `describe`
    block:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经准备好创建你的第一个测试了。将以下测试添加到 `describe` 块中：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We have a complete test, so let’s run it and see what happens:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个完整的测试，所以让我们运行它看看会发生什么：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The failure tells us that it can’t find the module. That’s because we haven’t
    created it yet.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 失败告诉我们它找不到该模块。那是因为我们还没有创建它。
- en: 'So, create a blank file named `src/CustomerForm.js`. Running your test again
    should give you the following output:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，创建一个名为 `src/CustomerForm.js` 的空白文件。再次运行你的测试应该会给出以下输出：
- en: '[PRE3]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Stack traces from test helper code
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 测试辅助代码的堆栈跟踪
- en: Jest’s stack trace points to a failure within our extensions code, not the test
    itself. If our code was in an npm module, Jest would have skipped those test lines
    from its output. Thankfully, the error message is helpful enough.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Jest的堆栈跟踪指向我们扩展代码中的失败，而不是测试本身。如果我们的代码在一个npm模块中，Jest会跳过测试输出中的那些测试行。幸运的是，错误信息足够有帮助。
- en: 'To fix this issue, we need to add an export that matches the import we wrote
    at the top of our test file. Add the following line to `src/CustomerForm.js`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了修复这个问题，我们需要添加一个与我们在测试文件顶部编写的导入匹配的导出。将以下行添加到 `src/CustomerForm.js`：
- en: '[PRE4]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Running some tests gives the actual expectation failure:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行一些测试给出了实际的期望失败：
- en: '[PRE5]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This can be fixed by making the component return something:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过让组件返回一些内容来修复：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Before moving on, let’s pull out a helper for finding the `form` element. As
    in the previous chapter, this is arguably premature as we have only one test using
    this code right now. However, we’ll appreciate having the helper when we come
    to write our form submission tests later.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们提取一个用于查找 `form` 元素的辅助函数。正如前一章所述，这可能是过早的，因为我们现在只有一个测试使用这段代码。然而，当我们编写表单提交测试时，我们会感激有这个辅助函数。
- en: 'Open `test/reactTestExtensions.js` and add the following function:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `test/reactTestExtensions.js` 并添加以下函数：
- en: '[PRE7]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Modify your test file by adding the following `import`. You can leave the `element`
    import in place because we’ll use it later in the next section:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下 `import` 修改你的测试文件。你可以保留 `element` 的导入，因为我们将在下一节中使用它：
- en: '[PRE8]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, update your test to use the helper, as shown here. After this, your
    test should still be passing:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新你的测试以使用辅助函数，如下所示。之后，你的测试应该仍然通过：
- en: '[PRE9]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That’s all there is to creating the basic `form` element. With that wrapper
    in place, we’re now ready to add our first field element: a text box.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是创建基本 `form` 元素的全部内容。有了这个包装器，我们现在可以添加我们的第一个字段元素：一个文本框。
- en: Accepting text input
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接受文本输入
- en: In this section, we’ll add a text box to allow the customer’s first name to
    be added or edited.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将添加一个文本框，以便添加或编辑客户的第一个名字。
- en: Adding a text field is more complicated than adding the `form` element. First,
    there’s the element itself, which has a `type` attribute that needs to be tested.
    Then, we need to prime the element with the initial value. Finally, we’ll need
    to add a label so that it’s obvious what the field represents.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个文本字段比添加 `form` 元素更复杂。首先，有元素本身，它有一个需要测试的 `type` 属性。然后，我们需要用初始值初始化元素。最后，我们需要添加一个标签，以便清楚地表示字段的意义。
- en: 'Let’s start by rendering an HTML text input field onto the page:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在页面上渲染一个 HTML 文本输入字段开始：
- en: 'Add the following test to `test/CustomerForm.test.js`. It contains three expectations
    (there’s an exercise at the end of this chapter that you can follow to pull these
    out as a single matcher):'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试添加到 `test/CustomerForm.test.js` 中。它包含三个期望（本章末尾有一个练习，你可以按照它来提取这些期望作为一个单独的匹配器）：
- en: '[PRE10]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Relying on the DOM’s Form API
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于 DOM 的表单 API
- en: 'This test makes use of the Form API: any form element allows you to access
    all of its input elements using the `elements` indexer. You give it the element’s
    `name` attribute (in this case, `firstName`) and that element is returned.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试使用了表单 API：任何表单元素都允许你使用 `elements` 索引器访问其所有输入元素。你给出元素的 `name` 属性（在这个例子中，是
    `firstName`），然后返回该元素。
- en: This means we must check the returned element’s tag. We want to make sure it
    is an `<input>` element. If we hadn’t used the Form API, one alternative would
    have been to use `elements("input")[0]`, which returns the first input element
    on the page. This would make the expectation on the element’s `tagName` property
    unnecessary.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们必须检查返回的元素的标签。我们想确保它是一个 `<input>` 元素。如果我们没有使用表单 API，一个替代方案将是使用 `elements("input")[0]`，它返回页面上第一个输入元素。这将使对元素
    `tagName` 属性的期望变得不必要。
- en: 'Let’s move a bit faster. We’ll make all the expectations pass at once. Update
    `CustomerForm` so that it includes a single input field, as shown here:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们加快速度。我们将一次使所有期望通过。更新 `CustomerForm` 以包括一个单独的输入字段，如下所示：
- en: '[PRE11]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since this form will be used when modifying existing customers as well as adding
    new ones, we need to design a way to get the existing customer data into the component.
    We’ll do that by setting an `original` prop that contains the form data. Add the
    following test:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这个表单将在修改现有客户以及添加新客户时使用，我们需要设计一种方法将现有客户数据放入组件中。我们将通过设置包含表单数据的 `original` 属性来实现这一点。添加以下测试：
- en: '[PRE12]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To make this test pass, change the component definition to the following. We
    will use a prop to pass in the previous `firstName` value:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使这个测试通过，将组件定义更改为以下内容。我们将使用一个属性来传递之前的 `firstName` 值：
- en: '[PRE13]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Upon running the tests again, you’ll see that although this test now passes,
    the first two tests fail because they don’t specify the `original` prop. What’s
    more, we have a warning:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试后，你会发现尽管这个测试现在通过了，但前两个测试失败了，因为它们没有指定 `original` 属性。更重要的是，我们有一个警告：
- en: '[PRE14]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To fix the initial tests, create a new constant, `blankCustomer`, that will
    act as our “base” customer. It’ll do just fine for tests that don’t care about
    specific field values, such as our first two tests. Add this definition just above
    the `beforeEach` block:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了修复初始测试，创建一个新的常量 `blankCustomer`，它将作为我们的“基础”客户。对于不关心特定字段值的测试来说，这完全足够，比如我们的前两个测试。将此定义添加到
    `beforeEach` 块之上：
- en: '[PRE15]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What about specifying an empty object for the original prop?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于指定一个空对象作为原始属性，有什么看法吗？
- en: In this object definition, we set the `firstName` value to an empty string.
    You may think that either `undefined` or `null` would be good candidates for the
    value. That way, we could sidestep having to define an object like this and just
    pass an empty object, `{}`. Unfortunately, React will warn you when you attempt
    to set a controlled component’s initial value to `undefined`, which we want to
    avoid. It’s no big deal, and besides that, an empty string is a more realistic
    default for a text box.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个对象定义中，我们将 `firstName` 的值设置为空字符串。你可能认为 `undefined` 或 `null` 是更好的候选值。这样，我们可以避免定义这样的对象，只需传递一个空对象
    `{}`。不幸的是，当你尝试将受控组件的初始值设置为 `undefined` 时，React 会警告你，这是我们想要避免的。这不是什么大问题，而且除了这个之外，空字符串对于文本框来说是一个更现实的默认值。
- en: 'Update the first two tests so that they render with the `original` prop set,
    as shown here. With this change in place, you should have three passing tests,
    but the warning remains:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新前两个测试，使它们以设置 `original` 属性的方式渲染，如下所示。在这个更改到位后，你应该有三个通过测试，但警告仍然存在：
- en: '[PRE16]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To get rid of the warning, add the word `readOnly` to the input tag. You might
    be thinking: surely, we don’t want a read-only field? You’re right, but we need
    a further test, for modifying the input value, before we can avoid using the `readOnly`
    keyword. We’ll add that test a little further on:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了消除警告，将单词 `readOnly` 添加到输入标签中。你可能认为我们当然不希望有一个只读字段？你说得对，但我们需要一个进一步的测试，用于修改输入值，然后我们才能避免使用
    `readOnly` 关键字。我们将在稍后添加那个测试：
- en: '[PRE17]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Always consider React warnings to be a test failure. Don’t proceed without first
    fixing any warnings.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 总是认为 React 警告是测试失败。在没有先修复任何警告的情况下不要继续进行。
- en: 'The last two tests include the following line, which reaches inside the form
    to pull out the `firstName` field:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后两个测试包括以下行，它进入表单以提取 `firstName` 字段：
- en: '[PRE18]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s promote this to be a function in `test/reactTestExtensions.js`. Open
    that file and add the following definition after the definition for `form`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个功能提升到 `test/reactTestExtensions.js` 文件中。打开该文件，在 `form` 定义之后添加以下定义：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, import it into `test/CustomerForm.js`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将其导入到 `test/CustomerForm.js`：
- en: '[PRE20]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Change the last test you wrote so that it uses the new helper:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改你写的最后一个测试，使其使用新的辅助函数：
- en: '[PRE21]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Update the first test in the same way:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以相同的方式更新第一个测试：
- en: '[PRE22]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next up, we’ll add a label to the field. Add the following test, which uses
    the `element` helper:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为该字段添加一个标签。添加以下测试，它使用 `element` 辅助函数：
- en: '[PRE23]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Make this pass by inserting the new element into your JSX for `CustomerForm`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将新元素插入到 `CustomerForm` 的 JSX 中来使这个测试通过：
- en: '[PRE24]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The htmlFor attribute
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: htmlFor 属性
- en: The JSX `htmlFor` attribute sets the HTML `for` attribute. `for` couldn’t be
    used in JSX because it is a reserved JavaScript keyword. The attribute is used
    to signify that the label matches a form element with the given ID – in this case,
    `firstName`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 的 `htmlFor` 属性设置了 HTML 的 `for` 属性。`for` 在 JSX 中不能使用，因为它是一个保留的 JavaScript
    关键字。该属性用于表示标签与具有给定 ID 的表单元素相匹配——在这种情况下，`firstName`。
- en: 'Let’s add some text content to that label:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在那个标签中添加一些文本内容：
- en: '[PRE25]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Update the `label` element to make the test pass:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `label` 元素以使测试通过：
- en: '[PRE26]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we need to ensure that our input has an ID that matches it with the
    label’s `htmlFor` value so that they match up. Add the following test:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要确保我们的输入有一个与标签的 `htmlFor` 值匹配的 ID，以便它们可以匹配。添加以下测试：
- en: '[PRE27]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Making that pass is as simple as adding the new attribute:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使其通过就像添加新的属性一样简单：
- en: '[PRE28]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We’ve now created *almost* everything we need for this field: the input field
    itself, its initial value, and its label. But we don’t have any behavior for handling
    changes to the value – that’s why we have the `readOnly` flag.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在几乎已经为这个字段创建了所有需要的东西：输入字段本身、它的初始值和它的标签。但我们没有处理值更改的行为——这就是为什么我们有 `readOnly`
    标志的原因。
- en: 'Change behavior only makes sense in the context of submitting the form with
    updated data: if you can’t submit the form, there’s no point in changing the field
    value. That’s what we’ll cover in the next section.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在提交表单并更新数据的情况下更改行为才有意义：如果你无法提交表单，更改字段值就没有意义。这就是我们将在下一节中讨论的内容。
- en: Submitting a form
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交表单
- en: For this chapter, we will define “submit the form” to mean “call the `onSubmit`
    callback function with the current `customer` object.” The `onSubmit` callback
    function is a prop we’ll be passing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将定义“提交表单”为“调用当前`customer`对象的`onSubmit`回调函数”。`onSubmit`回调函数是我们将要传递的属性。
- en: This section will introduce one way of testing form submission. In [*Chapter
    6*](B18423_06.xhtml#_idTextAnchor099), *Exploring Test Doubles*, we will update
    this to a call to `global.fetch` that sends our customer data to our application’s
    backend API.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍一种测试表单提交的方法。在[*第6章*](B18423_06.xhtml#_idTextAnchor099) *探索测试替身* 中，我们将更新这个调用为`global.fetch`，将我们的客户数据发送到应用程序的后端API。
- en: We’ll need a few different tests to specify this behavior, each test building
    up the functionality we need in a step-by-step fashion. First, we’ll have a test
    that ensures the form has a submit button. Then, we’ll write a test that clicks
    that button without making any changes to the form. We’ll need another test to
    check that submitting the form does not cause page navigation to occur. Finally,
    we’ll end with a test submission after the value of the text box has been updated.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要几个不同的测试来指定这种行为，每个测试都是逐步构建我们需要的功能。首先，我们将有一个测试来确保表单有一个提交按钮。然后，我们将编写一个测试来点击该按钮而不对表单进行任何更改。我们还需要另一个测试来检查提交表单不会导致页面导航发生。最后，在文本框的值更新后，我们将结束一个测试提交。
- en: Submitting without any changes
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无更改提交
- en: 'Let’s start by creating a button in the form. Clicking it will cause the form
    to submit:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在表单中创建一个按钮开始。点击它将导致表单提交：
- en: 'Start by adding a test to check whether a submit button exists on the page:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，添加一个测试来检查页面上是否存在提交按钮：
- en: '[PRE29]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To make that pass, add the following single line at the bottom of the form’s
    JSX:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使它通过，在表单的JSX底部添加以下单行：
- en: '[PRE30]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following test introduces a new concept, so we’ll break it down into its
    component parts. To start, create a new test, `starting`, as follows:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下测试引入了一个新概念，所以我们将将其分解为其组成部分。首先，创建一个新的测试，`starting`，如下所示：
- en: '[PRE31]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `hasAssertions` expectation tells Jest that it should expect at least one
    assertion to occur. It tells Jest that at least one assertion must run within
    the scope of the test; otherwise, the test has failed. You’ll see why this is
    important in the next step.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasAssertions`期望告诉Jest它应该期望至少发生一个断言。它告诉Jest至少有一个断言必须在测试的作用域内运行；否则，测试就失败了。你将在下一步中看到为什么这很重要。'
- en: 'Add the following part of the test into the outline, below the `hasAssertions`
    call:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试部分添加到大纲中，在`hasAssertions`调用下方：
- en: '[PRE32]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This function call is a mix of the`render` call itself, and the`onSubmit` handler.
    This is the handler that we want React to call on form submission.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数调用是`render`调用本身和`onSubmit`处理程序的混合。这是我们希望React在表单提交时调用的处理程序。
- en: 'Finish off the test by adding the following line just below the call to `render`.
    This is the **Act** phase of our test, which in this test is the last phase of
    the test:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`render`调用下方添加以下行来完成测试。这是我们的测试的**执行**阶段，在这个测试中是测试的最后一个阶段：
- en: '[PRE33]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Using hasAssertions to avoid false positives
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`hasAssertions`避免假阳性
- en: You can now see why we need `hasAssertions`. The test is written out of order,
    with the assertions defined within the `onSubmit` handler. If we did not use `hasAssertions`,
    this test would pass right now because we never call `onSubmit`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以明白为什么我们需要`hasAssertions`。测试是按照顺序编写的，断言定义在`onSubmit`处理程序中。如果我们没有使用`hasAssertions`，这个测试现在就会通过，因为我们从未调用`onSubmit`。
- en: I don’t recommend writing tests like this. In [*Chapter 6*](B18423_06.xhtml#_idTextAnchor099),
    *Exploring Test Doubles*, we’ll discover `hasAssertions`. The method we’re using
    here is a perfectly valid TDD practice; it’s just a little messy, so you will
    want to refactor it eventually.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我不建议编写这样的测试。在[*第6章*](B18423_06.xhtml#_idTextAnchor099) *探索测试替身* 中，我们将发现`hasAssertions`。我们在这里使用的方法是有效的TDD实践；它只是有点混乱，所以你最终会想要重构它。
- en: 'Now, you need to import `click`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你需要导入`click`：
- en: '[PRE34]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Making this test pass is straightforward, despite the complicated test setup.
    Change the component definition so that it reads as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管测试设置很复杂，但使这个测试通过是直接的。更改组件定义，使其如下所示：
- en: '[PRE35]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, run the test with `npm test`. You’ll discover that the test passed but
    we have a new warning, as shown here:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`npm test`运行测试。你会发现测试通过了，但我们有一个新的警告，如下所示：
- en: '[PRE36]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Something is not quite right. This warning is highlighting something very important
    that we need to take care of. Let’s stop here and look at it in detail.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有些地方不太对劲。这个警告强调了我们需要注意的非常重要的事情。让我们停下来，仔细看看。
- en: Preventing the default submit action
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阻止默认提交操作
- en: 'This `Not implemented` console error is coming from the JSDOM package. HTML
    forms have a default action when submitted: they navigate to another page, which
    is specified by the `form` element’s `action` attribute. JSDOM does not implement
    page navigation, which is why we get a `Not implemented` error.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`未实现`控制台错误来自JSDOM包。HTML表单在提交时有一个默认行为：它们会导航到另一个页面，这个页面由`form`元素的`action`属性指定。JSDOM没有实现页面导航，这就是为什么我们会得到一个`未实现`错误。
- en: In a typical React application like the one we’re building, we don’t want the
    browser to navigate. We want to stay on the same page and allow React to update
    the page with the result of the submit operation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们正在构建的典型React应用程序中，我们不想让浏览器导航。我们希望停留在同一页面上，并允许React使用提交操作的结果更新页面。
- en: 'The way to do that is to grab the `event` argument from the `onSubmit` prop
    and call `preventDefault` on it:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要从`onSubmit`属性中获取`event`参数，并在其上调用`preventDefault`：
- en: '[PRE37]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Since that’s production code, we need a test that verifies this behavior. We
    can do this by checking the event’s `defaultPrevented` property:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是生产代码，我们需要一个测试来验证这种行为。我们可以通过检查事件的`defaultPrevented`属性来完成：
- en: '[PRE38]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: So, now the question becomes, how do we get access to this `Event` in our tests?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题变成了，我们如何在测试中获取这个`Event`？
- en: We need to create the `event` object ourselves and dispatch it directly using
    the `dispatchEvent` DOM function on the form element. This event needs to be marked
    as `cancelable`, which will allow us to call `preventDefault` on it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要自己创建`event`对象，并直接使用表单元素的`dispatchEvent` DOM函数将其派发。这个事件需要标记为`cancelable`，这将允许我们在其上调用`preventDefault`。
- en: Why clicking the submit button won’t work
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么点击提交按钮不起作用
- en: In the last couple of tests, we purposely built a submit button that we could
    click to submit the form. While that will work for all our other tests, for this
    specific test, it does *not* work. That’s because JSDOM will take a `click` event
    and internally convert it into a `submit` event. There is no way we can get access
    to that `submit` event object if JSDOM creates it. Therefore, we need to directly
    fire the `submit` event.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后几项测试中，我们故意构建了一个可以点击以提交表单的提交按钮。虽然这对我们其他所有测试都有效，但对于这个特定的测试，它**并不**有效。这是因为JSDOM会将一个`click`事件内部转换为`submit`事件。如果我们无法访问JSDOM创建的`submit`事件对象，我们就无法获取它。因此，我们需要直接触发`submit`事件。
- en: This isn’t a problem. Remember that, in our test suite, we strive to act as
    a real browser would – by clicking a submit button to submit the form – but having
    one test work differently isn’t the end of the world.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个问题。记住，在我们的测试套件中，我们努力模拟真实浏览器的行为——通过点击提交按钮来提交表单——但有一个测试工作方式不同并不是世界末日。
- en: 'Let’s put all of this together and fix the warning:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把所有这些放在一起并修复警告：
- en: 'Open `test/reactTestExtensions.js` and add the following, just below the `click`
    definition. We’ll use this in the next test:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`test/reactTestExtensions.js`，在`click`定义下方添加以下内容。我们将在下一个测试中使用它：
- en: '[PRE39]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Why do we need the bubbles property?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要bubbles属性？
- en: If all of this wasn’t complicated enough, we also need to make sure the event
    *bubbles*; otherwise, it won’t make it to our event handler.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切还不够复杂，我们还需要确保事件**冒泡**；否则，它不会到达我们的事件处理器。
- en: When JSDOM (or the browser) dispatches an event, it traverses the element hierarchy
    looking for an event handler to handle the event, starting from the element the
    event was dispatched on, working upwards via parent links to the root node. This
    is known as bubbling.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当JSDOM（或浏览器）派发一个事件时，它会遍历元素层次结构，寻找处理该事件的处理器，从事件派发的元素开始，通过父链接向上到根节点。这被称为冒泡。
- en: Why do we need to ensure this event bubbles? Because React has its *own* event
    handling system that is triggered by events reaching the React root element. The
    `submit` event must bubble up to our `container` element before React will process
    it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要确保这个事件冒泡？因为React有自己的事件处理系统，它由事件到达React根元素触发。在React处理之前，`submit`事件必须冒泡到我们的`container`元素。
- en: 'Import the new helper into `test/CustomerForm.test.js`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的辅助函数导入到`test/CustomerForm.test.js`：
- en: '[PRE40]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add the following test to the bottom of the `CustomerForm` test suite. It specifies
    that `preventDefault` should be called when the form is submitted:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试添加到`CustomerForm`测试套件的底部。它指定在表单提交时应调用`preventDefault`：
- en: '[PRE41]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To make that pass, first, update `CustomerForm` so that it has an explicit
    return:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让这个通过，首先，更新`CustomerForm`使其具有显式的返回值：
- en: '[PRE42]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Just above the return, add a new function, `handleSubmit`, and update the form
    so that it calls that instead:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在返回之上添加一个新函数`handleSubmit`，并更新表单使其调用该函数：
- en: '[PRE43]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Run your tests and ensure they are all passing.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的测试并确保它们都通过。
- en: Submitting changed values
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提交更改的值
- en: It’s finally the time to introduce some state into our component. We will specify
    what should happen when the text field is used to update the customer’s first
    name.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在我们的组件中引入一些状态了。我们将指定当使用文本字段更新客户的姓氏时应发生什么。
- en: The most complicated part of what we’re about to do is dispatching the DOM `change`
    event. In the browser, this event is dispatched after every keystroke, notifying
    the JavaScript application that the text field value content has changed. An event
    handler receiving this event can query the `target` element’s `value` property
    to find out what the current value is.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将要做的事情中最复杂的部分是派发DOM `change`事件。在浏览器中，这个事件在每次按键后都会派发，通知JavaScript应用程序文本字段的内容已更改。接收此事件的处理器可以查询`target`元素的`value`属性以找出当前值。
- en: Crucially, we’re responsible for setting the `value` property before we dispatch
    the `change` event. We do that by calling the `value` property setter.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的是，我们在派发`change`事件之前负责设置`value`属性。我们通过调用`value`属性的setter来实现这一点。
- en: 'Somewhat unfortunately for us testers, React has change tracking behavior that
    is designed for the browser environment, not the Node test environment. In our
    tests, this change tracking logic suppresses change events like the ones our tests
    will dispatch. We need to circumvent this logic, which we can do with a helper
    function called `originalValueProperty`, as shown here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们这些测试人员来说，不幸的是，React有一个为浏览器环境设计的更改跟踪行为，而不是Node测试环境。在我们的测试中，这种更改跟踪逻辑抑制了像我们测试将要派发的那样的事件。我们需要绕过这种逻辑，我们可以使用一个名为`originalValueProperty`的助手函数来实现，如下所示：
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you’ll see in the next section, we’ll use this function to bypass React’s
    change tracking and trick it into processing our event, just like a browser would.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在下一节中看到的，我们将使用这个函数来绕过React的更改跟踪，并让它像浏览器一样处理我们的事件。
- en: Only simulating the final change
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 仅模拟最终更改
- en: Rather than creating a `change` event for each keystroke, we’ll manufacture
    just the final instance. Since the event handler always has access to the full
    value of the element, it can ignore all intermediate events and process just the
    last one that is received.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会为每次按键创建一个`change`事件，而是只制造最终的实例。由于事件处理器始终可以访问元素的完整值，它可以忽略所有中间事件，只处理接收到的最后一个事件。
- en: 'Let’s begin with a little bit of refactoring:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一点重构开始：
- en: 'We’re going to use the submit button to submit the form. We figured out how
    to access that button in a previous test:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用提交按钮来提交表单。我们已经在之前的测试中找到了访问该按钮的方法：
- en: '[PRE45]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let’s move this definition into `test/reactTestExtensions.js` so that we can
    use it on our future tests. Open that file now and add this definition to the
    bottom:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个定义移动到`test/reactTestExtensions.js`，这样我们就可以在未来的测试中使用它。现在打开那个文件，并将此定义添加到末尾：
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Move back to `test/CustomerForm.test.js` and add the new helper to the imports:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`test/CustomerForm.test.js`，并将新助手添加到导入中：
- en: '[PRE47]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Update the `renders a submit button` test so that it uses that new helper,
    as shown here:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`渲染提交按钮`测试，使其使用那个新助手，如下所示：
- en: '[PRE48]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The helper extraction dance
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 助手提取舞蹈
- en: Why are we doing this dance of writing a variable in a test (such as `const
    button = ...`) only to then extract it as a function moments later, as we just
    did with `submitButton`?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们只写一个变量（例如`const button = ...`）在测试中（如我们刚才对`submitButton`所做的），然后稍后将其提取为函数呢？
- en: Following this approach is a systematic way of building a library of helper
    functions, meaning you don’t have to think too heavily about the “right” design.
    First, start with a variable. If it turns out that you’ll use that variable a
    second or third time, then extract it into a function. No big deal.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这种方法是一种系统地构建助手函数库的方法，这意味着你不必太过于考虑“正确”的设计。首先，从一个变量开始。如果你发现你会在第二次或第三次使用那个变量，那么将其提取为一个函数。没什么大不了的。
- en: 'It’s time to write the next test. This is very similar to the last test, except
    now, we need to make use of a new `change` helper function. We’ll define this
    in the next step:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候编写下一个测试了。这与上一个测试非常相似，但现在，我们需要使用一个新的`change`辅助函数。我们将在下一步定义它：
- en: '[PRE49]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This function uses the new `change` helper that was discussed at the beginning
    of this section. Add the following definitions to `test/reactTestExtensions.js`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此函数使用本节开头讨论的新`change`辅助函数。将以下定义添加到`test/reactTestExtensions.js`中：
- en: '[PRE50]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Figuring out interactions between React and JSDOM
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 确定React和JSDOM之间的交互
- en: The implementation of the `change` function shown here is not obvious. As we
    saw earlier with the `bubbles` property, React does some pretty clever stuff on
    top of the DOM’s usual event system.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的`change`函数的实现并不明显。正如我们之前在`bubbles`属性中看到的，React在DOM的常规事件系统之上做了一些相当巧妙的事情。
- en: It helps to have a high-level awareness of how React works. I also find it helpful
    to use the Node debugger to step through JSDOM and React source code to figure
    out where the flow is breaking.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对React的工作原理有一个高级的认识是有帮助的。我还发现使用Node调试器逐步通过JSDOM和React源代码来找出流程中断的地方很有帮助。
- en: 'To make this pass, move to `src/CustomerForm.js` and import `useState` into
    the module by modifying the existing React import:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使这个通过，转到`src/CustomerForm.js`并将`useState`导入模块，通过修改现有的React导入：
- en: '[PRE51]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Change the customer constant definition to be assigned via a call to `useState`.
    The default state is the original value of `customer`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将客户常量定义改为通过调用`useState`来分配。默认状态是`customer`的原始值：
- en: '[PRE52]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create a new arrow function that will act as our event handler. You can put
    this just after the `useState` line that you added in the previous step:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的箭头函数，它将充当我们的事件处理程序。你可以在上一步添加的`useState`行之后放置这个函数：
- en: '[PRE53]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the returned JSX, modify the `input` element, as shown here. We are replacing
    the `readOnly` property with an `onChange` property and hooking it up to the handler
    we just created. Now, the `value` property also needs to be updated so that it
    can use React’s component state rather than the component prop:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在返回的JSX中，修改`input`元素，如下所示。我们将`readOnly`属性替换为`onChange`属性，并将其连接到我们刚刚创建的处理程序。现在，`value`属性也需要更新，以便它可以使用React组件状态而不是组件属性：
- en: '[PRE54]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Go ahead and run the test; it should now be passing.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好吧，运行测试；现在它应该通过了。
- en: With that, you’ve learned how to test-drive the `change` DOM event, and how
    to hook it up with React’s component state to save the user’s input. Next, it’s
    time to repeat the process for two more text boxes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你已经学会了如何测试驱动`change`DOM事件，以及如何将其与React组件状态连接起来以保存用户的输入。接下来，是时候重复这个过程来处理另外两个文本框了。
- en: Duplicating tests for multiple form fields
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为多个表单字段复制测试
- en: So far, we’ve written a set of tests that fully define the `firstName` text
    field. Now, we want to add two more fields, which are essentially the same as
    the `firstName` field but with different `id` values and labels.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经编写了一套测试，完全定义了`firstName`文本字段。现在，我们想要添加两个更多字段，这些字段本质上与`firstName`字段相同，但具有不同的`id`值和标签。
- en: Before you reach for copy and paste, stop and think about the duplication you
    could be about to add to both your tests and your production code. We have six
    tests that define the first name. This means we would end up with 18 tests to
    define three fields. That’s a lot of tests without any kind of grouping or abstraction.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在你伸手去复制粘贴之前，停下来想想你即将添加到你的测试和生产代码中的重复内容。我们有六个测试定义了名字。这意味着我们将最终得到18个测试来定义三个字段。那将是很多没有任何分组或抽象的测试。
- en: So, let’s do both – that is, group our tests and abstract out a function that
    generates our tests for us.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们同时做这两件事——也就是说，将我们的测试分组并抽象出一个为我们生成测试的函数。
- en: Nesting describe blocks
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套`describe`块
- en: We can nest `describe` blocks to break similar tests up into logical contexts.
    We can invent a convention for how to name these `describe` blocks. Whereas the
    top level is named after the form itself, the second-level `describe` blocks are
    named after the form fields.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以嵌套`describe`块，将类似的测试拆分为逻辑上下文。我们可以制定一个命名这些`describe`块的约定。顶级块以表单本身命名，而第二级`describe`块则以表单字段命名。
- en: 'Here’s how we’d like them to end up:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们希望它们最终的样子：
- en: '[PRE55]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: With this structure in place, you can simplify the `it` descriptive text by
    removing the name of the field. For example, `"renders the first name field as
    a text box"` becomes `"renders as a text box"` because it has already been scoped
    by the `"first name field"` `describe` block. Because of the way Jest displays
    `describe` block names before test names in the test output, each of these still
    reads like a plain-English sentence, but without the verbiage. In the example
    just given, Jest will show us `CustomerForm first name field renders as a text
    box`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在此结构已建立的情况下，您可以通过删除字段的名称来简化`it`描述性文本。例如，`"renders the first name field as a
    text box"`变为`"renders as a text box"`，因为它已经被`"first name field"` `describe`块所限定。由于Jest在测试输出中在测试名称之前显示`describe`块名称的方式，这些内容仍然读起来像一句普通的英语句子，但没有冗余的词汇。在刚才给出的例子中，Jest将显示`CustomerForm
    first name field renders as a text box`。
- en: 'Let’s do that now for the first name field. Wrap the six existing tests in
    a `describe` block, and then rename the tests, as shown here:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为第一个字段（姓名字段）做这个操作。将六个现有的测试包裹在一个`describe`块中，然后重命名测试，如下所示：
- en: '[PRE56]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Be careful not to include the `preventsDefault` test out of this, as it’s not
    field-specific. You may need to adjust the positioning of your tests in your test
    file.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不要将`preventsDefault`测试包含在内，因为它不是字段特定的。您可能需要调整测试文件中测试的位置。
- en: That covers grouping the tests. Now, let’s look at using test generator functions
    to remove repetition.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这就涵盖了测试分组。现在，让我们看看如何使用测试生成函数来减少重复。
- en: Generating parameterized tests
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成参数化测试
- en: Some programming languages, such as Java and C#, require special framework support
    to build parameterized tests. But in JavaScript, we can very easily roll our own
    parameterization because our test definitions are just function calls. We can
    use this to our advantage by pulling out each of the existing six tests as functions
    that take parameter values.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言，如Java和C#，需要特殊的框架支持来构建参数化测试。但在JavaScript中，我们可以非常容易地自己实现参数化，因为我们的测试定义只是函数调用。我们可以利用这一点，将现有的六个测试作为接受参数值的函数提取出来。
- en: 'This kind of change requires some diligent refactoring. We’ll do the first
    two tests together, and then you can either repeat these steps for the remaining
    five tests or jump ahead to the next tag in the GitHub repository:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的更改需要一些勤奋的重构。我们将前两个测试一起做，然后您可以重复这些步骤来完成剩下的五个测试，或者跳到GitHub仓库中的下一个标签：
- en: 'Starting with `renders as a text box`, wrap the entirety of the `it` call in
    an arrow function, and then call that function straight after, as shown here:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`renders as a text box`开始，将整个`it`调用包裹在一个箭头函数中，然后直接调用该函数，如下所示：
- en: '[PRE57]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Verify that all your tests are passing.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证所有测试是否通过。
- en: 'Parameterize this function by promoting the `firstName` string to a function
    parameter. Then, you’ll need to pass in the `firstName` string into the function
    call itself, as shown here:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`firstName`字符串提升为函数参数来参数化此函数。然后，您需要将`firstName`字符串传递给函数调用本身，如下所示：
- en: '[PRE58]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Again, verify that your tests are passing.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，验证您的测试是否通过。
- en: Push the `itRendersAsATextBox` function up one level, into the parent `describe`
    scope. That will allow you to use it in subsequent `describe` blocks.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`itRendersAsATextBox`函数提升一级，进入父`describe`作用域。这将允许您在后续的`describe`块中使用它。
- en: 'Use the same procedure for the next test, `includes the existing value`:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下一个测试，`includes the existing value`，使用相同的程序：
- en: '[PRE59]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Verify your tests are passing and then push `itIncludesTheExistingValue` up
    one level, into the parent `describe` scope.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证测试通过，然后将`itIncludesTheExistingValue`提升一级，进入父`describe`作用域。
- en: 'Repeat this process for the label tests, which can be included in one function.
    The second test can use a parameter within its test definition, as shown here:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于标签测试，也可以在一个函数中包含，第二个测试可以在其测试定义中使用一个参数，如下所示：
- en: '[PRE60]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Repeat the same process for the three remaining tests:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对剩下的三个测试重复相同的步骤：
- en: '[PRE61]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Important note
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Check the completed solution for the full listing. This can be found in the
    `Chapter04/Complete` directory.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 检查完整的解决方案，这可以在`Chapter04/Complete`目录中找到。
- en: 'With all that done, your `describe` block will succinctly describe what the
    first name field does:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所做的一切完成后，您的`describe`块将简洁地描述姓名字段的功能：
- en: '[PRE62]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Take a step back and look at the new form of the `describe` block. It is now
    very quick to understand the specification for how this field should work.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 退后一步，看看`describe`块的新形式。现在，理解这个字段应该如何工作的规范变得非常快。
- en: Solving a batch of tests
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决一批测试
- en: Now, we want to duplicate those six tests for the last name field. But how do
    we approach this? We do this test by test, just as we did with the first name
    field. However, this time, we should go much faster as our tests are one-liners,
    and the production code is a copy and paste job.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要复制最后名字字段的那六个测试。但我们如何着手呢？我们一个一个地测试，就像我们处理第一个名字字段时一样。然而，这次我们应该更快，因为我们的测试是一行代码，而生产代码是复制粘贴的工作。
- en: 'So, for example, the first test will be this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，第一个测试将是这样的：
- en: '[PRE63]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You’ll need to update `blankCustomer` so that it includes the new field:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要更新`blankCustomer`，使其包含新字段：
- en: '[PRE64]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'That test can be made to pass by adding the following line to our JSX, just
    below the `firstName` input field:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`firstName`输入字段下方添加以下行，可以使该测试通过：
- en: '[PRE65]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This is just the start for the input field; you’ll need to complete it as you
    add the next few tests.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是输入字段的开始；你需要在添加接下来的几个测试时完成它。
- en: Go ahead and add the remaining five tests, along with their implementation.
    Then, repeat this process for the phone number field. When adding the submit tests
    for the phone number, make sure that you provide a string value made up of numbers,
    such as `"012345"`. Later in this book, we’ll add validations to this field that
    will fail if you don’t use the right values now.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 继续添加剩余的五个测试，以及它们的实现。然后，为电话号码字段重复这个过程。在添加电话号码的提交测试时，确保提供一个由数字组成的字符串值，例如`"012345"`。在本书的后面部分，我们将添加验证，如果现在不使用正确的值，这些验证将失败。
- en: Jumping ahead
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过
- en: You might be tempted to try to solve all 12 new tests at once. If you’re feeling
    confident, go for it!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想一次性解决所有12个新测试。如果你很有信心，那就试试吧！
- en: 'If you want to see a listing of all the tests in a file, you must invoke Jest
    with a single file. Run the `npm test test/CustomerForm.test.js` command to see
    what that looks like. Alternatively, you can run `npx jest --verbose` to run all
    the tests with full test listings:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要查看文件中所有测试的列表，你必须使用单个文件调用Jest。运行`npm test test/CustomerForm.test.js`命令以查看其外观。或者，你可以运行`npx
    jest --verbose`来运行所有测试，并带有完整的测试列表：
- en: '[PRE66]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Modifying handleChange so that it works with multiple fields
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改`handleChange`使其与多个字段一起工作
- en: 'Time for a small refactor. After adding all three fields, you will have ended
    up with three very similar `onChange` event handlers:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候进行小重构了。添加所有三个字段后，你将拥有三个非常相似的`onChange`事件处理程序：
- en: '[PRE67]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You can simplify these down into one function by making use of the `name` property
    on `target`, which matches the field ID:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`target`上的`name`属性来简化这些函数，该属性与字段ID相匹配：
- en: '[PRE68]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Testing it out
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试它
- en: At this stage, your the `AppointmentsDayView` instance is complete. Now is a
    good time to try it out for real.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一阶段，你的`AppointmentsDayView`实例已经完成。现在是一个真正尝试它的好时机。
- en: 'Update your entry point in `src/index.js` so that it renders a new `CustomerForm`
    instance, rather than `AppointmentsDayView`. By doing so, you should be ready
    to manually test:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`src/index.js`中的入口点，使其渲染一个新的`CustomerForm`实例，而不是`AppointmentsDayView`。通过这样做，你应该准备好手动测试：
- en: '![Figure 4.1 – The completed CustomerForm ](img/Figure_4.01_B18423.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 完成的CustomerForm](img/Figure_4.01_B18423.jpg)'
- en: Figure 4.1 – The completed CustomerForm
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 完成的CustomerForm
- en: 'With that, you have learned one way to quickly duplicate specifications across
    multiple form fields: since `describe` and `it` are plain old functions, you can
    treat them just like you would with any other function and build your own structure
    around them.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，你已经学会了一种快速在多个表单字段间复制规范的方法：因为`describe`和`it`是普通的函数，你可以像对待任何其他函数一样对待它们，并在它们周围构建自己的结构。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to create an HTML form with text boxes. You
    wrote tests for the `form` element, and for `input` elements of types `text` and
    `submit`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何创建带有文本框的HTML表单。你为`form`元素和`input`元素（类型为`text`和`submit`）编写了测试。
- en: Although the text box is about the most basic input element there is, we’ve
    taken this opportunity to dig much deeper into test-driven React. We’ve discovered
    the intricacies of raising `submit` and `change` events via JSDOM, such as ensuring
    that `event.preventDefault()` is called on the event to avoid a browser page transition.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管文本框可能是最基础的输入元素，但我们利用这个机会深入研究了测试驱动的React。我们发现通过JSDOM引发`submit`和`change`事件的复杂性，例如确保在事件上调用`event.preventDefault()`以避免浏览器页面转换。
- en: We’ve also gone much further with Jest. We extracted common test logic into
    modules, used nested `describe` blocks, and built assertions using DOM’s Form
    API.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Jest 上也做得更深入。我们将常见的测试逻辑提取到模块中，使用了嵌套的 `describe` 块，并使用 DOM 的表单 API 构建断言。
- en: 'In the next chapter, we’ll test-drive a more complicated form example: a form
    with select boxes and radio buttons.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将测试一个更复杂的表单示例：一个包含下拉框和单选按钮的表单。
- en: Exercises
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'The following are some exercises for you to try out:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些供你尝试的练习：
- en: 'Extract a `labelFor` helper into `test/reactTestExtensions.js`. It should be
    used like so:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `labelFor` 辅助函数提取到 `test/reactTestExtensions.js` 中。它应该这样使用：
- en: '[PRE69]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Add a `toBeInputFieldOfType` matcher that replaces the three expectations in
    the `itRendersAsATextBox` function. It should be used like so:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `toBeInputFieldOfType` 匹配器，以替换 `itRendersAsATextBox` 函数中的三个期望。它应该这样使用：
- en: '[PRE70]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
