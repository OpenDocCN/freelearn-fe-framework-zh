- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Experimental Object Recognition with TensorFlow
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TensorFlow进行实验性物体识别
- en: 'It’s time for something a bit more experimental. As we’ve seen, **artificial
    intelligence** (**AI**) offers lots of new opportunities to explore when writing
    code assisted by AI as well as building solutions that are powered by AI. In this
    chapter, we’ll take a look at **TensorFlow**. Google developed and published TensorFlow
    under an open source license. It enables developers to use and train machine learning
    models for different sorts of applications. You can find a curated list of demos
    on the TensorFlow website: [https://www.tensorflow.org/js/demos](https://www.tensorflow.org/js/demos).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候做一些更实验性的东西了。正如我们所见，**人工智能**（**AI**）在编写由AI辅助的代码以及构建由AI驱动的解决方案时提供了许多新的探索机会。在本章中，我们将探讨**TensorFlow**。Google在开源许可下开发和发布了TensorFlow。它使开发者能够使用和训练适用于不同应用的机器学习模型。你可以在TensorFlow网站上找到精选的演示列表：[https://www.tensorflow.org/js/demos](https://www.tensorflow.org/js/demos)。
- en: We’re going to apply a small part of the libraries that Google has published
    by leveraging the default published model for object recognition.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用Google发布的默认物体识别模型，应用库中的一个小部分。
- en: First, we’ll build a small example prototype to discover some of the capabilities.
    Then, we’ll apply our newly acquired knowledge to build something experimental
    and fun. It’s another game, where you have to track down real-life objects using
    the camera in your browser!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将构建一个小型的示例原型来发现一些功能。然后，我们将应用我们新获得的知识来构建一些实验性和有趣的东西。这是一个游戏，你需要使用浏览器中的摄像头追踪现实生活中的物体！
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Prototyping a concept to identify capabilities and limitations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过原型设计来识别功能和限制
- en: Leveraging multiple external APIs to build a multimedia app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用多个外部API构建多媒体应用
- en: Using the browser’s native **Camera**, **Text to Speech**, and **Media** **Stream**
    APIs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用浏览器的原生**摄像头**、**语音合成**和**媒体流**API
- en: The example we’ll be building has touch points with previous chapters and offers
    some potential opportunities for you to customize the application for your personal
    use case. I challenge you to create something unique here, based on the final
    code solution – maybe even a native app using what you learned about Quasar in
    [*Chapter 7*](B19563_07.xhtml#_idTextAnchor204)!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的示例与前面的章节有交集，为你提供了定制应用程序以适应个人用例的潜在机会。我挑战你在这里创建一些独特的东西，基于最终的代码解决方案——也许甚至是一个使用你在[*第7章*](B19563_07.xhtml#_idTextAnchor204)中学到的Quasar知识构建的原生应用！
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We’ll build the main app on the **Vuetify** framework ([https://vuetifyjs.com/en/](https://vuetifyjs.com/en/))
    and **Pinia** ([https://pinia.vuejs.org/](https://pinia.vuejs.org/)) to manage
    the state. As stated previously, we’ll leverage various **TensorFlow** libraries
    ([https://www.tensorflow.org/js/](https://www.tensorflow.org/js/)) to incorporate
    some intelligence into our app.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在**Vuetify**框架（[https://vuetifyjs.com/en/](https://vuetifyjs.com/en/)）和**Pinia**（[https://pinia.vuejs.org/](https://pinia.vuejs.org/)）上构建主要应用来管理状态。如前所述，我们将利用各种**TensorFlow**库（[https://www.tensorflow.org/js/](https://www.tensorflow.org/js/)）将一些智能融入我们的应用。
- en: 'You can find the complete code for this chapter here: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/09.tensorflow.](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/09.tensorflow
    )'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到本章的完整代码：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/09.tensorflow.](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/09.tensorflow
    )
- en: Let’s get started with a prototype app!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从原型应用开始吧！
- en: Introduction to TensorFlow
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TensorFlow简介
- en: When I need to research a new framework or technique, I find it very helpful
    to create a small application for it so that I can test it in complete isolation.
    We’re going to apply the same approach with TensorFlow. The original idea is that
    we create an app using the object recognition library ([https://github.com/tensorflow/tfjs-models/tree/master/coco-ssd](https://github.com/tensorflow/tfjs-models/tree/master/coco-ssd))
    and apply the model to images from the camera on our device.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我需要研究一个新的框架或技术时，我发现创建一个小型应用来测试它非常有帮助，这样我就可以在完全隔离的环境中测试它。我们将以TensorFlow应用同样的方法。原始的想法是，我们使用物体识别库（[https://github.com/tensorflow/tfjs-models/tree/master/coco-ssd](https://github.com/tensorflow/tfjs-models/tree/master/coco-ssd)）并应用模型到我们设备上的摄像头图像。
- en: Setting up the project
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置项目
- en: 'Let’s use a familiar framework to quickly build some boilerplate for our new
    project. We’ll use the Vuetify CLI to create a new project for us:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个熟悉的框架来快速构建我们新项目的样板代码。我们将使用 Vuetify CLI 为我们创建一个新项目：
- en: Run `npm create vuetify@3.0.0` in the command-line interface.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行界面中运行 `npm create vuetify@3.0.0`。
- en: Choose `vue-tensorflow` as the project’s name.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `vue-tensorflow` 作为项目的名称。
- en: Use the `Essentials (Vuetify, VueRouter,` `Pinia)` installation.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Essentials (Vuetify, VueRouter, Pinia)` 安装。
- en: Select `TypeScript` using the arrow keys.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用箭头键选择 `TypeScript`。
- en: Select `npm` to install the dependencies.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `npm` 来安装依赖项。
- en: If you navigate to the new project folder, you can run the local development
    server with `npm run dev`. The result should look very familiar to us since we’ve
    done this a few times now (see [*Chapter 5*](B19563_05.xhtml#_idTextAnchor130),
    *Figure 5**.1*).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你导航到新的项目文件夹，你可以使用 `npm run dev` 运行本地开发服务器。结果应该对我们来说非常熟悉，因为我们已经做过几次了（见 [*第5章*](B19563_05.xhtml#_idTextAnchor130)，*图5**.1*）。
- en: 'Next, we’ll install the dependencies for using TensorFlow. The first two dependencies
    we’ll install will help us in sourcing the CPU and WebGL to help with calculations
    in the algorithm. From the terminal, run the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将安装使用 TensorFlow 的依赖项。我们将安装的前两个依赖项将帮助我们获取 CPU 和 WebGL 以帮助算法中的计算。从终端运行以下命令：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We’ll use a pretrained model to help us with object recognition. **Coco SSD**
    ([https://github.com/tensorflow/tfjs-models/tree/master/coco-ssd](https://github.com/tensorflow/tfjs-models/tree/master/coco-ssd))
    can be used to identify multiple objects in a single image. We can install the
    model as a dependency of our project by running the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用预训练的模型来帮助我们进行对象识别。**Coco SSD** ([https://github.com/tensorflow/tfjs-models/tree/master/coco-ssd](https://github.com/tensorflow/tfjs-models/tree/master/coco-ssd))
    可以用于识别单张图像中的多个对象。我们可以通过运行以下命令将模型作为我们项目的依赖项安装：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That’s all we need for now!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们需要的就这些了！
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: One of the limitations we’ll be running into is that a pretrained model is trained
    to recognize a limited set of classes (classes refer to a classification of an
    object in a category). We only have access to some 80 different classes. We’re
    going to have to work with this limitation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遇到的一个限制是，预训练的模型是训练来识别有限类别的（类别指的是一个类别中对象的分类）。我们只能访问大约80个不同的类别。我们将不得不在这个限制下工作。
- en: 'To prepare the object recognition for future developments, we’ll create a store
    to wrap the features. Since we selected Pinia during installation, an empty store
    has been initialized on the project. We’ll create a new file called `objects.ts`
    in the `./store` folder: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.1-object.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.1-object.ts).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为未来的发展准备对象识别，我们将创建一个存储库来封装特征。由于我们在安装过程中选择了 Pinia，项目上已经初始化了一个空的存储库。我们将在 `./store`
    文件夹中创建一个名为 `objects.ts` 的新文件：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.1-object.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.1-object.ts).
- en: We set some properties to track the status of the model. Bear in mind that it
    can take some time for a model to load, so we have to make sure that we inform
    the user so that they have a decent user experience. On store initialization,
    we must immediately call the `loadModel()` function, which loads the model on
    the store (*lines 14, 32–39*), for easy access throughout the app.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了一些属性来跟踪模型的状态。请注意，模型加载可能需要一些时间，因此我们必须确保通知用户，以便他们有一个良好的用户体验。在存储初始化时，我们必须立即调用
    `loadModel()` 函数，该函数在存储中加载模型（*第14行，32-39行*），以便在整个应用程序中方便访问。
- en: We’ve also added and exposed a `detect` function (*lines 22–30*). The function
    takes in an image and runs the image through the model. The result is an array
    of detected items with a certainty per item.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加并公开了一个 `detect` 函数（*第22-30行*）。该函数接收一个图像并通过模型运行该图像。结果是包含每个项目确定性的检测到的项目数组。
- en: For now, this is enough for us to start working on an implementation. Now, let’s
    build an interface for our prototype.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这已经足够我们开始实施工作了。现在，让我们为我们的原型构建一个界面。
- en: Performing and displaying a status check
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行和显示状态检查
- en: 'It would be very valuable to see what the app is doing, especially since the
    first load of the model can take some time. We’ll build a nice visual component
    to list the status of loading the model. Let’s create a component called `StatusCheck.vue`
    in the `./``components` folder:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 看到应用正在做什么是非常有价值的，尤其是第一次加载模型可能需要一些时间。我们将在`./components`文件夹中创建一个名为`StatusCheck.vue`的组件：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This component is simply listing the status from the store in a nicely formatted
    way. It also emits the `model-loaded` event when the model is loaded so that we
    can pick up on the event. Let’s have the model loading status show up in our app.
    We can delete the `HelloWorld.vue` file from the `./components` folder and replace
    the contents of `./view/Home.vue` with the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件只是以良好的格式列出存储中的状态。当模型加载时，它还会发出`model-loaded`事件，这样我们就可以捕捉到该事件。让我们让模型加载状态显示在我们的应用中。我们可以从`./components`文件夹中删除`HelloWorld.vue`文件，并用以下内容替换`./view/Home.vue`的内容：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we can run our app for the first time. You will notice that it takes a
    while to load at first, but after some time, you should see something similar
    to the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以第一次运行我们的应用。你将注意到它最初加载需要一段时间，但过了一段时间后，你应该看到以下类似的内容：
- en: '![Figure 9.1 – Visualizing the status of the model](img/B19563_09_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 可视化模型的状态](img/B19563_09_01.jpg)'
- en: Figure 9.1 – Visualizing the status of the model
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 可视化模型的状态
- en: Now that our model has been loaded, we can use it! We’ll build an image upload
    field and have the model analyze the contents of the image.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载了模型，我们可以使用它了！我们将构建一个图像上传字段，让模型分析图像的内容。
- en: Selecting an image
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择图像
- en: 'We’ll begin by creating a new component in the `components` folder. We’ll call
    it `ImageDetect.vue` and start with the following contents:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在`components`文件夹中创建一个新的组件。我们将称之为`ImageDetect.vue`，并从以下内容开始：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As shown in the template, we’re moving some template logic to this file. We’re
    using the `<StatusCheck />` component with the `@model-loaded` event to determine
    whether the image detection controls should be visible or active.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如模板所示，我们将一些模板逻辑移动到这个文件中。我们使用`<StatusCheck />`组件和`@model-loaded`事件来确定图像检测控件是否可见或激活。
- en: In the scripts, we first set some of the variables we need to track the images
    that are being selected in the browser. Once the user changes the contents of
    the file, we can load the image in the browser’s memory so that we can display
    it in the placeholder.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，我们首先设置一些变量，以便跟踪在浏览器中选择的图像。一旦用户更改文件内容，我们就可以在浏览器内存中加载图像，以便在占位符中显示它。
- en: 'We’ll go to `./views/Home.vue` and replace its contents to load this new component:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将前往`./views/Home.vue`并替换其内容以加载这个新组件：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we have a feature that provides images and we have a store that should
    be able to detect objects on images. Let’s start to connect those by adding the
    store references to the `script` tag and adding a button to trigger the detection:
    [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.2-ImageDetect.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.2-ImageDetect.vue).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个提供图像的功能，并且我们有一个能够检测图像中对象的存储。让我们通过将存储引用添加到`script`标签并添加一个按钮来触发检测来开始连接它们：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.2-ImageDetect.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.2-ImageDetect.vue)。
- en: As shown on *line 7*, we’re ready to display detected objects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如第7行所示，我们已准备好显示检测到的对象。
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'In terms of limitations, I mentioned that the model is capable of identifying
    several objects. The list can be found here: [https://github.com/tensorflow/tfjs-models/blob/master/coco-ssd/src/classes.ts](https://github.com/tensorflow/tfjs-models/blob/master/coco-ssd/src/classes.ts).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在局限性方面，我提到该模型能够识别多个对象。列表可以在以下位置找到：[https://github.com/tensorflow/tfjs-models/blob/master/coco-ssd/src/classes.ts](https://github.com/tensorflow/tfjs-models/blob/master/coco-ssd/src/classes.ts)。
- en: I recommend trying this feature out with images of a person, or one of the listed
    classes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议尝试使用人物图像或列出的类别之一来测试这个功能。
- en: 'After applying the detection, you should end up with something like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 应用检测后，你应该得到类似以下内容：
- en: '![Figure 9.2 – Object recognition based on an uploaded image](img/B19563_09_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 基于上传图像的对象识别](img/B19563_09_02.jpg)'
- en: Figure 9.2 – Object recognition based on an uploaded image
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 基于上传图像的对象识别
- en: 'This is already pretty interesting, but let’s see if we can apply some more
    features. First, we’ll look into formatting the results nicely: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.3-ImageDetect.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.3-ImageDetect.vue).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经很有趣了，但让我们看看我们是否可以应用更多功能。首先，我们将查看如何优雅地格式化结果：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.3-ImageDetect.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.3-ImageDetect.vue)。
- en: As shown on *lines 12–22*, we’ve added a nicely formatted list of detected items.
    We use the `roundNumber` function (*lines 18, 65–67*) to round the percentages.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如*第12-22行*所示，我们添加了一个格式良好的检测项目列表。我们使用`roundNumber`函数（*第18行，第65-67行*）来四舍五入百分比。
- en: Let’s explore adding an additional feature and see if we can give our application
    a voice by exploring the Speech Synthesis API.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索添加一个附加功能，看看我们是否可以通过探索语音合成API来给我们的应用添加语音。
- en: Adding a voice to the app
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为应用添加语音
- en: Since we’re looking at non-traditional input for our app (using images rather
    than a mouse and keyboard), it’s interesting to explore different ways of presenting
    information as well. Modern browsers have a built-in feature for converting **Text
    To Speech** (**TTS**) called **SpeechSynthesisUtterance** ([https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesisUtterance](https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesisUtterance)).
    Let’s work on an addition for our prototype where we can explore this.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在查看我们应用的非传统输入（使用图像而不是鼠标和键盘），探索不同的信息呈现方式也很有趣。现代浏览器内置了一个将**文本转换为语音**（**TTS**）的功能，称为**SpeechSynthesisUtterance**
    ([https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesisUtterance](https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesisUtterance))。让我们为我们的原型添加一个功能，以便我们可以探索这一点。
- en: 'This API is pretty straightforward to set up. We will start by creating a new
    component called `TextToSpeech.vue` in the `./components` folder that will accept
    the text as a prop:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个API设置起来相当简单。我们将首先在`./components`文件夹中创建一个新的组件，名为`TextToSpeech.vue`，它将接受文本作为属性：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the `tts` function, we can see how we can access the API and send a message
    to speak. Since we want to disable the button while speech is active, we’re keeping
    track of the `onstart` and `onend` callback functions and updating the `isSpeaking`
    variable accordingly. We’re playing around a bit with the `rate` and `pitch` settings
    as well.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tts`函数中，我们可以看到如何访问API并发送语音消息。由于我们希望在语音活动时禁用按钮，我们正在跟踪`onstart`和`onend`回调函数，并相应地更新`isSpeaking`变量。我们还在`rate`和`pitch`设置上做了一些实验。
- en: There are some more options we have when configuring `SpeechSynthesisUtterance`
    as we can read in the documentation. However, unfortunately, I’ve found that there
    are some limits. There are some mismatches between browsers and the support of
    certain languages is not very stable or usable. The `TextToSpeech.vue` component,
    however, should work in our application, so let’s add speech to our app!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置`SpeechSynthesisUtterance`时，我们有更多选项，正如我们可以在文档中看到的那样。然而，不幸的是，我发现了一些限制。浏览器之间有一些不匹配，某些语言的支持并不稳定或可用。然而，`TextToSpeech.vue`组件在我们的应用中应该可以工作，所以让我们给我们的应用添加语音功能！
- en: 'With the component stored, we’ll add it to the template of `ImageDetect.vue`
    (don’t forget to import the component!):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将组件存储后，我们将将其添加到`ImageDetect.vue`的模板中（别忘了导入组件！）：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see from the template, we need to provide the component with `speech`.
    Let’s have a look at the code: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.4-ImageDetect.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.4-ImageDetect.vue).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从模板中看到的那样，我们需要向组件提供`speech`。让我们看看代码：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.4-ImageDetect.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.4-ImageDetect.vue)。
- en: We’ve added a couple of helpers here. We want the speech to only name unique
    classes, so we’re adding a computed variable called `uniqueObjects` that filters
    all duplicate entries (*lines 71–75*). The computed `speech` value (*lines 77–85*)
    takes in that list and joins them using the Intl API, which we also used in [*Chapter
    4*](B19563_04.xhtml#_idTextAnchor092)! The output is what we can send safely to
    the `<TextToSpeech />` component.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里添加了一些辅助工具。我们希望语音只命名唯一的类别，因此我们添加了一个名为`uniqueObjects`的计算变量，它过滤所有重复条目（*第71-75行*）。计算出的`speech`值（*第77-85行*）接受该列表并使用Intl
    API将其连接起来，我们也在[*第4章*](B19563_04.xhtml#_idTextAnchor092)中使用过这个API！输出是我们可以安全发送到`<TextToSpeech
    />`组件的内容。
- en: Try it out if you want! Our prototype is functional, which is all we need to
    be able to learn from it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想的话，试试看！我们的原型是功能性的，这正是我们能够从中学习到的东西。
- en: Learning from the prototype
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从原型学习
- en: 'So, with this micro app in place, we can experiment a bit. I was running into
    two major problems:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有了这个微应用程序，我们可以进行一些实验。我遇到了两个主要问题：
- en: Object recognition works, but it is very limited to the classes from the pretrained
    model. Providing a self-trained model should be possible, but it is a bit too
    complex to handle in the scope of this topic.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象识别是可行的，但它非常有限，仅限于预训练模型中的类别。提供自训练模型应该是可能的，但在本主题的范围内处理它有点过于复杂。
- en: The TTS capabilities between browsers are not very stable or reliable, especially
    between languages.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器之间的TTS功能并不非常稳定或可靠，尤其是在不同语言之间。
- en: My initial idea was to create an app that would use the camera feed to point
    out objects that we could then learn to translate. With those two limitations,
    it’s not going to be feasible to build. Luckily, we can still have some fun with
    the reliable features, without needing to modify the model.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我的最初想法是创建一个应用程序，它会使用摄像头流来指出我们可以学习翻译的对象。有了这两个限制，构建它将不可行。幸运的是，我们仍然可以借助可靠的功能来玩得开心，而不需要修改模型。
- en: Let’s build a little game where we need to collect objects. We can have the
    existing classes list and prune it a bit so that it fits our use case. Let’s go
    on a scavenger hunt!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个小游戏，我们需要收集物品。我们可以使用现有的类列表，并对其进行一些修剪，使其适合我们的用例。让我们进行一次寻宝活动！
- en: Scavenge Hunter
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻宝猎人
- en: In this section, we’ll build a small app that can run on a web browser, preferably
    on a mobile phone. With *Scavenge Hunter*, the goal is to collect certain items
    from a list. We can use parts of the classes list to control the items our user
    needs to collect and in that case, we’re sure to be able to detect those objects!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个可以在网络浏览器上运行的小应用程序，最好是在手机上。使用*Scavenge Hunter*的目标是从列表中收集某些物品。我们可以使用类列表的一部分来控制用户需要收集的物品，在这种情况下，我们肯定能够检测到那些对象！
- en: Once an object has been detected, we’re going to add a score based on the find
    and certainty of the model. Since we can’t guarantee that objects are being recognized
    properly, we should also be able to skip an assignment. Instead of uploading an
    image, we’re going to use the camera stream!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦检测到对象，我们将根据模型的发现和确定性为其添加分数。由于我们无法保证对象被正确识别，我们还应该能够跳过分配。我们不是上传图片，而是使用摄像头流！
- en: Setting up the project
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置项目
- en: We can continue using the prototype we built or create a new project if we’d
    like. In the case of the latter, the dependencies and store are required, so we’d
    need to repeat the relevant steps provided in the *Setting up the project* and
    *Performing and displaying a status* *check* sections.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续使用我们构建的原型，或者如果我们想的话，创建一个新的项目。在后一种情况下，需要依赖项和存储，因此我们需要重复提供在*设置项目*和*执行和显示状态*检查部分的相关步骤。
- en: Let’s see how we can turn the foundation of our prototype into a little game,
    shall we?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将我们原型的基石转变为一个小游戏，好吗？
- en: Generic changes
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用更改
- en: 'We’re going to start with a configuration file. We need to create this file
    in the root of the project as `config.ts`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从配置文件开始。我们需要在项目的根目录中创建此文件，命名为`config.ts`：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It can be very helpful to have this sort of configuration files in a central
    place so that we don’t have to spend time hunting settings down in individual
    files. Feel free to modify the game configuration values in the `config.ts` file!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个中心位置拥有这类配置文件非常有帮助，这样我们就不必花费时间在单个文件中寻找设置。请随意修改`config.ts`文件中的游戏配置值！
- en: Let’s also open the `./index.html` template so that we can update the title
    tag to the new project’s name – that is, *Scavenge Hunter*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`./index.html`模板，这样我们就可以更新标题标签为新项目的名称——即*Scavenge Hunter*。
- en: 'We’ll also create two new view files in the `./views` folder. It’s okay to
    just paste some placeholder content here, like so:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在`./views`文件夹中创建两个新的视图文件。在这里粘贴一些占位符内容是可以的，如下所示：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We need a view for the finding state, called `Find.vue`, and one for the end
    of a game, called `End.vue`. We’ll add the contents later, in the *Building the
    finish screen* and *Skipping to the end* sections. With the views in place, we
    can update the `./router/index.ts` file with the following contents: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.5-index.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.5-index.ts).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个用于查找状态的视图，称为`Find.vue`，以及一个用于游戏结束的视图，称为`End.vue`。我们将在*构建完成屏幕*和*跳到结束*部分中稍后添加内容。有了视图，我们可以更新`./router/index.ts`文件，内容如下：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.5-index.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.5-index.ts)。
- en: 'We’re also going to simplify the interface a bit more. In the `./layouts/default`
    folder, delete the `AppBar.vue` and `View.vue` files. In the `Default.vue` file,
    replace its contents with the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将进一步简化界面。在`./layouts/default`文件夹中，删除`AppBar.vue`和`View.vue`文件。在`Default.vue`文件中，将其内容替换为以下内容：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, we should be able to run the app, but there’s not much new to do at the
    moment. Let’s add some core features via Pinia stores.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该能够运行应用程序，但此刻没有太多新的事情要做。让我们通过Pinia存储添加一些核心功能。
- en: Additional stores
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 额外的存储
- en: 'I usually start by designing and setting up the stores since they usually act
    as a central source of information and methods. First, we’re going to replace
    the contents of the `./store/app.ts` file with contents that are very similar
    to those from [*Chapter* *6*](B19563_06.xhtml#_idTextAnchor162): [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.6-app.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.6-app.ts).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常先设计和设置存储，因为它们通常充当信息和方法的核心来源。首先，我们将用与[*第6章*](B19563_06.xhtml#_idTextAnchor162)中非常相似的内容替换`./store/app.ts`文件的内容：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.6-app.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.6-app.ts)。
- en: It’s a trimmed-down version of the app store we used to build our fitness tracker,
    but we’ve removed all the unnecessary features.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建我们的健身追踪器时使用的应用存储的精简版，但我们已经移除了所有不必要的功能。
- en: 'Since we’re dealing with a predefined list of classes, we’re going to add those
    to the `object.ts` store as an additional value:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处理的是一个预定义的类别列表，我们将把这些类别添加到`object.ts`存储中作为额外的值：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: I’ve not added all of the categories and instead selected the classes that we
    could find in someone’s home. You can change this to what you think is reasonable
    to have on hand (especially for testing purposes).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我并没有添加所有的类别，而是选择了我们能在某人家里找到的类别。你可以将其更改为你认为合理的库存（特别是为了测试目的）。
- en: 'Let’s also introduce some game mechanics by adding a `./store/game.ts` store
    file: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.7-game.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.7-game.ts).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加一个`./store/game.ts`存储文件来引入一些游戏机制：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.7-game.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.7-game.ts)。
- en: This store contains references to the rounds that are being played and which
    are being skipped (*lines 19–23*), keeps track of the score (*line 23*), and helps
    in selecting a category from the list of objects we’ve defined in the `object`
    store. In particular, `getNewCategory` (*lines 28–45*) is interesting since it
    pulls a randomized category from the `objects` collection while making sure it’s
    always a unique new category.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此存储包含对正在进行的回合和跳过的回合的引用（*第19-23行*），跟踪得分（*第23行*），并帮助我们从一个定义在`object`存储中的对象列表中选择一个类别。特别是`getNewCategory`（*第28-45行*）很有趣，因为它从`objects`集合中抽取一个随机类别，同时确保它始终是一个独特的新类别。
- en: 'As a final step in this section, we’ll replace the contents of the `./App.vue`
    file: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.8-App.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.8-App.vue).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后一步，我们将替换`./App.vue`文件的内容：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.8-App.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.8-App.vue)。
- en: This connects the app store’s capabilities to the interface. Now, we can continue
    building up our little game!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将应用商店的功能与界面连接起来。现在，我们可以继续构建我们的小游戏了！
- en: Starting a new game
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始新游戏
- en: 'We’ll start by creating a button that triggers the conditions for a new game.
    In the `components` folder, we’ll create a `StartGame.vue` component, which is
    nothing more than a button with some actions on it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个按钮，该按钮会触发新游戏的条件。在`components`文件夹中，我们将创建一个`StartGame.vue`组件，它不过是一个带有一些动作的按钮：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, we’re relying on the store to tell the button whether the button
    should be disabled. We trigger a new game by calling the `reset()` function of
    `gameStore` and calling a `navigateToPage` function on `appStore`. Now, we should
    be able to place this button component on the `Home.vue` view. Let’s update that
    view completely with the following contents:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们依赖于存储来告诉按钮是否应该禁用。我们通过调用`gameStore`的`reset()`函数和在`appStore`上调用`navigateToPage`函数来触发新游戏。现在，我们应该能够在`Home.vue`视图中放置这个按钮组件。让我们用以下内容完全更新该视图：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you’re running the app now, you’ll notice that it’s impossible to start
    the game. Since we want to use the user’s camera feed, we need to request access.
    We’re going to expand the `StatusCheck.vue` file to also make sure we have access
    to a camera. We can use a composable from the `VueUse` library for this. So, from
    the terminal, let’s install the `VueUse` package with the following command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你会注意到无法开始游戏。由于我们想使用用户的摄像头视频流，我们需要请求访问权限。我们将扩展`StatusCheck.vue`文件，以确保我们有权访问摄像头。我们可以使用`VueUse`库中的组合式来完成这项工作。因此，从终端，让我们使用以下命令安装`VueUse`包：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this dependency, we can update the `StatusCheck.vue` file. The changes
    to that component are quite extensive, so use the source from [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.9-StatusCheck.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.9-StatusCheck.vue).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个依赖项，我们可以更新`StatusCheck.vue`文件。该组件的更改相当广泛，因此请使用以下来源：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.9-StatusCheck.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.9-StatusCheck.vue)。
- en: Apart from some additional formatting on our model loading status and some template
    changes that show the actual status, most changes take place in the script. The
    `usePermission` composable returns a reactive property that lets us know if the
    user has granted access to use the camera. If both the model is loaded and the
    user has granted camera access, the game can start (*lines 61–65*). As you can
    see, we’re using the `watch` function on multiple values by providing them as
    arrays (line 61) to the `watch` function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对模型加载状态的一些额外格式化和显示实际状态的模板更改外，大多数更改都在脚本中。`usePermission`组合式返回一个响应式属性，告诉我们用户是否已授予使用摄像头的访问权限。如果模型已加载且用户已授予摄像头访问权限，则游戏可以开始（*第61-65行*）。如您所见，我们通过将它们作为数组（第61行）提供给`watch`函数，在多个值上使用`watch`函数。
- en: In the `onMounted` hook (*lines 67–81*), we manually attempt to request a video
    stream. Once the stream starts, we immediately close it down since we don’t need
    the stream, just the permission. The permission is persistent throughout our visit.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onMounted`钩子（*第67-81行*）中，我们手动尝试请求视频流。一旦流开始，我们就立即关闭它，因为我们不需要流，只需要权限。权限在我们访问期间是持久的。
- en: Building the finish screen
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建完成屏幕
- en: 'Before we dive into the image streams and object-hunting aspects, we’ll build
    the final screen. We’ll create a component in the `./components` folder to display
    the result of a game called `ScoreCard.vue`: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.10-ScoreCard.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.10-ScoreCard.vue).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入到图像流和对象搜索方面之前，我们将构建最终的屏幕。我们将在`./components`文件夹中创建一个组件来显示一个名为`ScoreCard.vue`的游戏的结果：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.10-ScoreCard.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.10-ScoreCard.vue).
- en: In the component, we’re just displaying some of the metrics that were being
    collected on playthrough. They are all properties that are part of `gameStore`,
    so we have easy access to them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件中，我们只是显示了一些在游戏过程中收集的指标。它们都是`gameStore`的一部分，因此我们可以轻松访问它们。
- en: 'In `End.vue`, we’ll import the `ScoreCard.vue` file and make some additions
    to the template:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在`End.vue`中，我们将导入`ScoreCard.vue`文件并对模板进行一些修改：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There’s not much going on here apart from the `<StartGame />` component, which
    we have reused to simply trigger a new game. That’s how you use slots! Now, we
    can work on the middle section!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里除了`<StartGame />`组件之外没有太多的事情，我们重用了这个组件来简单地触发一个新游戏。这就是使用插槽的方式！现在，我们可以开始处理中间部分了！
- en: Skipping to the end
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳到结尾
- en: 'First, let’s make sure we can complete a (very limited) flow by skipping all
    assignments. We’re going to implement the basic game flow in the `./views/Find.vue`
    file. Let’s take a look at the `script` tag since we have a lot going on in this
    file: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.11-Find(script).vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.11-Find(script).vue).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们确保我们可以通过跳过所有任务来完成一个（非常有限）的流程。我们将在`./views/Find.vue`文件中实现基本的游戏流程。让我们看看这个文件中的`script`标签，因为我们在这个文件中有很多事情要做：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.11-Find(script).vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.11-Find(script).vue).
- en: At the top of the `script` tag, we’re loading the properties and methods from
    the stores (*lines 3–15*). We use `appStore` to navigate to different pages and
    `gameStore` because that contains information about the progress of the current
    game.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在`script`标签的顶部，我们正在加载存储库中的属性和方法（*第3-15行*）。我们使用`appStore`导航到不同的页面，使用`gameStore`因为它包含有关当前游戏进度的信息。
- en: We have some computed values that help in presenting and formatting data nicely.
    `currentRound` (*lines 17–19*) displays the progress of the game. We use `isPlaying`
    (*lines 21–23*) to determine the boundaries of the rounds versus the maximum set
    of rounds. Lastly, we have some fun randomized motivational quotes (*lines 25–29*)
    that we’ve loaded from our configuration file.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些计算值有助于以良好的方式呈现和格式化数据。`currentRound`（*第17-19行*）显示游戏的进度。我们使用`isPlaying`（*第21-23行*）来确定回合与设定的最大回合数的界限。最后，我们还有一些有趣的随机励志名言（*第25-29行*），这些名言是从我们的配置文件中加载的。
- en: There are two methods in this component. One is to `skip` (*lines 31–39*) a
    round. The `skip` function tracks the number of rounds skipped (*line 32*) and
    modifies the player’s `score` (*lines 33–37*). We must make sure the score doesn’t
    fall below `0`. After skipping, we call the `newRound` method.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件中有两个方法。一个是`skip`（*第31-39行*）一个回合。`skip`函数跟踪跳过的回合数（*第32行*）并修改玩家的`score`（*第33-37行*）。我们必须确保分数不低于`0`。跳过后，我们调用`newRound`方法。
- en: 'The `newRound` function (*lines 41–47*) tracks what should happen: either the
    number of rounds has reached the maximum and we should navigate to the `End` state,
    or we should load a new category using the `getCategory` function from the store.
    To ensure we get started when we enter this `Find` state, we will call that `newRound`
    function in the `onMounted` hook.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`newRound`函数（*第41-47行*）跟踪应该发生的事情：要么回合数已达到最大值，我们应该导航到`End`状态，要么我们应该使用存储库中的`getCategory`函数加载一个新的类别。为了确保我们进入这个`Find`状态时开始，我们将在`onMounted`钩子中调用那个`newRound`函数。'
- en: 'Next, let’s look at the template of the `Find.vue` file, where we connect the
    computed values and methods to a basic interface: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.12-Find(template).vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.12-Find(template).vue).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`Find.vue`文件的模板，在那里我们将计算值和方法连接到基本界面：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.12-Find(template).vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.12-Find(template).vue).
- en: Again, there’s not much special going on here. We’re using the `<SkipRound />`
    component with the `@skipped` event to make sure we can move forward in rounds,
    regardless of whether we’ve been able to use object recognition.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这里并没有什么特别之处。我们使用`<SkipRound />`组件和`@skipped`事件来确保无论我们是否能够使用对象识别，我们都可以在回合中前进。
- en: 'Running the app at this stage should give us a result similar to the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段运行应用程序应该会给出以下类似的结果：
- en: '![Figure 9.3 – The basic game flow in place](img/B19563_09_03.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 基本游戏流程](img/B19563_09_03.jpg)'
- en: Figure 9.3 – The basic game flow in place
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 基本游戏流程
- en: You should be able to complete the entire flow now by skipping all of the rounds.
    A game like this makes more sense on a mobile device than a laptop or personal
    computer, so this would be a good time to make sure we can test the app properly.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够通过跳过所有回合来完成整个流程。这种游戏在移动设备上比在笔记本电脑或个人电脑上更有意义，所以现在是确保我们可以正确测试应用程序的好时机。
- en: Testing on a mobile device
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在移动设备上进行测试
- en: 'If you’re building an app for a specific use case, it makes a lot of sense
    to test those cases as early as possible! While we can open the app in mobile
    views in our browser, it would make a lot of sense to run it on a mobile device
    as well. The first thing we can do is automatically expose the development server
    host by updating the `dev` script in the `package.json` file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在为特定的用例构建应用程序，尽早测试这些用例是非常有意义的！虽然我们可以在浏览器中的移动视图中打开应用程序，但将其在移动设备上运行同样有意义。我们可以做的第一件事是自动通过更新`package.json`文件中的`dev`脚本来暴露开发服务器的主机：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This change automatically serves the content through your local network, so
    as long as your mobile device and development server are on the same network,
    you can access the app via the network address:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改会自动通过你的本地网络提供服务，只要你的移动设备和开发服务器在同一网络中，你就可以通过网络地址访问应用程序：
- en: '![Figure 9.4 – Exposing the development server to the network](img/B19563_09_04.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 将开发服务器暴露给网络](img/B19563_09_04.jpg)'
- en: Figure 9.4 – Exposing the development server to the network
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 将开发服务器暴露给网络
- en: 'We’re not there yet, though. The media feed is only accessible over a secure
    connection. Going with **Vite’s** recommendation in the official documentation
    ([https://vitejs.dev/config/server-options.html#server-https](https://vitejs.dev/config/server-options.html#server-https)),
    we’ll install a plugin for this using the terminal:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们还没有完成。媒体流仅可通过安全连接访问。根据官方文档中**Vite**的建议([https://vitejs.dev/config/server-options.html#server-https](https://vitejs.dev/config/server-options.html#server-https))，我们将使用终端安装一个插件：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once the installation is completed, we’ll update the `vite.confis.ts` file
    so that it can use the plugin:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们将更新`vite.confis.ts`文件，使其能够使用插件：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After saving, we can restart the development server. The contents are now served
    over an HTTPS protocol. It is not using a signed certificate, so you will probably
    receive a warning from the browser upon first entry. You can now validate each
    step using your mobile device as well!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 保存后，我们可以重启开发服务器。现在内容是通过HTTPS协议提供的。它没有使用已签名的证书，因此你可能会在首次进入时收到浏览器的警告。现在你也可以使用你的移动设备验证每个步骤！
- en: With that, we’ve built a basic flow from start to finish and we can test it
    on a mobile device. The game itself is not very interesting yet though, right?
    It’s time to add some object recognition to the game!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就从开始到结束构建了一个基本流程，我们可以在移动设备上对其进行测试。然而，游戏本身目前并不那么有趣，对吧？是时候给游戏添加一些对象识别了！
- en: Object recognition from the camera
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从摄像头进行对象识别
- en: 'This will be a change that involves a couple of steps. First, we’ll introduce
    a component that can capture video from the browser. We’ll create a `CameraDetect.vue`
    component in the `./components` folder: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.13-CameraDetect.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.13-CameraDetect.vue).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个涉及几个步骤的变化。首先，我们将引入一个可以捕获浏览器视频的组件。我们将在`./components`文件夹中创建一个`CameraDetect.vue`组件：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.13-CameraDetect.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.13-CameraDetect.vue)。
- en: The code in the `CameraDetect.vue` component uses composables from the `@vueuse`
    package to interact with the browsers’ `Devices` and `userMedia` APIs. We’re using
    `useDevicesList` to list the available cameras (*lines 33–40*) and populate a
    `<v-select />` component (*lines 4–14*). This allows the user to switch between
    available cameras.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`CameraDetect.vue`组件中的代码使用`@vueuse`包中的composables与浏览器的`Devices`和`userMedia`API交互。我们使用`useDevicesList`列出可用的摄像头（*第33-40行*）并填充一个`<v-select
    />`组件（*第4-14行*）。这允许用户在可用的摄像头之间切换。'
- en: The user needs to manually activate a camera (also when switching between cameras)
    for security reasons. The button in the component toggles the camera stream (*lines
    44–46*). To display the stream, we use `watchEffect` to pipe the stream into the
    `video` reference (*lines 48–50*). We can display the camera feed to the user
    by referencing the stream in the `<video />` HTML component (*line 20*).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安全原因，用户需要手动激活摄像头（在切换摄像头时也是如此）。组件中的按钮切换摄像头流（*第44-46行*）。为了显示流，我们使用`watchEffect`将流导入`video`引用（*第48-50行*）。通过在`<video
    />`HTML组件中引用流，我们可以将摄像头视频显示给用户（*第20行*）。
- en: Our stream is the replacement for the file upload of our prototype. We already
    have our store prepared to detect objects, so now, we’ll connect the stream to
    the `detect` function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的流是我们原型文件上传的替代品。我们已经准备好存储以检测对象，因此现在我们将流连接到`detect`函数。
- en: Detecting and recognizing objects on a stream
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在流上检测和识别对象
- en: One of the changes from our prototype is the way we provide images to the object
    recognition method. Using a stream means that we need to continuously process
    input, just as fast as the browser can.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们原型的一个变化是我们向对象识别方法提供图像的方式。使用流意味着我们需要连续处理输入，就像浏览器能够做到的那样快。
- en: Recognizing objects
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别对象
- en: 'Our `detect` method from `objectStore` needs to be able to determine if the
    recognized objects are the objects we are looking for. We’ll add some capabilities
    to the function in the `object.ts` file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`objectStore`中的`detect`方法需要能够确定识别出的对象是我们寻找的对象。我们将在`object.ts`文件中的函数中添加一些功能：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we’re adding an optional parameter called `className`. If it’s provided,
    we define a `filter` function. The filter is applied to the collection of recognized
    objects. If no `className` is provided, that filter function just defaults to
    returning `true`, which means it doesn’t filter out any objects. We only do this
    to provide backward compatibility for the `<ImageDetect />` component.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个名为`className`的可选参数。如果提供了它，我们定义一个`filter`函数。该过滤器应用于识别出的对象集合。如果没有提供`className`，该过滤器函数默认返回`true`，这意味着它不会过滤掉任何对象。我们只这样做是为了为`<ImageDetect
    />`组件提供向后兼容。
- en: Note
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When working on existing code bases, you have to keep these sorts of compatibility
    issues in mind while developing. In our case, backward compatibility was needed
    for a prototype function, so it’s not vital for our app. I’m highlighting this
    because, in large-scale applications with low test coverage, you may run into
    these solutions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理现有的代码库时，在开发过程中必须考虑到这些兼容性问题。在我们的案例中，原型函数需要向后兼容，因此对我们应用来说不是至关重要。我强调这一点是因为，在测试覆盖率低的大型应用中，你可能会遇到这些解决方案。
- en: With our changes to the `object.ts` file, we can pass the stream to `objectStore`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们对`object.ts`文件的修改，我们可以将流传递给`objectStore`。
- en: Detecting objects from the stream
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从流中检测对象
- en: 'We’ll begin by passing the video stream’s contents to our updated `detect`
    function from `objectStore`. We’ll also include `gameStore` so that we can pass
    the current category as the `className` property. Let’s add these lines to the
    `CameraDetect.vue` file to get ourselves set up:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将视频流的内 容传递给从 `objectStore` 更新的 `detect` 函数。我们还将包括 `gameStore`，以便我们可以将当前类别作为
    `className` 属性传递。让我们将这些行添加到 `CameraDetect.vue` 文件中，以便我们设置好：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Don’t forget about the `watch` hook that we import from Vue; we’ll need it
    to monitor camera activity! Next, we’ll add a function called `detectObject` to
    our scripts:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记我们从 Vue 导入的 `watch` 钩子；我们需要它来监控摄像头活动！接下来，我们将在脚本中添加一个名为 `detectObject` 的函数：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What’s happening here? We’ve created a recursive function that continuously
    calls the `detect` method by passing the `video` and `currentCategory` values.
    To throttle the calls, we’re using `window.requestAnimationFrame` ([https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)).
    Normally, this API is meant to query the browser when animating: the browser will
    accept the callback function once it’s ready to process it. This is perfect for
    our use case as well!'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？我们创建了一个递归函数，它通过传递 `video` 和 `currentCategory` 值不断调用 `detect` 方法。为了节流调用，我们使用了
    `window.requestAnimationFrame` ([https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame))。通常，这个
    API 是在动画时查询浏览器：浏览器将在准备好处理它时接受回调函数。这对于我们的用例来说也非常合适！
- en: 'We can trigger the initial call as soon as the video is enabled. The `watch`
    hook we’ve imported can monitor the `enabled` variable and call the `detectObject`
    function once the video has been enabled:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在视频启用时立即触发初始调用。我们导入的 `watch` 钩子可以监控 `enabled` 变量，并在视频启用后调用 `detectObject`
    函数：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, once we’ve found a match, we need to signal this to our application.
    We’ll add an `emit` event called `found` to trigger once the `detected` property
    has been populated with items:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦我们找到匹配项，我们需要向我们的应用程序发出信号。我们将添加一个名为 `found` 的 `emit` 事件，一旦 `detected` 属性被填充了项，就会触发：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We’re returning the top match from the collection of `detected` items to the
    parent component.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将 `detected` 项集合中的顶级匹配返回给父组件。
- en: Note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can make testing easier by temporarily modifying the `objects` property
    in `objectsStore` so that it holds a couple of values of objects you have on hand,
    such as `person`. Later, you can restore the list to its previous state.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过临时修改 `objectsStore` 中的 `objects` 属性来简化测试，使其包含你手头的一些对象的值，例如 `person`。稍后，你可以将列表恢复到其之前的状态。
- en: 'Using Vue’s DevTools, you can test the app again. If you open the DevTools
    and navigate to the **Timeline** and **Component events** panels, once the camera
    has made a positive match, you will see continuous events being emitted (well,
    once for every animation frame):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Vue 的 DevTools，你可以再次测试应用程序。如果你打开 DevTools 并导航到 **时间轴** 和 **组件事件** 面板，一旦摄像头做出正匹配，你将看到连续的事件被发出（嗯，每个动画帧一次）：
- en: '![Figure 9.5 – Positive matches being emitted by the <CameraDetect /> component](img/B19563_09_05.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 由 <CameraDetect /> 组件发出的正匹配](img/B19563_09_05.jpg)'
- en: Figure 9.5 – Positive matches being emitted by the <CameraDetect /> component
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 由 <CameraDetect /> 组件发出的正匹配
- en: We can now connect the emitted event to the `Find` state. So, let’s move over
    to the `./views/Find.vue` file so that we can pick up on the `found` event and
    pull it into our little game!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将发出的事件连接到 `Find` 状态。所以，让我们转到 `./views/Find.vue` 文件，这样我们就可以捕捉到 `found`
    事件并将其拉入我们的小游戏！
- en: Connecting detection
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接检测
- en: 'If we open the `Find.vue` file, we can now add the event handler on the component
    to the template. We’ll also provide a `disable` property to control the camera
    by changing the component line to the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开 `Find.vue` 文件，我们现在可以在组件的模板上添加事件处理程序。我们还将提供一个 `disable` 属性来通过更改组件行来控制摄像头，如下所示：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the script block, we have to make some changes to both pick up on the `found`
    event and provide the value for the `detectionDisabled` property. Let’s look at
    the new component code: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.14-Find.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.14-Find.vue).'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本块中，我们必须对`found`事件进行一些更改，并为`detectionDisabled`属性提供值。让我们看看新的组件代码：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.14-Find.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.14-Find.vue)。
- en: We’ve added the `detectionDisabled` reactive variable (*line 51*) and are passing
    it down to the `<CameraDetect />` component. In the existing `skip` function,
    we’re setting the value of `detectionDisabled` to `false` (*line 68*). We’re also
    adding the `found` function (*lines 78–86*), where we update the `detectionDisabled`
    value as well and process a new score by calculating the certainty of the recognized
    object (*lines 81–83*) and updating `gameStore` (*line 84*). Similar to the `skip`
    function, we call the `newRound` function to progress the game.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`detectionDisabled`响应式变量（*第51行*）并将其传递给`<CameraDetect />`组件。在现有的`skip`函数中，我们将`detectionDisabled`的值设置为`false`（*第68行*）。我们还添加了`found`函数（*第78-86行*），其中更新`detectionDisabled`的值并处理新的分数，通过计算识别对象的确定性（*第81-83行*）并更新`gameStore`（*第84行*）。与`skip`函数类似，我们调用`newRound`函数来推进游戏。
- en: Once the `newRound` function has been called, we update the `detectionDisabled`
    variable and set it to `true` to continue detection.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用`newRound`函数，我们更新`detectionDisabled`变量并将其设置为`true`以继续检测。
- en: This would be another good time to test the app. In this case, upon detection,
    you will rapidly progress through the rounds toward the end. If recognition seems
    unreliable, you can lower `DETECTION_ACCURACY_THRESHOLD` in the `./``config.ts`
    file.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是测试应用的一个很好的时机。在这种情况下，一旦检测到，你将迅速通过轮次，向终点前进。如果识别似乎不可靠，你可以在`./config.ts`文件中将`DETECTION_ACCURACY_THRESHOLD`降低。
- en: Wrapping up the game flow
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结游戏流程
- en: Although the game is now functional, it’s not playable since we’re not giving
    enough feedback to the user. With `appStore` at our disposal, one of the easiest
    solutions is to use the dialog! Once we’ve incorporated that, our mini-game will
    be complete!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然游戏现在功能正常，但由于我们没有给用户提供足够的反馈，所以游戏不可玩。有了`appStore`在手，最简单的解决方案之一就是使用对话框！一旦我们整合了它，我们的迷你游戏就完成了！
- en: 'First, we’ll update the `CameraDetect.vue` file by adding the reference to
    the `dialogVisible` reactive value. To do this, add the following to the `script`
    tag:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过添加对`dialogVisible`响应式值的引用来更新`CameraDetect.vue`文件。为此，请将以下内容添加到`script`标签中：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we’ll use `dialogVisible` in our `detectObject` function to assess whether
    it should call the `detect` function from `objectStore`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`detectObject`函数中使用`dialogVisible`来评估是否应该从`objectStore`调用`detect`函数：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This doesn’t affect our code yet since dialog has never been visible up until
    now. We’ll remedy that by making some changes to the `Find.vue` file as well.
    To define the contents of the dialog, we’ll add the following computed value to
    the `script` tag:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对话框之前从未可见，这不会影响我们的代码。我们将通过修改`Find.vue`文件来解决这个问题。为了定义对话框的内容，我们将在`script`标签中添加以下计算值：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This returns a motivating line to display to the user. Feel free to modify
    this! The two functions that we’ll change are called `found` and `skipped`. Let’s
    have a look at the updated `found` function first:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一条激励用户的话语。请随意修改！我们将更改的两个函数是`found`和`skipped`。让我们首先看看更新的`found`函数：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see, we’re simply using the `appStore` method of `showDialog` to
    present a dialog to the user. The `<CameraDetect />` component is now able to
    detect when a dialog is visible and will stop detecting in the background. For
    the `skipped` function, we’ll add the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们只是在使用`appStore`的`showDialog`方法向用户展示一个对话框。《CameraDetect />》组件现在能够检测到对话框的可见性，并将停止在后台检测。对于`skipped`函数，我们将添加以下内容：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, these are very similar changes! Again, feel free to modify these
    contents to your liking as well.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这些更改非常相似！再次提醒，你可以根据自己的喜好修改这些内容。
- en: Our game is now done! Hooray! We’ve now almost concluded our collection of applications.
    I think this game lends itself to being enriched with even more capabilities and
    more customization so that you can make it your own mini-game. From previous chapters,
    we’ve touched upon a lot of additional techniques and concepts you could apply
    or just get creative.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏现在完成了！太棒了！我们现在几乎完成了我们的应用程序收集。我认为这个游戏非常适合增加更多功能和定制，以便你可以将其变成你自己的迷你游戏。从前几章中，我们讨论了许多你可以应用或只是发挥创造力的额外技术和概念。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter with a small prototype to experiment with a new sort
    of technology. Building something in an isolated environment helps you quickly
    understand how a certain technology can be adopted in an existing environment.
    As you’ve experienced, we were running into limitations that could not be resolved.
    In this case, it didn’t matter that much, since we have few business requirements
    to deal with.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一个小型原型开始本章，以实验一种新技术。在一个隔离的环境中构建东西可以帮助你快速了解某种技术如何在现有环境中被采用。正如你所经历的，我们遇到了无法解决的限制。在这种情况下，这并不重要，因为我们处理的企业需求很少。
- en: We also learned how to leverage existing and available APIs from the browser
    itself to build something unconventional. When putting together a portfolio, standing
    out with unique projects can make you stand out as a developer. Building little
    projects while combining multiple technologies can help you understand how you
    can compose applications with them. This is a more intensive approach but results
    in a much better understanding of technologies.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学会了如何利用浏览器本身现有的和可用的 API 来构建一些非常规的东西。当组合一个作品集时，通过独特项目脱颖而出可以使你作为一个开发者脱颖而出。在结合多种技术的同时构建小型项目可以帮助你了解如何将它们组合成应用程序。这是一个更密集的方法，但结果是对技术的理解更好。
- en: Feel free to spend some time customizing projects from previous chapters. In
    the final chapter, we are going to create a portfolio to host online. This will
    be the perfect showcase for everything you’ve achieved so far!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 随意花些时间自定义前几章的项目。在最后一章，我们将创建一个在线托管的作品集。这将是你迄今为止所取得成就的完美展示！
- en: 'Part 4: Wrapping Up'
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4部分：总结
- en: The final part brings all the previous topics together. You will learn how to
    optimize Nuxt for a static site purpose and how to deploy to a web host. Then,
    we will look into automating workflows such as the deployment process. This section
    gives you the freedom to customize the output for your personal use and connects
    all previous chapters into a presentable portfolio.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分将所有前面的主题结合起来。你将学习如何优化 Nuxt 以用于静态站点目的，以及如何部署到网络主机。然后，我们将探讨自动化工作流程，如部署过程。本节为你提供了自定义输出的自由，并将所有前面的章节连接成一个可展示的资料库。
- en: 'This part has the following chapter:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 10*](B19563_10.xhtml#_idTextAnchor321), *Building a Portfolio with
    Nuxt.js and Storyblok*'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B19563_10.xhtml#_idTextAnchor321)，*使用 Nuxt.js 和 Storyblok 构建作品集*'
