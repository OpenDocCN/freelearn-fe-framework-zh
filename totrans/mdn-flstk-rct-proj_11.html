<html><head></head><body>
<div id="_idContainer088" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-161"><a id="_idTextAnchor162" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-162" class="calibre5"><a id="_idTextAnchor163" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1">Making Sure Customers Find You with Search Engine Optimization</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">When we optimized the performance of our blog in the previous chapter, you may have noticed that the Lighthouse report also includes a </span><strong class="bold"><span class="kobospan" id="kobo.4.1">Search Engine Optimization</span></strong><span class="kobospan" id="kobo.5.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.6.1">SEO</span></strong><span class="kobospan" id="kobo.7.1">) score, which our</span><a id="_idIndexMarker513" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.8.1"> app scored relatively low on. </span><span class="kobospan" id="kobo.8.2">This score tells us how optimized our app is for being indexed properly and found by search engines such as Google or Bing. </span><span class="kobospan" id="kobo.8.3">After successfully developing a working blog app, of course, we want our blog to be found by users. </span><span class="kobospan" id="kobo.8.4">In this chapter, we are going to learn the basics of SEO and how to optimize the SEO score for our React application. </span><span class="kobospan" id="kobo.8.5">Then, we are going to learn how to create meta tags for easier integration on various social </span><span><span class="kobospan" id="kobo.9.1">media sites.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.10.1">In this chapter, we are going to cover the following </span><span><span class="kobospan" id="kobo.11.1">main topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.12.1">Optimizing an application for </span><span><span class="kobospan" id="kobo.13.1">search engines</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.14.1">Improving social </span><span><span class="kobospan" id="kobo.15.1">media embeds</span></span></li>
</ul>
<h1 id="_idParaDest-163" class="calibre5"><a id="_idTextAnchor164" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.16.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.17.1">Before we start, please install all requirements from </span><a href="B19385_01.xhtml#_idTextAnchor016" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.18.1">Chapter 1</span></em></span></a><em class="italic"><span class="kobospan" id="kobo.19.1">, Preparing For Full-Stack Development</span></em><span class="kobospan" id="kobo.20.1">, and </span><a href="B19385_02.xhtml#_idTextAnchor028" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.21.1">Chapter 2</span></em></span></a><em class="italic"><span class="kobospan" id="kobo.22.1">, Getting to Know Node.js </span></em><span><em class="italic"><span class="kobospan" id="kobo.23.1">and MongoDB</span></em></span><span><span class="kobospan" id="kobo.24.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.25.1">The versions listed in those chapters are the ones used in the book. </span><span class="kobospan" id="kobo.25.2">While installing a newer version should not be an issue, please note that certain steps might work differently on a newer version. </span><span class="kobospan" id="kobo.25.3">If you are having an issue with the code and steps provided in this book, please try using the versions mentioned in </span><em class="italic"><span class="kobospan" id="kobo.26.1">Chapters 1</span></em> <span><span class="kobospan" id="kobo.27.1">and </span></span><span><em class="italic"><span class="kobospan" id="kobo.28.1">2</span></em></span><span><span class="kobospan" id="kobo.29.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.30.1">You can find the code for this chapter on </span><span><span class="kobospan" id="kobo.31.1">GitHub: </span></span><a href="https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch8" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.32.1">https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch8</span></span></a><span><span class="kobospan" id="kobo.33.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.34.1">The CiA video for this chapter can be found </span><span><span class="kobospan" id="kobo.35.1">at: </span></span><a href="https://youtu.be/1xN3l0MMTbY" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.36.1">https://youtu.be/1xN3l0MMTbY</span></span></a></p>
<p class="calibre3"><span class="kobospan" id="kobo.37.1">If you cloned the full repository for the book, Husky may not find the </span><strong class="source-inline"><span class="kobospan" id="kobo.38.1">.git</span></strong><span class="kobospan" id="kobo.39.1"> directory when running </span><strong class="source-inline"><span class="kobospan" id="kobo.40.1">npm install</span></strong><span class="kobospan" id="kobo.41.1">. </span><span class="kobospan" id="kobo.41.2">In that case, just run </span><strong class="source-inline"><span class="kobospan" id="kobo.42.1">git init</span></strong><span class="kobospan" id="kobo.43.1"> in the root of the corresponding </span><span><span class="kobospan" id="kobo.44.1">chapter folder.</span></span></p>
<h1 id="_idParaDest-164" class="calibre5"><a id="_idTextAnchor165" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.45.1">Optimizing an application for search engines</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.46.1">Before we get started optimizing our app for search engines, let’s briefly learn how search engines work. </span><span class="kobospan" id="kobo.46.2">Search engines</span><a id="_idIndexMarker514" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.47.1"> work by storing information about websites in an index. </span><span class="kobospan" id="kobo.47.2">The </span><strong class="bold"><span class="kobospan" id="kobo.48.1">index</span></strong><span class="kobospan" id="kobo.49.1"> contains the</span><a id="_idIndexMarker515" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.50.1"> location, content, and meta information of websites. </span><span class="kobospan" id="kobo.50.2">Adding or updating pages in the index is called indexing and done by a crawler. </span><span class="kobospan" id="kobo.50.3">A </span><strong class="bold"><span class="kobospan" id="kobo.51.1">crawler</span></strong><span class="kobospan" id="kobo.52.1"> is an</span><a id="_idIndexMarker516" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.53.1"> automated software that fetches websites and indexes them. </span><span class="kobospan" id="kobo.53.2">It is called a crawler because it follows further links on the website to find more websites. </span><span class="kobospan" id="kobo.53.3">More advanced crawlers, such as </span><a id="_idIndexMarker517" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.54.1">the </span><strong class="bold"><span class="kobospan" id="kobo.55.1">Googlebot</span></strong><span class="kobospan" id="kobo.56.1">, can also detect whether JavaScript is required to render the contents of a website and even </span><span><span class="kobospan" id="kobo.57.1">render it.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.58.1">The following graphic visualizes how a search engine </span><span><span class="kobospan" id="kobo.59.1">crawler</span></span><span><a id="_idIndexMarker518" class="calibre6 pcalibre1 pcalibre"/></span><span><span class="kobospan" id="kobo.60.1"> works:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer084">
<span class="kobospan" id="kobo.61.1"><img alt="Figure 8.1 – Visualization of how a search engine crawler works" src="image/B19385_08_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.62.1">Figure 8.1 – Visualization of how a search engine crawler works</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.63.1">As we can see, a search crawler has a queue containing URLs that it needs to crawl and index. </span><span class="kobospan" id="kobo.63.2">It then visits the URLs one by one, fetches the HTML and, if it is an advanced crawler, detects whether it needs to execute JavaScript to render the content. </span><span class="kobospan" id="kobo.63.3">In that case, the URL is added to a render queue and the rendered HTML is passed back into the crawler later. </span><span class="kobospan" id="kobo.63.4">Then, the crawler extracts all the links to other pages and adds them to the queue. </span><span class="kobospan" id="kobo.63.5">Finally, the parsed content is added to </span><span><span class="kobospan" id="kobo.64.1">the index.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.65.1">To see whether a website is already indexed by a search engine, most search engines provide a </span><strong class="source-inline"><span class="kobospan" id="kobo.66.1">site:</span></strong><span class="kobospan" id="kobo.67.1"> operator, which can be used to check whether a URL is already indexed by it. </span><span class="kobospan" id="kobo.67.2">For example, </span><strong class="source-inline"><span class="kobospan" id="kobo.68.1">site:wikipedia.org</span></strong><span class="kobospan" id="kobo.69.1"> shows various URLs on Wikipedia that are already indexed. </span><span class="kobospan" id="kobo.69.2">If your website is not indexed yet, you can submit it to tools such as the </span><strong class="bold"><span class="kobospan" id="kobo.70.1">Google Search Console</span></strong><span class="kobospan" id="kobo.71.1">. </span><span class="kobospan" id="kobo.71.2">The </span><a id="_idIndexMarker519" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.72.1">Google Search Console also has a detailed overview of the indexing status and any problems with indexing. </span><span class="kobospan" id="kobo.72.2">However, it is not necessary to submit our site for it to be found, because most search engines automatically crawl the web and will eventually find </span><span><span class="kobospan" id="kobo.73.1">our website.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.74.1">If your website still does not get indexed, this might be because it is improperly configured. </span><span class="kobospan" id="kobo.74.2">First, you need to create a </span><strong class="source-inline"><span class="kobospan" id="kobo.75.1">robots.txt</span></strong><span class="kobospan" id="kobo.76.1"> file</span><a id="_idIndexMarker520" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.77.1"> to specify whether search engines are allowed to crawl parts of your website, and which parts they are allowed </span><span><span class="kobospan" id="kobo.78.1">to crawl.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.79.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.80.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.81.1">robots.txt</span></strong><span class="kobospan" id="kobo.82.1"> should not be used to hide web pages from Google search results. </span><span class="kobospan" id="kobo.82.2">Instead, it is used to reduce traffic from crawlers on unimportant or similar pages. </span><span class="kobospan" id="kobo.82.3">If you want to completely hide web pages from Google search results, either password-protect them, or use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.83.1">noindex</span></strong> <span><span class="kobospan" id="kobo.84.1">meta tag.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.85.1">Next, you need to make sure the contents of your website are visible to the crawler. </span><span class="kobospan" id="kobo.85.2">Server-side rendering can help here by allowing crawlers to view the contents of your website without running JavaScript. </span><span class="kobospan" id="kobo.85.3">Additionally, adding meta information using special HTML tags helps crawlers to get additional information about your website. </span><span class="kobospan" id="kobo.85.4">For small websites, pages need to be linked properly or add a manual sitemap. </span><span class="kobospan" id="kobo.85.5">For larger websites, such as a blog with many posts, a sitemap should always be defined. </span><span class="kobospan" id="kobo.85.6">Finally, having good performance, fast load times, and a good user experience makes your website rank higher on </span><span><span class="kobospan" id="kobo.86.1">search engines.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.87.1">We have already added server-side rendering to speed up crawling by serving content immediately without relying on JavaScript to render it. </span><span class="kobospan" id="kobo.87.2">Now, let’s further optimize our app for search engines. </span><span class="kobospan" id="kobo.87.3">We start by creating a </span><span><strong class="source-inline"><span class="kobospan" id="kobo.88.1">robots.txt</span></strong></span><span><span class="kobospan" id="kobo.89.1"> file.</span></span></p>
<h2 id="_idParaDest-165" class="calibre7"><a id="_idTextAnchor166" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.90.1">Creating a robots.txt file</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.91.1">First, let’s ensure that </span><a id="_idIndexMarker521" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.92.1">crawlers are explicitly allowed to access our app and index </span><a id="_idIndexMarker522" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.93.1">all pages on it. </span><span class="kobospan" id="kobo.93.2">To do so, we need to create a </span><strong class="source-inline"><span class="kobospan" id="kobo.94.1">robots.txt</span></strong><span class="kobospan" id="kobo.95.1"> file, which crawlers will read to find out which pages they are allowed to access (if any). </span><span class="kobospan" id="kobo.95.2">Follow these steps to create a </span><strong class="source-inline"><span class="kobospan" id="kobo.96.1">robots.txt</span></strong><span class="kobospan" id="kobo.97.1"> file that allows access for all crawlers to </span><span><span class="kobospan" id="kobo.98.1">all pages:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.99.1">Copy the </span><strong class="source-inline1"><span class="kobospan" id="kobo.100.1">ch7</span></strong><span class="kobospan" id="kobo.101.1"> folder to a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.102.1">ch8</span></strong><span class="kobospan" id="kobo.103.1"> folder, </span><span><span class="kobospan" id="kobo.104.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.105.1">$ cp -R ch7 ch8</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.106.1">Open the </span><strong class="source-inline1"><span class="kobospan" id="kobo.107.1">ch8</span></strong><span class="kobospan" id="kobo.108.1"> folder in </span><span><span class="kobospan" id="kobo.109.1">VS Code.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.110.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.111.1">public/robots.txt</span></strong><span class="kobospan" id="kobo.112.1"> file in the root of </span><span><span class="kobospan" id="kobo.113.1">our project.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.114.1">Open the newly created file and enter the following contents to allow all crawlers to index </span><span><span class="kobospan" id="kobo.115.1">all pages:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.116.1">
User-agent: *
Allow: /</span></pre><p class="calibre3"><span class="kobospan" id="kobo.117.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.118.1">robots.txt</span></strong><span class="kobospan" id="kobo.119.1"> works by defining blocks, each block being defined by matching a user agent. </span><span class="kobospan" id="kobo.119.2">The user agent can match various crawlers, such as </span><strong class="source-inline"><span class="kobospan" id="kobo.120.1">Googlebot</span></strong><span class="kobospan" id="kobo.121.1"> for Google, or you can use </span><strong class="source-inline"><span class="kobospan" id="kobo.122.1">*</span></strong><span class="kobospan" id="kobo.123.1"> to match all crawlers. </span><span class="kobospan" id="kobo.123.2">After the user agent, one or multiple </span><strong class="source-inline"><span class="kobospan" id="kobo.124.1">Allow</span></strong><span class="kobospan" id="kobo.125.1"> and/or </span><strong class="source-inline"><span class="kobospan" id="kobo.126.1">Disallow</span></strong><span class="kobospan" id="kobo.127.1"> statements can be made, that decide which paths a crawler is allowed or not allowed to access. </span><span class="kobospan" id="kobo.127.2">In our case, we are allowing access to all paths. </span><span class="kobospan" id="kobo.127.3">Additionally, a </span><strong class="source-inline"><span class="kobospan" id="kobo.128.1">Sitemap</span></strong><span class="kobospan" id="kobo.129.1"> can be specified, but we’ll see more on that later in the </span><em class="italic"><span class="kobospan" id="kobo.130.1">Creating a </span></em><span><em class="italic"><span class="kobospan" id="kobo.131.1">sitemap</span></em></span><span><span class="kobospan" id="kobo.132.1"> subsection.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.133.1">Open a Terminal pane and start the frontend by running the </span><span><span class="kobospan" id="kobo.134.1">following command:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.135.1">$ npm run dev</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.136.1">Open another Terminal pane and start the backend by running the </span><span><span class="kobospan" id="kobo.137.1">following commands:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.138.1">$ cd backend</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.139.1">$ npm run dev</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.140.1">Go to </span><strong class="source-inline1"><span class="kobospan" id="kobo.141.1">http://localhost:5173/robots.txt</span></strong><span class="kobospan" id="kobo.142.1"> in your browser to see the </span><strong class="source-inline1"><span class="kobospan" id="kobo.143.1">robots.txt</span></strong><span class="kobospan" id="kobo.144.1"> file</span><a id="_idIndexMarker523" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.145.1"> being </span><a id="_idIndexMarker524" class="calibre6 pcalibre1 pcalibre"/><span><span class="kobospan" id="kobo.146.1">served properly.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.147.1">Now that we have successfully allowed crawlers to access our app, we should improve our URL structure. </span><span class="kobospan" id="kobo.147.2">Let’s do that by creating separate pages for </span><span><span class="kobospan" id="kobo.148.1">each post.</span></span></p>
<h2 id="_idParaDest-166" class="calibre7"><a id="_idTextAnchor167" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.149.1">Creating separate pages for posts</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.150.1">At the moment, it is not</span><a id="_idIndexMarker525" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.151.1"> possible to view only a single post in our blog app, we can only view the list of all posts. </span><span class="kobospan" id="kobo.151.2">That is not good for SEO, as it means a search engine will always link to the index page, which might already contain different articles than what the user was searching for. </span><span class="kobospan" id="kobo.151.3">Let’s refactor our app a bit to only show post titles and authors on the main page, and then link to separate pages for each </span><span><span class="kobospan" id="kobo.152.1">blog post:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.153.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.154.1">src/components/Post.jsx</span></strong><span class="kobospan" id="kobo.155.1"> to allow displaying a single full post while displaying a smaller version of the post in the list, with a link to the full version. </span><span class="kobospan" id="kobo.155.2">First, we import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.156.1">Link</span></strong><span class="kobospan" id="kobo.157.1"> component </span><span><span class="kobospan" id="kobo.158.1">from </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.159.1">react-router-dom</span></strong></span><span><span class="kobospan" id="kobo.160.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.161.1">
import { Link } from 'react-router-dom'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.162.1">Then, we add an </span><strong class="source-inline1"><span class="kobospan" id="kobo.163.1">_id</span></strong><span class="kobospan" id="kobo.164.1"> prop and a </span><strong class="source-inline1"><span class="kobospan" id="kobo.165.1">fullPost</span></strong><span class="kobospan" id="kobo.166.1"> prop to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.167.1">Post</span></strong><span class="kobospan" id="kobo.168.1"> component. </span><span class="kobospan" id="kobo.168.2">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.169.1">fullPost</span></strong><span class="kobospan" id="kobo.170.1"> prop will be set to </span><strong class="source-inline1"><span class="kobospan" id="kobo.171.1">false</span></strong><span class="kobospan" id="kobo.172.1"> by default (when displayed in the post list) and set to </span><strong class="source-inline1"><span class="kobospan" id="kobo.173.1">true</span></strong><span class="kobospan" id="kobo.174.1"> when using it in the </span><span><span class="kobospan" id="kobo.175.1">single-post page:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.176.1">
export function Post({
  title,
  contents,
  author,
</span><strong class="bold1"><span class="kobospan1" id="kobo.177.1">  _id,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.178.1">  fullPost = false,</span></strong><span class="kobospan1" id="kobo.179.1">
}) {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.180.1">We make some adjustments to the component to show a link to the single-post page if we are not on a single-post </span><span><span class="kobospan" id="kobo.181.1">page yet:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.182.1">      {fullPost ? </span><span class="kobospan1" id="kobo.182.2">(</span></strong><span class="kobospan1" id="kobo.183.1">
        &lt;h3&gt;{title}&lt;/h3&gt;
</span><strong class="bold1"><span class="kobospan1" id="kobo.184.1">      ) : (</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.185.1">        &lt;Link to={`/posts/${_id}`}&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.186.1">          &lt;h3&gt;{title}&lt;/h3&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.187.1">        &lt;/Link&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.188.1">      )}</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.189.1">Additionally, we </span><a id="_idIndexMarker526" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.190.1">only show the contents of the blog post on a single-post page, and adjust the spacing of the author </span><span><span class="kobospan" id="kobo.191.1">info accordingly:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.192.1">
      </span><strong class="bold1"><span class="kobospan1" id="kobo.193.1">{fullPost &amp;&amp;</span></strong><span class="kobospan1" id="kobo.194.1"> &lt;div&gt;{contents}&lt;/div&gt;</span><strong class="bold1"><span class="kobospan1" id="kobo.195.1">}</span></strong><span class="kobospan1" id="kobo.196.1">
      {author &amp;&amp; (
        &lt;em&gt;
          </span><strong class="bold1"><span class="kobospan1" id="kobo.197.1">{fullPost &amp;&amp;</span></strong><span class="kobospan1" id="kobo.198.1"> &lt;br /&gt;</span><strong class="bold1"><span class="kobospan1" id="kobo.199.1">}</span></strong><span class="kobospan1" id="kobo.200.1">
          Written by &lt;User id={author} /&gt;
        &lt;/em&gt;
      )}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.201.1">Adjust the prop types to add the newly </span><span><span class="kobospan" id="kobo.202.1">defined props:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.203.1">
Post.propTypes = {
  title: PropTypes.string.isRequired,
  contents: PropTypes.string,
  author: PropTypes.string,
</span><strong class="bold1"><span class="kobospan1" id="kobo.204.1">  _id: PropTypes.string.isRequired,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.205.1">  fullPost: PropTypes.bool,</span></strong><span class="kobospan1" id="kobo.206.1">
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.207.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.208.1">src/api/posts.js</span></strong><span class="kobospan" id="kobo.209.1"> and add a new function to get a single post </span><span><span class="kobospan" id="kobo.210.1">by </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.211.1">id</span></strong></span><span><span class="kobospan" id="kobo.212.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.213.1">
export const getPostById = async (postId) =&gt; {
  const res = await fetch(`${import.meta.env.VITE_BACKEND_URL}/posts/${postId}`)
  return await res.json()
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.214.1">Create a</span><a id="_idIndexMarker527" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.215.1"> new </span><strong class="source-inline1"><span class="kobospan" id="kobo.216.1">src/pages/ViewPost.jsx</span></strong><span class="kobospan" id="kobo.217.1"> file, and start by importing all the components and functions that we are going </span><span><span class="kobospan" id="kobo.218.1">to need:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.219.1">
import { Link } from 'react-router-dom'
import PropTypes from 'prop-types'
import { useQuery } from '@tanstack/react-query'
import { Header } from '../components/Header.jsx'
import { Post } from '../components/Post.jsx'
import { getPostById } from '../api/posts.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.220.1">Then, define a component that accepts a </span><strong class="source-inline1"><span class="kobospan" id="kobo.221.1">postId</span></strong> <span><span class="kobospan" id="kobo.222.1">as props:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.223.1">
export function ViewPost({ postId }) {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.224.1">In the component, we use a query hook to fetch a single post </span><span><span class="kobospan" id="kobo.225.1">by </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.226.1">id</span></strong></span><span><span class="kobospan" id="kobo.227.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.228.1">
  const postQuery = useQuery({
    queryKey: ['post', postId],
    queryFn: () =&gt; getPostById(postId),
  })
  const post = postQuery.data</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.229.1">Next, render the header and a link back to the </span><span><span class="kobospan" id="kobo.230.1">main page:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.231.1">
  return (
    &lt;div style={{ padding: 8 }}&gt;
      &lt;Header /&gt;
      &lt;br /&gt;
      &lt;hr /&gt;
      &lt;Link to='/'&gt;Back to main page&lt;/Link&gt;
      &lt;br /&gt;
      &lt;hr /&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.232.1">Then, if we</span><a id="_idIndexMarker528" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.233.1"> managed to fetch a post with the given ID, render a post with the </span><strong class="source-inline1"><span class="kobospan" id="kobo.234.1">fullPost</span></strong><span class="kobospan" id="kobo.235.1"> prop set. </span><span class="kobospan" id="kobo.235.2">Otherwise, we show a </span><strong class="source-inline1"><span class="kobospan" id="kobo.236.1">not </span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.237.1">found</span></strong></span><span><span class="kobospan" id="kobo.238.1"> message:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.239.1">
      {post ? </span><span class="kobospan1" id="kobo.239.2">&lt;Post {...post} fullPost /&gt; : `Post with id ${postId} not found.`}
    &lt;/div&gt;
  )
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.240.1">Lastly, define the prop types for the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.241.1">ViewPost</span></strong></span><span><span class="kobospan" id="kobo.242.1"> component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.243.1">
ViewPost.propTypes = {
  postId: PropTypes.string.isRequired,
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.244.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.245.1">src/routes.jsx</span></strong><span class="kobospan" id="kobo.246.1"> and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.247.1">ViewPost</span></strong><span class="kobospan" id="kobo.248.1"> component and the </span><strong class="source-inline1"><span class="kobospan" id="kobo.249.1">getPostById</span></strong><span class="kobospan" id="kobo.250.1"> function (for </span><span><span class="kobospan" id="kobo.251.1">server-side rendering):</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.252.1">import { ViewPost } from './pages/ViewPost.jsx'</span></strong><span class="kobospan1" id="kobo.253.1">
import { getPosts</span><strong class="bold1"><span class="kobospan1" id="kobo.254.1">, getPostById</span></strong><span class="kobospan1" id="kobo.255.1"> } from './api/posts.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.256.1">Define a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.257.1">/posts/:postId</span></strong><span class="kobospan" id="kobo.258.1"> route for viewing a single post. </span><span class="kobospan" id="kobo.258.2">In the loader, we fetch the single blog post and an author, if it has one. </span><span class="kobospan" id="kobo.258.3">We then return the dehydrated</span><a id="_idIndexMarker529" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.259.1"> state and the </span><span><span class="kobospan" id="kobo.260.1">post ID:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.261.1">
  {
    path: '/posts/:postId',
    loader: async ({ params }) =&gt; {
      const postId = params.postId
      const queryClient = new QueryClient()
      const post = await getPostById(postId)
      await queryClient.prefetchQuery({
        queryKey: ['post', postId],
        queryFn: () =&gt; post,
      })
      if (post?.author) {
        await queryClient.prefetchQuery({
          queryKey: ['users', post.author],
          queryFn: () =&gt;
            getUserInfo(post.author),
        })
      }
      return { dehydratedState: dehydrate(queryClient), postId }
    },</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.262.1">Define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.263.1">Component</span></strong><span class="kobospan" id="kobo.264.1"> method for the route, where we get </span><strong class="source-inline1"><span class="kobospan" id="kobo.265.1">dehydratedState</span></strong><span class="kobospan" id="kobo.266.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.267.1">postId</span></strong><span class="kobospan" id="kobo.268.1"> and pass</span><a id="_idIndexMarker530" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.269.1"> them on to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.270.1">ViewPost</span></strong><span class="kobospan" id="kobo.271.1"> component, </span><span><span class="kobospan" id="kobo.272.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.273.1">
    Component() {
      const { dehydratedState, postId } = useLoaderData()
      return (
        &lt;HydrationBoundary state={dehydratedState}&gt;
          &lt;ViewPost postId={postId} /&gt;
        &lt;/HydrationBoundary&gt;
      )
    },
  },</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.274.1">Go to </span><strong class="source-inline1"><span class="kobospan" id="kobo.275.1">http://localhost:5173/</span></strong><span class="kobospan" id="kobo.276.1"> in your browser and you will see that all blog posts in the list now have a link in their title. </span><span class="kobospan" id="kobo.276.2">Click on the link to see the full blog post, as shown in the </span><span><span class="kobospan" id="kobo.277.1">following screenshot:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer085">
<span class="kobospan" id="kobo.278.1"><img alt="Figure 8.2 – Viewing a single blog post on a separate page" src="image/B19385_08_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.279.1">Figure 8.2 – Viewing a single blog post on a separate page</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.280.1">Now our blog</span><a id="_idIndexMarker531" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.281.1"> app is already much more organized, as we do not see the full contents of all blog posts on the main page. </span><span class="kobospan" id="kobo.281.2">We only see the title and author now and can then decide whether the article is interesting to us or not. </span><span class="kobospan" id="kobo.281.3">Furthermore, a search engine can provide separate entries for each blog post, making it easier to find posts on our app. </span><span class="kobospan" id="kobo.281.4">There is still room for improvement with the URL structure though, as it currently only contains the post ID. </span><span class="kobospan" id="kobo.281.5">Let’s introduce more meaningful URLs in the </span><span><span class="kobospan" id="kobo.282.1">next step.</span></span></p>
<h2 id="_idParaDest-167" class="calibre7"><a id="_idTextAnchor168" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.283.1">Creating meaningful URLs (slugs)</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.284.1">Websites often put</span><a id="_idIndexMarker532" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.285.1"> keywords in the URLs to make it easier for users to see what they will be opening just by looking at the URL. </span><span class="kobospan" id="kobo.285.2">Keywords in URLs are also a ranking factor for search engines, albeit a not-so-strong one. </span><span class="kobospan" id="kobo.285.3">The strongest one is always good content. </span><span class="kobospan" id="kobo.285.4">Nevertheless, having a good URL structure improves the user experience. </span><span class="kobospan" id="kobo.285.5">For example, if the link is </span><strong class="source-inline"><span class="kobospan" id="kobo.286.1">/posts/64a42dfd6a7b7ab47009f5e3/making-sure-customers-find-you-with-search-engine-optimization</span></strong><span class="kobospan" id="kobo.287.1"> instead of just </span><strong class="source-inline"><span class="kobospan" id="kobo.288.1">/posts/64a42dfd6a7b7ab47009f5e3</span></strong><span class="kobospan" id="kobo.289.1">, it is already clear from the URL alone what content they will find on the page. </span><span class="kobospan" id="kobo.289.2">Such keywords in the URL are called a URL slug, named after “slugs” in journalism, which refers to using short descriptions of articles as internal names. </span><span class="kobospan" id="kobo.289.3">Let’s</span><a id="_idIndexMarker533" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.290.1"> get started introducing slugs on our </span><span><span class="kobospan" id="kobo.291.1">post pages:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.292.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.293.1">src/routes.jsx</span></strong><span class="kobospan" id="kobo.294.1"> and adjust the path to allow for optionally including </span><span><span class="kobospan" id="kobo.295.1">a slug:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.296.1">
    path: '/posts/:postId</span><strong class="bold1"><span class="kobospan1" id="kobo.297.1">/:slug?</span></strong><span class="kobospan1" id="kobo.298.1">',</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.299.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.300.1">We are not doing any checks on whether the slug is correct or not. </span><span class="kobospan" id="kobo.300.2">In fact, this is not really necessary, and many pages do not do this. </span><span class="kobospan" id="kobo.300.3">As long as we have a correct ID, we can render the blog post. </span><span class="kobospan" id="kobo.300.4">We only need to make sure that the links to the page all include the correct slug. </span><span class="kobospan" id="kobo.300.5">However, we could additionally add a </span><strong class="source-inline1"><span class="kobospan" id="kobo.301.1">&lt;link&gt;</span></strong><span class="kobospan" id="kobo.302.1"> element with the </span><strong class="source-inline1"><span class="kobospan" id="kobo.303.1">rel="canonical"</span></strong><span class="kobospan" id="kobo.304.1"> attribute to a page, specifying the canonical page with the correct slug. </span><span class="kobospan" id="kobo.304.2">This would tell crawlers not to index duplicate pages when incorrect slugs </span><span><span class="kobospan" id="kobo.305.1">are used.</span></span></p>
<ol class="calibre15">
<li value="2" class="calibre11"><span class="kobospan" id="kobo.306.1">In the root of our project, install the </span><strong class="source-inline1"><span class="kobospan" id="kobo.307.1">slug</span></strong><span class="kobospan" id="kobo.308.1"> npm package, which contains a function to properly slugify </span><span><span class="kobospan" id="kobo.309.1">a title:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.310.1">$ npm install slug@8.2.3</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.311.1">This package already handles unicode and returns URL-safe strings. </span><span class="kobospan" id="kobo.311.2">So, we do not need to worry about sanitizing the </span><strong class="source-inline"><span class="kobospan" id="kobo.312.1">title</span></strong> <span><span class="kobospan" id="kobo.313.1">string ourselves.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.314.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.315.1">src/components/Post.jsx</span></strong><span class="kobospan" id="kobo.316.1"> and import the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.317.1">slug</span></strong></span><span><span class="kobospan" id="kobo.318.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.319.1">
import slug from 'slug'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.320.1">Then, adjust the link to the blog post by adding the slug, </span><span><span class="kobospan" id="kobo.321.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.322.1">
        &lt;Link to={`/posts/${_id}</span><strong class="bold1"><span class="kobospan1" id="kobo.323.1">/${slug(title)}</span></strong><span class="kobospan1" id="kobo.324.1">`}&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.325.1">Now, when we open a link from the list, the URL will look </span><span><span class="kobospan" id="kobo.326.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.327.1">
http://localhost:5173/posts/64a42dfd6a7b7ab47009f5e3/making-sure-customers-find-you-with-search-engine-optimization</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.328.1">Now we have </span><a id="_idIndexMarker534" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.329.1">human readable URLs for our blog posts! </span><span class="kobospan" id="kobo.329.2">However, you might have noticed that the title is still </span><strong class="bold"><span class="kobospan" id="kobo.330.1">Vite + React</span></strong><span class="kobospan" id="kobo.331.1"> on all pages of our app. </span><span class="kobospan" id="kobo.331.2">Let’s change that now by introducing dynamic titles and including the blog post title in the </span><span><span class="kobospan" id="kobo.332.1">page title.</span></span></p>
<h2 id="_idParaDest-168" class="calibre7"><a id="_idTextAnchor169" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.333.1">Adding dynamic titles</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.334.1">The title of a page</span><a id="_idIndexMarker535" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.335.1"> is even more important for SEO than keywords in the URL, as that is the title that will be shown in the search results in most cases. </span><span class="kobospan" id="kobo.335.2">So, we should choose our title wisely, and if we have dynamic content (like in our blog), we should also dynamically adjust the title to fit the content. </span><span class="kobospan" id="kobo.335.3">We can use the React Helmet library to facilitate changes in the </span><strong class="source-inline"><span class="kobospan" id="kobo.336.1">&lt;head&gt;</span></strong><span class="kobospan" id="kobo.337.1"> section of the HTML document. </span><span class="kobospan" id="kobo.337.2">This library allows us to render a special </span><strong class="source-inline"><span class="kobospan" id="kobo.338.1">Helmet</span></strong><span class="kobospan" id="kobo.339.1"> component. </span><span class="kobospan" id="kobo.339.2">The children of this component will replace existing tags in the </span><strong class="source-inline"><span class="kobospan" id="kobo.340.1">&lt;head&gt;</span></strong><span class="kobospan" id="kobo.341.1"> section. </span><span class="kobospan" id="kobo.341.2">Follow these steps to use React Helmet to dynamically set </span><span><span class="kobospan" id="kobo.342.1">the title:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.343.1">First of all, let’s change the general title of our app, as it is still </span><strong class="bold"><span class="kobospan" id="kobo.344.1">Vite + React</span></strong><span class="kobospan" id="kobo.345.1">. </span><span class="kobospan" id="kobo.345.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.346.1">index.html</span></strong><span class="kobospan" id="kobo.347.1"> in the root of our project and change the title. </span><span class="kobospan" id="kobo.347.2">We are going to call our blog app </span><strong class="source-inline1"><span class="kobospan" id="kobo.348.1">Full-Stack </span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.349.1">React Blog</span></strong></span><span><span class="kobospan" id="kobo.350.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.351.1">
    &lt;title&gt;</span><strong class="bold1"><span class="kobospan1" id="kobo.352.1">Full-Stack React Blog</span></strong><span class="kobospan1" id="kobo.353.1">&lt;/title&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.354.1">In the root of our project, install the </span><strong class="source-inline1"><span class="kobospan" id="kobo.355.1">react-helmet-async</span></strong><span class="kobospan" id="kobo.356.1"> dependency to be able to dynamically change </span><span><span class="kobospan" id="kobo.357.1">the title:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.358.1">$ npm install react-helmet-async@1.3.0</span></strong></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.359.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.360.1">React Helmet Async is a fork of the original React Helmet that adds support for newer </span><span><span class="kobospan" id="kobo.361.1">React versions.</span></span></p>
<ol class="calibre15">
<li value="3" class="calibre11"><span class="kobospan" id="kobo.362.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.363.1">src/pages/ViewPost.jsx</span></strong><span class="kobospan" id="kobo.364.1"> and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.365.1">Helmet</span></strong><span class="kobospan" id="kobo.366.1"> component </span><span><span class="kobospan" id="kobo.367.1">from </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.368.1">react-helmet-async</span></strong></span><span><span class="kobospan" id="kobo.369.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.370.1">
import { Helmet } from 'react-helmet-async'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.371.1">Render </span><a id="_idIndexMarker536" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.372.1">the </span><strong class="source-inline1"><span class="kobospan" id="kobo.373.1">Helmet</span></strong><span class="kobospan" id="kobo.374.1"> component and define the </span><strong class="source-inline1"><span class="kobospan" id="kobo.375.1">&lt;title&gt;</span></strong><span class="kobospan" id="kobo.376.1"> tag inside it, </span><span><span class="kobospan" id="kobo.377.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.378.1">
  return (
    &lt;div style={{ padding: 8 }}&gt;
</span><strong class="bold1"><span class="kobospan1" id="kobo.379.1">      {post &amp;&amp; (</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.380.1">        &lt;Helmet&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.381.1">          &lt;title&gt;{post.title} | Full-Stack React Blog&lt;/title&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.382.1">        &lt;/Helmet&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.383.1">      )}</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.384.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.385.1">src/pages/Blog.jsx</span></strong><span class="kobospan" id="kobo.386.1"> and </span><span><span class="kobospan" id="kobo.387.1">import </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.388.1">Helmet</span></strong></span><span><span class="kobospan" id="kobo.389.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.390.1">
import { Helmet } from 'react-helmet-async'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.391.1">Then, reset the title to </span><strong class="source-inline1"><span class="kobospan" id="kobo.392.1">Full-Stack React Blog</span></strong><span class="kobospan" id="kobo.393.1"> in the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.394.1">Blog</span></strong></span><span><span class="kobospan" id="kobo.395.1"> component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.396.1">
  return (
    &lt;div style={{ padding: 8 }}&gt;
</span><strong class="bold1"><span class="kobospan1" id="kobo.397.1">      &lt;Helmet&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.398.1">        &lt;title&gt;Full-Stack React Blog&lt;/title&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.399.1">      &lt;/Helmet&gt;</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.400.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.401.1">src/App.jsx</span></strong><span class="kobospan" id="kobo.402.1"> and import </span><span><span class="kobospan" id="kobo.403.1">the </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.404.1">HelmetProvider</span></strong></span><span><span class="kobospan" id="kobo.405.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.406.1">
import { HelmetProvider } from 'react-helmet-async'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.407.1">Then, adjust the </span><strong class="source-inline1"><span class="kobospan" id="kobo.408.1">App</span></strong><span class="kobospan" id="kobo.409.1"> component to </span><span><span class="kobospan" id="kobo.410.1">render </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.411.1">HelmetProvider</span></strong></span><span><span class="kobospan" id="kobo.412.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.413.1">
export function App({ children }) {
  return (
</span><strong class="bold1"><span class="kobospan1" id="kobo.414.1">    &lt;HelmetProvider&gt;</span></strong><span class="kobospan1" id="kobo.415.1">
      &lt;QueryClientProvider client={queryClient}&gt;
        &lt;AuthContextProvider&gt;
          {children}
        &lt;/AuthContextProvider&gt;
      &lt;/QueryClientProvider&gt;
</span><strong class="bold1"><span class="kobospan1" id="kobo.416.1">    &lt;/HelmetProvider&gt;</span></strong><span class="kobospan1" id="kobo.417.1">
  )
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.418.1">Click on a</span><a id="_idIndexMarker537" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.419.1"> single post in the app and you will see that the title now updates to include the </span><span><span class="kobospan" id="kobo.420.1">post title!</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.421.1">Now that we have successfully set a dynamic title, let’s pay some attention to other important information in the </span><strong class="source-inline"><span class="kobospan" id="kobo.422.1">&lt;head&gt;</span></strong><span class="kobospan" id="kobo.423.1"> section, the </span><span><strong class="bold"><span class="kobospan" id="kobo.424.1">meta tags</span></strong></span><span><span class="kobospan" id="kobo.425.1">.</span></span></p>
<h2 id="_idParaDest-169" class="calibre7"><a id="_idTextAnchor170" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.426.1">Adding other meta tags</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.427.1">Meta tags, as the </span><a id="_idIndexMarker538" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.428.1">name</span><a id="_idIndexMarker539" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.429.1"> tells us, contain meta information about a page. </span><span class="kobospan" id="kobo.429.2">Besides the title, we can set meta information such as a short description, or information on how the browser should render a website. </span><span class="kobospan" id="kobo.429.3">In this section, we will cover the most important SEO-relevant meta tags, starting with the description </span><span><span class="kobospan" id="kobo.430.1">meta tag.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.431.1">Description meta tag</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.432.1">The description meta tag</span><a id="_idIndexMarker540" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.433.1"> contains a short description of the contents of the </span><a id="_idIndexMarker541" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.434.1">page. </span><span class="kobospan" id="kobo.434.2">Similarly to the title tag, we can also dynamically set this tag, </span><span><span class="kobospan" id="kobo.435.1">as follows:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.436.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.437.1">src/pages/Blog.jsx</span></strong><span class="kobospan" id="kobo.438.1"> and add the following generic description </span><strong class="source-inline1"><span class="kobospan" id="kobo.439.1">&lt;</span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.440.1">meta&gt;</span></strong></span><span><span class="kobospan" id="kobo.441.1"> tag:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.442.1">
      &lt;Helmet&gt;
        &lt;title&gt;Full-Stack React Blog&lt;/title&gt;
</span><strong class="bold1"><span class="kobospan1" id="kobo.443.1">        &lt;meta</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.444.1">          name='description'</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.445.1">          content='A blog full of articles about full-stack React development.'</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.446.1">        /&gt;</span></strong><span class="kobospan1" id="kobo.447.1">
      &lt;/Helmet&gt;</span></pre><p class="calibre3"><span class="kobospan" id="kobo.448.1">Now, let’s add a dynamic meta description tag for each blog post. </span><span class="kobospan" id="kobo.448.2">The meta description should have between 50 and 160 characters, and since we do not have a short summary of our blog posts, let’s just use the full contents and truncate them after 160 characters. </span><span class="kobospan" id="kobo.448.3">Of course, it would be even better to let authors add a short summary when creating posts, but for simplicity, we just truncate the </span><span><span class="kobospan" id="kobo.449.1">description here.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.450.1">Edit the </span><strong class="source-inline1"><span class="kobospan" id="kobo.451.1">src/pages/ViewPost.jsx</span></strong><span class="kobospan" id="kobo.452.1"> file and </span><a id="_idIndexMarker542" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.453.1">define a simple function to truncate</span><a id="_idIndexMarker543" class="calibre6 pcalibre1 pcalibre"/> <span><span class="kobospan" id="kobo.454.1">a string:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.455.1">
function truncate(str, max = 160) {
  if (!str) return str
  if (str.length &gt; max) {
    return str.slice(0, max - 3) + '...'
</span><span class="kobospan1" id="kobo.455.2">  } else {
    return str
  }
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.456.1">We limit the string to 160 characters, and if it’s above 160, we truncate it to 157 characters and add three dots at </span><span><span class="kobospan" id="kobo.457.1">the end.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.458.1">Add the </span><a id="_idIndexMarker544" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.459.1">truncated </span><a id="_idIndexMarker545" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.460.1">content as a meta description tag to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.461.1">Helmet</span></strong><span class="kobospan" id="kobo.462.1"> component, </span><span><span class="kobospan" id="kobo.463.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.464.1">
      {post &amp;&amp; (
        &lt;Helmet&gt;
          &lt;title&gt;{post.title} | Full-Stack React Blog&lt;/title&gt;
</span><strong class="bold1"><span class="kobospan1" id="kobo.465.1">        &lt;meta name='description' content={truncate(post.contents)} /&gt;</span></strong></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.466.1">After adding the description meta tag, let’s learn about other meta tags that could </span><span><span class="kobospan" id="kobo.467.1">be used.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.468.1">Robots meta tag</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.469.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.470.1">robots</span></strong><span class="kobospan" id="kobo.471.1"> meta tag</span><a id="_idIndexMarker546" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.472.1"> tells crawlers whether and how they should crawl web pages. </span><span class="kobospan" id="kobo.472.2">It</span><a id="_idIndexMarker547" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.473.1"> can be used in addition to </span><strong class="source-inline"><span class="kobospan" id="kobo.474.1">robots.txt</span></strong><span class="kobospan" id="kobo.475.1">, but we should only use it if we want to dynamically restrict the way a certain page is crawled. </span><span class="kobospan" id="kobo.475.2">It looks </span><span><span class="kobospan" id="kobo.476.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.477.1">
&lt;meta name="robots" content="index, follow"&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.478.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.479.1">index</span></strong><span class="kobospan" id="kobo.480.1"> keyword tells crawlers to index the page, the </span><strong class="source-inline"><span class="kobospan" id="kobo.481.1">follow</span></strong><span class="kobospan" id="kobo.482.1"> keyword tells crawlers to crawl further links on the page. </span><span class="kobospan" id="kobo.482.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.483.1">index</span></strong><span class="kobospan" id="kobo.484.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.485.1">follow</span></strong><span class="kobospan" id="kobo.486.1"> keywords can be toggled off by using </span><strong class="source-inline"><span class="kobospan" id="kobo.487.1">noindex</span></strong><span class="kobospan" id="kobo.488.1"> and </span><span><strong class="source-inline"><span class="kobospan" id="kobo.489.1">nofollow</span></strong></span><span><span class="kobospan" id="kobo.490.1">, respectively.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.491.1">Viewport meta tag</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.492.1">Another important </span><a id="_idIndexMarker548" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.493.1">meta tag to</span><a id="_idIndexMarker549" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.494.1"> add is the viewport tag, which tells the browser (and crawlers) that your website is mobile friendly. </span><span class="kobospan" id="kobo.494.2">See the following example of how the meta tag affects how pages are rendered </span><span><span class="kobospan" id="kobo.495.1">on mobile:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer086">
<span class="kobospan" id="kobo.496.1"><img alt="Figure 8.3 – A blog post rendering before and after adding the viewport meta tag" src="image/B19385_08_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.497.1">Figure 8.3 – A blog post rendering before and after adding the viewport meta tag</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.498.1">Vite already </span><a id="_idIndexMarker550" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.499.1">added this meta tag automatically for us in the </span><strong class="source-inline"><span class="kobospan" id="kobo.500.1">index.html</span></strong><span class="kobospan" id="kobo.501.1"> template</span><a id="_idIndexMarker551" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.502.1"> it provided. </span><span class="kobospan" id="kobo.502.2">You can see it by looking at the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.503.1">index.html</span></strong></span><span><span class="kobospan" id="kobo.504.1"> file:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.505.1">
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.506.1">After learning about the viewport tag, we continue by learning about the charset </span><span><span class="kobospan" id="kobo.507.1">meta tag.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.508.1">Charset meta tag</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.509.1">The charset meta tag</span><a id="_idIndexMarker552" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.510.1"> tells the browser and crawlers about the character </span><a id="_idIndexMarker553" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.511.1">encoding of the web page. </span><span class="kobospan" id="kobo.511.2">Usually, you want to set this to UTF-8 to ensure all Unicode characters are rendered properly. </span><span class="kobospan" id="kobo.511.3">Again, Vite already added this meta tag automatically </span><span><span class="kobospan" id="kobo.512.1">for us:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.513.1">
&lt;meta charset="UTF-8" /&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.514.1">Now that we have learned about the relevant meta tags, let’s move on to creating a sitemap, which helps crawlers find all the pages on our app </span><span><span class="kobospan" id="kobo.515.1">more easily.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.516.1">Other relevant meta information</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.517.1">There is</span><a id="_idIndexMarker554" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.518.1"> additional meta information that can be relevant for a website, such as setting the language in the </span><strong class="source-inline"><span class="kobospan" id="kobo.519.1">&lt;html&gt;</span></strong><span class="kobospan" id="kobo.520.1"> tag, </span><span><span class="kobospan" id="kobo.521.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.522.1">
&lt;html lang="en"&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.523.1">Setting a favicon also improves the search snippet, which is what users see when deciding whether they should click on </span><span><span class="kobospan" id="kobo.524.1">a link.</span></span></p>
<h2 id="_idParaDest-170" class="calibre7"><a id="_idTextAnchor171" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.525.1">Creating a sitemap</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.526.1">A sitemap </span><a id="_idIndexMarker555" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.527.1">contains a</span><a id="_idIndexMarker556" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.528.1"> list of URLs that are part of an app, so that crawlers can easily detect new content and crawl the app more efficiently. </span><span class="kobospan" id="kobo.528.2">It also makes sure that all content is found, which is especially important for content-based apps with a large number of pages/posts. </span><span class="kobospan" id="kobo.528.3">Usually, sitemaps are provided in XML format. </span><span class="kobospan" id="kobo.528.4">They are not mandatory for SEO, but will make it easier and faster for crawlers to pick up content on your app. </span><span class="kobospan" id="kobo.528.5">As we have dynamic content on our blog app, we should also create a dynamic sitemap. </span><span class="kobospan" id="kobo.528.6">Follow these</span><a id="_idIndexMarker557" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.529.1"> steps to create a dynamic sitemap for our </span><span><span class="kobospan" id="kobo.530.1">blog app:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.531.1">First, we are going to need a base URL for our (deployed) frontend to prefix all paths on our sitemap with. </span><span class="kobospan" id="kobo.531.2">For now, we are simply going to set this to our localhost URL, but in production, this environment variable should be changed to the proper base URL of the app. </span><span class="kobospan" id="kobo.531.3">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.532.1">.env</span></strong><span class="kobospan" id="kobo.533.1"> in the root of our project and add a </span><strong class="source-inline1"><span class="kobospan" id="kobo.534.1">FRONTEND_URL</span></strong> <span><span class="kobospan" id="kobo.535.1">environment variable:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.536.1">
FRONTEND_URL="http://localhost:5173"</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.537.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.538.1">generateSitemap.js</span></strong><span class="kobospan" id="kobo.539.1"> file in the root of our project, start by importing the </span><strong class="source-inline1"><span class="kobospan" id="kobo.540.1">slug</span></strong><span class="kobospan" id="kobo.541.1"> function </span><span><span class="kobospan" id="kobo.542.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.543.1">dotenv</span></strong></span><span><span class="kobospan" id="kobo.544.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.545.1">
import slug from 'slug'
import dotenv from 'dotenv'
dotenv.config()</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.546.1">Then, save the previously created environment variable in a </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.547.1">baseUrl</span></strong></span><span><span class="kobospan" id="kobo.548.1"> variable:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.549.1">
const baseUrl = process.env.FRONTEND_URL</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.550.1">Now, define an </span><strong class="source-inline1"><span class="kobospan" id="kobo.551.1">async</span></strong><span class="kobospan" id="kobo.552.1"> function to generate a sitemap. </span><span class="kobospan" id="kobo.552.2">In this function, we start by fetching a list of blog posts, as we want each blog post to be part of </span><span><span class="kobospan" id="kobo.553.1">the sitemap:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.554.1">
export async function generateSitemap() {
  const postsRequest = await fetch(`${process.env.VITE_BACKEND_URL}/posts`)
  const posts = await postsRequest.json()</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.555.1">Next, we return a string containing the XML for the sitemap. </span><span class="kobospan" id="kobo.555.2">We start by defining the XML header and a </span><strong class="source-inline1"><span class="kobospan" id="kobo.556.1">&lt;</span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.557.1">urlset&gt;</span></strong></span><span><span class="kobospan" id="kobo.558.1"> tag:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.559.1">
  return `&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;urlset &gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.560.1">Inside the </span><strong class="source-inline1"><span class="kobospan" id="kobo.561.1">&lt;urlset&gt;</span></strong><span class="kobospan" id="kobo.562.1"> tag, we can use </span><strong class="source-inline1"><span class="kobospan" id="kobo.563.1">&lt;url&gt;</span></strong><span class="kobospan" id="kobo.564.1"> tags with </span><strong class="source-inline1"><span class="kobospan" id="kobo.565.1">&lt;loc&gt;</span></strong><span class="kobospan" id="kobo.566.1"> tags to link to various pages. </span><span class="kobospan" id="kobo.566.2">We</span><a id="_idIndexMarker558" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.567.1"> first list </span><a id="_idIndexMarker559" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.568.1">all the </span><span><span class="kobospan" id="kobo.569.1">static pages:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.570.1">
    &lt;url&gt;
        &lt;loc&gt;${baseUrl}&lt;/loc&gt;
    &lt;/url&gt;
    &lt;url&gt;
        &lt;loc&gt;${baseUrl}/signup&lt;/loc&gt;
    &lt;/url&gt;
    &lt;url&gt;
        &lt;loc&gt;${baseUrl}/login&lt;/loc&gt;
    &lt;/url&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.571.1">Then, we loop over all posts that we fetched from the backend and generate a </span><strong class="source-inline1"><span class="kobospan" id="kobo.572.1">&lt;url&gt;</span></strong><span class="kobospan" id="kobo.573.1"> tag for each of them, constructing the URLs from the post ID and </span><span><span class="kobospan" id="kobo.574.1">the slug:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.575.1">
    ${posts
      .map(
        (post) =&gt; `
    &lt;url&gt;
        &lt;loc&gt;${baseUrl}/posts/${post._id}/${slug(post.title)}&lt;/loc&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.576.1">We can also optionally specify a </span><strong class="source-inline1"><span class="kobospan" id="kobo.577.1">&lt;lastmod&gt;</span></strong><span class="kobospan" id="kobo.578.1"> tag, telling the crawler when the content was </span><span><span class="kobospan" id="kobo.579.1">last modified:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.580.1">
        &lt;lastmod&gt;${post.updatedAt ?? </span><span class="kobospan1" id="kobo.580.2">post.createdAt}&lt;/lastmod&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.581.1">Lastly, we join all</span><a id="_idIndexMarker560" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.582.1"> generated </span><strong class="source-inline1"><span class="kobospan" id="kobo.583.1">&lt;url&gt;</span></strong><span class="kobospan" id="kobo.584.1"> tags together </span><a id="_idIndexMarker561" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.585.1">into a single string and close the </span><strong class="source-inline1"><span class="kobospan" id="kobo.586.1">&lt;</span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.587.1">urlset&gt;</span></strong></span><span><span class="kobospan" id="kobo.588.1"> tag:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.589.1">
    &lt;/url&gt;`,
      )
      .join('')}
&lt;/urlset&gt;`
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.590.1">Now that we have a function to dynamically generate a sitemap, we still need to include a route to it in </span><span><span class="kobospan" id="kobo.591.1">our server.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.592.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.593.1">server.js</span></strong><span class="kobospan" id="kobo.594.1"> and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.595.1">generateSitemap</span></strong> <span><span class="kobospan" id="kobo.596.1">function there:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.597.1">
import { generateSitemap } from './generateSitemap.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.598.1">Then, go to the first </span><strong class="source-inline1"><span class="kobospan" id="kobo.599.1">app.use('*')</span></strong><span class="kobospan" id="kobo.600.1"> declaration inside the </span><strong class="source-inline1"><span class="kobospan" id="kobo.601.1">createProdServer</span></strong><span class="kobospan" id="kobo.602.1"> function and check whether the URL is </span><strong class="source-inline1"><span class="kobospan" id="kobo.603.1">/sitemap.xml</span></strong><span class="kobospan" id="kobo.604.1">. </span><span class="kobospan" id="kobo.604.2">If yes, generate the sitemap and return it </span><span><span class="kobospan" id="kobo.605.1">as XML:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.606.1">
  app.use('*', async (req, res, next) =&gt; {
</span><strong class="bold1"><span class="kobospan1" id="kobo.607.1">    if (req.originalUrl === '/sitemap.xml') {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.608.1">      const sitemap = await generateSitemap()</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.609.1">      return res</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.610.1">        .status(200)</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.611.1">        .set({ 'Content-Type': 'application/xml' })</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.612.1">        .end(sitemap)</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.613.1">    }</span></strong></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.614.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.615.1">In a more sophisticated setup, we could cache the generated sitemap either on our Express server, our own web server, or a separate </span><span><span class="kobospan" id="kobo.616.1">caching service.</span></span></p>
<ol class="calibre15">
<li value="12" class="calibre11"><span class="kobospan" id="kobo.617.1">We do </span><a id="_idIndexMarker562" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.618.1">the same change as in</span><a id="_idIndexMarker563" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.619.1"> the previous step for the second </span><strong class="source-inline1"><span class="kobospan" id="kobo.620.1">app.use('*')</span></strong><span class="kobospan" id="kobo.621.1"> declaration inside the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.622.1">createDevServer</span></strong></span><span><span class="kobospan" id="kobo.623.1"> function.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.624.1">Restart the server and go to </span><strong class="source-inline1"><span class="kobospan" id="kobo.625.1">http://localhost:5173/sitemap.xml</span></strong><span class="kobospan" id="kobo.626.1"> to see the sitemap being dynamically generated, with links to all created posts and their last </span><span><span class="kobospan" id="kobo.627.1">modified timestamps.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.628.1">We can now link to the sitemap in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.629.1">robots.txt</span></strong><span class="kobospan" id="kobo.630.1"> file. </span><span class="kobospan" id="kobo.630.2">As an example, we are going to set the URL to localhost. </span><span class="kobospan" id="kobo.630.3">In a production app, you would adjust this URL to point to the sitemap on the URL of the deployed application. </span><span class="kobospan" id="kobo.630.4">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.631.1">public/robots.txt</span></strong><span class="kobospan" id="kobo.632.1"> and add the </span><span><span class="kobospan" id="kobo.633.1">following line:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.634.1">
Sitemap: http://localhost:5173/sitemap.xml</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.635.1">Now that we have successfully implemented measures to improve our app for search engines, let’s take a look at our SEO score in the </span><span><span class="kobospan" id="kobo.636.1">Lighthouse report:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer087">
<span class="kobospan" id="kobo.637.1"><img alt="Figure 8.4 – Our Lighthouse SEO score is now 100!" src="image/B19385_08_4.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.638.1">Figure 8.4 – Our Lighthouse SEO score is now 100!</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.639.1">As we can see, our SEO score is now 100 (from 91 before). </span><span class="kobospan" id="kobo.639.2">This might only seem like a slight improvement, but the Lighthouse report only takes into account basic checks, such as having a title, description, viewport tag, and a </span><strong class="source-inline"><span class="kobospan" id="kobo.640.1">robots.txt</span></strong><span class="kobospan" id="kobo.641.1"> file. </span><span class="kobospan" id="kobo.641.2">We have done much more to optimize the user experience for visitors and search engines, such as improving the URL structure and adding dynamic titles </span><span><span class="kobospan" id="kobo.642.1">and descriptions.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.643.1">We could still further optimize our app by serving static assets via a </span><strong class="bold"><span class="kobospan" id="kobo.644.1">Content Delivery Network </span></strong><span class="kobospan" id="kobo.645.1">(</span><strong class="bold"><span class="kobospan" id="kobo.646.1">CDN</span></strong><span class="kobospan" id="kobo.647.1">) and</span><a id="_idIndexMarker564" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.648.1"> using responsive images (serving images in different sizes to optimize performance on slower connections and avoid loading the full-size images). </span><span class="kobospan" id="kobo.648.2">However, that is outside the scope of </span><span><span class="kobospan" id="kobo.649.1">this book.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.650.1">To wrap up this chapter, we are going to take a look at improving embeds on social </span><span><span class="kobospan" id="kobo.651.1">media sites.</span></span></p>
<h1 id="_idParaDest-171" class="calibre5"><a id="_idTextAnchor172" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.652.1">Improving social media embeds</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.653.1">We have already added the</span><a id="_idIndexMarker565" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.654.1"> important meta tags for search engines. </span><span class="kobospan" id="kobo.654.2">However, social media websites, such as Facebook and X (formerly Twitter), read additional meta tags to improve the embedding of your app on their sites and apps. </span><span class="kobospan" id="kobo.654.3">Most social networks use a standard called</span><a id="_idIndexMarker566" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.655.1"> Open Graph Meta Tags, which was originally created at Facebook. </span><span class="kobospan" id="kobo.655.2">These tags can contain additional information on the type of page, a special title, the description, and an image for embedding the page on a social </span><span><span class="kobospan" id="kobo.656.1">media website.</span></span></p>
<h2 id="_idParaDest-172" class="calibre7"><a id="_idTextAnchor173" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.657.1">Open Graph meta tags</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.658.1">The </span><strong class="bold"><span class="kobospan" id="kobo.659.1">Open Graph</span></strong><span class="kobospan" id="kobo.660.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.661.1">OG</span></strong><span class="kobospan" id="kobo.662.1">) meta tags</span><a id="_idIndexMarker567" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.663.1"> have four generic properties that every page </span><span><span class="kobospan" id="kobo.664.1">can have:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.665.1">og:type</span></strong><span class="kobospan" id="kobo.666.1">: Describes the type of the page; specific types may have </span><span><span class="kobospan" id="kobo.667.1">additional properties</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.668.1">og:title</span></strong><span class="kobospan" id="kobo.669.1">: Describes the title of the page as it should appear </span><span><span class="kobospan" id="kobo.670.1">on embeds</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.671.1">og:image</span></strong><span class="kobospan" id="kobo.672.1">: An URL to an image that should be used for </span><span><span class="kobospan" id="kobo.673.1">the embed</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.674.1">og:url</span></strong><span class="kobospan" id="kobo.675.1">: An URL to a link that should be used for </span><span><span class="kobospan" id="kobo.676.1">the embed</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.677.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.678.1">og:type</span></strong><span class="kobospan" id="kobo.679.1"> meta tag describes the type of content available on the page. </span><span class="kobospan" id="kobo.679.2">It tells the social media sites how the embed should be formatted. </span><span class="kobospan" id="kobo.679.3">Among others, the following values </span><span><span class="kobospan" id="kobo.680.1">are possible:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.681.1">website</span></strong><span class="kobospan" id="kobo.682.1">: The default value, a </span><span><span class="kobospan" id="kobo.683.1">basic embed</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.684.1">article</span></strong><span class="kobospan" id="kobo.685.1">: This is for news and blog posts, and has additional parameters for </span><strong class="source-inline1"><span class="kobospan" id="kobo.686.1">published_time</span></strong><span class="kobospan" id="kobo.687.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.688.1">modified_time</span></strong><span class="kobospan" id="kobo.689.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.690.1">author</span></strong><span class="kobospan" id="kobo.691.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.692.1">section</span></strong><span class="kobospan" id="kobo.693.1">, </span><span><span class="kobospan" id="kobo.694.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.695.1">tag</span></strong></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.696.1">profile</span></strong><span class="kobospan" id="kobo.697.1">: For user profiles, with additional parameters for </span><strong class="source-inline1"><span class="kobospan" id="kobo.698.1">first_name</span></strong><span class="kobospan" id="kobo.699.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.700.1">last_name</span></strong><span class="kobospan" id="kobo.701.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.702.1">username</span></strong><span class="kobospan" id="kobo.703.1">, </span><span><span class="kobospan" id="kobo.704.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.705.1">gender</span></strong></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.706.1">book</span></strong><span class="kobospan" id="kobo.707.1">: For books, with additional parameters for </span><strong class="source-inline1"><span class="kobospan" id="kobo.708.1">author</span></strong><span class="kobospan" id="kobo.709.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.710.1">isbn</span></strong><span class="kobospan" id="kobo.711.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.712.1">release_date</span></strong><span class="kobospan" id="kobo.713.1">, </span><span><span class="kobospan" id="kobo.714.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.715.1">tag</span></strong></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.716.1">music</span></strong><span class="kobospan" id="kobo.717.1"> types: This includes </span><strong class="source-inline1"><span class="kobospan" id="kobo.718.1">music.song</span></strong><span class="kobospan" id="kobo.719.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.720.1">music.album</span></strong><span class="kobospan" id="kobo.721.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.722.1">music.playlist</span></strong><span class="kobospan" id="kobo.723.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.724.1">music.radio_station</span></strong><span class="kobospan" id="kobo.725.1">, each of them having different </span><span><span class="kobospan" id="kobo.726.1">additional parameters</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.727.1">video</span></strong><span class="kobospan" id="kobo.728.1"> types: This includes </span><strong class="source-inline1"><span class="kobospan" id="kobo.729.1">video.movie</span></strong><span class="kobospan" id="kobo.730.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.731.1">video.episode</span></strong><span class="kobospan" id="kobo.732.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.733.1">video.tv_show</span></strong><span class="kobospan" id="kobo.734.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.735.1">video.other</span></strong><span class="kobospan" id="kobo.736.1">, each of them having different </span><span><span class="kobospan" id="kobo.737.1">additional parameters</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.738.1">A full description of the OG meta tags and </span><a id="_idIndexMarker568" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.739.1">all possible values can be found on their official </span><span><span class="kobospan" id="kobo.740.1">website: </span></span><a href="https://ogp.me/" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.741.1">https://ogp.me/</span></span></a><span><span class="kobospan" id="kobo.742.1">.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.743.1">Info</span></p>
<p class="callout"><span class="kobospan" id="kobo.744.1">Most social media sites support OG meta tags for embeds. </span><span class="kobospan" id="kobo.744.2">However, some websites, including X (formerly Twitter), have their own meta tags, which take priority over OG meta tags, if provided. </span><span class="kobospan" id="kobo.744.3">X can still read OG meta tags though, so it is enough to only </span><span><span class="kobospan" id="kobo.745.1">provide those.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.746.1">Now, we are going to focus on the </span><strong class="source-inline"><span class="kobospan" id="kobo.747.1">article</span></strong><span class="kobospan" id="kobo.748.1"> type, as we are developing a blog application, so we can use this type to provide better embeds for the </span><span><span class="kobospan" id="kobo.749.1">blog posts.</span></span></p>
<h2 id="_idParaDest-173" class="calibre7"><a id="_idTextAnchor174" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.750.1">Using the OG article meta tags</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.751.1">As we have learned, the </span><strong class="source-inline"><span class="kobospan" id="kobo.752.1">article</span></strong><span class="kobospan" id="kobo.753.1"> type allows</span><a id="_idIndexMarker569" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.754.1"> us to include meta information about the published time, modified time, and author of an article on our page. </span><span class="kobospan" id="kobo.754.2">Let’s do this now for our </span><span><span class="kobospan" id="kobo.755.1">single-post page:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.756.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.757.1">src/pages/ViewPost.jsx</span></strong><span class="kobospan" id="kobo.758.1"> and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.759.1">getUserInfo</span></strong><span class="kobospan" id="kobo.760.1"> API function, as we will need to resolve the author name for the corresponding </span><span><span class="kobospan" id="kobo.761.1">meta tag:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.762.1">
import { getUserInfo } from '../api/users.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.763.1">Inside the </span><strong class="source-inline1"><span class="kobospan" id="kobo.764.1">ViewPost</span></strong><span class="kobospan" id="kobo.765.1"> component after we fetch the post, fetch the author name. </span><span class="kobospan" id="kobo.765.2">We make sure to only do this call if the </span><strong class="source-inline1"><span class="kobospan" id="kobo.766.1">post?.author</span></strong><span class="kobospan" id="kobo.767.1"> attribute exists by using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.768.1">enabled</span></strong><span class="kobospan" id="kobo.769.1"> option of the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.770.1">useQuery</span></strong></span><span><span class="kobospan" id="kobo.771.1"> hook:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.772.1">
  const userInfoQuery = useQuery({
    queryKey: ['users', post?.author],
    queryFn: () =&gt; getUserInfo(post?.author),
    enabled: Boolean(post?.author),
  })
  const userInfo = userInfoQuery.data ?? </span><span class="kobospan1" id="kobo.772.2">{}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.773.1">Inside the </span><strong class="source-inline1"><span class="kobospan" id="kobo.774.1">Helmet</span></strong><span class="kobospan" id="kobo.775.1"> component, we define the </span><strong class="source-inline1"><span class="kobospan" id="kobo.776.1">og:type</span></strong><span class="kobospan" id="kobo.777.1"> tag as </span><strong class="source-inline1"><span class="kobospan" id="kobo.778.1">article</span></strong><span class="kobospan" id="kobo.779.1"> and define the title, published time, and </span><span><span class="kobospan" id="kobo.780.1">modified time:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.781.1">
      {post &amp;&amp; (
        &lt;Helmet&gt;
          &lt;title&gt;{post.title} | Full-Stack React Blog&lt;/title&gt;
          &lt;meta name='description' content={truncate(post.contents)} /&gt;
</span><strong class="bold1"><span class="kobospan1" id="kobo.782.1">          &lt;meta property='og:type' content='article' /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.783.1">          &lt;meta property='og:title' content={post.title} /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.784.1">          &lt;meta property='og:article:published_time' content={post.createdAt} /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.785.1">          &lt;meta property='og:article:modified_time' content={post.updatedAt} /&gt;</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.786.1">Then, we set the </span><strong class="source-inline1"><span class="kobospan" id="kobo.787.1">og:article:author</span></strong><span class="kobospan" id="kobo.788.1"> to the </span><span><span class="kobospan" id="kobo.789.1">resolved username:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.790.1">
          &lt;meta property='og:article:author' content={userInfo.username} /&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.791.1">Lastly, we loop through the tags (if there are none, we default to an empty array) and define a meta tag for </span><span><span class="kobospan" id="kobo.792.1">each tag:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.793.1">          {(post.tags ?? </span><span class="kobospan1" id="kobo.793.2">[]).map((tag) =&gt; (</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.794.1">            &lt;meta key={tag} property='og:article:tag' content={tag} /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.795.1">          ))}</span></strong><span class="kobospan1" id="kobo.796.1">
        &lt;/Helmet&gt;
      )}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.797.1">Arrays in </span><a id="_idIndexMarker570" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.798.1">OG meta tags work by redefining the same property </span><span><span class="kobospan" id="kobo.799.1">multiple times.</span></span></p></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.800.1">Now that we have successfully added meta tags, our blog app is optimized for search engines and social </span><span><span class="kobospan" id="kobo.801.1">media sites!</span></span></p>
<h1 id="_idParaDest-174" class="calibre5"><a id="_idTextAnchor175" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.802.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.803.1">In this chapter, we first briefly learned how search engines work. </span><span class="kobospan" id="kobo.803.2">Then, we created a </span><strong class="source-inline"><span class="kobospan" id="kobo.804.1">robots.txt</span></strong><span class="kobospan" id="kobo.805.1"> file, along with separate pages for each blog post, to better optimize our blog for search engines. </span><span class="kobospan" id="kobo.805.2">Next, we created meaningful URLs (slugs) and set dynamic titles and meta tags. </span><span class="kobospan" id="kobo.805.3">Then, we created a sitemap and evaluated the SEO score of our blog after all optimizations. </span><span class="kobospan" id="kobo.805.4">Finally, we learned how social media embeds work and which meta tags can be used to improve embeds for articles, such as </span><span><span class="kobospan" id="kobo.806.1">blog posts.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.807.1">In the next chapter, </span><a href="B19385_09.xhtml#_idTextAnchor176" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.808.1">Chapter 9</span></em></span></a><em class="italic"><span class="kobospan" id="kobo.809.1">, Implementing End-to-End Tests Using Playwright</span></em><span class="kobospan" id="kobo.810.1">, we are going to learn how to write end-to-end tests for our user interface by setting up Playwright. </span><span class="kobospan" id="kobo.810.2">Then, we are going to write some frontend tests for our </span><span><span class="kobospan" id="kobo.811.1">blog application.</span></span></p>
</div>
</body></html>