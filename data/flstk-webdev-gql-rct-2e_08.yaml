- en: '*Chapter 6*: Authentication with Apollo and React'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 6 章*：使用 Apollo 和 React 进行身份验证'
- en: We have come a long way over the last few chapters. We have now reached the
    point where we are going to implement authentication for our React and GraphQL
    web applications. In this chapter, you are going to learn about some essential
    concepts for building an application with authentication using GraphQL.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几章中，我们已经走得很远了。现在，我们已经到达了将要为我们的 React 和 GraphQL Web 应用程序实现身份验证的阶段。在本章中，你将学习到构建使用
    GraphQL 进行身份验证的应用程序的一些基本概念。
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: What is a JWT?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JWT 是什么？
- en: Cookies versus localStorage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cookie 与 localStorage 的比较
- en: Implementing authentication in Node.js and Apollo
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Node.js 和 Apollo 中实现身份验证
- en: Signing up and logging in users
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户注册和登录
- en: Authenticating GraphQL queries and mutations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证 GraphQL 查询和突变
- en: Accessing the user from the request context
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从请求上下文中访问用户
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The source code for this chapter is available in the following GitHub repository:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在以下 GitHub 仓库中找到：
- en: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter06)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter06)'
- en: What are JSON Web Tokens?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 JSON Web Tokens？
- en: '**JSON Web Tokens** (**JWTs**) are still a pretty new standard for carrying
    out authentication; not everyone knows about them, and even fewer people use them.
    This section does not provide a theoretical excursion through the mathematical
    or cryptographic basics of JWTs.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON Web Tokens** (**JWTs**) 仍然是一个相对较新的标准，用于执行身份验证；并不是每个人都了解它们，甚至更少的人使用它们。本节不会提供
    JWT 的数学或加密基础理论性的探讨。'
- en: In traditional web applications written using PHP, for example, you commonly
    have a session cookie. This cookie identifies the user session on the server.
    The session must be stored on the server to retrieve the initial user. The problem
    here is that the overhead of saving and querying all the sessions for all the
    users can be high. When using JWTs, however, there is no need for the server to
    preserve any kind of session ID.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在用 PHP 编写的传统 Web 应用程序中，你通常有一个会话 cookie。这个 cookie 识别服务器上的用户会话。会话必须存储在服务器上以检索初始用户。这里的问题是，保存和查询所有用户的会话可能会产生很高的开销。然而，在使用
    JWT 时，服务器无需保留任何类型的会话 ID。
- en: Generally speaking, a JWT consists of everything you need to identify a user.
    The most common approach is to store the creation time of the token, the username,
    the user ID, and maybe the role, such as an admin or a normal user. You should
    not include any personal or critical data for security reasons.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，JWT 包含了识别用户所需的一切。最常见的方法是存储令牌的创建时间、用户名、用户 ID，以及可能的角色，例如管理员或普通用户。出于安全原因，你不应该包含任何个人信息或关键数据。
- en: The reason a JWT exists is not to encrypt or secure data in any way. Instead,
    to authorize yourself using a resource such as a server, you send a signed JWT
    that your server can verify. It can only verify the JWT if it was created by a
    service stated as authentic by your server. In most cases, your server will have
    used its public key to sign the token. Any person or service that can read the
    communication between you and the server can access the token and can extract
    the payload without further ado. They are not able to edit its content though,
    because the token is signed with a signature.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: JWT 存在的原因并不是为了以任何方式加密或保护数据。相反，为了使用服务器等资源进行身份验证，你需要发送一个由你的服务器验证的已签名的 JWT。只有当它是由你的服务器声称为可信的服务创建时，它才能验证
    JWT。在大多数情况下，你的服务器将使用其公钥来签名令牌。任何可以读取你与服务器之间通信的人或服务都可以访问令牌，并且可以轻松提取有效载荷。尽管如此，他们无法编辑其内容，因为令牌是用签名签名的。
- en: The token needs to be transported and stored securely in the browser of the
    client. If the token gets into the wrong hands, that person can access the affected
    application with your identity, initiate actions in your name, or read personal
    data. It is also hard to invalidate a JWT. With a session cookie, you can delete
    the session on the server, and the user will no longer be authenticated through
    the cookie. With a JWT, however, we do not have any information on the server.
    It can only validate the signature of the token and find the user in your database.
    One common approach is to have a blacklist of all the disallowed tokens. Alternatively,
    you can keep the lifetime of a JWT low by specifying the expiration date. This
    solution, however, requires the user to frequently repeat the login process, which
    makes the experience less comfortable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌需要在客户端的浏览器中安全地传输和存储。如果令牌落入错误的手中，那个人可以使用您的身份访问受影响的应用程序，以您的名义发起操作，或读取个人信息。JWT
    的撤销也很困难。使用会话cookie，您可以在服务器上删除会话，用户将不再通过cookie进行认证。然而，使用 JWT，我们在服务器上没有任何信息。它只能验证令牌的签名并在您的数据库中找到用户。一种常见的方法是有一个所有不允许的令牌的黑名单。或者，您可以通过指定过期日期来降低
    JWT 的有效期。然而，这种解决方案需要用户频繁地重复登录过程，这会使体验变得不那么舒适。
- en: 'JWTs do not require any server-side storage. The great thing about server-side
    sessions is that you can store specific application states for your user and,
    for example, remember the last actions a user performed. Without a server-side
    store, you either need to implement these features in `localStorage` or implement
    a session store, which is not required for using JWT authentication at all:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: JWT 不需要任何服务器端存储。服务器端会话的妙处在于您可以存储特定应用程序状态，例如记住用户执行的最后操作。没有服务器端存储，您要么需要在 `localStorage`
    中实现这些功能，要么实现一个会话存储，这对于使用 JWT 认证根本不是必需的：
- en: Note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'JWTs are an important topic in developer communities. There is some excellent
    documentation available related to what JWTs are, how they can be used, and their
    technological background. Visit the following web page to learn more and to see
    a demonstration of the generation of a JWT: [https://jwt.io/](https://jwt.io/).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: JWT 在开发者社区中是一个重要的话题。有关 JWT 是什么、如何使用以及其技术背景的出色文档有很多。访问以下网页了解更多信息，并查看 JWT 生成演示：[https://jwt.io/](https://jwt.io/)。
- en: '![Figure 6.1 – JWT structure'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.1 – JWT 结构'
- en: '](img/Figure_6.01_B17337.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.01_B17337.jpg)'
- en: Figure 6.1 – JWT structure
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – JWT 结构
- en: 'As shown in the preceding diagram, a JWT consists of three parts:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，JWT 由三个部分组成：
- en: '**HEADER**: The header specifies the algorithm that was used to generate the
    JWT.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标题**: 标题指定了用于生成 JWT 的算法。'
- en: '**PAYLOAD**: The payload consists of all the "session" data, which are called
    claims. The preceding is just a simple representation and does not show the full
    complexity of a JWT.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有效载荷**: 有效载荷由所有“会话”数据组成，这些数据被称为声明。前面的只是一个简单的表示，并没有展示 JWT 的全部复杂性。'
- en: '**SIGNATURE**: The signature is calculated from the header and payload. To
    verify if a JWT has not been tampered with, the signature is compared to the newly
    generated signature from the actual payload and header.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**签名**: 签名是从标题和有效载荷计算得出的。为了验证 JWT 是否被篡改，签名将与从实际有效载荷和标题中新生成的签名进行比较。'
- en: In our example, we are going to use JWTs, since they are a modern and decentralized
    method of authentication. Still, you can choose to opt out of this at any point
    and use regular sessions instead, which can be quickly realized in Express.js
    and GraphQL.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将使用 JWT，因为它们是一种现代且去中心化的认证方法。尽管如此，您可以在任何时候选择退出此选项，并改用常规会话，这在 Express.js
    和 GraphQL 中可以快速实现。
- en: In the next section, we will look at the different ways of storing the JWT inside
    the browser and how to transmit between `localStorage` and cookies.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨在浏览器内部存储 JWT 的不同方法以及如何在 `localStorage` 和 cookies 之间传输。
- en: localStorage versus cookies
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: localStorage 与 cookies 的比较
- en: Let's look at another critical question. It is crucial to understand at least
    the basics of how authentication works and how it is secured. You are responsible
    for any faulty implementation that allows data breaches to occur, so always keep
    this in mind. Where do we store the token we receive from the server?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个关键问题。了解至少认证工作原理及其安全性的基础知识至关重要。您对任何可能导致数据泄露的故障实现负有责任，所以请始终牢记这一点。我们在哪里存储从服务器收到的令牌？
- en: In whichever direction you send a token, you should always be sure that your
    communication is secure. For web applications like ours, be sure that HTTPS is
    enabled and used for all requests. Once the user has successfully authenticated,
    the client receives the JWT, according to the JWT authentication workflow. A JWT
    is not tied to any particular storage medium, so you are free to choose whichever
    you prefer. If we do not store the token when it is received, it will be only
    available in the memory. While the user is browsing our site, this is fine, but
    the moment they refresh the page, they will need to log in again because we haven't
    stored the token anywhere.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你将令牌发送到哪个方向，你都应该始终确保你的通信是安全的。对于像我们这样的Web应用程序，请确保所有请求都启用了HTTPS。一旦用户成功认证，客户端将根据JWT认证工作流程接收JWT。JWT不绑定到任何特定的存储介质，因此你可以自由选择你喜欢的任何一种。如果我们不在收到令牌时存储它，它将仅在内存中可用。当用户浏览我们的网站时，这是可以的，但当他们刷新页面时，他们需要再次登录，因为我们没有在任何地方存储令牌。
- en: 'There are two standard options: to store the JWT inside `localStorage` or to
    store it inside a cookie. Let''s start by discussing the first option. `localStorage`
    is the option that''s often suggested in tutorials. This is fine, assuming you
    are writing a single-page web application where the content changes dynamically,
    depending on the actions of the user and client-side routing. We do not follow
    any links and load new sites to see new content; instead, the old one is just
    replaced with the new page that you want to show.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种标准选项：将JWT存储在`localStorage`中或存储在cookie中。让我们先讨论第一种选项。`localStorage`是教程中经常建议的选项。这是可以的，假设你正在编写一个单页Web应用程序，其中内容根据用户和客户端路由的动作动态更改。我们不遵循任何链接并加载新站点以查看新内容；相反，旧的内容只是被你想要显示的新页面所替换。
- en: 'Storing the token in `localStorage` has the following disadvantages:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将令牌存储在`localStorage`有以下缺点：
- en: '`localStorage` is not transmitted on every request. When the page is loaded
    initially, you are not able to send the token within your request, so resources
    that need authentication cannot be given back to you. Once your application has
    finished loading, you must make a second request to your server, including the
    token to access the secured content. This behavior has the consequence that it
    is not possible to build server-rendered applications.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localStorage`不是在每次请求时都传输。当页面首次加载时，你无法在请求中发送令牌，因此需要认证的资源无法返回给你。一旦你的应用程序加载完成，你必须向服务器发送第二个请求，包括令牌以访问受保护的内容。这种行为的结果是，无法构建服务器端渲染的应用程序。'
- en: The client needs to implement the mechanics to attach the token to every request
    that's sent to the server.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端需要实现将令牌附加到发送到服务器的每个请求的机制。
- en: Due to the nature of `localStorage`, there is no built-in expiry date on the
    client. If, at some point, the token reaches its expiration date, it still exists
    on the client inside `localStorage`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`localStorage`的性质，客户端没有内置的过期日期。如果在某个时刻，令牌达到其过期日期，它仍然存在于客户端的`localStorage`中。
- en: '`localStorage` is accessed through pure JavaScript and is therefore open to
    XSS attacks. If someone manages to integrate custom JavaScript in your code or
    site through unsanitized inputs, they can read the token from `localStorage`.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localStorage`通过纯JavaScript访问，因此容易受到XSS攻击。如果有人设法通过未经过滤的输入将自定义JavaScript集成到你的代码或网站上，他们可以从`localStorage`中读取令牌。'
- en: 'There are, however, many advantages of using `localStorage`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`localStorage`有许多优点：
- en: As `localStorage` is not sent automatically with every request, it is secure
    against any **Cross-Site-Request-Forgery** (**CSRF**) attacks attempting to run
    actions from external sites by making random requests.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`localStorage`不是在每次请求时自动发送，因此它对任何试图通过随机请求从外部站点执行操作的**跨站请求伪造**（**CSRF**）攻击具有安全性。
- en: '`localStorage` is easy to read in JavaScript since it is stored as a key-value
    pair.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localStorage`在JavaScript中很容易读取，因为它以键值对的形式存储。'
- en: It supports a bigger data size, which is great for storing an application state
    or data.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持更大的数据大小，这对于存储应用程序状态或数据来说非常好。
- en: The main problem with storing such critical tokens inside web storage is that
    you cannot guarantee that there is no unwanted access. Unless you can be sure
    that every single input is sanitized and you are not relying on any third-party
    tools that get bundled into your JavaScript code, there is always a potential
    risk. Just one package you did not build yourself could share your users' web
    storage with its creator, without you or the user ever noticing. Furthermore,
    when you are using a public **Content Delivery Network** (**CDN**), the attack
    base and, consequently, the risk for your application is multiplied.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将如此关键的令牌存储在Web存储中的主要问题是您无法保证没有不受欢迎的访问。除非您能确保每个单独的输入都经过清理，并且您不依赖于任何捆绑到您的JavaScript代码中的第三方工具，否则始终存在潜在的风险。即使是一个您没有构建的包也可能与创建者共享您的用户的Web存储，而您或用户可能从未注意到。此外，当您使用公共**内容分发网络**（**CDN**）时，攻击面和您的应用程序的风险都会增加。
- en: Now, let's look at cookies. These are great, despite their bad press due to
    the cookie compliance law that was initiated by the EU. Putting aside the more
    negative things that cookies can enable the companies to do, such as tracking
    users, there are still many good things about them. One significant difference
    compared to `localStorage` is that cookies are sent with every request, including
    the initial request for the site your application is hosted on.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看cookie。尽管由于欧盟启动的cookie合规性法律而受到负面报道，但它们仍然很棒。抛开cookie可以允许公司做的更负面的事情，比如跟踪用户，它们仍然有很多优点。与`localStorage`相比的一个显著区别是，cookie会随着每个请求发送，包括您应用程序托管站点的初始请求。
- en: 'Cookies come with the following advantages:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Cookie具有以下优点：
- en: Server-side rendering is no problem at all since cookies are sent with every
    request.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于每个请求都会发送cookie，因此服务器端渲染根本不是问题。
- en: No further logic needs to be implemented in the frontend to send the JWT.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端不需要实现任何额外的逻辑来发送JWT。
- en: Cookies can be declared as `httpOnly`, which means JavaScript can't access them.
    It secures our token from XSS attacks.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将cookie声明为`httpOnly`，这意味着JavaScript无法访问它们。这可以保护我们的令牌免受XSS攻击。
- en: Cookies have a built-in expiration date, which can be set to invalidate the
    cookie in the client browser.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cookie有一个内置的过期日期，可以设置为在客户端浏览器中使cookie失效。
- en: Cookies can be configured to only be readable from specific domains or paths.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以配置cookie，使其只能从特定的域或路径中读取。
- en: All browsers support cookies.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有浏览器都支持cookie。
- en: 'These advantages sound good so far, but let''s consider the downsides:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些优点听起来很好，但让我们考虑一下缺点：
- en: Cookies are generally open to CSRF attacks, which are situations in which an
    external website makes requests to your API. They expect you to be authenticated
    and hope that they can execute actions on your behalf. We can't stop the cookie
    from being sent with each request to your domain. A common prevention tactic is
    to implement a CSRF token. This special token is also transmitted by your server
    and saved as a cookie. The external website cannot access the cookie with JavaScript
    since it is stored under a different domain. Your server does not read a token
    from the cookies that are transmitted with each request, only from an HTTP header.
    This behavior guarantees that the token was sent by the JavaScript that was hosted
    on your application because only this can have access to the token. Setting up
    the XSRF token for verification, however, introduces a lot of work.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cookie通常容易受到CSRF攻击，在这些攻击中，外部网站向您的API发送请求。他们期望您已认证，并希望他们能代表您执行操作。我们无法阻止cookie与每个请求一起发送到您的域。常见的预防策略是实施CSRF令牌。这个特殊的令牌也由您的服务器传输并保存为cookie。由于它存储在不同的域下，外部网站无法使用JavaScript访问cookie。您的服务器不会从每个请求中读取cookie，而只从HTTP头中读取。这种行为保证了令牌是由托管在您的应用程序上的JavaScript发送的，因为只有这样才能访问令牌。然而，设置用于验证的XSRF令牌却需要做很多工作。
- en: Accessing and parsing cookies is not intuitive because they are stored as a
    big comma-separated string.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它们以一个大型的逗号分隔的字符串形式存储，访问和解析cookie并不直观。
- en: They can only store a small amount of data.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们只能存储少量的数据。
- en: So, we can see that both approaches have their advantages and disadvantages.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到这两种方法都有其优点和缺点。
- en: The most common method is to use `localStorage`, as this is the easiest method.
    In this book, we will start by using `localStorage`, but later switch over to
    cookies when using server-side rendering to give you experience with both. You
    may not need server-side rendering at all. If this is the case, you can skip this
    part and the cookie implementation too.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的方法是使用 `localStorage`，因为这是最简单的方法。在这本书中，我们将首先使用 `localStorage`，但稍后将在使用服务器端渲染时切换到
    cookies，以便让你体验两种方法。你可能根本不需要服务器端渲染。如果是这种情况，你可以跳过这部分，以及 cookie 实现。
- en: In the next section, we are going to implement authentication with GraphQL.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现使用 GraphQL 的身份验证。
- en: Authentication with GraphQL
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphQL 身份验证
- en: 'The basics of authentication should now be clear to you. Now, our task is to
    implement a secure way for users to authenticate. If we have a look at our current
    database, we will see that we are missing the required fields. To do so, follow
    these steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在身份验证的基本知识应该已经清楚。现在，我们的任务是实现一种安全的方法让用户进行身份验证。如果我们查看当前的数据库，我们会看到我们缺少所需的字段。为此，请按照以下步骤操作：
- en: 'Let''s prepare and add a `password` field and an `email` field. As we learned
    in [*Chapter 3*](B17337_03_Final_ASB_ePub.xhtml#_idTextAnchor054), *Connecting
    to the Database*, we must create a migration to edit our user table. You can look
    up the commands in that chapter if you have forgotten them:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们准备并添加一个 `password` 字段和一个 `email` 字段。正如我们在 [*第 3 章*](B17337_03_Final_ASB_ePub.xhtml#_idTextAnchor054)
    中所学的，*连接到数据库*，我们必须创建一个迁移来编辑我们的用户表。如果你忘记了这些命令，可以在该章节中查找：
- en: '[PRE0]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding command generates the new file for us.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述命令为我们生成了新文件。
- en: 'Replace the content of it and try writing the migration on your own, or you
    can check for the right commands in the following code snippet:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换其内容，然后尝试自己编写迁移，或者你可以检查以下代码片段中的正确命令：
- en: '[PRE1]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'All the fields are simple strings. Execute the migration, as stated in [*Chapter
    3*](B17337_03_Final_ASB_ePub.xhtml#_idTextAnchor054), *Connecting to the Database*.
    The email address needs to be unique. Our old seed file for the users needs to
    be updated now to represent the new fields that we have just added. Add the following
    fields to the first user:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有字段都是简单的字符串。按照 [*第 3 章*](B17337_03_Final_ASB_ePub.xhtml#_idTextAnchor054) 中所述，*连接到数据库*
    执行迁移。电子邮件地址必须是唯一的。现在我们需要更新我们为用户的老种子文件，以表示我们刚刚添加的新字段。将以下字段添加到第一个用户：
- en: '[PRE2]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Do this for all the users and change the email address for each. Otherwise,
    it will not work. The password is in hashed format and represents the plain password
    123456789\. Since we have added new fields in a separate migration, we must add
    these to the model.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对所有用户都这样做，并更改每个用户的电子邮件地址。否则，它将不起作用。密码是哈希格式，代表明文密码123456789。由于我们在单独的迁移中添加了新字段，我们必须将这些字段添加到模型中。
- en: 'Open and add the following new lines as fields to the `user.js` file in the
    `model` folder:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开并添加以下新行作为字段到 `model` 文件夹中的 `user.js` 文件：
- en: '[PRE3]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now clear the database, run all the migrations, and execute the seeders again.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在清空数据库，运行所有迁移，并再次执行种子文件。
- en: The first thing we must do is get the login process running. At the moment,
    we are just faking being logged in as the first user in our database.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是让登录过程运行起来。目前，我们只是在模拟作为数据库中的第一个用户登录。
- en: Apollo login mutation
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Apollo 登录突变
- en: 'In this section, we are going to edit our GraphQL schema and implement the
    matching resolver function. Follow these steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编辑我们的 GraphQL 模式并实现相应的解析函数。按照以下步骤操作：
- en: 'Let''s start with the schema and add a new mutation to the `RootMutation` object
    of our `schema.js` file:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从模式开始，向我们的 `schema.js` 文件中的 `RootMutation` 对象添加一个新突变。
- en: '[PRE4]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding schema gives us a login mutation that accepts an email address
    and a password. Both are required to identify and authenticate the user. Then,
    we need to respond with something to the client. For now, the `Auth` type returns
    a token, which is a JWT in our case. You might want to add a different option
    according to your requirements:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述模式为我们提供了一个接受电子邮件地址和密码的登录突变。两者都是识别和验证用户的必要条件。然后，我们需要向客户端响应一些内容。目前，`Auth` 类型返回一个令牌，在我们的案例中是一个
    JWT。你可能想根据你的需求添加不同的选项：
- en: '[PRE5]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The schema is now ready. Head over to the `resolvers` file and add the login
    function inside the mutation object. Before we do this, install and import two
    new packages:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模式现在已准备就绪。前往 `resolvers` 文件，并在突变对象中添加登录函数。在我们这样做之前，安装并导入两个新包：
- en: '[PRE6]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Import these packages at the top of the `resolvers` file:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `resolvers` 文件顶部导入这些包：
- en: '[PRE7]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `login` function receives `email` and `password` as parameters. It should
    look as follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`login` 函数接收 `email` 和 `password` 作为参数。它应该如下所示：'
- en: '[PRE8]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding code goes through the following steps:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码执行以下步骤：
- en: We query all the users where the email address matches.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们查询所有邮箱地址匹配的用户。
- en: If a user is found, we can move on. It is not possible to have multiple users
    with the same address, as the MySQL unique constraint forbids this.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到用户，我们可以继续。由于 MySQL 唯一约束禁止这种情况，因此不可能有多个用户具有相同的地址。
- en: Next, we use the user's password and compare it with the submitted password,
    using the `bcrypt` package, as explained previously.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用用户的密码，并使用之前解释的 `bcrypt` 包将其与提交的密码进行比较。
- en: 'If the password was correct, we generate a JWT token for the `jwt` variable
    using the `jwt.sign` function. It takes three arguments: the payload, which is
    the user ID and their email address; the key that we sign the JWT with; and the
    amount of time in which the JWT is going to expire.'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果密码正确，我们使用 `jwt.sign` 函数为 `jwt` 变量生成 JWT 令牌。它接受三个参数：负载，即用户 ID 和他们的电子邮件地址；我们用于签名
    JWT 的密钥；以及 JWT 将要过期的时长。
- en: Finally, we return an object containing our JWT.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们返回一个包含我们的 JWT 的对象。
- en: Note
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Something that you might need to rethink is how much detail you give in an error
    message. For example, we might not want to distinguish between an incorrect password
    and a non-existent user. It allows possible attackers or data collectors to know
    which email address is in use.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可能需要重新思考的是错误消息中的详细程度。例如，我们可能不想区分密码错误和不存在用户的情况。这允许可能的攻击者或数据收集者知道哪个电子邮件地址正在使用。
- en: The `login` function is not working yet because we are missing `JWT_SECRET`,
    which is used to sign the JWT. In production, we use the environment variables
    to pass the JWT secret key into our backend code so that we can use this approach
    in development too.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`login` 函数尚未工作，因为我们缺少 `JWT_SECRET`，这是用于签名 JWT 的。在生产中，我们使用环境变量将 JWT 密钥传递到我们的后端代码中，以便我们也可以在开发中使用这种方法。'
- en: 'For Linux or Mac, type the following command directly in the Terminal:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 Linux 或 Mac，请在终端中直接输入以下命令：
- en: '[PRE9]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `export` function sets the `JWT_SECRET` environment variable for you. Replace
    the JWT provided with a random one. You can use any password generator by setting
    the character count to 128 and excluding any special characters. Setting the environment
    variable allows us to read the secret in our application. You must replace it
    when going to production.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`export` 函数为您设置 `JWT_SECRET` 环境变量。用随机生成的 JWT 替换提供的 JWT。您可以通过将字符数设置为 128 并排除任何特殊字符来使用任何密码生成器。设置环境变量允许我们在应用程序中读取密钥。您必须在进入生产环境时替换它。'
- en: 'Insert the following code at the top of the file:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部插入以下代码：
- en: '[PRE10]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code reads the environment variable from the global Node.js `process`
    object. Be sure to replace the JWT once you publish your application and be sure
    to always store the secret securely. After letting the server reload, we can send
    the first login request. We are going to learn how to do this in React later,
    but the following code shows an example of using Postman:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码从全局 Node.js `process` 对象中读取环境变量。一旦发布应用程序，请务必替换 JWT，并确保始终安全地存储密钥。在让服务器重新加载后，我们可以发送第一个登录请求。我们将在后面的
    React 中学习如何做到这一点，但以下代码展示了使用 Postman 的一个示例：
- en: '[PRE11]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This request should return a token:'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个请求应该返回一个令牌：
- en: '[PRE12]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, we have generated a signed JWT and returned it within the mutation's
    response. We can continue here and send the token with every request inside the
    HTTP authorization header. Then, we can get the authentication running for all
    the other GraphQL queries or mutations that we have implemented so far.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，我们已经生成并返回了一个签名 JWT。我们可以在每个请求的 HTTP 认证头中继续发送此令牌。然后，我们可以为迄今为止实现的全部 GraphQL
    查询或突变启动认证。
- en: Let's continue and learn how to set up React to work with our authentication
    on the backend.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续学习如何设置 React 以与后端上的认证一起工作。
- en: The React login form
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React 登录表单
- en: 'We need to handle the different authentication states of our application:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要处理我们应用程序的不同认证状态：
- en: The first scenario is that the user is not logged in and cannot see any posts
    or chats. In this case, we need to show a login form to allow the user to authenticate
    themselves.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种情况是用户未登录，无法查看任何帖子或聊天。在这种情况下，我们需要显示登录表单，以便用户可以验证自己。
- en: The second scenario is that an email and password are sent through the login
    form. The response needs to be interpreted, and if the result is correct, we need
    to save the JWT inside `localStorage` of the browser for now.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种情况是，通过登录表单发送电子邮件和密码。需要解释响应，如果结果是正确的，我们现在需要将JWT保存到浏览器的`localStorage`中。
- en: When changing `localStorage`, we also need to rerender our React application
    to show the logged-in state.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当更改`localStorage`时，我们还需要重新渲染我们的React应用程序以显示登录状态。
- en: Furthermore, the user should be able to log out again.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，用户应该能够再次注销。
- en: We must also be able to handle if the JWT expires and the user is unable to
    access any functionalities.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还必须能够处理JWT过期且用户无法访问任何功能的情况。
- en: 'The login form will look as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 登录表单将如下所示：
- en: '![Figure 6.2 – Login form'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.2 – 登录表单'
- en: '](img/Figure_6.02_B17337.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.02_B17337.jpg]'
- en: Figure 6.2 – Login form
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 6.2 – 登录表单
- en: 'To get started with the login form, follow these steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用登录表单，请按照以下步骤操作：
- en: Set up a separate login mutation file inside the `apollo` folder. It is likely
    that we only need this component in one place in our code, but it is a good idea
    to save GraphQL requests in separate files.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`apollo`文件夹内设置一个单独的登录突变文件。我们可能只需要在代码中的一个地方使用这个组件，但将GraphQL请求保存在单独的文件中是一个好主意。
- en: Build the login form component, which uses the login mutation to send the form
    data.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建登录表单组件，该组件使用登录突变发送表单数据。
- en: Create the `CurrentUser` query to retrieve the logged-in user object.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`CurrentUser`查询以检索已登录的用户对象。
- en: Conditionally render the login form if the user is not authenticated or the
    real application, such as the newsfeed, if the user is logged in.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户未认证或登录到真实应用程序（如新闻源），则条件渲染登录表单。
- en: 'We will begin by creating a new `login.js` file inside the `mutations` folder
    for the client components:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在客户端组件的`mutations`文件夹内创建一个新的`login.js`文件：
- en: '[PRE13]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As in the previous mutations, we parse the query string and export the `login`
    function from the `useMutation` Hook.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与之前的突变一样，我们解析查询字符串并从`useMutation`钩子中导出`login`函数。
- en: 'Now, we must implement the actual login form that uses this mutation. To do
    this, we will create a `loginregister.js` file directly inside the `components`
    folder. As you may expect, we handle the login and registration of users in one
    component. Import the dependencies first:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须实现使用此突变的实际登录表单。为此，我们将在`components`文件夹内直接创建一个`loginregister.js`文件。正如你所预期的，我们在一个组件中处理用户的登录和注册。首先导入依赖项：
- en: '[PRE14]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `LoginForm` component will store the form state, display an error message
    if something goes wrong, show a loading state, and send the login mutation, including
    the form data. Add the following code beneath the `import` statements:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LoginForm`组件将存储表单状态，如果出现错误则显示错误消息，显示加载状态，并发送包含表单数据的登录突变。在`import`语句下方添加以下代码：'
- en: '[PRE15]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The overall React component is pretty straightforward. We just have one form
    and two inputs and we store their values in two state variables. The `onSubmit`
    function is called when the form is submitted, which will then trigger the login
    mutation. The `update` function of the mutation will be a bit different than the
    other mutations we have had so far. We don't write the return value in the Apollo
    cache; instead, we store the JWT inside `localStorage`. The syntax is pretty simple.
    You can directly use `localStorage.get` and `localStorage.set` to interact with
    the web storage.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 整个React组件相当简单。我们只有一个表单和两个输入，并将它们的值存储在两个状态变量中。当表单提交时，会调用`onSubmit`函数，这将触发登录突变。突变的`update`函数将与其他突变有所不同。我们不在Apollo缓存中写入返回值；相反，我们在`localStorage`中存储JWT。语法相当简单。你可以直接使用`localStorage.get`和`localStorage.set`与Web存储进行交互。
- en: After saving the JWT to `localStorage`, we call a `changeLoginState` function,
    which we will implement in the next step. The idea of this function is to have
    one global switch to change a user from logged in to logged out or vice versa.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在将JWT保存到`localStorage`之后，我们调用一个`changeLoginState`函数，我们将在下一步实现它。这个函数的目的是有一个全局开关，用于将用户从登录状态切换到注销状态，或反之。
- en: We now need to export a component that will be used by our application. The
    easiest thing to do is set up a wrapper component that handles the login and sign-up
    cases for us.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要导出一个将被我们的应用程序使用的组件。最简单的方法是设置一个包装组件，该组件为我们处理登录和注册情况。
- en: 'Insert the following code for the wrapper component:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为包装组件插入以下代码：
- en: '[PRE16]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This component just renders the login form and passes the `changeLoginState`
    function.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个组件只是渲染登录表单并传递`changeLoginState`函数。
- en: All the basics for authenticating the user are now ready, but they have not
    been imported yet or displayed anywhere. Open the `App.js` file. There, we will
    directly display the feed, chats, and the top bar. The user should not be allowed
    to see everything if they are not logged in. Continue reading to change this.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有用于验证用户的基本功能现在都已准备就绪，但尚未导入或显示在任何地方。打开`App.js`文件。在那里，我们将直接显示动态内容、聊天和顶部栏。如果用户未登录，不应允许他们看到一切。继续阅读以更改此设置。
- en: 'Import the new form that we have just created and import the `useEffect` Hook
    from React:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们刚刚创建的新表单和从React导入的`useEffect`钩子：
- en: '[PRE17]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we must store whether the user is logged in or not and, also on the first
    render of our application, check the login state based on `localStorage`. Add
    the following code to the `App` component:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须存储用户是否已登录，以及在我们应用程序的第一次渲染中，根据`localStorage`检查登录状态。将以下代码添加到`App`组件中：
- en: '[PRE18]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When loading our page, we have the `loggedIn` state variable to store the current
    logged-in status inside. The default value is either `true` if the token exists
    or `false` if not.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当加载我们的页面时，我们有一个`loggedIn`状态变量来存储当前的登录状态。默认值是如果存在令牌则为`true`，如果不存在则为`false`。
- en: 'Then, in the `return` statement, we can use conditional rendering to show the
    login form when the `loggedIn` state variable is set to `false`, which means that
    there is no JWT inside our `localStorage`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`return`语句中，我们可以使用条件渲染来显示登录表单，当`loggedIn`状态变量设置为`false`时，这意味着我们的`localStorage`中没有JWT：
- en: '[PRE19]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, we pass the `setLoggedIn` function to the login form, which
    is then able to trigger a logged-in state so that React can rerender and show
    the logged-in area. We call this property `changeLoginState` and use it inside
    the login form inside the `update` method in the login mutation.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们将`setLoggedIn`函数传递给登录表单，这使得它能够触发登录状态，以便React可以重新渲染并显示登录区域。我们称这个属性为`changeLoginState`，并在登录突变的`update`方法中登录表单内部使用它。
- en: 'Add the CSS from the official GitHub repository:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从官方GitHub仓库添加CSS：
- en: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition)'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition)'
- en: Once we've logged in, our application will present us with the common posts
    feed, as it did previously. The authentication flow is now working, but there
    is one more open task. In the next section, we will allow new users to register
    at Graphbook.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们登录，我们的应用程序将展示常见的帖子动态内容，就像之前一样。认证流程现在正在工作，但还有一个未完成的任务。在下一节中，我们将允许新用户在Graphbook上注册。
- en: Apollo signup mutation
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Apollo注册突变
- en: 'You should now be familiar with creating new mutations. To do so, follow these
    steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该熟悉创建新的突变。要这样做，请遵循以下步骤：
- en: 'First, edit the schema to accept the new mutation:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，编辑模式以接受新的突变：
- en: '[PRE20]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We only need the `username`, `email`, and `password` properties, which were
    mentioned in the preceding code, to accept new users. If your application requires
    a gender or something else, you can add it here. When we're trying to sign up,
    we need to ensure that neither the email address nor the username has already
    been taken.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们只需要`username`、`email`和`password`属性，这些在前面代码中已提及，以接受新用户。如果你的应用程序需要性别或其他信息，你可以在这里添加。当我们尝试注册时，我们需要确保电子邮件地址和用户名尚未被占用。
- en: 'Copy over the code to implement the resolver for signing up new users:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码复制以实现为新用户注册的解析器：
- en: '[PRE21]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s go through this code step by step:'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们一步一步地通过这段代码：
- en: As we mentioned previously, first, we must check if a user with the same email
    or username exists. If this is the case, we throw an error. We use the `Op.or`
    Sequelize operator to implement the MySQL OR condition.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如我们之前提到的，首先，我们必须检查是否存在具有相同电子邮件或用户名的用户。如果是这样，我们抛出一个错误。我们使用Sequelize的`Op.or`运算符来实现MySQL的OR条件。
- en: If the user does not exist, we can hash the password using `bcrypt`. You cannot
    save the plain password for security reasons. When running the `bcrypt.hash` function,
    a random salt is used to make sure nobody ever gets access to the original password.
    This command takes quite some computing time, so the `bcrypt.hash` function is
    asynchronous, and the promise must be resolved before we continue.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户不存在，我们可以使用 `bcrypt` 对密码进行散列。出于安全原因，您不能保存明文密码。当运行 `bcrypt.hash` 函数时，会使用随机盐来确保没有人能够访问原始密码。这个命令需要相当多的计算时间，所以
    `bcrypt.hash` 函数是异步的，我们必须在继续之前解决这个承诺。
- en: The encrypted password, including the other data the user has sent, is then
    inserted into our database as a new user.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加密的密码，包括用户发送的其他数据，随后被插入到我们的数据库中作为新用户。
- en: After creating the user, we generate a JWT and return it to the client. The
    JWT allows us to log the user in directly once they've signed up. If you do not
    want this behavior, you can just return a message to indicate that the user has
    signed up successfully.
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建用户后，我们生成一个 JWT 并将其返回给客户端。JWT 允许我们在用户注册后直接登录。如果您不希望这种行为，您只需返回一条消息来指示用户已成功注册。
- en: Now, you can test the `signup` mutation again with Postman while starting the
    backend using `npm run server`. With that, we have finished the backend implementation.
    So, let's start working on the frontend.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在使用 `npm run server` 启动后端的同时，再次使用 Postman 测试 `signup` 突变。这样，我们就完成了后端实现。那么，让我们开始前端的工作。
- en: React signup form
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React 注册表单
- en: 'The registration form is nothing special. We will follow the same steps that
    we took with the login form:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表单没有什么特别之处。我们将遵循与登录表单相同的步骤：
- en: Clone the `LoginMutation` component, replace the request at the top with the
    `signup` mutation, and hand over the `signup` method to the underlying children.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制 `LoginMutation` 组件，将顶部的请求替换为 `signup` 突变，并将 `signup` 方法传递给底层的子组件。
- en: 'At the top, import all the dependencies and then parse the new query:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部，导入所有依赖项，然后解析新的查询：
- en: '[PRE22]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, the `username` field is new here, which we send with every `signup`
    request. The logic itself has not changed, so we still extract the JWT from the
    `signup` field when logging the user in after a successful request.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，这里的 `username` 字段是新的，我们将其与每个 `signup` 请求一起发送。逻辑本身并没有改变，所以我们仍然在请求成功后从 `signup`
    字段中提取 JWT 来登录用户。
- en: 'It''s good to see that the `login` and `signup` mutations are quite similar.
    The biggest change is that we conditionally render the login form or the registration
    form. Follow these steps:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 很好看到 `login` 和 `signup` 突变相当相似。最大的变化是我们有条件地渲染登录表单或注册表单。按照以下步骤操作：
- en: 'Import the new mutation into the `loginregister.js` file:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的突变导入到 `loginregister.js` 文件中：
- en: '[PRE23]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, replace the complete `LoginRegisterForm` component with the following
    new one:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，用以下新的组件替换完整的 `LoginRegisterForm` 组件：
- en: '[PRE24]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You should notice that we are storing a `showLogin` variable in the component
    state. This decides if the login or register component is shown, which handles
    the actual business logic.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该注意到我们在组件状态中存储了一个 `showLogin` 变量。这个变量决定是否显示登录或注册组件，这处理了实际的业务逻辑。
- en: 'Then, add a separate component for the register form before the export statement:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在导出语句之前添加一个用于注册表单的单独组件：
- en: '[PRE25]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, I added the `username` field, which must be given to
    the mutation. Everything is now set to invite new users to join our social network
    and log in as often as they want.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我添加了 `username` 字段，这个字段必须提供给突变。现在一切设置完毕，可以邀请新用户加入我们的社交网络，并且他们可以随时登录。
- en: In the next section, we will learn how to use authentication with our existing
    GraphQL requests.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何在我们现有的 GraphQL 请求中使用身份验证。
- en: Authenticating GraphQL requests
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证 GraphQL 请求
- en: 'The problem is that we are not using authentication everywhere at the moment.
    We are verifying that the user is who they say they are, but we are not rechecking
    this when the requests for chats or messages come in. To accomplish this, we must
    send the JWT token, which we generated specifically for this case, with every
    Apollo request. On the backend, we must specify which request requires authentication,
    read the JWT from the HTTP authorization header, and verify it. Follow these steps:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是我们目前并没有在所有地方使用身份验证。我们正在验证用户是否是他们所说的那个人，但在收到聊天或消息请求时并没有重新检查这一点。为了完成这个任务，我们必须在每个
    Apollo 请求中发送我们专门为此情况生成的 JWT 令牌。在后端，我们必须指定哪些请求需要身份验证，从 HTTP 授权头中读取 JWT 并验证它。按照以下步骤操作：
- en: 'Open the `index.js` file from the `apollo` folder for the client-side code.
    Our `ApolloClient` is currently configured as explained in [*Chapter 4*](B17337_04_Final_ASB_ePub.xhtml#_idTextAnchor085),
    *Hooking Apollo into React*. Before we send any requests, we must read the JWT
    from `localStorage` and add it as an HTTP authorization header. Inside the `link`
    property, we have specified the links for our `ApolloClient` processes. Before
    we configure the HTTP link, we must insert a third preprocessing Hook, as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`apollo`文件夹中的`index.js`文件以获取客户端代码。我们的`ApolloClient`当前配置如[*第4章*](B17337_04_Final_ASB_ePub.xhtml#_idTextAnchor085)中所述，*将Apollo集成到React中*。在我们发送任何请求之前，我们必须从`localStorage`中读取JWT并将其添加为HTTP授权头。在`link`属性中，我们已指定了`ApolloClient`处理过程的链接。在我们配置HTTP链接之前，我们必须插入一个第三个预处理钩子，如下所示：
- en: '[PRE26]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we have called the new link `AuthLink` because it allows us to authenticate
    the client on the server. You can copy the `AuthLink` approach for other situations
    where you need to customize the header of your Apollo requests. Here, we just
    read the JWT from `localStorage` and, if it is found, we construct the header
    using the spread operator and add our token to the `Authorization` field as a
    Bearer Token. This is everything that needs to be done on the client side.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，我们称新的链接为`AuthLink`，因为它允许我们在服务器上对客户端进行身份验证。您可以将`AuthLink`方法复制到需要自定义Apollo请求头的其他情况中。在这里，我们只是从`localStorage`读取JWT，如果找到，我们使用扩展运算符构建头，并将我们的令牌添加到`Authorization`字段作为Bearer
    Token。这就是客户端需要完成的所有事情。
- en: 'To clarify things, take a look at the following `link` property to learn how
    to use this new preprocessor. No initialization is required; it is merely a function
    that is called every time a request is made. Copy the `link` configuration to
    our Apollo Client setup:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了澄清问题，请查看以下`link`属性以了解如何使用这个新的预处理器。不需要初始化；它只是一个在每次请求时被调用的函数。将`link`配置复制到我们的Apollo客户端设置中：
- en: '[PRE27]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s install one dependency that we require:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们安装一个我们需要的依赖项：
- en: '[PRE28]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For our backend, we need a pretty complex solution. Create a new file called
    `auth.js` inside the GraphQL `services` folder. We want to be able to mark specific
    GraphQL requests in our schema with a so-called directive. If we add this directive
    to our GraphQL schema, we can execute a function whenever the marked GraphQL action
    is requested. In this function, we can verify whether the user is logged in or
    not. Have a look at the following function and save it in the `auth.js` file:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的后端，我们需要一个相当复杂的解决方案。在GraphQL的`services`文件夹中创建一个名为`auth.js`的新文件。我们希望能够在我们的模式中用所谓的指令标记特定的GraphQL请求。如果我们将此指令添加到我们的GraphQL模式中，我们可以在标记的GraphQL操作被请求时执行一个函数。在这个函数中，我们可以验证用户是否已登录。查看以下函数并将其保存到`auth.js`文件中：
- en: '[PRE29]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Starting from the top, we import three things from the `@graphql/utils` package:'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从顶部开始，我们从`@graphql/utils`包中导入三样东西：
- en: The `mapSchema` function takes two arguments. The first is the actual GraphQL
    schema and then an object of functions that can transform the schema.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mapSchema`函数接受两个参数。第一个是实际的GraphQL模式，然后是一个可以转换模式的函数对象。'
- en: The `getDirective` function will read the schema and try to get the specified
    `directiveName`. Based on that, we can do anything that we want.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getDirective`函数将读取模式并尝试获取指定的`directiveName`。基于此，我们可以做我们想要做的任何事情。'
- en: '`MapperKind` is just a set of types that we can use. We are using that to only
    run functions for specific types.'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MapperKind`只是一组我们可以使用的类型。我们正在使用它来只为特定类型运行函数。'
- en: This function or directive will read the user from the context and pass it to
    our resolvers where the directive is specified within our GraphQL schema.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数或指令将读取用户从上下文，并将其传递到我们的解析器中，其中指令在我们的GraphQL模式中指定。
- en: 'We must load the new `authDirective` function in the `graphql` `index.js` file,
    which sets up the whole Apollo Server:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须在`graphql`的`index.js`文件中加载新的`authDirective`函数，该函数设置了整个Apollo Server：
- en: '[PRE30]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Before we create our executable schema, we must extract the new schema transformer
    from the `authDirective` function. After creating the executable schema, we must
    pass it to the transformer so that `authDirective` starts to work. Replace the
    current schema creation with the following code:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们创建可执行模式之前，我们必须从`authDirective`函数中提取新的模式转换器。在创建可执行模式后，我们必须将其传递给转换器，以便`authDirective`开始工作。用以下代码替换当前的方案创建：
- en: '[PRE31]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To verify what we have just done, go to the GraphQL schema and edit `postsFeed`
    `RootQuery` by adding `@auth` to the end of the line, like this:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证我们刚刚所做的工作，请转到GraphQL模式并编辑`postsFeed` `RootQuery`，在行尾添加`@auth`，如下所示：
- en: '[PRE32]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Because we are using a new directive, we also must define it in our GraphQL
    schema so that our server knows about it. Copy the following code directly to
    the top of the schema:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在使用一个新的指令，我们还需要在我们的 GraphQL 模式中定义它，以便我们的服务器了解它。将以下代码直接复制到模式的最顶部：
- en: '[PRE33]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This tiny snippet tells Apollo Server that the `@auth` directive can be used
    with queries, fields, and field definitions so that we can use it everywhere.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段简短的内容告诉 Apollo Server，`@auth` 指令可以与查询、字段和字段定义一起使用，这样我们就可以在所有地方使用它。
- en: 'If you reload the page and manually set the `loggedIn` state variable to true
    via React Developer Tools, you will see the following error message:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您重新加载页面并通过 React Developer Tools 手动将 `loggedIn` 状态变量设置为 true，您将看到以下错误消息：
- en: '![Figure 6.3 – GraphQL login error'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.3 – GraphQL login error]'
- en: '](img/Figure_6.03_B17337.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_6.03_B17337.jpg]'
- en: Figure 6.3 – GraphQL login error
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – GraphQL 登录错误
- en: Since we implemented the error component earlier, we are now correctly receiving
    an unauthenticated error for the `postsFeed` query if the user is not logged in.
    How can we use the JWT to identify the user and add it to the request context?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前实现了错误组件，现在如果用户未登录，我们正在正确地接收到 `postsFeed` 查询的无权限错误。我们如何使用 JWT 来识别用户并将其添加到请求上下文中？
- en: Note
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Schema directives are a complex topic as there are many important things to
    bear in mind regarding Apollo and GraphQL. I recommend that you read up on directives
    in detail in the official Apollo documentation: [https://www.graphql-tools.com/docs/introduction](https://www.graphql-tools.com/docs/introduction).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 模式指令是一个复杂的话题，因为关于 Apollo 和 GraphQL 有许多重要的事情需要记住。我建议您在官方 Apollo 文档中详细了解指令：[https://www.graphql-tools.com/docs/introduction](https://www.graphql-tools.com/docs/introduction)。
- en: 'In [*Chapter 2*](B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032), *Setting
    Up GraphQL with Express.js*, we set up Apollo Server by providing the executable
    schema and the context, which has been the request object until now. We must check
    if the JWT is inside the request. If this is the case, we need to verify it and
    query the user to see if the token is valid. Let''s start by verifying the authorization
    header. Before doing so, import the new dependencies into the GraphQL `index.js`
    file:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 2 章*](B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032) *使用 Express.js
    设置 GraphQL* 中，我们通过提供可执行模式和上下文来设置 Apollo Server，直到现在上下文一直是请求对象。我们必须检查 JWT 是否在请求中。如果是这种情况，我们需要验证它并查询用户以查看令牌是否有效。让我们先验证授权头。在这样做之前，将新依赖项导入到
    GraphQL 的 `index.js` 文件中：
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `context` field of the `ApolloServer` initialization must look as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApolloServer` 初始化的 `context` 字段必须如下所示：'
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we have extended the `context` property of the `ApolloServer` class to
    a full-featured function. We read the `auth` token from the headers of the requests.
    If the `auth` token exists, we need to strip out the bearer string, because it
    is not part of the original token that was created by our backend. The Bearer
    Token is the best method of JWT authentication.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `ApolloServer` 类的 `context` 属性扩展为一个功能齐全的函数。我们从请求的头部读取 `auth` 令牌。如果 `auth`
    令牌存在，我们需要移除携带者字符串，因为它不是我们后端创建的原始令牌的一部分。携带者令牌是 JWT 身份验证的最佳方法。
- en: Note
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are other authentication methods available, such as basic authentication,
    but the bearer method is the best to follow. You can find a detailed explanation
    under RFC6750 by the IETF at [https://tools.ietf.org/html/rfc6750](https://tools.ietf.org/html/rfc6750).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的其他身份验证方法还有基本身份验证等，但携带者方法是最佳选择。您可以在 IETF 的 RFC6750 中找到详细说明：[https://tools.ietf.org/html/rfc6750](https://tools.ietf.org/html/rfc6750)。
- en: 'Afterward, we must use the `JWT.verify` function to check if the token matches
    the signature that''s been generated by the secret from the environment variables.
    The next step is to retrieve the user once they''ve been verified successfully.
    Replace the content of the `verify` callback with the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们必须使用 `JWT.verify` 函数来检查令牌是否与从环境变量中生成的密钥创建的签名匹配。下一步是验证成功后检索用户。将 `verify`
    回调的内容替换为以下代码：
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If the `err` object in the previous code has been filled, we can only return
    the ordinary request object, which triggers an error when it reaches the `auth`
    directive, since there is no user attached. If there are no errors, we can use
    the `utils` object we are already passing to the Apollo Server setup to access
    the database. If you need a reminder, take a look at [*Chapter 2*](B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032),
    *Setting Up GraphQL with Express.js*. After querying the user, we must add them
    to the request object and return the merged user and request object as the context.
    This leads to a successful response from our authorizing directive.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前一段代码中的`err`对象已被填充，我们只能返回普通的请求对象，当它到达`auth`指令时将触发错误，因为没有附加用户。如果没有错误，我们可以使用我们已经在Apollo
    Server设置中传递的`utils`对象来访问数据库。如果你需要提醒，请查看[*第2章*](B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032)，*使用Express.js设置GraphQL*。在查询用户后，我们必须将其添加到请求对象中，并将合并后的用户和请求对象作为上下文返回。这导致我们的授权指令返回成功响应。
- en: Now, let's test this behavior. Start the frontend with `npm run client` and
    the backend using `npm run server`. Don't forget that all Postman requests now
    have to include a valid JWT if the `auth` directive is used in the GraphQL query.
    You can run the login mutation and copy it over to the authorization header to
    run any query. We are now able to mark any query or mutation with the authorization
    flag and, as a result, require the user to be logged in.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试这种行为。使用`npm run client`启动前端，使用`npm run server`启动后端。别忘了，现在所有Postman请求都必须包含有效的JWT，如果GraphQL查询中使用了`auth`指令。你可以运行登录突变，并将其复制到授权头中运行任何查询。我们现在能够将任何查询或突变标记为授权标志，并因此要求用户登录。
- en: Accessing the user context from resolver functions
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从解析函数中访问用户上下文
- en: At the moment, all the API functions of our GraphQL server allow us to simulate
    the user by selecting the first that's available from the database. As we have
    just introduced a full-fledged authentication, we can now access the user from
    the request context. This section quickly explains how to do this for the chat
    and message entities. We will also implement a new query called `currentUser`,
    where we retrieve the logged-in user in our client.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们GraphQL服务器的所有API函数都允许我们通过从数据库中选择可用的第一个来模拟用户。正如我们刚刚引入了完整的认证，我们现在可以从请求上下文中访问用户。本节将快速解释如何为聊天和消息实体执行此操作。我们还将实现一个名为`currentUser`的新查询，在我们的客户端中检索登录用户。
- en: Chats and messages
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聊天和消息
- en: First of all, you must add the `@auth` directive to the chats inside GraphQL's
    `RootQuery` to ensure that users need to be logged in to access any chats or messages.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须将`@auth`指令添加到GraphQL的`RootQuery`中的聊天，以确保用户需要登录才能访问任何聊天或消息。
- en: 'Take a look at the resolver function for the chats. Currently, we are using
    the `findAll` method to get all users, take the first one, and query for all the
    user''s chats. Replace this code with the following new resolver function:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下聊天解析函数。目前，我们使用`findAll`方法获取所有用户，取第一个，并查询该用户的所有聊天。用以下新的解析函数替换此代码：
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, we don''t retrieve the user; instead, we directly insert the user ID
    from the context, as shown in the preceding code. That''s all we have to do: all
    the chats and messages that belong to the logged-in user are queried directly
    from the chats table.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不检索用户；而是直接从上下文中插入用户ID，如前述代码所示。这就是我们必须要做的：所有属于登录用户的聊天和消息都直接从聊天表中查询。
- en: We would need to copy this for the mutations for chats and messages and all
    the other queries and mutations that we have at the moment.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要复制这部分代码以用于聊天、消息以及其他当前我们拥有的所有查询和突变。
- en: CurrentUser GraphQL query
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CurrentUser GraphQL查询
- en: 'JWTs allow us to query for the currently logged-in user. Then, we can display
    the correct authenticated user in the top bar. To request the logged-in user,
    we require a new query called `currentUser` on our backend. In the schema, you
    simply have to add the following line to the `RootQuery` queries:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: JWTs允许我们查询当前登录的用户。然后，我们可以在顶部栏中显示正确的认证用户。为了请求登录用户，我们在后端需要一个名为`currentUser`的新查询。在模式中，你只需将以下行添加到`RootQuery`查询中：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Like the `postsFeed` and `chats` queries, we also need the `@auth` directive
    to extract the user from the request context.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`postsFeed`和`chats`查询一样，我们还需要`@auth`指令来从请求上下文中提取用户。
- en: 'Similarly, in the resolver functions, you only need to insert the following
    three lines:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在解析函数中，你只需要插入以下三行：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We return the user from the context right away, because it is already a user
    model instance with all the appropriate data being returned by Sequelize. On the
    client side, we create this query in a separate component and file. Bear in mind
    that you don''t need to pass the result to all the children because this is done
    automatically by `ApolloConsumer` later. You can follow the previous query component
    examples to see this. Just create a file called `currentUserQuery.js` in the `queries`
    folder with the following content:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们立即从上下文中返回用户，因为它已经是一个包含所有适当数据（由Sequelize返回）的用户模型实例。在客户端，我们在单独的组件和文件中创建此查询。请注意，你不需要将结果传递给所有子组件，因为这是由`ApolloConsumer`后来自动完成的。你可以通过查看之前的查询组件示例来了解这一点。只需在`queries`文件夹中创建一个名为`currentUserQuery.js`的文件，并包含以下内容：
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, you can import the new query inside the `App.js` file and add the following
    line to the `App` component:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在`App.js`文件中导入新的查询，并将以下行添加到`App`组件中：
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we executed the `useCurrentUserQuery` Hook to ensure that the query has
    been executed at a global level for all the components. Also, we show a loading
    indicator until the request has finished to ensure that the user is loaded before
    we do anything else.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们执行了`useCurrentUserQuery`钩子以确保查询在全局范围内对所有组件执行。此外，我们显示一个加载指示器，直到请求完成，以确保在我们做其他任何事情之前用户已经加载。
- en: Every time the `loggedIn` state variable is `true`, we render the components.
    To get access to the response, we must use `ApolloConsumer` in the bar component,
    which we implemented in the previous chapter. We run the `currentUser` query in
    the `App.js` file to ensure that all the child components can rely on the Apollo
    cache to access the user before being rendered.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 每当`loggedIn`状态变量为`true`时，我们渲染组件。为了获取响应，我们必须在上一章中实现的`bar`组件中使用`ApolloConsumer`。我们在`App.js`文件中运行`currentUser`查询，以确保所有子组件可以在渲染之前依赖Apollo缓存来访问用户。
- en: 'Instead of having a hardcoded fake user inside `ApolloConsumer`, we can use
    the the `client.readQuery` function to extract the data stored in the `ApolloClient`
    cache to give it to the underlying child component. Replace the current consumer
    with the following code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在`ApolloConsumer`内部使用硬编码的假用户，我们可以使用`client.readQuery`函数从`ApolloClient`缓存中提取数据，并将其提供给底层的子组件。用以下代码替换当前的消费者：
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we passed the extracted `currentUser` result from the `client.readQuery`
    method to all the wrapped children of the current component.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将从`client.readQuery`方法中提取的`currentUser`结果传递给当前组件的所有包装子组件。
- en: The chats that are displayed from now on, as well as the user in the top bar,
    are no longer faked; instead, they are filled with the data related to the logged-in
    user.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始显示的聊天以及顶部栏中的用户，不再是伪造的；相反，它们被与已登录用户相关的数据填充。
- en: The mutations to create new posts or messages still use a static user ID. We
    can switch over to the real logged-in user in the same way as we did previously
    in this section by using the user ID from the `context.user` object. You should
    now be able to do this on your own.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新帖子或消息的突变仍然使用静态用户ID。我们可以通过使用`context.user`对象中的用户ID，以与我们在本节之前相同的方式切换到真正的已登录用户。你现在应该能够自己做到这一点。
- en: Logging out using React
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用React注销
- en: 'To complete the circle, we still have to implement the functionality to log
    out. There are two cases when the user can be logged out:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成闭环，我们仍然需要实现注销功能。当用户可以注销时，有两种情况：
- en: The user wants to log out and hits the logout button.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户想要注销并点击注销按钮。
- en: The JWT has expired after 1 day as specified; the user is no longer authenticated,
    and we have to set the state to logged out.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据指定的1天后JWT已过期；用户不再认证，我们必须将状态设置为注销。
- en: 'Follow these steps to accomplish this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此操作：
- en: 'We will begin by adding a new logout button to the top bar of our application''s
    frontend. To do this, create a new `logout.js` component inside the `bar` folder.
    It should look as follows:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在我们的应用程序前端顶部栏添加一个新的注销按钮。为此，在`bar`文件夹内创建一个新的`logout.js`组件。它应该看起来如下：
- en: '[PRE43]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see, the logout button triggers the component's logout method when
    it is clicked. Inside the `logout` method, we remove the JWT from `localStorage`
    and execute the `changeLoginState` function that we receive from the parent component.
    Be aware that we do not send a request to our server to log out; instead, we remove
    the token from the client. This is because there is no black or white list that
    we are using to disallow or allow a certain JWT to authenticate on our server.
    The easiest way to log out a user is to remove the token on the client side so
    that neither the server nor the client has it.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，当点击登出按钮时，它将触发组件的登出方法。在`logout`方法内部，我们从`localStorage`中删除JWT并执行我们从父组件接收到的`changeLoginState`函数。请注意，我们没有向我们的服务器发送请求来登出；相反，我们从客户端删除了令牌。这是因为我们没有使用黑白名单来禁止或允许某些JWT在我们的服务器上进行认证。最简单的方法是在客户端删除令牌，这样服务器和客户端都没有它。
- en: We also reset the client cache. When a user logs out, we must remove all data.
    Otherwise, other users on the same browser will be able to extract all the data,
    which we must prevent. To gain access to the underlying Apollo Client, we must
    import the `withApollo` `Logout` component wrapped inside it. When logging out,
    we must execute the `client.stop` and `client.resetStore` functions so that all
    the data is deleted.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还重置了客户端缓存。当用户登出时，我们必须删除所有数据。否则，同一浏览器上的其他用户将能够提取所有数据，这是我们必须防止的。为了访问底层的Apollo
    Client，我们必须导入包裹在其中的`withApollo` `Logout`组件。在登出时，我们必须执行`client.stop`和`client.resetStore`函数，以便删除所有数据。
- en: 'To use our new `Logout` component, open the `index.js` file from the `bar`
    folder and import it at the top. We can render it within the `div` top bar, below
    the other inner `div` tag:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用我们新的`Logout`组件，打开`bar`文件夹中的`index.js`文件，并在顶部导入它。我们可以在顶部的`div`顶部栏中渲染它，位于其他内部`div`标签下方：
- en: '[PRE44]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we pass the `changeLoginState` function to the `Logout` component.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将`changeLoginState`函数传递给`Logout`组件。
- en: 'Extract the `changeLoginState` function from the `Bar` component props, as
    follows:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Bar`组件的props中提取`changeLoginState`函数，如下所示：
- en: '[PRE45]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the `App.js` file, you must implement one more function to handle the current
    user query correctly. If we are not logged in and then log in, we need to fetch
    the current user. And if we log out, we need to either set or be able to easily
    fetch the current user query again. Add the following function:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App.js`文件中，你必须实现一个额外的函数来正确处理当前用户查询。如果我们未登录然后登录，我们需要获取当前用户。如果我们登出，我们需要设置或能够轻松地再次获取当前用户查询。添加以下函数：
- en: '[PRE46]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Hand this function over not only to `LoginRegisterForm` but also to the `Bar`
    component, as follows:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此函数不仅传递给`LoginRegisterForm`，还传递给`Bar`组件，如下所示：
- en: '[PRE47]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If you copy the complete CSS from the official GitHub repository, you should
    see a new button at the top-right corner of the screen when you are logged in.
    Hitting it logs you out and requires you to sign in again since the JWT has been
    deleted.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你从官方GitHub仓库复制完整的CSS，当你登录时，你应该在屏幕右上角看到一个新按钮。点击它将你登出，并要求你再次登录，因为JWT已被删除。
- en: 'The other situation in which we implement logout functionality is when the
    JWT we are using expires. In this case, we log the user out automatically and
    require them to log in again. Go to the `App` component and add the following
    lines:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现登出功能的另一种情况是我们使用的JWT过期。在这种情况下，我们会自动登出用户，并要求他们再次登录。转到`App`组件，并添加以下行：
- en: '[PRE48]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we are using the `client.onClearStore` event, which is caught through
    the `client.onClearStore` function once the client store is cleared.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用的是`client.onClearStore`事件，该事件通过`client.onClearStore`函数在客户端存储被清除时捕获。
- en: 'To get the preceding code to work, we must access the Apollo Client in our
    `App` component. The easiest way to do this is to use the `withApollo` HoC. Just
    import it from the `@apollo/client` package in the `App.js` file:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使前面的代码正常工作，我们必须在我们的`App`组件中访问Apollo Client。最简单的方法是在`App.js`文件中使用`withApollo`
    HoC。只需从`@apollo/client`包中导入它：
- en: '[PRE49]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, export the `App` component – not directly, but through the HoC – and
    extract the `client` property. The following code must go directly beneath the
    `App` component:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过高阶组件（HoC）导出`App`组件——不是直接导出，而是通过HoC——并提取`client`属性。以下代码必须直接位于`App`组件下方：
- en: '[PRE50]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, the component can access the client through its properties. The `clearStore`
    event is thrown whenever the client restore is reset, as its name suggests. You
    are going to see why we need this shortly. When listening to events in React,
    we have to stop listening when the component is unmounted. We handle this inside
    the `useEffect` Hook in the preceding code. Now, we must reset the client store
    to initiate the logout state. When the event is caught, we execute the `changeLoginState`
    function automatically. Consequently, we could remove the section that we passed
    `changeLoginState` to the logout button initially because it is no longer needed,
    but this is not what we want to do here.
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，组件可以通过其属性访问客户端。每当客户端恢复被重置时，就会抛出`clearStore`事件，正如其名称所暗示的。你很快就会看到为什么我们需要这个。在React中监听事件时，我们必须在组件卸载时停止监听。我们在前面的代码中的`useEffect`
    Hook中处理这个问题。现在，我们必须重置客户端存储以启动注销状态。当事件被捕获时，我们会自动执行`changeLoginState`函数。因此，我们可以移除最初传递给注销按钮的`changeLoginState`部分，因为不再需要它，但这里我们并不想这样做。
- en: 'Extract the client from the `App` component props, like so:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`App`组件的props中提取客户端，如下所示：
- en: '[PRE51]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Go to the `index.js` file in the `apollo` folder. There, we already caught
    and looped over all the errors that were returned from our GraphQL API. What we
    must do now is loop over all the errors but check each of them for an `UNAUTHENTICATED`
    error. Then, we must execute the `client.clearStore` function. Insert the following
    code into the Apollo Client setup:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`apollo`文件夹中的`index.js`文件。在那里，我们已经捕获并遍历了从我们的GraphQL API返回的所有错误。我们现在必须遍历所有错误，但检查每个错误是否包含`UNAUTHENTICATED`错误。然后，我们必须执行`client.clearStore`函数。将以下代码插入到Apollo客户端设置中：
- en: '[PRE52]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As you can see, we access the `extensions` property of the error. The `extensions.code`
    field holds the specific error type that's returned. If we are not logged in,
    we remove the JWT and then reset the store. By doing this, we trigger the event
    in our `App` component, which sends the user back to the login form.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们访问了错误的`extensions`属性。`extensions.code`字段持有返回的具体错误类型。如果我们没有登录，我们会移除JWT然后重置存储。通过这样做，我们在`App`组件中触发事件，将用户送回登录表单。
- en: A further extension would be to offer a refresh token API function. This feature
    could be run every time we successfully use the API. The problem with this is
    that the user would stay logged in forever, so long as they are using the application.
    Usually, this is not a problem, but if someone else is accessing the same computer,
    they will be authenticated as the original user. There are different ways to implement
    these kinds of functionalities to make the user experience more comfortable, but
    I am not a big fan of these for security reasons.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步的扩展将是提供一个刷新令牌API函数。这个功能可以在我们每次成功使用API时运行。这个问题是用户将永远保持登录状态，只要他们使用应用程序。通常这并不是问题，但如果其他人正在访问同一台计算机，他们将作为原始用户进行认证。有不同方式实现这些功能以使用户体验更舒适，但我并不是很喜欢这些功能，出于安全原因。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Until now, one of the main issues we had with our application is that we didn't
    have any authentication. We can now tell who is logged in every time a user accesses
    our application. This allows us to secure the GraphQL API and insert new posts
    or messages into the name of the correct user. In this chapter, we discussed the
    fundamental aspects of JWTs, `localStorage`, and cookies. We also looked at how
    hashed password verification and signed tokens work. We then covered how to implement
    JWTs inside React and how to trigger the correct events to log in and log out.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应用程序的主要问题之一是我们没有进行任何认证。现在，每当用户访问我们的应用程序时，我们都可以知道谁登录了。这允许我们保护GraphQL
    API，并以正确用户的身份插入新的帖子或消息。在本章中，我们讨论了JWT、`localStorage`和cookie的基本方面。我们还探讨了散列密码验证和签名令牌的工作原理。然后，我们介绍了如何在React中实现JWT以及如何触发登录和注销的正确事件。
- en: In the next chapter, we are going to implement image uploads with a reusable
    component that allows the user to upload new avatar images.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用一个可重复使用的组件实现图像上传，该组件允许用户上传新的头像图像。
