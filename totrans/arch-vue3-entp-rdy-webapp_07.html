<html><head></head><body>
<div id="_idContainer062">
<p><a id="_idTextAnchor229"/></p>
<h1 class="chapter-number" id="_idParaDest-112"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-113"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.2.1">Dockerizing a Vue 3 App</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we demonstrated how to build a complete Pinterest clone with Vue.js 3, GraphQL, and Strapi for the backend. </span><span class="koboSpan" id="kobo.3.2">You also utilized your knowledge of GraphQL to develop an enterprise Pinterest clone application. </span><span class="koboSpan" id="kobo.3.3">In this chapter, you will learn the nitty-gritty details of the steps involved in dockerizing your Vue.js 3 project. </span><span class="koboSpan" id="kobo.3.4">In addition, you will learn about best practices and industry standards to dockerize and deploy an enterprise Vue.js 3 web application. </span><span class="koboSpan" id="kobo.3.5">This chapter will also take a more practical approach by covering how to dockerize a full stack web application and deploy the container to a cloud platform using </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">Docker Compose.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We will cover the following key topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Overview </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">of Docker</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Dockerizing </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">the app</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Running the app </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">on Docker</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Dockerizing Vue.js 3 and Node.js with </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">Docker Compose</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Running the app on </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">Docker Compose</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">By the end of this chapter, you will have learned about best practices and industry standards to dockerize and deploy an enterprise Vue.js 3 web application. </span><span class="koboSpan" id="kobo.17.2">You will also have gained practical experience by dockerizing a full stack web application and deploying the container to a cloud platform using </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Docker Compose.</span></span></p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">To get started with this chapter, I recommend you read through </span><a href="B17237_06.xhtml#_idTextAnchor192"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.21.1">Chapter 6</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.22.1">, Building a Complete Pinterest Clone with GraphQL</span></em><span class="koboSpan" id="kobo.23.1">, first, where we built a complete Pinterest clone using Vue.js 3, GraphQL, and the Strapi CRM for the backend. </span><span class="koboSpan" id="kobo.23.2">We will be using that application a lot in this chapter to learn about Docker and </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">Docker Compose.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">All the code files for this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">at </span></span><a href="https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-7"><span class="No-Break"><span class="koboSpan" id="kobo.27.1">https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-7</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.28.1">.</span></span></p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.29.1">Overview of Docker</span></h1>
<p><span class="koboSpan" id="kobo.30.1">Docker has evolved over the years and knowing how to use it has become one of the most critical and in-demand skills </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.31.1">for anyone interested in DevOps. </span><span class="koboSpan" id="kobo.31.2">Therefore, whether you’re a seasoned DevOps engineer or a beginner, you definitely need to add Docker to your collection </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">of skills.</span></span></p>
<p><span class="koboSpan" id="kobo.33.1">Docker is the new buzzword in the DevOps and container orchestration industry. </span><span class="koboSpan" id="kobo.33.2">It was created in 2013 and was developed by the parent company, </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">Docker, Inc.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">Docker can package an application and its dependencies in a virtual container that can run on any Linux, Windows, or macOS computer. </span><span class="koboSpan" id="kobo.35.2">A container refers to an isolated or bundled application with the tools, libraries, and configuration files needed to execute </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">One of the benefits of Docker is that it is a toolkit that enables developers to build, deploy, run, update, and </span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.38.1">stop containers using simple commands and work-saving automation through a single API across different operating systems </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">and platforms.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">This chapter explores everything you need to know about Docker, the different unique features of Docker, and why you should consider dockerizing your applications. </span><span class="koboSpan" id="kobo.40.2">We will also work through creating and setting up your first </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">Docker application.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">In the next section, we will explore Docker and its benefits to give us insights into why we need it in our </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">development pipeline</span><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.44.1">.</span></span></p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.45.1">What is Docker?</span></h2>
<p><span class="koboSpan" id="kobo.46.1">Docker is an open source platform that allows developers to build, test, and deploy applications quickly. </span><span class="koboSpan" id="kobo.46.2">Docker </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.47.1">achieves this by packaging your application in standardized units called containers. </span><span class="koboSpan" id="kobo.47.2">These containers have everything the software needs to run, including libraries, system tools, code, and a runtime environment. </span><span class="koboSpan" id="kobo.47.3">It also virtualizes the operating system of the computer on which it is installed </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">and running.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">To further explain this, let’s say we have developed two different instances of our application, that is, the frontend and </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">the backend.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">The backend is developed with a Node.js stack, including a PostgreSQL database and other tools that make </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.52.1">the Node.js backend execute properly on your </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">local server.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">Next, your frontend is created with Vue.js 3 and the necessary tools and configuration that make your Vue.js 3 application </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">run smoothly.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">Here are a couple of problems that might arise when working in a team or individually if you aren’t </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">using Docker:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.58.1">If a new team member joins, it might be tedious to onboard the member into the code base since the </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.59.1">member needs to install and configure the correct version of the project and download the exact versions of the </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">files required.</span></span></li>
<li><span class="koboSpan" id="kobo.61.1">When deploying the application, provisioning different servers for all the services used by your application will be a lot of work. </span><span class="koboSpan" id="kobo.61.2">For instance, you will have to provision different servers for the database, frontend, and backend. </span><span class="koboSpan" id="kobo.61.3">You may also need to provision different servers for different environments, such as staging, testing, and production, or use one server with lots of configurations </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">each time.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.63.1">With Docker, you can solve these problems by configuring, provisioning, and packaging all these services with a </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.64.1">simple configuration file called a Dockerfile or a YAML file to define and run multi-container Docker applications using </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">Docker Compose.</span></span></p>
<p><span class="koboSpan" id="kobo.66.1">To understand how Docker will solve these problems, take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<span class="koboSpan" id="kobo.68.1"><img alt="Figure 7.1 – A screenshot of the Docker host and layers (source: freeCodeCamp [freecodecamp.org/news/docker-simplified-96639a35ff36/])" src="image/Figure_7.01_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.69.1">Figure 7.1 – A screenshot of the Docker host and layers (source: freeCodeCamp [freecodecamp.org/news/docker-simplified-96639a35ff36/])</span></p>
<p><span class="koboSpan" id="kobo.70.1">The preceding screenshot shows the internal layers and structure of Docker, where your application is bundled into </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.71.1">containers with all the required resources to run smoothly. </span><span class="koboSpan" id="kobo.71.2">Additionally, each container uses your shared </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">system resources.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">This allows each container to be isolated from the others present on the same host. </span><span class="koboSpan" id="kobo.73.2">Thus, it allows multiple containers with different application requirements and dependencies to run on the same host, as long as they have the same operating </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">system requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">Therefore, with Docker, you can run multiple applications as containers and use commands and a single configuration file to control everything. </span><span class="koboSpan" id="kobo.75.2">In the next section, we will carefully examine the benefits of Docker to our </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">development pipe</span><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.77.1">line.</span></span></p>
<h3><span class="koboSpan" id="kobo.78.1">The benefits of Docker</span></h3>
<p><span class="koboSpan" id="kobo.79.1">Some of the key </span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.80.1">benefits of using Docker are </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">listed here:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.82.1">Optimized storage system</span></strong><span class="koboSpan" id="kobo.83.1">: Containers are usually a few megabytes in size and consume very little disk space. </span><span class="koboSpan" id="kobo.83.2">Therefore, a large number of applications can be hosted on the </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">same host.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.85.1">Cost-effective</span></strong><span class="koboSpan" id="kobo.86.1">: Docker is less demanding when it comes to the hardware required to run it. </span><span class="koboSpan" id="kobo.86.2">Therefore, it reduces the cost of acquiring expensive hardware for different </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">setups drastically.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.88.1">Robustness</span></strong><span class="koboSpan" id="kobo.89.1">: Docker has a faster boot time as it consumes very little memory in comparison to a virtual machine since it does not have an operating </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">system installed.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.91.1">Multiple containers</span></strong><span class="koboSpan" id="kobo.92.1">: With the same operating requirements, Docker supports multiple applications </span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.93.1">with different application requirements and dependencies, to be hosted together on the </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">same host.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.95.1">These are the benefits of using Docker to manage and ship your enterprise applications. </span><span class="koboSpan" id="kobo.95.2">Let’s next explore why you should use Docker in your </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">enterprise-level appli</span><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.97.1">cation.</span></span></p>
<h3><span class="koboSpan" id="kobo.98.1">Why use Docker</span></h3>
<p><span class="koboSpan" id="kobo.99.1">Docker enables you to publish your code quickly and efficiently. </span><span class="koboSpan" id="kobo.99.2">It standardizes the operations of </span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.100.1">an application, allows you to move code seamlessly, and saves revenue by improving the utilization </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">of resources.</span></span></p>
<p><span class="koboSpan" id="kobo.102.1">Here are some of the reasons you should start using Docker in scalable </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">enterprise applications:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.104.1">Ship more software faster</span></strong><span class="koboSpan" id="kobo.105.1">: Acc</span><a href="https://aws.amazon.com/docker/"><span class="koboSpan" id="kobo.106.1">ording</span></a><span class="koboSpan" id="kobo.107.1"> to Amazon (</span><a href="https://aws.amazon.com/docker/"><span class="koboSpan" id="kobo.108.1">https://aws.amazon.com/docker/</span></a><span class="koboSpan" id="kobo.109.1">), Docker users ship products 7x faster than non-Docker users. </span><span class="koboSpan" id="kobo.109.2">Docker enables you to ship isolated services as often as needed. </span><span class="koboSpan" id="kobo.109.3">When building enterprise-level and scalable applications, features and bug fixes happen in hours, if not minutes. </span><span class="koboSpan" id="kobo.109.4">Therefore, urgent building, testing, and deployment are needed and Docker comes in handy in </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">this area.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.111.1">Standardize operations</span></strong><span class="koboSpan" id="kobo.112.1">: Docker follows industry-standard application development practices. </span><span class="koboSpan" id="kobo.112.2">Isolated standardized units called containers make it easy to deploy, identify issues, and roll back </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">for remediation.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.114.1">Seamlessly move</span></strong><span class="koboSpan" id="kobo.115.1">: Developers can move applications between different environments and systems without worrying about installing any libraries or missing configuration files. </span><span class="koboSpan" id="kobo.115.2">Docker-based applications can be moved seamlessly from local development to a </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">production environment.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.117.1">Save money</span></strong><span class="koboSpan" id="kobo.118.1">: Docker-based applications are cost-effective since you can run multiple applications on one server in the form of containers. </span><span class="koboSpan" id="kobo.118.2">Docker containers make it easier to run more code on each server, improving your utilization of CPU resources and saving </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">you money.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.120.1">Now you know why you </span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.121.1">should use Docker in your enterprise applications and the benefits you can incur from using Docker. </span><span class="koboSpan" id="kobo.121.2">With Docker, you can ship products faster and more efficiently. </span><span class="koboSpan" id="kobo.121.3">When combined with other industry-standard tools, you can completely remove the hassle of manual deployment by instead adopting automated deployment. </span><span class="koboSpan" id="kobo.121.4">In the next section, we are going to explore how to dockerize your </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">first app</span><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.123.1">lication.</span></span></p>
<h1 id="_idParaDest-117"><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.124.1">Implementing Docker with Vue.js 3</span></h1>
<p><span class="koboSpan" id="kobo.125.1">Docker is an </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.126.1">enterprise-ready container platform that </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.127.1">enables organizations to seamlessly build, share, and run any application, anywhere. </span><span class="koboSpan" id="kobo.127.2">Almost all enterprise-level companies containerize their applications for faster production workloads so that they can deploy anytime, sometimes several times </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">a day.</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">One way to build an enterprise-level application is to dockerize the project from the beginning. </span><span class="koboSpan" id="kobo.129.2">Therefore, we are going to dockerize the Pinterest Vue.js 3 app with the Strapi backend we developed in </span><a href="B17237_06.xhtml#_idTextAnchor192"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.130.1">Chapter 6</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.131.1">, Building a Complete Pinterest Clone with GraphQL</span></em><span class="koboSpan" id="kobo.132.1">, and create a Docker image so that we can deploy that image any time or sometimes several times </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">a day.</span></span></p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.134.1">Prerequisite</span></h2>
<p><span class="koboSpan" id="kobo.135.1">Most importantly, you </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.136.1">must download and install Docker in your local development system for local testing. </span><span class="koboSpan" id="kobo.136.2">You can go to this link to download and install it on different operating </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">systems: </span></span><a href="https://docs.docker.com/install/"><span class="No-Break"><span class="koboSpan" id="kobo.138.1">https://docs.docker.c</span><span id="_idTextAnchor241"/><span class="koboSpan" id="kobo.139.1">om/install/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.140.1">.</span></span></p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor242"/><span class="koboSpan" id="kobo.141.1">Example project</span></h2>
<p><span class="koboSpan" id="kobo.142.1">In </span><a href="B17237_06.xhtml#_idTextAnchor192"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.143.1">Chapter 6</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.144.1">, Building a Complete Pinterest Clone with GraphQL</span></em><span class="koboSpan" id="kobo.145.1">, we developed a </span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.146.1">Pinterest clone using Vue.js 3 and Strapi for the backend. </span><span class="koboSpan" id="kobo.146.2">In this section, we will learn how to dockerize the project from scratch. </span><span class="koboSpan" id="kobo.146.3">Here is a demo of </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">the application:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<span class="koboSpan" id="kobo.148.1"><img alt="Figure 7.2 – A screenshot of the Pinterest clone demo" src="image/Figure_7.02_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.149.1">Figure 7.2 – A screenshot of the Pinterest clone demo</span></p>
<p><span class="koboSpan" id="kobo.150.1">The application displays images in a masonry grid layout based on the number of images we have stored in our </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">Strapi database.</span></span></p>
<p><span class="koboSpan" id="kobo.152.1">The Strapi backend allows you to manage and control the entire backend of the application, from adding pins and boards to creating </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">new users.</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">We will dockerize both the Vue.js 3 Pinterest app and the Strapi backend using individual Dockerfiles and multi-stage builds to create efficient </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">Do</span><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.156.1">cker images.</span></span></p>
<h3><span class="koboSpan" id="kobo.157.1">Dockerizing the Pinterest app</span></h3>
<p><span class="koboSpan" id="kobo.158.1">We will start by dockerizing the Pinterest Vue.js 3 application. </span><span class="koboSpan" id="kobo.158.2">In this multi-stage build, building a Vue.js 3 project </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.159.1">and putting those static assets in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">dist</span></strong><span class="koboSpan" id="kobo.161.1"> folder is the first step. </span><span class="koboSpan" id="kobo.161.2">So, let’s create a Dockerfile and configure our Vue.js </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">3 application.</span></span></p>
<p><span class="koboSpan" id="kobo.163.1">Create a Dockerfile in the root directory of your Pinterest clone Vue.js 3 app. </span><span class="koboSpan" id="kobo.163.2">If the Strapi backend is still inside the frontend folder as you clone from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">Chapter 6</span></strong></span><span class="koboSpan" id="kobo.165.1"> repository (</span><a href="https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-6"><span class="koboSpan" id="kobo.166.1">https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-6</span></a><span class="koboSpan" id="kobo.167.1">), you can create a parent folder and move the Strapi backend folder side by side with the frontend folder, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer059">
<span class="koboSpan" id="kobo.169.1"><img alt="Figure 7.3 – A screenshot of the current folder structure" src="image/Figure_7.03_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.170.1">Figure 7.3 – A screenshot of the current folder structure</span></p>
<p><span class="koboSpan" id="kobo.171.1">Moreover, you can clone the completed </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">Chapter 7</span></strong></span><span class="koboSpan" id="kobo.173.1"> (</span><a href="https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-7"><span class="koboSpan" id="kobo.174.1">https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-7</span></a><span class="koboSpan" id="kobo.175.1">) repository from this link, which contains the complete </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">Lastly, let’s explore the </span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.178.1">configuration file to dockerize the Vue.js 3 enterprise application. </span><span class="koboSpan" id="kobo.178.2">Open your Dockerfile and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.180.1">
# Use the official Node.js 14 Alpine image from https://hub.docker.com/_/node.
</span><span class="koboSpan" id="kobo.180.2"># Using an image with specific version tags allows deterministic builds.
</span><span class="koboSpan" id="kobo.180.3">FROM node:16.17.0-alpine
# Create and change to the app directory.
</span><span class="koboSpan" id="kobo.180.4">WORKDIR /usr/src/frontend
# Copy important root files to the builder image.
</span><span class="koboSpan" id="kobo.180.5">COPY package*.json ./
# Install production dependencies.
</span><span class="koboSpan" id="kobo.180.6">RUN npm install
# Copy the Vue 3 source to the container image.
</span><span class="koboSpan" id="kobo.180.7">COPY . </span><span class="koboSpan" id="kobo.180.8">.
</span><span class="koboSpan" id="kobo.180.9"># Expose container port
EXPOSE 3000
# Run the Vue service on container startup.
</span><span class="koboSpan" id="kobo.180.10">CMD ["npm", "run", "dev"]</span></pre>
<p><span class="koboSpan" id="kobo.181.1">The code snippet is self-explanatory with the comments explaining every command we used in </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">the Dockerfile.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">Let’s build the </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.184.1">image with the </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.186.1">
// build the image
docker build -t pinterest-vue-frontend .
</span><span class="koboSpan" id="kobo.186.2">// check the images
docker images
```</span></pre>
<p><span class="koboSpan" id="kobo.187.1">In summary, we have successfully dockerized our Vue.js 3 Pinterest application. </span><span class="koboSpan" id="kobo.187.2">In the next section, we will dockerize the Strapi backend </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">applicati</span><a id="_idTextAnchor244"/><span class="koboSpan" id="kobo.189.1">on separately.</span></span></p>
<h3><span class="koboSpan" id="kobo.190.1">Dockerizing the Strapi backend app</span></h3>
<p><span class="koboSpan" id="kobo.191.1">In this section, we </span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.192.1">will follow the same approach used in dockerizing the Vue.js 3 frontend project to create a Docker instance for the </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">Strapi backend.</span></span></p>
<p><span class="koboSpan" id="kobo.194.1">Therefore, create a Dockerfile inside the Strapi backend folder of your project and add the following </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">configuration code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.196.1">
# Use the official Node.js 14 Alpine image from https://hub.docker.com/_/node.
</span><span class="koboSpan" id="kobo.196.2"># Using an image with specific version tags allows deterministic builds.
</span><span class="koboSpan" id="kobo.196.3">FROM node:14.16.1 AS builder
# Create and change to the app directory.
</span><span class="koboSpan" id="kobo.196.4">WORKDIR /usr/src/backend
# Copy important root files to the builder image.
</span><span class="koboSpan" id="kobo.196.5">COPY package*.json ./
# Install production dependencies.
</span><span class="koboSpan" id="kobo.196.6">RUN npm install
# Copy the Backend source to the container image.
</span><span class="koboSpan" id="kobo.196.7">COPY . </span><span class="koboSpan" id="kobo.196.8">.
</span><span class="koboSpan" id="kobo.196.9"># build app for production with minification
RUN npm run build
EXPOSE 1337
# Init final image generation.
</span><span class="koboSpan" id="kobo.196.10">FROM node:14.16.1
# Run the Strapi service on container startup.
</span><span class="koboSpan" id="kobo.196.11">CMD ["npm", "start"]</span></pre>
<p><span class="koboSpan" id="kobo.197.1">We copied the previous configuration and changed the building process for the backend app. </span><span class="koboSpan" id="kobo.197.2">The code snippet </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.198.1">is self-explanatory with comments explaining every command we used in the Dockerfile. </span><span class="koboSpan" id="kobo.198.2">In the next section, we are going to run the applications on Docker and test </span><a id="_idTextAnchor245"/><span class="No-Break"><span class="koboSpan" id="kobo.199.1">them separately.</span></span></p>
<h3><span class="koboSpan" id="kobo.200.1">Running the images on Docker</span></h3>
<p><span class="koboSpan" id="kobo.201.1">After building </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.202.1">the Docker image, next, we need to run the image </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.203.1">on Docker using the </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.205.1">
```bash
// run the Frontend image
docker run -d -p  3000:3001 --name pinterest-frontend pinterest-vue-frontend
// run the Strapi Backend Image
docker run -d -p  1337:3002 --name pinterest-backend pinterest-strapi-backend
// check the container
docker ps
```</span></pre>
<p><span class="koboSpan" id="kobo.206.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">ps</span></strong><span class="koboSpan" id="kobo.208.1"> command checks the container for the list of images currently running in your Docker engine. </span><span class="koboSpan" id="kobo.208.2">You should see two images with the names specified in the preceding Docker </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">run</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.210.1"> command.</span></span></p>
<p><span class="koboSpan" id="kobo.211.1">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">run</span></strong><span class="koboSpan" id="kobo.213.1"> command is successful, you can access the frontend application on the web at the address </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">http://localhost:3001</span></strong><span class="koboSpan" id="kobo.215.1"> and the backend instance at port </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">3002</span></strong><span class="koboSpan" id="kobo.217.1">. </span><span class="koboSpan" id="kobo.217.2">This port change is possible because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">-p</span></strong><span class="koboSpan" id="kobo.219.1"> option exposes our internal frontend Vue.js 3 server port </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">3000</span></strong><span class="koboSpan" id="kobo.221.1"> to the external port </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">3001</span></strong><span class="koboSpan" id="kobo.223.1">, which makes it possible to access our internal Docker application in </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">our browser.</span></span></p>
<p><span class="koboSpan" id="kobo.225.1">At this point, if everything </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.226.1">is successful, you should be greeted with your </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.227.1">demo Vue.js 3 application. </span><span class="koboSpan" id="kobo.227.2">However, following this approach poses a problem. </span><span class="koboSpan" id="kobo.227.3">Developers need to build, test, and deploy applications in isolation, which can be avoided with </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">Docker Compose.</span></span></p>
<p><span class="koboSpan" id="kobo.229.1">In this section, we explored how to dockerize the Pinterest clone application we have developed in this book. </span><span class="koboSpan" id="kobo.229.2">We learned how to create, build, and run the Dockerfile we used in dockerizing the project using different Docker commands. </span><span class="koboSpan" id="kobo.229.3">In the next section, we will explore how to use Docker Compose to build, test, and deploy multiple a</span><a id="_idTextAnchor246"/><span class="koboSpan" id="kobo.230.1">pplications </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">at once.</span></span></p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor247"/><span class="koboSpan" id="kobo.232.1">Dockerizing Vue.js and Node.js with Docker Compose</span></h1>
<p><span class="koboSpan" id="kobo.233.1">In the previous </span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.234.1">section, we explored </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.235.1">how to dockerize Vue.js 3 applications and how to dockerize a Node.js application using Strapi, which was </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.236.1">done separately. </span><span class="koboSpan" id="kobo.236.2">In this </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.237.1">section, we are going to explore how to build, test, and deploy bundled applications. </span><span class="koboSpan" id="kobo.237.2">Furthermore, we are going to build and dockerize both applic</span><a id="_idTextAnchor248"/><span class="koboSpan" id="kobo.238.1">ations as a </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">single unit.</span></span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor249"/><span class="koboSpan" id="kobo.240.1">Overview of Docker Compose</span></h2>
<p><span class="koboSpan" id="kobo.241.1">Docker Compose is a tool </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.242.1">designed to enable users to easily define and share multi-container applications. </span><span class="koboSpan" id="kobo.242.2">By creating a YAML file, Compose allows us to quickly launch or shut down all services with a </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">single command.</span></span></p>
<p><span class="koboSpan" id="kobo.244.1">With Docker Compose, developers can build, test, and deploy multiple containers and images bundled together to form a </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">single application.</span></span></p>
<p><span class="koboSpan" id="kobo.246.1">In the next section, we are going to explore how to bundle the frontend and backend applications that we demonstrated</span><a id="_idTextAnchor250"/><span class="koboSpan" id="kobo.247.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">previous section.</span></span></p>
<h3><span class="koboSpan" id="kobo.249.1">Dockerizing the Pinterest clone app</span></h3>
<p><span class="koboSpan" id="kobo.250.1">To bundle a deployable </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.251.1">application, we are going to start by creating a central Dockerfile and Docker Compose YAML file inside the root directory that contains the different configurations to bundle our application with </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">Docker Compose.</span></span></p>
<p><span class="koboSpan" id="kobo.253.1">Before you start, rename your </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">strapi-pinterest-api</span></strong><span class="koboSpan" id="kobo.255.1"> folder to </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">backend</span></strong><span class="koboSpan" id="kobo.257.1">. </span><span class="koboSpan" id="kobo.257.2">The following screenshot shows the current </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">folder structure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer060">
<span class="koboSpan" id="kobo.259.1"><img alt="Figure 7.4 – A screenshot of the current folder structure with Docker and Docker Compose files" src="image/Figure_7.04_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.260.1">Figure 7.4 – A screenshot of the current folder structure with Docker and Docker Compose files</span></p>
<p><span class="koboSpan" id="kobo.261.1">Next, create a Dockerfile inside the </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.262.1">root directory and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">following script:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.264.1">
FROM node:14.15.0
ARG PACKAGE_PATH=
ARG WORKING_DIR=
WORKDIR ${WORKING_DIR}
COPY ${PACKAGE_PATH}/package*.json ${WORKING_DIR}
RUN npm install --silent
COPY ${PACKAGE_PATH} ${WORKING_DIR}
VOLUME $WORKING_DIR/node_modu</span><a id="_idTextAnchor251"/><span class="koboSpan" id="kobo.265.1">les
CMD [ "npm", "start" ]</span></pre>
<h4><span class="koboSpan" id="kobo.266.1">Code walk-through</span></h4>
<p><span class="koboSpan" id="kobo.267.1">Let’s walk through the code together and understa</span><a id="_idTextAnchor252"/><span class="koboSpan" id="kobo.268.1">nd the nitty-gritty </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">of it.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.270.1">Step 1: </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.271.1">Import Node.js</span></strong></span></p>
<p><span class="koboSpan" id="kobo.272.1">The first step </span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.273.1">in every Dockerfile is to specify the build image. </span><span class="koboSpan" id="kobo.273.2">In this case, we specify Node.js as </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">our image.</span></span></p>
<p><span class="koboSpan" id="kobo.275.1">This will install Node.js with the specified version number and set up the environme</span><a id="_idTextAnchor253"/><span class="koboSpan" id="kobo.276.1">nt to run </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">Node.js properly.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.278.1">Step 2: Create the </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.279.1">required arguments</span></strong></span></p>
<p><span class="koboSpan" id="kobo.280.1">The second step is to </span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.281.1">create the arguments required by Docker Compose when building individual images of our frontend and </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">backend applications:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.283.1">
ARG PACKAGE_PATH=
ARG WORKING_DIR=
WORKDIR ${WORKING_DIR}</span></pre>
<p><span class="koboSpan" id="kobo.284.1">Additionally, we </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.285.1">create a working directory specifying the argument we created earlier. </span><span class="koboSpan" id="kobo.285.2">This will auto-inject the specified working directory in </span><a id="_idTextAnchor254"/><span class="koboSpan" id="kobo.286.1">the Docker Compose </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">YAML file.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.288.1">Step 3: Copy, install, and </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.289.1">run commands</span></strong></span></p>
<p><span class="koboSpan" id="kobo.290.1">Lastly, we copy files </span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.291.1">from the specified working </span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.292.1">directory into the Docker virtual working directory. </span><span class="koboSpan" id="kobo.292.2">We start by copying </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">package*.json</span></strong><span class="koboSpan" id="kobo.294.1"> files, running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">install</span></strong><span class="koboSpan" id="kobo.296.1"> command, and copying the remaining files later. </span><span class="koboSpan" id="kobo.296.2">This approach utilizes the Docker </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">caching system:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.298.1">
COPY ${PACKAGE_PATH}/package*.json ${WORKING_DIR}
RUN npm install --silent
COPY ${PACKAGE_PATH} ${WORKING_DIR}
VOLUME $WORKING_DIR/node_modules
CMD [ "npm", "start" ]</span></pre>
<p><span class="koboSpan" id="kobo.299.1">Furthermore, after </span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.300.1">mounting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">node_modules</span></strong><span class="koboSpan" id="kobo.302.1"> folder of the specified working directory, Docker will execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">npm start</span></strong><span class="koboSpan" id="kobo.304.1"> command to start </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.306.1">Now that we have created a central Dockerfile for both the frontend and backend, let’s continue by creating a YAML Docker Compose file to bundle our separate </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">applications together.</span></span></p>
<p><span class="koboSpan" id="kobo.308.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">docker-compose.yaml</span></strong><span class="koboSpan" id="kobo.310.1"> file inside the root directory and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">following script:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.312.1">
version: "3.5"
services:
 api:
   build:
     context: .
</span><span class="koboSpan" id="kobo.312.2">     dockerfile: Dockerfile
     args:
       PACKAGE_PATH: backend
       WORKING_DIR: /usr/src/
   expose:
     - 1337
   ports:
     - 1337:1337
   environment:
     - NODE_ENV=development
     - HOST=0.0.0.0
     - PORT=1337
     - BASE_URL=http://api:1337
   env_file:
     - ./.env
   volumes:
     - ./backend:/usr/src
   command: &gt;
     sh -c "npm install"
 frontend:
   build:
     context: .
</span><span class="koboSpan" id="kobo.312.3">     dockerfile: Dockerfile
     args:
       PACKAGE_PATH: frontend
       WORKING_DIR: /usr/src/
   expose:
     - 3000
   ports:
     - 3000:3000
   environment:
     - APP_ENV=production
     - APP_BACKEND=http://0.0.0.0:1337/api
     - NODE_PATH=/usr/src/
     - APP_TOKEN=eyJhbGciOiJIUzI1NiJ9.c29sb[STRAPI_TOKEN]
   env_file:
     - ./common.env
   volumes:
     - ./frontend:/usr/src
   depends_on:
     - </span><a id="_idTextAnchor255"/><span class="koboSpan" id="kobo.313.1">api
   command: ["npm", "start"]</span></pre>
<h4><span class="koboSpan" id="kobo.314.1">Code walk-through</span></h4>
<p><span class="koboSpan" id="kobo.315.1">Let’s walk through the code together and un</span><a id="_idTextAnchor256"/><span class="koboSpan" id="kobo.316.1">derstand the nitty-gritty </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">of it.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.318.1">Step 1: Versioning </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.319.1">and services</span></strong></span></p>
<p><span class="koboSpan" id="kobo.320.1">Every Docker Compose </span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.321.1">file always starts with a version number of the version of Docker Compose you intend to use when building and bundling the application. </span><span class="koboSpan" id="kobo.321.2">In this demo, we specify </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">version 3.5.</span></span></p>
<p><span class="koboSpan" id="kobo.323.1">Furthermore, every Docker Compose YAML is always split into different services. </span><span class="koboSpan" id="kobo.323.2">You can add as many services as required that each application depends on. </span><span class="koboSpan" id="kobo.323.3">For instance, if the backend of your project depends on a database (PostgreSQL), you can specify that as </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">a service.</span></span></p>
<p><span class="koboSpan" id="kobo.325.1">In this demo, we have </span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.326.1">specified only two services, namely </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.328.1">Backend</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.329.1">Frontend</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.330.1">Each of the services </span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.331.1">contains configurations that enable them to run smoothly. </span><span class="koboSpan" id="kobo.331.2">Let’s explore the configurations we </span><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.332.1">have added to the </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">frontend service.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.334.1">Step 2: The </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.335.1">build section</span></strong></span></p>
<p><span class="koboSpan" id="kobo.336.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">build</span></strong><span class="koboSpan" id="kobo.338.1"> section includes </span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.339.1">configurations that help in building the application. </span><span class="koboSpan" id="kobo.339.2">It contains commands such as the context, working directory, and </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">defined arguments:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.341.1">
 build:
    context: .
</span><span class="koboSpan" id="kobo.341.2">     dockerfile: Dockerfile
     args:
       PACKAGE_PATH: frontend
       WORKING_DIR: /usr/src/</span></pre>
<p><span class="koboSpan" id="kobo.342.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">context</span></strong><span class="koboSpan" id="kobo.344.1"> command specifies the part of the directory where the Dockerfile we created earlier is stored. </span><span class="koboSpan" id="kobo.344.2">In our case, it was stored in the </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">root directory.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">Next, we call the Dockerfile with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">dockerfile</span></strong><span class="koboSpan" id="kobo.348.1"> command and specify the required parameters with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">args</span></strong><span class="koboSpan" id="kobo.350.1"> command. </span><span class="koboSpan" id="kobo.350.2">Lastly, we specify the </span><a id="_idTextAnchor258"/><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">PACKAGE_PATH</span></strong><span class="koboSpan" id="kobo.352.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">WORKING_DIR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.354.1"> values.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.355.1">Step 3: Exposing </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.356.1">the port</span></strong></span></p>
<p><span class="koboSpan" id="kobo.357.1">In this </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.358.1">step, we exposed the internal Docker port used to run the application to the </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">outside world:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.360.1">
   expose:
  </span><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.361.1">   - 3000
   ports:
     - 3000:3000</span></pre>
<p><strong class="bold"><span class="koboSpan" id="kobo.362.1">Step 4: Creating </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.363.1">environment variables</span></strong></span></p>
<p><span class="koboSpan" id="kobo.364.1">In this </span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.365.1">step, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">environment</span></strong><span class="koboSpan" id="kobo.367.1"> command to add the required environment variables, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">APP_BACKEND</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.369.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">APP_ENV</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.372.1">
  environment:
     - APP_ENV=production
     - APP_BACKEND=http://0.0.0.0:1337/api
     - NODE_PATH=/usr/src/
     - APP_TOKEN=eyJhbGciOiJIUzI1NiJ9.c29sb[STRAPI_TOKEN]
   env_file:
     - ./.env</span></pre>
<p><span class="koboSpan" id="kobo.373.1">Then, we create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">env</span></strong><span class="koboSpan" id="kobo.375.1"> file in the root directory using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">env_file</span></strong><span class="koboSpan" id="kobo.377.1"> command to stor</span><a id="_idTextAnchor260"/><span class="koboSpan" id="kobo.378.1">e the details we </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">specified previously.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.380.1">Step 5: Running </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.381.1">the app</span></strong></span></p>
<p><span class="koboSpan" id="kobo.382.1">Lastly, we mount the </span><a id="_idIndexMarker305"/><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">frontend</span></strong><span class="koboSpan" id="kobo.384.1"> directory and specify that the frontend project depends on our backend API service, which is our Strapi backend. </span><span class="koboSpan" id="kobo.384.2">This allows Docker to execute the project in sequence from the backend first before </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">the frontend:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.386.1">
 volumes:
     - ./frontend:/usr/src
   depends_on:
     - api
   command: ["npm", "start"]</span></pre>
<p><span class="koboSpan" id="kobo.387.1">Finally, we call the </span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.388.1">command to execute the project. </span><span class="koboSpan" id="kobo.388.2">This same approach is repeated for the backend service. </span><span class="koboSpan" id="kobo.388.3">In the next section, we are going to learn how </span><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.389.1">to run the project using </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">Docker Compose.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor262"/><span class="koboSpan" id="kobo.391.1">Running the app on Docker Compose</span></h2>
<p><span class="koboSpan" id="kobo.392.1">After creating a </span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.393.1">successful Docker Compose YAML </span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.394.1">configuration file, let’s run our Pinterest clone project using </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">Docker Compose.</span></span></p>
<p><span class="koboSpan" id="kobo.396.1">Before you start running the project, make sure to set up and install Docker and Docker Compose. </span><span class="koboSpan" id="kobo.396.2">Next, type </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">docker compose up</span></strong><span class="koboSpan" id="kobo.398.1"> in your terminal root directory to deploy the project. </span><span class="koboSpan" id="kobo.398.2">Alternatively, type </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">docker-compose up</span></strong><span class="koboSpan" id="kobo.400.1"> to use Docker Compose directly. </span><span class="koboSpan" id="kobo.400.2">The application will be served </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">at </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">http://localhost:3000/</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.404.1">If everything is properly configured, you should be presented with a full stack Pinterest application, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer061">
<span class="koboSpan" id="kobo.406.1"><img alt="Figure 7.5 – Preview of Pinterest application demo" src="image/Figure_7.05_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.407.1">Figure 7.5 – Preview of Pinterest application demo</span></p>
<p><span class="koboSpan" id="kobo.408.1">If you are unsure about anything, please refer back to the code base of this chapter (</span><a href="https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-7"><span class="koboSpan" id="kobo.409.1">https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-7</span></a><span class="koboSpan" id="kobo.410.1">) to see the working and complete </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">project setup.</span></span></p>
<p><span class="koboSpan" id="kobo.412.1">In this section, we explored how </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.413.1">to use Docker Compose </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.414.1">to create and manage many services using the Dockerfile that we created in the previous section. </span><span class="koboSpan" id="kobo.414.2">We also learned how to bundle our full stack application, including the frontend, bac</span><a id="_idTextAnchor263"/><span class="koboSpan" id="kobo.415.1">kend, and a database, using </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">Docker Compose.</span></span></p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor264"/><span class="koboSpan" id="kobo.417.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.418.1">This chapter dove deeper into the nitty-gritty steps involved in dockerizing your Vue.js 3 project. </span><span class="koboSpan" id="kobo.418.2">In addition, we explored best practices and industry standards to dockerize and deploy an enterprise Vue.js 3 web application. </span><span class="koboSpan" id="kobo.418.3">We also learned how to dockerize a full stack web application using </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">Docker Compose.</span></span></p>
<p><span class="koboSpan" id="kobo.420.1">Using a Dockerfile, we were able to dockerize our Pinterest clone demo application so that it can be deployed and managed by other team members or on any cloud provider easily. </span><span class="koboSpan" id="kobo.420.2">Also, we learned how to bundle and manage a full stack application that includes the backend, the frontend, a database service, as well as many more features, all in a single file, using </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">Docker Compose.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">In the next chapter, you will explore the concept of testing. </span><span class="koboSpan" id="kobo.422.2">You will learn what to test from an array of available components and methods. </span><span class="koboSpan" id="kobo.422.3">In addition, you will learn about best practices and industry standards related to testing libraries and how to integrate them with </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">Vue.js 3.</span></span></p>
</div>


<div class="Content" id="_idContainer063">
<h1 id="_idParaDest-124"><a id="_idTextAnchor265"/><span class="koboSpan" id="kobo.1.1">Part 4: Testing Enterprise Vue.js 3 Apps</span></h1>
<p><span class="koboSpan" id="kobo.2.1">Testing an enterprise project can be daunting and unnecessarily complex. </span><span class="koboSpan" id="kobo.2.2">This part will explore everything relating to enterprise testing and what to test precisely to eliminate time spent on testing the </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">wrong code.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part comprises the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B17237_08.xhtml#_idTextAnchor266"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 8</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><a href="https://epic.packtpub.services/index.php?module=oss_Chapters&amp;action=DetailView&amp;record=b958045c-cbca-b3c1-9404-61d6c95961a4"><em class="italic"><span class="koboSpan" id="kobo.8.1">Testing and What to Test in </span></em></a><em class="italic"><span class="koboSpan" id="kobo.9.1">Vue.js 3</span></em></li>
<li><a href="B17237_09.xhtml#_idTextAnchor322"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.11.1">, </span><a href="https://epic.packtpub.services/index.php?module=oss_Chapters&amp;action=DetailView&amp;record=b5bd1ffc-0280-c217-aa63-61d6c9ee0198"><em class="italic"><span class="koboSpan" id="kobo.12.1">Best Practices in Unit Testing</span></em></a></li>
<li><a href="B17237_10.xhtml#_idTextAnchor363"><em class="italic"><span class="koboSpan" id="kobo.13.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.14.1">, </span><a href="https://epic.packtpub.services/index.php?module=oss_Chapters&amp;action=DetailView&amp;record=907b43f6-1d49-47b3-a4ac-63835de51e8f"><em class="italic"><span class="koboSpan" id="kobo.15.1">Integration Testing in Vue.js 3</span></em></a></li>
<li><a href="B17237_11.xhtml#_idTextAnchor420"><em class="italic"><span class="koboSpan" id="kobo.16.1">Chapter 11</span></em></a><span class="koboSpan" id="kobo.17.1">, </span><em class="italic"><span class="koboSpan" id="kobo.18.1">Industry Standard End-to-End Testing</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer064">
</div>
</div>
<div>
<div id="_idContainer065">
</div>
</div>
</body></html>