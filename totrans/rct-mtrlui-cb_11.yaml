- en: Text - Collecting Text Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling input with state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placeholder and helper text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation and error display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiline input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input adornments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input masking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Material-UI has a flexible text input component that can be used in a variety
    of ways to collect user input. Its usages range from collecting simple one-liner
    text input to masked input adorned with icons.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling input with state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `TextField` component can be controlled by the React component, `state`,
    just like regular HTML text input elements. As with other types of form controls,
    the actual value is often the starting point—the state for each form control grows
    more complex as more functionality is added.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like any other text input element, you need to provide the `TextField`
    component with an `onChange` event handler that updates the state for the input.
    Without this handler, the value of the input won''t change as the user types.
    Let''s look at an example where three text fields are rendered and they''re each
    controlled by their own piece of state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When you first load the screen, here''s what you''ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8024952-a0e0-408b-abda-dcf7598f720c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you type in each of the text fields, you''ll update the state of the component
    for the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ea51776-70c6-4e2c-a1fb-08c4cc328278.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The setter functions that are created with `useState()`: `setFirst()`, `setSecond()`,
    and `setThird()`, change the value of the `TextField` component by changing the
    state that''s used by the component in the `onChange` event.'
  prefs: []
  type: TYPE_NORMAL
- en: The `TextField` component is a convenient abstraction that builds on other Material-UI
    components, such as `FormControl` and `Input`. You could achieve the exact same
    result by replacing `TextField` with each of these components. But all you would
    get is more code to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if, instead of only keeping the `TextField` value in the component state,
    you also kept the `id` and `label` information as well? It might seem confusing
    to store values that never change as a state, but the trade-off is that you can
    have the state data drive what's rendered by the component instead of having to
    repeat the same `TextField` components over and over.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s change the shape of the component state, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of an object with string properties to hold the text field values,
    the `inputs` state is an array of objects. It''s an array so that the component
    can iterate over the values while maintaining their order. Each object has everything
    necessary to render `TextField`. Let''s look at the updated markup next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Each `Grid` item now maps to an element from the `inputs` array. If you need
    to add, remove, or change something about one of these text fields, you can do
    so by updating the state. Finally, let''s see what the `onChange()` implementation
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `onChange()` function updates an item in an array, the `inputs` array. First,
    it finds the `index` of the item to update, based on the text field `id`. Then,
    it updates the `value` property with the value of the text field.
  prefs: []
  type: TYPE_NORMAL
- en: The functionality is the exact same as before, with a different approach that
    requires less JSX markup.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`TextField` demos: [https://material-ui.com/demos/text-fields/](https://material-ui.com/demos/text-fields/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextField` API documentation: [https://material-ui.com/api/text-field/](https://material-ui.com/api/text-field/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placeholder and helper text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At a minimum, text fields should have a label so that the user knows what to
    type. But a label on its own can be downright confusing—especially if you have
    several text fields on the same screen. To help the user understand what to type,
    you can utilize `placeholder` and `helperText` in addition to `label`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write some code that showcases various `label`, `placeholder`, and `helperText`
    configurations you can use with the `TextField` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the four text fields look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25391d7d-8f72-4426-b852-3f47470da137.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at each of these text fields and break down their strengths
    and weaknesses.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, there''s a text field with a `label` component only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When you only have `label`, it is displayed where the user would enter text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b0626b6-ecd4-4027-918e-211150f60b6a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the user navigates to the text field and it receives focus, the `label`
    shrinks and moves out of the way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03fe8f73-1944-411e-9e59-df5c5619237f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next text field specifies placeholder text using the `placeholder` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `placeholder` text should provide the user with an example of a valid value
    if possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e6f3ced-f537-423a-8a42-275e56e9c4bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the user starts entering text, the `placeholder` value goes away:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9006a19c-5496-46e9-85d9-394f8e24f94d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next text field provides the `helperText` property with a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46b2b250-5ad6-4e09-bc12-654793bd8fdc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The helper text of a text field is static in the sense that it''s always visible
    and doesn''t move, even after the user starts typing. Lastly, text fields can
    have all three properties that help the user figure out what value to provide:'
  prefs: []
  type: TYPE_NORMAL
- en: A label that tells the user what the value is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placeholder text that provides an example value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helper text that gives more of an explanation of why the value is needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you combine these three properties, you''re increasing the likelihood
    that the user will understand what to type. When the text field is unfocused,
    the label and the helper text are visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb208c84-4ee7-4935-8206-e77698bcf5f6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the text field receives focus, the label shrinks and the placeholder value
    is revealed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d42f7cac-235b-44dc-ae5c-f43fd3887427.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`TextField` demos: [https://material-ui.com/demos/text-fields/](https://material-ui.com/demos/text-fields/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextField` API documentation: [https://material-ui.com/api/text-field/](https://material-ui.com/api/text-field/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation and error display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even with helper text, placeholders, and labels, users will inevitably enter
    something that's not quite right. It's not that they are trying to mess things
    up (some are, to be fair); it's that mistakes happen. When mistakes are made,
    text input fields need to be marked as being in an error state.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that you have two inputs: a phone number and an email address, and
    you want to make sure that the values provided by the user are correct.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note: Validation isn''t perfect. Thankfully, this piece can work, however,
    you need it to and you''ll still get all of the Material-UI pieces.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ValidationAndErrorDisplay` component will render two `TextField` components
    on the screen. This is what they look like when the screen first loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b8d39f4-978d-446f-956a-87e915e50775.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Phone and Email text fields are just regular text fields with labels, helper
    text, and placeholders. For example, when the Phone field receives focus, it looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e75273ea-ba88-4bde-9ae0-01b6bdd1f234.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you start typing, the value of the text field is validated against a phone
    format regular expression. Here''s what the field looks like when it has an invalid
    phone number value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/810fbb72-4907-491c-bcfb-a5941ec70789.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, once you have a valid phone number value, the state of the text field
    goes back to normal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f2b37a4-9080-4505-bc7b-93d6c691bc0d.png)'
  prefs: []
  type: TYPE_IMG
- en: The Email field works the same way—the only difference is the regular expression
    used to validate the format of the value.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by taking a look at the state of the `ValidationAndErrorDisplay`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `inputs` array is mapped to `TextField` components by the `render()` method.
    Each object in this array has properties that map directly to the `TextField`
    component. For instance, `id`, `label`, `placeholder`—these are all `TextField`
    properties. The objects each have two functions that help with validating the
    text field values. First, `getHelperText()` returns either the default helper
    text, or error text that replaces the helper text if the `error` argument is true.
    The `isValid()` function validates the `value` argument against a regular expression
    and returns `true` if it matches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at the `onChange()` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As the user types, this function updates the value state of the given text field.
    It also calls the `isValid()` function, passing it the updated value. The `error`
    state is set to `true` if the value is invalid. The `helperText` state is also
    updated using `getHelperText()`, which also depends on the validity of the value.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What if this example could be modified so that you didn''t have to store error
    messages as a state, or have a function to change the helper text of the text
    field? To do this, you could introduce a new `TextField` abstraction that handles
    setting the `error` property and changes the `helperText` component when the value
    is `invalid`. Here''s the new component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Instead of having a function that returns `true` if the data is valid, the `MyTextField`
    component expects an `isInvalid()` property that returns `false` if the data is
    valid and an `error` message when it's `invalid`. Then, the `error` property can
    use this value, which changes the color of the text field to indicate that it's
    in an error state and the `helperText` property can use either the string that
    is returned by the `isInvalid()` function, or the `helperText` property that was
    passed to the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at the state that the `ValidationAndErrorDisplay` component
    uses now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The inputs no longer need the `getHelperText()` function or the `error` state.
    The `isInvalid()` function returns the error helper text when the value is invalid.
    Next, let''s look at the `onChange()` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, it doesn't have to touch the `error` state, or worry about updating the
    helper text, or about calling any validation functions—this is all handled by
    `MyTextField` now.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`TextField` demos: [https://material-ui.com/demos/text-fields/](https://material-ui.com/demos/text-fields/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextField` API documentation: [https://material-ui.com/api/text-field/](https://material-ui.com/api/text-field/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Password fields are a special type of text input that hides the individual characters
    on the screen as they are typed. Material-UI `TextField` components support this
    type of field by changing the value of the `type` property.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s a simple example that changes a regular text input into a `password`
    input that prevents the value from displaying on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the screen looks like when it first loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a6e6e19-0632-4b5f-b229-446065797c30.png)'
  prefs: []
  type: TYPE_IMG
- en: If you change the value of the Password field, any new characters remain hidden,
    even though the actual value typed is stored in the `password` state of the `PasswordFields`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `type` property tells the `TextField` component to use a password HTML `input`
    element. This is how the value remains hidden as the user types it, or if the
    field is pre-populated with a `password` value. Sometimes, Password fields can
    be autofilled.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use the `autoComplete` property to control how password values are
    automatically filled by the browser. A common case for this value is to have the
    Password field automatically filled on a login screen once the Username field
    is filled. Here''s an example of how you can use this property when you have Username
    and Password fields on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The first `TextField` component uses the `autoComplete` value of `username`.
    It also passes `{ name: ''username'' }` to `InputProps` so that the `name` property
    is set on the `<input>` element. The reason you need to do this is so that, in
    the second `TextField` component, the `autoComplete` value of `current-password`
    tells the browser to look up the password based on the `username` field value.'
  prefs: []
  type: TYPE_NORMAL
- en: Not all browsers implement this functionality the same. In order for any credentials
    to be automatically filled in text fields, they have to be saved using the native
    browser credential remembering tool.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`TextField` demos: [https://material-ui.com/demos/text-fields/](https://material-ui.com/demos/text-fields/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextField` API documentation: [https://material-ui.com/api/text-field/](https://material-ui.com/api/text-field/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiline input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For some fields, users need the ability to provide text values that span multiple
    lines. The `multiline` property helps accomplish this goal.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that you have a field that could require multiple lines of text,
    provided by the user. You can specify the `multiline` property to allow for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The text field looks like a normal field when the screen first loads, because
    it has one row by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a19c398-c8e5-45c3-9dec-9d0913d74504.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can enter as many lines as you need to in this text field. New lines are
    started by pressing *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e2e2af7-818a-4787-b57c-34a6c8067726.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `multiline` Boolean property is used to indicate to the `TextField` component
    that `multiline` support is needed for the field. With the preceding example,
    you might run into a couple of issues if you''re planning on using the `multiline`
    input in a crowded space, such as a screen with many other fields on it or in
    a dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: The height of the field changes as the user presses *Enter*, adding more rows
    to the component. This might cause layout problems as other elements are moved
    around.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the field starts with one row and looks like a regular single-line text input,
    then the user might not realize that they can enter multiple lines of text in
    the field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To help prevent scenarios where a dynamically-sized `multiline` text field
    might cause problems, you can specify the number of rows used by a `multiline`
    text field. Here''s an example of how to use the `rows` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the text field will have exactly five rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5ad81ce-816c-4031-8f1f-981b822fc656.png)'
  prefs: []
  type: TYPE_IMG
- en: If the user enters more than five lines of text, a vertical scrollbar will be
    displayed—the height of the text doesn't change and can't impact the layout of
    other surrounding components. You can impose the same type of height restriction
    on the `TextField` component by using the `rowsMax` property instead of `rows`.
    The difference is that the text field will start out with one row and will grow
    as the user adds new lines. But if you set `rowsMax` to `5`, the text field will
    not exceed five rows.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`TextField` demos: [https://material-ui.com/demos/text-fields/](https://material-ui.com/demos/text-fields/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextField` API documentation: [https://material-ui.com/api/text-field/](https://material-ui.com/api/text-field/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input adornments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Material-UI `Input` components have properties that allow you to customize the
    way that they look and behave. The idea is that you can adorn inputs with other
    Material-UI components to extend the functionality of basic text inputs in a way
    that makes sense for the users of your application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say that your app has several screens that have password inputs. The users
    of your app like the ability to see passwords as they're typed. By default, values
    will be hidden, but if the input component itself had a button that toggles the
    visibility of the value, that would make your users happy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a generic component that will adorn password fields with
    a visibility toggle button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what you''ll see if you start typing without clicking on the toggle
    visibility button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/930874fb-fa0e-486a-afd1-8f3b1b38adab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s what the Password field looks like if we click on the toggle visibility
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49398d97-f542-4a88-988c-d61ea6aad051.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at the `PasswordField` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This component maintains a piece of state called `visible`. The reason that
    `PasswordField` maintains this state instead of the parent component is because
    of the separation of concerns principle. The parent component, for example, probably
    needs access to the value of the password field. This value gets passed into `PasswordField`
    as a property. However, only `PasswordField` cares about the `visibility` state.
    So, by keeping it encapsulated within this component, you've simplified any code
    that uses `PasswordField`.
  prefs: []
  type: TYPE_NORMAL
- en: The other valuable aspect of this abstraction is the adornment itself. The `type`
    property changes as the `visible` state changes—this is the mechanism that reveals
    or hides the password value. The `endAdornment` property is passed to the `Input`
    component that `TextField` renders, passed via `InputProps`. This is how you can
    add components to the field. In this example, you're adding an icon button to
    the right-hand side (end) of the input. The icon here changes based on the visible
    state and, when clicked, the `toggleVisible()` method is called to actually change
    the visible state.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use input adornments for more than buttons that reveal the value of
    a password field. For example, in a field that is validated, you can use input
    adornments to help visualize the validation state of the field. Let''s say that
    you need to validate an email field as the user types. You could create an abstraction
    in the form of a component that changes the color and the adornment of the component
    based on the result of validating what the user has provided. Here''s what that
    component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea with `ValidationField` is to take an `isValid()` function property
    and use it to test the value property. If it returns `true`, then `startAdornment`
    is a checkmark. If `isValid()` returns `false`, then `startAdornment` is a red
    *x*. Here''s how the component is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ValidationField` component can be used almost identically to `TextField`.
    The one addition is the `isValid` property. Any state is handled outside of `ValidationField`,
    which means that `isValid()` is called any time the value changes, and will update
    the appearance of the component to reflect the validity of the data. By way of
    an added bonus: you don''t actually have to store any kind of error state anywhere,
    because `ValidationField` derives everything that it needs from the value and
    `isValid` properties.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the field looks like with an invalid email address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91f68951-9510-4ca3-bc1a-5881aee255a0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s what the field looks like with a valid email address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ee21ae7-f4cf-4f60-96e6-423060dfa997.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`TextField` demos: [https://material-ui.com/demos/text-fields/](https://material-ui.com/demos/text-fields/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextField` API documentation: [https://material-ui.com/api/text-field/](https://material-ui.com/api/text-field/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IconButton` API documentation: [https://material-ui.com/api/icon-button/](https://material-ui.com/api/icon-button/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputAdornment` API documentation: [https://material-ui.com/api/input-adornment/](https://material-ui.com/api/input-adornment/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input masking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some text inputs require values with a specific format. With Material-UI `TextField`
    components, you can add masking capabilities that help guide the user toward providing
    the correct format.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that you have phone number and email fields and you want to provide
    an input mask for each. Here''s how you can use the `MaskedInput` component from
    `react-text-mask` with `TextField` components to add masking abilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the screen looks like when it first loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eefc70ba-4ed3-4d28-ac55-7e79a69076ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you start typing a value into the Phone field, the format mask appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1748999d-66b2-4e88-ad00-42e2597f9915.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s what the completed value looks like—the user never has to type `(`,
    `)`, or `-`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/061f343c-d584-4ca4-b4e6-910d33d9e61b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s what the completed Email value looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27b064e0-fbc5-46a2-923d-ea369d627a79.png)'
  prefs: []
  type: TYPE_IMG
- en: With the email input, the user will actually have to type `@` and `.` because
    the mask doesn't know how many characters are in any part of the email address.
    It does, however, prevent the user from putting either of these characters in
    the wrong place.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make this work, you created a `PhoneInput` component and an `EmailInput`
    component. The idea of each is to provide a basic abstraction around the `MaskedInput`
    component. Let''s take a closer look at each, starting with `PhoneInput`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The properties that are passed to `PhoneInput` are forwarded to `MaskedInput`
    for the most part. The `ref` property needs to be set explicitly because it's
    named differently. The `placeholder` property is set to be whitespace. The `mask`
    property is the most important—this is what determines the pattern that the user
    sees as they start typing. The value passed to `mask` is an array with regular
    expressions and string characters. The string characters are what show up when
    the user starts typing—in the case of phone number, these are the `(`, `)`, and
    `-` characters. The regular expressions are the dynamic pieces that match against
    what the user types. With a phone number, any digit will do, but symbols and letters
    aren't allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `EmailInput` component now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This follows the same approach as `PhoneInput`. The main difference is that,
    instead of passing an array of strings and regular expressions, the `emailMask`
    function (imported from `react-text-mask`) is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have these two masked inputs, you use them by passing them to
    the `inputComponent` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`TextField` demos: [https://material-ui.com/demos/text-fields/](https://material-ui.com/demos/text-fields/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextField` API documentation: [https://material-ui.com/api/text-field/](https://material-ui.com/api/text-field/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React text mask: [https://github.com/text-mask/text-mask](https://github.com/text-mask/text-mask)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
