- en: '*Chapter 6*: Implementing Additional Tools and Plugins for Testing'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：实现测试的额外工具和插件'
- en: In the previous chapters, we learned the basics of React Testing Library and
    how to test from simple to complex components using the tool. In this chapter,
    we will learn how to increase our productivity by using additional tools. We will
    install and use a few plugins to help our ability to write tests by avoiding common
    mistakes and following React Testing Library's best practices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了React Testing Library的基础知识以及如何使用该工具测试从简单到复杂的组件。在本章中，我们将学习如何通过使用额外的工具来提高我们的生产力。我们将安装并使用一些插件，以帮助我们避免常见错误并遵循React
    Testing Library的最佳实践。
- en: We will add a library to audit and increase application accessibility. We'll
    ensure we select the best React Testing Library query method with Testing Playground.
    Finally, we will increase our productivity by using Wallaby.js to receive rapid
    feedback on our tests' status from our code editor.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个库来审计并提高应用程序的可访问性。我们将确保我们使用Testing Playground选择最佳的React Testing Library查询方法。最后，我们将通过使用Wallaby.js从代码编辑器快速获取测试状态反馈来提高我们的生产力。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Using `eslint-plugin-testing-library` to follow best practices and avoid common
    mistakes when using React Testing Library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`eslint-plugin-testing-library`来遵循最佳实践，避免在使用React Testing Library时犯常见错误
- en: Using `eslint-plugin-jest-dom` to follow best practices and avoid common mistakes
    when using `jest-dom`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`eslint-plugin-jest-dom`来遵循最佳实践，避免在使用`jest-dom`时犯常见错误
- en: Using `jest-axe` to increase application accessibility
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`jest-axe`来提高应用程序的可访问性
- en: Selecting the Testing Library-recommended queries with Testing Playground
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Testing Playground选择Testing Library推荐的查询
- en: Increasing our testing productivity with Wallaby.js
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Wallaby.js提高我们的测试生产力
- en: The skills in this chapter will increase your productivity and enhance your
    ability to test React applications using Testing Library's best practices.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的技能将提高你的生产力，并增强你使用Testing Library最佳实践测试React应用程序的能力。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For the examples in this chapter, you will need to have Node.js installed on
    your machine. We will be using the `create-react-app` CLI tool for all code examples.
    Please familiarize yourself with the tool before starting this chapter, if required.
    Code snippets will be provided throughout the chapter to understand the code under
    test, but the objective is to understand how to test the code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的示例，你需要在你的机器上安装Node.js。我们将使用`create-react-app` CLI工具来展示所有代码示例。如果需要，请在开始本章之前熟悉这个工具。本章将提供代码片段来理解要测试的代码，但目标是理解如何测试代码。
- en: You can find code examples for this chapter at [https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter06](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter06).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter06](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter06)找到本章的代码示例。
- en: Implementing best practices with Testing Library ESLint plugins
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Testing Library ESLint插件实现最佳实践
- en: In this section, you will learn how to install and use `eslint-plugin-testing-library`
    and `eslint-plugin-jest-dom`. The purpose of these plugins is to audit your test
    code and help you to write tests that follow the best practices of `jest-dom`.
    The plugins work by highlighting areas that can be improved and providing recommendations
    to refactor your code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何安装和使用`eslint-plugin-testing-library`和`eslint-plugin-jest-dom`。这些插件的目的是对你的测试代码进行审计，并帮助你编写遵循`jest-dom`最佳实践的测试。插件通过突出可以改进的区域并提供重构代码的建议来工作。
- en: 'Before installing the plugins, we need to have **ESLint** installed in our
    project. ESLint is a tool that statistically analyzes and informs you of problems
    in your code. You can think of ESLint as having someone look over your shoulder
    to point out issues you might otherwise take longer to debug on your own. For
    example, you could create the following function:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装插件之前，我们需要在我们的项目中安装**ESLint**。ESLint是一个统计分析并通知你代码中问题的工具。你可以把ESLint想象成有人在你的肩膀上查看，指出你可能需要更长的时间自己调试的问题。例如，你可以创建以下函数：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, we have a `reverseWord` function that reverses a passed-in
    string. If we invoke the function with the word `packt`, we get the following
    result:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个`reverseWord`函数，该函数反转传入的字符串。如果我们用单词`packt`调用该函数，我们得到以下结果：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding code, we get a result of `tkcap` when we pass in `packt` as
    a parameter to the function. However, if we mistakenly misspell the function name
    and run the code, we get the following result:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，当我们将 `packt` 作为参数传递给函数时，我们得到的结果是 `tkcap`。然而，如果我们错误地拼写函数名称并运行代码，我们会得到以下结果：
- en: '![Figure 6.1 – The reverseWord function name typo](img/Figure_6.1_B16887.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – reverseWord 函数名称拼写错误](img/Figure_6.1_B16887.jpg)'
- en: Figure 6.1 – The reverseWord function name typo
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – reverseWord 函数名称拼写错误
- en: In the previous code, the console output indicates `ReferenceError`. The error
    refers to the interpreter not locating a defined function, called `reverseeWord`,
    in the file. The problem was that the user mistakenly added an extra `e` in the
    function name. We could create a better workflow by installing and configuring
    ESLint in our project to help debug issues.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，控制台输出指示 `ReferenceError`。错误指的是解释器没有在文件中找到定义的函数，名为 `reverseeWord`。问题在于用户错误地多加了一个
    `e` 在函数名称中。我们可以通过在我们的项目中安装和配置 ESLint 来创建一个更好的工作流程，以帮助调试问题。
- en: 'If you are using `create-react-app` for your project, then ESLint should automatically
    be installed for you. For projects that don''t already have ESLint installed,
    use the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 `create-react-app` 为你的项目，那么 ESLint 应该会自动为你安装。对于尚未安装 ESLint 的项目，请使用以下命令：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The previous command will install ESLint as a development dependency to your
    project.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将 ESLint 作为开发依赖项安装到你的项目中。
- en: 'Next, we can create a configuration file to tell ESLint how we want it to lint
    our files:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以创建一个配置文件来告诉 ESLint 我们希望它如何检查我们的文件：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The configuration file that was created in `json` format, in the previous code,
    has a few settings that tell ESLint how to lint our files. The `"extends"` key
    is set to `"eslint:recommended"`. This means that we want to use ESLint's recommended
    linting rules. The `"parserOptions"` key is set to an object with two keys. The
    `"ecmaVersion"` key is set to `"sourceType"` key is set to `"module"`, meaning
    our code will support ES modules. There are numerous ways ESLint can be configured
    to lint your project files.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中创建的以 `json` 格式的配置文件包含一些设置，告诉 ESLint 如何检查我们的文件。`"extends"` 键设置为 `"eslint:recommended"`。这意味着我们希望使用
    ESLint 推荐的检查规则。`"parserOptions"` 键设置为包含两个键的对象。`"ecmaVersion"` 键设置为 `"sourceType"`，`"module"`
    键设置为 `"module"`，这意味着我们的代码将支持 ES 模块。ESLint 可以以多种方式配置来检查你的项目文件。
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please refer to *Configuring ESLint* ([https://eslint.org/docs/user-guide/configuring/](https://eslint.org/docs/user-guide/configuring/))
    for more details.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 *配置 ESLint* ([https://eslint.org/docs/user-guide/configuring/](https://eslint.org/docs/user-guide/configuring/))
    获取更多详细信息。
- en: 'Use the following command to run ESLint against your project files:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令来运行 ESLint 检查你的项目文件：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the previous command, we use the `npx` command to run ESLint against all
    of the project files. Note that `npx` allows you to quickly execute `npm` packages
    regardless of whether the package is installed locally or globally on your machine
    or not installed at all. We receive the following output in the console after
    running the command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的命令中，我们使用 `npx` 命令来运行 ESLint 检查所有项目文件。请注意，`npx` 允许你快速执行 `npm` 包，无论该包是否已在本地的机器上本地或全局安装，或者根本未安装。在运行命令后，我们在控制台中收到以下输出：
- en: '![Figure 6.2 – ESLint output'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.2 – ESLint 输出](img/Figure_6.2_B16887.jpg)'
- en: '](img/Figure_6.2_B16887.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.2 – ESLint 输出](img/Figure_6.2_B16887.jpg)'
- en: Figure 6.2 – ESLint output
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – ESLint 输出
- en: In the previous command, ESLint informs us of two errors in our code. The first
    error says that the `reverseWord` function was never used on line `1`, referencing
    the `no-unused-vars` ESLint rule. The second error says that `reverseeWord` on
    line `3` is not defined anywhere in the file, referencing the `no-undef` ESLint
    rule. We can also enhance our ESLint workflow by displaying the output directly
    in our code editor to learn about any potential issues before running our code.
    For example, the VSCode and Atom code editors have third-party tools that we can
    install to display problems directly in the editor.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的命令中，ESLint 通知我们代码中有两个错误。第一个错误说 `reverseWord` 函数从未在行 `1` 上使用，引用了 ESLint 的
    `no-unused-vars` 规则。第二个错误说行 `3` 上的 `reverseeWord` 在文件中任何地方都没有定义，引用了 ESLint 的 `no-undef`
    规则。我们还可以通过在代码编辑器中直接显示输出来增强我们的 ESLint 工作流程，以在学习代码运行之前了解任何潜在的问题。例如，VSCode 和 Atom
    代码编辑器都有第三方工具，我们可以安装这些工具以在编辑器中直接显示问题。
- en: Note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please refer to *ESLint* ([https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint))
    for the VSCode editor extension. Alternatively, you can refer to *linter-eslint*
    ([https://atom.io/packages/linter-eslint](https://atom.io/packages/linter-eslint))
    for the Atom editor plugin for installation and configuration details.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅*ESLint*([https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint))以获取VSCode编辑器扩展的详细信息。或者，你可以查阅*linter-eslint*([https://atom.io/packages/linter-eslint](https://atom.io/packages/linter-eslint))以获取Atom编辑器插件的安装和配置细节。
- en: Displaying the linter output directly in the code editor provides faster feedback
    than manually running ESLint via the command line. Now that you understand how
    to get ESLint up and running, we will install and configure `eslint-plugin-testing-library`
    in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将lint输出直接显示在代码编辑器中比手动通过命令行运行ESLint提供更快的反馈。现在你已经了解了如何启动ESLint，我们将在下一节中安装和配置`eslint-plugin-testing-library`。
- en: Installing and configuring eslint-plugin-testing-library
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置eslint-plugin-testing-library
- en: 'In this section, we will learn how to install and configure `eslint-plugin-testing-library`
    inside our application. Install the plugin using the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在我们的应用程序中安装和配置`eslint-plugin-testing-library`。使用以下命令安装插件：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding command installs `eslint-plugin-testing-library` as a development
    dependency in your project. Now that the plugin is installed, we can add it to
    our ESLint configuration file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将`eslint-plugin-testing-library`作为开发依赖项安装到你的项目中。现在插件已安装，我们可以将其添加到我们的ESLint配置文件中：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the previous code, we created an `"overrides"` section in our ESLint configuration
    to target any files ending in `.test.js`. Then, we added `plugin:testing-library/react`
    to the `extends` array in the configuration file. We added the React version of
    the plugin to gain React-specific rules and the rules we get from DOM Testing
    Library's base rules. The plugin applies a particular set of linting rules that
    are specific to React applications. For example, the `no-dom-import` rule, which
    doesn't allow direct imports from DOM Testing Library, is useful because React
    Testing Library re-exports everything from DOM Testing Library, eliminating the
    need for direct imports.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在ESLint配置中创建了一个`"overrides"`部分，以针对以`.test.js`结尾的任何文件。然后，我们在配置文件中的`extends`数组中添加了`plugin:testing-library/react`。我们添加了插件的React版本以获得React特定的规则和来自DOM
    Testing Library的基本规则。该插件应用了一组特定的linting规则，这些规则专门针对React应用程序。例如，`no-dom-import`规则不允许直接从DOM
    Testing Library导入，这很有用，因为React Testing Library重新导出DOM Testing Library的所有内容，消除了直接导入的需要。
- en: Note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please refer to *Supported Rules* ([https://github.com/testing-library/eslint-plugin-testing-library#supported-rules](https://github.com/testing-library/eslint-plugin-testing-library#supported-rules))
    for a complete list of React-specific applied rules.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅*支持规则*([https://github.com/testing-library/eslint-plugin-testing-library#supported-rules](https://github.com/testing-library/eslint-plugin-testing-library#supported-rules))以获取React特定应用的规则完整列表。
- en: 'Note that the `react-app` entry is also included in the array. The `react-app`
    entry adds ESLint rules that have been set up by `create-react-app`. Now that
    we have the plugin set up in the project, we can write tests. We will test a drop-down
    component that allows a user to select a programming language:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`react-app`入口也被包含在数组中。`react-app`入口添加了由`create-react-app`设置的ESLint规则。现在我们在项目中设置了插件，我们可以编写测试。我们将测试一个允许用户选择编程语言的下拉组件：
- en: '![Figure 6.3 – The drop-down component'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 – 下拉组件'
- en: '](img/Figure_6.3_B16887.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.3_B16887.jpg)'
- en: Figure 6.3 – The drop-down component
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 下拉组件
- en: 'In the preceding screenshot, you can see a dropdown that lists four programing
    languages that a user can click on to choose. When a user selects a language,
    we get the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你可以看到一个下拉列表，列出了用户可以点击以选择四种编程语言。当用户选择一种语言时，我们会得到以下内容：
- en: '![Figure 6.4 – The selected drop-down option](img/Figure_6.4_B16887.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – 选定的下拉选项](img/Figure_6.4_B16887.jpg)'
- en: Figure 6.4 – The selected drop-down option
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 选定的下拉选项
- en: 'Here, you can view the text **You selected: JavaScript**, which appears when
    a user selects the **JavaScript** option. We can write a test to verify that the
    selected language displays on the screen:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以查看文本**你选择了：JavaScript**，这是当用户选择**JavaScript**选项时出现的。我们可以编写一个测试来验证所选语言是否显示在屏幕上：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, first, we render the `LanguageDropdown` component in
    the DOM. Next, we click on the **Programming Language** button. Then, we select
    **JavaScript** from the menu options. Next, we will verify that the selected option
    is displayed on the screen:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们在DOM中渲染了`LanguageDropdown`组件。接下来，我们点击了**编程语言**按钮。然后，我们从菜单选项中选择**JavaScript**。接下来，我们将验证所选选项是否显示在屏幕上：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, we use the `waitFor` method from React Testing Library
    to get the element with the text that includes the selected option. The `waitFor`
    method can be used when you need to wait for an element in the DOM. However, according
    to `eslint-plugin-testing-library`, `waitFor` is not the best way to select an
    element in this situation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用React Testing Library的`waitFor`方法来获取包含所选选项的文本的元素。当需要等待DOM中的元素时，可以使用`waitFor`方法。然而，根据`eslint-plugin-testing-library`，在这种情况下使用`waitFor`并不是选择元素的最佳方式：
- en: '![Figure 6.5 – The findByRole linter suggestion'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5 – findByRole代码检查建议](img/Figure_6.5_B16887.jpg)'
- en: '](img/Figure_6.5_B16887.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5 – findByRole代码检查建议](img/Figure_6.5_B16887.jpg)'
- en: Figure 6.5 – The findByRole linter suggestion
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – findByRole代码检查建议
- en: In the previous screenshot, the code that includes the `waitFor` method is underlined
    by ESLint, drawing our attention to the code issue. When we hover over the `waitFor`
    method code, we get feedback indicating that the preferred query is `findByRole`
    via the `prefer-find-by` rule of `eslint-plugin-testing-library`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的屏幕截图中，包含`waitFor`方法的代码被ESLint下划线标注，引起了我们的注意。当我们悬停在`waitFor`方法代码上时，我们得到反馈，表明首选的查询是`findByRole`，这是通过`eslint-plugin-testing-library`的`prefer-find-by`规则实现的。
- en: In [*Chapter 5*](B16887_05_Final_PG_ePub.xhtml#_idTextAnchor083), *Refactoring
    Legacy Applications with React Testing Library*, we learned how to use the `findByRole`
    query to select elements that need time to appear on the screen. The `prefer-find-by`
    rule is a `fixable` rule; this means that we can select to have the problem code
    automatically fixed for us.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B16887_05_Final_PG_ePub.xhtml#_idTextAnchor083)，“使用React Testing Library重构遗留应用程序”，我们学习了如何使用`findByRole`查询来选择需要时间出现在屏幕上的元素。`prefer-find-by`规则是一个可修复的规则；这意味着我们可以选择让问题代码自动为我们修复。
- en: 'One easy way to automatically fix issues is by setting up your code editor
    to automatically resolve any fixable issues when saving a file. Please refer to
    the documentation of your respective code editor for instructions. If, for some
    reason, your editor does not have a *fix on save* feature, you can run `eslint
    --fix` in the command line or use pre-commit hooks via `git`. As a last resort,
    you always have the option of referring to the `eslint-plugin-testing-library`
    documentation, which is related to the `prefer-find-by` rule and others, for suggestions.
    Once we refactor the problem code, we get the following output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 自动修复问题的简单方法是将代码编辑器设置为在保存文件时自动解决任何可修复的问题。请参阅您各自代码编辑器的文档以获取说明。如果由于某种原因，您的编辑器没有“保存时修复”功能，您可以在命令行中运行`eslint
    --fix`或通过`git`使用预提交钩子。作为最后的手段，您始终可以选择参考与`eslint-plugin-testing-library`相关的文档，其中包括`prefer-find-by`规则和其他规则的建议。一旦我们重构了问题代码，我们得到以下输出：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, the `waitFor` code is replaced with the `findByRole`
    query method. The code has a cleaner syntax that behaves similarly to the `waitFor`
    code and satisfies the linter rules. Finally, we assert that the selected code
    is in the document.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，将`waitFor`代码替换为`findByRole`查询方法。该代码具有更简洁的语法，其行为类似于`waitFor`代码，并满足代码检查规则。最后，我们断言所选代码在文档中。
- en: 'Some rules are not automatically enabled with the React version of `eslint-plugin-testing-library`.
    For example, in previous versions of React Testing Library, it was common to see
    selectors written as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一些规则在`eslint-plugin-testing-library`的React版本中不是自动启用的。例如，在React Testing Library的先前版本中，常见的选择器编写方式如下：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, we access the query methods by destructuring them off
    the rendered component. The latest React Testing Library versions suggest using
    the `screen` object to access query methods for a better user experience. The
    `screen` object allows you to access query methods using your editor''s autocomplete
    feature rather than undergoing explicit destructuring via the rendered component.
    We can add the `prefer-screen-queries` rule to our ESLint configuration file to
    enforce this way of selecting query methods:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过解构渲染的组件来访问查询方法。最新的 React Testing Library 版本建议使用 `screen` 对象来访问查询方法，以获得更好的用户体验。`screen`
    对象允许您使用编辑器的自动完成功能来访问查询方法，而不是通过渲染组件进行显式的解构。我们可以将 `prefer-screen-queries` 规则添加到我们的
    ESLint 配置文件中，以强制执行这种选择查询方法的方式：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we added a `"rules"` key to the configuration file. The
    `"rules"` key is used when we want to add specific rules to enforce our code.
    Inside the `"rules"` key, we add the `"testing-library/prefer-screen-queries"`
    key, which is set to `"error"`. If we had our project set up with a linting script
    to run ESLint across our files, the error would trigger an exit code to stop file
    execution, making it clear that the current code is not acceptable for use.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在配置文件中添加了一个 `"rules"` 键。当我们要添加特定的规则来强制执行我们的代码时，会使用 `"rules"` 键。在 `"rules"`
    键内部，我们添加了 `"testing-library/prefer-screen-queries"` 键，并将其设置为 `"error"`。如果我们有一个项目设置了一个运行
    ESLint 的 linting 脚本来跨文件运行，错误将触发一个退出代码来停止文件执行，从而清楚地表明当前代码不适合使用。
- en: 'Now, with this rule in place, the previous code using destructuring will be
    flagged by ESLint:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了这个规则，使用解构的先前代码将被 ESLint 标记：
- en: '![Figure 6.6 – The prefer-screen-queries linter suggestion'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.6 – prefer-screen-queries 检查器建议'
- en: '](img/Figure_6.6_B16887.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.6_B16887.jpg)'
- en: Figure 6.6 – The prefer-screen-queries linter suggestion
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – prefer-screen-queries 检查器建议
- en: In the previous screenshot, `getByRole` is underlined by ESLint to draw our
    attention to the query issue. When we hover over the query, we get feedback indicating
    that the preferred approach uses `screen` to query DOM elements via the `prefer-screen-queries`
    rule of `eslint-plugin-testing-library`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，`getByRole` 被 ESLint 下划线标记，以引起我们对查询问题的注意。当我们悬停在查询上时，我们会得到反馈，表明首选的方法使用
    `screen` 通过 `eslint-plugin-testing-library` 的 `prefer-screen-queries` 规则来查询 DOM
    元素。
- en: 'Unlike the `prefer-find-by` rule in the previous example, `prefer-screen-queries`
    is not a *fixable* rule. This means that we will need to fix the code manually.
    When we refactor the code, we get the following result:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个示例中的 `prefer-find-by` 规则不同，`prefer-screen-queries` 不是一个可修复的规则。这意味着我们需要手动修复代码。当我们重构代码时，我们会得到以下结果：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The DOM selectors have been refactored to use the `screen` object in the preceding
    code, satisfying the `prefer-screen-queries` rule. The code also looks cleaner
    compared to the version using destructured query methods.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，DOM 选择器已经被重构为使用 `screen` 对象，满足了 `prefer-screen-queries` 规则。与使用解构查询方法的版本相比，代码看起来也更简洁。
- en: 'In some situations, we might want rules that provide a warning compared to
    an error when ESLint runs across project files. The warning won''t stop code execution;
    however, instead, it will serve as a reminder to the user to remove the file''s
    highlighted code before committing the code. For example, it is common to use
    the `debug` method to view the current state of the DOM as we build tests:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能希望规则在 ESLint 在项目文件中运行时提供警告而不是错误。警告不会停止代码执行；然而，它将作为对用户的一个提醒，在提交代码之前移除文件中突出显示的代码。例如，在构建测试时，使用
    `debug` 方法查看当前 DOM 的状态是很常见的：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the previous code, the `debug` method is used for logging the current DOM
    output to the console after rendering the `LanguageDropdown` component. The `debug`
    method will be highlighted in the editor, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`debug` 方法用于在渲染 `LanguageDropdown` 组件后，将当前 DOM 输出记录到控制台。`debug` 方法将在编辑器中突出显示，如下所示：
- en: '![Figure 6.7 – The no-debug linter suggestion'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.7 – no-debug 检查器建议'
- en: '](img/Figure_6.7_B16887.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.7_B16887.jpg)'
- en: Figure 6.7 – The no-debug linter suggestion
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – no-debug 检查器建议
- en: In the preceding screenshot, `debug` is underlined by ESLint to draw our attention
    to an issue with the query. When we hover over the query, we get feedback indicating
    the method should be removed via the `no-debug` rule of `eslint-plugin-testing-library`.
    We often forget to remove the console's logging code before committing work, so
    the `no-debug` rule serves as a helpful reminder to remove it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图上，ESLint 用下划线标记了 `debug`，以引起我们对查询问题的注意。当我们悬停在查询上时，我们得到反馈，表明应该通过 `eslint-plugin-testing-library`
    的 `no-debug` 规则来移除该方法。我们常常忘记在提交工作之前移除控制台的日志代码，因此 `no-debug` 规则作为一个有用的提醒来移除它。
- en: Now you know how to install and configure ESLint with `eslint-plugin-testing-library`
    to help avoid issues and follow best practices while writing tests.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你知道如何安装和配置 ESLint 与 `eslint-plugin-testing-library`，以帮助避免问题并在编写测试时遵循最佳实践。
- en: In the next section, we will go a step further by installing another plugin
    that is specific to `jest-dom`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过安装另一个针对 `jest-dom` 特定的插件来更进一步。
- en: Installing and configuring eslint-plugin-jest-dom
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置 eslint-plugin-jest-dom
- en: 'In the previous section, we installed and configured ESLint and `eslint-plugin-testing-library`.
    In this section, we will teach you how to install and configure `eslint-plugin-jest-dom`,
    ensuring we follow the best practices using `jest-dom`. Use the following command
    to install the plugin:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们安装并配置了 ESLint 和 `eslint-plugin-testing-library`。在本节中，我们将教你如何安装和配置 `eslint-plugin-jest-dom`，确保我们使用
    `jest-dom` 遵循最佳实践。使用以下命令安装插件：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The previous command installs `eslint-plugin-jest-dom` as a development dependency
    inside the project. Now that the plugin is installed, we can add it to our ESLint
    configuration file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将 `eslint-plugin-jest-dom` 作为项目中的开发依赖项安装。现在插件已安装，我们可以将其添加到我们的 ESLint 配置文件中：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the previous code, we added `plugin:jest-dom/recommended` to the `extends`
    array in the configuration file. The `recommended` configuration for the plugin
    is used to automatically include a set of standard rules to enforce `jest-dom`
    best practices. We will test a `checkbox` component that allows the user to select
    their preferred programming languages:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在配置文件中的 `extends` 数组中添加了 `plugin:jest-dom/recommended`。该插件的 `recommended`
    配置用于自动包含一组标准规则，以强制执行 `jest-dom` 的最佳实践。我们将测试一个允许用户选择他们首选编程语言的 `checkbox` 组件：
- en: '![Figure 6.8 – The languages checkbox component'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.8 – 语言复选框组件'
- en: '](img/Figure_6.8_B16887.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.8_B16887.jpg)'
- en: Figure 6.8 – The languages checkbox component
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – 语言复选框组件
- en: 'In the preceding screenshot, you can see that there are four checkboxes for
    programming languages that a user can select from. When a user selects a language,
    we get the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图上，你可以看到有四个编程语言的复选框，用户可以从中选择。当用户选择一种语言时，我们得到以下信息：
- en: '![Figure 6.9 – The selected language checkbox'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.9 – 已选语言复选框'
- en: '](img/Figure_6.9_B16887.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.9_B16887.jpg)'
- en: Figure 6.9 – The selected language checkbox
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – 已选语言复选框
- en: 'In the preceding screenshot, the user selects **JavaScript**, which results
    in the associated checkbox being selected, the text color changing to *green,*
    and the font-weight changing to *bold*. We can write a test to verify that the
    checkbox for the selected language is selected and has the expected classes associated
    with the color and font-weight of the text the user sees on the screen:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图上，用户选择了 **JavaScript**，这导致相关的复选框被选中，文本颜色变为 *绿色*，字体粗细变为 *粗体*。我们可以编写一个测试来验证所选语言的复选框被选中，并且具有与用户在屏幕上看到的文本颜色和字体粗细相匹配的预期类：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding code, we render the `LanguageCheckBox` component to the DOM.
    Next, we get the `jsCheckbox` variable, and click on it. Next, we will make assertions
    on the expected output. First, we try using the `toHaveAttribute` Jest matcher:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将 `LanguageCheckBox` 组件渲染到 DOM 中。接下来，我们获取 `jsCheckbox` 变量，并点击它。接下来，我们将对预期的输出进行断言。首先，我们尝试使用
    `toHaveAttribute` Jest 匹配器：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code, we use `toHaveAttribute` to verify that the checkbox
    has the `checked` attribute after being clicked. However, our test will fail with
    this matcher because it only looks for an explicit `checked` attribute that is
    added to the elements commonly used in situations where we want a prechecked checkbox.
    In our case, we''re testing the result of a user clicking on the checkbox in the
    resulting DOM, so we need a different matcher. Next, we try using the `toHaveProperty`
    Jest matcher:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `toHaveAttribute` 来验证在点击后复选框是否有 `checked` 属性。然而，我们的测试将因为这个匹配器而失败，因为它只寻找添加到元素中的显式
    `checked` 属性，这些元素通常用于我们想要预选中复选框的情况。在我们的情况下，我们正在测试用户点击结果 DOM 中复选框的结果，因此我们需要一个不同的匹配器。接下来，我们尝试使用
    `toHaveProperty` Jest 匹配器：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding code, we use the `toHaveProperty` Jest matcher to verify that
    the checkbox has the `checked` property set to `true`. This matcher works in a
    technical sense, but it doesn''t read very clearly. Additionally, when we hover
    over the matcher, we get the following output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `toHaveProperty` Jest 匹配器来验证复选框的 `checked` 属性被设置为 `true`。这个匹配器在技术上是可行的，但它读起来不是很清楚。此外，当我们悬停在匹配器上时，我们得到以下输出：
- en: '![Figure 6.10 – The prefer-checked linter suggestion'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.10 – prefer-checked 检查器建议](img/Figure_6.10_B16887.jpg)'
- en: '](img/Figure_6.10_B16887.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.10 – B16887.jpg](img/Figure_6.10_B16887.jpg)'
- en: Figure 6.10 – The prefer-checked linter suggestion
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – prefer-checked 检查器建议
- en: 'In the preceding screenshot, the `toHaveProperty` matcher is underlined by
    ESLint to draw our attention to the matcher''s issue. When we hover over the matcher,
    we get feedback indicating it should be replaced with the `jest-dom` `toBeChecked`
    matcher via the `prefer-checked` rule of `eslint-plugin-jest-dom`. The rule is
    automatically fixable and will refactor the matcher for us if we have our code
    editor set up. When we refactor our matcher, we get the following output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图上，`toHaveProperty` 匹配器被 ESLint 下划线标注以引起我们对匹配器问题的注意。当我们悬停在匹配器上时，我们得到反馈表明应该通过
    `eslint-plugin-jest-dom` 的 `prefer-checked` 规则将其替换为 `jest-dom` 的 `toBeChecked`
    匹配器。该规则可以自动修复，并且如果我们的代码编辑器设置正确，它将为我们重构匹配器。当我们重构我们的匹配器时，我们得到以下输出：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, we use the `toBeChecked` `jest-dom` matcher to verify
    that the checkbox is checked. Now we have a matcher that eliminates any issues
    with previous matcher versions and also reads a lot better. Next, we will assert
    the expected classes:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `toBeChecked` `jest-dom` 匹配器来验证复选框是否被选中。现在我们有一个匹配器，它消除了先前匹配器版本中的任何问题，并且读起来要好得多。接下来，我们将断言预期的类：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding code, we access the `className` property inside the element
    with the `javascript` text to verify that it contains the `text-success` and `font-weight-bold`
    classes. However, when we hover over `toContain`, we get the following feedback:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过 `javascript` 文本访问元素内部的 `className` 属性以验证它是否包含 `text-success` 和
    `font-weight-bold` 类。然而，当我们悬停在 `toContain` 上时，我们得到以下反馈：
- en: '![Figure 6.11 – The prefer-to-have-class linter suggestion'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.11 – prefer-to-have-class 检查器建议](img/Figure_6.11_B16887.jpg)'
- en: '](img/Figure_6.11_B16887.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.11 – B16887.jpg](img/Figure_6.11_B16887.jpg)'
- en: Figure 6.11 – The prefer-to-have-class linter suggestion
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 – prefer-to-have-class 检查器建议
- en: 'In the preceding screenshot, the `toContain` matcher is underlined by ESLint
    to draw our attention to the matcher''s issue. When we hover over the matcher,
    we get feedback indicating that it should be replaced with the `jest-dom` `toHaveClass`
    matcher via the `prefer-to-have-class` rule of `eslint-plugin-jest-dom`. Similar
    to the previous example, the `prefer-to-have-class` rule is automatically fixable
    and will refactor the matcher for us if we have our code editor set up to do so.
    When we refactor the code, we get the following output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图上，`toContain` 匹配器被 ESLint 下划线标注以引起我们对匹配器问题的注意。当我们悬停在匹配器上时，我们得到反馈表明应该通过
    `jest-dom` 的 `toHaveClass` 匹配器替换它，这是通过 `eslint-plugin-jest-dom` 的 `prefer-to-have-class`
    规则实现的。与前面的例子类似，`prefer-to-have-class` 规则可以自动修复，并且如果我们的代码编辑器设置正确，它将为我们重构匹配器。当我们重构代码时，我们得到以下输出：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, we refactored our code to use the `jest-dom` `toHaveClass`
    matcher. Now we have a matcher that is easier to implement and read compared to
    our original example.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将代码重构为使用 `jest-dom` 的 `toHaveClass` 匹配器。现在我们有一个比原始示例更容易实现和阅读的匹配器。
- en: Now you understand how to install and use the `eslint-plugin-jest-dom` plugin
    to use assertion matchers that follow the `jest-dom` best practices. In the next
    section, we will learn how to install and use a package to increase the accessibility
    of our component's source code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何安装和使用 `eslint-plugin-jest-dom` 插件来使用遵循 `jest-dom` 最佳实践的断言匹配器。在下一节中，我们将学习如何安装和使用一个包来提高我们组件源代码的易访问性。
- en: Testing accessibility with jest-axe
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 jest-axe 测试易访问性
- en: 'In this section, we will learn how to use a tool that is designed to help improve
    the accessibility of our features. There are many tools available that can help
    increase accessibility by automating the process of auditing and reporting issues,
    such as Wave ([https://wave.webaim.org/](https://wave.webaim.org/)) and Lighthouse
    ([https://developers.google.com/web/tools/lighthouse](https://developers.google.com/web/tools/lighthouse)).
    However, there is no single tool that can guarantee accessibility across an entire
    application. Accessibility auditing tools are helpful, but they do not replace
    the need for manual accessibility auditing done by a human. For example, when
    an abbreviation is used for the first time in a line of text, the related expanded
    version should be included:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用一个旨在帮助我们改进功能易访问性的工具。有许多工具可以帮助通过自动化审计和报告问题的过程来提高易访问性，例如 Wave ([https://wave.webaim.org/](https://wave.webaim.org/))
    和 Lighthouse ([https://developers.google.com/web/tools/lighthouse](https://developers.google.com/web/tools/lighthouse))。然而，没有单个工具可以保证整个应用程序的易访问性。易访问性审计工具是有帮助的，但它们不能取代由人类进行的手动易访问性审计的需求。例如，当在文本行中首次使用缩写时，应包括相关的扩展版本：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding sentence, the expanded version, `Structured Query Language`,
    is included with its abbreviated form, `SQL`. The sentence would need to be manually
    checked to verify accessibility. We will learn how to use `jest-axe`, which is
    a tool that adds a custom matcher for Jest and behaves in ways that are similar
    to ESLint. The tool helps find and report common accessibility issues in your
    code, such as image buttons with no alternate text or `inputs` with no associated
    labels. Use the following command to install the tool:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的句子中，扩展版本 `结构化查询语言` 与其缩写形式 `SQL` 一起包含。该句子需要手动检查以验证易访问性。我们将学习如何使用 `jest-axe`，这是一个为
    Jest 添加自定义匹配器并具有与 ESLint 类似行为的工具。该工具有助于在您的代码中查找和报告常见的易访问性问题，例如没有替代文本的图像按钮或没有相关标签的
    `inputs`。使用以下命令安装此工具：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The previous command installs `jest-axe` as a development dependency inside
    the project. Now that the tool is installed, we can use it in our tests. First,
    we will test the accessibility of an image button:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令在项目中安装了 `jest-axe` 作为开发依赖。现在工具已安装，我们可以在测试中使用它。首先，我们将测试图像按钮的易访问性：
- en: '![Figure 6.12 – An inaccessible image button](img/Figure_6.12_B16887.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.12 – 一个不可访问的图像按钮](img/Figure_6.12_B16887.jpg)'
- en: Figure 6.12 – An inaccessible image button
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – 一个不可访问的图像按钮
- en: 'In the preceding screenshot, we have an image that behaves as a **Submit**
    button. The following is the source code for the image button:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们有一个作为 **提交** 按钮行为的图像。以下是该图像按钮的源代码：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding code, we will import an image and pass it as `source` for
    an input of the `image` type. Now we will write a test to verify that the element
    is accessible to users:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将导入一个图像并将其作为 `image` 类型的输入的 `source`。现在我们将编写一个测试来验证该元素对用户是可访问的：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding code, first, we import the `render` method from React Testing
    Library. Then, we import the `axe` method from `jest-axe`. The `axe` method is
    what we will use to audit the accessibility of our component. Next, we import
    `jest-axe/extend-expect`, which adds a special matcher to Jest to report the audit
    outcome in a readable format. Finally, we import the `NoAccessibility` component
    to test. Next, we will write the main test code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们从 React Testing Library 中导入 `render` 方法。然后，我们从 `jest-axe` 中导入 `axe`
    方法。`axe` 方法是我们将用来审计我们组件的易访问性的方法。接下来，我们导入 `jest-axe/extend-expect`，它为 Jest 添加了一个特殊的匹配器，以便以可读的格式报告审计结果。最后，我们导入
    `NoAccessibility` 组件进行测试。接下来，我们将编写主要的测试代码：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, first, we destructure `container` off the rendered component.
    Unlike query methods, we can destructure `container` off the rendered component
    without violating DOM Testing Library's best practices because it is not available
    on the `screen` object. `container` is the `div` element that wraps your React
    component under test.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们从渲染的组件中解构 `container`。与查询方法不同，我们可以在不违反 DOM 测试库的最佳实践的情况下从渲染的组件中解构
    `container`，因为它不在 `screen` 对象上。`container` 是包裹你的待测试 React 组件的 `div` 元素。
- en: Next, we pass `container` as an argument to the `axe` method and store it in
    the `results` variable. The `axe` method will run an accessibility audit across
    our component under test. Finally, we assert that the results have no accessibility
    issues using the `toHaveNoViolations` matcher. The test will pass if no violations
    are found.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将 `container` 作为参数传递给 `axe` 方法，并将其存储在 `results` 变量中。`axe` 方法将在我们的待测试组件上运行可访问性审计。最后，我们使用
    `toHaveNoViolations` 匹配器断言结果没有可访问性问题。如果没有发现违规，测试将通过。
- en: 'However, if violations are found, the test will fail and provide feedback to
    resolve those issues. When we run the test, we get the following output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果发现违规，测试将失败并提供反馈以解决这些问题。当我们运行测试时，我们得到以下输出：
- en: '![Figure 6.13 – Inaccessible image button test output'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.13 – 不可访问图像按钮测试输出'
- en: '](img/Figure_6.13_B16887.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.13_B16887.jpg)'
- en: Figure 6.13 – Inaccessible image button test output
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 – 不可访问图像按钮测试输出
- en: 'The preceding screenshot shows that accessibility violations were found in
    the `NoAccessibility` component, which resulted in a test failure with feedback.
    First, the feedback indicates that an `input` element is the source of the issue.
    Next, we see the entire element printed on the screen. Then, we get the `"Image
    buttons must have alternate text (input-image-alt)"` message, informing us why
    the element failed the audit. Next, we get several suggestions that we can implement
    to resolve the issue. Finally, we get a hyperlink that we can follow to gain a
    deeper understanding of the issue. We will resolve the issue by providing an `alt`
    attribute:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图显示，在 `NoAccessibility` 组件中发现了可访问性违规，导致测试失败并提供反馈。首先，反馈表明 `input` 元素是问题的来源。接下来，我们看到整个元素打印在屏幕上。然后，我们得到
    `"Image buttons must have alternate text (input-image-alt)"` 消息，告知我们为什么该元素未能通过审计。接下来，我们得到一些可以实施的建议来解决该问题。最后，我们得到一个超链接，我们可以通过它来深入了解问题。我们将通过提供
    `alt` 属性来解决该问题：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding code, we added an `alt` attribute with the value of `login`.
    Now, when we rerun our test, we get the following result:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了一个值为 `login` 的 `alt` 属性。现在，当我们重新运行我们的测试时，我们得到以下结果：
- en: '![Figure 6.14 – Accessible image button test output'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.14 – 可访问图像按钮测试输出'
- en: '](img/Figure_6.14_B16887.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.14_B16887.jpg)'
- en: Figure 6.14 – Accessible image button test output
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 – 可访问图像按钮测试输出
- en: 'In the preceding screenshot, the test results indicate that `NoAccessibility,
    given accessibility audit, returns no violations` passes with no violations. Next,
    we will test the accessibility of a list that includes an image:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，测试结果显示，在可访问性审计中，`NoAccessibility` 没有违反规则，测试通过且没有违反规则。接下来，我们将测试包含图像的列表的可访问性：
- en: '![Figure 6.15 – An inaccessible list'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.15 – 不可访问列表'
- en: '](img/Figure_6.15_B16887.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.15_B16887.jpg)'
- en: Figure 6.15 – An inaccessible list
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15 – 不可访问列表
- en: 'In the preceding screenshot, we have an unordered list that includes an `image`
    element. The following is the source code for the list:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们有一个包含 `image` 元素的未有序列表。以下是列表的源代码：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding code, we have an unordered list element with two `list item`
    child elements and one `image` child element. Our test code will be the same as
    the previous test for the image button. The only difference here is the component
    that we pass into the `render` method. So, for this example, we will only focus
    on the test results:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个包含两个 `list item` 子元素和一个 `image` 子元素的未有序列表元素。我们的测试代码将与之前图像按钮的测试代码相同。这里唯一的区别是我们传递给
    `render` 方法的组件。因此，对于这个例子，我们只关注测试结果：
- en: '![Figure 6.16 – Inaccessible list test results](img/Figure_6.16_B16887.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.16 – 不可访问列表测试结果](img/Figure_6.16_B16887.jpg)'
- en: Figure 6.16 – Inaccessible list test results
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16 – 不可访问列表测试结果
- en: The preceding screenshot shows that accessibility violations were found in the
    unordered list component, which resulted in a test failure with feedback. First,
    the feedback indicates that a `ul` element is the source of the issue. Next, we
    see the entire element printed on the screen. Then, we get the `"<ul> and <ol>
    must only directly contain <li>, <script> or <template> elements (list)"` message,
    which helps us to understand why the element failed the audit.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示，在无序列表组件中发现了可访问性违规，这导致测试失败并给出反馈。首先，反馈表明问题源是一个 `ul` 元素。接下来，我们看到整个元素在屏幕上打印出来。然后，我们得到
    `"<ul> 和 <ol> 必须仅直接包含 <li>、<script> 或 <template> 元素（列表）"` 的消息，这有助于我们理解为什么该元素未能通过审核。
- en: 'Next, we get a suggestion regarding how to resolve the issue. Finally, we get
    a hyperlink that we can follow to gain a deeper understanding of the issue. We
    will resolve the issue by moving the image inside an `li` element:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们得到有关如何解决问题的建议。最后，我们得到一个超链接，我们可以点击以深入了解问题。我们将通过将图像移动到 `li` 元素内来解决问题：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the previous code, we wrapped the `image` element inside an `li` element.
    When we rerun our test, the test will pass and return results that are similar
    to what we saw in the image button's previous test. Now you know how to use `jest-axe`
    to increase the accessibility of applications using React with Jest. It is important
    to reiterate that automated accessibility tools help increase our applications'
    ability to work for various end users. However, they cannot catch all issues and
    are not a replacement for manual audits.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们将 `image` 元素包裹在一个 `li` 元素内。当我们重新运行测试时，测试将通过并返回与我们在图像按钮之前测试中看到的结果相似的结果。现在你知道如何使用
    `jest-axe` 来提高使用 Jest 的 React 应用的可访问性。重要的是要重申，自动化可访问性工具有助于提高我们应用程序为各种最终用户工作的能力。然而，它们不能捕捉到所有问题，也不能替代人工审核。
- en: Next, we will learn how to use a tool to speed up our element selections with
    React Testing Library.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何使用工具来通过 React Testing Library 加速我们的元素选择。
- en: Selecting the best queries with Testing Playground
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Testing Playground 选择最佳查询
- en: In this section, we will learn how to use **Testing Playground**. This is a
    tool that makes it easier for you to determine the right DOM Testing Library query
    selector. Testing Playground allows you to paste HTML into an interactive website,
    which allows you to click on elements as they appear rendered in the browser.
    This enables you to learn which DOM Testing Library queries can be used to select
    a particular element.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用 **Testing Playground**。这是一个使你更容易确定正确的 DOM Testing Library 查询选择器的工具。Testing
    Playground 允许你将 HTML 粘贴到一个交互式网站上，这样你就可以在浏览器中渲染元素时点击它们。这使得你可以了解哪些 DOM Testing Library
    查询可以用来选择特定的元素。
- en: 'The tool always suggests queries in order, based on the DOM Testing Library
    query recommendations for elements that offer multiple ways of selection. Furthermore,
    the tool allows you to copy the selector to use in your test code. We will look
    at two ways of using Testing Playground: first, via the website, and second, via
    a Chrome extension.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 工具总是根据 DOM Testing Library 对具有多种选择方式的元素的查询推荐顺序建议查询。此外，该工具允许你将选择器复制到测试代码中使用。我们将探讨两种使用
    Testing Playground 的方法：首先是通过网站，其次是通过 Chrome 扩展程序。
- en: Selecting queries using the Testing Playground website
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Testing Playground 网站选择查询
- en: In this section, we will learn how to use Testing Playground via its website.
    In previous examples throughout the book, we used the `debug` method to log the
    resulting HTML of components to the console while writing tests. One limitation
    of the `debug` method is that it has no feature that enables you to log the output
    to the browser and test out different query methods to select elements.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何通过其网站使用 Testing Playground。在本书前面的示例中，我们使用了 `debug` 方法在编写测试时将组件的结果
    HTML 记录到控制台。`debug` 方法的局限性之一是它没有功能可以让你将输出记录到浏览器并测试不同的查询方法来选择元素。
- en: 'We can use the `logTestingPlaygroundURL` method inside a test file to log the
    resulting HTML to a browser via *Testing Playground* ([https://testing-playground.com/](https://testing-playground.com/))
    and utilize the site''s query selector features. For example, we could be in the
    process of selecting elements in a test for the following `MoreInfoPopover` component:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在测试文件中使用 `logTestingPlaygroundURL` 方法将结果 HTML 记录到浏览器中的 *Testing Playground*
    ([https://testing-playground.com/](https://testing-playground.com/))，并利用该网站的查询选择器功能。例如，我们可能正在为以下
    `MoreInfoPopover` 组件选择元素进行测试：
- en: '![Figure 6.17 – The Popover component'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.17 – Popover 组件'
- en: '](img/Figure_6.17_B16887.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.17_B16887.jpg)'
- en: Figure 6.17 – The Popover component
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17 – 弹出组件
- en: 'In the preceding screenshot, we have a `button` element with the text `button`
    element using DOM Testing Library queries, so we start our test as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图上，我们有一个带有文本`button`元素的`button`元素，使用DOM测试库查询，因此我们开始测试如下：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We import the `render` and `screen` methods from React Testing Library and
    the component under test in the preceding code. Inside the main test code, first,
    we render the component in the DOM. Next, we call the `logTestingPlaygroundURL`
    method. When we run the test, we get the following output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们导入了React测试库的`render`和`screen`方法以及待测试的组件。在主测试代码内部，首先，我们在DOM中渲染组件。接下来，我们调用`logTestingPlaygroundURL`方法。当我们运行测试时，我们得到以下输出：
- en: '![Figure 6.18 – The Testing Playground link](img/Figure_6.18_B16887.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图6.18 – 测试游乐场链接](img/Figure_6.18_B16887.jpg)'
- en: Figure 6.18 – The Testing Playground link
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18 – 测试游乐场链接
- en: 'In the preceding screenshot, we have a unique link to the Testing Playground
    website to follow and view our component''s rendered HTML. When we follow the
    link, we should see something similar to the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图上，我们有一个唯一的链接，可以访问测试游乐场网站并查看我们的组件渲染的HTML。当我们点击链接时，我们应该看到以下类似的内容：
- en: '![Figure 6.19 – The Testing Playground HTML structure'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.19 – 测试游乐场HTML结构'
- en: '](img/Figure_6.19_B16887.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.19_B16887.jpg)'
- en: Figure 6.19 – The Testing Playground HTML structure
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19 – 测试游乐场HTML结构
- en: 'In the preceding screenshot, the link navigated us to the Testing Playground
    website. First, we see a section that includes the HTML structure for our component.
    Next, we see the rendered browser output, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图上，链接将我们导航到测试游乐场网站。首先，我们看到一个包含我们组件HTML结构的部分。接下来，我们看到渲染的浏览器输出，如下所示：
- en: '![Figure 6.20 – The Testing Playground browser output](img/Figure_6.20_B16887.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图6.20 – 测试游乐场浏览器输出](img/Figure_6.20_B16887.jpg)'
- en: Figure 6.20 – The Testing Playground browser output
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20 – 测试游乐场浏览器输出
- en: 'In the preceding screenshot, we can see a section with the browser output for
    our component. Notice that we don''t see the complete result with associated styles
    included. The Testing Playground website only displays the HTML content. Next,
    we see a **suggested query** section, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图上，我们可以看到一个包含我们组件浏览器输出的部分。注意，我们没有看到包含相关样式的完整结果。测试游乐场网站仅显示HTML内容。接下来，我们看到一个**建议查询**部分，如下所示：
- en: '![Figure 6.21 – Testing Playground suggested query'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.21 – 测试游乐场建议查询'
- en: '](img/Figure_6.21_B16887.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.21_B16887.jpg)'
- en: Figure 6.21 – Testing Playground suggested query
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.21 – 测试游乐场建议查询
- en: In the preceding screenshot, we get a `button` element we clicked on in the
    browser output section. The `getByRole` query is the best way to select the button
    based on its HTML structure. Additionally, we can see the **This is great. Ship
    it!** message, which suggests that we should use this query further.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图上，我们在浏览器输出部分点击了一个`button`元素。`getByRole`查询是根据HTML结构选择按钮的最佳方式。此外，我们还可以看到**这太棒了。发货**的消息，这表明我们应该进一步使用此查询。
- en: 'There are also other options available, as shown in the following screenshot,
    to select the element:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了其他可选的选项，用于选择元素：
- en: '![Figure 6.22 – Testing Playground query priority options'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.22 – 测试游乐场查询优先级选项'
- en: '](img/Figure_6.22_B16887.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.22_B16887.jpg)'
- en: Figure 6.22 – Testing Playground query priority options
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.22 – 测试游乐场查询优先级选项
- en: 'In the preceding code, we can see multiple options to select the element in
    order of priority. Based on the HTML structure of the `button` element, there
    are two ways we could choose the element – *by its role* and *by its text value*.
    The other listed queries are not available for the button and, therefore, display
    **n/a**. If we decide to select the **Text** query option, we should see something
    similar to the following screenshot:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到多个选项，按照优先级顺序选择元素。根据`button`元素的HTML结构，我们可以选择两种方式来选择元素 – *通过其角色*
    和 *通过其文本值*。其他列出的查询对于按钮不可用，因此显示**不可用**。如果我们决定选择**文本**查询选项，我们应该看到以下截图类似的内容：
- en: '![Figure 6.23 – The Testing Playground text query option'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.23 – 测试游乐场文本查询选项'
- en: '](img/Figure_6.23_B16887.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.23_B16887.jpg)'
- en: Figure 6.23 – The Testing Playground text query option
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.23 – 测试游乐场文本查询选项
- en: In the preceding screenshot, we can see the text `getByText` to select the button,
    it is not the best query for the selected element. Once we decide on the query
    we want to grab the element, we can click on the icon displayed on the far right
    of the **suggested query** box to copy the code needed to select the element within
    our test.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到用于选择按钮的文本`getByText`，它不是选择所选元素的最佳查询。一旦我们决定要抓取的查询，我们就可以点击**建议查询**框最右侧的图标来复制选择测试中元素的所需代码。
- en: Now you know how to use the `logTestingPlaygroundURL` method to select elements
    using the Testing Playground website. There is one notable limitation to using
    the Testing Playground website. When we click on the **More Info** button, we
    should see a popup appear beneath the button. We cannot use the Testing Playground
    website to perform this action since it only copies the HTML and not the associated
    JavaScript to render the result of clicking on the button.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何使用`logTestingPlaygroundURL`方法通过Testing Playground网站选择元素。使用Testing
    Playground网站有一个显著的限制。当我们点击**更多信息**按钮时，我们应该看到一个弹出窗口出现在按钮下方。由于它只复制HTML而不是相关的JavaScript来渲染按钮点击的结果，我们无法使用Testing
    Playground网站执行此操作。
- en: In the next section, we will learn how to use the Testing Playground Chrome
    extension to overcome this limitation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用Testing Playground Chrome扩展程序来克服这个限制。
- en: Selecting queries using the Testing Playground Chrome extension
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Testing Playground Chrome扩展程序选择查询
- en: In this section, we will install and use the Testing Playground Chrome extension
    to overcome the limitations of using the Testing Playground website. This extension
    provides the benefit of allowing you to use Testing Playground features locally,
    in the same browser that is used to run your application. The extension is currently
    only available for the Google Chrome browser, so be sure to install it if necessary.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将安装和使用Testing Playground Chrome扩展程序来克服使用Testing Playground网站的限制。此扩展程序的好处是允许你在运行应用程序的同一浏览器中本地使用Testing
    Playground功能。该扩展程序目前仅适用于Google Chrome浏览器，所以如果需要，请确保安装它。
- en: Install the *Testing Playground Chrome extension* ([https://chrome.google.com/webstore/detail/testing-playground/hejbmebodbijjdhflfknehhcgaklhano](https://chrome.google.com/webstore/detail/testing-playground/hejbmebodbijjdhflfknehhcgaklhano))
    via the Chrome Web Store. Once the extension is installed, a new **Testing Playground**
    tab is added to your **Chrome Developer Tools**.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Chrome Web Store安装*Testing Playground Chrome扩展程序*([https://chrome.google.com/webstore/detail/testing-playground/hejbmebodbijjdhflfknehhcgaklhano](https://chrome.google.com/webstore/detail/testing-playground/hejbmebodbijjdhflfknehhcgaklhano))。一旦扩展程序安装完成，就会在你的**Chrome开发者工具**中添加一个新的**Testing
    Playground**标签页。
- en: 'Going back to the `MoreInfoPopover` component from the previous section, we
    can write a test to verify that the popover is displayed when a user clicks on
    the **More Info** button:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到上一节中的`MoreInfoPopover`组件，我们可以编写一个测试来验证当用户点击**更多信息**按钮时，弹出窗口是否显示：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding code, we render `MoreInfoPopover` in the DOM. Next, we will
    use the Testing Playground extension to find the preferred query selector for
    the button:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在DOM中渲染了`MoreInfoPopover`。接下来，我们将使用Testing Playground扩展程序来找到按钮的首选查询选择器：
- en: '![Figure 6.24 – The Testing Playground Chrome extension'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.24 – The Testing Playground Chrome extension]'
- en: '](img/Figure_6.24_B16887.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_6.24_B16887.jpg]'
- en: Figure 6.24 – The Testing Playground Chrome extension
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.24 – Testing Playground Chrome扩展程序
- en: 'In the previous screenshot, we can see a tab added for the `getByRole` query
    selector. When we copy the selector, we get the query code to add to our test:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到一个为`getByRole`查询选择器添加的标签页。当我们复制选择器时，我们得到要添加到我们的测试中的查询代码：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding code, we copied the `getByRole` selector to access the **More
    Info** button. Next, we will use the extension to help select the popover, which
    is displayed after clicking on the button:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们复制了`getByRole`选择器以访问**更多信息**按钮。接下来，我们将使用扩展程序来帮助选择弹出窗口，该弹出窗口在点击按钮后显示：
- en: '![Figure 6.25 – The popover query selector](img/Figure_6.25_B16887.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 6.25 – The popover query selector](img/Figure_6.25_B16887.jpg)'
- en: Figure 6.25 – The popover query selector
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.25 – 弹出查询选择器
- en: 'In the preceding screenshot, `getByRole` is the suggested query for the `popover`
    element after selecting it in the browser. Now we have all the selectors that
    we need to write the remaining test code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，`getByRole`是在浏览器中选择`popover`元素后建议的查询。现在我们有了编写剩余测试代码所需的所有选择器：
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the preceding code, first, we click on the `popover` element by its heading
    and store it in a variable. Notice that we used `findByRole` instead of the `getByRole`
    query. Testing Playground only provides `getBy*` queries, so it might be necessary
    to modify the copied query based on the situation. Finally, we assert that the
    `popover` element is in the DOM. When we run the test, we get the following result:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们通过其标题点击 `popover` 元素并将其存储在一个变量中。请注意，我们使用了 `findByRole` 而不是 `getByRole`
    查询。Testing Playground 只提供 `getBy*` 查询，因此可能需要根据情况修改复制的查询。最后，我们断言 `popover` 元素在
    DOM 中。当我们运行测试时，我们得到以下结果：
- en: '![Figure 6.26 – The popover test results'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.26 – 弹出测试结果'
- en: '](img/Figure_6.26_B16887.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.26_B16887.jpg)'
- en: Figure 6.26 – The popover test results
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.26 – 弹出测试结果
- en: In the previous screenshot, the results indicate that the `MoreInfoPopover,
    given clicked button, displays popover` test passes as expected. Now you know
    how to install and use the Testing Playground Chrome extension to enhance your
    workflow when writing tests. The Testing Playground website and extension are
    great supporting tools to utilize when working with DOM Testing Library.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，结果显示 `MoreInfoPopover, given clicked button, displays popover` 测试按预期通过。现在您知道了如何安装和使用
    Testing Playground Chrome 扩展来增强编写测试时的工作流程。Testing Playground 网站和扩展是处理 DOM 测试库时的优秀辅助工具。
- en: In the next section, we will learn how to use a tool that will speed up the
    results feedback from beginning to completion when writing tests.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用一个工具，该工具将加快编写测试时从开始到完成的结果反馈。
- en: Increasing our testing productivity with Wallaby.js
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Wallaby.js 提高我们的测试生产力
- en: In this section, we will learn how to increase our productivity by using the
    Wallaby.js productivity tool. Wallaby.js works by automatically running your tests
    behind the scenes via a Headless Chrome browser. There is also the option to run
    tests in other environments, such as Node.js or Phantom.js, with a custom configuration
    file. Wallaby.js helps to speed up your workflow by providing immediate test results
    inside your code editor, so you can type without needing to save and run a test
    script to view the results.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何通过使用 Wallaby.js 生产力工具来提高我们的生产力。Wallaby.js 通过在后台通过无头 Chrome 浏览器自动运行您的测试来实现。还有在
    Node.js 或 Phantom.js 等其他环境中运行测试的选项，并带有自定义配置文件。Wallaby.js 通过在代码编辑器内提供即时测试结果来帮助加快您的工作流程，因此您可以在无需保存和运行测试脚本查看结果的情况下进行输入。
- en: 'Wallaby.js provides many features, such as the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Wallaby.js 提供了许多功能，例如以下内容：
- en: '**Time Travel Debugging**: This allows you to navigate through your code to
    pinpoint bug sources easily.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间旅行调试**：这允许您轻松地导航代码以定位错误源。'
- en: '**Test Story Viewer**: This provides the ability to view the code associated
    with your test on one compact screen.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试故事查看器**：这提供了在单个紧凑屏幕上查看与您的测试相关联的代码的能力。'
- en: '**Inline Code Coverage**: This informs you of the test coverage for each line
    of code inside the code editor.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内联代码覆盖率**：这会告知您代码编辑器内每行代码的测试覆盖率。'
- en: Note
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Please refer to the *Features* section ([https://wallabyjs.com/#features](https://wallabyjs.com/#features))
    on the Wallaby.js documentation website for a complete list of features.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请参考 Wallaby.js 文档网站上的 *功能* 部分 ([https://wallabyjs.com/#features](https://wallabyjs.com/#features))
    以获取功能列表的完整列表。
- en: Installing and configuring Wallaby.js
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置 Wallaby.js
- en: In this section, we will learn how to install and set up Wallaby.js for the
    Visual Studio Code editor. Please refer to the *Install* section ([https://wallabyjs.com/download/](https://wallabyjs.com/download/))
    on the Wallaby.js documentation website for a complete list of installation options.
    To get started, add the Wallaby.js VSCode extension to your editor via the *VSCode
    Marketplace* ([https://marketplace.visualstudio.com/items?itemName=WallabyJs.wallaby-vscode](https://marketplace.visualstudio.com/items?itemName=WallabyJs.wallaby-vscode)).
    Once the extension has been installed, we can configure it to work in our project.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何为 Visual Studio Code 编辑器安装和设置 Wallaby.js。请参考 Wallaby.js 文档网站上的 *安装*
    部分 ([https://wallabyjs.com/download/](https://wallabyjs.com/download/)) 以获取完整的安装选项列表。要开始，请通过
    *VSCode 市场place* ([https://marketplace.visualstudio.com/items?itemName=WallabyJs.wallaby-vscode](https://marketplace.visualstudio.com/items?itemName=WallabyJs.wallaby-vscode))
    将 Wallaby.js VSCode 扩展添加到您的编辑器中。一旦扩展被安装，我们就可以配置它以在我们的项目中工作。
- en: The quickest and easiest way to configure Wallaby.js is with automatic configuration.
    Projects using specific versions of tools such as `create-react-app version 3`
    or greater, or `Jest version 24` or greater, qualify for automatic configuration.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 配置Wallaby.js最快最简单的方法是使用自动配置。使用特定版本的工具（如`create-react-app版本3`或更高版本，或`Jest版本24`或更高版本）的项目符合自动配置条件。
- en: For projects that do not qualify for automatic configuration, please refer to
    the *Configuration File* section ([https://wallabyjs.com/docs/intro/config.html?editor=vsc#configuration-file](https://wallabyjs.com/docs/intro/config.html?editor=vsc#configuration-file))
    in the Wallaby.js documentation for specific configurations based on your project
    setup.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不符合自动配置的项目，请参考Wallaby.js文档中的“配置文件”部分（[https://wallabyjs.com/docs/intro/config.html?editor=vsc#configuration-file](https://wallabyjs.com/docs/intro/config.html?editor=vsc#configuration-file)），根据您的项目设置获取具体的配置信息。
- en: 'Start Wallaby.js in VSCode with automatic configuration using the command palette:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令面板在VSCode中启动Wallaby.js并使用自动配置：
- en: '![Figure 6.27 – Select Configuration'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.27 – 选择配置](img/Figure_6.27_B16887.jpg)'
- en: '](img/Figure_6.27_B16887.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.27 – Wallaby.js配置文件](img/Figure_6.27_B16887.jpg)'
- en: Figure 6.27 – Select Configuration
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.27 – 选择配置
- en: 'In the preceding screenshot, `wallaby` is entered into the command palette
    to bring up the available Wallaby.js commands. We will click on the **Wallaby.js:
    Select Configuration** option:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的屏幕截图中，我们在命令面板中输入`wallaby`以显示可用的Wallaby.js命令。我们将点击**Wallaby.js: 选择配置**选项：'
- en: '![Figure 6.28 – The Automatic Configuration option'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.28 – 自动配置选项'
- en: '](img/Figure_6.28_B16887.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.28 – Wallaby.js配置文件](img/Figure_6.28_B16887.jpg)'
- en: Figure 6.28 – The Automatic Configuration option
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.28 – 自动配置选项
- en: 'In the preceding screenshot, we have selected the **Automatic Configuration
    <project directory>** and **Automatic Configuration <custom directory>** options.
    We will select **<project directory>** to use the directory of our current project.
    Once we select the configuration, Wallaby.js will start and run our tests to provide
    feedback directly inside the test files of the code editor, as shown in the following
    screenshot:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们已选择**自动配置 <项目目录>**和**自动配置 <自定义目录>**选项。我们将选择**<项目目录>**以使用当前项目的目录。一旦选择配置，Wallaby.js将启动并运行我们的测试，直接在代码编辑器的测试文件中提供反馈，如下面的屏幕截图所示：
- en: '![Figure 6.29 – Wallaby.js enhanced test output'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.29 – Wallaby.js增强测试输出](img/Figure_6.29_B16887.jpg)'
- en: '](img/Figure_6.29_B16887.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.29 – Wallaby.js增强测试输出](img/Figure_6.29_B16887.jpg)'
- en: Figure 6.29 – Wallaby.js enhanced test output
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.29 – Wallaby.js增强测试输出
- en: In the preceding screenshot, we can see a test that we created earlier, in the
    *Selecting the best queries with Testing Playground* section of this chapter,
    enhanced with Wallaby.js' features. First, we see green-colored square shapes
    to the left of the line numbers indicating that all the test lines have passed.
    Next, we see links for the Wallaby.js **Debug**, **View Story**, **Profile**,
    and **Focus** features, which we can click on to analyze the test from the perspective
    of that particular feature.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到一个在“使用测试游乐场选择最佳查询”部分创建的测试，并增强了Wallaby.js的功能。首先，我们看到行号左侧有绿色的方块形状，表示所有测试行都已通过。接下来，我们看到Wallaby.js的**调试**、**查看故事**、**分析**和**聚焦**功能的链接，我们可以点击它们来从特定功能的视角分析测试。
- en: Finally, we see the test runtime, `45ms`, logged next to the test. Now you understand
    how to install and configure Wallaby.js. You should also understand the basic
    enhancements that Wallaby.js adds directly inside the test files.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到测试运行时间`45ms`记录在测试旁边。现在您已经了解了如何安装和配置Wallaby.js。您也应该了解Wallaby.js直接在测试文件中添加的基本增强功能。
- en: In the next section, we will walk through how to write a test utilizing Wallaby.js's
    Interactive Test Output feature.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍如何使用Wallaby.js的交互式测试输出功能编写测试。
- en: Writing tests with Interactive Test Output
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用交互式测试输出编写测试
- en: In the *Selecting the best queries with Testing Playground* section of this
    chapter, we wrote the `MoreInfoPopover, given clicked button, displays popover`
    test for a `MoreInfoPopover` component. Let's walk through how to create the same
    test utilizing Wallaby.js.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的“使用测试游乐场选择最佳查询”部分，我们为`MoreInfoPopover`组件编写了`MoreInfoPopover, given clicked
    button, displays popover`测试。现在让我们来了解一下如何使用Wallaby.js创建相同的测试。
- en: 'First, we will render the component under test in the DOM and use the `debug`
    method to log the current state of the HTML output:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将测试组件渲染到DOM中，并使用`debug`方法记录当前HTML输出的状态：
- en: '![Figure 6.30 – The Wallaby.js inline debug output'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.30 – Wallaby.js内联调试输出'
- en: '](img/Figure_6.30_B16887.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.30_B16887.jpg)'
- en: Figure 6.30 – The Wallaby.js inline debug output
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.30 – Wallaby.js 内联调试输出
- en: In the preceding screenshot, we used the `//?` command from Wallaby.js to log
    the results of `debug` directly inside the code editor. The output is automatically
    displayed horizontally to the right of `debug` when we hover over the method.
    This feature speeds up our workflow because, normally, we would have to execute
    our test runner from the command line to see the output.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们使用了 Wallaby.js 的 `//?` 命令将 `debug` 的结果直接记录在代码编辑器中。当我们将鼠标悬停在方法上时，输出会自动显示在
    `debug` 的右侧。此功能加快了我们的工作流程，因为通常情况下，我们不得不从命令行执行测试运行器来查看输出。
- en: 'Next, we will add queries to select the DOM elements:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加查询以选择 DOM 元素：
- en: '![Figure 6.31 – A query error'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.31 – 查询错误]'
- en: '](img/Figure_6.31_B16887.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.31_B16887.jpg)'
- en: Figure 6.31 – A query error
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.31 – 查询错误
- en: In the preceding screenshot, we have a test failure resulting from React Testing
    Library not finding a `heading` element named `lorem ipsum`. Wallaby.js increases
    our ability to discover the error in two ways. First, we see a red-colored square
    shape to the left of the test name and, specifically, the line number where the
    error occurred. The inline code notifications help us to quickly identify where
    we should focus on pinpointing the cause of the error. Second, when we hover over
    the `test` method, React Testing Library's test result output is displayed directly
    in the code editor.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们有一个测试失败，这是由于 React Testing Library 没有找到名为 `lorem ipsum` 的 `heading`
    元素。Wallaby.js 以两种方式提高了我们发现错误的能力。首先，我们在测试名称左侧和具体错误发生的行号处看到一个红色的方块形状。内联代码通知帮助我们快速确定我们应该关注的位置以定位错误的根源。其次，当我们悬停在
    `test` 方法上时，React Testing Library 的测试结果输出会直接在代码编辑器中显示。
- en: 'This feature speeds up our workflow because Wallaby.js reruns our test and
    provides feedback any time we add new code to the test. Furthermore, we don''t
    even have to save our test file to gain feedback. We can also view test feedback
    in the **Wallaby.js Tests** console:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能加快了我们的工作流程，因为 Wallaby.js 在我们向测试添加新代码时重新运行我们的测试并提供反馈。此外，我们甚至不必保存测试文件就能获得反馈。我们还可以在
    **Wallaby.js 测试** 控制台中查看测试反馈：
- en: '![Figure 6.32 – The Wallaby.js Tests console](img/Figure_6.32_B16887.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.32 – Wallaby.js 测试控制台](img/Figure_6.32_B16887.jpg)'
- en: Figure 6.32 – The Wallaby.js Tests console
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.32 – Wallaby.js 测试控制台
- en: In the preceding screenshot, we can see similar React Testing Library feedback
    to what we see directly in the editor anytime code is updated in the test file,
    but now it is in an expanded view. Additionally, we can see the number of failing
    tests compared to passing tests, and clickable links for `Launch Coverage & Test
    Explorer`, which is a feature that allows you to see visualized test coverage
    for each file, and `Search Test`, which is a feature that allows you to quickly
    search for any test in the project.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到与在测试文件中更新代码时直接在编辑器中看到的类似的 React Testing Library 反馈，但现在它是一个扩展视图。此外，我们还可以看到失败测试与通过测试的数量对比，以及可点击的链接“启动覆盖率
    & 测试资源管理器”，这是一个允许您查看每个文件的视觉测试覆盖率的特性，以及“搜索测试”，这是一个允许您快速在项目中搜索任何测试的特性。
- en: 'After debugging the failure with the help of Wallaby.js'' in-editor features,
    we learned that the `heading` element with the name of `lorem ipsum` is not immediately
    displayed. Using our knowledge of Testing Library queries, we can determine that
    the element should be selected using an asynchronous `findBy*` query:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Wallaby.js 的编辑器功能帮助下调试失败后，我们了解到名为 `lorem ipsum` 的 `heading` 元素并未立即显示。利用我们对
    Testing Library 查询的了解，我们可以确定该元素应该使用异步的 `findBy*` 查询来选择：
- en: '[PRE34]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the preceding code, we update the selector to `findByRole`. Immediately
    after updating the selector, we get feedback within the editor:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将选择器更新为 `findByRole`。在更新选择器后，我们立即在编辑器中获得了反馈：
- en: '![Figure 6.33 – Query refactor'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.33 – 查询重构]'
- en: '](img/Figure_6.33_B16887.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.33_B16887.jpg)'
- en: Figure 6.33 – Query refactor
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.33 – 查询重构
- en: In the preceding screenshot, we see green-colored square shapes to the left
    of all of the line numbers. This indicates that we have successfully refactored
    the test code to a working state. We have also written an assertion to verify
    that the test passes as expected. Now you know how to use Wallaby.js to gain instant
    editor feedback and test debugging capabilities. Using Wallaby.js is a great tool
    to have when you need to save time running and debugging tests.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们看到所有行号左侧都有绿色的正方形形状。这表明我们已经成功重构了测试代码到工作状态。我们还编写了一个断言来验证测试是否按预期通过。现在您知道了如何使用
    Wallaby.js 获取即时编辑反馈和测试调试功能。当您需要节省运行和调试测试的时间时，Wallaby.js 是一个非常有用的工具。
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has taught you the benefits of using ESLint plugins to follow the
    DOM Testing Library and `jest-dom` best practices. You have gained an understanding
    of accessible code and used `jest-axe` to increase the accessibility of your applications.
    You have learned how to speed up the process of determining the best query method
    with Testing Playground. Finally, you have learned how to increase test writing
    productivity with Wallaby.js.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了使用 ESLint 插件遵循 DOM 测试库和 `jest-dom` 最佳实践的益处。您已经了解了可访问代码的概念，并使用 `jest-axe`
    提高了您应用程序的可访问性。您还学习了如何通过测试游乐场加速确定最佳查询方法的过程。最后，您学习了如何通过 Wallaby.js 提高测试编写效率。
- en: In the next chapter, you will learn about end-to-end UI testing using the popular
    Cypress framework.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何使用流行的 Cypress 框架进行端到端 UI 测试。
- en: Questions
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Install and configure the React-specific version of `eslint-plugin-testing-library`
    into a project and add additional rules.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 React 特定的 `eslint-plugin-testing-library` 版本安装到项目中，并添加额外的规则。
- en: Create examples of `jest` assertions using matchers that don't use `jest-dom`
    best practices. Then, install and configure `eslint-plugin-jest-dom` inside a
    project and use it as a guide to correct highlighted issues.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建使用不遵循 `jest-dom` 最佳实践的匹配器的 `jest` 断言示例。然后，在项目中安装并配置 `eslint-plugin-jest-dom`，并使用它作为指导来纠正突出显示的问题。
- en: Create a few components with accessibility issues, install and run `jest-axe`
    against the components and use the feedback to fix them.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一些存在可访问性问题的组件，安装并运行 `jest-axe` 对这些组件进行测试，并使用反馈来修复它们。
- en: Visit three of your favorite websites and use Testing Playground to see how
    many elements you can select using DOM Testing Library's preferred `byRole*` queries.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问您最喜欢的三个网站，并使用测试游乐场查看您可以使用 DOM 测试库首选的 `byRole*` 查询选择多少个元素。
- en: Install Wallaby.js and log how quickly you can write a test using its in-editor
    features.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Wallaby.js 并记录使用其编辑器功能编写测试的速度有多快。
