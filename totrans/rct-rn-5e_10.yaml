- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User Interface Framework Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are developing a React application, it’s typical to rely on an existing
    **UI library** rather than building one from scratch. There are lots of React
    UI component libraries available to choose from, and there’s no wrong choice,
    as long as the components make your life simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we delve into the **Material UI** React library, a popular
    choice for React development. Material UI stands out due to its comprehensive
    suite of customizable components, adherence to Google’s Material Design principles,
    and extensive documentation, making it an optimal choice for developers seeking
    efficiency and aesthetic coherence in their UI design. Here are the specific topics
    that we’ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Layout and UI organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **navigation components**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting user input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with **styles** and **themes**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter09](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: You can also find more information about Material UI components and its API
    at [https://mui.com/material-ui/](https://mui.com/material-ui/).
  prefs: []
  type: TYPE_NORMAL
- en: Layout and organization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Material UI** excels in simplifying the complex process of designing application
    layouts. By offering a robust set of components, specifically **containers** and
    **grids**, it empowers developers to efficiently structure and organize UI elements.
    **Containers** serve as the foundation, providing a flexible way to encapsulate
    and align content within the overall layout. **Grids**, on the other hand, allow
    more granular control, enabling precise placement and alignment of components
    across different screen sizes, ensuring responsiveness and consistency.'
  prefs: []
  type: TYPE_NORMAL
- en: This section aims to unpack the functionality of containers and grids within
    Material UI. We’ll explore how these tools can be leveraged to create intuitive
    and aesthetically pleasing layouts, which are crucial for enhancing user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Using containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Aligning components horizontally on a page often presents a significant challenge
    due to the intricate balance required between spacing, alignment, and responsiveness.
    This complexity arises from the need to maintain a visually appealing and functional
    layout across various screen sizes, ensuring that elements are evenly distributed
    and maintain their intended appearance without unintended overlaps or gaps. The
    `Container` component from Material UI is a simple but powerful layout tool. It
    controls the horizontal width of its children. Let’s look at an example to see
    what’s possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This example has three `Container` components, each of which wraps a `Typography`
    component. The `Typography` component is used to render text in Material UI applications.
    Each `Container` component used in this example takes a `maxWidth` property. It
    accepts a breakpoint string value. These breakpoints represent common screen sizes.
    This example uses small (`sm`), medium (`md`), and large (`lg`). When the screen
    reaches these breakpoint sizes, the container width will stop growing. Here’s
    what the page looks like when the width is smaller than the `sm` breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_09_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: The sm breakpoint'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we were to resize the screen so that it was larger than the `md` breakpoint,
    but smaller than the `lg` breakpoint, here is what it would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_09_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: The lg breakpoint'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the first container stays at a fixed width now that we’ve exceeded
    its `maxWidth` breakpoint. The `md` and `lg` containers just keep growing along
    with the screen until their breakpoints have been passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what these `Container` components look like when the screen width
    surpasses all breakpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_09_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: All breakpoints'
  prefs: []
  type: TYPE_NORMAL
- en: The `Container` component gives you control over how your page elements grow
    horizontally. They’re also responsive, so your layouts will be updated as the
    screen dimensions change.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll look at using Material UI components to build more
    complex and responsive layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Building responsive grid layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Material UI has a `Grid` component that we can use to compose responsive complex
    layouts. At a high level, a `Grid` component can be either a container or an item
    within a container. By combining these two roles, we can achieve any type of layout
    for our app. To get familiar with Material UI grid layouts, let’s put together
    an example that uses a common layout pattern that we’ll find in many web applications.
    Here is what the result looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_09_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: A sample responsive grid layout'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, this layout has familiar sections that are typical in many
    web applications. This is just an example layout; you can use the `Grid` component
    to build any type of layout you can imagine. Let’s look at the code that created
    this layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down how the sections in this layout are created. We’ll start with
    the header section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `xs` breakpoint property value of `12` means that the header will always
    span the entire width of the screen since `12` is the highest value you can use
    here. Next, let’s look at the navigation items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the navigation section, we have a grid with the `xs="auto"` prop. It matches
    the column’s size with the width of its content. Also, you can see that we use
    a `Stack` component to place components in a vertical direction with spacing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll look at the main content section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `xs` breakpoint is a true value used to fill all free space after the navigation
    section in the grid.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you were introduced to what Material UI has to offer in the
    way of layouts. You can use the `Container` component to control the width of
    sections and how they change in response to screen dimension changes. You then
    learned that the `Grid` component is used to put together more complex grid layouts.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we’ll look at some of the navigational components
    found in Material UI.
  prefs: []
  type: TYPE_NORMAL
- en: Using navigation components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have an idea of how the layout of our application is going to look and
    work, we can start to think about the navigation. This is an important piece of
    our UI because it’s how the user gets around the application, and it will be used
    frequently. In this section, we’ll learn about two of the navigational components
    offered by Material UI.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating with drawers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Drawer` component, just like a physical drawer, slides open to reveal
    content that is easily accessed. When we’re finished, the drawer closes again.
    This works well for navigation because it stays out of the way, allowing more
    space on the screen for the active task that the user is engaged with. Let’s look
    at an example, starting with the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at what’s happening here. Everything that this component renders
    is within the `BrowserRouter` component because the items in the drawer are links
    to routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `First`, `Second`, and `Third` components are used to render the main application
    content when the user clicks on a link in the drawer. The drawer itself is opened
    when the `Open Nav` button is clicked. Let’s take a closer look at the state that’s
    used to control this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `open` state controls the visibility of the drawer. The `onClose` property
    of the `Drawer` component calls this function, too, meaning that the drawer closes
    when any of the links within it are activated. Next, let’s look at how the links
    within the drawer are generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The items that are displayed in a `Drawer` component are actually list items,
    as you can see here. The `links` property has all the link objects with the `url`
    and `name` properties. Each item in the items array is mapped to the `NavLink`,
    which is used to handle navigation and highlight the active route. Within `NavLink`,
    we have the `ListItemButton` component, which generates the list item with text
    by rendering a `ListItemText` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s look at the default value for the `links` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what the drawer looks like when it’s opened after the screen first loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_09_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: A drawer showing links to our pages'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try clicking on the `First Page` link. The drawer closes and renders the content
    of the `/first` route. Then, when you open the drawer again, you’ll notice that
    the `First Page` link is rendered as the active link:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_09_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: The First Page link is styled as the active link in the drawer'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to use the `Drawer` component as the main navigation
    for your application. In the following section, we’ll look at the `Tabs` component.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating with tabs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tabs are another common navigation pattern found in modern web apps. The Material
    UI `Tabs` component lets us use tabs as links and hook them up to a router. Let’s
    look at an example of how to do this. Here is the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the interest of space, I’ve left out the route configuration for `/page2`
    and `/page3`; it follows the same pattern as `/page1`. The `Tabs` and `Tab` components
    from Material UI don’t actually render any content underneath the selected tab.
    It’s up to us to provide the content as the `Tabs` component only looks after
    showing the tabs and marking one of them as selected. This example aims to have
    the `Tab` components use `Link` components that link to content rendered by routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now take a closer look at the `RouteLayout` component. Each `Tab` component
    uses the `Link` component so that, when it is clicked, the router is activated
    with the route specified in the `to` property. The `Outlet` component is then
    used as a child of our route content. To match the active tab, we use a simple
    approach to handle the current route using `useRouteMatch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `useRouteMatch` hook uses `useLocation` to get the current `pathname` and
    then check whether it matches our patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the page looks like when it first loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_09_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: Tabs with the first item active'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on the **ITEM TWO** tab, the URL will update, the active tab will
    change, and the page content below the tabs will change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_09_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.8: Tabs with the second item active'
  prefs: []
  type: TYPE_NORMAL
- en: By now, you have learned about two of the navigation approaches that you can
    use in your Material UI application. The first is to use a `Drawer` that is only
    displayed when the user needs to access navigational links. The second is to use
    `Tabs` that are always visible. In the following section, you’ll learn about collecting
    input from users.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collecting input from users can be difficult. There are many nuanced things
    about every field that we need to consider if we plan on getting the user experience
    right. Thankfully, the `Form` components available in Material UI take care of
    a lot of usability concerns for us. In this section, you’ll get a brief sampling
    of the input controls that you can use.
  prefs: []
  type: TYPE_NORMAL
- en: Checkboxes and radio buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Checkboxes are useful for collecting `true/false` answers from users, while
    radio buttons are useful for getting the user to select an option from a short
    number of choices. Let’s take a look at an example of these components in Material
    UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This example has two pieces of state information. The `checkbox` state controls
    the value of the `Checkbox` component, while the `radio` value controls the state
    of the `RadioGroup` component. The `checkbox` state is passed to the `checked`
    property of the `Checkbox` component, while the radio state is passed to the `value`
    property of the `RadioGroup` component. Both components have `onChange` handlers
    that call their respective state setter functions: `setCheckbox()` and `setRadio()`.
    You’ll notice that many other Material UI components are involved in the display
    of these controls. For example, the label for the `checkbox` is displayed using
    the `FormControlLabel` component, while the radio control uses a `FormControl`
    component and a `FormLabel` component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the two input controls look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_09_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.9: A checkbox and a radio group'
  prefs: []
  type: TYPE_NORMAL
- en: The labels for both of these controls are updated to reflect the state of the
    components as they change. The checkbox labels show whether the checkbox is checked,
    and the radio labels show the currently selected value. In the next section, we’ll
    look at text inputs and select components.
  prefs: []
  type: TYPE_NORMAL
- en: Text inputs and select inputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Text fields** allow our users to enter text, while `Select` allows them to
    choose from several options. The difference between selects and radio buttons
    is that selects require less space on the screen since the options are only displayed
    when the user opens the options menu.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a `Select` component now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The value state used in this example controls the selected value in the `Select`
    component. When the user changes their selection, the `setValue()` function changes
    the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MenuItem` component is used to specify the available options in the `select`
    field; the `value` property is set as the value state when a given item is selected.
    Here’s what the `select` field looks like when the menu is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_09_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.10: A menu with the first item active'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s look at a `TextField` component example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The value state controls the value of the text input and changes as the user
    types. Here’s what the `text` field looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_09_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.11: A text field with user-provided text'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other `FormControl` components, the `TextField` component doesn’t require
    several other supporting components. Everything that we need can be specified
    via properties. In the next section, we’ll look at the `Button` component.
  prefs: []
  type: TYPE_NORMAL
- en: Working with buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Material UI buttons are very similar to HTML button elements. The difference
    is that they’re React components that work well with other aspects of Material
    UI, such as theming and layout. Let’s look at an example that renders different
    styles of buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This example renders four different button styles. We’re using the `Stack` component
    to render the row of buttons. When the buttons are clicked on, the state toggles
    to primary and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the buttons look like when they’re first rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_09_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.12: Four styles of Material UI buttons'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the buttons look like when they’ve each been clicked on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_09_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.13: What the buttons look like after they’ve been clicked on'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about some of the user input controls available
    in Material UI. `Checkboxes` and `radio` buttons are useful when the user needs
    to turn something on or off or choose an option. Text inputs are necessary when
    the user needs to type in some text, while `select` fields are useful when you
    have a list of options to choose from but limited space to display those options.
    Finally, you learned that Material UI has several styles of buttons that can be
    used when the user needs to initiate an action. In the following section, we’ll
    look at how styles and themes work in Material UI.
  prefs: []
  type: TYPE_NORMAL
- en: Working with styles and themes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Included with Material UI are systems for extending the styles of UI components
    and extending **theme styles** that are applied to all components. In this section,
    you’ll learn about using both of these systems.
  prefs: []
  type: TYPE_NORMAL
- en: Making styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Material UI comes with a `styled()` function that can be used to create styled
    components based on JavaScript objects. The return value of this function is a
    new component with the new styles applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The names used in this style (`MuiButton-root`, `MuiButton-contained`, and `MuiButton-sizeSmall`)
    aren’t something that we came up with. These are part of the **Button CSS API**.
    The root style is applied to all buttons, so, in this example, all three buttons
    will have the margin value that we’ve applied here. The `contained` style is applied
    to buttons that use the contained variant. The `sizeSmall` style is applied to
    buttons that have a small value for the size property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the custom button styles look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_09_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.14: Buttons using customized styles'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to change the look and feel of individual components,
    it’s time to think about customizing the look and feel of the application as a
    whole.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing themes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Material UI comes with a default theme. We can use this as the starting point
    to create our own theme. There are two main steps to creating a new theme in Material
    UI:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `createTheme()` function to customize the default theme settings and
    return a new theme object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `ThemeProvider` component to wrap our application so that the appropriate
    theme is applied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s look at how this process works in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The custom theme that we’ve created here does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: It changes the default font size for all components to `11`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It updates the left and right margin values for the `MenuItem` components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many values can be set in a Material UI theme; refer to the customization documentation
    for more. The `components` section is used for component-specific customizations.
    This is useful when you need to style every instance of a component in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was a very brief introduction to Material UI, the most popular
    React UI framework. We started by looking at the components used to assist with
    the layout of our pages. We then looked at components that can help the user navigate
    around your application. Next, you learned how to collect user input using Material
    UI form components. Finally, you learned how to style your Material UI using styles
    and modifying themes.
  prefs: []
  type: TYPE_NORMAL
- en: The insights gained from this chapter allow you to build complex interfaces
    without the overhead of developing UI components from scratch, accelerating your
    development process. Furthermore, React application development inherently relies
    on the synergistic use of various auxiliary libraries. A deep understanding of
    the React ecosystem and its key libraries empowers developers to rapidly prototype
    and iterate on their applications, making development effective.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look at ways to improve the efficiency of your component
    state updates using the latest functionality available in the latest version of
    React.
  prefs: []
  type: TYPE_NORMAL
