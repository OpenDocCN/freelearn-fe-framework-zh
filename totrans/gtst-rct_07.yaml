- en: Chapter 7. Making Your Component Reusable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have dug into React's components' lifecycle, properties, state,
    and ECMAScript with respect to React 0.1.13 and future versions. In this chapter,
    we will also see how we can write reusable components/code in React applications.
    Such reusable components in React are named Mixins. Furthermore, we will explore
    how the React component's properties can be validated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics to be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding mixins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A higher order component in ECMA6 (as Mixin is not supported in ECMA6)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different types of validations in a React application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The structure of a React component and application's architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Mixins (reusable components) are typically those React components that are
    used in multiple places and thus can be reused. Typically, the design elements,
    such as buttons, layout components, form fields, or any code logic/computation,
    that are used more than once are extracted in code named Mixin. Thus, Mixins help
    us incorporate some additional functionalities to existing React components by
    acting as helpers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like in the previous chapters , the index.html content remains the same. Only
    the contents of the corresponding js (having the React components) changes.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Mixins by example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example we are setting the interval of the window global objects for
    every 100 ms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Content of index.html:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Content of index.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Run the httpserver from the application''s root dir:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output for this code on opening `localhost:3333`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring Mixins by example](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The app screenshot using Mixin with a lifecycle method
  prefs: []
  type: TYPE_NORMAL
- en: 'The explanation of the executed code:'
  prefs: []
  type: TYPE_NORMAL
- en: A mixin is nothing but a JavaScript object, which can be reused within the React
    component later. We begin with defining the Mixin.
  prefs: []
  type: TYPE_NORMAL
- en: The `componentWillMount` is a lifecycle method, which is added as a part of
    the Mixin. Later, when the Mixin is called from the react component, the log from
    `console.log` can be seen in the bottom part of the developer tool portion of
    the webpage to present **Component Will Mount**.
  prefs: []
  type: TYPE_NORMAL
- en: We add a typical react component (`<App />`), which calls the `<Label />` component.
    It's a render function, which displays the text presented on the label. The App
    component can have multiple react components, which will internally call different
    react components.
  prefs: []
  type: TYPE_NORMAL
- en: In the next example, we will see such an example.
  prefs: []
  type: TYPE_NORMAL
- en: React component `(<Label />`) is called from the `<App />` component. It's using
    the React Mixin (ReactMixin).
  prefs: []
  type: TYPE_NORMAL
- en: In line mixins:[ReactMixin], Mixins in React, are called using the keyword Mixin,
    followed by the Mixin name (ReactMixin in this case), within an array. We can
    define multiple Mixins, as JavaScript objects. All these separate Mixins can then
    be called from a single React component (each Mixin representing a separate element
    in an array).
  prefs: []
  type: TYPE_NORMAL
- en: We will explore such an example, with multiple Mixins, later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We then add the `setInterval()` function
  prefs: []
  type: TYPE_NORMAL
- en: '`The setInterval`() method is a window function in JavaScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's declared as `window.setInterval(function, milliseconds)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although it's a method based on window object, but it's not necessary to call
    the `setInterval()` method on the window object, such as in the previously mentioned
    code. It can be called without the window prefix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first parameter is the function that gets executed (`this.increaseCountBy10`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter is the interval of time between executions of each of the
    function, `this.increaseCountBy10`. The interval is set to `100ms` in this case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lifecycle method (`componentWillMount`) is then called for the second time
    in the previously mentioned code. For the first time, it is called within the
    Mixin body, which logs the `Component Will Mount` on the log.
  prefs: []
  type: TYPE_NORMAL
- en: For the second time, it is called within the React component (`<Label />`).
    Due to the second call, the `setInterval()` method is incrementing the value from
    `0` (count set to `0` initially) to `10`, in each `100` ms.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Take a look at the Facebook documentation [https://facebook.github.io/react/docs/reusable-components.html](https://facebook.github.io/react/docs/reusable-components.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '"A nice feature of Mixins is that if a component is using multiple Mixins and
    several Mixins define the same lifecycle method (i.e. several Mixins want to do
    some clean up when the component is destroyed), all of the lifecycle methods are
    guaranteed to be called. Methods defined on Mixins run in the order Mixins were
    listed, followed by a method call on the component."'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see another example of Mixins in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We shall now see another example where multiple Mixin will be called from a
    single React component. The following code is declared:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we shall declare two react Mixins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Second part of the code, we will call both the React Mixins, from the
    react component `<App />`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the command httpster from application root directly like before to
    see the output from two Mixins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring Mixins by example](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The app screenshot using multiple Mixins
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The same property name in both the Mixins, for example, **text**, in this case,
    will throw an error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same method name within the different Mixins will throw an error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same lifecycle methods can be called both within Mixin and within a React
    component. The order of execution of these lifecycle methods is Mixin, followed
    by a React component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case the same lifecycle method is called within different Mixins, then the
    order of execution is in the order in which the Mixins are called within the array
    [lower to higher index].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order components in Mixins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In ReactJS using ES6, Mixins are no longer supported. Instead of this, they
    have introduced higher order components.
  prefs: []
  type: TYPE_NORMAL
- en: These higher order components are widely used in the Relay framework, which
    is a complete React-based framework released by Facebook. The higher order component
    wraps up child UI components. Thus, these components when called will first execute
    its queries and thereby render the child UI component(s). When the query is passed,
    data is passed from the child component to the higher order component in as props.
  prefs: []
  type: TYPE_NORMAL
- en: Validations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Validations** are an integral part of any application dealing with user input.
    In ReactJS, there are some validations provided by the library that enables the
    developer to validate the data received.'
  prefs: []
  type: TYPE_NORMAL
- en: Data are received mostly as properties (props) in react application. The various
    validators are exported from `React.PropTypes`. Any validation error, if occurs,
    will appear in the JavaScript console. Any such error occurring due to validation
    check will only occur in the development mode due to performance reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the Facebook ReactJS development team documentation [https://facebook.github.io/react/docs/reusable-components.html#prop-validation](https://facebook.github.io/react/docs/reusable-components.html#prop-validation).
    The following is an example of the various validators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: An example using the isRequired validator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `index.html` page. Use different JS pages in order to check the different
    versions of the validations used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As the name of the validation suggests, the `isRequired` validator ensures
    that the property of the React component remains present. Otherwise, it will throw
    an error in the JS console. The `React.PropTypes.{foo}` properties are the JavaScript
    functions, which internally check whether a prop is valid or not. When the prop
    is valid, it will return `null`, but when the prop is invalid, then it returns
    an error. In [Chapter 4](part0029_split_000.html#page "Chapter 4. Stateful Components
    and Events"), *Stateful Components and Events* we dug into ES6\. In the next example,
    we will be using the ES6 syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Run the httpster from your app's root dir in order to see the output in your
    browser's `localhost:3333`
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example using the isRequired validator](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The app screenshot—the isRequired validation in the React component prop
  prefs: []
  type: TYPE_NORMAL
- en: 'A few points from the ES6 point of view with respect to the previously mentioned
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`use strict` has been used opt in to a restricted variant of JavaScript. This
    is used as we are using let instead of var. `use strict` allows to place a component
    in a `strict` operating context and prevents certain actions from being taken
    and throws more exceptions.'
  prefs: []
  type: TYPE_NORMAL
- en: let declares variables that are limited in scope to the block, statement, or
    expression on which it is used.
  prefs: []
  type: TYPE_NORMAL
- en: See the details at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/).
  prefs: []
  type: TYPE_NORMAL
- en: An example using custom validator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is the template, generally used while using custom validation
    in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through an example of our own with custom error messages and use
    a few of these validations and see how it validates in the JavaScript console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Run the httpster from your app's root dir in order to see the output in your
    browser's `localhost:3333`
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this code is shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example using custom validator](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The app screenshot—custom validation in the React component prop
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add more validations in the property (name) as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Run the httpster from your app's root dir in order to see the output in your
    browser's `localhost:3333`
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the following code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example using custom validator](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The app screenshot—validation in React component prop
  prefs: []
  type: TYPE_NORMAL
- en: Thus, if we pass the name property with more than seven chars, there would be
    no error in the JS console, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have explored quite a lot regarding ReactJS, there might be queries
    in your mind about how to architecture a react component or more broadly a react
    application as a whole. There are no ground rules that have been set, which is
    ideal while writing an application based on ReactJS. However, if we dig into the
    tutorials by the Facebook documentation team, hyperlink [https://facebook.github.io/react/docs/tutorial.html](https://facebook.github.io/react/docs/tutorial.html),
    we will be able to understand the underlying way they have used while writing
    such an app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore first how a component is structured mostly:'
  prefs: []
  type: TYPE_NORMAL
- en: The component `declaredData` is fetched from the server [if required].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `propTypes` of the component are declared [used for validations].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Component lifecycle methods [`componentWillMount`, `componentDidMount`, `componentDidUpdate`,`componentWillUnmount`,
    and so on] are defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within each of these lifecycle methods, the functions of these methods are either
    declared or called internally from another JS functions, defined explicitly for
    a particular task. It's to be remembered that the previously mentioned lifecycle
    methods are not necessary to use all at the same time/any in an application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The render method, which has to be present within any react component. Thus,
    the way to structure any react-based application varies application-wise. Although
    there is no best way, but like any other application, it's advisable to compartmentalize
    the code in order to follow separation of concerns. We should separate the react
    views, components and data. One component directory can call other child component(s)
    as and when required, which thereby increases readability and testability of the
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: React being an open source JavaScript library, there are various open source
    sites and developers who are working on this library each day in order to enhance
    and tweak the library, as required.
  prefs: []
  type: TYPE_NORMAL
- en: For an application, using the ReactJS library, typically the views (React views)
    are separated as per their function (for example, home page, admin page, and product
    catalog). With each of the subfolder within the view, you can add the test.js
    file or you can keep all the test-related files under the same tests folder. In
    case you need some react views, which should be shared across other components,
    you can keep all those related files under the shared/lib folder.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored how we can develop reusable components in ReactJS
    (Mixins, before ES6 implementation). We also came to know about the higher order
    components, which are used later in the latter versions of ReactJS (from 0.13),
    which support ES6 and doesn't support Mixins. Validations are an integral part
    of any application, especially those using user input (that is, form inputs).
    We explored how ReactJS deals with validations and how we can use our custom validations
    as well. We got an overview how the react components are structured. In the following
    chapter, we will be dealing with the testing, in a React application.
  prefs: []
  type: TYPE_NORMAL
