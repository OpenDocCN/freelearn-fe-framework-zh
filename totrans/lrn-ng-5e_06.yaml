- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive Patterns in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling asynchronous information is a common task in our everyday lives as
    developers. **Reactive programming** is a paradigm that helps us consume, digest,
    and transform asynchronous information using data streams. **RxJS** is a JavaScript
    library that provides methods to manipulate data streams using **observables**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Angular provides an unparalleled toolset to help us when working with asynchronous
    data. Observable streams are at the forefront of this toolset, giving developers
    a rich set of capabilities when creating Angular applications. The core of the
    Angular framework is lightly dependent on RxJS. Other Angular packages, such as
    the router and the HTTP client, are more tightly coupled with observables. However,
    at the time of writing, the Angular team is currently investigating making the
    preceding packages less dependent on observables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Strategies for handling asynchronous information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive programming in Angular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The RxJS library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscribing to observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsubscribing from observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The chapter contains various code samples to walk you through observables and
    RxJS. You can find the related source code in the `ch06` folder of the following
    GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition)'
  prefs: []
  type: TYPE_NORMAL
- en: Strategies for handling asynchronous information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We manage data asynchronously in different forms, such as consuming data from
    a backend API, a typical operation in our daily development workflow, or reading
    contents from the local file system. We always consume data over HTTP, such as
    when authenticating users by sending credentials to an authentication service.
    We also use HTTP when fetching the latest posts in our favorite social network
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Modern mobile devices have introduced a unique way of consuming remote services.
    They defer requests and response consumption until mobile connectivity is available.
    Responsivity and availability have become a big deal.
  prefs: []
  type: TYPE_NORMAL
- en: Although internet connections are high-speed nowadays, response time is always
    involved when serving such information. Thus, as we will see in this section,
    we put in place mechanisms to handle the state of our applications transparently
    for the end user.
  prefs: []
  type: TYPE_NORMAL
- en: Shifting from callback hell to promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes we might need to build functionalities in our application that change
    its state asynchronously once time has elapsed. In these cases we must introduce
    code patterns, such as the **callback pattern** , to handle this deferred change
    in the application state.
  prefs: []
  type: TYPE_NORMAL
- en: In a callback, the function that triggers asynchronous action accepts another
    function as a parameter. The function is executed when the asynchronous operation
    has been completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need the source code of the Angular application we created in *Chapter
    5* , *Managing Complex Tasks with Services* , to follow along with the rest of
    the chapter. After you get the code, we suggest you take the following actions
    for simplicity:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the `favorites` folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the `favorites.service.ts` and its unit test file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the `favorite.ts` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the `numeric.directive.ts` file and its unit test file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the `product-view` folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see how to use a callback through an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app.component.html` file and add a `<header>` HTML element to display
    the `title` component property using interpolation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `app.component.ts` file and create the following property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `setTitle` property is used to change the `title` component property based
    on the `title` property from application settings. It returns an arrow function
    because we will use it as a callback to another method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a `changeTitle` method that calls another method, named, by convention,
    `callback` , after two seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `constructor` to call the `changeTitle` method, passing the `setTitle`
    property as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we use the `setTitle` property without parentheses
    because we pass function signatures and not actual function calls when we use
    callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: If we run the Angular application using the `ng serve` command, we see that
    the `title` property changes after two seconds. The problem with the pattern we
    just described is that the code can become confusing and cumbersome as we introduce
    more nested callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following scenario where we need to drill down into a folder hierarchy
    to access photos on a device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We depend on the previous asynchronous call and the data it brings back before
    we can do the next call. We must execute a method inside a callback that executes
    another method with a callback. The code quickly looks complex and difficult to
    read, leading to a situation known as **callback hell** .
  prefs: []
  type: TYPE_NORMAL
- en: We can avoid callback hell using **promises** . Promises introduce a new way
    of envisioning asynchronous data management by conforming to a neater and more
    solid interface. Different asynchronous operations can be chained at the same
    level and even be split and returned from other functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand how promises work, let’s refactor our previous callback
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new method in the `AppComponent` class named `onComplete` that returns
    a `Promise` object. A promise can either be **resolved** or **rejected** . The
    `resolve` parameter indicates that the promise was completed successfully and
    optionally returns a result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Introduce a timeout of two seconds in the promise so that it resolves after
    this time has elapsed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, replace the `changeTitle` call in the `constructor` with the promise-based
    method. To execute a method that returns a promise, we invoke the method and chain
    it with the `then` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should not notice any significant difference if we rerun the Angular application.
    The real value of promises lies in the simplicity and readability afforded to
    our code. We could now refactor the previous folder hierarchy example accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The chaining of the `then` method in the preceding code shows how we can line
    up one asynchronous call after another. Each previous asynchronous call passes
    its result in the upcoming asynchronous method.
  prefs: []
  type: TYPE_NORMAL
- en: Promises are compelling, but sometimes we might need to produce a response output
    that follows a more complex digest process or even cancel the whole process. We
    cannot accomplish such behavior with promises because they are triggered as soon
    as they are instantiated. In other words, promises are not lazy. On the other
    hand, the possibility of tearing down an asynchronous operation after it has been
    fired but not completed yet can become quite handy in specific scenarios. Promises
    allow us to resolve or reject an asynchronous operation, but sometimes we might
    want to abort everything before getting to that point.
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of that, promises behave as one-time operations. Once they are resolved,
    we cannot expect to receive any further information or state change notifications
    unless we run everything from scratch. To summarize the limitations of promises:'
  prefs: []
  type: TYPE_NORMAL
- en: They cannot be canceled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are immediately executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are one-time operations; there is no easy way to retry them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They respond with only one value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s illustrate some of the limitations with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace `setTimeout` with `setInterval` in the `onComplete` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The promise will now resolve repeatedly every two seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `setTitle` property to append the current `timestamp` in the `title`
    property of the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the Angular application and you will notice that the timestamp is set only
    once after two seconds and never changes again. The promise resolves itself, and
    the entire asynchronous event terminates at that very moment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We may need a more proactive implementation of asynchronous data handling to
    fix the preceding behavior, which is where observables come into the picture.
  prefs: []
  type: TYPE_NORMAL
- en: Observables in a nutshell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An observable is an object that maintains a list of dependents, called **observers**
    , and informs them about state and data changes by emitting events asynchronously.
    To do so, the observable implements all the necessary machinery to produce and
    emit such events. It can be triggered and canceled at any time, regardless of
    whether it has emitted the expected data already.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observers must subscribe to an observable to be notified and react to reflect
    the state change. This pattern, known as the **observer pattern** , allows concurrent
    operations and more advanced logic. These observers, also known as **subscribers**
    , keep listening to whatever happens in the observable until it is destroyed.
    We can see all this with more transparency in an actual example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `Observable` artifact from the `rxjs` npm package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a component property named `title$` that creates an `Observable` object.
    The constructor of an observable accepts an `observer` object as a parameter.
    The `observer` is an arrow function that contains the business logic that will
    be executed when someone uses the observable. Call the `next` method of the `observer`
    every two seconds to indicate a data or application state change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we define an observable variable, we tend to append the `$` sign to the
    variable name. It is a convention that we follow to identify observables in our
    code efficiently and quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `constructor` component to use the newly created `title$` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the `subscribe` method to register to the `title$` observable and get
    notified of any changes. If we do not call this method, the `setTitle` method
    will never execute.
  prefs: []
  type: TYPE_NORMAL
- en: An observable will not do anything unless a subscriber subscribes to it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the application, you will notice that the timestamp changes every
    two seconds. Congratulations! You have entered the world of observables and reactive
    programming!
  prefs: []
  type: TYPE_NORMAL
- en: Observables return a stream of events, and our subscribers receive prompt notifications
    of those events so that they can act accordingly. They do not perform an asynchronous
    operation and terminate (although we can configure them to do so) but start a
    stream of ongoing events to which we can subscribe.
  prefs: []
  type: TYPE_NORMAL
- en: That’s not all, however. This stream can combine many operations before hitting
    observers subscribed to it. Just as we can manipulate arrays with methods such
    as `map` or `filter` to transform them, we can do the same with the stream of
    events emitted by observables. It is a pattern known as reactive programming,
    and Angular makes the most of this paradigm to handle asynchronous information.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The observer pattern stands at the core of reactive programming. The most basic
    implementation of a reactive script encompasses several concepts that we need
    to become familiar with:'
  prefs: []
  type: TYPE_NORMAL
- en: An observable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An observer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A timeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stream of events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of composable operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may sound daunting, but it isn’t. The big challenge here is to change our
    mindset and learn how to think reactively, which is the primary goal of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming entails applying asynchronous subscriptions and transformations
    to observable streams of events.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explain through a more descriptive example. Think about an interaction
    device such as a keyboard. It has keys that the user presses. Each one of those
    keystrokes triggers a specific keyboard event, such as `keyUp` . The keyUp event
    features a wide range of metadata, including—but not limited to—the numeric code
    of the specific key the user pressed at a given moment. As the user continues
    hitting keys, more keyUp events are triggered and piped through an imaginary timeline.
    The timeline is a continuous stream of data where the keyUp event can happen at
    any time; after all, the user decides when to press those keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall the example with observables from the previous section. That code could
    notify an observer that every two seconds, another value was emitted. We know
    how often a timer interval is triggered. In the case of keyUp events, we don’t
    know because they are not under our control. Let’s try to explain it further by
    implementing a key logger in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Angular component named `key-logger` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `key-logger.component.html` file and replace its content with the
    following HTML template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding template, we added an `<input>` HTML element and attached the
    `keyContainer` template reference variable.
  prefs: []
  type: TYPE_NORMAL
- en: A template reference variable can be added to any HTML element, not just components.
  prefs: []
  type: TYPE_NORMAL
- en: We also display a `keys` property representing all the keyboard keys the user
    has pressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `key-logger.component.ts` file and import the `OnInit` , `viewChild`
    , and `ElementRef` artifacts from the `@angular/core` npm package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following properties in the `KeyLoggerComponent` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `input` property is used to query the `<input>` HTML element using the `keyContainer`
    template reference variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `import` statement to import the `fromEvent` artifact from
    the `rxjs` npm package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The RxJS library has various helpful artifacts, called **operators** , that
    we can use with observables. The `fromEvent` operator creates an observable from
    the DOM event of a native HTML element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `ngOnInit` method from the `OnInit` interface to listen for `keyup`
    events in the `<input>` element and save pressed keys in the `keys` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we get access to the native HTML input element through the `nativeElement`
    property of the template reference variable. The result of querying using the
    `viewChild` function is an `ElementRef` object, which is a wrapper over the actual
    HTML element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app.component.ts` file and import the `KeyLoggerComponent` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `app.component.html` file and add the `<app-key-logger>` selector
    in the template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the application using the `ng serve` command and start pressing keys to
    verify the usage of the key logger that we have just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B21418_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Key logger output'
  prefs: []
  type: TYPE_NORMAL
- en: An essential aspect of observables is using operators and chaining observables
    together, enabling **rich composition** . Observable operators look like array
    methods when we want to use them. For example, a `map` operator for observables
    is used similarly to the `map` method of an array. In the following section, we
    will learn about the RxJS library, which provides these operators, and learn about
    some of them through examples.
  prefs: []
  type: TYPE_NORMAL
- en: The RxJS library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned previously, Angular comes with a peer dependency on RxJS, the
    JavaScript flavor of the **ReactiveX** library, which allows us to create observables
    out of a large variety of scenarios, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Interaction events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callback functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive programming does not aim to replace asynchronous patterns like promises
    or callbacks. All the way around, it can leverage them as well to create observable
    sequences.
  prefs: []
  type: TYPE_NORMAL
- en: RxJS has built-in support for various composable operators to transform, filter,
    and combine the resulting event streams. Its API provides convenient methods for
    observers to subscribe to these streams so that our components can respond accordingly
    to state changes or input interaction. Let’s see some of these operators in action
    in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating observables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already learned how to create an observable from a DOM event using the
    `fromEvent` operator. Two other popular operators concerned with observable creation
    are the `of` and `from` operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `of` operator is used to create an observable from values such as numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The previous snippet prints the numbers **1** , **2** , and **3** in the browser
    console window *in order* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The `from` operator is used to convert an array to an observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `from` operator is also very useful when converting promises or callbacks
    to observables. We could wrap the `onComplete` method in the `constructor` of
    the `AppComponent` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `from` operator is an excellent way to migrate to observables if you use
    promises in an existing application!
  prefs: []
  type: TYPE_NORMAL
- en: Besides creating observables, the RxJS library also contains a couple of handy
    operators to manipulate and transform data emitted from observables.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming observables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already learned how to create a numeric-only directive in *Chapter
    4* , *Enriching Applications Using Pipes and Directives* . We will now use RxJS
    operators to accomplish the same thing in our key logger component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `key-logger.component.ts` file and import the `tap` operator from
    the `rxjs` npm package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Refactor the `ngOnInit` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `pipe` operator links and combines multiple operators separated by commas.
    We can think of it as a recipe that defines the operators that should be applied
    to an observable. One of them is the `tap` operator, which is used when we want
    to do something with the data emitted without modifying it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to exclude non-numeric values that the `logger$` observable emits.
    We already get the actual key pressed from the `evt` property, but it returns
    alphanumeric values. It would not be efficient to list all non-numeric values
    and exclude them manually. Instead, we will use the `map` operator to get the
    actual Unicode value of the key. It behaves similarly to the `map` method of an
    array as it returns an observable with a modified version of the initial data.
    Import the `map` operator from the `rxjs` npm package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following snippet above the `tap` operator in the `ngOnInit` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now add the `filter` operator, which operates similarly to the `filter`
    method of an array for excluding non-numeric values. Import the `filter` operator
    from the `rxjs` npm package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following snippet after the `map` operator in the `ngOnInit` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The observable currently emits Unicode character codes. We must convert them
    back to keyboard characters to display them on the HTML template. Refactor the
    `tap` operator to accommodate this change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As a final touch, we will add an input binding in the component to toggle the
    numeric-only feature on and off conditionally:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `input` function in the `import` statement of the `@angular/core` npm
    package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `numeric` input property in the `KeyLoggerComponent` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Refactor the `filter` operator in the `ngOnInit` method so that it takes into
    account the `numeric` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `logger$` observable will filter non-numeric values only if the `numeric`
    input property is `true` .
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ngOnInit` method should finally look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `app.component.html` file and add a binding to the `numeric` property
    in the `<app-key-logger>` selector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the application using the `ng serve` command and enter `Angular 19` inside
    the input box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, γραμματοσειρά, στιγμιότυπο οθόνης, γραμμή  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_06_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Numeric key logger'
  prefs: []
  type: TYPE_NORMAL
- en: We have seen RxJS operators manipulating observables that return primitive data
    types such as numbers, strings, and arrays. In the following section, we will
    learn how to use observables in our e-shop application.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already learned that an observer needs to subscribe to an observable
    to get emitted data. The observer in our case will be the product list component
    and the observable will reside inside the `products.service.ts` file. Thus, we
    first need to convert the `ProductsService` class to use observables instead of
    plain arrays so that components can subscribe to get data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `products.service.ts` file and add the following `import` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Extract the product data used in the `getProducts` method into a separate service
    property to enhance code readability:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `getProducts` method so that it returns the `products` property
    as an observable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we use the `of` operator to create a new observable
    from the `products` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ProductsService` class now emits product data using observables. We must
    modify the component to subscribe and get this data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-list.component.ts` file and create a `getProducts` method
    in the `ProductListComponent` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding method, we subscribe to the `getProducts` method of the `ProductsService`
    class because it returns an observable instead of a plain array. The `products`
    array is returned inside the `subscribe` method, where we set the `products` component
    property to the array emitted from the observable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `ngOnInit` method so that it calls the newly created `getProducts`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We could have added the body of the `getProducts` method inside the `ngOnInit`
    method directly. We did not as component lifecycle event methods should be as
    clear and concise as possible. Always try to extract their logic in a separate
    method for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application using the `ng serve` command, and you should see the product
    list displayed on the page successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, λογότυπο  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_06_03.png)Figure 6.3: Product list'
  prefs: []
  type: TYPE_NORMAL
- en: As depicted in the previous image, we have achieved the same result of displaying
    the product list as in *Chapter 5* , *Managing Complex Tasks with Services* ,
    but using observables. It may not be evident at once, but we have set the foundation
    for working with the Angular HTTP client which is based on observables. In *Chapter
    8* , *Communicating with Data Services over HTTP* , we will explore the HTTP client
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: When we subscribe to observables, we are prone to potential memory leaks if
    we do not clean them up on time. In the following section, we will learn about
    different ways to accomplish that.
  prefs: []
  type: TYPE_NORMAL
- en: Unsubscribing from observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we subscribe to an observable, we create an observer that listens for changes
    in a data stream. The observer watches the stream continuously while the subscription
    remains active. When a subscription is active, it reserves memory in the browser
    and consumes certain resources. If we do not tell the observer to unsubscribe
    at some point and clean up any resources, the subscription to the observable will
    *possibly* lead to a memory leak.
  prefs: []
  type: TYPE_NORMAL
- en: An observer usually needs to unsubscribe when the Angular component that created
    the subscription must be destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most well-known techniques to use for unsubscribing from observables
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Unsubscribe from an observable manually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `async` pipe in a component template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see both techniques in action in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying a component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A component has lifecycle events we can use to hook on and perform custom logic,
    as we learned in *Chapter 3* , *Structuring User Interfaces with Components* .
    One of them is the `ngOnDestroy` event, which is called when the component is
    destroyed and no longer exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall `ProductListComponent` and `ProductViewComponent` , which we used earlier
    in our examples. They subscribe to the appropriate methods of `ProductsService`
    and `ProductViewService` upon component initialization. When components are destroyed,
    the reference of the subscriptions stays active, which may lead to unpredictable
    behavior. We need to manually unsubscribe when components are destroyed to clean
    up any resources properly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-list.component.ts` file and add the following `import` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following property in the `ProductListComponent` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assign the `productsSub` property to the subscription result in the `getProducts`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the `OnDestroy` lifecycle hook from the `@angular/core` npm package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `OnDestroy` to the implemented interface list of the `ProductListComponent`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `ngOnDestroy` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `unsubscribe` method removes an observer from the active listeners of a
    subscription and cleans up any reserved resources.
  prefs: []
  type: TYPE_NORMAL
- en: That’s a lot of boilerplate code to unsubscribe from a single subscription.
    It may quickly become unreadable and unmaintainable if we have many subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can use a particular type of operator called `takeUntilDestroyed`
    **,** which is available in the `@angular/core/rxjs-interop` package. We will
    explore the way of unsubscribing from observables using this operator in the product
    list component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-list.component.ts` file and import the `inject` , `DestroyRef`
    , and `takeUntilDestroyed` artifacts as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `takeUntilDestroyed` artifact is an operator that unsubscribes from an observable
    when the component is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the following property to inject the `DestroyRef` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `getProducts` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding method, we use the `pipe` operator to chain the `takeUntilDestroyed`
    operator with the subscription from the `getProducts` method of the `ProductsService`
    class. The `takeUntilDestroyed` operator accepts a parameter of the `DestroyRef`
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Remove any code related to the `ngOnDestroy` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That’s it! We have now converted our subscription to be more declarative and
    readable. However, the problem of maintainability still exists. Our components
    are now unsubscribing from their observables manually. We can solve that using
    a special-purpose Angular pipe, the `async` pipe, which allows us to unsubscribe
    automatically with less code.
  prefs: []
  type: TYPE_NORMAL
- en: Using the async pipe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `async` pipe is a built-in Angular pipe used in conjunction with observables,
    and its role is two-fold. It helps us to type less code and saves us from having
    to set up and tear down a subscription. It automatically subscribes to an observable
    and unsubscribes when the component is destroyed. We will use it to simplify the
    code of the product list component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-list.component.ts` file and add the following `import` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `AsyncPipe` class into the `imports` array of the `@Component` decorator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Convert the `products` component property to an observable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assign the `getProducts` method of the `ProductsService` class to the `products$`
    component property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The body of the `getProducts` method has now been reduced to one line and has
    become more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-list.component.html` file and add the following snippet at
    the beginning of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we subscribe to the `products$` observable using the
    `async` pipe and create a template variable using the `@let` keyword. The template
    variable has the same name as the respective component property we had previously,
    so we do not need to change the component template further.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! We do not need to subscribe or unsubscribe from the observable manually
    anymore! The `async` pipe takes care of everything for us.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned that observables react to application events and emit values
    asynchronously in registered observers. We could visualize observables as wrapper
    objects around emitted values. Angular enriches the reactivity field of web applications
    by providing a similar wrapper that works synchronously and reacts to application
    state changes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It takes much more than a single chapter to cover in detail all the great things
    we can do with reactivity in Angular. The good news is that we have covered all
    the tools and classes we need for basic Angular development.
  prefs: []
  type: TYPE_NORMAL
- en: We learned what reactive programming is and how it can be used in Angular. We
    saw how to apply reactive techniques like observables to interact with data streams.
    We explored the RxJS library and how to use some operators to manipulate observables.
    We learned different ways of subscribing and unsubscribing from observables in
    Angular components.
  prefs: []
  type: TYPE_NORMAL
- en: The rest is just left to your imagination, so feel free to go the extra mile
    and put all of this knowledge into practice in your Angular applications. The
    possibilities are endless, and you have strategies ranging from promises and observables.
    You can leverage the incredible functionalities of the reactive patterns and build
    amazing reactive experiences for your Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: As we have already highlighted, the sky’s the limit. However, we still have
    a long and exciting road ahead. In the next chapter, we will explore signals,
    an alternate reactive pattern built into the Angular framework. We will learn
    how to use Angular signals to handle the state of an Angular application.
  prefs: []
  type: TYPE_NORMAL
