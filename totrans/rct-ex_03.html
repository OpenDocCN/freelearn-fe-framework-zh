<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Data Flow and Life Cycle Events"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Data Flow and Life Cycle Events</h1></div></div></div><p>In the previous chapter, we saw the power of JSX. JSX makes it easy to write the React components.</p><p>In this chapter, we will focus on the data flow between components and how to manage state and life cycle of components.</p><p>In this chapter, we will cover the following points:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Data flow in React</li><li class="listitem" style="list-style-type: disc">Props</li><li class="listitem" style="list-style-type: disc">PropTypes</li><li class="listitem" style="list-style-type: disc">State</li><li class="listitem" style="list-style-type: disc">State versus props</li><li class="listitem" style="list-style-type: disc">When to use state and props</li><li class="listitem" style="list-style-type: disc">Component life cycle overview</li><li class="listitem" style="list-style-type: disc">Component life cycle methods</li></ul></div><p>At the end of the chapter, we will get familiar with the data flow in the React components and the ways of maintaining and managing state. We will also get used to the life cycle of a component and various life cycle hooks provided by React.</p><div class="section" title="Data flow in React"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Data flow in React</h1></div></div></div><p>Shawn and Mark <a id="id66" class="indexterm"/>were getting ready to start working on a rainy day with a cup of coffee.</p><p>"Hey Mike, I have a question about props that we used to pass the <code class="literal">headings</code> and <code class="literal">changeSet</code> data to other components."</p><p>"Shoot!" Mike exclaimed.</p><p>"It seems to me that we are passing data to the components that are below the current component, but how can a component pass the data to the parent component?"</p><p>"Ah. In React, by default, all the data flows only in one direction: from parent component to child component. That's it."</p><p>This makes the job of the <a id="id67" class="indexterm"/>child component simple and predictable. Take props from the parent and render." Mike explained.</p><div class="informalexample"><pre class="programlisting">var RecentChangesTables = React.createClass({
  render: function(){
    return(&lt;table className = 'table'&gt;
             &lt;Headings headings = {this.props.headings} /&gt;
             &lt;Rows changeSets = {this.props.changeSets} /&gt;
           &lt;/table&gt;);
    }
});</pre></div><p>"Let's look at our example. The <code class="literal">RecentChangesTables</code> component passes the props to the <code class="literal">Headings</code> and <code class="literal">Rows</code> components. So basically, we can say that <code class="literal">RecentChangesTables</code> owns the <code class="literal">Headings</code> and <code class="literal">Rows</code> components."</p><p>"In React, an owner component sets props for another components." Mike explained.</p><p>"Got it. Therefore, in the preceding case, <code class="literal">&lt;table&gt;</code> is also owned by <code class="literal">RecentChangesTables</code>?" Shawn asked.</p><p>"No. The owner relationship is specific to the React components. In this case, table is the parent of <code class="literal">Headings</code> and <code class="literal">Rows</code>, similar to the parent-child relationship in DOM. But it's not an owner of them." explained Mike.</p><p>"A component is the owner of a child component if that child gets created in the render method of the parent. I guess this will solve the confusion." Mike added.</p><p>"Yes. Got the difference between owner and parent-child relationship." said Shawn.</p><p>"Furthermore, a component should not mutate its props. They should always be consistent with what the parent has set. It's a very important point that makes React's behavior consistent as well as fast, as we'll see soon." Mike further added.</p><p>"Props can be accessed by <code class="literal">this.props</code>, as we have already seen. If anything in the parent's props changes, React will make sure that the changes are flown downstream and will re-render the component tree." Mike.</p><p>"Excellent. Yesterday, I was reading something about validating the props." remembered Shawn.</p><p>"Yes. React allows validating the props using <code class="literal">PropTypes</code>. Let's take a look at them." said Mike, taking a sip <a id="id68" class="indexterm"/>from his freshly ground coffee.</p></div></div>
<div class="section" title="Props validation"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Props validation</h1></div></div></div><p>"React provides a <a id="id69" class="indexterm"/>way to validate the props using PropTypes. This is extremely useful to ensure that the components are used correctly. Here is an example of using <code class="literal">propTypes</code> for our app." explained Mike.</p><div class="informalexample"><pre class="programlisting">var App = React.createClass({
  propTypes: {
   headings: React.PropTypes.array,
   changeSets: React.PropTypes.array,
   author: React.PropTypes.string.isRequired
   },
  
  render: function(){
    return(&lt;table className = 'table'&gt;
             &lt;Headings headings = {this.props.headings} /&gt;
             &lt;Rows changeSets = {this.props.changeSets} /&gt;
           &lt;/table&gt;);
    }
});</pre></div><p>"Oh! Will it show an error as we are not passing the author, which is required, I assume? I see that <code class="literal">propTypes</code> has set the author value to be <code class="literal">isRequired</code>." Shawn asked.</p><div class="mediaobject"><img src="graphics/4730_03_01.jpg" alt="Props validation"/></div><p>"No. It will not throw an error, but it will show a nice warning for us to take a look at." said Mike.</p><p>"Also, <code class="literal">propTypes</code> are only checked in development. Their job is to just check that all the assumptions that we are making about our components are being met." Mike added.</p><p>"Got it. I agree that it's better to have it rather than getting surprised by random hiccups during production," Shawn.</p><p>"Yes. It's especially useful as, along with standard types, we can also validate the custom types." Mike informed.</p><div class="informalexample"><pre class="programlisting">var App = React.createClass({
  propTypes: {
   headings: function(props, propName, componentName) {
   if(propName === 'headings')
     return Error('Failed Validation');
   }
  },
  
  render: function(){
    return(&lt;table className = 'table'&gt;
             &lt;Headings headings = {this.props.headings} /&gt;
             &lt;Rows changeSets = {this.props.changeSets} /&gt;
           &lt;/table&gt;);
    }
});</pre></div><p>"Therefore, if the <a id="id70" class="indexterm"/>structure of the props is not as per your assumption, you can raise a warning by defining a custom validator as shown in the previous case", Mike explained.</p></div>
<div class="section" title="Specifying default props"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Specifying default props</h1></div></div></div><p>"Shawn, React also <a id="id71" class="indexterm"/>allows us to define some default values for props. This is useful when parent component is passing props based on some condition or not passing some props at all due to some change," Mike said.</p><div class="informalexample"><pre class="programlisting">var App = React.createClass({

 getDefaultProps: function() {
    return {
      headings: ['When happened ', 'Who did it', 'What they change']
    };
  },
  
  render: function(){
            …
  }
});

var data = [{ "when": "2 minutes ago",
              "who": "Jill Dupre",
              "description": "Created new account"
            },
            {
              "when": "1 hour ago",
              "who": "Lose White",
              "description": "Added first chapter"
            }];

React.render(&lt;App changeSets={data}/&gt;, document.body);</pre></div><p>"Here, we updated the code to not send the headings from props. Instead, we used the <code class="literal">getDefaultProps</code> function to define the default props that will be used in case they are not passed."</p><div class="mediaobject"><img src="graphics/4730_03_02.jpg" alt="Specifying default props"/></div><p>"Therefore, our output <a id="id72" class="indexterm"/>looks like this."</p><p>"Oh, ok. Makes sense. Rather than fiddling with the if-else clauses to check whether the prop is present, default props make it simple enough to predefine our data." said Shawn.</p></div>
<div class="section" title="Modifying this.props.children"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Modifying this.props.children</h1></div></div></div><p>"Shawn. There <a id="id73" class="indexterm"/>is one special prop that we should know <a id="id74" class="indexterm"/>about. It's <code class="literal">this.props.children</code>," continued Mike.</p><p>"React captures all the children that are present in the opening and closing tag into props that can be accessed through <code class="literal">this.props.children</code>." said Mike.</p><p>"Let's try to modify our code to use <code class="literal">this.props.children</code>. This is also required as we want to display a header for our output table." Mike added.</p><div class="informalexample"><pre class="programlisting">var RecentChangesTable = React.createClass({
  render: function(){
          return(
          &lt;div&gt;
            &lt;h1&gt; Recent Changes &lt;/h1&gt;
            &lt;table className='table'&gt;
               {this.props.children}
            &lt;/table&gt;
          &lt;/div&gt;
          );
  }
});

var App = React.createClass({
  render: function(){
    return(&lt;RecentChangesTable&gt;
             &lt;Headings headings = {this.props.headings} /&gt;
             &lt;Rows changeSets = {this.props.changeSets} /&gt;
           &lt;/RecentChangesTable&gt;);
    }
});</pre></div><div class="mediaobject"><img src="graphics/4730_03_03.jpg" alt="Modifying this.props.children"/></div><p>"Cool. So we extracted the table in its own component and also added a header." Shawn confirmed.</p><p>"Yes and we <a id="id75" class="indexterm"/>rendered <code class="literal">Headings</code> and <code class="literal">Rows</code> using <code class="literal">this.props.children</code>." Mike explained.</p><p>"Awesome. Let <a id="id76" class="indexterm"/>me change our code based on our discussion about props." Shawn said excitedly.</p></div>
<div class="section" title="State"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec32"/>State</h1></div></div></div><p>"Shawn, let's talk about <a id="id77" class="indexterm"/>one more technique of handling data in a component, state. Every component can have its own state in React. The main difference between state and props is that props are passed to the component from the parent component; whereas, state is something that is internal to the component.</p><p>Props are passed when a component gets instantiated. State is something that can change over time. Therefore, changes in state affect the rendering of components. Consider state as some sort of private data structure of the component." Mike added.</p><p>"Mike, but then we have not used state at all until now. We were just using props." Shawn asked.</p><p>"True. That is because state should be introduced only when it is required. You already know managing state <a id="id78" class="indexterm"/>is hard. As we were playing with static data of <code class="literal">ChangeSets</code> API, we didn't require state. However, we will need it very soon." Mike added.</p></div>
<div class="section" title="Setting initial state"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Setting initial state</h1></div></div></div><p>"The initial state can be <a id="id79" class="indexterm"/>set using the <code class="literal">getInitialState</code> function." said Mike.</p><div class="informalexample"><pre class="programlisting">var App = React.createClass({
  getInitialState: function() {
    return {
      changeSets: []
    };
  },
  
  render: function(){
    console.log(this.state.changeSets); // prints []  
});</pre></div><p>"State can be accessed <a id="id80" class="indexterm"/>similar to props using <code class="literal">this.state</code>." Mike explained further.</p></div>
<div class="section" title="Setting state"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Setting state</h1></div></div></div><p>"We might need to update <a id="id81" class="indexterm"/>the initial state based on some user events. Updating state is also easy using the <code class="literal">setState()</code> function." informed Mike.</p><div class="informalexample"><pre class="programlisting">var App = React.createClass({
  getInitialState: function() {
    return {
      changeSets: [],
      headings: ['Updated At', 'Author', 'Change']
    };
  },
  
  handleEvent: function(data) {
    this.setState({ changeSets: data.changeSets });
  },
  
  render: function(){
    …    
});</pre></div></div>
<div class="section" title="Avoiding state"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Avoiding state</h1></div></div></div><p>"Currently, we don't <a id="id82" class="indexterm"/>need state; however, when we fetch the dynamic data from <code class="literal">RecentChanges</code> API, we will use state with props." Mike added.</p><p>"Cool. Based on our discussion, I think that we should avoid state as much as possible." Shawn suggested.</p><p>"True. If a component does not change, then there is no need to use state. It's better to depend on props passed by the parent component in that case. This also avoids re-rendering of the component again and again as changes to state initiate a re-render of the component." Mike explained.</p></div>
<div class="section" title="State versus props"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec36"/>State versus props</h1></div></div></div><p>"Shawn, it's important to <a id="id83" class="indexterm"/>understand the difference between props and state and where to use what." informed Mike.</p><p>"Props are immutable. They <a id="id84" class="indexterm"/>should not be updated by the component to which they are passed. They are are owned by the component which passes them to some other component. State is something internal and private to the component. State can and will change depending on the interactions with the outer world." said Mike.</p><p>"State should store as simple data as possible, such as whether an input checkbox is checked or not or a CSS class that hides or displays the component." Mike added.</p><p>"Another thing to make sure is to not duplicate props in state." said Mike.</p><div class="informalexample"><pre class="programlisting">var App = React.createClass({
  getInitialState: function() {
    return {
      changeSets: this.props.changeSets
    };
  }
});</pre></div><p>"It is possible to set the state based on data passed in props. However, the parent component can update the props and send them again. In this case, the state will be muddled up with new data if there have been any changes to the state."</p><p>"Also, the data is present at two places now, therefore, it becomes harder to manage two sources of data." Mike explained.</p><p>"I think that in such <a id="id85" class="indexterm"/>cases, it's best to use props directly, right?" Shawn asked.</p><p>"Yes. The state is entirely <a id="id86" class="indexterm"/>optional. It's best to avoid it as much as possible. You got that right." Mike said happily.</p></div>
<div class="section" title="Component life cycle overview"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Component life cycle overview</h1></div></div></div><p>"Shawn, now let's <a id="id87" class="indexterm"/>start taking a look at how to dynamically fetch data from <a class="ulink" href="https://openlibrary.org/">https://openlibrary.org/</a>, store it in our component, and render it after making it compatible to render.</p><p>A component goes through different life cycle events. They help facilitate when we should initialize which part of a component or when should some external data be fetched.</p><p>We have already seen some of these methods such as <code class="literal">render</code>, <code class="literal">getInitialState</code>, and <code class="literal">getDefaultProps</code>.</p><p>An updated detailed list and example for the same can be found at <a class="ulink" href="http://videos.bigbinary.com/react/react-life-cycle-methods-in-depth.html">http://videos.bigbinary.com/react/react-life-cycle-methods-in-depth.html</a>.</p><p>Let's go through each of these, one by one, and how they can be used so that we can start fetching dynamic information for display. Here is a list of methods that we will discuss:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">componentWillMount</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">componentDidMount</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">componentWillReceiveProps(object nextProps)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">boolean shouldComponentUpdate(object nextProps, object nextState)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">componentWillUpdate(object nextProps, object nextState)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">componentDidUpdate(object prevProps, object prevState)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">componentWillUnmount()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">React.unmountComponentAtNode(document.body)</code><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>You can follow along the next example at <a class="ulink" href="http://jsbin.com/tijeco/3/edit">http://jsbin.com/tijeco/3/edit</a>.</p></div></div></li></ul></div></div>
<div class="section" title="Component life cycle methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec38"/>Component life cycle methods</h1></div></div></div><p>"Shawn, let's <a id="id88" class="indexterm"/>start with an exhaustive example that triggers these methods." Mike informed.</p><div class="informalexample"><pre class="programlisting">console.log('Start') // Marks entry point of JS code.
var App = React.createClass({
    componentWillMount: function(){
      console.log('componentWillMount');
    },
    
    componentDidMount: function(){
      console.log('componentDidMount');
    },
    
    getInitialState: function(){
      return { status: true}
    },

    getDefaultProps: function(){
      return {name: 'John'};
    },
  
    componentWillReceiveProps: function(nextProps){
      console.log('componentWillReceiveProps');
    },

    shouldComponentUpdate: function(nextProps, nextState){
      console.log('shouldComponentUpdate');
      return true;
    },
    
    componentWillUpdate: function(){
      console.log('componentWillUpdate');
    },
    
    render: function() {
      console.log('render');
      return &lt;h1 onClick={this.toggleState}&gt;    
             {this.state.status.toString()}
             &lt;/h1&gt;
    },

    componentWillUnmount: function(){
      console.log('componentWillUnmount')
    },
    
    toggleState: function() {
      this.setState({status: !this.state.status})
    }
    });

/* List of methods and signatures for reference
* componentWillMount
* componentDidMount
* componentWillReceiveProps(object nextProps)
* boolean shouldComponentUpdate(object nextProps, object nextState)
* componentWillUpdate(object nextProps, object nextState)
* componentDidUpdate(object prevProps, object prevState)
* componentWillUnmount()
/

React.render(&lt;App name='Jane'/&gt;, document.body);</pre></div><div class="mediaobject"><img src="graphics/4730_03_04.jpg" alt="Component life cycle methods"/></div><p>"It simply displays a body with the <code class="literal">true</code> text and then on clicking, it changes it to display <code class="literal">false</code>." Mike.</p><p>"Shawn, to keep things simple, I have added just a simple <code class="literal">console.log()</code> method for every life cycle method so that we know it was called. If we do a fresh run, the following is printed:"</p><div class="informalexample"><pre class="programlisting">"Start"
"componentWillMount"
"render"
"componentDidMount"</pre></div><p>"Ah, got it. Basically, the window first printed <code class="literal">Start</code> to signal the file has been loaded." Shawn said.</p><p>"Correct. Next, it printed out <code class="literal">componentWillMount</code>. That's the entry point for our component. This method is called when a component gets mounted on the body for the first time. If you can see, we are calling <code class="literal">React.render</code>."</p><div class="informalexample"><pre class="programlisting">React.render(&lt;App name='Jane'/&gt;, document.body);</pre></div><p>This is what triggers <a id="id89" class="indexterm"/>
<code class="literal">componentWillMount</code>. In this method, we can call <code class="literal">setState</code> to perform some changes to our internal data. However, that doesn't call a new re-render or this method again.</p><p>Next is the actual <code class="literal">render</code> method call. This is responsible for the actual component display.</p><p>Finally, we have a call to <code class="literal">componentDidMount</code>. This is invoked immediately after mounting the component and only once after the component is rendered.</p><p>We can make use of this to fetch the dynamic information that we want to display in our component after the initial render of the component.</p><p>"Once that's done, we are done with our initial run for the display of a component!"</p><p>"Nice." exclaimed Shawn.</p><p>"Now, we have added a simple <code class="literal">onClick</code> event. This calls <code class="literal">this.toggleState</code>, which toggles the current status from <code class="literal">true</code> to <code class="literal">false</code> and vice versa."</p><p>As the state is affected, React re-renders the <code class="literal">App</code> component. We can see the method call sequence when this happens, as follows:"</p><div class="informalexample"><pre class="programlisting">"…"
"shouldComponentUpdate"
"componentWillUpdate"
"render"
"…"</pre></div><p>"Ah, nice. It went through another re-render cycle." said Shawn.</p><p>"Correct. When the state was changed, React knew it needed to re-render the <code class="literal">App</code> component. It calls <code class="literal">shouldComponentUpdate</code> first. This method returns <code class="literal">true</code> or <code class="literal">false</code> indicating React to render the component or not.</p><p>"We can also control whether the component should be re-rendered or not even if the state gets updated. This method can return <code class="literal">false</code> and then React will not re-render the component even if the state is changed."</p><div class="informalexample"><pre class="programlisting">    shouldComponentUpdate: function(nextProps, nextState){
      console.log('shouldComponentUpdate');
      return false; // Will not re-render the component.
    },</pre></div><p>"We can also compare <code class="literal">nextProps</code> and <code class="literal">nextState</code> to the existing values and then decide whether to re-render."</p><p>"Awesome, this means that we could get faster components!" Shawn exclaimed.</p><p>"Exactly. By default, it always returns true, to always render on changes." Mike concluded.</p><p>"Next up, <code class="literal">componentWillUpdate</code> will get called just before <code class="literal">rendering</code>. We can take care of any changes that <a id="id90" class="indexterm"/>we would like to do or any housekeeping. One thing to note is that we can't call <code class="literal">setState</code> in this method. State updates should be handled elsewhere."</p><p>"Oh, ok," Shawn.</p><p>"We are only left with <code class="literal">componentWillReceiveProps</code>."</p><div class="informalexample"><pre class="programlisting"> componentWillReceiveProps: function(nextProps){
      console.log('componentWillReceiveProps');
    },</pre></div><p>"It receives <code class="literal">nextProps</code>, which are the new props that the child component receives from the parent component. This method is not called for initial render. We can update the state or do some other housekeeping work based on the changes in props."</p><p>"Nice, Mike. I think I am getting a better hang of this."</p><p>"Finally, we have <code class="literal">componentWillUnmount</code>. This is called when the component is unmounted from the body. We can use this to release the resources, perform cleanups, unset any timers, and so on."</p><p>"Got it."</p><p>"Alright! Let's update our component to start fetching the information from <a class="ulink" href="https://openlibrary.org/">https://openlibrary.org/</a>."</p><p>"So, what we will be doing is updating the <code class="literal">componentDidMount</code> to perform an AJAX call and fetch data to display."</p><div class="informalexample"><pre class="programlisting">  componentDidMount : function(){
    $.ajax({
      url: 'http://openlibrary.org/recentchanges.json?limit=10',
      context: this,
      dataType: 'json',
      type: 'GET'
    }).done(function (data) {
      var changeSets = this.mapOpenLibraryDataToChangeSet(data);
      this.setState({changeSets: changeSets});
    });
  }</pre></div><p>"Here, we are <a id="id91" class="indexterm"/>making a call to <a class="ulink" href="http://openlibrary.org/recentchanges.json?limit=10">http://openlibrary.org/recentchanges.json?limit=10</a> and asking for the ten most-recent changes. We will get the data in the following format:"</p><div class="informalexample"><pre class="programlisting">[{
     comment:   "Added new cover",
     kind:      "add-cover",
     author:    {
         key: "/people/fsrc"
     },
     timestamp: "2015-05-25T19:20:33.981700",
     changes:   [
                    {
                        key:      "/books/OL25679864M",
                        revision: 2
                    }
                ],
     ip:        null,
     data:      { url: "" },
     id:        "49441324"
 }, 
{
…
}
]</pre></div><p>"We will need to format the data as per our requirements so that it's displayed nicely. Let's take a look at it:"</p><div class="informalexample"><pre class="programlisting">mapOpenLibraryDataToChangeSet : function (data) {
  return data.map(function (change, index) {
    return {
      "when": jQuery.timeago(change.timestamp),
      "who": change.author.key,
      "description": change.comment
    }
  });
} </pre></div><p>"Here, we are extracting the timestamp, author information, and description of the change, which is the comment in the change. As the changed time is a timestamp, we have made use of the <code class="literal">jQuery.timeago</code> plugin to get desirable display of time, such as <code class="literal">2 minutes ago</code> and so forth. To use this plugin, we need to include it in our HTML <code class="literal">head</code> tag." Mike explained.</p><div class="informalexample"><pre class="programlisting">&lt;script src="jquery.timeago.js" type="text/javascript"&gt;&lt;/script&gt;</pre></div><p>"Looks like it's all <a id="id92" class="indexterm"/>coming together." Shawn.</p><p>"It is, let's take a look at everything in action, shall we?"</p><div class="informalexample"><pre class="programlisting">var Heading = React.createClass({
    render: function () {
        var headingStyle = {
            backgroundColor: 'FloralWhite',
            fontSize: '19px'
        };
        return (&lt;th style={headingStyle}&gt; {this.props.heading} &lt;/th&gt;);
    }
});
var Headings = React.createClass({
    render: function () {
        var headings = this.props.headings.map(function (name, index) {
            return (&lt;Heading key={"heading-" + index} heading={name}/&gt;);
        });

        return (&lt;tr className='table-th'&gt; {headings} &lt;/tr&gt;);
    }
});
var Row = React.createClass({
    render: function () {
        var trStyle = {backgroundColor: 'aliceblue'};
        return (&lt;tr style={trStyle}&gt;
            &lt;td&gt; {this.props.changeSet.when} &lt;/td&gt;
            &lt;td&gt; {this.props.changeSet.who} &lt;/td&gt;
            &lt;td&gt; {this.props.changeSet.description} &lt;/td&gt;
        &lt;/tr&gt;);
    }
});
var Rows = React.createClass({
    render: function () {
        var rows = this.props.changeSets.map(function (changeSet, index) {
            return (&lt;Row key={index} changeSet={changeSet}/&gt;);
        });

        return (&lt;tbody&gt;{rows}&lt;/tbody&gt;);
    }
});

var App = React.createClass({
    getInitialState: function () {
        return {changeSets: [];
    },
    mapOpenLibraryDataToChangeSet: function (data) {
        return data.map(function (change, index) {
            return {
                "when": jQuery.timeago(change.timestamp),
                "who": change.author.key,
                "description": change.comment
            }
        });
    },
    componentDidMount: function () {
        $.ajax({
            url: 'http://openlibrary.org/recentchanges.json?limit=10',
            context: this,
            dataType: 'json',
            type: 'GET'
        }).done(function (data) {
            var changeSets = this.mapOpenLibraryDataToChangeSet(data);
            this.setState({changeSets: changeSets});
        });
    },

    render: function () {
        return (&lt;table className='table'&gt;
            &lt;Headings headings={this.props.headings}/&gt;
            &lt;Rows changeSets={this.state.changeSets}/&gt;
        &lt;/table&gt;);
    }
});

var headings = ['Updated at ', 'Author', 'Change'];
React.render(&lt;App headings={headings} /&gt;, document.body);</pre></div><p>"Here's our final product!", exclaimed Mike.</p><p>"Awesome, I can't wait to see what we build next!" Shawn added.</p><p>Another productive <a id="id93" class="indexterm"/>day at Adequate. Mike and Shawn, happy with the progress, headed back.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec39"/>Summary</h1></div></div></div><p>In this chapter, we looked at how to pass around data in the React components using props and state. We also discussed how and when to use state and props. We looked at how <code class="literal">propTypes</code> can be used to validate the props. After that, we discussed the component's life cycle. We discussed about the various life cycle methods and how they can be used. After that, we used these life cycle methods to get real-time data from Open Library API.</p></div></body></html>