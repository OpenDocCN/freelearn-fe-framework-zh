- en: Integration Testing with Appium
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Appium进行集成测试
- en: In the preceding chapter, we explored how to do unit testing, but unit testing
    doesn't allow you to test whether the button used in your app still actually runs
    a function, or what happens when the user swipes left. For that, we will need
    application testing or end-to-end testing. Well, let's start learning end-to-end
    testing; this is where testing can get complicated and fun.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了如何进行单元测试，但单元测试不允许你测试应用程序中使用的按钮是否仍然实际运行一个函数，或者当用户向左滑动时会发生什么。为此，我们需要应用程序测试或端到端测试。好吧，让我们开始学习端到端测试；这是测试变得复杂和有趣的地方。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Appium testing framework
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Appium测试框架
- en: Writing MochaJS, ChaiJS, and ShouldJS tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写MochaJS、ChaiJS和ShouldJS测试
- en: How to find and interact with elements on the screen
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在屏幕上查找和与元素交互
- en: How to run the tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何运行测试
- en: Travis and GitHub integration
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Travis和GitHub集成
- en: Integration testing
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: There are several full application frameworks out there, but we will show you
    how to use Appium ([http://appium.io](http://appium.io)). Appium is an awesome
    open source application testing framework. Appium supports both iOS and Android,
    which makes it a perfect fit for doing all our on-device testing. You want to
    start creating tests to test your basic flow through your application, and even
    create more complicated tests that test alternate flows through your app.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有几个完整的应用程序框架，但我们将向您展示如何使用Appium（[http://appium.io](http://appium.io)）。Appium是一个出色的开源应用程序测试框架。Appium支持iOS和Android，这使得它非常适合进行所有我们的设备测试。您想要开始创建测试来测试您通过应用程序的基本流程，甚至创建更复杂的测试来测试通过应用程序的替代流程。
- en: 'Let''s get it installed first; run the following command:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先安装它；运行以下命令：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding command installs Appium, the Appium communication driver **WD** ([http://admc.io/wd/](http://admc.io/wd/)),
    and the **NativeScript driver** ([https://github.com/NativeScript/nativescript-dev-appium](https://github.com/NativeScript/nativescript-dev-appium)).
    The WD driver is what communicates with Appium and the NativeScript driver. The
    `nativescript-dev-appium` is the driver that interacts with WD and your test code.
    In reality, the NativeScript driver is a very thin wrapper around the WD driver
    and just facilitates some configuration and then exposes the WD driver to your
    application. So interaction commands will be found in the WD documentation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令安装了Appium，Appium通信驱动**WD**（[http://admc.io/wd/](http://admc.io/wd/))，以及**NativeScript驱动程序**（[https://github.com/NativeScript/nativescript-dev-appium](https://github.com/NativeScript/nativescript-dev-appium)）。WD驱动程序是与Appium通信以及NativeScript驱动程序的通信。`nativescript-dev-appium`是与WD交互以及与你的测试代码交互的驱动程序。实际上，NativeScript驱动程序是WD驱动程序的一个非常薄的包装，仅便于一些配置，然后将WD驱动程序暴露给应用程序。因此，交互命令可以在WD文档中找到。
- en: Application/Integration testing takes a bit more work, as you have to programmatically
    run it as a normal user would interact with your app. So, you have to do things,
    such as find the button element, then perform `button.tap()`. So, your tests might
    be a bit verbose, but this allows you to test any, and all, functionalities. The
    down side is that this is a lot more time-consuming to run and takes more maintenance
    work when you change screens. However, the payoff is that when you add code, it
    verifies that your app still runs properly on each screen automatically, and you
    can test it on multiple devices and resolutions, once again automatically.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序/集成测试需要更多的工作，因为你必须以普通用户交互的方式程序化地运行它。因此，你必须做一些事情，比如找到按钮元素，然后执行`button.tap()`。所以，你的测试可能会有些冗长，但这允许你测试任何，以及所有的功能。缺点是这需要更多的时间来运行，并且在更改屏幕时需要更多的维护工作。然而，回报是当你添加代码时，它会自动验证你的应用程序在每个屏幕上仍然可以正常运行，并且你可以自动在多个设备和分辨率上测试它。
- en: After installation, you will have a brand new `e2e-tests` folder in your root
    folder of your application. This folder is where all your end-to-end test files
    will live. Now, one thing that you need to know is that the Appium NativeScript
    driver uses the MochaJS test framework ([https://mochajs.org/](https://mochajs.org/)).
    The Mocha testing framework is similar to the Jasmine framework, which we discussed
    in the preceding chapter. It uses the same `describe` and `it` functions for the
    start of the tests, just like Jasmine. In addition, it uses the Chai ([http://chaijs.com/](http://chaijs.com/))
    and ShouldJS ([https://github.com/shouldjs/should.js](https://github.com/shouldjs/should.js))
    testing frameworks that work hand in hand with the Mocha test framework and the
    WD driver.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你将在应用程序的根目录下有一个全新的`e2e-tests`文件夹。这个文件夹将存放你所有的端到端测试文件。现在，你需要知道的是，Appium
    NativeScript驱动程序使用MochaJS测试框架（[https://mochajs.org/](https://mochajs.org/)）。Mocha测试框架类似于我们在上一章中讨论的Jasmine框架。它使用相同的`describe`和`it`函数来开始测试，就像Jasmine一样。此外，它还使用Chai
    ([http://chaijs.com/](http://chaijs.com/))和ShouldJS ([https://github.com/shouldjs/should.js](https://github.com/shouldjs/should.js))测试框架，这些框架与Mocha测试框架和WD驱动程序协同工作。
- en: Another thing to note is that all these are designed around pure JavaScript.
    You can get typings for Mocha, Should, and Chai, but for the NativeScript Appium
    driver or WD driver, typings don't exist. You can use TypeScript, but it is awkward,
    as commands are not just WD-based commands but chained through mocha. TypeScript
    gets easily confused as to what context you are in. So, mostly the Appium tests
    are created in pure JavaScript rather than in TypeScript. However, feel free to
    use TypeScript if you want; just make sure that you run `tsc` to build the `JS`
    files before you run the tests.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是，所有这些都是在纯JavaScript的基础上设计的。你可以为Mocha、Should和Chai获取类型定义，但对于NativeScript
    Appium驱动程序或WD驱动程序，类型定义不存在。你可以使用TypeScript，但这会很尴尬，因为命令不仅仅是基于WD的命令，而是通过mocha链式执行的。TypeScript很容易混淆你当前所处的上下文。因此，Appium测试主要是在纯JavaScript而不是TypeScript中创建的。然而，如果你想使用TypeScript，请确保在运行测试之前运行`tsc`来构建`JS`文件。
- en: Configuration
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置
- en: 'One more setup step that you will need to do is to create an `appium.capabilities.json`
    file in the root folder of your project. This is basically a configuration file
    that you can use to configure the emulator that you need to run any of your tests
    on. The file is documented on the Appium site but to get you up and running quickly
    you can use the paired-down file which we use as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要进行的一个设置步骤是在项目的根目录下创建一个`appium.capabilities.json`文件。这是一个基本的配置文件，你可以用它来配置你需要在上面运行任何测试的模拟器。该文件在Appium网站上有所说明，但为了让你快速启动，你可以使用我们使用的简化版文件，如下所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We've simplified it and removed all other emulator entries to save space. However
    you give each emulator entry a key-- you tell Appium using the key the emulator
    configuration that you will be running. This example file shows two configurations.
    The first one is an Android 4.4 device, and the second one is an iOS simulator
    (iPhone 6 runs iOS 10). You can have as many configurations as you want in this
    file. When you run Appium, you can tell it which device you will target, using
    the `--runType=KEY` parameter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简化了它，并删除了所有其他模拟器条目以节省空间。然而，你需要为每个模拟器条目提供一个键——你告诉Appium使用该键来指定你将要运行的模拟器配置。这个示例文件显示了两个配置。第一个是一个Android
    4.4设备，第二个是一个iOS模拟器（iPhone 6运行iOS 10）。你可以在该文件中设置任意多的配置。当你运行Appium时，你可以使用`--runType=KEY`参数来告诉它你将针对哪个设备。
- en: Creating a test
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个测试
- en: 'Let''s start our journey and create a new test file: `list.test.js`. This file
    will test our mix-list screen. The screen''s HTML (`/app/modules/mixer/components/mix-list.component.html`)
    looks like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始我们的旅程，创建一个新的测试文件：`list.test.js`。这个文件将测试我们的混合列表屏幕。屏幕的HTML（`/app/modules/mixer/components/mix-list.component.html`）看起来如下：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We've included the code here so that you can see easily how we made the test
    with the details provided on the screen.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里包含了代码，这样你可以很容易地看到我们如何根据屏幕上提供的详细信息制作测试。
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We need to include the NativeScript Appium driver in our JavaScript test code;
    this is what is used to actually communicate and set up the Mocha, ShouldJS, WD,
    Appium, and Chia to be able to work properly. The following line alone is required
    for your usage:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在JavaScript测试代码中包含NativeScript Appium驱动程序；这是用来实际通信和设置Mocha、ShouldJS、WD、Appium和Chai以使其能够正常工作的。以下行对于你的使用是必需的：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As the comments in the source code mention, it is critical that you give enough
    time to start up Appium and the application in your emulator. So, out personal
    default is `100,000`; you can play with this number, but this is the maximum amount
    of time it will wait before it will declare the tests a failure. Having a larger
    value means that you give your emulator and Appium more time to actually start
    running. Appium gives you its startup output quickly, but when it goes to actually
    initialize the test and driver, that process takes a lot of time. Once the test
    starts to run, it runs very fast:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如源代码中的注释所述，确保你有足够的时间启动Appium和你的模拟器中的应用程序至关重要。因此，我们个人的默认值是`100,000`；你可以调整这个数字，但这将是它等待宣布测试失败的最大时间量。较大的值意味着你给你的模拟器和Appium更多的时间来实际启动。Appium会快速给出其启动输出，但当它开始初始化测试和驱动器时，这个过程需要花费很多时间。一旦测试开始运行，它就会非常快地运行：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It is also very important to initialize and create the driver before your tests
    are run. This driver is global throughout your tests. So, we will declare it globally
    in the `describe` function and then initialize it with the Mocha `before` function
    that runs before any tests are run:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的测试运行之前初始化和创建驱动器也非常重要。在整个测试过程中，这个驱动器是全局的。因此，我们将在`describe`函数中全局声明它，然后使用在所有测试运行之前运行的Mocha
    `before`函数来初始化它：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We also add a Mocha after function to shut down the driver when we are all
    done. It is very important to ensure that any time you are working with the driver
    that you properly return it. Almost every single test piece is actually a promise
    underneath it. If you forget to return the promise, the testing harness will get
    royally mixed up and may run tests out of order and even close the driver before
    the tests are completed. So, always return the promise:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个Mocha后置函数，在我们全部完成时关闭驱动器。确保每次你在使用驱动器时都正确地返回它非常重要。实际上，几乎每一个测试片段下面都隐藏着一个承诺。如果你忘记返回承诺，测试工具将变得混乱不堪，可能会以错误的顺序运行测试，甚至在测试完成之前关闭驱动器。所以，总是要返回承诺：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `it` function is used just like we did in Jasmine--you are describing a
    test you plan on running so that you can find it if the test fails. Again, we
    return the promise chain; it is very important that you don't forget to do this.
    The driver variable is what gives us the different functionality when dealing
    with the emulators. So, the documentation for the functionality is in the WD repository,
    but I will give you a quick overview to get you going.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`it`函数的使用方式就像我们在Jasmine中做的那样——你正在描述你计划运行的测试，这样你就可以在测试失败时找到它。再次强调，我们返回承诺链；你绝对不要忘记做这件事。驱动器变量是我们在处理模拟器时获得不同功能的原因。所以，该功能的文档在WD仓库中，但我将给你一个快速概述，帮助你开始。'
- en: '`.elementByXPath` and `.elementById` are really the only two functions that
    work well to properly find elements with NativeScript . However there is also
    a `.waitForElementByXPath` and `.waitForElementById` which both wait for the elements
    to show up. If you look at the documentation, you will observe a lot of `elementByXXX`
    commands, but Appium was designed for a browser, and NativeScript is not a browser.
    That is why, only some commands that have been emulated in the nativescript-dev-appium
    driver work to find elements in the NativeScript DOM.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`.elementByXPath`和`.elementById`是真正能很好地用于在NativeScript中正确查找元素的唯一两个函数。然而，也存在`.waitForElementByXPath`和`.waitForElementById`，这两个函数都会等待元素出现。如果你查看文档，你会观察到很多`elementByXXX`命令，但Appium是为浏览器设计的，而NativeScript不是浏览器。这就是为什么，只有一些在nativescript-dev-appium驱动器中模拟的命令才能在NativeScript
    DOM中查找元素。'
- en: 'So our test says find an element by XPath. XPath allows you to drill into your
    DOM and find components any level deep and also subcomponents of other components.
    So, if you do something like `/GridLayout/StackLayout/Label`, it will find a `Label`
    that is a child of a `StackLayout`, which is a child of a `GridLayout`. Using
    `*//*` will mean that you can find that element at any level in the DOM. Finally
    the `nsAppium.getXPathElement` is a method which was added to the official NativeScript
    driver by Nathanael Anderson to allow us to make the XPath tests cross-platform.
    In all reality, what you are passing to the XPath function is the real native
    name of the object. For example, a button on Android is a `android.widget.Button` or
    it could be a `UIAButton` or a `XCUIElementTypeButton` on iOS. So because you
    don''t want to hardcode `getByElementXPath("android.widget.Button")`, this helper
    function translates the NativeScript `Button` to the proper underlying OS element
    that NativeScript actually uses when it creates a button in NativeScript. If,
    in the future, you add a plugin that uses an element that the `getXPathElement`
    doesn''t know about, you can still use the real name of the element for those
    tests:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的测试是使用XPath查找元素。XPath允许你深入DOM并找到任何深度的组件，以及其他组件的子组件。所以，如果你做类似`/GridLayout/StackLayout/Label`的事情，它将找到一个`Label`，它是`StackLayout`的子组件，而`StackLayout`又是`GridLayout`的子组件。使用`*//*`意味着你可以在DOM的任何级别找到该元素。最后，`nsAppium.getXPathElement`是一个由Nathanael
    Anderson添加到官方NativeScript驱动程序的方法，允许我们进行跨平台的XPath测试。实际上，你传递给XPath函数的是对象的真正原生名称。例如，在Android上，按钮是`android.widget.Button`，或者它可能是iOS上的`UIAButton`或`XCUIElementTypeButton`。所以因为你不想硬编码`getByElementXPath("android.widget.Button")`，这个辅助函数将NativeScript的`Button`转换为NativeScript在创建按钮时实际使用的正确底层OS元素。如果将来你添加了一个使用`getXPathElement`不知道的元素的插件，你仍然可以使用元素的真正名称进行这些测试：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`.text()` is a function that Appium driver exposes to get the text value of
    the elements it finds. The `.should.eventually.exist.equal` is a Mocha and Should
    code. We are basically making sure that once this item is found, it actually matches
    the Unicode value of F067, which in Font-Awesome is the Plus character (fa-plus).
    Once it exists, we are happy--the test either succeeds or fails, depending on
    whether we break the screen or the screen continues to be the way we expect it.
    In addition, after the `**.equal**`, we could have chained more commands, such
    as `.tap()`, to fire the button if we wanted.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`.text()`是一个Appium驱动程序公开的函数，用于获取它找到的元素的文本值。`.should.eventually.exist.equal`是Mocha和Should代码。我们基本上确保一旦找到这个项目，它实际上匹配F067的Unicode值，在Font-Awesome中是加号字符（fa-plus）。一旦它存在，我们就满意了——测试要么成功，要么失败，这取决于我们是否打破了屏幕，或者屏幕是否继续以我们期望的方式存在。此外，在`**.equal**`之后，我们还可以链式调用更多命令，例如`.tap()`，如果我们想触发按钮的话。'
- en: 'Okay, let''s look at the next test that runs:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们看看下一个运行的测试：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This test searches the screen to show the `Demo` ListView item. We are looking
    for a NativeScript Label (that is, `nsAppium.getXPathElement`) anywhere in the
    NativeScript DOM (that is, `*//*`) that contains the text value of Demo in it.
    (that is, `[@text=''Demo'']`). This element should eventually exist, and once
    it does exist, it calls the `tap()` function. Now, if you look at the source code,
    you will see the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试在屏幕上搜索以显示`Demo` ListView项。我们正在寻找NativeScript Label（即`nsAppium.getXPathElement`），它在NativeScript
    DOM（即`*//*`）中的任何地方都包含文本值Demo。（即`[@text='Demo']`）。这个元素最终应该存在，一旦它存在，它就调用`tap()`函数。现在，如果你查看源代码，你会看到以下内容：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, it will run the select function when the `tap` is fired. The `select` function
    ends up ultimately loading the `/app/modules/player/components/track-list/track-list.component.html`
    file, which is used to display the composition of that mixer item on the screen.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当`tap`事件触发时，它将运行选择函数。`select`函数最终会加载`/app/modules/player/components/track-list/track-list.component.html`文件，该文件用于在屏幕上显示该混音项的组成。
- en: All the tests are executed sequentially, and the state of the app is preserved
    from one test to another. This means that tests are not independent like we are
    used to when writing unit-tests.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试都是顺序执行的，并且应用的状态从一个测试保留到另一个测试。这意味着测试并不是像我们编写单元测试时那样相互独立的。
- en: 'The next test we will verify is that the `Demo` Label actually switches screens
    in the next test after we tap on it:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要验证的下一个测试是，在点击它之后，`Demo` 标签实际上会在下一个测试中切换屏幕：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So, now that we are on a new screen, we will verify that the `ListView` contains
    a Label with the name of `Drums`. This test just verifies that the screen actually
    changed when we tapped on the `Demo` Label in the prior test. We could have verified
    the text value but really if it exists, we are good. So, let''s look at the next
    test:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经进入了一个新的屏幕，我们将验证`ListView`是否包含一个名为`Drums`的标签。这个测试只是验证在我们点击前一个测试中的`Demo`标签时，屏幕实际上是否发生了变化。我们本可以验证文本值，但如果我们确认它存在，我们就没问题了。所以，让我们看看下一个测试：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our final example test shows chaining. We search the Label that has the volume
    control symbol. Then, once it exists, we tap on it. Then, we verify that the text
    actually became the volume off symbol. The `f028` is the Font Awesome Unicode
    value for `fa-volume-up`, and the `f026` is the Font Awesome Unicode value for
    `fa-volume-off`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的示例测试展示了链式调用。我们搜索具有音量控制符号的标签。一旦它存在，我们就点击它。然后，我们验证文本实际上变成了音量关闭符号。`f028`是`fa-volume-up`的Font
    Awesome Unicode值，而`f026`是`fa-volume-off`的Font Awesome Unicode值。
- en: 'So now that you have this really cool test, you want to launch your emulator.
    The emulator should be already running. You also should ensure that you have the
    latest version of the application on the device. Then, to run the test, simply
    type the following command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在你有了这个非常酷的测试，你想要启动你的模拟器。模拟器应该已经运行了。你还应该确保设备上有应用程序的最新版本。然后，要运行测试，只需输入以下命令：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Ensure that you put in which run type configuration you are going to use, and
    you should see something like this after a few minutes:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你输入你将要使用的运行类型配置，几分钟后你应该能看到类似以下内容：
- en: '![](img/00058.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00058.jpeg)'
- en: Remember that Appium end-to-end tests take a while to start, so if it looks
    like it is frozen for a while, don't panic and quit it. It may take 24 seconds
    for the first test, seconds for each additional test. The first test has all the
    time in it. It is normal for Appium to take a long time to start the driver and
    the application on the emulator. This delay normally occurs after you see the
    first couple of lines of text printed, as shown in the preceding screen, so, have
    some patience.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Appium端到端测试启动需要一段时间，所以如果它看起来冻结了一段时间，不要慌张并退出它。第一次测试可能需要24秒，每个额外的测试可能需要几秒钟。第一次测试包含了所有时间。Appium在模拟器上启动驱动程序和应用程序需要很长时间是正常的。这种延迟通常发生在你看到前几行文本打印出来之后，如前述屏幕所示，所以，请有点耐心。
- en: More Appium testing
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多Appium测试
- en: 'I wanted to include one more test (not used in this application) that I have
    written in the past for a different project since this will give you an idea of
    just how powerful Appium can be:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我想包括一个额外的测试（在这个应用程序中没有使用），这是我过去为不同的项目编写的，因为这会给你一个关于Appium有多强大的概念：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first thing you might note is that I did not return the promise chain. That
    is because this example shows how to use the asynchronous support of `it`. For
    an async support, you can use a promise or make the function coming into `it`
    have a `done` callback function. When Mocha detects a callback function in the
    `it`, it will run your `it` tests in the async mode and doesn't need the promise
    to let it know that it can resume with the next test. Sometimes, you may just
    want to maintain full control or you may be calling code that requires async callbacks.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到的第一件事是，我没有返回promise链。这是因为这个例子展示了如何使用`it`的异步支持。对于异步支持，你可以使用一个promise或者让传入`it`的函数有一个`done`回调函数。当Mocha检测到`it`中的回调函数时，它将以异步模式运行你的`it`测试，并且不需要promise来让它知道它可以继续下一个测试。有时，你可能只是想保持完全控制，或者你可能正在调用需要异步回调的代码。
- en: This test looks for a `EditText` element that contains `Enter your name`. Then,
    it actually types *Testing* into it using the `sendKeys`. Next, it asks for the
    `text` out of the field and uses the `then` part of the promise to check the value
    against the hardcoded testing. When it is all finished, it calls the `done` function.
    If you pass the `done` function an `Error` object, then it knows that the test
    failed. So, you can see in the `if` statement that we passed a `new Error` and
    that we put the `done` function in the `catch` part of the `then` statement.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试寻找一个包含`Enter your name`的`EditText`元素。然后，它实际上使用`sendKeys`将*Testing*输入其中。接下来，它请求字段的`text`并使用promise的`then`部分来检查值与硬编码的测试值是否匹配。当一切完成后，它调用`done`函数。如果你向`done`函数传递一个`Error`对象，那么它就知道测试失败了。所以，你可以在`if`语句中看到我们传递了一个`new
    Error`，并且我们将`done`函数放在了`then`语句的`catch`部分。
- en: We have barely scratched the surface of what you can do with Appium, Should,
    Mocha, and Chia. You can control pretty much all aspects of the application as
    if you were manually doing each step. Initially, in your development, manually
    testing is a lot faster. However, as you start to build up end-to-end tests, each
    time you make changes, you can check whether the app still works properly, and
    you do not have to sit in front of multiple devices for any amount of time--you
    just start the tests and see the results later.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎只是触及了使用Appium、Should、Mocha和Chia所能做到的一小部分。你可以控制应用几乎所有的方面，就像你在手动进行每一步一样。最初，在你的开发过程中，手动测试要快得多。然而，当你开始构建端到端测试时，每次你进行更改，你都可以检查应用是否仍然正常工作，而且你不必长时间坐在多个设备前——你只需启动测试，稍后查看结果即可。
- en: Automated testing
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试
- en: One more thing that you should note is that the more automated you make your
    testing, the more likely you are to use it and gain from its benefits. If you
    constantly have to manually run the test, you are likely to get annoyed and stop
    running them. So automating this is critical in our opinion. Since there are many
    books written on this subject we are just going to give you a couple of pointers
    that you can research and then move forward.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点需要注意，你使测试自动化程度越高，你越有可能使用它并从中获益。如果你必须不断手动运行测试，你可能会感到厌烦并停止运行它们。所以，我们认为自动化这一点至关重要。由于关于这个主题有许多书籍，我们只是给你提供一些你可以研究并继续前进的提示。
- en: Most source control systems allow you to create hooks. With these hooks, you
    can create a commit hook so that on check-in of any new code, your testing frameworks
    will run. These hooks are normally pretty simple to create as they are simple
    scripts that just run each time a commit is made.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数源代码控制系统允许你创建钩子。通过这些钩子，你可以创建一个提交钩子，以便在检查任何新代码时运行你的测试框架。这些钩子通常很简单创建，因为它们只是每次提交时运行的简单脚本。
- en: In addition, if you are using GitHub, there are sites such as Travis that you
    can tie into easily without having to do any hook changes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你使用GitHub，你可以轻松地将Travis等网站集成进来，而无需进行任何钩子更改。
- en: GitHub and Travis integration
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitHub和Travis集成
- en: 'Here is how you can do some integration with GitHub and Travis; this will allow
    your NativeScript Testing framework, which we discussed in the preceding chapter,
    to automatically run your tests on each change or pull request. Create a new `.travis.yml`
    file in the very root of your GitHub repository. This file should look like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何与GitHub和Travis进行一些集成的示例；这将允许你的NativeScript测试框架，我们在上一章中讨论过，在每次更改或pull request时自动运行你的测试。在你的GitHub仓库的根目录中创建一个新的`.travis.yml`文件。这个文件应该看起来像这样：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This basically configures Travis to start an Android emulator; it waits for
    the emulator to start and then runs the `npm` commands. You can learn what these
    `npm` commands do from your `package.json`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上配置了Travis启动一个Android模拟器；它等待模拟器启动，然后运行`npm`命令。你可以从你的`package.json`中了解这些`npm`命令的作用。
- en: 'So, in your root application, that is, the package.json file of your app, you
    want to add the following keys:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在你的根应用中，即你的应用的`package.json`文件，你想要添加以下键：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With these two changes, Travis will automatically test every single pull request
    to your repository, which then means that you can code, and Travis will continually
    do all your unit testing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个更改之后，Travis将自动测试你仓库中的每一个pull request，这意味着你可以编码，而Travis将不断进行所有单元测试。
- en: 'In addition, you can change the preceding Travis configuration file to add
    Appium to be installed and run also just by doing the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以通过以下方式更改先前的Travis配置文件，以便添加Appium进行安装和运行：
- en: Adding the Appium dependencies to your main `package.json` dependencies.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Appium依赖项添加到你的主`package.json`依赖项中。
- en: Adding to the root of your project a `appium.capabilities.json` that has a `travisAndroid`
    key.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的项目根目录中添加一个具有`travisAndroid`键的`appium.capabilities.json`。
- en: Adding the `&& npm run appium --runType=travisAndroid` to your `travistest` key
    in the `package.json` file.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`package.json`文件中将`&& npm run appium --runType=travisAndroid`添加到`travistest`键中。
- en: GitHub already has the integration with Travis built-in, so it is simple to
    document and get it running. If you use Gitlabs, you can use the Gitlabs CI system
    to do testing. In addition, you can use the repository hooks to use a wide number
    of other continuous integration services that are available. Finally, you can
    also develop your own.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 已经内置了与 Travis 的集成，因此记录文档并启动它非常简单。如果你使用 Gitlabs，你可以使用 Gitlabs CI 系统进行测试。此外，你还可以使用仓库钩子来使用大量可用的其他持续集成服务。最后，你也可以开发自己的服务。
- en: Summary
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to install and run Appium, how to build complete
    end-to-end tests and how to use the testing frameworks to test your screens fully.
    In addition, we covered how important it is to automate the running of the unit
    testing and Appium, and one way you can do so is using Travis and GitHub.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何安装和运行 Appium，如何构建完整的端到端测试，以及如何使用测试框架全面测试你的屏幕。此外，我们还讨论了自动化单元测试和 Appium
    运行的重要性，以及你可以使用 Travis 和 GitHub 来实现这一目标的一种方法。
- en: Now hang on tight--we will make a quick turn and start discussing how to deploy
    and use Webpack to optimize your builds for release.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请系好安全带——我们将快速转向，开始讨论如何部署和使用 Webpack 来优化你的构建以供发布。
