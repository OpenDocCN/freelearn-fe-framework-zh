- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Styling React Apps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式化React应用
- en: Learning Objectives
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够做到以下几件事情：
- en: Style JSX elements via inline style assignments or with the help of CSS classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过内联样式赋值或使用CSS类来样式化JSX元素
- en: Set inline and class styles, both statically and dynamically or conditionally
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置内联和类样式，无论是静态的、动态的还是条件性的
- en: Build reusable components that allow for style customization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建可重用的组件，允许进行样式定制
- en: Utilize CSS Modules to scope styles to components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用CSS模块将样式限制在组件范围内
- en: Understand the core idea behind `styled-components` , a third-party CSS-in-JS
    library
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`styled-components`这个第三方CSS-in-JS库背后的核心思想
- en: Use Tailwind CSS to style React apps
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Tailwind CSS来样式化React应用
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: React.js is a frontend JavaScript library. This means that it’s all about building
    (web) user interfaces and handling user interaction.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: React.js是一个前端JavaScript库。这意味着它全部关于构建（Web）用户界面和处理用户交互。
- en: Up to this point, this book has extensively explored how React can be used to
    add interactivity to a web app. State, event handling, and dynamic content are
    key concepts relating to this.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书已经广泛探讨了如何使用React为Web应用添加交互性。状态、事件处理和动态内容是与这一主题相关的关键概念。
- en: Of course, websites and web apps are not just about interactivity. You could
    build an amazing web app that offers interactive and engaging features, and yet
    it may still be unpopular if it lacks appealing visuals. Presentation is key,
    and the web is no exception.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，网站和Web应用不仅仅是关于交互性的。你可以构建一个提供交互性和吸引人的功能的出色Web应用，但如果它缺乏吸引人的视觉元素，它可能仍然不受欢迎。展示是关键，网络也不例外。
- en: Therefore, like all other apps and websites, React apps and websites need proper
    styling, and when working with web technologies, **Cascading Style Sheets** (
    **CSS** ) is the language of choice.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，就像所有其他应用和网站一样，React应用和网站需要适当的样式，并且在处理Web技术时，**层叠样式表**（**CSS**）是首选的语言。
- en: However, this book is not about CSS. It won’t explain or teach you how to use
    CSS, as there are dedicated, better resources for that (e.g., the free CSS guides
    at [https://developer.mozilla.org/en-US/docs/Learn/CSS](https://developer.mozilla.org/en-US/docs/Learn/CSS)
    ). But this chapter will teach you how to combine CSS code with JSX and React
    concepts, such as state and props. You will learn how to add styles to your JSX
    elements, style custom components, and make those components’ styles configurable.
    This chapter will also teach you how to set styles dynamically and conditionally
    and explore popular third-party libraries, like styled-components and Tailwind
    CSS, that can be used for styling.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这本书不是关于CSS的。它不会解释或教你如何使用CSS，因为已经有针对这一主题的专用、更好的资源（例如，[https://developer.mozilla.org/en-US/docs/Learn/CSS](https://developer.mozilla.org/en-US/docs/Learn/CSS)
    上的免费CSS指南）。但本章将教你如何将CSS代码与JSX和React概念（如状态和属性）结合使用。你将学习如何为你的JSX元素添加样式，样式自定义组件，并使这些组件的样式可配置。本章还将教你如何动态和条件性地设置样式，并探索流行的第三方库，如styled-components和Tailwind
    CSS，它们可用于样式化。
- en: How Does Styling Work in React Apps?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React应用中的样式是如何工作的？
- en: Up to this point, the apps and examples presented in this book have only had
    minimal styling. But they at least had some basic styling, rather than no styling
    at all.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中展示的应用和示例都只有最基本的美化。但至少它们有一些基本的美化，而不是完全没有美化。
- en: But how was that styling added? How can styles be added to user interface elements
    (such as DOM elements) when using React?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，那种样式是如何添加的？在使用React时，如何将样式添加到用户界面元素（如DOM元素）中？
- en: The short answer is, “Just as you would to non-React apps.” You can add CSS
    styles and classes to JSX elements just as you would to regular HTML elements.
    And in your CSS code, you can use all the features and selectors you know from
    CSS. There are no React-specific changes you have to make when writing CSS code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的回答是，“就像你对非React应用所做的那样。”你可以像对常规HTML元素一样，将CSS样式和类添加到JSX元素中。在你的CSS代码中，你可以使用你从CSS中知道的所有特性和选择器。在编写CSS代码时，你不需要做出任何特定的React更改。
- en: The code examples used so far (i.e., the activities or other examples hosted
    on GitHub) always used regular CSS styling, with the help of CSS selectors, to
    apply some basic styles to the final user interface. Those CSS rules were defined
    in an `index.css` file, which is part of every newly created React project (when
    using Vite for project creation, as shown in *Chapter 1* , *React – What and Why*
    ).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止使用的代码示例（即GitHub上托管的活动或其他示例）总是使用常规CSS样式，借助CSS选择器，将一些基本样式应用到最终用户界面。这些CSS规则定义在一个`index.css`文件中，它是每个新创建的React项目的一部分（当使用Vite创建项目时，如*第一章*，*React
    – 什么和为什么*所示）。
- en: 'For example, here’s the `index.css` file used in *Activity 5.2* of the previous
    chapter ( *Chapter 5* , *Rendering Lists and Conditional Content* ):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是前一章（*第五章*，*渲染列表和条件内容*）的*活动5.2*中使用的`index.css`文件：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The actual CSS code and its meaning are not important (as mentioned, this book
    is not about CSS). However, what is important is the fact that this code contains
    no JavaScript or React code at all. As mentioned, the CSS code you write is totally
    independent of the fact that you’re using React in your app.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的CSS代码及其含义并不重要（如前所述，这本书不是关于CSS的）。然而，重要的是这个代码完全不包含JavaScript或React代码。如前所述，你编写的CSS代码完全独立于你在应用中使用React的事实。
- en: The more interesting question is, how is that code actually applied to the rendered
    web page? How is it imported into that page?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的问题是，这些代码实际上是如何应用到渲染的网页上的？它是如何导入到该页面的？
- en: 'Normally, you would expect style file imports (via `<link href="…">` ) inside
    of the HTML files that are served. Since React apps are typically about building
    **single-page applications** (see *Chapter 1* , *React – What and Why* ), you
    only have one HTML file—the `index.html` file. But if you inspect that file, you
    won’t find any `<link href="…">` import that would point to the `index.css` file
    (only some other `<link>` element that imports a favicon), as you can see in the
    following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会在提供的HTML文件内部期望找到样式文件导入（通过`<link href="…">`）。由于React应用通常是关于构建**单页应用**（见*第一章*，*React
    – 什么和为什么*），你只有一个HTML文件——`index.html`文件。但如果你检查该文件，你不会找到任何指向`index.css`文件的`<link
    href="…">`导入（只有一些其他导入favicon的`<link>`元素），如下面的截图所示：
- en: '![img](img/B31339_06_01.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_06_01.png)'
- en: 'Figure 6.1: The <head> section of the index.html file contains no <link> import
    that points to the index.css file'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：`index.html`文件的`<head>`部分不包含指向index.css文件的`<link>`导入
- en: How are the styles defined in `index.css` imported and applied then?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`index.css`中的样式是如何导入并应用的？
- en: 'You find an `import` statement in the root entry file (this is the `main.jsx`
    file in projects generated via `Vite` ):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在根入口文件（这是通过`Vite`生成的项目中的`main.jsx`文件）中，你可以找到一个`import`语句：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `import './index.css';` statement leads to the CSS file being imported and
    the defined CSS code being applied to the rendered web page.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`import ''./index.css'';`语句导致CSS文件被导入，并且定义的CSS代码被应用到渲染的网页上。'
- en: It is worth noting that this is not standard JavaScript behavior. You can’t
    import CSS files into JavaScript—at least, not if you’re just using vanilla JavaScript.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这不是标准的JavaScript行为。你不能将CSS文件导入到JavaScript中——至少，如果你只是使用纯JavaScript的话。
- en: CSS works this way in React apps because the code is transpiled before it’s
    loaded into the browser. Therefore, you won’t find that `import` statement in
    the final JavaScript code that’s executed in the browser. Instead, during the
    **transpilation process** , the transpiler identifies the CSS import, removes
    it from the JavaScript file, and injects the CSS code (or an appropriate link
    to the potentially bundled and optimized CSS file) into the `index.html` file.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在React应用中，CSS以这种方式工作，因为代码在加载到浏览器之前会被转换。因此，你不会在浏览器中执行的最终JavaScript代码中找到那个`import`语句。相反，在**转换过程**中，转换器识别CSS导入，将其从JavaScript文件中移除，并将CSS代码（或指向可能捆绑和优化的CSS文件的适当链接）注入到`index.html`文件中。
- en: You can confirm this by inspecting the rendered **Document Object Model** (
    **DOM** ) content of the loaded web page in the browser.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在浏览器中检查加载的网页的渲染**文档对象模型**（**DOM**）内容来确认这一点。
- en: 'To do so, select the **Elements** tab in developer tools in Chrome, as shown
    below:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请选择Chrome开发者工具中的**元素**选项卡，如下所示：
- en: '![img](img/B31339_06_02.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_06_02.png)'
- en: 'Figure 6.2: Injected CSS <style> elements can be found in the DOM at runtime'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：在运行时DOM中可以找到注入的CSS `<style>` 元素
- en: You can define any styles you want to apply to your HTML elements (that is,
    to your JSX elements in your components) directly inside of the `index.css` file,
    or in any other CSS files that are imported by the `index.css` file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接在`index.css`文件中，或在由`index.css`文件导入的任何其他CSS文件中定义要应用于你的HTML元素（即你的组件中的JSX元素）的任何样式。
- en: You could also add additional CSS import statements, pointing at other CSS files,
    to the `main.jsx` file or any other JavaScript files (including files that store
    components). However, it is important to keep in mind that CSS styles are always
    global. No matter whether you import a CSS file into `main.jsx` or a component-specific
    JavaScript file, the styles defined in that CSS file will be applied globally.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将额外的CSS导入语句添加到`main.jsx`文件或任何其他JavaScript文件（包括存储组件的文件）中。然而，重要的是要记住，CSS样式始终是全局的。无论你是否将CSS文件导入到`main.jsx`或组件特定的JavaScript文件中，该CSS文件中定义的样式都将应用于全局。
- en: That means that styles defined in a `goal-list.css` file, which may be imported
    in a `GoalList.jsx` file, could still affect JSX elements defined in a totally
    different component. Later in this chapter, you will learn about techniques that
    allow you to prevent accidental style clashes and implement style scoping.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在`goal-list.css`文件中定义的样式，即使可能被导入到`GoalList.jsx`文件中，也可能影响在完全不同的组件中定义的JSX元素。在本章的后面部分，你将了解到一些技术，这些技术可以帮助你防止意外的样式冲突并实现样式作用域。
- en: Using Inline Styles
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内联样式
- en: You can use CSS files to define global CSS styles and use different CSS selectors
    to target different JSX elements (or groups of elements).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用CSS文件来定义全局CSS样式，并使用不同的CSS选择器来针对不同的JSX元素（或元素组）。
- en: But even though it’s typically discouraged, you can also set inline styles directly
    on JSX elements via the `style` prop.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通常不建议这样做，但你也可以通过`style`属性直接在JSX元素上设置内联样式。
- en: '**Note**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'If you’re wondering why inline styles are discouraged, the following discussion
    on Stack Overflow provides many arguments against inline styles: [https://stackoverflow.com/questions/2612483/whats-so-bad-about-in-line-css](https://stackoverflow.com/questions/2612483/whats-so-bad-about-in-line-css)
    .'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么不建议使用内联样式，Stack Overflow上的以下讨论提供了许多反对内联样式的论点：[https://stackoverflow.com/questions/2612483/whats-so-bad-about-in-line-css](https://stackoverflow.com/questions/2612483/whats-so-bad-about-in-line-css)。
- en: 'Setting inline styles in JSX code works like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSX代码中设置内联样式的方式如下：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, the `style` prop is added to the `<li>` element (all JSX elements
    support the `style` prop), and both the `color` and `size` properties of the text
    are set via CSS.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，向`<li>`元素（所有JSX元素都支持`style`属性）添加了`style`属性，并通过CSS设置了文本的`color`和`size`属性。
- en: 'This approach differs from what you would use to set inline styles when working
    with just HTML (instead of JSX). When using plain HTML, you would set inline styles
    like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与仅使用HTML（而不是JSX）设置内联样式的方法不同。当使用纯HTML时，你会这样设置内联样式：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The difference is that the `style` prop expects to receive a JavaScript object
    that contains the style settings—not a plain string. This is something that must
    be kept in mind, since, as mentioned previously, inline styles typically aren’t
    used that often.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于，`style`属性期望接收一个包含样式设置的JavaScript对象——而不是一个普通的字符串。这是必须记住的，因为，如前所述，内联样式通常不常用。
- en: Since the `style` object is an object and not a plain string, it is passed as
    a value between curly braces—just as an array, a number, or any other non-string
    value would have to be set between curly braces (anything between double or single
    quotes is treated as a string value). Therefore, it’s worth noting that the preceding
    example does not use any kind of special “double curly-braces” syntax and, instead,
    uses one pair of curly braces to surround the non-string value and another pair
    to surround the object data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`style`对象是一个对象而不是一个普通字符串，它被作为值放在大括号之间——就像数组、数字或任何其他非字符串值一样必须在大括号之间设置（双引号或单引号之间的任何内容都被视为字符串值）。因此，值得注意的是，前面的例子没有使用任何特殊的“双大括号”语法，而是使用一对大括号来包围非字符串值，另一对大括号来包围对象数据。
- en: Inside the `style` object, any CSS style properties supported by the underlying
    DOM element can be set. The property names are those defined for the HTML element
    (i.e., the same CSS property names you could target and set with vanilla JavaScript,
    when mutating an HTML element).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`style`对象内部，可以设置底层DOM元素支持的任何CSS样式属性。属性名称是针对HTML元素定义的（即，与你可以用纯JavaScript针对和设置的目标和设置的CSS属性名称相同），当修改HTML元素时。
- en: When setting styles in JavaScript code (as with the `style` prop shown above),
    JavaScript CSS property names have to be used. Those names are similar to the
    CSS property names you would use in CSS code but not quite the same. Differences
    occur for property names that consist of multiple words (e.g., `font-size` ).
    When targeting such properties in JavaScript, camelCase notation must be used
    ( `fontSize` instead of `font-size` ), as JavaScript properties cannot contain
    dashes. Alternatively, you could wrap the property name with quotes ( `'font-size'`
    ).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当在JavaScript代码中设置样式（如上面显示的`style`属性）时，必须使用JavaScript CSS属性名称。这些名称与你在CSS代码中使用的CSS属性名称相似，但并不完全相同。当针对由多个单词组成的属性名称（例如，`font-size`）时，会出现差异。在JavaScript中针对此类属性时，必须使用驼峰式命名法（`fontSize`而不是`font-size`），因为JavaScript属性不能包含破折号。或者，你也可以用引号包裹属性名称（`'font-size'`）。
- en: '**Note**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'You can find more information about the HTML element style property and JavaScript
    CSS property names here: [https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style)
    .'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到有关HTML元素样式属性和JavaScript CSS属性名称的更多信息：[https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style)。
- en: Setting Styles via CSS Classes
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过CSS类设置样式
- en: As mentioned, using inline styles is typically discouraged, and therefore, CSS
    styles defined in CSS files (or between `<style>` tags in the document `<head>`
    section) are preferred.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，通常不建议使用内联样式，因此，在CSS文件中定义的CSS样式（或在文档`<head>`部分的`<style>`标签之间）更受欢迎。
- en: 'In those CSS code blocks, you can write regular CSS code and use CSS selectors
    to apply CSS styles to certain elements. You could, for example, style all `<li>`
    elements on a page (no matter which component may have rendered them) like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些CSS代码块中，你可以编写常规CSS代码并使用CSS选择器将CSS样式应用于特定元素。例如，你可以这样设置页面上的所有`<li>`元素（无论哪个组件可能渲染了它们）的样式：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As long as this code gets added to the page (because the CSS file in which it
    is defined is imported into `main.jsx` , for instance), the styling will be applied.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 只要此代码被添加到页面中（因为定义它的CSS文件被导入到`main.jsx`等），样式就会被应用。
- en: 'Quite frequently, developers aim to target specific elements or groups of elements.
    Instead of applying some style to all `<li>` elements on a page, the goal could
    be to only target the `<li>` elements that are part of a specific list. Consider
    this HTML structure that’s rendered to the page (it may be split across multiple
    components, but this doesn’t matter here):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者经常试图针对特定的元素或元素组。而不是将某些样式应用于页面上的所有`<li>`元素，目标可能是仅针对属于特定列表的`<li>`元素。考虑以下渲染到页面的HTML结构（它可能分布在多个组件中，但这在这里并不重要）：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, the navigation list items will most likely not receive the
    same styling as the `course goal` list items (and vice versa).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，导航列表项很可能不会收到与`course goal`列表项相同的样式（反之亦然）。
- en: 'Typically, this problem would be solved with the help of CSS classes and the
    class selector. You could adjust the HTML code like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这个问题会借助CSS类和类选择器来解决。你可以像这样调整HTML代码：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following CSS code would then only target the course goal list items but
    not the navigation list items:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下CSS代码只会针对课程目标列表项，而不会针对导航列表项：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This approach almost works in React apps as well.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在React应用中也几乎同样适用。
- en: 'However, if you try to add CSS classes to JSX elements, as shown in the previous
    example, you will face a warning in the browser’s developer tools:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你尝试向JSX元素添加CSS类，如前一个示例所示，你将在浏览器开发者工具中遇到警告：
- en: '![A white background with red text  Description automatically generated](img/B31339_06_03.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![带有红色文字的白色背景，描述自动生成](img/B31339_06_03.png)'
- en: 'Figure 6.3: A warning output by React'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：React输出的警告
- en: 'As illustrated in the preceding figure, you should not add `class` as a prop
    and, instead, use `className` . Indeed, if you swap `class` for `className` as
    a prop name, the warning will disappear, and the class CSS styles will be applied.
    Hence, the proper JSX code looks like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，你不应该将`class`作为属性添加，而应该使用`className`。实际上，如果你将`class`替换为`className`作为属性名，警告就会消失，并且类CSS样式将被应用。因此，正确的JSX代码如下：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: But why is React suggesting you use `className` instead of `class` ?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么React建议你使用`className`而不是`class`？
- en: It’s similar to using `htmlFor` instead of `for` when working with `<label>`
    objects (as discussed in *Chapter 4* , *Working with Events and State* ). Just
    like `for` , `class` is a keyword in JavaScript, and therefore, `className` is
    used as a prop name instead.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这与在处理`<label>`对象时使用`htmlFor`而不是`for`类似（如第4章*处理事件和状态*中讨论的）。就像`for`一样，`class`是JavaScript中的一个关键字，因此，`className`被用作属性名。
- en: Setting Styles Dynamically
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态设置样式
- en: With inline styles and CSS classes (and global CSS styles in general), there
    are various ways of applying styles to elements. Thus far, all examples have shown
    static styles—that is, styles that will never change once a page has been loaded.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内联样式和CSS类（以及通常的全局CSS样式），有各种方法可以将样式应用于元素。到目前为止，所有示例都显示了静态样式——也就是说，一旦页面加载完成，样式就不会改变。
- en: 'But while most page elements don’t change their styles after a page is loaded,
    you also typically have some elements that should be styled dynamically or conditionally.
    Here are some examples:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数页面元素在页面加载后不会改变它们的样式，但你通常也有一些元素应该动态或条件性地设置样式。以下是一些示例：
- en: A to-do app where different to-do priorities receive different colors
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个待办事项应用，其中不同的待办事项优先级会收到不同的颜色
- en: An input form where invalid form elements should be highlighted following an
    unsuccessful form submission
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个输入表单，其中无效的表单元素应在表单提交失败后突出显示
- en: A web-based game where players can choose colors for their avatars
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个基于Web的游戏，玩家可以为他们的头像选择颜色
- en: In such cases, applying static styles is not enough, and dynamic styles should
    be used instead. Setting styles dynamically is straightforward. Again, it’s just
    about applying the key React concepts covered earlier (most importantly, those
    regarding the setting of dynamic values from *Chapter 2* , *Understanding React
    Components and JSX* , and *Chapter 4* , *Working with Events and State* ).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，应用静态样式是不够的，应该使用动态样式。动态设置样式很简单。再次强调，这只是应用之前覆盖的React关键概念（最重要的是第2章*理解React组件和JSX*和第4章*处理事件和状态*中关于设置动态值的内容）。
- en: 'Here’s an example where the color of a paragraph is set dynamically to the
    color that a user enters into an input field:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，其中段落的颜色会动态设置为用户在输入字段中输入的颜色：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The text entered in the `<input>` field is stored in the `enteredColor` state.
    This state is then used to set the `color` CSS property of the `<p>` element dynamically.
    This is achieved by passing a `style` object, with the `color` property set to
    the `enteredColor` value as a value to the `style` prop of the `<p>` element.
    The text color of the paragraph is, therefore, set dynamically to the value entered
    by the user (assuming that users enter valid CSS color values into the `<input>`
    field).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<input>`字段中输入的文本存储在`enteredColor`状态中。然后使用此状态动态设置`<p>`元素的`color` CSS属性。这是通过传递一个`style`对象来实现的，其中`color`属性设置为`enteredColor`的值，作为`<p>`元素的`style`属性的值。因此，段落的文本颜色会动态设置为用户输入的值（假设用户将有效的CSS颜色值输入到`<input>`字段中）。
- en: 'You’re not limited to inline styles; CSS classes can also be set dynamically,
    as in the following snippet:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅限于内联样式；CSS类也可以动态设置，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this example, the `chosenPriority` state will alternate between `low-prio`
    and `high-prio` , depending on the drop-down selection. The state value is then
    output as text inside the paragraph and is also used as a dynamic CSS class name,
    applied to the `<p>` element. For this to have any visual effect, there must,
    of course, be `low-prio` and `high-prio` CSS classes defined in some CSS file
    or `<style>` block. For example, consider the following code in `index.css` :'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`chosenPriority`状态将在`low-prio`和`high-prio`之间交替，取决于下拉选择。然后状态值作为段落内的文本输出，也用作动态CSS类名，应用于`<p>`元素。当然，为了产生任何视觉效果，必须在某个CSS文件或`<style>`块中定义`low-prio`和`high-prio`
    CSS类。例如，考虑以下`index.css`中的代码：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Conditional Styles
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件样式
- en: Closely related to **dynamic styles** are **conditional styles** . In fact,
    ultimately, they are really just a special case of dynamic styles. In the previous
    examples, inline style values and class names were set as equal to values chosen
    or entered by the user.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与**动态样式**密切相关的是**条件样式**。实际上，它们最终只是动态样式的特殊案例。在先前的例子中，内联样式值和类名被设置为等于用户选择或输入的值。
- en: 'However, you can also derive styles or class names dynamically based on different
    conditions, as shown here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你也可以根据不同的条件动态地派生样式或类名，如下所示：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, a wrapper component around the standard `<input>` element is
    built. (For more information about wrapper components, see *Chapter 3* , *Components
    and Props* .) The main purpose of this wrapper component is to set some default
    styles for the wrapped `<input>` element. The **wrapper component** is built to
    provide a pre-styled input element that can be used anywhere in the app. Indeed,
    providing pre-styled elements is one of the most common and popular use cases
    for building wrapper components.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，围绕标准`<input>`元素构建了一个包装组件。（有关包装组件的更多信息，请参阅*第3章*，*组件和属性*。）这个包装组件的主要目的是为包装的`<input>`元素设置一些默认样式。**包装组件**被构建为提供可以用于应用中任何位置的预样式输入元素。实际上，提供预样式元素是构建包装组件最常见和最受欢迎的使用场景之一。
- en: In this concrete example, the default styles are applied using CSS classes.
    If the `isValid` prop value is `true` and the value of the `isRecommended` prop
    is `false` , the `input-default` CSS class will be applied to the `<input>` element,
    since neither of the two `if` statements become active.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个具体的例子中，默认样式是通过CSS类应用的。如果`isValid`属性值为`true`且`isRecommended`属性值为`false`，则`input-default`
    CSS类将应用于`<input>`元素，因为两个`if`语句都没有激活。
- en: If `isRecommended` is `true` (but `isValid` is `false` ), the `input-recommended`
    CSS class would be applied. If `isValid` is `false` , the `input-invalid` class
    is added instead. Of course, the CSS classes must be defined in some imported
    CSS files (for example, in `index.css` ).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`isRecommended`为`true`（但`isValid`为`false`），则应用`input-recommended` CSS类。如果`isValid`为`false`，则添加`input-invalid`类。当然，CSS类必须在某些导入的CSS文件中定义（例如，在`index.css`中）。
- en: 'Inline styles could be set in a similar way, as shown in the following snippet:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 内联样式也可以以类似的方式设置，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, the background color of the `<input>` element is set conditionally,
    based on the values received via the `isValid` and `isRecommended` props.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`<input>`元素的背景颜色是基于通过`isValid`和`isRecommended`属性接收到的值有条件地设置的。
- en: Combining Multiple Dynamic CSS Classes
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合多个动态CSS类
- en: In previous examples, a maximum of one CSS class was set dynamically at a time.
    However, it’s not uncommon to encounter scenarios where multiple dynamically derived
    CSS classes should be merged and added to an element.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的例子中，一次只能动态设置一个CSS类。然而，遇到需要合并和添加到元素中的多个动态派生CSS类的情况并不少见。
- en: 'Consider the following example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, two CSS classes are added to `<p>` by simply combining them into one
    string. Alternatively, you could directly add a string with the two classes like
    this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，通过简单地将它们组合成一个字符串，就可以向`<p>`元素添加两个CSS类。或者，你也可以直接添加包含两个类的字符串，如下所示：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This code will work, but what if the goal is to also add another class name
    to the list of classes, based on the `isImportant` prop value (which is ignored
    in the preceding example)?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将能正常工作，但如果目标是基于`isImportant`属性值（在先前的例子中被忽略）向类列表中添加另一个类名呢？
- en: 'Replacing the default list of classes is easy, as you have learned:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 替换默认的类列表很容易，正如你所学到的：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: But what if the goal is not to replace the list of default classes? What if
    `text-important` should be added as a class to `<p>` , in addition to `text-default`
    and `text-expl` ?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果目标不是替换默认类列表呢？如果`text-important`应该作为类添加到`<p>`元素中，除了`text-default`和`text-expl`呢？
- en: 'The `className` prop expects to receive a string value, so passing an array
    of classes isn’t an option. However, you can simply merge multiple classes into
    one string, and there are a couple of different ways to do that:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`className`属性期望接收一个字符串值，因此传递一个类数组不是一种选择。然而，你可以简单地合并多个类成一个字符串，并且有几种不同的方法可以做到这一点：'
- en: 'String concatenation:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串连接：
- en: '[PRE17]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Using a template literal:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板字符串：
- en: '[PRE18]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Joining an array:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组连接：
- en: '[PRE19]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These examples could all be used inside the `if` statement ( `if (isImportant)`
    ) to conditionally add the `text-important` class, based on the `isImportant`
    prop value. All three approaches, as well as variations of these approaches, will
    work because all these approaches produce a string. In general, any approach that
    yields a string can be used to generate values for `className` .
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例都可以在`if`语句（`if (isImportant)`）中使用，根据`isImportant`属性值有条件地添加`text-important`类。所有这三种方法以及这些方法的变体都将工作，因为所有这些方法都产生一个字符串。一般来说，任何产生字符串的方法都可以用来生成`className`的值。
- en: Merging Multiple Inline Style Objects
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并多个内联样式对象
- en: When working with inline styles, instead of CSS classes, you can also merge
    multiple style objects. The main difference is that you don’t produce a string
    with all values but, rather, an object with all combined style values.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理内联样式时，除了CSS类，您还可以合并多个样式对象。主要区别在于您不生成包含所有值的字符串，而是一个包含所有组合样式值的对象。
- en: 'This can be achieved by using standard JavaScript techniques to merge multiple
    objects into one object. The most popular technique involves using the **spread
    operator** , as shown in this example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用标准的JavaScript技术将多个对象合并为一个对象来实现。最流行的技术涉及使用**扩展运算符**，如下例所示：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, you will observe that `defaultStyle` is an object with a `color` property.
    If `isImportant` is `true` , it’s replaced with an object that contains all the
    properties it had before (via the spread operator, `...defaultStyle` ) as well
    as the `backgroundColor` property.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您会注意到`defaultStyle`是一个具有`color`属性的对象。如果`isImportant`为`true`，它将被替换为一个包含所有先前属性（通过扩展运算符`...defaultStyle`）以及`backgroundColor`属性的对象。
- en: '**Note**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: For more information on the function and use of the spread operator, see *Chapter
    5* , *Rendering Lists and Conditional Content* .
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 关于扩展运算符的功能和使用，请参阅*第5章*，*渲染列表和条件内容*。
- en: Building Components with Customizable Styles
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用可定制样式构建组件
- en: As you are aware by now, components can be reused. This is supported by the
    fact that they can be configured via props. The same component can be used in
    different places on a page with different configurations to yield a different
    output.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如您现在所知，组件可以被重用。这一点得到了支持，因为它们可以通过属性进行配置。同一个组件可以在页面的不同位置使用不同的配置来产生不同的输出。
- en: Since styles can be set both statically and dynamically, you can also make the
    styling of your components customizable. The preceding examples already show such
    customization in action; for example, the `isImportant` prop was used in the previous
    example to conditionally add a `red` background color to a paragraph. The `ExplanationText`
    component therefore already allows indirect style customization via the `isImportant`
    prop.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于样式可以静态和动态设置，您也可以使组件的样式可定制。前面的示例已经展示了这种定制的作用；例如，在先前的示例中，`isImportant`属性被用来有条件地向段落添加红色背景色。因此，`ExplanationText`组件已经通过`isImportant`属性允许间接的样式定制。
- en: 'Besides this form of customization, you could also build components that accept
    props already holding CSS class names or style objects. For example, the following
    wrapper component accepts a `className` prop that is merged with a default CSS
    class ( `btn` ):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这种形式的定制外，您还可以构建接受已持有CSS类名或样式对象的属性的组件。例如，以下包装组件接受一个`className`属性，该属性与默认CSS类（`btn`）合并：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This component could be used in another component in the following way:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件可以用以下方式在另一个组件中使用：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If used like this, the final `<button>` element would receive both the `btn`
    as well as `btn-alert` classes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这样使用，最终的`<button>`元素将同时接收`btn`和`btn-alert`类。
- en: You don’t have to use `className` as a prop name; any name can be used, since
    it’s your component. However, it’s not a bad idea to use `className` because you
    can then keep your mental model of setting CSS classes via `className` (for built-in
    components, you will not have that choice).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必使用`className`作为属性名；任何名称都可以使用，因为它是您的组件。然而，使用`className`并不是一个坏主意，因为这样您可以保持通过`className`设置CSS类的心理模型（对于内置组件，您将没有这样的选择）。
- en: 'Instead of merging prop values with default CSS class names or style objects,
    you can overwrite default values. This allows you to build components that come
    with some styling out of the box without enforcing that styling:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与将属性值与默认CSS类名或样式对象合并不同，您可以覆盖默认值。这允许您构建一些带有默认样式的组件，而无需强制使用该样式：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can see how all the different concepts covered throughout this book are
    coming together here: props allow customization, values can be set, swapped, and
    changed dynamically and conditionally, and therefore, highly reusable and configurable
    components can be built.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，本书中涵盖的所有不同概念是如何在这里汇聚的：属性允许定制，值可以设置、交换和动态条件地更改，因此可以构建高度可重用和可配置的组件。
- en: Customization with Fixed Configuration Options
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用固定配置选项进行定制
- en: Besides exposing props such as `className` or `style` , which are merged with
    other classes or styles defined inside a component function, you can also build
    components that apply different styles or class names based on other prop values.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了暴露`className`或`style`等属性，这些属性会与组件函数内部定义的其他类或样式合并外，你还可以构建基于其他属性值应用不同样式或类名的组件。
- en: This has been shown in the previous examples where props such as `isValid` or
    `isImportant` were used to apply certain styles conditionally. This way of applying
    styles could, therefore, be called “indirect styling” (although this is not an
    official term).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这在前面的示例中已经展示过，其中使用了`isValid`或`isImportant`等属性来有条件地应用某些样式。因此，这种应用样式的做法可以被称为“间接样式”（尽管这不是一个官方术语）。
- en: Both approaches can shine in different circumstances. For wrapper components,
    for example, accepting `className` or `style` props (which can be merged with
    other styles inside the component) enables the component to be used just like
    a built-in component (e.g., like the component it wraps). Indirect styling, on
    the other hand, can be very useful if you want to build components that provide
    a couple of pre-defined variations.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法在不同的环境中都能发挥作用。例如，对于包装组件，接受`className`或`style`属性（这些可以在组件内部与其他样式合并）使得组件可以像内置组件一样使用（例如，像它所包装的组件）。另一方面，如果你想要构建提供一些预定义变体的组件，间接样式可能非常有用。
- en: A good example is a text box that provides two built-in themes that can be selected
    via a specific prop.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是，一个文本框提供了两个内置主题，可以通过特定的属性进行选择。
- en: '![A screenshot of a phone  Description automatically generated](img/B31339_06_04.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![手机的截图  自动生成的描述](img/B31339_06_04.png)'
- en: 'Figure 6.4: A TextBox is styled based on the value of the “mode” prop'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：根据“mode”属性的值对TextBox进行样式化
- en: 'The code for the `TextBox` component could look like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextBox`组件的代码可能看起来像这样：'
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This `TextBox` component always yields a paragraph element. If the `mode` prop
    is set to any value other than `'alert'` or `'info'` , the paragraph doesn’t receive
    any special styling. But if `mode` is equal to `'alert'` or `'info'` , specific
    CSS classes are added to the paragraph.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`TextBox`组件始终返回一个段落元素。如果`mode`属性设置为除`'alert'`或`'info'`之外的任何值，则段落不会接收任何特殊样式。但如果`mode`等于`'alert'`或`'info'`，则会向段落添加特定的CSS类。
- en: This component, therefore, doesn’t allow direct styling via some `className`
    or `style` prop that would be merged, but it does offer different variations or
    themes that can be set with the help of a specific prop (the `mode` prop in this
    case).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个组件不允许通过某些`className`或`style`属性进行直接样式化，但它确实提供了不同的变体或主题，可以通过特定的属性（在这种情况下是`mode`属性）来设置。
- en: The Problem with Unscoped Styles
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未限定样式的问题
- en: 'If you consider the different examples you’ve so far dealt with in this chapter,
    there’s one specific use case that occurs quite frequently: styles are relevant
    to a specific component only.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑本章中迄今为止处理的不同示例，那么有一个特定的用例出现得相当频繁：样式仅与特定组件相关。
- en: For example, in the `TextBox` component in the previous section, `'box-alert'`
    and `'box-info'` are CSS classes that are likely only relevant for this specific
    component and its markup. If any other JSX element in the app had a `'box-alert'`
    class applied to it (even though that might be unlikely), it probably shouldn’t
    be styled the same as the `<p>` element in the `TextBox` component.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前一节的`TextBox`组件中，`'box-alert'`和`'box-info'`是可能只与这个特定组件及其标记相关的CSS类。如果应用了`'box-alert'`类的任何其他JSX元素（尽管这不太可能），那么它可能不应该与`TextBox`组件中的`<p>`元素以相同的样式进行样式化。
- en: Styles from different components could clash with each other and overwrite each
    other because styles are not scoped (i.e., restricted) to a specific component.
    CSS styles are always global, unless inline styles are used (which is discouraged,
    as mentioned earlier).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 来自不同组件的样式可能会相互冲突并覆盖彼此，因为样式不是限定（即，限制）在特定组件内的。CSS样式始终是全局的，除非使用内联样式（如前所述，这是不推荐的）。
- en: When working with component-based libraries such as React, this lack of scoping
    is a common issue. It’s easy to write conflicting styles as app sizes and complexities
    grow (or, in other words, as more and more components are added to the code base
    of a React app).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s why various solutions for this problem have been developed by members
    of the React community. The following are three of the most popular solutions:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: CSS Modules (supported out of the box in React projects created with Vite)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styled components (using a third-party library called `styled-components` )
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tailwind CSS (a popular CSS library)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scoped Styles with CSS Modules
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CSS Modules** is the name for an approach where individual CSS files are
    linked to specific JavaScript files and the components defined in those files.
    This link is established by transforming CSS class names, such that every JavaScript
    file receives its own, unique CSS class names. This transformation is performed
    automatically as part of the code build workflow. Therefore, a given project setup
    must support CSS Modules by performing the described CSS class name transformation.
    Projects created via Vite support CSS Modules by default.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a program  Description automatically generated](img/B31339_06_05.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: CSS modules in action. CSS class names are transformed into unique
    names during the build workflow'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS Modules are enabled and used by naming CSS files in a very specific and
    clearly defined way: `<anything>.module.css` . `<anything>` is any value of your
    choosing, but the `.module` part in front of the file extension is required, as
    it signals (to the project build workflow) that this CSS file should be transformed
    according to the CSS Modules approach.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, CSS files named like this must be imported into components in a
    specific way:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This `import` syntax is different from the `import` syntax shown at the beginning
    of this section for `index.css` :'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When importing CSS files as shown in the second snippet, the CSS code is simply
    merged into the `index.html` file and applied globally. When using CSS Modules
    instead (first code snippet), the CSS class names defined in the imported CSS
    file are transformed such that they are unique for the JS file that imports the
    CSS file.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Since the CSS class names are transformed and are therefore no longer equal
    to the class names you defined in the CSS file, you import an object ( `classes`
    , in the preceding example) from the CSS file. This object exposes all transformed
    CSS class names under keys that match the CSS class names defined by you in the
    CSS file. The values of those properties are the transformed class names (as strings).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a complete example, starting with a component-specific CSS file ( `TextBox.module.css`
    ):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The JavaScript file ( `TextBox.jsx` ) for the component to which the CSS code
    should belong looks like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Note**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: The full example code can also be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/examples/01-css-modules-intro](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/examples/01-css-modules-intro)
    .
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'If you inspect the rendered text element in the browser developer tools, you
    will note that the CSS class name applied to the `<p>` element does not match
    the class name specified in the `TextBox.module.css` file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_06_06.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: CSS class name transforms because of CSS Modules usage'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: This is the case because, as described previously, the class name was transformed
    during the build process to be unique. If any other CSS file, imported by another
    JavaScript file, were to define a class with the same name ( `info` in this case),
    the styles would not clash and not overwrite each other, as the interfering class
    names would be transformed into different class names before being applied to
    the DOM elements.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, in the example provided on GitHub, you can find another `info` CSS
    class defined in the `index.css` file:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That file is still imported into `main.jsx` , and hence its styles are applied
    globally to the entire document. Nonetheless, the `.info` styles clearly aren’t
    affecting `<p>` rendered by `TextBox` (there is no red border around the text
    box in *Figure 6.6* ). They aren’t affecting that element because it doesn’t have
    an `info` class anymore; the class was renamed `_info_1mtzh_8` by the build workflow
    (although the name you see will differ, as it contains a random element).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: It’s also worth noting that the `index.css` file is still imported into `main.jsx`
    , as shown at the beginning of this chapter. The `import` statement is not changed
    to `import classes from './index.css';` , nor is the CSS file called `index.module.css`
    .
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Note, too, that you can use CSS Modules to scope styles to components and can
    also mix the usage of CSS Modules with regular CSS files, which are imported into
    JavaScript files without using CSS Modules (i.e., without scoping).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: One other important aspect of using CSS Modules is that you can only use CSS
    class selectors (that is, in your `.module.css` files) because CSS Modules rely
    on CSS classes. You can write selectors that combine classes with other selectors,
    such as `input.invalid` , but you can’t add selectors that don’t use classes at
    all in your `.module.css` files. For example, `input { ... }` or `#some-id { ...
    }` selectors wouldn’t work here.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: CSS Modules are a very popular way of scoping styles to (React) components,
    and they will be used throughout many examples for the rest of this book.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The styled-components Library
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `styled-components` library is a so-called **CSS-in-JS** solution. CSS-in-JS
    solutions aim to remove the separation between CSS code and JavaScript code by
    merging them into the same file. Component styles would be defined right next
    to the component logic. It comes down to personal preference whether you favor
    separation (as enforced by using CSS files) or keeping the two languages close
    to each other.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `styled-components` is a third-party library that’s not pre-installed
    in newly created React projects, you have to install this library as a first step
    if you want to use it. This can be done via `npm` (which was automatically installed
    together with Node.js in *Chapter 1* , *React – What and Why* ):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `styled-components` library essentially provides wrapper components around
    all built-in core components (as in, around `p` , `a` , `button` , `input` , and
    so on). It exposes all these wrapper components as **tagged templates** —JavaScript
    functions that aren’t called like regular functions but, instead, are executed
    by adding backticks (a template literal) right after the function name, for example,
    `` doSomething`text data` `` .
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Tagged templates can be confusing when you see them for the first time, especially
    since it’s a JavaScript feature that isn’t used too frequently. Chances are high
    that you haven’t worked with them too often. It’s even more likely that you have
    never built a custom-tagged template before. You can learn more about tagged templates
    in this excellent documentation on MDN at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates)
    .
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a component that imports and uses `styled-components` to set and scope
    styling:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This component isn’t a component function but, rather, a constant that stores
    the value returned by executing the `styled.button` tagged template. That tagged
    template returns a component function that yields a `<button>` element. The styles
    passed via the tagged template (i.e., inside the template literal) are applied
    to that returned button element. You can see this if you inspect the button in
    the browser’s developer tools:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer program  Description automatically generated](img/B31339_06_07.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: The rendered button element receives the defined component styles'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 6.7* , you can also see how the `styled-components` library applies
    your styles to the element. It extracts your style definitions from the tagged
    template string and injects them into a `<style>` element in the `<head>` section
    of the document. The injected styles are then applied via a class selector that
    is generated (and named) by the `styled-components` library. Finally, the automatically
    generated CSS class name is added to the element ( `<button>` , in this case)
    by the library.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The components exposed by the `styled-components` library spread any extra props
    you pass to a component onto the wrapped core component. In addition, any content
    inserted between the opening and closing tags is also inserted between the tags
    of the wrapped component.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s why the `Button` created previously can be used like this without adding
    any extra logic to it:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Note**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The complete example code can be found on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/examples/02-styled-components-intro](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/examples/02-styled-components-intro)
    .
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: You can do more with the `styled-components` library. For example, you can set
    styles dynamically and conditionally. This book is not primarily about that library
    though. It’s just one of many alternatives to CSS Modules. Therefore, it is recommended
    that you explore the official `styled-components` documentation if you want to
    learn more, which you can find at [https://styled-components.com/](https://styled-components.com/)
    .
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Use the Tailwind CSS Library for Styling
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scoping styles with the help of CSS modules or the `styled-component` library
    is a very useful and popular technique.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: But no matter which approach you use, you must write all the CSS code on your
    own. Hence you, of course, need to know CSS.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: But what if you don’t? Or if you simply don’t like writing CSS code?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: In that case, you can use one of the many CSS libraries and frameworks available—for
    example, the **Bootstrap** CSS framework or the **Tailwind CSS** library. Tailwind
    has become a very popular styling solution for React projects (for developers
    who don’t want to write custom CSS code).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that Tailwind is a CSS library that’s actually not focused on React.
    Instead, you can use Tailwind in any web project to style your HTML code—no matter
    which JavaScript library or framework (if any) is being used there.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'But Tailwind is a common choice for React apps, since its core philosophy plays
    nicely with the component-focused model of React. This is because when using Tailwind
    for styling, you typically compose overall styles by applying many small CSS classes
    to individual JSX elements:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When first encountering code that uses Tailwind CSS, the long list of CSS classes
    may look intimidating and chaotic. But when working with Tailwind, you typically
    quickly get used to it.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, because Tailwind’s approach offers many advantages:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need to learn CSS in detail—understanding the Tailwind syntax, which
    is less complex than writing CSS from scratch, suffices.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You compose styles by combining CSS classes—similar to how you compose user
    interfaces from components in React.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don’t have to switch between JSX and CSS files.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling changes can be applied and tested very quickly.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see in the above code snippet, the core idea of Tailwind essentially
    is that it provides many combinable CSS classes that each do very little. For
    example, the `bg-gray-200` class just sets the background color to a certain shade
    of gray, and nothing else.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it’s the combination of all those CSS classes that achieves a certain
    look, and Tailwind CSS offers many such classes that you may use and combine.
    You find a full list in the official documentation at [https://tailwindcss.com/docs/utility-first](https://tailwindcss.com/docs/utility-first)
    .
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with Tailwind in React projects, you can therefore build React
    components not just to reuse logic or JSX markup but also styles:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this example, the `Item` component is built to reuse the Tailwind styles
    applied to the `<li>` element.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'You also find this example project on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/examples/03-tailwind](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/examples/03-tailwind)
    .'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'If you plan on using Tailwind in your React project, you must install it as
    a first step. Detailed installation instructions for a broad variety of project
    setups can be found in the official documentation—this includes instructions for
    Vite projects: [https://tailwindcss.com/docs/guides/vite](https://tailwindcss.com/docs/guides/vite)
    .'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: The installation process is not as simple as just importing a CSS file but nonetheless
    relatively straightforward. It does require a couple of setup steps, since Tailwind
    needs to plug into the project build process to analyze your JSX files and produce
    CSS code that contains all used class names and style rules.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Besides offering many utility styles that can be combined, Tailwind also provides
    plenty of customization opportunities and configuration options. Therefore, entire
    books could be written about Tailwind alone. However, that’s, of course, not what
    this book is about. Therefore, if you’re interested in using Tailwind in your
    React projects, Tailwind’s official documentation (see the links above) is a great
    place to learn more.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Using Other CSS or JavaScript Styling Libraries and Frameworks
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Obviously, it comes down to personal preferences whether you want to write custom
    CSS code (potentially scoped with CSS Modules or `styled-components` ) or whether
    you want to work with third-party CSS libraries, like Tailwind CSS. There is no
    wrong or right choice, and you’ll see all kinds of approaches being used in different
    React projects.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'The options presented in this chapter are also not exhaustive—there are other
    kinds of CSS and JavaScript libraries, too:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Utility libraries that solve very specific CSS problems—independent of the fact
    that you’re using them in a React project (for example, `Animate.css` , which
    helps to add animations)
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other CSS frameworks or libraries that provide a broad variety of pre-built
    CSS classes that can be applied to elements to quickly achieve a certain look
    (for example, **Bootstrap** )
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript libraries that help with styling or specific styling aspects like
    animations (for example, **Framer Motion** )
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some libraries and frameworks have React-specific extensions or specifically
    support React, but that does not mean that you can’t use libraries that don’t
    have this.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Summary and Key Takeaways
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Standard CSS can be used to style React components and JSX elements.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS files are typically directly imported into JavaScript files, which is possible
    thanks to the project build process, which extracts the CSS code and injects it
    into the document (the HTML file).
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an alternative to global CSS styles (with `element` , `id` , `class` , or
    other selectors), inline styles can be used to apply styling to JSX elements.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using CSS classes for styling, you must use the `className` prop (not `class`
    ).
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styles can be set statically and dynamically or conditionally with the same
    syntax that is used to inject other dynamic or conditional values into JSX code—a
    pair of curly braces.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highly configurable custom components can be built by setting styles (or CSS
    classes) based on prop values, or by merging received prop values with other styles
    or class name strings.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using just CSS, clashing CSS class names can be a problem.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS Modules solve this problem by transforming class names into unique names
    (per component) as part of the build workflow.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, third-party libraries such as `styled-components` can be used.
    This library is a CSS-in-JS library that also has the advantage or disadvantage
    (depending on your preference) of removing the separation between JS and CSS code.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tailwind CSS is another popular styling choice for React projects—it’s a library
    that allows you to compose styles by combining many small CSS classes.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other CSS libraries or frameworks can be used as well; React does not impose
    any restrictions regarding that.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s Next?
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With styling covered, you’re now able to build not just functional but also
    visually appealing user interfaces. Even if you often work with dedicated web
    designers or CSS experts, you still typically need to be able to set and assign
    styles (dynamically) that are delivered to you.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: With styling being a general concept that is relatively independent of React,
    the next chapter will dive back into more React-specific features and topics.
    You will learn about **portals** and **refs** , which are two key concepts that
    are built into React. You will discover which problems are solved by these concepts
    and how the two features are used.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Test Your Knowledge!
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your knowledge of the concepts covered in this chapter by answering the
    following questions. You can then compare your answers to examples that can be
    found here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/06-styling/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/06-styling/exercises/questions-answers.md)
    .'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: With which language are styles for React components defined?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which important difference, compared to projects without React, has to be kept
    in mind when it comes to assigning classes to elements?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can styles be assigned dynamically and conditionally?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does “Scoping” mean in the context of styling?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How could styles be scoped to components? Briefly explain at least one concept
    that helps with scoping.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply What You Learned
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are now not only able to build interactive user interfaces but also style
    those user interface elements in engaging ways. You can set and change those styles
    dynamically or based on conditions.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will find two activities that allow you to apply your newly
    gained knowledge in combination with what you learned in previous chapters.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 6.1: Providing Input Validity Feedback upon Form Submission'
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you will build a basic form that allows users to enter an
    email address and a password. The provided input of each input field is validated,
    and the validation result is stored (for each individual input field).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this activity is to add some general form styling and some conditional
    styling that becomes active once an invalid form has been submitted. The exact
    styles are up to you, but to highlight invalid input fields, the background color
    of the affected input field must be changed, as well as its border color and the
    text color of the related label.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Create a new React project and add a form component to it.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output the form component in the project’s root component.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the form component, output a form that contains two input fields: one for
    entering an email address and one for entering a password.'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add labels to the input fields.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the entered values and check their validity upon form submission (you
    can be creative in forming your own validation logic).
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick appropriate CSS classes from the provided `index.css` file (alternatively,
    you can write your own classes as well).
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add them to the invalid input fields and their labels once invalid values have
    been submitted.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final user interface should look like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a login screen  Description automatically generated](img/B31339_06_08.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: The final user interface with invalid input values highlighted
    in red'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Since this book is not about CSS and you may not be a CSS expert, you can use
    the `index.css` file from the solution and focus on the React logic to apply appropriate
    CSS classes to JSX elements.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: All code files used for this activity, and a full solution, can be found at
    [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/activities/practice-1)
    .
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 6.2: Using CSS Modules for Style Scoping'
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you’ll take the final app built in *Activity 6.1* and adjust
    it to use CSS Modules. The goal is to migrate all component-specific styles into
    a component-specific CSS file, which uses CSS Modules for style scoping.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: The final user interface therefore looks the same as it did in the previous
    activity. However, the styles will be scoped to the `Form` component so that clashing
    class names won’t interfere with styling.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Finish the previous activity or take the finished code from GitHub.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the styles belonging specifically to the `Form` component and move
    them into a new, component-specific CSS file.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change CSS selectors to class name selectors and add classes to JSX elements
    as needed (this is because CSS Modules require class name selectors).
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the component-specific CSS file as explained throughout this chapter and
    assign the CSS classes to the appropriate JSX elements.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: All code files used for this activity, and a full solution, can be found at
    [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/activities/practice-2](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/activities/practice-2)
    .
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
