<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Getting Started with Angular Components and Directives</h1>
                </header>
            
            <article>
                
<p>At this point, we're already familiar with the core building blocks that Angular provides for the development of single-page applications and the relations between them. However, we've touched only the surface by introducing the general idea behind Angular's concepts and the basic syntax used for their definition. In this chapter, we'll take a deep dive into Angular's components and directives.</p>
<p>In the following sections, we will cover these topics:</p>
<ul>
<li>Enforcing separation of concerns with the building blocks that Angular provides</li>
<li>The appropriate use of directives or components when interacting with the DOM</li>
<li>Exploring built-in directives and developing custom ones</li>
<li>An in-depth look at components and their templates</li>
<li>Content projection</li>
<li>View children versus content children</li>
<li>The component's life cycle</li>
<li>Using template references</li>
<li>Configuring Angular's change detection</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The "Hello world!" application in Angular</h1>
                </header>
            
            <article>
                
<p>Now, let's build our first <kbd>"Hello world!"</kbd> application in Angular and TypeScript. Before we start, let's set up our environment!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up our environment</h1>
                </header>
            
            <article>
                
<p>The core team of Angular developed a brand new CLI tool for Angular, which allows us to bootstrap our applications with a few commands. Although we will introduce it in the final chapter, until then, in order to boost our learning experience, we will use the code located at <a href="https://github.com/mgechev/switching-to-angular">https://github.com/mgechev/switching-to-angular</a>. This repository includes all the examples in this book, in one big application. It has all the required dependencies declared in <kbd>package.json</kbd>, the definition of basic gulp tasks, such as the development server, the transpilation of our TypeScript code to ECMAScript 5, and live-reload.</p>
<div class="packt_infobox">The code for this book is based on Angular Seed (<a href="https://github.com/mgechev/angular-seed">https://github.com/mgechev/angular-seed</a>). Although the project provides a solid foundation, it may introduce a tooling overhead for Angular and TypeScript beginners. Once we get familiar with the fundamentals of Angular, I'd strongly recommend that you use the official Angular CLI as a starting point for your first project, available at <a href="https://github.com/angular/angular-cli">https://github.com/angular/angular-cli</a>.</div>
<p>In order to set up the <kbd>switching-to-angular</kbd> project, you'll need Git, Node.js v6.x.x or newer, and <kbd>npm</kbd>, up and running on your computer. If you have an older version of Node.js installed, I recommend that you take a look at nvm (the Node.js version manager, which is available at <a href="https://github.com/creationix/nvm">https://github.com/creationix/nvm</a>) or n (<a href="https://www.npmjs.com/package/n"><span class="URLPACKT">https://www.npmjs.com/package/n</span></a>). Using these tools, you'll be able to have multiple versions of Node.js on your machine and switch between them with a single command via the command line.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing the sample project repository</h1>
                </header>
            
            <article>
                
<p>Let's start by setting up the <kbd>switching-to-angular</kbd> project. Open your terminal and enter the following commands:</p>
<pre><strong># Will clone the repository and save it to directory called
# switching-to-angular
$ git clone https://github.com/mgechev/switching-to-angular.git
$ cd switching-to-angular
$ npm install</strong></pre>
<p>The first line will clone the <kbd><span>switching-to-angular</span></kbd> project into a directory called <kbd><span>switching-to-angular</span></kbd>; after that, we enter into that directory.</p>
<p>The last step before being able to run the seed project is to install all the required dependencies using <kbd>npm</kbd>. This step may take a while depending on your internet connection, so be patient and do not interrupt it. If you encounter any problems, do not hesitate to raise the issues at <a href="https://github.com/mgechev/switching-to-angular/issues">https://github.com/mgechev/switching-to-angular/issues</a>.</p>
<p>The last step left is to start the development server. For this, run the following command:</p>
<pre><strong>$ npm start </strong></pre>
<p>When the process of the transpilation is completed, your browser will automatically open the <kbd>http://localhost:5555/dist/dev</kbd> URL. You should now see a view similar to what is shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="357" width="622" src="assets/25fcdd91-0dce-41a0-a4b8-7b3973291b24.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 1</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Angular and TypeScript</h1>
                </header>
            
            <article>
                
<p>Now, let's play around with the files we already have. Navigate to the <kbd>app/ch5/hello-world</kbd> directory inside <kbd>switching-to-angular</kbd>. Then, open <kbd>app.ts</kbd> and replace its content with the following snippet:</p>
<pre>// ch5/hello-world/app.ts 
 
import {Component, NgModule} from '@angular/core';
import {BrowserModule} from '@angular/platform-browser';
import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';

@Component({
  selector: 'my-app',
  templateUrl: './app.html'
})
class App {
  target: string;
  constructor() {
    this.target = 'world';
  }
}

@NgModule({
  declarations: [App],
  imports: [BrowserModule],
  bootstrap: [App],
})
class AppModule {}

platformBrowserDynamic().bootstrapModule(AppModule);</pre>
<p>Let's take a look at the code line by line:</p>
<pre>import {Component, NgModule} from '@angular/core';
import {BrowserModule} from '@angular/platform-browser';
import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';</pre>
<p>Initially, we import the <kbd>@Component</kbd> and <kbd>@NgModule</kbd> decorators from the <kbd>@angular/core</kbd> module, <kbd>BrowserModule</kbd> from <kbd>@angular/platform-browser</kbd> and the <kbd>platformBrowserDynamic</kbd> object from <kbd>@angular/platform-browser-dynamic</kbd>. Later, we use <kbd>@Component</kbd> to decorate the <kbd>App</kbd> class. To the <kbd>@Component</kbd> decorator, we pass an object literal where we reference to an external template.</p>
<p>As the next step, we define the view of the component. However, note that in this case, we use <kbd>templateUrl</kbd> instead of simply inlining the template of the component.</p>
<p>Open <kbd>app.html</kbd> and replace the file's content with <kbd>&lt;h1&gt;Hello {{target}}!&lt;/h1&gt;</kbd>. Since we can use a template by both inlining it (with <kbd>template</kbd>) and setting its URL (<kbd>templateUrl</kbd>), in some sense, the API of the component is similar to that of the AngularJS directives.</p>
<p>In the last line of the snippet, we bootstrap the application by providing the root module.</p>
<p>Now, let's take a look at <kbd>index.html</kbd> in order to get a sense of what goes on when we start the application:</p>
<pre>&lt;!-- ch5/hello-world/index.html --&gt; 
&lt;!DOCTYPE html&gt; 
&lt;html lang="en"&gt; 
&lt;head&gt; 
  &lt;meta charset="utf-8"&gt; 
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; 
  &lt;title&gt;&lt;%= TITLE %&gt;&lt;/title&gt; 
  &lt;meta name="description" content=""&gt; 
  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; 
  &lt;!-- inject:css --&gt; 
  &lt;!-- endinject --&gt; 
&lt;/head&gt; 
&lt;body&gt; 
  &lt;my-app&gt;Loading...&lt;/my-app&gt; 
  &lt;!-- inject:js --&gt; 
  &lt;!-- endinject --&gt; 
  &lt;%= INIT %&gt; 
&lt;/body&gt; 
&lt;/html&gt; </pre>
<p>Note that inside the body of the page, we use the <kbd>my-app</kbd> element with content and a text node with the <kbd>"Loading..."</kbd> value. The <kbd>"Loading..."</kbd> label will be visible until the application gets bootstrapped and the main component gets rendered.</p>
<div class="mce-root packt_infobox">The <kbd>&lt;%= INIT %&gt;</kbd> and <kbd>&lt;-- inject:js...</kbd> template placeholders inject content that is specific to individual demos. They are not Angular specific, but instead, aim to prevent code duplications in the code samples attached to the book because of the shared structure between them. In order to see how this specific HTML file has been transformed, open <kbd>/dist/dev/ch5/hello-world/index.html</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Angular directives</h1>
                </header>
            
            <article>
                
<p>We have already built our simple <kbd>"Hello world!"</kbd> app. Now, let's start building something that is closer to a real-life application. By the end of this section, we'll have a simple application that lists a number of items we need to do and greets us at the header of the page.</p>
<p>Let's start by developing the root component. The two modifications from the preceding example that we need to make are renaming the <kbd>target</kbd> property to <kbd>name</kbd> and adding a list of <kbd>todos</kbd> to the controller definition of the component:</p>
<pre>// ch5/ng-for/detailed-syntax/app.ts 
 
import {Component, NgModule} from '@angular/core';
import {BrowserModule} from '@angular/platform-browser';
import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';

@Component({
  selector: 'app',
  templateUrl: './app.html',
})
class App {
  todos: string[];
  name: string;<br/>  constructor() {
    this.name = 'John';
    this.todos = ['Buy milk', 'Save the world'];
  }
}

@NgModule({
  declarations: [App],
  imports: [BrowserModule],
  bootstrap: [App],
})
class AppModule {}

platformBrowserDynamic().bootstrapModule(AppModule);</pre>
<p>The only thing that is left is updating the template in order to consume the provided data. We're already familiar with the <kbd>ng-repeat</kbd> directive from AngularJS. It allows us to loop over a list of items using a microsyntax, which is later interpreted by AngularJS.</p>
<p>However, the directive doesn't carry enough semantics, so it is hard to build tools that perform static code analysis and help us improve our development experience. Since the <kbd>ng-repeat</kbd> directive is quite useful, Angular kept the idea and improved it further in order to allow more sophisticated tooling by introducing further semantics on top of it. It allows IDEs and text editors to perform better static code analysis. Such support will prevent us from making typos in the code we write and allow us to have a smoother development experience.</p>
<p>In <kbd>app.html</kbd>, add the following content:</p>
<pre>&lt;!-- ch5/ng-for/detailed-syntax/app.html --&gt; 
 
&lt;h1&gt;Hello {{name}}!&lt;/h1&gt; 
&lt;p&gt; 
  Here's a list of the things you need to do: 
&lt;/p&gt; 
&lt;ul&gt; 
  &lt;ng-template ngFor let-todo [ngForOf]="todos"&gt; 
    &lt;li&gt;{{todo}}&lt;/li&gt; 
  &lt;/ng-template&gt; 
&lt;/ul&gt; </pre>
<div class="packt_infobox">Note that in Angular version 2.x.y, the framework was using <kbd>template</kbd> instead of <kbd>ng-template</kbd>. Since the semantics of the <kbd>template</kbd> element in the context of Angular is different compared to its semantics in the context of the HTML standard, in version 4 of Angular, the <kbd>template</kbd> element was deprecated and renamed to <kbd>ng-template</kbd>.</div>
<p>Now, after you refresh your browser, you should see the following result:</p>
<div class="CDPAlignCenter CDPAlign"><img height="174" width="288" src="assets/867d95db-0273-410b-b2f0-cf36cdc47979.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 2</div>
<p>So far, so good! The only new things left to expain in the last snippets are the attributes of the <kbd>ng-template</kbd> element that we're not familiar with, such as <kbd>ngFor</kbd>, <kbd>let-todo</kbd>, and <kbd>[ngForOf]</kbd>. Let's take a look at them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The ngFor directive</h1>
                </header>
            
            <article>
                
<p>The <kbd>ngFor</kbd> directive allows us to loop over a collection of items and not only does exactly what <kbd>ng-repeat</kbd> does in AngularJS, but also brings some extra semantics. Notice that the <kbd>ngForOf</kbd> attribute is surrounded by brackets. At first, these brackets may seem like invalid HTML. However, according to the HTML specification, their use is permitted in attribute names. The only thing the W3C validator will complain about is the fact that the <kbd>ng-template</kbd> element doesn't own such attributes; however, browsers won't have problems processing the markup.</p>
<p>The semantics behind these brackets is that the value of the attribute surrounded by them is an expression, which needs to be evaluated.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improved semantics of the directives syntax</h1>
                </header>
            
            <article>
                
<p>In <a href="ced71b5c-e25d-4781-8aab-81ef0a053b14.xhtml"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Get Going with Angular</em>, we mentioned the opportunity for improved tooling in Angular. A big issue in AngularJS is the different ways in which we can use directives. This requires an understanding of the attribute values, which can be literals, expressions, callbacks, or a microsyntax. In Angular, this problem is eliminated by introducing a few simple conventions that are built into the framework:</p>
<ul>
<li><kbd>propertyName="value"</kbd></li>
<li><kbd>[propertyName]="expression"</kbd></li>
<li><kbd>(eventName)="handler()"</kbd></li>
</ul>
<p>In the first line, the <kbd>propertyName</kbd> attribute accepts a string literal as a value. Angular will not process the attribute's value any further; it will use it the way it is set in the template.</p>
<p>The second syntax, <kbd>[propertyName]="expression"</kbd>, gives a hint to Angular that the value of the attributes should be handled as an expression. When Angular finds an attribute surrounded by brackets, it will interpret the expression in the context of the component associated with the template. In short, if we want to set a nonstring value or the result of an expression as value of a given property, we will need to use this syntax.</p>
<p>The previous example shows how we can bind to events. The semantics behind <kbd>(eventName)="handler()"</kbd> is that we want to invoke the <kbd>handler()</kbd> expression each time when an event with the <kbd>eventName</kbd> <span>name</span><span> </span><span>is triggered.</span></p>
<p>We will discuss more examples later in this chapter.</p>
<div class="mce-root packt_infobox">Angular provides alternative canonical syntax, which allows us to define the bindings of the elements without using brackets. For instance, the property binding can be expressed using the following code: <kbd><span>&lt;input [value]="foo"&gt;</span></kbd>. It can also be expressed using this: <kbd><span>&lt;input bind-value="foo"&gt;</span></kbd>. Similarly, we can express the event bindings with the following code: <kbd><span>&lt;button (click)="handle()"&gt;Click me&lt;/button&gt;</span></kbd>. They can also be expressed using this: <kbd><span>&lt;button on-click="handle()"&gt;Click me&lt;/button&gt;</span></kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Declaring variables inside a template</h1>
                </header>
            
            <article>
                
<p>The final thing left from the preceding template is the <kbd>let-todo</kbd> attribute. Using this syntax, we are telling Angular that we want to declare a new variable called <kbd>todo</kbd> and bind it to the individual items from the collection we get from the evaluation of the expression set as the value of <kbd>[ngForOf]</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using syntax sugar in templates</h1>
                </header>
            
            <article>
                
<p>Although the template syntax gives meaning of the code to the IDEs or text editors we use, it is quite verbose. Angular provides an alternative syntax, which will be desugared to the one shown in the preceding snippet.</p>
<p>There are a few Angular directives that require a <kbd>ng-template</kbd> element, for example, <kbd>ngForOf</kbd>, <kbd>ngIf</kbd>, and <kbd>ngSwitch</kbd>. Since such directives are used often, there's an alternative syntax for them. Instead of typing the entire <kbd>ng-template</kbd> element explicitly, we can simply prefix the directive with <kbd>*</kbd>. This will allow us to change our <kbd>ngForOf</kbd> directive syntax usage as follows:</p>
<pre><span>&lt;!-- ch5/ng-for/syntax-sugar/app.html --&gt; 
 
&lt;ul&gt; 
  &lt;li *ngFor="let todo of todos"&gt;{{todo}}&lt;/li&gt; 
&lt;/ul&gt; </span></pre>
<p>Later, this template will be desugared by Angular to the more verbose syntax described earlier. Since the less verbose syntax is easier to read and write, its use is considered as the best practice.</p>
<div class="packt_infobox">The <kbd>*</kbd> character allows us to remove the <kbd>ng-template</kbd> element and put the directive directly on the top-level child element of the <kbd>ng-template</kbd> element (in the previous example, the <kbd>li</kbd> list item).</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining Angular directives</h1>
                </header>
            
            <article>
                
<p>Now that we've built a simple Angular component, let's continue our journey by understanding the Angular directives.</p>
<p>Using Angular directives, we can apply different behavioral or structural changes over the DOM. In this example, we will build a simple tooltip directive.</p>
<p>In contrast to components, directives do not have templates. Another core difference between these two concepts is that the given HTML element may have only a single component, but multiple directives on it. In other words, directives augment the elements compared to components that are the actual elements in our views.</p>
<p><span>Angular's official style guide recommends using directives as attributes, prefixed with a namespace. Keeping this in mind, we will use the tooltip directive in the following way:</span></p>
<pre><span>&lt;div saTooltip="Hello world!"&gt;&lt;/div&gt; </span></pre>
<p>In the preceding snippet, we use the tooltip directive over the <kbd><span>div</span></kbd> element. As a namespace, its selector uses the <kbd><span>sa</span></kbd> string.</p>
<div class="packt_infobox">Since the focus of the book is an efficient and intuitive learning of Angular's concepts, the code snippets may not completely align with the Angular style guide. However, for production applications, following best practices is essential. You can find the official Angular style guide at <span class="URLPACKT"><a href="https://angular.io/styleguide">https://angular.io/styleguide</a></span>.</div>
<p>Now, let's develop a tooltip directive! Before implementing it, we need to import a couple of symbols from <kbd><span>@angular/core</span></kbd>. Open a new TypeScript file called <kbd><span>app.ts</span></kbd> and enter the following content; we'll fill the placeholders later:</p>
<pre><span>import {Directive, ElementRef, HostListener...} from '@angular/core'; </span></pre>
<p>In the preceding line, we import the following definitions:</p>
<ul>
<li><kbd><span>ElementRef</span></kbd>: This allows us to inject the element reference (we're not limited to the DOM only) to the host element of the directive. In the sample usage of the preceding tooltip, as <kbd>ElementRef</kbd>, we will get an Angular wrapper of the <kbd><span>div</span></kbd> element, which holds the <kbd><span>saTooltip</span></kbd> attribute.</li>
<li><kbd><span>Directive</span></kbd>: This decorator allows us to add the metadata required for the new directives we define.</li>
<li><kbd><span>HostListener(eventname)</span></kbd>: This is a method decorator that accepts an event name as an argument. During initialization of the directive, Angular will add the decorated method as an event handler for the <kbd><span>eventname</span></kbd> events fired by the host element.</li>
</ul>
<p>Let's look at the implementation of the directive:</p>
<pre><span>// ch5/tooltip/app.ts 
 
@Directive({
  selector: '[saTooltip]'
})
export class Tooltip {
  @Input() saTooltip:string;

  constructor(private el: ElementRef, private overlay: Overlay) {
    this.overlay.attach(el.nativeElement);
  }

  @HostListener('mouseenter')
  onMouseEnter() {
    this.overlay.open(this.el, this.saTooltip);
  }

  @HostListener('mouseleave')
  onMouseLeave() {
    this.overlay.close();
  }
}</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting the directive's inputs</h1>
                </header>
            
            <article>
                
<p>In the previous code example, we declare a directive with the <kbd><span>saTooltip</span></kbd> selector. Note that Angular's HTML compiler is case sensitive, which means that it will distinguish <kbd><span>[satooltip]</span></kbd> and <kbd><span>[saTooltip]</span></kbd> as different selectors. After that, we declare the input of the directive using the <kbd><span>@Input</span></kbd> decorator over the <kbd><span>saTooltip</span></kbd> property. The semantics behind this code is that we declare a property called <kbd><span>saTooltip</span></kbd> and bind it to the value of the result that we got from the evaluation of the expression passed to the <kbd><span>saTooltip</span></kbd> attribute.</p>
<p>The <kbd><span>@Input</span></kbd> decorator accepts a single argument, that is, the name of the attribute we want to bind to. In case we don't pass an argument, Angular will create a binding between the attribute with the same name as the property itself. We will explain the input and output concepts in detail later in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the directive's constructor</h1>
                </header>
            
            <article>
                
<p>The constructor declares two private properties: <kbd><span>el</span></kbd> of the <kbd><span>ElementRef</span></kbd> type and <kbd><span>overlay</span></kbd> of the <kbd><span>Overlay</span></kbd> type. The <kbd><span>Overlay</span></kbd> class implements logic to manage the overlays of the tooltips and will be injected using the DI mechanism of Angular. In order to declare it as available for injection, we will need to declare the top-level component in the following way:</p>
<pre><span>@Component({ 
  selector: 'app', 
  templateUrl: './app.html', 
  providers: [Overlay], 
  // ... 
}) 
class App {} </span></pre>
<div class="packt_infobox">We will take a look at the dependency injection mechanism of Angular in the next chapter, where we will explain the way in which we can declare the dependencies of our services, directives, and components. The implementation of the <kbd><span>Overlay</span></kbd> class is not important for the purpose of this chapter. However, if you're interested in it, you can find it at <kbd><span>ch5/tooltip/app.ts</span></kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Better encapsulation of directives with NgModules</h1>
                </header>
            
            <article>
                
<p>In order to make the tooltip directive available to the Angular's compiler, we will need to explicitly declare where we intend to use it. For instance, take a look at the <kbd><span>AppModule</span></kbd> class at <kbd><span>ch5/tooltip/app.ts</span></kbd>:</p>
<pre><span>@NgModule({
  declarations: [Tooltip, App],
  providers: [Overlay],
  imports: [BrowserModule],
  bootstrap: [App],
})
class AppModule {}</span></pre>
<p>To the <kbd><span>@NgModule</span></kbd> decorator, we pass an object literal that has the <kbd><span>declarations</span></kbd> property. This property contains a list of all the directives that will be available in all component subtrees with roots of any of the components listed in the <kbd><span>bootstrap</span></kbd> array. Another way to extend the list of available directives is to import a module. For instance, the <kbd><span>BrowserModule</span></kbd> module includes some very commonly used directives for the browser environment.</p>
<p>At first, it might seem annoying that you should explicitly declare all the directives that are used in your modules; however, this enforces better encapsulation. In AngularJS, all directives are in a global namespace. This means that all the directives defined in the application are accessible in all the templates. This brings in some problems, for example, name collision. In order to deal with this issue, we often introduce naming conventions, for instance, the <kbd><span>"ng-"</span></kbd> prefix of all the directives defined by AngularJS and <kbd><span>"ui-"</span></kbd> for all directives coming with the Angular UI.</p>
<p>Currently, by explicitly declaring all the directives that are used within a given module, we create a namespace specific to the individual components' subtrees (that is, the directives will be visible to the given root component and all of its successor components). Preventing name collisions is not the only benefit we get; it also helps us with better semantics of the code that we produce, since we're always aware of the directives accessible by the given component when we know in which module it's declared. We can find all the accessible directives of the given component by following the path from the component to the top module and taking the union of all the values of <kbd><span>declarations</span></kbd> and the declarations of <kbd><span>imports</span></kbd> of the modules. Given that components are extended from directives, we need to explicitly declare all the used components as well.</p>
<p>The <kbd><span>BrowserModule</span></kbd> module exports the built-in directives provided by Angular by exporting the <kbd><span>CommonModule</span></kbd> module that contains them. This list of predefined directives includes <kbd><span>NgClass</span></kbd>, <kbd><span>NgFor</span></kbd>, <kbd><span>NgIf</span></kbd>, <kbd><span>NgStyle</span></kbd>, <kbd><span>NgSwitch</span></kbd>, <kbd><span>NgSwitchWhen</span></kbd>, and <kbd><span>NgSwitchDefault</span></kbd>. Their names are quite self-explanatory; we'll take a look at how we can use some of them later in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using NgModules for declaring reusable components</h1>
                </header>
            
            <article>
                
<p class="p1">With NgModules, we can achieve a good degree of encapsulation. By explicitly exporting the public components, directives, pipes, and services, we can hide some of the implementation details of our modules. This way, we can implement reusable modules and expose only their public interface, and we do not reveal any low-level components to the user of the module.</p>
<p class="p1">In order to get a better idea, let's take a look at the following example:</p>
<pre><span>@Component(...)
class ZippyHeader {
  @Input() header: string;
}

@Component(...)
class Zippy {
  @Input() header: string;
  visible = true;
}

@Component(...)
class App {}</span></pre>
<p>In the preceding snippet, we declare the <kbd><span>Zippy</span></kbd>, <kbd><span>ZippyHeader</span></kbd>, and <kbd><span>App</span></kbd> components. <kbd><span>Zippy</span></kbd> is a component that has a header and a content; we can toggle the visibility of the content by clicking on the header. In the <kbd><span>ZippyHeader</span></kbd> component, we can implement some logic for handling the click events and/or visualizing the header. In the <kbd><span>App</span></kbd> component, we use the <kbd><span>Zippy</span></kbd> component by passing text for its header and content, like this:</p>
<pre>&lt;zippy header="Header"&gt;<br/>  &lt;content&gt;Lorem Ipsum&lt;/content&gt;<br/>&lt;/zippy&gt;</pre>
<p>In order to create a working Angular application, we will need to declare an <kbd>NgModule</kbd> decorator, which somehow references all the three components. We can approach this in two main ways:</p>
<ol>
<li>Declare a single <kbd>NgModule</kbd> decorator and include all the three components inside of its list of declarations.</li>
<li>Declare two NgModules:</li>
</ol>
<ul>
<li>One that declares the <kbd><span>Zippy</span></kbd> and <kbd><span>ZippyHeader</span></kbd> components, called <kbd><span>ZippyModule</span></kbd></li>
<li>Another one that declares the <kbd><span>App</span></kbd> component and imports the <kbd><span>ZippyModule</span></kbd> module</li>
</ul>
<p>The second approach has a couple of advantages: in <kbd><span>ZippyModule</span></kbd>, we can declare both <kbd><span>Zippy</span></kbd> and <kbd><span>ZippyHeader</span></kbd>, but we can export only <kbd><span>Zippy</span></kbd> because <kbd><span>ZippyHeader</span></kbd> is used internally, within <kbd><span>Zippy</span></kbd>, and we don't have to expose it to the user. By declaring the <kbd><span>ZippyModule</span></kbd> module, we can import it into other modules in our application where we want to reuse the <kbd><span>Zippy</span></kbd> component, or we can even extract it as a separate <kbd>npm</kbd> module and reuse it in multiple applications.</p>
<p>The second approach will look like this:</p>
<pre><span>// ch5/zippy/app.ts

@Component(...)
class ZippyHeader {...}

@Component(...)
class Zippy {...}

@NgModule({
</span>  declarations: [Zippy, ZippyHeader],
  exports: [Zippy]<span>
  imports: [CommonModule],
})
class ZippyModule {}

@Component(...)
class App {...}

@NgModule({
  imports: [BrowserModule, ZippyModule],
  declarations: [App],
  bootstrap: [App]
})
class AppModule {}

platformBrowserDynamic().bootstrapModule(AppModule);</span></pre>
<p>In the example, in the <kbd><span>ZippyModule</span></kbd><span> </span><span>module</span><span>, we declare both</span> <kbd>Zippy</kbd> <span>and</span> <kbd>ZippyHeader</kbd><span>, but we export only</span> <kbd>Zippy</kbd><span>. We also import the</span> <kbd>CommonModule</kbd><span> </span><span>module</span><span> </span><span>from</span> <kbd>@angular/common</kbd> <span>in order to reuse Angular's built-in directives (for instance,</span> <kbd>NgIf</kbd> <span>is exported by</span> <kbd>CommonModule</kbd><span>).</span></p>
<p>In the <kbd>AppModule</kbd> class, all we need to do is to import <kbd><span>ZippyModule</span></kbd>, and this way, we'll be able to use all of its exports and providers. We'll discuss providers further in the next chapter.</p>
<div class="packt_infobox">Note that good practices suggest that we should implement each individual component into a separate file. For the sake of simplicity in the examples for this book, we've violated this practice. For a list of best practices, visit <a href="https://angular.io/styleguide">https://angular.io/styleguide</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the custom element schema</h1>
                </header>
            
            <article>
                
<p>Now, let's suppose we want to add a timer to our page and reuse a web component that we have already built. In this case, our application can look something like this:</p>
<pre><span>//  ch5/custom-element/app.ts

import {Component, NgModule} from '@angular/core';
import {BrowserModule} from '@angular/platform-browser';
import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';

@Component({
  selector: 'my-app',
  template: `
    &lt;h1&gt;Hello {{name}}&lt;/h1&gt;
    The current timeout is &lt;simple-timer&gt;&lt;/simple-timer&gt;
  `
})
class App {
  name: string = 'John Doe';
}

@NgModule({
  imports: [BrowserModule],
  declarations: [App],
  bootstrap: [App]
})
class AppModule {}

platformBrowserDynamic().bootstrapModule(AppModule);</span></pre>
<p>Now, if we run our application, we'll get the following error:</p>
<div class="CDPAlignCenter CDPAlign"><img height="704" width="1884" class="image-border" src="assets/3c603b6a-fc1f-4084-a4c5-302a8d9c3e66.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 3</div>
<p>When Angular parses the template of the <kbd><span>App</span></kbd> component, it will find <kbd>&lt;simple-timer&gt;&lt;/simple-timer&gt;</kbd>. It is not an element defined by the HTML specification, and it doesn't match any of the selectors of the directives declared or imported in the <kbd>AppModule</kbd> class, so the framework will throw an error.</p>
<p>So, how we can use Angular with custom components? The solution is to use the <kbd><span>schemas</span></kbd> property of the object literal we pass to <kbd><span>@NgModule</span></kbd>:</p>
<pre><span>import {..., CUSTOM_ELEMENTS_SCHEMA} from '@angular/core';

//...

@NgModule({
  imports: [BrowserModule],
  declarations: [App],
  schemas: [CUSTOM_ELEMENTS_SCHEMA],
  bootstrap: [App]
})
class AppModule {}</span></pre>
<p>This way, we change the default schema that Angular uses for the validation of the elements and their attributes during parsing.</p>
<p>By default, the framework will throw an error if it finds an element that doesn't match the element selector of any of the imported or declared directive, or an element defined by the HTML5 spec.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating custom Angular components</h1>
                </header>
            
            <article>
                
<p>Now, let's build a simple to-do application in order to demonstrate the syntax to define components.</p>
<p>Our to-do items will have the following format:</p>
<pre><span>interface Todo { 
  completed: boolean; 
  label: string; 
} </span></pre>
<p>Let's start by importing everything we will need:</p>
<pre><span>import {Component, NgModule, ViewEncapsulation} from '@angular/core'; 
//...</span></pre>
<p>Now, let's declare the component and the metadata associated with it:</p>
<pre><span>@Component({ 
  selector: 'todo-app', 
  templateUrl: './app.html', 
  styles: [ 
    `ul li { 
      list-style: none; 
    } 
    .completed { 
      text-decoration: line-through; 
    }` 
  ], 
  encapsulation: ViewEncapsulation.Emulated 
}) </span></pre>
<p>Here, we specify that the selector of the <kbd><span>Todo</span></kbd> component will be the <kbd><span>todo-app</span></kbd> element. Later, we add the template URL, which points to the <kbd><span>app.html</span></kbd> file. After that, we use the <kbd><span>styles</span></kbd> property; this is the first time we encounter it. As we can guess from its name, it is used to set the styles of the component. Finally, we add <kbd>encapsulation</kbd>. This is a feature of Angular which allows us to have control over the scope of the defined styles.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing the component's view encapsulation</h1>
                </header>
            
            <article>
                
<p>As we know, Angular is inspired from web components, whose core feature is the shadow DOM. The shadow DOM allows us to encapsulate the styles of our web components without allowing them to leak outside the component's scope; Angular provides this feature. If we want Angular to use the shadow DOM, we can use <kbd><span>ViewEncapsulation.Native</span></kbd>. However, at the time of writing this book, the shadow DOM is not supported by all browsers; if we want to have the same level of encapsulation without using the shadow DOM, we can set the value of the encapsulation property to <kbd><span>ViewEncapsulation.Emulated</span></kbd>.</p>
<p>If we don't want to have any encapsulation at all, we can use <kbd><span>ViewEncapsulation.None</span></kbd>. By default, the renderer uses encapsulation of the <kbd><span>Emulated</span></kbd> type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the component's controllers</h1>
                </header>
            
            <article>
                
<p>Now, let's continue with the implementation of the application:</p>
<pre><span>// ch5/todo-app/app.ts 
class TodoCtrl { 
  todos: Todo[] = [{ 
    label: 'Buy milk', 
    completed: false 
  }, { 
    label: 'Save the world', 
    completed: false 
  }];
  name: string = 'John'; 

  addTodo(label) { ... }
 
  removeTodo(idx) { ... } 

  toggleCompletion(idx) { ... } 
} </span></pre>
<p>Here is part of the implementation of the controller associated with the template of the <kbd><span>Todo</span></kbd> application. Inside the class declaration, we initialized the <kbd><span>todos</span></kbd> property to an array with two <kbd><span>todo</span></kbd> items.</p>
<p>Now, let's update the template and render these items. Here's how this is done:</p>
<pre><span>&lt;ul&gt; 
  &lt;li *ngFor="let todo of todos; let index = index" [class.completed]="todo.completed"&gt; 
    &lt;input type="checkbox" [checked]="todo.completed" 
      (change)="toggleCompletion(index)"&gt; 
    {{todo.label}} 
  &lt;/li&gt; 
&lt;/ul&gt; </span></pre>
<p>In the template, we iterate over all the <kbd><span>todo</span></kbd> items inside the <kbd><span>todos</span></kbd> property of the controller. For each <kbd><span>todo</span></kbd> item, we create a checkbox that can <kbd><span>toggle</span></kbd> the completion status of the item; we also render the label of the <kbd><span>todo</span></kbd> item with the interpolation directive. Here, we can notice a syntax that was explained earlier:</p>
<ul>
<li>We bind to the change event of the checkbox using <kbd><span>(change)="statement"</span></kbd></li>
<li>We bind to the property of the <kbd><span>todo</span></kbd> item using <kbd><span>[checked]="expr"</span></kbd></li>
</ul>
<p>In order to have a line across the completed <kbd><span>todo</span></kbd> items, we bind to the <kbd><span>class.completed</span></kbd> property of the element. Since we want to apply the <kbd><span>completed</span></kbd> class to all the completed to-do items, we use <kbd><span>[class.completed]="todo.completed"</span></kbd>. This way, we declare that we want to apply the <kbd><span>completed</span></kbd> class depending on the value of the <kbd><span>todo.completed</span></kbd> expression. Here is how our application looks now:</p>
<div class="CDPAlignCenter CDPAlign"><img height="206" width="341" src="assets/35ff6a9c-2e44-4543-a093-5e02f6854ec3.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 4</div>
<div class="packt_infobox">Similar to the class binding syntax, Angular allows us to bind to the element's styles and attributes of the element. For instance, we can bind to the <kbd><span>colspan</span></kbd> attribute of <span>the </span><kbd>td</kbd><span> element </span><span>using the following line of code:</span> <kbd>&lt;td [attr.colspan]="colspanCount"&gt;&lt;/td&gt;</kbd><span>. </span><span>In the same way, we can bind to any</span> <kbd>style</kbd> <span>property using</span><span> </span><kbd>&lt;div [style.backgroundImage]="expression"&gt;&lt;/td&gt;</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling user actions</h1>
                </header>
            
            <article>
                
<p>So far, so good! Now, let's implement the <kbd><span>toggleCompletion</span></kbd> method. This method accepts the index of the to-do item as an argument:</p>
<pre><span>toggleCompletion(idx) { 
  let todo = this.todos[idx]; 
  todo.completed = !todo.completed; 
} </span></pre>
<p>In <kbd><span>toggleCompletion</span></kbd>, we simply toggle the <kbd><span>completed</span></kbd> Boolean value associated with the current to-do item, which is specified by the index passed as an argument to the method.</p>
<p>Now, let's add a text input to add the new to-do items:</p>
<pre><span>&lt;p&gt; 
  Add a new todo: 
  &lt;input #newtodo type="text"&gt; 
  &lt;button (click)="addTodo(newtodo.value); newtodo.value = ''"&gt; 
    Add 
  &lt;/button&gt; 
&lt;/p&gt; </span></pre>
<p>The input here defines a new variable called <kbd><span>newtodo</span></kbd>. Now, we can reference the input element using the <kbd><span>newtodo</span></kbd> identifier inside the template. Once the user clicks on the button, the <kbd><span>addTodo</span></kbd> method defined in the controller will be invoked with the value of the <kbd><span>newtodo</span></kbd> input as an argument. Inside the statement that is passed to the <kbd><span>(click)</span></kbd> attribute, we also reset the value of the <kbd><span>newtodo</span></kbd> input by setting it to the empty string.</p>
<div class="packt_infobox">Note that directly manipulating DOM elements is not considered as the best practice since it will prevent our component from running properly outside the browser environment. We will explain how we can migrate this application to web workers in <span class="ChapterrefPACKT"><a href="3ad730a8-f797-4fc1-b908-5a20eeffac23.xhtml"/><a href="b9d6c03a-d141-4201-afc6-339a41a38715.xhtml">Chapter 9</a>,</span> <em>Tooling and Development Experience</em><span class="ChapterrefPACKT">.</span></div>
<p>Now, let's define the <kbd><span>addTodo</span></kbd> method:</p>
<pre><span>addTodo(label) { 
  this.todos.push({ 
    label, 
    completed: false 
  }); 
} </span></pre>
<p>Inside it, we create a new to-do item using the object literal syntax.</p>
<p>The only thing left in our application is to implement the removal of the existing to-do items. Since it is quite similar to the functionality used to toggle the completion of the to-do items, I'll leave its implementation as a simple exercise for the reader.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using inputs and outputs</h1>
                </header>
            
            <article>
                
<p>By refactoring our <kbd><span>todo</span></kbd> application, we will demonstrate how we can take advantage of the directives' inputs and outputs:</p>
<div class="CDPAlignCenter CDPAlign"><img height="87" width="322" src="assets/9efdd73b-a5ad-4303-91d8-582bfabaf8de.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 5</div>
<p>We can think of the inputs as properties (or even arguments) that the given directive accepts. The outputs could be considered as events that it triggers. When we use a directive provided by a third-party library, mostly, we care about its inputs and outputs because they define its API.</p>
<p>Inputs refer to values that parameterize the directive's behavior and/or view. On the other hand, outputs refer to events that the directive fires when something special happens.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Determining the inputs and outputs</h1>
                </header>
            
            <article>
                
<p>Now, let's divide our monolithic to-do application into separate components that communicate with each other. In the following screenshot, you can see the individual components, which when composed together, implement the functionality of the application:</p>
<div class="CDPAlignCenter CDPAlign"><img height="241" width="334" src="assets/046b7f78-e340-444b-94ad-f23e18106427.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 6</div>
<p>The outer rectangle represents the entire <kbd><span>Todo</span></kbd> application. The first nested rectangle contains the component that is responsible for entering labels of the new to-do items, and the one below it lists the individual items stored in the root component.</p>
<p>Having said this, we can define these three components as follows:</p>
<ul>
<li><kbd><span>TodoApp</span></kbd>: This is responsible for maintaining the list of to-do items (adding new items and toggling the completion status).</li>
<li><kbd><span>InputBox</span></kbd>: <span>This is r</span>esponsible for entering the label of the new to-do item. It has the following inputs and outputs:
<ul>
<li>Inputs: a placeholder for the textbox and a label for the submit button</li>
<li>Outputs: the content of the textbox once the submit button is clicked</li>
</ul>
</li>
<li><kbd><span>TodoList</span></kbd>: This is responsible for rendering the individual to-do items. It has the following inputs and outputs:
<ul>
<li>Inputs: This is a list of to-do items</li>
<li>Outputs: This is the completion status of a to-do item</li>
</ul>
</li>
</ul>
<p>Now, let's begin with the implementation!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the inputs and outputs</h1>
                </header>
            
            <article>
                
<p>Let's use a bottom-up approach, and start with the <kbd><span>InputBox</span></kbd> component. Before that, we need a couple of imports from Angular's <kbd><span>@angular/core</span></kbd> package:</p>
<pre><span>import { 
  Component, 
  Input, 
  Output, 
  EventEmitter 
} from '@angular/core'; </span></pre>
<p>In this snippet, we import the <kbd><span>@Component</span></kbd>, <kbd><span>@Input</span></kbd>, and <kbd><span>@Output</span></kbd> decorators and the <kbd><span>EventEmitter</span></kbd> class. As their names state, <kbd><span>@Input</span></kbd> and <kbd><span>@Output</span></kbd> are used for declaring the directive's inputs and outputs. <kbd><span>EventEmitter</span></kbd> is a generic class (that is, accepting a type parameter), which when combined with properties decorated with <kbd><span>@Output</span></kbd>, allows them to <kbd>emit</kbd> values.</p>
<p>As the next step, let's take a look at the <kbd><span>InputBox</span></kbd> component's declaration:</p>
<pre><span>// ch5/inputs-outputs/app.ts 
 
@Component({ 
  selector: 'text-input', 
  template: ` 
    &lt;input #todoInput [placeholder]="inputPlaceholder"&gt; 
    &lt;button (click)="emitText(todoInput.value); 
                     todoInput.value = '';"&gt; 
      {{buttonLabel}} 
    &lt;/button&gt; 
  ` 
}) 
class InputBox {...} </span></pre>
<p>Note that in the template, we declare a text input and keep a reference to it using the <kbd><span>todoInput</span></kbd> identifier, and set its placeholder property to the value that we got from the evaluation of the <kbd><span>inputPlaceholder</span></kbd> identifier. This is the first input that we need to declare:</p>
<pre><span>class InputBox { 
  @Input() inputPlaceholder: string; 
  ... 
} </span></pre>
<p>Similarly, we declare the other input of the <kbd><span>buttonLabel</span></kbd> component, which we use as a value of the label of the button:</p>
<pre><span>class InputBox { 
  @Input() inputPlaceholder: string; 
  @Input() buttonLabel: string; 
  ... 
} </span></pre>
<p>In the preceding template, we bind the click event of the button to the <kbd><span>emitText(todoInput.value); todoInput.value = '';</span></kbd> statement. The <kbd><span>emitText</span></kbd> method should be defined in the component's controller; once it is invoked, it should <kbd>emit</kbd> the value of the text input. Here is how we can implement this behavior:</p>
<pre><span>class InputBox { 
  ... 
  @Output() inputText = new EventEmitter&lt;string&gt;();
 
  emitText(text: string) { 
    this.inputText.emit(text); 
  } 
} </span></pre>
<p>Initially, we declare an output called <kbd><span>inputText</span></kbd>. As its value, we set a new instance of the <kbd><span>EventEmitter&lt;string&gt;</span></kbd> type that we create.</p>
<div class="packt_infobox">Note that all the outputs of all the components need to be instances of <kbd><span>EventEmitter</span></kbd>.</div>
<p>Inside the <kbd><span>emitText</span></kbd> method, we invoke the <kbd><span>emit</span></kbd> method of  <kbd>inputText</kbd> and as its argument, we pass the value of the text input.</p>
<p>Now, let's define the <kbd><span>TodoList</span></kbd> component in the same fashion:</p>
<pre><span>@Component(...) 
class TodoList { 
  @Input() todos: Todo[]; 
  @Output() toggle = new EventEmitter&lt;Todo&gt;();
  toggleCompletion(index: number) { 
    let todo = this.todos[index]; 
    this.toggle.emit(todo); 
  } 
} </span></pre>
<p>Since the value of the object literal passed to the <kbd><span>@Component</span></kbd> decorator is not essential for the purpose of this section, we omitted it. The complete implementation of this example can be found at <kbd><span>ch5/inputs-outputs/app.ts</span></kbd>. Let's take a look at the body of the <kbd><span>TodoList</span></kbd> class. Similarly, to the <kbd><span>InputBox</span></kbd> component, we define the <kbd><span>todos</span></kbd> input. We also define the <kbd><span>toggle</span></kbd> output by declaring the <kbd><span>toggle</span></kbd> property, setting its value to a new instance of the <kbd><span>EventEmitter&lt;Todo&gt;</span></kbd> type and decorating it with the <kbd><span>@Output</span></kbd> decorator.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Passing inputs and consuming the outputs</h1>
                </header>
            
            <article>
                
<p>Now, let's combine the components we defined in the previous section and implement the complete application.</p>
<p>The last component we need to take a look at is <kbd><span>TodoApp</span></kbd>:</p>
<pre><span>@Component({ 
  selector: 'todo-app',
  template: ` 
    &lt;h1&gt;Hello {{name}}!&lt;/h1&gt; 
 
    &lt;p&gt; 
      Add a new todo: 
      &lt;input-box inputPlaceholder="New todo..." 
        buttonLabel="Add" 
        (inputText)="addTodo($event)"&gt; 
      &lt;/input-box&gt; 
    &lt;/p&gt; 
 
    &lt;p&gt;Here's the list of pending todo items:&lt;/p&gt; 
    &lt;todo-list [todos]="todos" (toggle)="toggleCompletion($event)"&gt;&lt;/todo-list&gt; 
  ` 
}) 
class TodoApp {...} </span></pre>
<p>Initially, we define the <kbd><span>TodoApp</span></kbd> class and decorate it with the <kbd><span>@Component</span></kbd> decorator. Note that in order to use the <kbd><span>InputBox</span></kbd> and <kbd><span>TodoList</span></kbd> components, we will need to include them in the <kbd><span>declarations</span></kbd> property of the decorator of the module, which declares <kbd><span>TodoApp</span></kbd>. The magic of how these components collaborate together happens in the template:</p>
<pre><span>&lt;input-box inputPlaceholder="New todo..." 
  buttonLabel="Add" 
  (inputText)="addTodo($event)"&gt; 
&lt;/input-box&gt; </span></pre>
<p>First, we use the <kbd><span>InputBox</span></kbd> component and pass values to the <kbd><span>inputPlaceholder</span></kbd> and <kbd><span>buttonLabel</span></kbd> inputs. Note that just like we saw earlier, if we want to pass an expression as a value to any of these inputs, we will need to surround them with brackets (that is, <kbd><span>[inputPlaceholder]="expression"</span></kbd>). In this case, the expression will be evaluated in the context of the component that owns the template, and the result will be passed as an input to the component that owns the given property.</p>
<p>Right after we pass the value for the <kbd><span>buttonLabel</span></kbd> input, we consume the <kbd><span>inputText</span></kbd> output by setting the value of the <kbd><span>(inputText)</span></kbd> attribute to the <kbd><span>addTodo($event)</span></kbd> expression. The value of <kbd><span>$event</span></kbd> will equal the value we passed to the <kbd><span>emit</span></kbd> method of the <kbd><span>inputText</span></kbd> object inside the <kbd><span>emitText</span></kbd> method of <kbd><span>InputBox</span></kbd> (in case we bind to a native event, the value of the event object will be the native event object itself).</p>
<p>In the same way, we pass the input of the <kbd><span>TodoList</span></kbd> component and handle its toggle output. Now, let's define the logic behind the <kbd><span>TodoApp</span></kbd> component:</p>
<pre><span>class TodoApp { 
  todos: Todo[] = []; 
  name: string = 'John';
 
  addTodo(label: string) { 
    this.todos.push({ 
      label, 
      completed: false 
    }); 
  }
 
  toggleCompletion(todo: Todo) { 
    todo.completed = !todo.completed; 
  } 
} </span></pre>
<p>In the <kbd><span>addTodo</span></kbd> method, we simply push a new to-do item to the <kbd><span>todos</span></kbd> array. The implementation of <kbd><span>toggleCompletion</span></kbd> is even simpler: we toggle the value of the completed flag that is passed as an argument to the to-do item. Now, we are familiar with the basics of the components' inputs and outputs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Event bubbling</h1>
                </header>
            
            <article>
                
<p>In Angular, we have the same bubbling behavior we're used to in the DOM. For instance, let's suppose we have the following template:</p>
<pre><span>&lt;input-box inputPlaceholder="New todo..." 
  buttonLabel="Add" 
  (click)="handleClick($event)" 
  (inputText)="addTodo($event)"&gt; 
&lt;/input-box&gt; </span></pre>
<p>The template declaration of the <kbd><span>input-box</span></kbd> component looks like this:</p>
<pre><span>&lt;input #todoInput [placeholder]="inputPlaceholder"&gt; 
&lt;button (click)="emitText(todoInput.value); 
                 todoInput.value = '';"&gt; 
  {{buttonLabel}} 
&lt;/button&gt; </span></pre>
<p>Once the user clicks on the button defined within the template of the <kbd><span>input-box</span></kbd> component, the <kbd><span>handleClick($event)</span></kbd> expression will be evaluated.</p>
<p>Further, the <kbd><span>target</span></kbd> property of the first argument of <kbd><span>handleClick</span></kbd> will be the button itself, but the <kbd><span>currentTarget</span></kbd> property will be the <kbd><span>input-box</span></kbd> element. The event will bubble the same way if we're not using Angular. At some point, it will reach the document unless a handler along the way doesn't stop its propagation.</p>
<p>In contrast, if we have a custom <kbd>@Output</kbd> decorator, the event will not bubble and instead of a DOM event object, the value of the <kbd><span>$event</span></kbd> variable will be the value that we pass to the <kbd>emit</kbd> method of the output.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Renaming the inputs and outputs</h1>
                </header>
            
            <article>
                
<p>Now, we will explore how we can rename the directives' inputs and outputs. Let's suppose that we have the following definition of the <kbd><span>TodoList</span></kbd> component:</p>
<pre><span>class TodoList { 
  ... 
  @Output() toggle = new EventEmitter&lt;Todo&gt;();
 
  toggle(index: number) { 
    ... 
  } 
} </span></pre>
<p>The output of the component is called <kbd><span>toggle</span></kbd>; the method that handles changes in the checkboxes responsible for toggling completion of the individual to-do items is also called <kbd><span>toggle</span></kbd>. This code will not be compiled, as in the <kbd><span>TodoList</span></kbd> controller, we have two identifiers named in the same way. We have two options here:</p>
<ul>
<li>We can rename the method</li>
<li>We can rename the property</li>
</ul>
<p>If we rename the property, this will change the name of the component's output as well. So, the following line of code will no longer work:</p>
<pre><span>&lt;todo-list [toggle]="foobar($event)"...&gt;&lt;/todo-list&gt; </span></pre>
<p>What we can do instead is rename the <kbd><span>toggle</span></kbd> property and explicitly set the name of the output using the <kbd><span>@Output</span></kbd> decorator:</p>
<pre><span>class TodoList { 
  ... 
  @Output('toggle') toggleEvent = new EventEmitter&lt;Todo&gt;();
 
  toggle(index: number) { 
    ... 
  } 
} </span></pre>
<p>This way, we will be able to trigger the <kbd><span>toggle</span></kbd> output using the <kbd><span>toggleEvent</span></kbd> property.</p>
<div class="packt_infobox">Note that such renames can be confusing and are not considered as best practices. For a complete set of best practices, visit <a href="https://angular.io/styleguide"><span class="URLPACKT">https://</span><span class="URLPACKT">angular.io/styleguide</span></a>.</div>
<p>Similarly, we can rename the component's inputs using the following code snippet:</p>
<pre><span>class TodoList { 
  @Input('todos') todoList: Todo[]; 
  @Output('toggle') toggleEvent = new EventEmitter&lt;Todo&gt;();
 
  toggle(index: number) { 
    ... 
  } 
} </span></pre>
<p>Now, it doesn't matter that we renamed the input and output properties of <kbd><span>TodoList</span></kbd>; it still has the same public interface:</p>
<pre><span>&lt;todo-list [todos]="todos" 
  (toggle)="toggleCompletion($event)"&gt; 
&lt;/todo-list&gt; </span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An alternative syntax to define inputs and outputs</h1>
                </header>
            
            <article>
                
<p>The <kbd><span>@Input</span></kbd> and <kbd><span>@Output</span></kbd> decorators are syntax sugar for easier declaration of the directive's <kbd>inputs</kbd> and outputs. The original syntax for this purpose is as follows:</p>
<pre><span>@Directive({ 
  outputs: ['outputName: outputAlias'], 
  inputs: ['inputName: inputAlias'] 
}) 
class Dir { 
  outputName = new EventEmitter(); 
}</span></pre>
<p>Using <kbd><span>@Input</span></kbd> and <kbd><span>@Output</span></kbd>, the preceding syntax is equivalent to this:</p>
<pre><span>@Directive(...) 
class Dir { 
  @Output('outputAlias') outputName = new EventEmitter&lt;any&gt;(); 
  @Input('inputAlias') inputName: any;
} </span></pre>
<p>Although both have the same semantics, according to the best practices, we should use the latter one, because it is easier to read and understand.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Explaining Angular's content projection</h1>
                </header>
            
            <article>
                
<p>Content projection is an important concept when developing user interfaces. It allows us to project pieces of content into different places of the user interface of our application. Web components solve this problem with the <kbd><span>content</span></kbd> element. In AngularJS, it is implemented with the infamous transclusion.</p>
<p>Angular is inspired by modern web standards, especially web components, which led to the adoption of some of the methods of content projection used there. In this section, we'll look at them in the context of Angular using the <kbd><span>ng-content</span></kbd> directive.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic content projection in Angular</h1>
                </header>
            
            <article>
                
<p>Let's suppose we're building a component called <kbd><span>fancy-button</span></kbd>. This component will use the standard HTML button element and add some extra behavior to it. Here is the definition of the <kbd><span>fancy-button</span></kbd> component:</p>
<pre><span>@Component({ 
  selector: 'fancy-button', 
  template: '&lt;button&gt;Click me&lt;/button&gt;' 
}) 
class FancyButton { ... } </span></pre>
<p>Inside of the <kbd><span>@Component</span></kbd> decorator, we set the inline template of the component together with its selector. Now, we can use the component with the following markup:</p>
<pre><span>&lt;fancy-button&gt;&lt;/fancy-button&gt; </span></pre>
<p>On the screen, we will see a standard HTML button that has a label with the <kbd>Click me</kbd> content. This is not a very flexible way to define reusable UI components. Most likely, the users of the fancy button will need to change the content of the label to something, depending on their application.</p>
<p>In AngularJS, we were able to achieve this result with <kbd><span>ng-transclude</span></kbd>:</p>
<pre><span>// AngularJS example 
app.directive('fancyButton', function () { 
  return { 
    restrict: 'E', 
    transclude: true, 
    template: '&lt;button&gt;&lt;ng-transclude&gt;&lt;/ng-transclude&gt;&lt;/button&gt;' 
  }; 
}); </span></pre>
<p>In Angular, we have the <kbd><span>ng-content</span></kbd> element:</p>
<pre><span>// ch5/ng-content/app.ts 
@Component({ 
  selector: 'fancy-button', 
  template: '&lt;button&gt;&lt;ng-content&gt;&lt;/ng-content&gt;&lt;/button&gt;' 
}) 
class FancyButton { /* Extra behavior */ } </span></pre>
<p>Now, we can pass custom content to the fancy button by executing this:</p>
<pre><span>&lt;fancy-button&gt;Click &lt;i&gt;me&lt;/i&gt; now!&lt;/fancy-button&gt; </span></pre>
<p>As a result, the content between the opening and closing <kbd><span>fancy-button</span></kbd> tags will be placed where the <kbd><span>ng-content</span></kbd> directive resides.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Projecting multiple content chunks</h1>
                </header>
            
            <article>
                
<p>Another typical use case of content projection is when we pass content to a custom Angular component or AngularJS directive and we want different parts of this content to be projected to different locations in the template.</p>
<p>For instance, let's suppose we have a <kbd><span>panel</span></kbd> component that has a title and a body, and we can use it in the following way:</p>
<pre><span>&lt;panel&gt;
  &lt;section class="panel-title"&gt;Sample title&lt;/section&gt;
  &lt;section class="panel-content"&gt;Content&lt;/section&gt;
&lt;/panel&gt;</span></pre>
<p>The template of our <kbd><span>panel</span></kbd> component looks like this:</p>
<pre><span>&lt;div class="panel"&gt; 
  &lt;div class="panel-title"&gt; 
    &lt;!-- Project the content of panel-title here --&gt; 
  &lt;/div&gt; 
  &lt;div class="panel-content"&gt; 
    &lt;!-- Project the content of panel-content here --&gt; 
  &lt;/div&gt; 
&lt;/div&gt;` </span></pre>
<p>In AngularJS 1.5, we are able to do this using multislot transclusion, which was implemented in order to allow us to have a smoother transition to Angular. Let's take a look at how we can proceed in Angular in order to define such a <kbd><span>panel</span></kbd> component:</p>
<pre><span>// ch5/ng-content/app.ts 
@Component({ 
  selector: 'panel', 
  styles: [ ... ], 
  template: ` 
    &lt;div class="panel"&gt; 
      &lt;div class="panel-title"&gt; 
        &lt;ng-content select=".panel-title"&gt;&lt;/ng-content&gt; 
      &lt;/div&gt; 
      &lt;div class="panel-content"&gt; 
        &lt;ng-content select=".panel-content"&gt;&lt;/ng-content&gt; 
      &lt;/div&gt; 
    &lt;/div&gt;` 
}) 
class Panel { } </span></pre>
<p>In the template, we have a <kbd><span>div</span></kbd> element with the <kbd><span>panel</span></kbd> class, which wraps the two nested <kbd><span>div</span></kbd> elements, respectively—one for the title of <kbd><span>panel</span></kbd> and one for the content of <kbd><span>panel</span></kbd>.</p>
<p>In order to project the content of the <kbd><span>section</span></kbd> element with the <kbd><span>panel-title</span></kbd> <span>class name</span><span> </span><span>to where the title should be, we will need to use the</span> <kbd>ng-content</kbd> <span>element. As its</span> <kbd>selector</kbd> <span>attribute, we will need to use a CSS selector, which matches the element whose content we want to project (in this case, the selector should be</span> <kbd>.panel-title</kbd> <span>or</span> <kbd>section.panel-title</kbd><span>).</span></p>
<p>In case we set the value of the <kbd><span>selector</span></kbd> attribute to <kbd><span>.panel-title</span></kbd>, it will match all the elements with the <kbd><span>.panel-title</span></kbd> <span>classes</span><span> </span><span>that reside inside the target</span> <kbd>panel</kbd> <span>element. After this,</span> <kbd>ng-content</kbd> <span>will grab their content and set them as its own content.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Nesting components</h1>
                </header>
            
            <article>
                
<p>We've already built a few simple applications as a composition of components and directives. We saw that components are basically directives with views, so we can implement them by nesting or composing other directives and components.</p>
<p>The following figure illustrates this with a structural diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="138" width="148" src="assets/f9dd1a8c-9475-4c25-9e6a-7fb75ca9c1bc.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 7</div>
<p>The composition could be achieved by nesting directives and components within the components templates, taking advantage of the nested nature of the used markup. For instance, let's say we have a component with the <kbd><span>sample-component</span></kbd> selector, which has the following definition:</p>
<pre><span>@Component({ 
  selector: 'sample-component', 
  template: '&lt;view-child&gt;&lt;/view-child&gt;' 
}) 
class Sample {} </span></pre>
<p>The template of the <kbd><span>Sample</span></kbd> component has a single-child element with the <kbd><span>view-child</span></kbd><span> </span><span>tag name</span><span>.</span></p>
<p>On the other hand, we can use the <kbd><span>Sample</span></kbd> component inside the template of another component, and since it can be used as an element, we can also nest other components or directives inside of it:</p>
<pre><span>&lt;sample-component&gt; 
  &lt;content-child1&gt;&lt;/content-child1&gt; 
  &lt;content-child2&gt;&lt;/content-child2&gt; 
&lt;/sample-component&gt; </span></pre>
<p>This way, the <kbd><span>sample-component</span></kbd> component has two different types of successors:</p>
<ul>
<li>Successors defined within its template</li>
<li>Successors passed as nested elements between its opening and closing tags</li>
</ul>
<p>In the context of Angular, the direct children elements defined within the component's template are called <strong>view children</strong> and the ones nested between its opening and closing tags are called <strong>content children</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using view children and content children</h1>
                </header>
            
            <article>
                
<p>Let's take a look at the implementation of a sample <kbd><span>Tabs</span></kbd> component, which uses the following structure:</p>
<pre><span>&lt;tabs (changed)="tabChanged($event)"&gt; 
  &lt;tab-title&gt;Tab 1&lt;/tab-title&gt; 
  &lt;tab-content&gt;Content 1&lt;/tab-content&gt; 
  &lt;tab-title&gt;Tab 2&lt;/tab-title&gt; 
  &lt;tab-content&gt;Content 2&lt;/tab-content&gt; 
&lt;/tabs&gt; </span></pre>
<p>The preceding structure is composed of three components:</p>
<ul>
<li><kbd><span>Tab</span></kbd> component</li>
<li><kbd><span>TabTitle</span></kbd> component</li>
<li><kbd><span>TabContent</span></kbd> component</li>
</ul>
<p>Let's take a look at the implementation of the <kbd><span>TabTitle</span></kbd> component:</p>
<pre><span>@Component({ 
  selector: 'tab-title', 
  styles: [...], 
  template: ` 
    &lt;div class="tab-title" (click)="handleClick()"&gt; 
      &lt;ng-content&gt;&lt;/ng-content&gt; 
    &lt;/div&gt; 
  ` 
}) 
class TabTitle { 
  @Output() tabSelected: EventEmitter&lt;TabTitle&gt; = 
    new EventEmitter&lt;TabTitle&gt;();
 
  handleClick() { 
    this.tabSelected.emit(this); 
  } 
} </span></pre>
<p>There's nothing new in this implementation. We define a <kbd><span>TabTitle</span></kbd> component, which has a single property called <kbd><span>tabSelected</span></kbd>. It is of the <kbd><span>EventEmitter</span></kbd><span> </span><span>type </span><span>and will be triggered once the user clicks on the tab title.</span></p>
<p>Now, let's take a look at the <kbd><span>TabContent</span></kbd> component:</p>
<pre><span>@Component({ 
  selector: 'tab-content', 
  styles: [...], 
  template: ` 
    &lt;div class="tab-content" [hidden]="!isActive"&gt; 
      &lt;ng-content&gt;&lt;/ng-content&gt; 
    &lt;/div&gt; 
  ` 
}) 
class TabContent { 
  isActive: boolean = false; 
} </span></pre>
<p>This has an even simpler implementation—all we do is project the DOM passed to the <kbd><span>tab-content</span></kbd> element inside <kbd><span>ng-content</span></kbd>, and hide it once the value of the <kbd><span>isActive</span></kbd> property becomes <kbd><span>false</span></kbd>.</p>
<p>The interesting part of the implementation is the <kbd><span>Tabs</span></kbd> component itself:</p>
<pre><span>// ch5/basic-tab-content-children/app.ts 
@Component({ 
  selector: 'tabs', 
  styles: [...], 
  template: ` 
    &lt;div class="tab"&gt; 
      &lt;div class="tab-nav"&gt; 
        &lt;ng-content select="tab-title"&gt;&lt;/ng-content&gt; 
      &lt;/div&gt; 
      &lt;ng-content select="tab-content"&gt;&lt;/ng-content&gt; 
    &lt;/div&gt; 
  ` 
}) 
class Tabs { 
  @Output('changed') 
  tabChanged: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;(); 
 
  @ContentChildren(TabTitle) 
  tabTitles: QueryList&lt;TabTitle&gt;; 
 
  @ContentChildren(TabContent) 
  tabContents: QueryList&lt;TabContent&gt;; 
 
  active: number;
  select(index: number) {...} 
  ngAfterViewInit() {...} 
} </span></pre>
<p>In this snippet, we have a decorator that we haven't used yet: the <kbd><span>@ContentChildren</span></kbd> decorator. The <kbd><span>@ContentChildren</span></kbd> property decorator fetches the content children of the given component. This means that we can get references to all <kbd><span>TabTitle</span></kbd> and <kbd><span>TabContent</span></kbd> instances from within the instance of the <kbd><span>Tabs</span></kbd> component and get them in the order in which they are declared in the markup. There's an alternative decorator called <kbd><span>@ViewChildren</span></kbd>, which fetches all the view children of the given element. Let's take a look at the difference between view children and content children before we explain the implementation further.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">View child versus content child</h1>
                </header>
            
            <article>
                
<p>Although both concepts sound similar, they have quite different semantics. In order to understand them better, let's take a look at the following example:</p>
<pre><span>// ch5/view-child-content-child/app.ts 
@Component({ 
  selector: 'user-badge', 
  template: '...' 
}) 
class UserBadge {} 
 
@Component({ 
  selector: 'user-rating', 
  template: '...' 
}) 
class UserRating {} </span></pre>
<p>Here, we've defined two components: <kbd><span>UserBadge</span></kbd> and <kbd><span>UserRating</span></kbd>. Let's define a parent component, which comprises both the components:</p>
<pre><span>@Component({ 
  selector: 'user-panel', 
  template: '&lt;user-badge&gt;&lt;/user-badge&gt;'
}) 
class UserPanel {...} </span></pre>
<p>Note that the template of the view of <kbd><span>UserPanel</span></kbd> contains only the <kbd><span>UserBadge</span></kbd> component's selector. Now, let's use the <kbd><span>UserPanel</span></kbd> component in our application:</p>
<pre><span>// ch5/view-child-content-child/app.ts<br/><br/>@Component({ 
  selector: 'app', 
  template: `&lt;user-panel&gt; 
    &lt;user-rating&gt;&lt;/user-rating&gt; 
  &lt;/user-panel&gt;`
}) 
class App {} </span></pre>
<p>The template of our main <kbd><span>App</span></kbd> component uses the <kbd><span>UserPanel</span></kbd> component and nests the <kbd><span>UserRating</span></kbd> component inside it. Now, let's suppose we want to get a reference to the instance of the <kbd><span>UserRating</span></kbd> component that is used inside the <kbd><span>user-panel</span></kbd> element in the <span>template of</span><span> </span><kbd>App</kbd><span> and a reference to the</span> <kbd>UserBadge</kbd> <span>component, which is used inside the</span><span> </span><span>template of </span><kbd>UserPanel</kbd><span>. In order to do this, we can add two more properties to the</span> <kbd>UserPanel</kbd> <span>controller and add the</span> <kbd>@ContentChild</kbd> <span>and</span> <kbd>@ViewChild</kbd> <span>decorators to them with the appropriate arguments:</span></p>
<p> </p>
<pre><span>// ch5/view-child-content-child/app.ts<br/><br/>class UserPanel { 
  @ViewChild(UserBadge) 
  badge: UserBadge; 
 
  @ContentChild(UserRating) 
  rating: UserRating;
 
  constructor() { 
    // 
  } 
} </span></pre>
<p>The semantics of the <kbd><span>badge</span></kbd> property declaration is <em>get the instance of the first child component of the <kbd>UserBadge</kbd> type, which is used inside the <kbd>UserPanel</kbd></em> <span><em>template.</em> Accordingly, the semantics of the</span> <kbd>rating</kbd> <span>property's declaration is <em>get the instance of the first child component of the </em></span><em><kbd>UserRating</kbd> type, which is nested inside the <kbd>UserPanel</kbd></em> <span><em>host element.</em></span></p>
<p>Now, if you run this code, you'll note that the values of the <kbd><span>badge</span></kbd> and <kbd><span>rating</span></kbd> properties are still equal to the <kbd><span>undefined</span></kbd> value inside the controller's constructor. This is because they are still not initialized in this phase of the component's life cycle. The life cycle hooks that we can use in order to get a reference to these child components are <kbd><span>ngAfterViewInit</span></kbd> and <kbd><span>ngAfterContentInit</span></kbd>. We can use these hooks simply by adding definitions of the <kbd><span>ngAfterViewInit</span></kbd> and <kbd><span>ngAfterContentInit</span></kbd> methods to the component's controller. We will make a complete overview of the life cycle hooks that Angular provides shortly.</p>
<p>To recap, we can say that the content children of the given components are the child elements that are nested within the component's host element. In contrast, the view children directives of the given component are the elements used within its template.</p>
<div class="packt_infobox">In order to get a platform independent reference to a DOM element, again, we can use <kbd><span>@ContentChild</span></kbd> and <kbd><span>@ViewChild</span></kbd>. For instance, if we have the following template: <kbd><span>&lt;input #todo&gt;</span></kbd> we can get a reference to the <kbd><span>input</span></kbd> using <kbd><span>@ViewChild('todo')</span></kbd>.</div>
<p>Since we are already familiar with the core differences between view children and content children, now we can continue with our tabs implementation.</p>
<p>In the tabs component, instead of using the <kbd><span>@ContentChild</span></kbd> decorator, we use <kbd><span>@ContentChildren</span></kbd>. We do this because we have multiple content children and we want to get them all:</p>
<pre><span>@ContentChildren(TabTitle) 
tabTitles: QueryList&lt;TabTitle&gt;; 
 
@ContentChildren(TabContent) 
tabContents: QueryList&lt;TabContent&gt;; </span></pre>
<p>Another main difference that we will note is that the types of the <kbd><span>tabTitles</span></kbd> and <kbd><span>tabContents</span></kbd> properties are <kbd><span>QueryList</span></kbd> with their respective type parameter and not the component's type itself. We can think of the <kbd><span>QueryList</span></kbd> data structure as a JavaScript array—we can apply the same high-order functions (<kbd><span>map</span></kbd>, <kbd><span>filter</span></kbd>, <kbd><span>reduce</span></kbd>, and so on) over it and loop over its elements; however, <kbd><span>QueryList</span></kbd> is also observable, that is, we can observe it for changes.</p>
<p>As the final step of our <kbd><span>Tabs</span></kbd> definition, let's take a peek at the implementation of the <kbd><span>ngAfterContentInit</span></kbd> and <kbd><span>select</span></kbd> methods:</p>
<pre><span>ngAfterContentInit() { 
  this.tabTitles 
    .map(t =&gt; t.tabSelected) 
    .forEach((t, i) =&gt; { 
      t.subscribe(_ =&gt; { 
        this.select(i) 
      }); 
    }); 
  this.active = 0; 
  this.select(0); 
}</span></pre>
<p>In the first line of the method's implementation, we loop all <kbd><span>tabTitles</span></kbd> properties and take the observable's references. These objects have a method called <kbd><span>subscribe</span></kbd>, which accepts a callback as an argument. Once the <kbd><span>.emit()</span></kbd> method of the <kbd><span>EventEmitter</span></kbd> instance (that is, the <kbd><span>tabSelected</span></kbd> property of any tab) is called, the callback passed to the <kbd><span>subscribe</span></kbd> method will be invoked.</p>
<p>Now, let's take a look at the implementation of the <kbd><span>select</span></kbd> method:</p>
<pre><span>select(index: number) { 
  let contents: TabContent[] = this.tabContents.toArray(); 
  contents[this.active].isActive = false; 
  this.active = index; 
  contents[this.active].isActive = true; 
  this.tabChanged.emit(index); 
} </span></pre>
<p>In the first line here, since <kbd><span>tabContents</span></kbd> is of the <kbd><span>QueryList&lt;TabContent&gt;</span></kbd><span> </span><span>type</span><span>, we get its array representation. After that, we set the</span> <kbd>isActive</kbd> <span>flag of the current active tab to</span> <kbd>false</kbd> <span>and select the next active one. In the last line in the implementation of the</span> <kbd>select</kbd> <span>method, we trigger the</span> selected <span>event of the</span> <kbd>Tabs</kbd> <span>component by invoking</span> <kbd>this.tabChanged.emit</kbd> <span>with the index of the currently selected tab.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hooking into the component's life cycle</h1>
                </header>
            
            <article>
                
<p>Components in Angular have a well-defined life cycle, which allows us to hook into different phases of it and have further control over our application. We can do this by implementing specific methods in the component's controller. In order to be more explicit, thanks to the expressiveness of TypeScript, we can implement different interfaces associated with the life cycle's phases. Each of these interfaces has a single method, which is associated with the phase itself.</p>
<p>The following diagram shows all the phases we can hook into:</p>
<div class="CDPAlignCenter CDPAlign"><img height="106" width="278" src="assets/603bcc04-bfef-4c74-acc8-866dd17df571.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 8</div>
<p>Let's take a look at the different life cycle hooks:</p>
<ul>
<li><kbd><span>OnChanges</span></kbd>: This hook will be invoked once a change in the input properties of a given component is detected. For instance, let's take a look at the following component:</li>
</ul>
<pre><span>      @Component({ 
        selector: 'panel', 
        inputs: ['title'] 
      }) 
      class Panel {...} </span></pre>
<p>We can use it like this:</p>
<pre><span>&lt;panel [title]="expression"&gt;&lt;/panel&gt; </span></pre>
<p>Once the value of the expression associated with the <kbd><span>[title]</span></kbd> attribute is changed, the <kbd><span>ngOnChanges</span></kbd> hook will be invoked. We can implement it using this code snippet:</p>
<pre><span>@Component(...) 
class Panel { 
  ngOnChanges(changes) { 
    Object.keys(changes).forEach(prop =&gt; { 
      console.log(prop, 'changed. Previous value', changes[prop].previousValue); 
    }); 
  } 
} </span></pre>
<p>The preceding snippet will display all the changed bindings and their old values. In order to be more explicit in the implementation of the hook, we can use interfaces:</p>
<pre><span>import {Component, OnChanges} from '@angular/core'; <br/>@Component(...) 
class Panel implements OnChanges { 
  ngOnChanges(changes) {...} 
} </span></pre>
<p>All the interfaces representing the individual life cycle hooks declare a single method with the name of the interface itself prefixed with <kbd><span>ng</span></kbd>.</p>
<p>In the upcoming list, we'll use the term life cycle hook, both for interface and/or the method, except if we won't imply anything specifically for only one of them.</p>
<ul>
<li><kbd><span>OnInit</span></kbd>: This hook will be invoked once the given component is initialized. We can implement it using the <kbd><span>OnInit</span></kbd> interface with its <kbd><span>ngOnInit</span></kbd> method.</li>
<li><kbd><span>DoCheck</span></kbd>: This will be invoked when the change detector of the given component is invoked. It allows us to implement our own change detection algorithm for the given component. Note that <kbd><span>DoCheck</span></kbd> and <kbd><span>OnChanges</span></kbd> should not be implemented together on the same directive.</li>
<li><kbd><span>OnDestroy</span></kbd>: If we implement the <kbd><span>OnDestroy</span></kbd> interface with its <kbd><span>ngOnDestroy</span></kbd> method, we can hook into the destroy life cycle phase of a component. This method will be invoked once the component is detached from the component tree.</li>
</ul>
<p>Now, let's take a look at the life cycle hooks associated with the component's content and view children:</p>
<ul>
<li><kbd><span>AfterContentInit</span></kbd>: If we implement the <kbd><span>ngAfterContentInit</span></kbd> life cycle hook, we will be notified when the component's content is fully initialized. This is the phase when the properties decorated with <kbd><span>ContentChild</span></kbd> or <kbd><span>ContentChildren</span></kbd> will be initialized.</li>
<li><kbd><span>AfterContentChecked&lt;/span&gt;</span></kbd>: By implementing this hook, we'll be notified each time the content of the given component has been checked by the change detection mechanism of Angular.</li>
<li><kbd><span>AfterViewInit</span></kbd>: If we implement this life cycle hook with its <kbd><span>ngAfterViewInit</span></kbd> method, we will be notified when the component's view is initialized. This is the phase when the properties decorated with <kbd><span>ViewChild</span></kbd> or <kbd><span>ViewChildren</span></kbd> will be initialized.</li>
<li><kbd><span>AfterViewChecked</span></kbd>: This is similar to <kbd><span>AfterContentChecked</span></kbd>. The <kbd><span>AfterViewChecked</span></kbd> hook will be invoked once the view of our component is checked.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Order of execution of the life cycle hooks</h1>
                </header>
            
            <article>
                
<p>In order to trace the order of execution of the callbacks associated with each hook, let's take a peek at the <kbd><span>ch5/life-cycle/app.ts</span></kbd> example:</p>
<pre><span>// ch5/life-cycle/app.ts<br/><br/>@Component({ 
  selector: 'panel', 
  template: '&lt;ng-content&gt;&lt;/ng-content&gt;' 
}) 
class Panel { 
  @Input() title: string;
  @Input() caption: string;
  ngOnChanges(changes) {...} 
  ngOnInit() {...} 
  ngDoCheck() {...} 
  ngOnDestroy() {...} 
  ngAfterContentInit() {...} 
  ngAfterContentChecked() {...} 
  ngAfterViewInit() {...} 
  ngAfterViewChecked() {...} 
} </span></pre>
<p>The <kbd><span>Panel</span></kbd> component implements all the hooks without explicitly implementing the interfaces associated with them for the sake of simplicity. Keep in mind that it's considered best practice to implement the interfaces of the individual life cycle hooks we use.</p>
<p>We can use the component in the following template:</p>
<pre><span>&lt;button (click)="toggle()"&gt;Toggle&lt;/button&gt; 
&lt;div *ngIf="counter % 2 == 0"&gt; 
  &lt;panel caption="Sample caption" &gt;Hello world!&lt;/panel&gt; 
&lt;/div&gt; </span></pre>
<p>In the preceding example, we have a panel and a button. Upon each click of the button, the panel will be either removed or appended to the view by the <kbd><span>ngIf</span></kbd> directive.</p>
<p>During the application initialization, if the result of the <kbd><span>"counter % 2 == 0"</span></kbd> expression is evaluated to <kbd><span>true</span></kbd>, the <kbd><span>ngOnChanges</span></kbd> method will be invoked. This happens because the values of the title and caption properties will be set for the first time.</p>
<p>Right after this, the <kbd><span>ngOnInit</span></kbd> method will be called, since the component has been initialized. Once the component's initialization is completed, the change detection will be triggered, which will lead to the invocation of the <kbd><span>ngDoCheck</span></kbd> method that allows us to hook custom logic for detecting changes in the state.</p>
<p>After the <kbd><span>ngDoCheck</span></kbd> method, the change detector will perform a check on the component's content (<kbd><span>ngAfterContentInit</span></kbd> and <kbd><span>ngAfterContentChecked</span></kbd> will be invoked in this order). Right after this, the same will happen for the component's view (<kbd><span>ngAfterViewInit</span></kbd> followed by <kbd><span>ngAfterViewChecked</span></kbd>).</p>
<p>Once the expression of the <kbd><span>ngIf</span></kbd> directive is evaluated to <kbd><span>false</span></kbd>, the entire component will be detached from the view, which will lead to the invocation of the <kbd><span>ngOnDestroy</span></kbd> hook.</p>
<p>On the next click, if the value of the expression of <kbd><span>ngIf</span></kbd> is equal to <kbd><span>true</span></kbd>, the same sequence of calls of the life cycle hooks as the one during the initialization phase will be executed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining generic views with TemplateRef</h1>
                </header>
            
            <article>
                
<p>We are already familiar with the concepts of inputs, content children, and view children, and we also know when we can get a reference to them in the component's life cycle. Now, we will combine them and introduce a new concept: <kbd><span>TemplateRef</span></kbd>.</p>
<p>Let's take a step back and take a look at the last to-do application we developed earlier in this chapter. In the following screenshot, you can see what its UI looks like:</p>
<div class="CDPAlignCenter CDPAlign"><img height="219" width="363" src="assets/3090e812-1395-45df-8dc1-33bf865f769d.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 9</div>
<p>If we take a look at its implementation in <kbd><span>ch5/inputs-outputs/app.ts</span></kbd>, we'll see that the template used to render the individual to-do items is defined inside the template of the entire to-do application.</p>
<p>What if we want to use a different layout to render the to-do items? We can do this by creating another component called <kbd><span>Todo</span></kbd>, which encapsulates the responsibility of rendering them. Then, we can define separate <kbd><span>Todo</span></kbd> components for the different layouts we want to support. This way, we need to have <em>n</em> different components for <em>n</em> different layouts, even though we need to change only their templates.</p>
<p>Angular comes with a more elegant solution. Earlier in this chapter, we have already discussed the <kbd>ng-template</kbd> element. Angular allows us to reference such <kbd>ng-template</kbd> elements and use them by passing them as content children.</p>
<p>Here is how we can pass the custom layout to our refactored <kbd><span>TodoApp</span></kbd> component:</p>
<pre><span>// ch5/template-ref/app.ts 
&lt;todo-app&gt; 
  &lt;ng-template let-todo&gt; 
    &lt;input type="checkbox" [checked]="todo.completed" 
      (change)="todo.completed = !todo.completed;"&gt; 
    &lt;span [class.completed]="todo.completed"&gt; 
      {{todo.label}} 
    &lt;/span&gt;&lt;br&gt; 
  &lt;/ng-template&gt; 
&lt;/todo-app&gt; </span></pre>
<p>In the template, we declare a variable called <kbd><span>todo</span></kbd>; later in the template, we can use it to reference to the current to-do object.</p>
<p>Now, let's take a look at how we can get a reference to this template in the controller of the <kbd><span>TodoApp</span></kbd> component:</p>
<pre><span>// ch5/template-ref/app.ts 
class TodoApp { 
  @ContentChild(TemplateRef) itemsTemplate: TemplateRef; 
  // ... 
} </span></pre>
<p>All we do here is define a property called <kbd><span>itemsTemplate</span></kbd> and decorate it with the <kbd><span>@ContentChild</span></kbd> decorator. During the component's life cycle (more accurately, in <kbd><span>ngAfterContentInit</span></kbd>), the value of <kbd><span>itemsTemplate</span></kbd> will be set to a reference of the template that we passed as the content of the <kbd><span>todo-app</span></kbd> element.</p>
<p>There is one more problem though: we need the template in the <kbd><span>TodoList</span></kbd> component, since that's the place where we render the individual to-do items. What we can do is define another input of the <kbd><span>TodoList</span></kbd> component and pass the template directly from <kbd><span>TodoApp</span></kbd>:</p>
<pre><span>// ch5/template-ref/app.ts 
class TodoList { 
  @Input() todos: Todo[]; 
</span>  @Input() itemsTemplate: TemplateRef;<span> 
  @Output() toggle = new EventEmitter&lt;Todo&gt;(); 
} </span></pre>
<p>We need to pass it as an input from the template of <kbd><span>TodoApp</span></kbd>:</p>
<pre><span>... 
&lt;todo-list [todos]="todos" 
  [itemsTemplate]="itemsTemplate"&gt; 
&lt;/todo-list&gt; </span></pre>
<p>The only thing left is to use this template reference in the template of the <kbd><span>TodoList</span></kbd> application:</p>
<pre><span>&lt;!-- ... --&gt; 
&lt;ng-template *ngFor="let todo of todos; template: itemsTemplate"&gt;&lt;/ng-template&gt; </span></pre>
<p>We have explained the extended syntax of the <kbd><span>ngForOf</span></kbd> directive in the previous sections of this chapter. The preceding snippet shows one more property of this directive that we can set: the <kbd><span>template</span></kbd> property. By default, the template of the <kbd><span>ngForOf</span></kbd> directive is the element it is used on. By specifying a template reference we can use the passed <kbd>TemplateRef</kbd> class instead.</p>
<p>Let's desugar the preceding syntax from even further:</p>
<div>
<pre><span>&lt;ng-template ngFor let-todo [ngForOf]="todos" [ngForTemplate]="itemsTemplate"&gt;<br/></span>&lt;/ng-template&gt;</pre>
<p>We pass the template that we want to use by setting the <kbd>[ngForTemplate]</kbd> input of the <kbd>NgForOf</kbd> directive, which we place on top of the <kbd>ng-template</kbd> element.</p>
<p>The template declaration, on the other hand, looks like this:</p>
<div>
<pre><span>&lt;ng-template let-todo&gt;<br/>  ...<br/>&lt;/ng-template&gt;</span></pre>
<p>There are a few things which look similar—we have <kbd>ng-template</kbd> in both places, as well as the <kbd>let-todo</kbd><span> </span><span>binding</span><span>. As we would expect, the</span> <kbd>let-todo</kbd> <span>attribute will bind the current to-do item to the</span> <kbd>todo</kbd> <span>variable. Notice that we do not set any value to the</span> <kbd>let-todo</kbd> <span>attribute; this will implicitly bind the</span> <kbd>todo</kbd> <span>variable to the</span> <kbd>$implicit</kbd> <span>property</span><span> </span><span>of the context of the</span> <kbd>NgForOf</kbd> <span>directive (that is, </span><kbd>NgForOfContext</kbd><span>). In fact, we don't need to keep the attribute names the same, for example, in the external template we pass to</span> <kbd>NgForOf</kbd><span>, </span><span>we can use</span> <kbd>let-current</kbd> <span>and we will get the exact same behavior. As soon as we don't set a value to this attribute, Angular will assign it to the</span> <kbd>$implicit</kbd> <span>property of the context.</span></p>
<p>The context though, provides few more properties: <kbd>index</kbd> (index of the current element we're iterating over), <kbd>even</kbd> (if the current index is an even number), <kbd>odd</kbd> (if the current index is an odd number), and others. If we want to get access to any of them within our <kbd>TemplateRef</kbd> class, we need to change its declaration to the following:</p>
<pre><span>... <br/> &lt;ng-template let-todo </span>let-i="index"&gt; 
    Index: {{i}}<span><br/>    &lt;input type="checkbox" [checked]="todo.completed" 
      (change)="todo.completed = !todo.completed;"&gt; 
    &lt;span [class.completed]="todo.completed"&gt; 
      {{todo.label}} 
    &lt;/span&gt;&lt;br&gt; 
  &lt;/ng-template&gt; <br/>...</span></pre>
<p>This way, we can associate the <kbd>index</kbd> property provided by <kbd>NgForOfContext</kbd> to the <kbd>i</kbd> variable in our <kbd>TemplateRef</kbd>.</p>
<p>Now let's continue our journey by exploring the Angular's change detection mechanism!</p>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding and enhancing the change detection</h1>
                </header>
            
            <article>
                
<p>We have already briefly described the change detection mechanism of the framework. We said that compared with AngularJS, where it runs in the context of the <em>scope</em>, in Angular, it runs in the context of the individual components. Another concept we mentioned is the zones, which basically intercept all the asynchronous calls that we make using the browser APIs and provide execution context for the change detection mechanism of the framework. Zones fix the annoying problem that we have in AngularJS, where when we use APIs outside of Angular, we needed to explicitly invoke the <kbd><span>digest</span></kbd> loop.</p>
<p>In <a href=""/><a href="ced71b5c-e25d-4781-8aab-81ef0a053b14.xhtml"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Get Going with Angular</em> and <a href="7bc2aa38-2853-468a-8e03-c25387eb03aa.xhtml">Chapter 3</a>, <em>The Building Blocks of an Angular Application</em>, we discussed that the code that performs change detection over our components is being generated, either runtime (<strong>just-in-time</strong>) or as part of our build process (<strong>ahead-of-time</strong>). AOT compilation works great for environments with strict <strong>CSP</strong> (short for, <strong>Content-Security-Policy</strong>) because of the disabled dynamic evaluation of JavaScript; it also provides much better performance since Angular will not have to compile the components' templates. We will explain it in detail in <a href="3ad730a8-f797-4fc1-b908-5a20eeffac23.xhtml"/><a href="b9d6c03a-d141-4201-afc6-339a41a38715.xhtml">Chapter 9</a><em>, Tooling and Development Experience</em>.</p>
<p>In this section, we'll explore another property of the <kbd><span>@Component</span></kbd> decorator's configuration object, which provides us further control over the change detection mechanism of the framework by changing its strategy. By explicitly setting the strategy, we are able to prevent the change detection mechanism from running over a component's subtrees, which in some cases can bring great performance benefits.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The order of execution of the change detectors</h1>
                </header>
            
            <article>
                
<p>Now, let's briefly describe the order in which the change detectors are invoked in a given component tree.</p>
<p>For this purpose, we will use the last implementation of the to-do application we have, but this time, we'll extract the logic to render the individual to-do items into a separate component called <kbd>TodoItem</kbd>. In the following diagram, we can see the application's structure, also known as, component tree:</p>
<div class="CDPAlignCenter CDPAlign"><img height="212" width="180" src="assets/b2dbd1f0-8a02-434d-b064-c681d41ba564.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 10</div>
<p>At the top level is the <kbd>TodoApp</kbd> component, which has two children: <kbd>InputBox</kbd> and <kbd>TodoList</kbd>. The <kbd>TodoList</kbd> component renders the individual to-do items using the <kbd>TodoItem</kbd> components. The implementation details are not important for our purpose, so we will ignore them.</p>
<p>Now, we need to realize that there is an implicit dependency between the state of the parent component and its children. For instance, the state of the <kbd>TodoList</kbd> component depends completely on the to-do items that are located at its parent: the <kbd>TodoApp</kbd> component. There's a similar dependency between <kbd>TodoItem</kbd> and <kbd>TodoList</kbd> since the <kbd>TodoList</kbd> component passes the individual to-do items to a separate instance of the <kbd>TodoItem</kbd> component. This means that if the list of to-do items in <kbd>TodoList</kbd> changes, this will automatically reflect some of the <kbd>TodoItem</kbd> components:</p>
<div class="CDPAlignCenter CDPAlign"><img height="193" width="192" src="assets/fb1f6569-5a5e-4efd-b07a-58f492fcdea0.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 11</div>
<p>Owing to our last observation, the order of execution of the change detectors attached to the individual components is like the one shown in the preceding figure. Once the change detection mechanism runs, initially it will perform a check over the <kbd>TodoApp</kbd> component. Right after this, the <kbd>InputBox</kbd> component will be checked for changes, followed by the <kbd>TodoList</kbd> component. In the end, Angular will invoke the change detector of the <kbd>TodoItem</kbd> component.</p>
<p>You can trace the order of execution in the <kbd>ch5/change_detection_strategy_order/app.ts</kbd> example, where each individual component logs a message once its <kbd><span>ngDoCheck</span></kbd> method is invoked.</p>
<div class="packt_infobox">Note that only the components have an instance of a change detector attached to them; directives use the change detector of their parent component.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding Angular's change detection strategies</h1>
                </header>
            
            <article>
                
<p>The change detection strategies that Angular provides are <kbd><span>Default</span></kbd> and <kbd><span>OnPush</span></kbd>. We will describe how we can take advantage of <kbd><span>OnPush</span></kbd> in detail, since it is very powerful when working with immutable data.</p>
<p>Now, let's import the TypeScript enum, which can be used to configure the strategy used for the individual components:</p>
<pre><span>// ch5/change_detection_strategy_broken/app.ts 

import {ChangeDetectionStrategy} from '@angular/core'; </span></pre>
<p>Now, we can configure the <kbd><span>TodoList</span></kbd> component to use the <kbd><span>OnPush</span></kbd> strategy:</p>
<pre><span>@Component({ 
  selector: 'todo-list', 
  changeDetection: ChangeDetectionStrategy.OnPush, 
  template: `...`, 
  styles: [...] 
}) 
class TodoList { ... } </span></pre>
<p>This way, the change detection will be skipped until the component doesn't receive inputs that have different values. Note that comparison uses equality check, which means that it'll compare primitive types by their value and objects by comparing their references. You can go to <a href="http://localhost:5555/dist/dev/ch5/change_detection_strategy_broken/">http://localhost:5555/dist/dev/ch5/change_detection_strategy_broken/</a> and see the inconsistent behavior of the <kbd><span>TodoList</span></kbd> component. When you add a new to-do item in the input and click on the <span class="packt_screen">Add</span> button, it won't immediately appear in the list.</p>
<p>By default, the change detection will always check for changes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing immutable data structures and OnPush</h1>
                </header>
            
            <article>
                
<p>Now, we will describe the <kbd><span>OnPush</span></kbd> change detection strategy. It is extremely useful when the result that the given component produces depends only on its inputs. In such cases, we can pass an immutable data to its inputs in order to make sure that it will not be mutated by any component. This way, by having a component that depends only on its immutable inputs and doesn't produce any side effects, we can make sure that it produces different user interfaces only once it receives different inputs (that is, with different references).</p>
<p>In this section, we will apply the <kbd><span>OnPush</span></kbd> strategy to the <kbd><span>TodoList</span></kbd> component. Since it depends only on its inputs (the <kbd><span>todos</span></kbd> input), we want to make sure that its change detection will be performed only once it receives a new reference of the <kbd><span>todos</span></kbd> collection.</p>
<p>The essence of an immutable data is that it cannot change. This means that once we create the <kbd><span>todos</span></kbd> collection, we cannot change it; instead, the <kbd><span>add</span></kbd> (or, in our case, <kbd><span>push</span></kbd>) method will return a new collection—a <em>copy</em> of the initial collection with the new item included.</p>
<p>This may seem like a huge overhead to copy the entire collection on each change. In big applications, this may have a big performance impact. However, we don't need to copy the entire collection. There are libraries that implement the immutable data structure using smarter algorithms, for example, persistent data structures. Persistent data structures are beyond the scope of the current content. Further information about them can be found in most computer science textbooks for advanced data structures. The good thing is that we don't have to understand their implementation in depth in order to use them. There is a library called <kbd>Immutable.js</kbd> that implements a few commonly used immutable data structures. In our case, we will use the immutable list. Generally, the immutable list behaves just like a normal list, but on each operation that is supposed to mutate it, it returns a new immutable list.</p>
<p>This means that if we have a list called <kbd><span>foo</span></kbd>, which is immutable, and append a new item to the list, we will get a new reference:</p>
<pre><span>let foo = List.of(1, 2, 3); 
let changed = foo.push(4); 
foo === changed // false 
console.log(foo.toJS()); // [ 1, 2, 3 ] 
console.log(changed.toJS()); // [ 1, 2, 3, 4 ] </span></pre>
<p>In order to take advantage of immutability, we will need to install <kbd>Immutable.js</kbd> using <kbd>npm</kbd>.</p>
<p>The library is already a part of the project that contains the code for the book. You can find a reference to <kbd>Immutable.js</kbd> in <kbd><span>package.json</span></kbd>, located in the root of the project. You can take a look at <kbd><span>ch5/change_detection_strategy/app.ts</span></kbd> to see how we include the immutable collections in our TypeScript application.</p>
<p>Now, it's time to refactor our to-do application and make it use immutable data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using immutable data in Angular</h1>
                </header>
            
            <article>
                
<p>Let's take a look at how we currently keep the to-do items in the <kbd><span>TodoApp</span></kbd> component:</p>
<pre><span>class TodoApp { 
  todos: Todo[] = [...]; 
  ... 
} </span></pre>
<p>We use an array of <kbd><span>Todo</span></kbd> items. The JavaScript array is mutable, which means that if we pass it to a component that uses the <kbd><span>OnPush</span></kbd> strategy, it is not safe to skip the change detection in case we get the same input reference. For instance, we may have two components that use the same list of to-do items. Both components can modify the list since it is mutable. This will lead to an inconsistent state for any of the components in case their change detection is not performed. That's why we need to make sure that the list that holds the items is immutable. All we need to do in the <kbd><span>TodoApp</span></kbd> component in order to make sure that it holds its data in an immutable data structure is this:</p>
<pre><span>// ch5/change_detection_strategy/app.ts 
<br/>class TodoApp { 
  todos: Immutable.fromJS([{ 
    label: 'Buy milk', 
    completed: false 
  }, { 
    label: 'Save the world', 
    completed: false 
  }]);
  ... 
} </span></pre>
<p>In this way, we construct the <kbd><span>todos</span></kbd> property as an immutable list, which contains immutable objects; all we need to do is to invoke the function <kbd><span>fromJS</span></kbd> exported by <kbd>Immutable.js</kbd>. It will recursively turn any JavaScript object into an immutable object.</p>
<p>Next, since the mutation operations of the immutable list return a new list, we need to make a slight modification in <kbd><span>addTodo</span></kbd> and <kbd><span>toggleTodoCompletion</span></kbd>:</p>
<pre><span>... 
addTodo(label: string) { 
  this.todos = this.todos.push(Immutable.fromJS({ 
    label, 
    completed: false 
  })); 
}

toggleCompletion(index: number) { 
  this.todos = this.todos.update(index, todo =&gt; { 
    return Immutable.fromJS({ 
      label: todo.label, 
      completed: !todo.completed 
    });
  }); 
} 
... </span></pre>
<p>The <kbd><span>addTodo</span></kbd> function looks exactly the same as before, except that we set the result of the <kbd><span>push</span></kbd> method as a value to the <kbd><span>todos</span></kbd> property.</p>
<p>In <kbd><span>toggleTodoCompletion</span></kbd>, we use the <kbd><span>update</span></kbd> method of the immutable list. As the first argument, we pass the index of the to-do item we want to modify, and the second argument is a callback that does the actual modification. Note that since we use immutable data in this case, we copy the modified to-do item. This is required because it tells the <kbd><span>update</span></kbd> method that the item with the given index has been changed (since it is immutable, it is considered as changed only when it has a new reference), which means that the entire list has been changed.</p>
<p>This was the complex part! Now, let's take a look at the <kbd><span>TodoList</span></kbd> component's definition:</p>
<pre><span>@Component({ 
  selector: 'todo-list', 
  changeDetection: ChangeDetectionStrategy.OnPush, 
  template: `...`, 
  styles: [...] 
}) 
class TodoList { 
  @Input() todos: ImmutableList&lt;Todo&gt;; 
  @Output() toggle = new EventEmitter&lt;number&gt;();
 
  toggleCompletion(index: number) { 
    this.toggle.emit(index); 
  } 
} </span></pre>
<p>Finally, we need to modify the way we access the properties of the immutable to-do items inside the templates:</p>
<pre><span>&lt;ul&gt;
  &lt;li *ngFor="let todo of todos; let index = index"
      [class.completed]="todo.get('completed')"&gt;
     &lt;input type="checkbox" [checked]="todo.get('completed')"
       (change)="toggleCompletion(index)"&gt;
    {{todo.get('label')}}
  &lt;/li&gt;
&lt;/ul&gt;</span></pre>
<p>The change we made here is that instead of using direct property access, such as <kbd><span>todo.completed</span></kbd>, we invoke the <kbd><span>get</span></kbd> method of the object by passing the property name associated with the value we want to get, in this case <kbd><span>"completed"</span></kbd>.</p>
<p>Inside the <kbd><span>@Component</span></kbd> decorator, we set the <kbd><span>changeDetection</span></kbd> property to the value of the <kbd><span>OnPush</span></kbd> strategy. This means that the component will run its change detector only when any of its inputs gets a new reference. Everything else, except the property access, inside of the template of the component stays exactly the same since <kbd><span>ngForOf</span></kbd> internally uses ES2015 iterators to loop over the items in the provided collection. They are supported by <kbd>Immutable.js</kbd>, so no changes in the template are required.</p>
<p>Since we need the index of the changed item instead of its reference (the one we use in the <kbd><span>update</span></kbd> method of the <kbd><span>todos</span></kbd> collection in <kbd><span>TodoApp</span></kbd>), we change the type of the output of the component to <kbd><span>EventEmitter&lt;number&gt;</span></kbd>. In <kbd><span>toggleCompletion</span></kbd>, we emit the index of the changed to-do item.</p>
<p>This is how we optimized our simple to-do application by preventing the change detection mechanism from running in the entire right subtree, in case the parent component hasn't pushed an input with a new reference.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we went through the core building blocks of an Angular application: directives and components. We built a couple of sample components, which showed us the syntax to be used for the definition of these fundamental concepts. We also described the life cycle of each directive and the core set of features the given directive and component have. As the next step, we saw how we can enhance the performance of our application using the <kbd><span>OnPush</span></kbd> change detection strategy with an immutable data.</p>
<p>The next chapter is completely dedicated to the Angular services and the dependency injection mechanism of the framework. We will take a look at how we can define and instantiate custom injectors and how we can take advantage of the dependency injection mechanism in our directives and components.</p>


            </article>

            
        </section>
    </body></html>