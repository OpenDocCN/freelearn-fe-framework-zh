<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Introduction to Test-Driven Development"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Introduction to Test-Driven Development</h1></div></div></div><p>Angular is at the forefront of client-side JavaScript testing. Every Angular tutorial includes an accompanying test, and event test modules are a part of the core Angular package. The Angular team is focused on making testing fundamental to web development.</p><p>This chapter introduces you to the fundamentals of <span class="strong"><strong>test-driven development</strong></span> (<span class="strong"><strong>TDD</strong></span>) with Angular, including the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An overview of TDD</li><li class="listitem" style="list-style-type: disc">The TDD life cycle: test first, make it run, and make it better</li><li class="listitem" style="list-style-type: disc">Common testing techniques</li></ul></div><div class="section" title="An overview of TDD"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec7"/>An overview of TDD</h1></div></div></div><p>TDD is an evolutionary approach to development, where you write a test before you write just enough production code to fulfill that test and its refactoring.</p><p>This section will explore the fundamentals of TDD. Let's take a tailor as an example and see how he would apply TDD to his own process.
</p><div class="section" title="Fundamentals of TDD"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec6"/>Fundamentals of TDD</h2></div></div></div><p>Get an idea of what to write in your code before you start writing it. This may sound cliched, but this is essentially what TDD gives you. TDD begins by defining expectations, then makes you meet the expectations, and finally forces you to refine the changes after the expectations are met.</p><p>Some of the clear benefits of practicing TDD are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>No change is small</strong></span>: Small changes can cause a lot of breaking issues in the entire project. Practicing TDD is the only way that can help, as the test suite will catch the breaking points and save the project after any change, and will thus save lives of developers.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Specifically identify the tasks</strong></span>: A test suite specifically provides a clear vision of the tasks and the step-by-step workflow in order to be successful. Setting up the tests first allows you to focus on only the components that have been defined in the tests.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Confidence in refactoring</strong></span>: Refactoring involves moving, fixing, and changing a project. Tests protect the core logic from refactoring by ensuring that the logic behaves independently of the code structure.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Upfront investment, benefits in the future</strong></span>: Initially, it looks like testing takes extra time, but it actually pays off later when the project becomes bigger, it gives us confidence to extend the features as just running the test will identify the breaking issues, if any.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>QA resources might be limited</strong></span>: In most cases, there are some limitations on QA resources as it always takes extra time for everything to be manually checked by the QA team, but writing some test cases and running them successfully will definitely save some QA time.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Documentation</strong></span>: Tests define the expectations that a particular object or function must meet. An expectation acts as a contract and can be used to see how a method should or can be used. This makes the code readable and easier to understand.</li></ul></div></div><div class="section" title="Measuring the success with different eyes"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec7"/>Measuring the success with different eyes</h2></div></div></div><p>TDD is not just a software development practice--its fundamental principles are shared by other craftsmen as well. One of these craftsmen is a tailor, whose success depends on precise measurements and careful planning.</p><div class="section" title="Breaking down the steps"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec1"/>Breaking down the steps</h3></div></div></div><p>Here are the high-level steps that a tailor performs to make a suit:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="strong"><strong>Testing first</strong></span>:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Determining the measurements for the suit</li><li class="listitem" style="list-style-type: disc">Having the customer determine the style and material they want for their suit</li><li class="listitem" style="list-style-type: disc">Measuring the customer's arms, shoulders, torso, waist, and legs</li></ul></div><p>
</p></li><li class="listitem"><span class="strong"><strong>Making the cuts</strong></span>:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Selecting the fabric based on the desired style</li><li class="listitem" style="list-style-type: disc">Measuring the fabric based on the customer's body shape</li><li class="listitem" style="list-style-type: disc">Cutting the fabric based on the measurements</li></ul></div><p>
</p></li><li class="listitem"><span class="strong"><strong>Refactoring</strong></span>:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Comparing the cut and look to the customer's desired style</li><li class="listitem" style="list-style-type: disc">Making adjustments to meet the desired style</li></ul></div><p>
</p></li><li class="listitem"><span class="strong"><strong>Repeating</strong></span>:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Test first</strong></span>: Determining the measurements for the suit   </li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Make the cuts</strong></span>: Measuring the fabric and making the cuts</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Refactor</strong></span>: Making changes based on the reviews</li></ul></div><p>
</p></li></ol></div><p>The preceding steps are an example of a TDD approach. The measurements must be taken before the tailor can start cutting the raw material. For a moment, imagine that the tailor didn't use a test-driven approach and didn't use a measuring tape (testing tool). It would be ridiculous if the tailor started cutting before measuring.</p><p>As a developer, do you "cut before measuring"? Would you trust a tailor without a measuring tape? How would you feel about a developer who doesn't test?</p></div><div class="section" title="Measure twice, cut once"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec2"/>Measure twice, cut once</h3></div></div></div><p>The tailor always starts with measurements. What would happen if the tailor made cuts before measuring? What would happen if the fabric was cut too short? How much extra time would go into the tailoring? Thus, measure twice, cut once.</p><p>Software developers can choose from an endless amount of approaches to use before starting development. One common approach is to work off a specification. A documented approach may help in defining what needs to be built; however, without tangible criteria for how to meet a specification, the actual application that gets developed may be completely different from the specification. With a TDD approach, every stage of the process verifies that the result meets the specification. Think about how a tailor continues to use a measuring tape to verify the suit throughout the process.</p><p>TDD embodies a test-first methodology. TDD gives developers the ability to start with a clear goal and write code that will directly meet a specification, so you can develop like a professional and follow the practices that will help you write quality software.</p></div></div></div></div>
<div class="section" title="Practical TDD with JavaScript"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec8"/>Practical TDD with JavaScript</h1></div></div></div><p>Let's dive into practical TDD in the context of JavaScript. This walk through will take us through the process of adding the multiplication functionality to a calculator.</p><p>Just keep the TDD life cycle, as follows, in mind:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Test first</li><li class="listitem" style="list-style-type: disc">Make it run</li><li class="listitem" style="list-style-type: disc">Make it better</li></ul></div><div class="section" title="Point out the development to-do list"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec8"/>Point out the development to-do list</h2></div></div></div><p>A development to-do list helps organize and focus on tasks individually. It also helps provide a platform to list down ideas during the development process, which could be a single feature later on.</p><p>Let's add the first feature in the development to-do list--the add multiplication functionality:</p><p><span class="emphasis"><em>3 * 3 = 9</em></span></p><p>The preceding list describes what needs to be done. It also provides a clear example of how to verify the multiplication <span class="emphasis"><em>3 * 3 = 9.</em></span></p></div><div class="section" title="Setting up the test suite"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec9"/>Setting up the test suite</h2></div></div></div><p>To set up the test, let's create the initial calculator in a file called <code class="literal">calculator.js</code>. It is initialized as an object as follows:</p><pre class="programlisting">var calculator = {}; &#13;
</pre><p>The test will be run through a web browser as a simple HTML page. So for that, let's create an HTML page and import <code class="literal">calculator.js</code> to test it and save the page as <code class="literal">testRunner.html</code>.</p><p>To run the test, let's open the <code class="literal">testRunner.html</code> file in your web browser.</p><p>The <code class="literal">testRunner.html</code> file will look like this:</p><pre class="programlisting">&lt;!DOCTYPE html&gt; &#13;
&lt;html&gt; &#13;
&lt;head&gt; &#13;
  &lt;title&gt;Test Runner&lt;/title&gt; &#13;
&lt;/head&gt; &#13;
&lt;body&gt; &#13;
 &#13;
&lt;script src="calculator.js"&gt;&lt;/script&gt; &#13;
&lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>The test suite is ready for the project and the development to-do list for the features is ready as well. The next step is to dive into the TDD life cycle based on the feature list one by one.</p></div><div class="section" title="Test first"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Test first</h2></div></div></div><p>Though it's easy to write a multiplication function and it will work as its a pretty simple feature, as a part of practicing TDD, it's time to follow the TDD life cycle. The first phase of the life cycle is to write a test based on the development to-do list.</p><p>Here are the steps for the first test:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open <code class="literal">calculator.js</code>.</li><li class="listitem">Create a new function <code class="literal">multipleTest1</code> to test multiplying <span class="emphasis"><em>3 * 3, </em></span>after that <code class="literal">calculator.js</code> file will look as follows:</li></ol></div><pre class="programlisting">        function multipleTest1() { &#13;
            // Test &#13;
            var result = calculator.multiply(3, 3); &#13;
 &#13;
            // Assert Result is expected &#13;
            if (result === 9) { &#13;
                console.log('Test Passed'); &#13;
            } else { &#13;
                console.log('Test Failed'); &#13;
            } &#13;
        };  &#13;
&#13;
        multipleTest1();</pre><p>The test calls a <code class="literal">multiply</code> function, which still needs to be defined. It then asserts that the results are as expected by displaying a pass or fail message.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note3"/>Note</h3><p>Keep in mind that in TDD, you are looking at the use of the method and explicitly writing how it should be used. This allows you to define the interface based on a use case, as opposed to only looking at the limited scope of the function being developed.</p></div></div><p>The next step in the TDD life cycle is focused on making the test run.</p></div><div class="section" title="Make the test run"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Make the test run</h2></div></div></div><p>In this step, we will run the test, just as the tailor did with the suite. The measurements were taken in the test step, and now the application can be molded to fit the measurements.</p><p>The following are the steps to run the test:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open <code class="literal">testRunner.html</code> on a web browser.</li><li class="listitem">Open the JavaScript developer <span class="strong"><strong>Console</strong></span> window in the browser.</li></ol></div><p>The test will throw an error, which will be visible in the browser's developer console, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/5405_01_01.jpg" alt="Make the test run"/></div><p>
</p><p>The error thrown is expected as the calculator application calls a function that hasn't been created yet--<code class="literal">calculator.multiply</code>.</p><p>In TDD, the focus is on adding the easiest change to get a test to pass. There is no need to actually implement the multiplication logic. This may seem unintuitive. The point is that once a passing test exists, it should always pass. When a method contains fairly complex logic, it is easier to run a passing test against it to ensure that it meets the expectations.</p><p>What is the easiest change that can be made to make the test pass? By returning the expected value of <code class="literal">9</code>, the test should pass. Although this won't add the multiply feature, it will confirm the application wiring. In addition, after we have passed the test, making future changes will be easy as we have to simply keep the test passing!</p><p>Now, add the <code class="literal">multiply</code> function and have it return the required value of <code class="literal">9</code>, as illustrated:</p><pre class="programlisting">var calculator = { &#13;
    multiply : function() { &#13;
        return 9; &#13;
    } &#13;
}; &#13;
</pre><p>Now, let's refresh the page to rerun the test and look at the JavaScript console. The result should be as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_01_002-1.jpg" alt="Make the test run"/></div><p>
</p><p>Yes! No more errors. There's a message showing that test has been passed.</p><p>Now that there is a passing test, the next step will be to remove the hard coded value from   the <code class="literal">multiply</code> function.</p></div><div class="section" title="Make the project better"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Make the project better</h2></div></div></div><p>The refactoring step needs to remove the hard coded <code class="literal">return</code> value from the <code class="literal">multiply</code> function, which we added as the easiest solution to pass the test, and add the required logic to get the expected result.</p><p>The required logic is as follows:</p><pre class="programlisting">var calculator = { &#13;
    multiply : function(amount1, amount2) { &#13;
        return amount1 * amount2; &#13;
    } &#13;
}; &#13;
</pre><p>Now, let's refresh the browser to rerun the tests; It will pass the test as it did earlier. Excellent! Now the <code class="literal">multiply</code> function is complete.</p><p>The full code of the <code class="literal">calculator.js</code> file for the <code class="literal">calculator</code> object with its test will look as follows:</p><pre class="programlisting">var calculator = { &#13;
    multiply : function(amount1, amount2) { &#13;
        return amount1 * amount2; &#13;
    } &#13;
}; &#13;
 &#13;
function multipleTest1() { &#13;
    // Test &#13;
    var result = calculator.multiply(3, 3); &#13;
    &#13;
    // Assert Result is expected &#13;
    if (result === 9) { &#13;
        console.log('Test Passed'); &#13;
    } else { &#13;
        console.log('Test Failed'); &#13;
    } &#13;
}&#13;
 &#13;
multipleTest1(); &#13;
</pre></div></div>
<div class="section" title="Mechanism of testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec9"/>Mechanism of testing</h1></div></div></div><p>To be a proper TDD-following developer, it is important to understand some fundamental mechanisms of testing techniques and approaches to testing. In this section, we will walk through a couple of examples of testing techniques and mechanisms that will be leveraged in this book.</p><p>This will mostly include the following points:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Testing doubles with <span class="strong"><strong>Jasmine</strong></span> spies</li><li class="listitem" style="list-style-type: disc">Refactoring the existing tests</li><li class="listitem" style="list-style-type: disc">Building patterns</li></ul></div><p>Here are the additional terms that will be used:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Function under test</strong></span>: This is the function that is being tested. It is also referred to as system under test, object under test, and so on.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The 3 As (Arrange, Act, and Assert)</strong></span>: This is a technique used to set up tests, first described by Bill Wake (<a class="ulink" href="http://xp123.com/articles/3a-arrange-act-assert/">http://xp123.com/articles/3a-arrange-act-assert/</a>). The 3 As will be discussed further in <a class="link" href="ch02.html" title="Chapter 2. Details of JavaScript Testing">Chapter 2</a>, <span class="emphasis"><em>Details of JavaScript Testing</em></span>.</li></ul></div><div class="section" title="Testing with a framework"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Testing with a framework</h2></div></div></div><p>We have already seen a quick and simple way to perform tests on the calculator application, where we have set the test for the <code class="literal">multiply</code> method. But in real life, it will be more complex and a way larger application, where the earlier technique will be too complex to manage and perform. In that case, it will be handy and easier to use a testing framework. A testing framework provides methods and structures to test. This includes a standard structure to create and run tests, the ability to create assertions/expectations, the ability to use test doubles, and a lot more. This book uses Jasmine as the test framework. Jasmine is a behavior-driven testing framework. It is highly compatible with testing Angular applications. In <a class="link" href="ch02.html" title="Chapter 2. Details of JavaScript Testing">Chapter 2</a>, <span class="emphasis"><em>Details of JavaScript Testing</em></span>, we will take an in-depth look at Jasmine.</p><p>The following example code is not exactly how it runs with the Jasmine test/spec runner, it's just about the idea of how the doubles work or how these doubles return the expected result. In <a class="link" href="ch02.html" title="Chapter 2. Details of JavaScript Testing">Chapter 2</a>, <span class="emphasis"><em>Details of JavaScript Testing,</em></span> we will demonstrate exactly how this double should be used with the Jasmine spec runner.</p></div><div class="section" title="Testing doubles with Jasmine spies"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Testing doubles with Jasmine spies</h2></div></div></div><p>A test double is an object that acts as and is used in place of another object. Jasmine has a test double function which is known as <code class="literal">spies</code>. A Jasmine spy is used with the <code class="literal">spyOn()</code> method.</p><p>Let's take a look at the following <code class="literal">testableObject</code> object that needs to be tested. Using a test double, we can determine the number of times <code class="literal">testableFunction</code> gets called.</p><p>The following is an example of a test double:</p><pre class="programlisting">var testableObject = { &#13;
    testableFunction : function() { } &#13;
}; &#13;
jasmine.spyOn(testableObject, 'testableFunction'); &#13;
 &#13;
testableObject.testableFunction(); &#13;
testableObject.testableFunction(); &#13;
testableObject.testableFunction(); &#13;
 &#13;
console.log(testableObject.testableFunction.count); &#13;
</pre><p>The preceding code creates a test double using a Jasmine spy (<code class="literal">jasmine.spyOn</code>). The following are some of the features that a Jasmine test double offers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The count of calls on a function</li><li class="listitem" style="list-style-type: disc">The ability to specify a return value (stub a return value)</li><li class="listitem" style="list-style-type: disc">The ability to pass a call to the underlying function (pass through)</li></ul></div><p>Throughout this book, we will gain further experience in the use of test doubles.</p><div class="section" title="Stubbing a return value"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec3"/>Stubbing a return value</h3></div></div></div><p>The great thing about using a test double is that the underlying code of a method does not have to be called. With a test double, we can specify exactly what a method should return for a given test.</p><p>Consider the following example of an object and a function, where the function returns a string:</p><pre class="programlisting">var testableObject = { &#13;
    testableFunction : function() { return 'stub me'; } &#13;
}; &#13;
</pre><p>The preceding object, <code class="literal">testableObject</code>, has a function, <code class="literal">testableFunction</code>, that needs to be stubbed.</p><p>So, to stub the single return value, it will need to chain the <code class="literal">and.returnValue</code> method and will pass the expected value as <code class="literal">param</code>.</p><p>Here is how to spy chain the single return value to stub it:</p><pre class="programlisting">jasmine.spyOn(testableObject, 'testableFunction') &#13;
.and &#13;
.returnValue('stubbed value'); &#13;
</pre><p>Now, when <code class="literal">testableObject.testableFunction</code> is called, <code class="literal">stubbed value</code> will be returned.</p><p>Consider the following example of the preceding single <code class="literal">stubbed value</code>:</p><pre class="programlisting">var testableObject = { &#13;
    testableFunction : function() { return 'stub me'; } &#13;
}; &#13;
//before the return value is stubbed &#13;
Console.log(testableObject.testableFunction()); &#13;
//displays 'stub me' &#13;
 &#13;
jasmine.spyOn(testableObject,'testableFunction') &#13;
.and &#13;
.returnValue('stubbed value'); &#13;
 &#13;
//After the return value is stubbed &#13;
Console.log(testableObject.testableFunction()); &#13;
//displays 'stubbed value' &#13;
</pre><p>Similarly, we can pass multiple returned values as in the preceding example.</p><p>Here is how to spy chain the multiple return values to stub them one by one:</p><pre class="programlisting">jasmine.spyOn(testableObject, 'testableFunction') &#13;
.and &#13;
.returnValues('first stubbed value', 'second stubbed value', 'third stubbed value'); &#13;
</pre><p>So, for every call of <code class="literal">testableObject.testableFunction</code>, it will return the stubbed value in order until it reaches the end of the return value list.</p><p>Consider the example of the preceding multiple stubbed values:</p><pre class="programlisting">jasmine.spyOn(testableObject, 'testableFunction') &#13;
.and &#13;
.returnValue('first stubbed value', 'second stubbed value', 'third stubbed value'); &#13;
 &#13;
//After the is stubbed return values &#13;
Console.log(testableObject.testableFunction()); &#13;
//displays 'first stubbed value' &#13;
Console.log(testableObject.testableFunction()); &#13;
//displays 'second stubbed value' &#13;
Console.log(testableObject.testableFunction()); &#13;
//displays 'third stubbed value' &#13;
</pre></div><div class="section" title="Testing arguments"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec4"/>Testing arguments</h3></div></div></div><p>A test double provides insights into how a method is used in an application. As an example, a test might want to assert what arguments a method was called with or the number of times a method was called. Here is an example function:</p><pre class="programlisting">var testableObject = { &#13;
    testableFunction : function(arg1, arg2) {} &#13;
}; &#13;
</pre><p>The following are the steps to test the arguments with which the preceding function is called:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a spy so that the arguments called can be captured:<pre class="programlisting">        jasmine.spyOn(testableObject, 'testableFunction'); &#13;
</pre></li><li class="listitem">Then, to access the arguments, run the following:</li></ol></div><pre class="programlisting">        //Get the arguments for the first call of the function &#13;
        var callArgs = testableObject.testableFunction&#13;
        .call.argsFor(0); &#13;
 &#13;
        console.log(callArgs); &#13;
        //displays ['param1', 'param2'] &#13;
</pre><p>Here is how the arguments can be displayed using <code class="literal">console.log</code>:</p><pre class="programlisting">var testableObject = { &#13;
    testableFunction : function(arg1, arg2) {} &#13;
}; &#13;
//create the spy &#13;
jasmine.spyOn(testableObject, 'testableFunction'); &#13;
 &#13;
//Call the method with specific arguments &#13;
  testableObject.testableFunction('param1', 'param2'); &#13;
 &#13;
//Get the arguments for the first call of the function &#13;
var callArgs = testableObject.testableFunction.call.argsFor(0); &#13;
 &#13;
console.log(callArgs); &#13;
//displays ['param1', 'param2'] &#13;
</pre></div></div><div class="section" title="Refactoring"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Refactoring</h2></div></div></div><p>Refactoring is the act of restructuring, rewriting, renaming, and removing code in order to improve the design, readability, maintainability, and overall aesthetics of a piece of code. The TDD life cycle step of <span class="emphasis"><em>making the project   better</em></span> is primarily concerned with refactoring. This section will walk us through a refactoring example.</p><p>Take a look at the following example of a function that needs to be refactored:</p><pre class="programlisting">var abc = function(z) { &#13;
    var x = false; &#13;
    if(z &gt; 10) &#13;
        return true; &#13;
    return x; &#13;
} &#13;
</pre><p>This function works fine and does not contain any syntactical or logical issues. The problem is that the function is difficult to read and understand. Refactoring this function will improve its naming, structure, and definition. The exercise will remove the masquerading complexity and reveal the function's true meaning and intention.</p><p>Here are the steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Rename the function and variable names to be more meaningful, that is, rename <code class="literal">x</code> and <code class="literal">z</code> so that they make sense:<pre class="programlisting">        var isTenOrGreater = function(value) { &#13;
            var falseValue = false; &#13;
            if(value &gt; 10) &#13;
                return true; &#13;
            return falseValue; &#13;
        } &#13;
</pre><p>Now, the function can easily be read and the naming makes sense.</p></li><li class="listitem">Remove any unnecessary complexity. In this case, the <code class="literal">if</code> conditional statement can be removed completely, as follows:<pre class="programlisting">        var isTenOrGreater = function(value) { &#13;
            return value &gt; 10; &#13;
        }; &#13;
</pre></li><li class="listitem">Reflect on the result.</li></ol></div><p>At this point, the refactoring is complete, and the function's purpose should jump out at you. The next question that should be asked is: "Why does this method exist in the first place?".</p><p>This example only provided a brief walk-through of the steps that can be taken to identify the issues in code and how to improve them. Other examples will be given throughout this book.</p></div><div class="section" title="Building with a builder"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Building with a builder</h2></div></div></div><p>These days, the design pattern is kind of a common practice, and we follow the design patterns to make life easier. For the same reason, the builder pattern will be followed here.</p><p>The builder pattern uses a <code class="literal">builder</code> object to create another object. Imagine an object with 10 properties. How will test data be created for every property? Will the object have to be recreated in every test?</p><p>A <code class="literal">builder</code> object defines an object to be reused across multiple tests. The following code snippet provides an example of the use of this pattern. This example will use the <code class="literal">builder</code> object in the <code class="literal">validate</code> method:</p><pre class="programlisting">var book = { &#13;
    id : null, &#13;
    author : null, &#13;
    dateTime : null &#13;
}; &#13;
</pre><p>The <code class="literal">book</code> object has three properties: <code class="literal">id</code>, <code class="literal">author</code>, and <code class="literal">dateTime</code>. From a testing perspective, we would want the ability to create a valid object, that is, one that has all the fields defined. We may also want to create an invalid object with missing properties, or we may want to set certain values in the object to test the validation logic. Like here <code class="literal">dateTime</code> is an actual date time, which should assign by builder object.</p><p>Here are the steps to create a builder for the <code class="literal">bookBuilder</code> object:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a builder function, as shown here:<pre class="programlisting">        var bookBuilder = function() {}; &#13;
</pre></li><li class="listitem">Create a valid object within the builder, as follows:<pre class="programlisting">        var bookBuilder = function() { &#13;
            var _resultBook = { &#13;
                id: 1, &#13;
                author: 'Any Author', &#13;
                dateTime: new Date() &#13;
            }; &#13;
        } &#13;
</pre></li><li class="listitem">Create a function to return the built object:<pre class="programlisting">        var bookBuilder = function() { &#13;
            var _resultBook = { &#13;
                id: 1, &#13;
                author: "Any Author", &#13;
                dateTime: new Date() &#13;
            }; &#13;
            this.build = function() { &#13;
                return _resultBook; &#13;
            } &#13;
        } &#13;
</pre></li><li class="listitem">As illustrated, create another function to set the <code class="literal">_resultBook</code> author field:<pre class="programlisting">        var bookBuilder = function() { &#13;
            var _resultBook = { &#13;
                id: 1, &#13;
                author: 'Any Author', &#13;
                dateTime: new Date() &#13;
            }; &#13;
            this.build = function() { &#13;
                return _resultBook; &#13;
            }; &#13;
            this.setAuthor = function(author){ &#13;
                _resultBook.author = author; &#13;
            }; &#13;
        }; &#13;
</pre></li><li class="listitem">Change the function definition so that calls can be chained:<pre class="programlisting">        this.setAuthor = function(author) { &#13;
            _resultBook.author = author; &#13;
            return this; &#13;
        }; &#13;
</pre></li><li class="listitem">A setter function will also be created for <code class="literal">dateTime</code>, as shown here:<pre class="programlisting">        this.setDateTime = function(dateTime) { &#13;
            _resultBook.dateTime = dateTime; &#13;
            return this; &#13;
        }; &#13;
</pre></li></ol></div><p>Now, <code class="literal">bookBuilder</code> can be used to create a new book, as follows:</p><pre class="programlisting">var bookBuilder = new bookBuilder(); &#13;
 &#13;
var builtBook = bookBuilder.setAuthor('Ziaul Haq') &#13;
.setDateTime(new Date()) &#13;
.build(); &#13;
console.log(builtBook.author); // Ziaul Haq &#13;
</pre><p>The preceding builder can now be used throughout our tests to create a single consistent object.</p><p>Here is the complete builder for reference:</p><pre class="programlisting">var bookBuilder = function() { &#13;
    var _resultBook = { &#13;
        id: 1, &#13;
        author: 'Any Author', &#13;
        dateTime: new Date() &#13;
    }; &#13;
    &#13;
    this.build = function() { &#13;
        return _resultBook; &#13;
    }; &#13;
 &#13;
    this.setAuthor = function(author) { &#13;
        _resultBook.author = author; &#13;
        return this; &#13;
    }; &#13;
  &#13;
    this.setDateTime = function(dateTime) { &#13;
        _resultBook.dateTime = dateTime; &#13;
        return this; &#13;
    }; &#13;
}; &#13;
</pre><p>Let's create the <code class="literal">validate</code> method to validate the created book object from the builder:</p><pre class="programlisting">var validate = function(builtBookToValidate){ &#13;
    if(!builtBookToValidate.author) { &#13;
        return false; &#13;
    } &#13;
    if(!builtBookToValidate.dateTime) { &#13;
        return false; &#13;
    } &#13;
    return true; &#13;
}; &#13;
</pre><p>Let's start by creating a valid book object with the builder by passing all the required information, and if this is passed via the <code class="literal">validate</code> object, this should show a valid message:</p><pre class="programlisting">var validBuilder = new bookBuilder().setAuthor('Ziaul Haq') &#13;
.setDateTime(new Date()) &#13;
.build(); &#13;
 &#13;
// Validate the object with validate() method &#13;
if (validate(validBuilder)) { &#13;
    console.log('Valid Book created'); &#13;
} &#13;
</pre><p>In the same way, let's create an invalid book object via the builder by passing some null value in the required information. And by passing the object to the <code class="literal">validate</code> method, it should show the message explaining why it's invalid:</p><pre class="programlisting">var invalidBuilder = new bookBuilder().setAuthor(null).build(); &#13;
 &#13;
if (!validate(invalidBuilder)) { &#13;
    console.log('Invalid Book created as author is null'); &#13;
} &#13;
 &#13;
var invalidBuilder = new bookBuilder().setDateTime(null).build(); &#13;
 &#13;
if (!validate(invalidBuilder)) { &#13;
    console.log('Invalid Book created as dateTime is null'); &#13;
} &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip4"/>Tip</h3><p><span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books that you have purchased. If you have purchased this book from elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div></div>
<div class="section" title="Self-test questions"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Self-test questions</h1></div></div></div><p>Q1. A test double is another name for a duplicate test.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">True</li><li class="listitem">False</li></ol></div><p>Q2. TDD stands for test-driven development.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">True</li><li class="listitem">False</li></ol></div><p>Q3. The purpose of refactoring is to improve code quality.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">True</li><li class="listitem">False</li></ol></div><p>Q4. A test object builder consolidates the creation of objects for testing.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">True</li><li class="listitem">False</li></ol></div><p>Q5. The 3 As are a sports team.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">True</li><li class="listitem">False</li></ol></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Summary</h1></div></div></div><p>This chapter provided an introduction to TDD. It discussed the TDD life cycle (test first, make it run, and make it better) and these steps can be used by anybody for TDD approach similar to how we have saw being used by a tailor. Finally, it looked over some of the testing techniques that will be discussed throughout this book, including test doubles, refactoring, and building patterns.</p><p>Although TDD is a huge topic, this book is solely focused on the TDD principles and practices to be used with Angular.</p><p>In the next chapter, we will know details about JavaScript testing.</p></div></body></html>