- en: Asynchronous Data Services with Angular
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular进行异步数据服务
- en: Connecting to data services and APIs and handling asynchronous information is
    a common task in our everyday lives as developers. In this sense, Angular provides
    an unparalleled tool set to help its enthusiastic developers when it comes to
    consuming, digesting, and transforming all kinds of data fetched from data services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到数据服务和API，并处理异步信息是我们作为开发人员在日常生活中的常见任务。在这方面，Angular为其热情的开发人员提供了无与伦比的工具集，帮助他们消费、消化和转换从数据服务中获取的各种数据。
- en: There are so many possibilities that it would require an entire book to describe
    all that you can do to connect to APIs or to consume information from the filesystem
    asynchronously through HTTP. In this book, we will only scratch the surface, but
    the insights covered in this chapter about the HTTP API and its companion classes
    and tools will give you all that you need to connect your applications to HTTP
    services in no time, leaving all that you can do with them up to your creativity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有太多的可能性，需要一本整书来描述你可以通过连接到API或通过HTTP异步地从文件系统中消费信息所能做的一切。在本书中，我们只是浅尝辄止，但本章涵盖的关于HTTP
    API及其伴随的类和工具的见解将为您提供一切所需，让您的应用程序在短时间内连接到HTTP服务，而您可以根据自己的创造力来发挥它们的全部潜力。
- en: 'In this chapter, we will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Look at the different strategies for handling asynchronous data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看处理异步数据的不同策略
- en: Introduce Observables and Observers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Observables和Observers
- en: Discuss functional reactive programming and RxJS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论函数式响应式编程和RxJS
- en: Review the HTTP class and its API and learn some nice service patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查HTTP类及其API，并学习一些不错的服务模式
- en: Learn about Firebase and how to connect it to your Angular app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Firebase以及如何将其连接到您的Angular应用程序
- en: See all of the preceding points in action through actual code examples
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实际的代码示例来看待前面提到的所有要点
- en: Strategies for handling asynchronous information
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异步信息的策略
- en: Consuming information from an API is a common operation in our daily practice.
    We consume information over HTTP all the time—when authenticating users by sending
    out credentials to an authentication service, or when fetching the latest tweets
    in our favorite Twitter widget. Modern mobile devices have introduced an unparalleled
    way of consuming remote services by deferring requests and response consumption
    until mobile connectivity is available. Responsivity and availability have become
    a big deal. Although modern internet connections are ultra-fast, there is always
    a response time involved when serving such information that forces us to put in
    place mechanisms to handle states in our applications in a transparent way for
    the end user.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从API中获取信息是我们日常实践中的常见操作。我们一直在通过HTTP获取信息——当通过向认证服务发送凭据来对用户进行身份验证时，或者在我们喜爱的Twitter小部件中获取最新的推文时。现代移动设备引入了一种无与伦比的消费远程服务的方式，即推迟请求和响应消费，直到移动连接可用。响应速度和可用性变得非常重要。尽管现代互联网连接速度超快，但在提供此类信息时总会涉及响应时间，这迫使我们建立机制以透明地处理应用程序中的状态，以便最终用户使用。
- en: This is not specific to scenarios where we need to consume information from
    an external resource.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不局限于我们需要从外部资源消费信息的情景。
- en: Asynchronous response - from callbacks to promises
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步响应-从回调到承诺
- en: Sometimes, we might need to build functionalities that depend on time as a parameter
    of something, and we need to introduce code patterns that handle this deferred
    change in the application state.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能需要构建依赖于时间作为某个参数的功能，并且需要引入处理应用程序状态中这种延迟变化的代码模式。
- en: 'For all these scenarios, we have always used code patterns, such as the callback
    pattern, where the function that triggers the asynchronous action expects another
    function in its signature, which will emit a sort of notification as soon as the
    asynchronous operation is completed, as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 针对所有这些情况，我们一直使用代码模式，比如回调模式，触发异步操作的函数期望在其签名中有另一个函数，该函数在异步操作完成后会发出一种通知，如下所示：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The problem with this pattern is that code can become quite confusing and cumbersome
    as the application grows and more and more nested callbacks are introduced. In
    order to avoid this scenario, `Promises`introduced a new way of envisioning asynchronous
    data management by conforming to a neater and more solid interface, in which different
    asynchronous operations can be chained at the same level and even be split and
    returned from other functions. The following code introduces how to construct
    a `Promise`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的问题在于，随着应用程序的增长和引入越来越多的嵌套回调，代码可能变得相当混乱和繁琐。为了避免这种情况，`Promises`引入了一种新的方式来构想异步数据管理，通过符合更整洁和更稳固的接口，不同的异步操作可以在同一级别链接甚至可以从其他函数中分割和返回。以下代码介绍了如何构造`Promise`：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code example is perhaps a bit more verbose, but it definitely
    produces a more expressive and elegant interface for our function. As for chaining
    data, we need to understand what problem we are solving. We are solving something
    called callback hell, looking like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码示例可能有点冗长，但它确实为我们的函数提供了更具表现力和优雅的接口。至于链式数据，我们需要了解我们要解决的问题。我们正在解决一种称为回调地狱的东西，看起来像这样：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As can be seen in the preceding code, we have a situation where we are dependent
    on the previous async call and the data it brings back before we are able to do
    the next async call. This leads to us having to execute a method inside of a callback
    inside of a callback, and so on and so forth. You get the idea—the code quickly
    ends up looking horrible, also known as *callback hell*. Continuing with the subject
    of chaining async calls, chaining is the answer to *callback hell* and `Promises` allows
    us to chain them, like so:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们有一个情况，即在执行下一个异步调用之前，我们依赖于先前的异步调用和它带回的数据。这导致我们不得不在回调中执行一个方法，然后在回调中执行另一个方法，依此类推。你明白了吧——代码很快就会变得很糟糕，也就是所谓的*回调地狱*。继续讨论链式异步调用的主题，链式是解决*回调地狱*的答案，`Promises`允许我们像这样链接它们：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The chaining of the `.then()`method calls in the preceding code shows how we
    can clearly line up one async call after another, and that the previous async
    call has input its result in the upcoming `async` method.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`.then()`方法调用的链接显示了我们如何清晰地将一个异步调用排在另一个异步调用之后，并且先前的异步调用已经将其结果输入到即将到来的`async`方法中。
- en: 'So, `Promises` take over the coding arena by storm and no developer out there
    seems to question the great value they bring to the game. So, why do we need another
    paradigm? Well, because sometimes we might need to produce a response output that
    follows a more complex digest process as it is being returned, or even cancel
    the whole process. This cannot be done with `Promises`, because they are triggered
    as soon as they''re being instantiated. In other words, `Promises` are not lazy.
    On the other hand, the possibility of tearing down an asynchronous operation after
    it has been fired but not completed yet can become quite handy in certain scenarios.
    `Promises` only allow us to resolve or reject an asynchronous operation, but sometimes
    we might want to abort everything before getting to that point. On top of that,
    `Promises` behave as one-time operations. Once they are resolved, we cannot expect
    to receive any further information or state change notification unless we run
    everything again from scratch. Moreover, we sometimes need a more proactive implementation
    of async data handling. This is where Observables come into the game. To summarize
    the limitations of promises:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，“Promises”以其强大的编码能力风靡编程领域，似乎没有开发人员会质疑它们为游戏带来的巨大价值。那么，为什么我们需要另一种范式呢？嗯，因为有时我们可能需要产生一个响应输出，该输出遵循更复杂的处理过程，甚至取消整个过程。这不能通过“Promises”来实现，因为它们一旦被实例化就会被触发。换句话说，“Promises”不是懒惰的。另一方面，在异步操作被触发但尚未完成之前取消它的可能性在某些情况下可能非常方便。“Promises”只允许我们解决或拒绝异步操作，但有时我们可能希望在达到那一点之前中止一切。此外，“Promises”表现为一次性操作。一旦它们被解决，我们就不能期望收到任何进一步的信息或状态变化通知，除非我们从头开始重新运行一切。此外，我们有时需要更主动地实现异步数据处理。这就是
    Observable 出现的地方。总结一下 Promises 的限制：
- en: They cannot be cancelled
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们无法被取消
- en: They are  immediately executed
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们会立即执行
- en: They are one-time operations only; there is no easy way to retry them
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们只是一次性操作；没有简单的重试方法
- en: They respond with only one value
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们只会响应一个值
- en: Observables in a nutshell
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observable 简而言之
- en: An Observable is basically an async event emitter that informs another element,
    called the Observer, that the state has changed. In order to do so, the Observable
    implements all of the machinery that it needs to produce and emit such async events,
    and it can be fired and canceled at any time regardless of whether it has emitted
    the expected data events already or not.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Observable 基本上是一个异步事件发射器，通知另一个元素，称为观察者，状态已经改变。为了做到这一点，Observable 实现了所有需要产生和发射这样的异步事件的机制，并且可以在任何时候被触发和取消，无论它是否已经发出了预期的数据事件。
- en: This pattern allows concurrent operations and more advanced logic since the
    Observers that subscribe to the Observable async events will react to reflect
    the state change of the Observable they subscribe to.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式允许并发操作和更高级的逻辑，因为订阅 Observable 异步事件的观察者将会反应 Observable 的状态变化。
- en: These subscribers, which are the Observers we mentioned earlier, will keep listening
    to whatever happens in the Observable until the Observable is disposed, if that
    happens eventually. In the meantime, information will be updated throughout the
    application with no intention whatsoever of triggering routines.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些订阅者，也就是我们之前提到的观察者，会一直监听 Observable 中发生的任何事情，直到 Observable 被处理掉，如果最终发生的话。与此同时，信息将在整个应用程序中更新，而不会触发例行程序。
- en: 'We can probably see all this with more transparency in an actual example. Let''s
    refactor the example we covered when assessing promise-based async operations
    and replace the `setTimeout` command with `setInterval`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能可以在一个实际的例子中更透明地看到所有这些。让我们重新设计我们在评估基于 Promise 的异步操作时涵盖的示例，并用“setInterval”命令替换“setTimeout”命令：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Copy and paste the preceding snippet in your browser's console window and see
    what happens. The text `Our asynchronous operation has been completed` will show
    up at the dev tools' console only once after 2 seconds and will never be rendered
    again. The promise resolved itself and the entire async event was terminated at
    that very moment.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 复制并粘贴上述片段到浏览器的控制台窗口，看看会发生什么。文本“我们的异步操作已经完成”将在2秒后只显示一次，并且不会再次呈现。承诺自行解决，整个异步事件在那一刻终止。
- en: 'Now, point your browser to an online JavaScript code playground such as JSBIN
    ([https://jsbin.com/](https://jsbin.com/)), and create a new code snippet enabling
    just the JavaScript and the Console tabs. Then, make sure you add the RxJS library
    from the Add library option dropdown (we will need this library to create Observables,
    but don''t panic; we will cover this later in this chapter) and insert the following
    code snippet:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将浏览器指向在线JavaScript代码 playground，比如JSBIN（[https://jsbin.com/](https://jsbin.com/)），并创建一个新的代码片段，只启用JavaScript和Console选项卡。然后，确保您从“添加库”选项下拉菜单中添加RxJS库（我们将需要这个库来创建Observables，但不要惊慌；我们将在本章后面介绍这个库），并插入以下代码片段：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run it and expect a message to appear on the right pane. 2 seconds later, we
    will see the same message showing up, and then again and again. In this simple
    example, we created an `observable` and then subscribed to its changes, throwing
    to the console whatever it emitted (a simple message, in this example) as a sort
    of push notification.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它，并期望在右窗格上出现一条消息。2秒后，我们将看到相同的消息出现，然后再次出现。在这个简单的例子中，我们创建了一个“observable”，然后订阅了它的变化，将其发出的内容（在这个例子中是一个简单的消息）作为一种推送通知输出到控制台。
- en: The Observable returns a stream of events and our subscribers receive prompt
    notification of those streamed events, so they can act accordingly. This is what
    the magic of Observables relies on—Observables do not perform an async operation
    and die (although we can configure them to do so), but start a stream of continuous
    events we can subscribe our subscribers to.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Observable返回一系列事件，我们的订阅者会及时收到这些事件的通知，以便他们可以相应地采取行动。这就是Observable的魔力所在——Observable不执行异步操作并终止（尽管我们可以配置它们这样做），而是开始一系列连续的事件，我们可以订阅我们的订阅者。
- en: If we comment out the last line, nothing will happen. The console pane will
    remain silent and all the magic will begin only when we subscribe our source object.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们注释掉最后一行，什么也不会发生。控制台窗格将保持沉默，所有的魔法将只在我们订阅我们的源对象时开始。
- en: That's not all, however. This stream can be the subject of many operations before
    they hit the Observers subscribed to them. Just as we can grab a collection object,
    such as an array, and apply functional methods over it such as `map()` or `filter()`in
    order to transform and play around with the array items, we can do the same with
    the stream of events that are emitted by our Observables. This is what is known
    as reactive functional programming, and Angular makes the most of this paradigm
    to handle asynchronous information.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这还不是全部。在这些事件到达订阅者之前，这个流可以成为许多操作的主题。就像我们可以获取一个集合对象，比如数组，并对其应用`map()`或`filter()`等函数方法来转换和操作数组项一样，我们也可以对我们的Observable发出的事件流进行相同的操作。这就是所谓的响应式函数编程，Angular充分利用这种范式来处理异步信息。
- en: Reactive functional programming in Angular
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Angular中的响应式函数编程
- en: 'The Observable pattern stands at the core of what we know as reactive functional
    programming. Basically, the most basic implementation of a reactive functional
    script encompasses several concepts that we need to become familiar with:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Observable模式是我们所知的响应式函数编程的核心。基本上，响应式函数脚本的最基本实现涵盖了我们需要熟悉的几个概念：
- en: An Observable
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察对象
- en: An Observer
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者
- en: A timeline
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间线
- en: A stream of events featuring the same behavior as an object's collection
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列具有与对象集合相同行为的事件
- en: A set of composable operators, also known as Reactive Extensions
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组可组合的操作符，也称为响应式扩展
- en: Sounds daunting? It's not. Believe us when we tell you that all of the code
    you have gone through so far is much more complex than this. The big challenge
    here is to change your mindset and learn to think in a reactive fashion, and that
    is the main goal of this section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来令人生畏？其实不是。相信我们告诉你，到目前为止你所经历的所有代码比这复杂得多。这里的重大挑战是改变你的思维方式，学会以一种反应式的方式思考，这是本节的主要目标。
- en: To put it simply, we can just say that reactive programming entails applying
    asynchronous subscriptions and transformations to Observable streams of events.
    We can imagine your poker face right now, so let's put together a more descriptive
    example.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们可以说，响应式编程涉及将异步订阅和转换应用于事件的Observable流。我们可以想象你现在的无表情，所以让我们组合一个更具描述性的例子。
- en: 'Think about an interaction device such as a keyboard. A keyboard has keys that
    the user presses. Each one of those key strokes triggers a key press event. That
    key press event features a wide range of metadata, including—but not limited to—the
    numeric code of the specific key the user pressed at a given moment. As the user
    continues hitting keys, more **keyUp** events are triggered and piped through
    an imaginary timeline. The timeline of keyUp events should look like the following
    diagram:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 想想交互设备，比如键盘。键盘上有用户按下的按键。用户按下每一个按键都会触发一个按键事件。该按键事件包含大量元数据，包括但不限于用户在特定时刻按下的特定按键的数字代码。当用户继续按键时，会触发更多的**keyUp**事件，并通过一个虚拟时间线传输。keyUp事件的时间线应该如下图所示：
- en: '![](assets/980af034-ac9f-4795-bf54-820c5e6674c8.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/980af034-ac9f-4795-bf54-820c5e6674c8.png)'
- en: 'What you can see from the preceding timeline of keyUps is that it is a continuous
    stream of data where the keyUp event can happen at any time; after all, the user
    decides when to press those keys. Remember the Observable code we wrote, containing
    the `setTimeout`? That code was able to tell a concept Observer that every time
    2 seconds passed, another value should be emitted. What''s the difference between
    that code and our keyUps? Nothing. Well, we know how often a timer interval is
    triggered, and with keyUps, we don''t really know because it is not in our hands.
    But that is really the only difference, which means keyUps can be thought of as
    an Observable as well:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的keyUps时间线中可以看出，这是一系列连续的数据，其中keyUp事件可以在任何时候发生；毕竟，用户决定何时按下这些按键。还记得我们写的Observable代码，包含`setTimeout`吗？那段代码能够告诉一个概念观察者，每隔2秒就应该发出另一个值。那段代码和我们的keyUps有什么区别？没有。嗯，我们知道定时器间隔触发的频率，而对于keyUps，我们并不知道，因为这不在我们的控制之中。但这真的是唯一的区别，这意味着keyUps也可以被视为一个Observable：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So, what I am really telling you is that timeout as well as keyUps can be thought
    as one and the same concept, the Observable. That makes it easier to understand
    all things async. There is, however, another observation we need to make, namely
    that whatever async concept occurs, it occurs in a list-like way.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我真正告诉你的是，超时以及keyUps可以被视为同一个概念，即Observable。这样更容易理解所有异步事物。然而，我们还需要另一个观察，即无论发生什么异步概念，它都是以列表的方式发生的。
- en: 'Even though the time might differ, it''s still a series of events, like a list.
    A list usually has a bunch of methods on it to project, filter, or in other ways
    manipulate its element, and guess what, so do Observables. A list can perform
    tricks like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管时间可能不同，但它仍然是一系列事件，就像一个列表。列表通常有一堆方法来投影、过滤或以其他方式操作它的元素，猜猜，Observable也可以。列表可以执行这样的技巧：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So can Observables, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Observables可以如下：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The difference is just in the naming at this point. For a list, `.map()` and `.filter()`are
    called methods. For an Observable, the same methods are called Reactive Extensions
    or operators. Imagine at this point that `keyUps`and timeouts can be described
    as Observables and that we have operators to manipulate data. Now, take the bigger
    leap of realizing that anything async, even HTTP calls, can be thought of as Observables.
    This means that we can suddenly mix and match anything async. This enables something
    called **rich composition**. Whatever the async concept is, it and its data can
    be thought of as a stream, and you are a wizard that can bend it to your will.
    Feel empowered—you can now turn your application into a reactive architecture.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，区别只是命名不同。对于列表，`.map()`和`.filter()`被称为方法。对于Observable，相同的方法被称为Reactive
    Extensions或操作符。想象一下，在这一点上，`keyUps`和超时可以被描述为Observables，并且我们有操作符来操作数据。现在，更大的飞跃是意识到任何异步的东西，甚至是HTTP调用，都可以被视为Observables。这意味着我们突然可以混合和匹配任何异步的东西。这使得一种称为**丰富组合**的东西成为可能。无论异步概念是什么，它和它的数据都可以被视为一个流，你是一个可以按照自己的意愿来弯曲它的巫师。感到有力量——你现在可以将你的应用程序转变为一个反应式架构。
- en: The RxJS library
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxJS库
- en: 'As mentioned previously, Angular comes with a peer dependency on RxJS, the
    JavaScript flavor of the ReactiveX library that allows us to create Observables
    and Observable sequences out of a large variety of scenarios, such as:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Angular依赖于RxJS，这是ReactiveX库的JavaScript版本，它允许我们从各种情景中创建Observables和Observable序列，比如：
- en: Interaction events
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互事件
- en: Promises
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺
- en: Callback functions
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调函数
- en: Events
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: In this sense, reactive programming does not aim to replace asynchronous patterns
    such as promises or callbacks. All the way around, it can leverage them as well
    to create Observable sequences.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个意义上，响应式编程并不旨在取代承诺或回调等异步模式。相反，它也可以利用它们来创建Observable序列。
- en: RxJS comes with built-in support for a wide range of composable operators to
    transform, filter, and combine the resulting event streams. Its API provides convenient
    methods to subscribe Observers to these streams so that our scripts and components
    can respond accordingly to state changes or interaction input. While its API is
    so massive that covering it in detail is out of the scope of this book, we will
    highlight some bits of its most basic implementation in order for you to better
    understand how HTTP connections are handled by Angular.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS提供了内置支持，用于转换、过滤和组合生成的事件流的广泛的可组合操作符。其API提供了方便的方法来订阅观察者，以便我们的脚本和组件可以相应地对状态变化或交互输入做出响应。虽然其API如此庞大，以至于详细介绍超出了本书的范围，但我们将重点介绍其最基本的实现，以便您更好地理解Angular如何处理HTTP连接。
- en: Before jumping into the HTTP API provided by Angular, let's create a simple
    example of an Observable event stream that we can transform with Reactive Extensions
    and subscribe observers to. To do so, let's use the scenario described in the
    previous section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究Angular提供的HTTP API之前，让我们创建一个简单的Observable事件流的示例，我们可以用Reactive Extensions来转换，并订阅观察者。为此，让我们使用前一节中描述的情景。
- en: 'We envisioned how a user interacting with our application through the keyboard
    can''t turn it into a timeline of keystrokes and, therefore, an event stream.
    Go back to JSBIN, delete the contents of the JavaScript pane, and then write down
    the following snippet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设想用户通过键盘与我们的应用程序进行交互，可以将其转化为按键的时间线，因此成为一个事件流。回到JSBIN，删除JavaScript窗格的内容，然后写下以下片段：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code is pretty self-descriptive. We leverage the `Rx.Observable`
    class and its `fromEvent` method to create an event emitter that streams the `keyup`
    events that take place in the scope of the document object. Each of the event
    objects emitted is a complex object. So, we simplify the streamed objects by mapping
    the event stream onto a new stream that contains only the key codes pertaining
    to each keystroke. The map method is a Reactive Extension that features the same
    behavior as the JavaScript map functional method. This is why we usually refer
    to this code style as reactive functional programming.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码相当自描述。我们利用`Rx.Observable`类及其`fromEvent`方法来创建一个事件发射器，该发射器流式传输在文档对象范围内发生的`keyup`事件。每个发射的事件对象都是一个复杂对象。因此，我们通过将事件流映射到一个新流上，该新流仅包含与每次按键对应的键码，来简化流式传输的对象。`map`方法是一种响应式扩展，具有与JavaScript中的`map`函数方法相同的行为。这就是为什么我们通常将这种代码风格称为响应式函数式编程。
- en: 'All right, so now we have an event stream of numeric keystrokes, but we are
    only interested in observing those events that inform us of hits on the cursor
    keys. We can build a new stream out of an existing stream by applying more Reactive
    Extensions. So, let''s do it with `keyboardStream` by filtering such a stream
    and returning only those events that are related to cursor keys. We will also
    map those events to their text correspondence for the sake of clarity. Append
    the following chunk of code, following the previous snippet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在我们有了一个数字按键的事件流，但我们只对观察那些通知我们光标键击中的事件感兴趣。我们可以通过应用更多的响应式扩展来从现有流构建一个新流。因此，让我们用`keyboardStream`过滤这样一个流，并仅返回与光标键相关的事件。为了清晰起见，我们还将这些事件映射到它们的文本对应项。在前面的片段后面添加以下代码块：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We could have done all of this in a single action by chaining the filter and
    map methods to the `keyboardStream` Observable and then subscribing to its output,
    but it's generally a good idea to separate concerns. By shaping our code in this
    way, we have a generic keyboard events stream that we can reuse later on for something
    completely different. So, our application can scale up while keeping the code
    footprint to a minimum.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以通过将`filter`和`map`方法链接到`keyboardStream` Observable来一次性完成所有操作，然后订阅其输出，但通常最好分开处理。通过以这种方式塑造我们的代码，我们有一个通用的键盘事件流，以后可以完全不同的用途重复使用。因此，我们的应用程序可以扩展，同时保持代码占用空间最小化。
- en: 'Now that we have mentioned subscribers, let''s subscribe to our cursor moves
    stream and print the `move` commands to the console. We type the following statement
    at the end of our script, then clear the console pane, and click on the Output
    tab so that we can have surface to input code in so we can try different code
    statements out:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们提到了订阅者，让我们订阅我们的光标移动流，并将`move`命令打印到控制台。我们在脚本的末尾输入以下语句，然后清除控制台窗格，并单击输出选项卡，以便我们可以在上面输入代码，以便我们可以尝试不同的代码语句：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Click anywhere on the Output pane to put the focus on it and start typing random
    keyboard keys and cursor keys.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 单击输出窗格的任意位置将焦点放在上面，然后开始输入随机键盘键和光标键。
- en: You are probably wondering how we can apply this pattern to an asynchronous
    scenario such as consuming information from an HTTP service. Basically, you have
    so far become used to submitting async requests to AJAX services and then delegating
    the response handling a callback function or just piping it through a promise.
    Now, we will handle the call by returning an Observable. This Observable will
    emit the server response as an event in the context of a stream, which will be
    funneled through the Reactive Extensions to better digest the response.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道我们如何将这种模式应用到从HTTP服务中获取信息的异步场景中。基本上，你到目前为止已经习惯了向AJAX服务提交异步请求，然后通过回调函数处理响应或者通过promise进行处理。现在，我们将通过返回一个Observable来处理调用。这个Observable将在流的上下文中作为事件发出服务器响应，然后通过Reactive
    Extensions进行更好地处理响应。
- en: Introducing the HTTP API
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍HTTP API
- en: 'Now, before we dive into describing what the Angular framework has given us
    in terms of   `HttpClient` service implementation, let''s talk about how we can
    wrap an `XmlHttpRequest` into an Observable. To do that, we first need to realize
    that there is a contract that we need to fulfill to consider it a successful wrapping.
    The contract is made up of the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们深入描述Angular框架在`HttpClient`服务实现方面给我们的东西之前，让我们谈谈如何将`XmlHttpRequest`包装成一个Observable。为了做到这一点，我们首先需要意识到有一个合同需要履行，以便将其视为成功的包装。这个合同由以下内容组成：
- en: Emit any arrived data using `observer.next(data)`
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`observer.next(data)`来发出任何到达的数据
- en: When we don't expect any more data we should call `observer.complete()`
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们不再期望有更多的数据时，我们应该调用`observer.complete()`
- en: Emit any errors using `observer.error(error)`
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`observer.error(error)`来发出任何错误
- en: 'That''s it; its pretty simple really. Let''s see what a `XmlHttpRequest` call
    looks like:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样；实际上非常简单。让我们看看`XmlHttpRequest`调用是什么样子的：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Ok, so we have a typical callback pattern where the `onreadystatechange` property
    points to a method that is being invoked once the data arrives. That''s all we
    need to know to wrap the following code, so let''s do that:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们有一个典型的回调模式，其中`onreadystatechange`属性指向一个方法，一旦数据到达就会被调用。这就是我们需要知道的所有内容来包装以下代码，所以让我们来做吧：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That's it, the wrapping is complete; you have now built your own HTTP service.
    Of course, this isn't much, there are a lot of cases we are not handling, POST,
    PUT, DELETE, caching, and so on. It was, however, important for you to realize
    all the heavy lifting the HTTP service in Angular was doing for you. Another important
    lesson here was how easy it is to take any kind of async API and turn that into
    an Observable that fits in nicely with the rest of our async concepts. So, let's
    continue with Angular's implementation of a HTTP service. We will use the `HttpClient` service
    from this point.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，包装完成了；你现在已经构建了自己的HTTP服务。当然，这还不够，我们还有很多情况没有处理，比如POST、PUT、DELETE、缓存等等。然而，重要的是让你意识到Angular中的HTTP服务为你做了所有繁重的工作。另一个重要的教训是，将任何类型的异步API转换为与我们其他异步概念很好契合的Observable是多么容易。所以，让我们继续使用Angular的HTTP服务实现。从这一点开始，我们将使用`HttpClient`服务。
- en: The `HttpClient` class provides a powerful API that abstracts all the operations
    required to handle asynchronous connections through a variety of HTTP methods,
    handling the responses in an easy and comfortable way. Its implementation was
    considered with a lot of care to ensure that programmers feel at ease while developing
    solutions that take advantage of this class to connect to an API or a data resource.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient`类提供了一个强大的API，它抽象了处理通过各种HTTP方法进行异步连接所需的所有操作，并以一种简单舒适的方式处理响应。它的实现经过了很多精心的考虑，以确保程序员在开发利用这个类连接到API或数据资源的解决方案时感到轻松自在。'
- en: 'In a nutshell, instances of the `HttpClient` class (which has been implemented
    as an `Injectable` resource and can therefore be used in our class constructors
    just by injecting it as a dependency provider) expose a connection method named
    `request()`   to perform any type of HTTP connection. The Angular team has created
    some syntax shortcuts for the most common request operations, such as GET, POST,
    PUT, and every existing HTTP verb. So, creating an async HTTP request is as easy
    as this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`HttpClient`类的实例（已经作为`Injectable`资源实现，并且可以在我们的类构造函数中作为依赖提供者注入）公开了一个名为`request()`的连接方法，用于执行任何类型的HTTP连接。Angular团队为最常见的请求操作（如GET、POST、PUT以及每个现有的HTTP动词）创建了一些语法快捷方式。因此，创建一个异步的HTTP请求就像这样简单：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Also, all of this can be simplified into a single line of code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，所有这些都可以简化为一行代码：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As we can see, the `HttpClient` class connection methods operate by returning
    an Observable stream. This allows us to subscribe Observers to the stream, which
    will process the information accordingly once it is returned, as many times as
    required:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`HttpClient`类的连接方法通过返回一个Observable流来操作。这使我们能够订阅观察者到流中，一旦返回，观察者将相应地处理信息，可以多次进行：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding example, we give the `get()`method a templated type that does
    the type conversion for us. Let''s highlight this bit more:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们给`get()`方法一个模板化类型，它为我们进行了类型转换。让我们更加强调一下这一点：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This very fact saves us from having to deal with a response object directly
    and performing a map operation to turn our JSON into a list of Jedi objects. All
    we have to remember is the URL to our resource and specify a type and what you
    subscribe to is instantly usable for the subscribe of our service.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事实使我们不必直接处理响应对象并执行映射操作将我们的JSON转换为Jedi对象列表。我们只需要记住我们资源的URL，并指定一个类型，你订阅的内容就可以立即用于我们服务的订阅。
- en: By doing this, we can respawn the HTTP request as many times as we need, and
    the rest of our machinery will react accordingly. We can even merge the event
    stream represented by the HTTP call with other related calls, and compose more
    complex Observable streams and data threads. The possibilities are endless.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们可以根据需要重新发起HTTP请求，我们的其余机制将相应地做出反应。我们甚至可以将HTTP调用表示的事件流与其他相关调用合并，并组合更复杂的Observable流和数据线程。可能性是无限的。
- en: Working with headers
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理头部
- en: We mentioned the   `HttpRequest` classes while introducing the `HttpClient`
    class. On a regular basis, you will not need to make use of low-level classes,
    mostly because of the shortcut methods provided by the `HttpClient` class abstract
    and the need to declare the HTTP verb in use (GET, POST, and so on) and the URL
    you want to consume. With that being said, you will sometimes want to introduce
    special HTTP headers in your requests or append query string parameters automatically
    to each request, for argument's sake. That is why these classes can become quite
    handy in certain scenarios. Think of a use case where you want to add an authentication
    token to each request in order to prevent unauthorized users from reading data
    from one of your API endpoints.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍`HttpClient`类时，我们提到了`HttpRequest`类。通常情况下，您不需要使用低级别的类，主要是因为`HttpClient`类提供了快捷方法，并且需要声明正在使用的HTTP动词（GET、POST等）和要消耗的URL。话虽如此，有时您可能希望在请求中引入特殊的HTTP头，或者自动附加查询字符串参数到每个请求中，举例来说。这就是为什么这些类在某些情况下会变得非常方便。想象一个使用情况，您希望在每个请求中添加身份验证令牌，以防止未经授权的用户从您的API端点中读取数据。
- en: 'In the following example, we read an authentication token and append it as
    a header to our request to a data service. Contrary to our example, we will inject
    the `options` hash object straight into the `HttpRequest` constructor, skipping
    the step of creating an object instance. Angular provides a wrapper class for
    defining custom headers as well, and we will take advantage of it in this scenario.
    Let''s suppose we do have an API that expects all requests to include a custom
    header named `Authorization`, attaching the `authToken` that is received when
    logging into the system, which is then persisted in the browser''s local storage
    layer, for instance:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们读取身份验证令牌并将其附加为标头到我们对数据服务的请求。与我们的示例相反，我们将“options”哈希对象直接注入到“HttpRequest”构造函数中，跳过创建对象实例的步骤。Angular还提供了一个包装类来定义自定义标头，我们将在这种情况下利用它。假设我们有一个API，希望所有请求都包括名为“Authorization”的自定义标头，附加在登录系统时收到的“authToken”，然后将其持久化在浏览器的本地存储层中，例如：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Again, we would like to note that apart from this scenario, you will seldom
    need to create custom request configurations, unless you want to delegate the
    creation of request configurations in a factory class or method and reuse the
    same `Http` wrapper all the time. Angular gives you all the flexibility to go
    as far as you wish when abstracting your applications.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，除了这种情况，您很少需要创建自定义请求配置，除非您希望在工厂类或方法中委托请求配置的创建并始终重用相同的“Http”包装器。Angular为您提供了所有的灵活性，可以在抽象化应用程序时走得更远。
- en: Handling errors when performing HTTP requests
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理执行HTTP请求时的错误
- en: Handling errors raised in our requests by inspecting the information returned
    in the `Response` object is actually quite simple. We just need to inspect the
    value of its `Boolean` property, which will return `false` if the HTTP status
    of the response falls somewhere outside of the 2xx range, clearly indicating that
    our request could not be accomplished successfully. We can double-check that by
    inspecting the `status` property to understand the error code or the   `type` 
     property, which can assume the following values: `basic`, `cors`, `default`, `error`,
    or `opaque`. Inspecting the response headers and the `statusText` property of
    the `HttpResponse` object will provide insightful information about the origin
    of the error.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 处理我们请求中引发的错误，通过检查“Response”对象返回的信息实际上非常简单。我们只需要检查其“Boolean”属性的值，如果响应的HTTP状态在2xx范围之外，它将返回“false”，清楚地表明我们的请求无法成功完成。我们可以通过检查“status”属性来双重检查，以了解错误代码或“type”属性，它可以假定以下值：“basic”，“cors”，“default”，“error”或“opaque”。检查响应标头和“HttpResponse”对象的“statusText”属性将提供有关错误来源的深入信息。
- en: 'All in all, we are not meant to inspect those properties on every response
    message we get. Angular provides an Observable operator to catch errors, injecting
    in its signature the `HttpResponse` object we require, to inspect the previous
    properties:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们并不打算在每次收到响应消息时检查这些属性。Angular提供了一个Observable操作符来捕获错误，在其签名中注入我们需要检查的“HttpResponse”对象的先前属性：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Worth noting is that we capture our error by using the `catch()` operator and
    return a new operator by calling `Observable.of(error)` and letting our error
    serve as input for the new Observable we create. This is a week for us to not
    crash the stream, but let it live on. Of course, in a more real scenario, we would
    probably not just create a new Observable, but maybe log the error and return
    something completely different potentially or add some retry logic. The point
    is that with the `catch()` operator, we have a way of capturing the error; how
    you handle it depends on your scenario.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们通过使用`catch()`操作符捕获错误，并通过调用`Observable.of(error)`返回一个新的操作符，让我们的错误作为我们创建的新Observable的输入。这对我们来说是一个不会使流崩溃的方法，而是让它继续存在。当然，在更真实的情况下，我们可能不只是创建一个新的Observable，而是可能记录错误并返回完全不同的东西，或者添加一些重试逻辑。关键是，通过`catch()`操作符，我们有一种捕获错误的方法；如何处理它取决于您的情况。
- en: In a normal scenario, you would want to inspect more data than the error properties,
    aside from logging that information in a more solid exception tracking system.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，您可能希望检查除了错误属性之外的更多数据，除了在更可靠的异常跟踪系统中记录这些信息之外。
- en: Injecting the HttpClient service
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入HttpClient服务
- en: 'The `HttpClient` service can be injected into our own components and custom
    classes by leveraging Angular''s unique dependency injection system. So, if we
    ever need to implement HTTP calls, we need to import the `HttpClientModule`and
    import the `HttpClient` service:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient`服务可以通过利用Angular独特的依赖注入系统注入到我们自己的组件和自定义类中。因此，如果我们需要实现HTTP调用，我们需要导入`HttpClientModule`并导入`HttpClient`服务：'
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the code provided, we just follow up with the `bio` example that we pointed
    out in the previous section. Note how we are importing the `HttpClient` type and
    injecting it as a dependency in the `Biography` constructor.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供的代码中，我们只是按照我们在上一节中指出的`bio`示例进行。请注意我们如何导入`HttpClient`类型，并将其作为依赖项注入到`Biography`构造函数中。
- en: Usually, we need to perform multiple HTTP calls in different parts of our application,
    so it's usually recommended to create a `DataService` and a `DataModule` that
    wraps the `HttpClientModule` and the `HttpClient` service.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们需要在应用程序的不同部分执行多个HTTP调用，因此通常建议创建一个`DataService`和一个`DataModule`，它包装了`HttpClientModule`和`HttpClient`服务。
- en: 'The following is an example of creating such a `DataService`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建这样一个`DataService`的示例：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The corresponding `DataModule` would look like the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的`DataModule`将如下所示：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you want to add your own caching or authorization logic for calling the backend,
    this is the place to do it. Another way is to use `HttpInterceptors`, an example
    of using `HttpInterceptors` will be provided in an upcoming section in this chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想为调用后端添加自己的缓存或授权逻辑，这就是要做的地方。另一种方法是使用`HttpInterceptors`，在本章的即将到来的部分中将提供使用`HttpInterceptors`的示例。
- en: 'Of course, any module that wanted to use this `DataModule` would need to import
    it, like so:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，任何想要使用这个`DataModule`的模块都需要导入它，就像这样：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And any construct in our `FeatureModule` can now inject the `DataService`,
    like so:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`FeatureModule`中的任何构造现在都可以注入`DataService`，就像这样：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A real case study – serving Observable data through HTTP
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个真实的案例研究 - 通过HTTP提供Observable数据
- en: In the previous chapter, we refactored our entire app into models, services,
    pipes, directives, and component files. One of those services was the `TaskService` class,
    which is the bread and butter of our app since it delivers the data that we need
    to build our task list and other related components.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们将整个应用程序重构为模型、服务、管道、指令和组件文件。其中一个服务是`TaskService`类，它是我们应用程序的核心，因为它提供了我们构建任务列表和其他相关组件所需的数据。
- en: 'In our example, the `TaskService`class was contained within the information
    we wanted to deliver. In a real-world scenario, you need to fetch that information
    from a server API or backend service. Let''s update our example to emulate this
    scenario. First, we will remove the task information from the `TaskService` class
    and wrap it into an actual JSON file. Let''s create a new JSON file inside the
    shared folder and populate it with the task information that we had hardcoded
    in the original `TaskService.ts` file, now in JSON format, though:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，TaskService类包含在我们想要传递的信息中。在实际情况下，您需要从服务器API或后端服务中获取该信息。让我们更新我们的示例以模拟这种情况。首先，我们将从TaskService类中删除任务信息，并将其包装成一个实际的JSON文件。让我们在共享文件夹中创建一个新的JSON文件，并用我们在原始TaskService.ts文件中硬编码的任务信息填充它，现在以JSON格式：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With the data properly wrapped in its own file, we can consume it as if it
    were an actual backend service from our `TaskService`client class. However, we
    will need to conduct relevant changes in our main.ts file for that. The reason
    is that despite installing the RxJS bundle when installing all the Angular peer
    dependencies, the reactive functional operators, such as`map()`, do not become
    available straight away. We could import all of them at once by inserting the
    following line of code in some step at the beginning of our application initialisation
    flow, such as the bootstrapping stage in `main.ts`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据正确包装在自己的文件中后，我们可以像使用实际后端服务一样从我们的TaskService客户端类中使用它。但是，为此我们需要在main.ts文件中进行相关更改。原因是，尽管在安装所有Angular对等依赖项时安装了RxJS包，但反应式功能操作符（例如`map()`）并不会立即可用。我们可以通过在应用程序初始化流的某个步骤中插入以下代码行来一次性导入所有这些内容，例如在`main.ts`的引导阶段：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'However, that would import all the reactive functional operators, which will
    not be used at all and will consume an unnecessarily huge amount of bandwidth
    and resources. Instead, the convention is to import only what is needed, so append
    the following import line at the top of the `main.ts` file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这将导入所有反应式功能操作符，这些操作符根本不会被使用，并且会消耗大量带宽和资源。相反，惯例是只导入所需的内容，因此在main.ts文件的顶部追加以下导入行：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When a reactive operator is imported this way, it gets automatically added to
    the Observable prototype, being then available for use throughout the entire application.
    It should be said that the concept of lettable operators was just introduced per
    RxJS 5.5\. At the time of this book's writing we are just in the shift of patching
    the Operator prototype, as described above and moving into the lettable operator
    space. For the interested reader, please have a look at this article that describes
    in detail what this will mean for your code. The changes are not that big, but
    there is still change: [https://blog.angularindepth.com/rxjs-understanding-lettable-operators-fe74dda186d3 ](https://blog.angularindepth.com/rxjs-understanding-lettable-operators-fe74dda186d3)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当以这种方式导入反应式操作符时，它会自动添加到Observable原型中，然后可以在整个应用程序中使用。应该说，可讳操作符的概念刚刚在RxJS 5.5中引入。在撰写本书时，我们刚刚在修补操作员原型的转变中，如上所述，并进入可讳操作符空间。对于感兴趣的读者，请查看这篇文章，其中详细描述了这对您的代码意味着什么。更改并不是很大，但仍然有变化：[https://blog.angularindepth.com/rxjs-understanding-lettable-operators-fe74dda186d3](https://blog.angularindepth.com/rxjs-understanding-lettable-operators-fe74dda186d3)
- en: Leveraging HTTP – refactoring our TaskService to use HTTP service
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用HTTP - 重构我们的TaskService以使用HTTP服务
- en: With all the dependencies properly in place, the time has come to refactor
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 所有依赖项都已经就位，现在是重构的时候了
- en: 'our `TaskService.ts` file. Open the service file and let''s update the import
    statements block:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的TaskService.ts文件。打开服务文件，让我们更新导入语句块：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'First, we import in the `HttpClient` and `Response` symbols so that we can
    annotate our objects later on. The Observable symbol is imported from the RxJS
    library so that we can properly annotate the return types of our async HTTP requests.
    We also import `Task` as a model (it is an interface) from the file `task.model.ts`,
    as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入`HttpClient`和`Response`符号，以便稍后可以注释我们的对象。Observable符号是从RxJS库导入的，以便我们可以正确注释我们的异步HTTP请求的返回类型。我们还从文件`task.model.ts`导入`Task`作为模型（它是一个接口），如下所示：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We will refactor this service using two steps:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过两个步骤重构此服务：
- en: Rewrite the service to use the HTTP service.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写服务以使用HTTP服务。
- en: Implement a store/feed pattern and give the service a state.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现存储/反馈模式并给服务一个状态。
- en: Using the Angular HTTP service
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular HTTP服务
- en: 'Now, we will replace the existing implementation using static data inside of
    the service to one using the HTTP service. To do this, we call the `http.get()` method
    on the HTTP service to fetch data, but we also need to use the map operator to
    get a result we can display outwards:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用HTTP服务替换现有的静态数据实现。为此，我们调用HTTP服务的`http.get()`方法来获取数据，但我们还需要使用map操作符来获得我们可以向外显示的结果：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To use the previously defined service, we just need to tell the module about
    it. We do so by adding it to the `providers` keyword:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用先前定义的服务，我们只需要告诉模块关于它。我们通过将其添加到`providers`关键字来实现这一点：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Thereafter, we need to inject the `TaskService` in a consumer component and
    display it in a suitable way:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，我们需要在使用者组件中注入`TaskService`并以适当的方式显示它：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: A stateful TaskService for most scenarios
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大多数情况下使用有状态的TaskService
- en: 'So far, we have covered how to inject an HTTP service into a service constructor
    and have been able to subscribe to such a service from a component. In some cases,
    a component might want to deal with the data directly and not with Observables.
    In fact, most of our cases are like that. So, we don''t have to use Observables
    much; HTTP services are utilizing Observables, right? We are talking about the
    component layer. Currently, we have this happening inside of our component:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了如何将HTTP服务注入到服务构造函数中，并且已经能够从组件订阅这样的服务。在某些情况下，组件可能希望直接处理数据而不是使用Observables。实际上，我们大多数情况下都是这样。因此，我们不必经常使用Observables；HTTP服务正在利用Observables，对吧？我们正在谈论组件层。目前，我们在组件内部正在发生这种情况：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we see that we assign `taskService.getTasks()` to a stream called `tasks$`.
    What is the `$` at the end of the`tasks$`variable? This is a naming convention
    that we use for streams; let's try to follow that for any future streams/Observable
    fields that we declare. We use the words Observable and stream interchangeably,
    as they come to mean the same thing in the context of Angular. We also let the `|
    async` async pipe handle it with `*ngFor` and display our tasks.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到我们将`taskService.getTasks()`分配给一个名为`tasks$`的流。`tasks$`变量末尾的`$`是什么？这是我们用于流的命名约定；让我们尝试遵循任何未来流/可观察字段的命名约定。我们在Angular的上下文中将Observable和stream互换使用，它们的含义是相同的。我们还让`|
    async`异步管道与`*ngFor`一起处理它并显示我们的任务。
- en: 'We can do this in an even simpler way, like so:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以更简单的方式做到这一点，就像这样：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'So, the following changes took place:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，发生了以下更改：
- en: '`ngOnInit()` and the assigning to the `tasks$` stream was removed'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngOnInit()`和分配给`tasks$`流的部分被移除了'
- en: The async pipe was removed
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步管道被移除
- en: We replaced the `tasks$` stream with a `tasks` array
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们用`tasks`数组替换了`tasks$`流
- en: How can this still work? The answer lies in how we define our service. Our service
    needs to expose an array of items and we need to ensure the array is changed when
    we get some data back from HTTP, or when we receive data from elsewhere, such
    as from a web socket or a product like Firebase.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这还能工作吗？答案在于我们如何定义我们的服务。我们的服务需要暴露一个项目数组，并且我们需要确保当我们从HTTP获取到一些数据时，或者当我们从其他地方接收到数据时，比如来自Web套接字或类似Firebase的产品时，数组会发生变化。
- en: We just mentioned two interesting methods, sockets and Firebase. Let's explain
    what those are and how they relate to our service. A web socket is a technique
    that establishes a two-way communication, a so-called *full duplex connection*,
    with the help of the TCP protocol. So, why is it interesting to mention it in
    the context of HTTP? Most of the time, you have simple scenarios where you fetch
    data over HTTP, and you can leverage Angular's HTTP service. Sometimes, the data
    might come from a full duplex connection in addition to it coming from HTTP.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚提到了两种有趣的方法，套接字和Firebase。让我们解释一下它们是什么，以及它们如何与我们的服务相关。Web套接字是一种利用TCP协议建立双向通信的技术，所谓的*全双工连接*。那么，在HTTP的背景下提到它为什么有趣呢？大多数情况下，您会有简单的场景，您可以通过HTTP获取数据，并且可以利用Angular的HTTP服务。有时，数据可能来自全双工连接，除了来自HTTP。
- en: What about Firebase? Firebase is a product by Google that allows us to create
    a database in the cloud. As can be expected, we can perform CRUD operations on
    the database, but the strength lies in the fact that we can set up subscriptions
    to it and thereby listen to changes when they occur. This means we can easily
    create collaboration apps, where a number of clients are operating on the same
    data source. This is a very interesting topic. This means you can quickly supply
    your Angular app with a backend, so for that reason, it deserves its own chapter.
    It also happens to be the next chapter of this book.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 那么Firebase呢？Firebase是谷歌的产品，允许我们在云中创建数据库。正如可以预料的那样，我们可以对数据库执行CRUD操作，但其强大之处在于我们可以设置订阅并监听其发生的更改。这意味着我们可以轻松创建协作应用程序，其中许多客户端正在操作相同的数据源。这是一个非常有趣的话题。这意味着您可以快速为您的Angular应用程序提供后端，因此，出于这个原因，它值得有自己的章节。它也恰好是本书的下一章。
- en: Back to the point we were trying to make. On paper, it sounds like the addition
    of sockets or Firebase would complicate our service a whole lot. In practice,
    they don't. The only thing you need to keep in mind is that when such data arrives,
    it needs to be added to our `tasks`array. We make the assumption here that it
    is interesting to deal with tasks from a HTTP service as well as from full duplex
    connections like Firebase or web sockets.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们试图表达的观点。从理论上讲，添加套接字或Firebase似乎会使我们的服务变得更加复杂。实际上，它们并不会。您需要记住的唯一一件事是，当这样的数据到达时，它需要被添加到我们的`tasks`数组中。我们在这里做出的假设是，处理来自HTTP服务以及来自Firebase或Web套接字等全双工连接的任务是有趣的。
- en: Let's have a look at what it would look like to involve an HTTP service and
    sockets in our code. You can easily leverage sockets by using a library that wraps
    its API.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在我们的代码中涉及HTTP服务和套接字会是什么样子。您可以通过使用包装其API的库轻松利用套接字。
- en: WebSockets are supported natively by most browsers, but it is considered experimental
    still. With that said, it still makes sense to rely on a library that helps us
    work with sockets, but it's worth keeping track of when WebSockets are becoming
    less experimental as we would no longer consider using a library. For the interested
    reader, please check the official documentation at [https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数浏览器原生支持WebSockets，但仍被认为是实验性的。话虽如此，依然有意义依赖于一个帮助我们处理套接字的库，但值得注意的是，当WebSockets变得不再是实验性的时候，我们将不再考虑使用库。对于感兴趣的读者，请查看官方文档[https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)
- en: 'One such library is the `socket.io` library; it can be installed in the following
    way:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个这样的库是`socket.io`库；可以通过以下方式安装它：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To start using this in Angular, you need to:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始在Angular中使用这个，您需要：
- en: Import the `socket.io-client`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`socket.io-client`。
- en: Establish a connection by calling `io(url)`; this will return a socket that
    you can add subscriptions to.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`io(url)`建立连接；这将返回一个套接字，您可以向其添加订阅。
- en: Wait for incoming events that will contain a payload that we want to display
    in our app.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待包含我们想要在应用程序中显示的有效负载的传入事件。
- en: Generate events and send the possible payload when you want to talk to a backend
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成事件并在想要与后端通信时发送可能的有效负载
- en: 'The following code will only show you how to do these steps. There is more
    to socket implementation, though, such as creating a backend. To see what a full
    example with Angular and `socket.io` looks like, the interested reader is encouraged
    to have a look at the following article by Torgeir Helgwold:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将只向您展示如何执行这些步骤。然而，套接字的实现还有更多，比如创建后端。要了解使用Angular和`socket.io`的完整示例是什么样子，鼓励感兴趣的读者查看Torgeir
    Helgwold的以下文章：
- en: '[http://www.syntaxsuccess.com/viewarticle/socket.io-with-rxjs-in-angular-2.0](http://www.syntaxsuccess.com/viewarticle/socket.io-with-rxjs-in-angular-2.0)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.syntaxsuccess.com/viewarticle/socket.io-with-rxjs-in-angular-2.0](http://www.syntaxsuccess.com/viewarticle/socket.io-with-rxjs-in-angular-2.0)'
- en: 'This isn''t really an HTTP topic, which is why we settle for only showing the
    points of interest in the code, which is where we would receive the data and add
    it to our tasks array. We also highlight the setting up and tearing down of the
    socket. Highlighting is done in bold, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上不是一个HTTP主题，这就是为什么我们只显示代码中感兴趣的部分，这是我们将接收数据并将其添加到任务数组中的地方。我们还强调了套接字的设置和拆除。强调是用粗体来做的，如下所示：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is a very simple example that works well for showing data in a template,
    as well updating the template when the `tasks`array changes. As you can see, if
    we involve a `socket`, it won't matter; our template will still be updated.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的示例，非常适合在模板中显示数据，并在`tasks`数组更改时更新模板。正如您所看到的，如果我们涉及`socket`，那也没关系；我们的模板仍然会被更新。
- en: 'This way of doing it also comprises another scenario—how do two sibling components
    or more communicate? The answer is quite simple: they use the `TaskService`. If
    you want the other components template to be updated, then simply change the contents
    of the tasks array and it will be reflected in the UI. The code for this follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法还包括另一种情况——两个或更多兄弟组件如何通信？答案很简单：它们使用`TaskService`。如果您希望其他组件的模板得到更新，那么只需更改任务数组的内容，它将反映在UI中。以下是此代码：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This means that we also need to add a `addTask()` method to our service, like
    so:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们还需要向我们的服务添加一个`addTask()`方法，如下所示：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The other component would look pretty much identical in terms of the parts
    that relate to setting up the `taskService`, exposing a `tasks` property and manipulating
    the `tasks`list. Regardless of which one of the components takes the initiative
    to change the task list through user interaction, the other component would be
    notified. I want to highlight what makes this general approach work, though. For
    this approach to work, you need to expose the tasks array through a getter in
    the component, like so:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个组件在设置`taskService`、公开`tasks`属性和操作`tasks`列表方面看起来基本相同。无论哪个组件采取主动通过用户交互更改任务列表，另一个组件都会收到通知。我想强调这种通用方法的工作原理。为了使这种方法起作用，您需要通过组件中的getter公开任务数组，如下所示：
- en: '[PRE39]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Otherwise, the changes to it won't be picked up.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，对它的更改将不会被接收。
- en: 'There is one drawback, though. What if we wanted to know exactly when an item
    was added and, say, display some CSS based on that? In that case, you have two
    options:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个缺点。如果我们想确切地知道何时添加了一个项目，并且，比如说，基于此显示一些CSS，那该怎么办？在这种情况下，您有两个选择：
- en: Set up the socket connection in the component and listen for the data changes
    there.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件中设置套接字连接并在那里监听数据更改。
- en: Use a behavior subject inside of the task service instead of a task array. Any
    changes from HTTP or socket will write to the subject through `subject.next()`.
    If you do this, then you can simply subscribe to the subject when a change happens.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任务服务中使用行为主题而不是任务数组。来自HTTP或套接字的任何更改都将通过`subject.next()`写入主题。如果这样做，那么当发生更改时，您可以简单地订阅该主题。
- en: The last alternative is a bit complicated to explain in a few words, so the
    whole next section is dedicated to explaining how you can use a `BehaviourSubject` over
    an array.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选择有点复杂，无法用几句话解释清楚，因此下一节将专门解释如何在数组上使用`BehaviourSubject`。
- en: Further improvements – turning TaskService into a stateful, more robust service
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步改进-将TaskService转变为有状态、更健壮的服务
- en: 'RxJS and Observables didn''t arrive just to be a one-to-one match to Promises.
    RxJS and reactive programming arrived to promote a different kind of architecture,
    as well. From such an architecture emerged a store pattern suitable for services.
    The store pattern is about ensuring our service is stateful and can deal with
    data coming from more places than HTTP. The potential places where data can arrive
    from could be, for example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS和Observables并不仅仅是为了与Promises一一对应而到来。RxJS和响应式编程到来是为了推广一种不同类型的架构。从这样的架构中出现了适用于服务的存储模式。存储模式是确保我们的服务是有状态的，并且可以处理来自HTTP以外更多地方的数据。数据可能来自的潜在地方可能包括，例如：
- en: HTTP
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP
- en: localStorage
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: localStorage
- en: Sockets
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字
- en: Firebase
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firebase
- en: Handling service calls when network connection intermittently goes offline
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网络连接间歇性中断时处理服务调用
- en: 'First of all, you owe it to the application users to ensure that your application
    still works if the network connection goes down, at least when it comes to reading
    data. For that situation, it would be nice if we could answer with `localStorage`
    if the HTTP response fails to deliver. This, however, means we need logic in our
    service that works in the following way:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您应该确保如果网络连接中断，应用程序仍然可以正常工作，至少在读取数据方面，您对应用程序用户有责任。对于这种情况，如果HTTP响应未能传递，我们可以使用`localStorage`进行回答。然而，这意味着我们需要在我们的服务中编写以下方式工作的逻辑：
- en: '[PRE40]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s take our service and modify it slightly to account for being offline:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拿出我们的服务，并稍微修改一下以适应离线状态：
- en: '[PRE41]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As you can see, we do two things:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们做了两件事：
- en: We add the `.do()` operator to carry out a side effect; in this case, we write
    the response to `localStorage`
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加`.do()`运算符来执行副作用；在这种情况下，我们将响应写入`localStorage`
- en: We add the `catch()` operator and respond with a new Observable that contains
    previously stored data or an empty array
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了`catch()`操作符，并响应一个包含先前存储的数据或空数组的新Observable
- en: There is nothing wrong with solving it this way, and in a lot of cases, it might
    even be good enough. What happens when data arrives from many different directions,
    though, as suggested earlier? If that is the case, then we must have the ability
    to push data into the stream. Normally, it's only Observers that can push data
    with `observer.next()`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 用这种方式解决问题没有错，而且在很多情况下，这甚至可能足够好。然而，如果像之前建议的那样，数据从许多不同的方向到达，会发生什么？如果是这种情况，那么我们必须有能力将数据推送到流中。通常，只有观察者可以使用`observer.next()`推送数据。
- en: 'There is another construct, though, the `Subject`. The `Subject`has a dual
    nature. It has the ability to both push data to the stream and it can also be
    subscribed to. Let''s rewrite our service to account for the external arrival
    of data and then add `Sock.io` library support so you will see how this is scaled.
    We start by making the service stateful. It would be tempting to just code it
    like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个构造，`Subject`。`Subject`具有双重性质。它既能向流中推送数据，也可以被订阅。让我们重写我们的服务以解决外部数据的到达，然后添加`Sock.io`库支持，这样您就会看到它是如何扩展的。我们首先使服务具有状态。诱人的做法是直接编写如下代码：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The preceding changes we propose are bolded and entail creating a `tasks`array
    field and doing an assignment to the tasks field with the arriving data. This
    works, but it might be more than we need.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议的前述更改是加粗的，并且包括创建一个`tasks`数组字段，并对到达的数据进行任务字段的赋值。这样做是有效的，但可能超出了我们的需求。
- en: Introducing the store/feed pattern
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入store/feed模式
- en: 'We can do better than this, though. We can do better in the sense that we really
    don''t need to create that last array. You might think at this point, let me get
    this straight; you want my service to be stateful without a backing field? Well,
    kind of, and it is possible using something called a `BehaviourSubject`. A `BehaviourSubject` has
    the following properties:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，我们可以做得更好。我们可以更好地做到这一点，因为我们实际上不需要创建那个最后的数组。在这一点上，你可能会想，让我弄清楚一下；你希望我的服务具有状态，但没有后备字段？嗯，有点，而且使用一种称为`BehaviourSubject`的东西是可能的。`BehaviourSubject`具有以下属性：
- en: It is able to act as an `Observer` and `Observable`, so it can push data and
    be subscribed to at the same time
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它能够充当`Observer`和`Observable`，因此它可以推送数据并同时被订阅
- en: It can have an initial value
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以有一个初始值
- en: It will remember the last value that it emitted
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将记住它上次发出的值
- en: 'So, with the `BehaviourSubject`, we essentially kill two birds with one stone.
    It can remember things that were last emitted and it can push out data, making
    it ideal to use when connecting to other data sources such as web sockets. Let''s
    add it first to our service:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用`BehaviourSubject`，我们实际上一举两得。它可以记住上次发出的数据，并且可以推送数据，使其在连接到其他数据源（如Web套接字）时非常理想。让我们首先将其添加到我们的服务中：
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, we are instantiating the `BehaviourSubject`and as we can see its default
    constructor takes a parameter, an initial value. We give it an empty array. This
    initial value is the first thing to be presented to a subscriber. It makes sense
    from an application standpoint to showcase a first value while waiting for that
    first HTTP call to finish.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实例化了`BehaviourSubject`，并且可以看到它的默认构造函数需要一个参数，即初始值。我们给它一个空数组。这个初始值是呈现给订阅者的第一件事。从应用程序的角度来看，在等待第一个HTTP调用完成时展示第一个值是有意义的。
- en: 'We also define a `store()` property that ensures that when we expose the `BehaviourSubject` to
    the world, we do so as an `Observable`. This is defensive coding. As the subject
    has a `next()` method on it that allows us to push values into it; we want to
    take that ability away from anyone that is not in our service. We do this because
    we want to make sure that anything added to it is handled through the public API
    of the `TaskService` class:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个`store()`属性，以确保当我们向外部公开`BehaviourSubject`时，我们将其作为`Observable`。这是防御性编码。因为主题上有一个`next()`方法，允许我们将值推送到其中；我们希望将这种能力从不在我们服务中的任何人身上夺走。我们这样做是因为我们希望确保任何添加到其中的内容都是通过`TaskService`类的公共API处理的：
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The last change was the addition made to the `.do()` operator:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的更改是添加到`.do()`操作符的
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This will ensure that any subscribers to our service will always get the last
    emitted data. Try it yourself with a code like this in a component:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保我们服务的任何订阅者始终获得最后发出的数据。在组件中尝试以下代码：
- en: '[PRE46]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: At this point, we have made sure it doesn't matter when you start subscribing
    to `taskService.store`. Whether it's immediately or after 3 seconds, as the preceding
    code shows, we will still get the last emitted data.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经确保无论何时开始订阅`taskService.store`，无论是立即还是在3秒后，如前面的代码所示，我们仍然会获得最后发出的数据。
- en: Persisting data
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化数据
- en: 'What if we need to persist what is coming from a form in a component? Well
    then, we need to do the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要持久化来自组件表单的内容怎么办？那么，我们需要做以下操作：
- en: Expose an `add()` method on our service
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的服务上公开一个`add()`方法
- en: Do an `http.post()` call
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行一个`http.post()`调用
- en: Poke the `getTasks()` to ensure it refetches the data
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`getTasks()`以确保它重新获取数据
- en: 'Let''s start with the simpler case of adding a task from a component. We assume
    the user has entered all the necessary data needed to create a `Task`in the application
    UI. An `addTask()` method has been invoked from the component, which in turn invokes
    a similar `addTask()`method on the service. We need to add the last method to
    our service and also in that method call an endpoint with a POST request so our
    task gets persisted, like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从更简单的情况开始，从组件中添加任务。我们假设用户已经输入了创建应用程序UI中的`Task`所需的所有必要数据。从组件中调用了一个`addTask()`方法，这反过来调用了服务上类似的`addTask()`方法。我们需要向我们的服务添加最后一个方法，并且在该方法中调用一个带有POST请求的端点，以便我们的任务得到持久化，就像这样：
- en: '[PRE47]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'At this point, we assume the calling component is responsible for doing all
    sorts of CRUD operations on a component, including showing a list of tasks. By
    adding a task and persisting it, the mentioned list would now lack a member, which
    is why it makes sense to do a fresh call to `getTasks()`. So, if we had a simple
    service with just a `getTasks()` method, then that would just return a list of
    tasks, including our newly persisted task, like so:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们假设调用组件负责在组件上执行各种CRUD操作，包括显示任务列表。通过添加任务并持久化它，提到的列表现在将缺少一个成员，这就是为什么有必要对`getTasks()`进行新的调用。因此，如果我们有一个简单的服务，只有一个`getTasks()`方法，那么它将返回一个任务列表，包括我们新持久化的任务，如下所示：
- en: '[PRE48]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: OK, so this works if we have a simplified `TaskService`that lacks our pretty
    store/feed pattern. There is a problem, though—we are using RxJS wrong. What do
    we mean by wrong? Every time we use `addTask()`, we set up a new subscription.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，如果我们有一个简化的`TaskService`，缺少我们漂亮的存储/反馈模式，那么这将起作用。不过，有一个问题——我们在使用RxJS时出错了。我们所说的错误是什么？每次我们使用`addTask()`时，我们都建立了一个新的订阅。
- en: 'What you want is the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要的是以下内容：
- en: One subscription to a stream of tasks
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅任务流
- en: A cleanup phase where the subscription is being unsubscribed
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理阶段，订阅被取消订阅
- en: 'Let''s start by tackling the first problem; one stream. We assume that we will
    need to use the stateful version of our `TaskService`instead. We change the component
    code to this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先解决第一个问题；一个流。我们假设我们需要使用我们的`TaskService`的有状态版本。我们将组件代码更改为这样：
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As you can see, we are now subscribing to the store property instead, but we
    have removed the refetch behavior inside of the `taskService.addTask()` method
    to read like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们现在订阅了store属性，但是我们已经将`taskService.addTask()`方法内的重新获取行为移除，改为这样：
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We will instead place this refresh logic in the `taskService`, like so:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个刷新逻辑放在`taskService`中，像这样：
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, everything works as intended. We have one subscription to our task stream
    in the component and the refresh logic is being pushed back to the service by
    us poking the `fetchTasks()` method.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切都按预期运行。我们在组件中有一个订阅任务流，刷新逻辑被我们通过调用`fetchTasks()`方法推回到服务中。
- en: 'We have one more order of business. How do we deal with subscriptions, and
    more to the point, how do we deal with unsubscribing? Remember how we added a `subscription`member
    to our component? That took us halfway there. Let''s implement an `OnDestroy` interface
    to our component and implement the contract:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一项业务要处理。我们如何处理订阅，更重要的是，我们如何处理取消订阅？记得我们如何向组件添加了一个`subscription`成员吗？那让我们完成了一半。让我们为我们的组件实现一个`OnDestroy`接口并实现这个约定：
- en: '[PRE52]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: By implementing the `OnDestroy` interface, we have a way to call `unsubscribe()` on
    the subscription and we do that in the `ngOnDestroy()` method that the `OnDestroy`interface
    makes us implement. Thus, we clean up after ourselves.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现`OnDestroy`接口，我们有一种方法在订阅上调用`unsubscribe()`，我们在`OnDestroy`接口让我们实现的`ngOnDestroy()`方法中这样做。因此，我们为自己清理了一下。
- en: The pattern of implementing the `OnInit` interface and the `OnDestroy`interface
    is something that you should be doing when creating a component. It is a good
    practice to set up subscriptions and anything else the component needs in the `ngOnInit()` method
    and conversely tear down subscriptions and other type of constructs in the `ngOnDestroy()` method.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`OnInit`接口和`OnDestroy`接口的模式是在创建组件时应该做的事情。在`ngOnInit()`方法中设置订阅和组件需要的其他任何内容是一个良好的实践，相反，在`ngOnDestroy()`方法中取消订阅和其他类型的构造是一个良好的实践。
- en: 'There is an even better way, though, and that is using the `async |`async pipe.
    The async pipe will remove the need to save a reference to a subscription and
    call `.unsubscribe()`on it, as this is handled internally in the async pipe. We
    will talk more about the async pipe in the upcoming sections in this chapter,
    but here is what the component would look like leveraging it instead of the `OnDestroy` interface:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一种更好的方法，那就是使用`async`管道。`async`管道将消除保存订阅引用并调用`.unsubscribe()`的需要，因为这在`async`管道内部处理。我们将在本章的后续部分更多地讨论`async`管道，但是这是组件利用它而不是`OnDestroy`接口的样子：
- en: '[PRE53]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Our code just removed a lot of boilerplate, and the best part is that it is
    still working. As long as all your data is being displayed in a component, then
    the async pipe is the way to go; however, if you fetch up data that is shared
    between other services or used as a precondition to fetching other data, then
    it might not be so clear-cut as to be using the async pipe.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码刚刚删除了很多样板代码，最好的部分是它仍然在工作。只要你的所有数据都在一个组件中显示，那么`async`管道就是最好的选择；然而，如果你获取的数据是在其他服务之间共享或者作为获取其他数据的先决条件，那么使用`async`管道可能就不那么明显了。
- en: The important thing at the end of the day is that you resort to using one of
    these techniques.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，最终你要求使用这些技术之一。
- en: Refreshing our service
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刷新我们的服务
- en: 'We are almost done describing our `TaskService`, but there is one more aspect
    we need to cover. Our service doesn''t take into account that a third party might
    make changes to the endpoint database. We will see those changes if we move away
    from the component or reload the entire application. If we want to see those changes
    when they happen, we need to have some kind of behavior that tells us when data
    has changed. It is tempting to think of a polling solution and just refresh the
    data at certain intervals. This might be a painful approach, though, as the data
    we fetch might consist of a large object graph. Ideally, we only want to fetch
    what really changed and amend that to our application. Why do we care so much
    about this in the age of broadband connections? Here is the problem—an application
    should be able to be used on a mobile app and both speed as well as mobile data
    contracts might be an issue, so we need to consider the mobile user. Here are
    some things we should consider:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎描述完了我们的`TaskService`，但还有一个方面我们需要涵盖。我们的服务没有考虑到第三方可能对终端数据库进行更改。如果我们远离组件或重新加载整个应用程序，我们将看到这些更改。如果我们想在更改发生时看到这些更改，我们需要有一些行为告诉我们数据何时发生了变化。诱人的是想到一个轮询解决方案，只是在一定的时间间隔内刷新数据。然而，这可能是一个痛苦的方法，因为我们获取的数据可能包含一个庞大的对象图。理想情况下，我们只想获取真正发生变化的数据，并将其修改到我们的应用程序中。在宽带连接时代，为什么我们如此关心这个问题？这是问题所在——一个应用程序应该能够在移动应用上使用，速度和移动数据合同可能是一个问题，所以我们需要考虑移动用户。以下是一些我们应该考虑的事情：
- en: The size of the data
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据的大小
- en: The polling interval
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮询间隔
- en: 'If the expected size of the data is really big, then it might be a good idea
    to poke an endpoint and ask it for everything that changed after a certain time;
    this would change the size of the payload drastically. We could also just ask
    for a partial object graph back. The polling interval is another thing to consider.
    We need to ask ourselves: how often do we really need to refetch all the data?
    The answer could be never.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据的预期大小真的很大，那么向一个端点发出请求并询问它在一定时间后发生了什么变化可能是一个好主意；这将大大改变有效载荷的大小。我们也可以只要求返回一个部分对象图。轮询间隔是另一个需要考虑的事情。我们需要问自己：我们真的需要多久才能重新获取所有数据？答案可能是从不。
- en: 'Let''s say we opt for an approach where we ask for the delta (the change after
    a certain time); it could look like the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们选择一种方法，我们要求获取增量（在一定时间后的变化）；它可能看起来像下面这样：
- en: '[PRE54]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Regardless of what approach and considerations you take here, remember that
    not all users are on a broadband connection. It's also worth nothing that more
    and more of theses refresh scenarios tend to be solved with Web Sockets nowadays
    so you create an open connection between server and client, and the server can
    decide when it's time to send the client some new data. We will leave it to you,
    dear reader, to refactor this example using Sockets.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你采取什么方法和考虑，记住并不是所有用户都在宽带连接上。值得注意的是，越来越多的刷新场景现在 tend to be solved with Web
    Sockets，所以你可以在服务器和客户端之间创建一个开放的连接，服务器可以决定何时向客户端发送一些新数据。我们将把这个例子留给你，亲爱的读者，使用Sockets进行重构。
- en: 'We now have a service which is:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个可以：
- en: Stateless
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态
- en: Able to handle offline connections
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够处理离线连接
- en: Able to cater for other data services such as sockets
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为其他数据服务提供服务，比如sockets
- en: Able to refresh its data at a certain interval
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够在一定的时间间隔内刷新数据
- en: All this was made possible through the `BehaviourSubject` and `localStorage`.
    Don't just treat RxJS as an add-on to a `Promise`, but use its constructs and
    operators to craft robust services and architecture patterns.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是通过`BehaviourSubject`和`localStorage`实现的。不要把RxJS只当作`Promise`的附加功能，而是使用它的构造和操作符来构建健壮的服务和架构模式。
- en: HttpInterceptor
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HttpInterceptor
- en: 'An interceptor is a piece of code that can be executed between your HTTP calls
    and the rest of the application. It can be hooked up when you are about to send
    a request as well as when receiving a response. So, what do we use it for? There
    many areas of application, but some might be:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器是一段可以在您的HTTP调用和应用程序的其余部分之间执行的代码。它可以在您即将发送请求时以及接收响应时挂钩。那么，我们用它来做什么呢？应用领域有很多，但有些可能是：
- en: Adding a custom token for all outgoing requests
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有出站请求添加自定义令牌
- en: Wrapping all incoming error responses in a business exception; this can also
    be done on the backend
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有传入的错误响应包装成业务异常；这也可以在后端完成
- en: Redirecting a request somewhere else
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重定向请求到其他地方
- en: 'An `HttpInterceptor`is an interface imported from `@angular/common/http`. To
    create an interceptor, you need to take the following steps:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpInterceptor`是从`@angular/common/http`导入的一个接口。要创建一个拦截器，您需要按照以下步骤进行：'
- en: Import and implement the `HttpInterceptor` interface
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入并实现`HttpInterceptor`接口
- en: Register the interceptor in the root module provider
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根模块提供程序中注册拦截器
- en: Write the business logic for what is to happen to the request
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写请求的业务逻辑
- en: Creating a mock interceptor
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个模拟拦截器
- en: Let's take all, the earlier mentioned steps and create a real interceptor service. Imagine
    that all calls to a certain endpoint are directed to a JSON file or a dictionary.
    Doing so will create a mock behavior where you are able to ensure that all outgoing
    calls are intercepted, and in their place, you answer with suitable mock data.
    This will allow you to develop the API at your own pace while relying on mocked
    data. Let's dig a little deeper into this scenario.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们采取所有先前提到的步骤，并创建一个真正的拦截器服务。想象一下，对某个端点的所有调用都被定向到一个JSON文件或字典。这样做将创建一个模拟行为，您可以确保所有出站调用都被拦截，并在它们的位置上，您用适当的模拟数据回应。这将使您能够以自己的节奏开发API，同时依赖于模拟数据。让我们深入探讨一下这种情况。
- en: 'Let''s start off by creating our service. Let''s call it `MockInterceptor`.
    It will need to implement the `HttpInterceptor` interface like so:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建我们的服务。让我们称之为`MockInterceptor`。它将需要像这样实现`HttpInterceptor`接口：
- en: '[PRE55]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To fulfil the contract of the interface, we need to have the method `intercept()` that
    takes a request and a `next()`handler as parameters. Thereafter, we need to ensure
    we return an Observable of `HttpEvent` type from the `intercept()`method. We have
    yet to write any logic in there, so this won''t actually compile. Let''s add some
    basic code in the `intercept()` method just to make it work, like so:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了履行接口的约定，我们需要有一个接受请求和`next()`处理程序作为参数的`intercept()`方法。此后，我们需要确保从`intercept()`方法返回`HttpEvent`类型的Observable。我们还没有在那里写任何逻辑，所以这实际上不会编译。让我们在`intercept()`方法中添加一些基本代码，使其工作，像这样：
- en: '[PRE56]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We added a call to `next.handle(request)`, which means we take the incoming
    request and just pass it further in the pipeline. This code doesn't do anything
    useful, but it does compile and does teach us that whatever we do inside the `intercept()` method,
    we need to call `next.handle()` with a request object.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了对`next.handle(request)`的调用，这意味着我们接受传入的请求并将其传递到管道中。这段代码并没有做任何有用的事情，但它可以编译，并且教会我们，无论我们在`intercept()`方法中做什么，我们都需要使用请求对象调用`next.handle()`。
- en: 'Let''s return to what we were trying to achieve in the first place—mocking
    an outgoing request. This means we want to replace the outgoing request with `our`
    request. To accomplish our mocking behavior, we need to do the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到最初的目标——模拟出站请求。这意味着我们想要用`我们的`请求替换出站请求。为了实现我们的模拟行为，我们需要做以下事情：
- en: Investigate our outgoing request and determine whether we want to answer with
    a mock or let it through
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查我们的出站请求，并确定我们是要用模拟来回应还是让它通过
- en: Construct a mock response if we want to mock it
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想要模拟它，构造一个模拟响应
- en: Register our new interceptor with the `providers` for a module
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`providers`为一个模块注册我们的新拦截器
- en: 'Let''s add some code to our `intercept()` method as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`intercept()`方法中添加一些代码，如下所示：
- en: '[PRE57]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: What we are essentially saying here is that we are trying to perform a GET request
    to something. `/starwars`will intercept it and instead respond with a JSON file.
    So, `/starwars/ships` would instead lead to us respond with `ships.json` and `/starwars/planets`
    would lead to `planets.json`. You get the idea; all other requests would be let
    through.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里基本上是在说，我们正在尝试对某个东西执行GET请求。`/starwars`将会拦截它，而不是响应一个JSON文件。所以，`/starwars/ships`将会导致我们响应`ships.json`，`/starwars/planets`将会导致`planets.json`。你明白了吧；所有其他请求都会被放行。
- en: 'We have one more thing to do—tell our module this interceptor exists. We open
    up our module file and add the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一件事要做——告诉我们的模块这个拦截器存在。我们打开我们的模块文件并添加以下内容：
- en: '[PRE58]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Some best practices
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些最佳实践
- en: 'There are some best practices to follow when dealing with data services in
    Angular, especially when Observables are involved, and those are:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理Angular中的数据服务时，特别是涉及到Observables时，有一些最佳实践需要遵循，其中包括：
- en: Handle your errors. This one goes without saying and hopefully this is not something
    new on your radar.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理你的错误。这是不言而喻的，希望这对你来说并不是什么新鲜事。
- en: Make sure that any manually created Observables have a cleanup method.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保任何手动创建的Observables都有一个清理方法。
- en: Unsubscribe to your streams/Observables, or else you might have resource leaks.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消订阅你的流/可观察对象，否则可能会出现资源泄漏。
- en: Use the async pipe to manage the subscribe/unsubscribe process for you.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用async管道来为你管理订阅/取消订阅过程。
- en: We have so far not discussed how to create a cleanup method when manually creating
    Observables, which is why we will cover that in a subsection.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有讨论如何在手动创建Observables时创建清理方法，这就是为什么我们将在一个小节中进行讨论。
- en: The async pipe has been mentioned a couple of times in the Firebase section,
    but it's worth mentioning again and building on that knowledge by explaining its
    role in the subscribe/unsubscribe process to streams.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firebase部分已经提到了async管道几次，但值得再次提及并通过解释它在订阅/取消订阅流程中的作用来建立对它的了解。
- en: Async operator
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步操作符
- en: 'The async pipe is an Angular pipe, and as such it is used in a template. It
    is used in conjunction with streams/Observables. It plays two roles: it helps
    us to type less, and secondly, it saves us the whole ceremony of having to set
    up and tear down a subscription.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: async管道是一个Angular管道，因此它用在模板中。它与流/可观察对象一起使用。它发挥了两个作用：它帮助我们少打字，其次，它节省了整个设置和拆除订阅的仪式。
- en: 'If it did not exist, it would be tempting to type the following when trying
    to display data from a stream:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它不存在，当尝试从流中显示数据时，很容易会输入以下内容：
- en: '[PRE59]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As you can see, we have to subscribe and unsubscribe to the data. We also need
    to introduce a data property to assign it to. The async pipe saves us a few keystrokes,
    so we instead can type our component like this:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们需要订阅和取消订阅数据。我们还需要引入一个数据属性来分配它。async管道为我们节省了一些按键，所以我们可以像这样输入我们的组件：
- en: '[PRE60]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This is a lot less code. We removed:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这是少了很多代码。我们删除了：
- en: The `OnDestroy` interface
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDestroy`接口'
- en: The `subscription` variable
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscription`变量'
- en: Any call to subscribe/unsubscribe
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何订阅/取消订阅的调用
- en: We did need to add `{{ data | async }}`, which is a quite a small addition.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实需要添加`{{ data | async }}`，这是一个相当小的添加。
- en: 'However, if what we get back is a more complicated object and we would like
    to display its properties, we have to type something like this in the template:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们得到的是一个更复杂的对象，并且我们想要显示它的属性，我们必须在模板中输入类似这样的内容：
- en: '[PRE61]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We do this as the data is not yet set, and accessing a property at that point
    would lead to a runtime error, hence our `?` operator. Now, this looks a bit verbose,
    and we can fix that with the `-` operator, like so:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是因为数据还没有设置，此时访问属性会导致运行时错误，因此我们使用了`?`操作符。现在，这看起来有点冗长，我们可以使用`-`操作符来解决这个问题，就像这样：
- en: '[PRE62]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now it's looking a lot better. Using the async pipe will reduce a lot of boilerplate.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来好多了。使用`async pipe`将减少大量样板代码。
- en: Being a good citizen – cleaning up after yourself
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做一个好公民 - 在自己之后清理
- en: 'Okay, so I''ve told you the importance of calling `.unsubscribe()`, and you
    have taken my word for it at this point that if it is not called, resources won''t
    be cleaned up. It is important to know about this mostly when you deal with streams
    that have a never-ending stream of data, such as scroll events, or in cases where
    you need to create your own Observables. I will now demonstrate a little bit of
    the internals of an Observable to make things clearer:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我已经告诉过你调用`.unsubscribe()`的重要性，你现在应该相信我，如果不调用它，资源就不会被清理。当你处理有着永无止境的数据流的流时，比如滚动事件，或者在需要创建自己的Observables时，了解这一点非常重要。我现在将展示一些Observable的内部，以使事情更清晰：
- en: '[PRE63]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This is an example of creating our own Observable. You think you are safe now
    just because you called `.unsubscribe()`like you were told? Wrong. The interval
    will keep on ticking because you didn''t tell it stop. In panic, you close the
    browser tab and wish the Observable away—you are safe for now. The correct approach
    to this is to add a cleanup function, like so:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个创建自己的Observable的例子。你以为只因为你按照指示调用了`.unsubscribe()`就安全了？错。间隔会继续计时，因为你没有告诉它停止。慌乱中，你关闭了浏览器标签，希望Observable消失
    - 现在你是安全的。正确的方法是添加一个清理函数，就像这样：
- en: '[PRE64]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Upon calling `subscription.unsubscribe()`, it will call the `cleanUp()`function
    internally. Most of, if not all, factory methods out there used to create Observables
    will have their own `cleanUp()`function defined. It is important for you to know
    that should you venture down that rabbit hole of creating your own Observable,
    refer to this section, be a good citizen, and implement a `cleanUp()` function.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`subscription.unsubscribe()`时，它将在内部调用`cleanUp()`函数。大多数，如果不是全部，用于创建Observables的工厂方法都会定义自己的`cleanUp()`函数。重要的是，你应该知道，如果你冒险创建自己的Observable，请参考本节，做一个好公民，并实现`cleanUp()`函数。
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As we pointed out at the beginning of this chapter, it takes much more than
    a single chapter to cover in detail all the great things that can be done with
    the Angular HTTP connection functionalities, but the good news is that we have
    covered pretty much all the tools and classes we need.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头指出的，要详细介绍Angular HTTP连接功能所能做的所有伟大事情，需要不止一个章节，但好消息是我们已经涵盖了几乎所有我们需要的工具和类。
- en: The rest is just left to your imagination, so feel free to go the extra mile
    and put all of this knowledge into practice by creating brand new Twitter reader
    clients, newsfeed widgets, or blog engines, and assembling all kinds of components
    of your choice. The possibilities are endless, and you have assorted strategies
    to choose from, ranging from Promises to Observables. You can leverage the incredible
    functionalities of the Reactive Functional extensions and the tiny but powerful
    `Http` class.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的就留给你的想象力了，所以随时可以尽情发挥，通过创建全新的Twitter阅读客户端、新闻源小部件或博客引擎，以及组装各种你选择的组件来将所有这些知识付诸实践。可能性是无限的，你可以选择各种策略，从Promises到Observables。你可以利用响应式功能扩展和强大的`Http`类的令人难以置信的功能。
- en: As we have already highlighted, the sky is the limit. But, we still have a long
    and exciting road ahead. Now that we know how to consume asynchronous data in
    our components, let's discover how we can provide a broader user experience in
    our applications by routing users into different components. We will cover this
    in the next chapter.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经强调的那样，天空是无限的。但是，我们还有一条漫长而令人兴奋的道路在前方。现在我们知道了如何在我们的组件中消费异步数据，让我们来探索如何通过将用户路由到不同的组件中，为我们的应用提供更广泛的用户体验。我们将在下一章中介绍这个内容。
