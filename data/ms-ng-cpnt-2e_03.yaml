- en: Dealing with Data and State
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数据和状态
- en: In this chapter, we will go one step further in structuring our application
    and work on the data architecture that serves as the base for our task management
    system. So far, we've obtained task data synchronously from the task service which
    we created in the previous chapter. However, in real-world scenarios, this will
    rarely be the case. In a real application, we would obtain data in an asynchronous
    way where we need to manage client state, and we need to ensure the integrity
    of our state and data at all times. In this chapter, we'll look at how we can
    restructure our application to deal with a RESTful interface using the HTTP client
    module which comes with Angular. We will use an in-memory database to simulate
    our HTTP backend. Furthermore, we will be looking at some critical concepts like
    reactive programming, immutability, and "pure" components to help us build a data
    architecture that shines on both a small as well as large scale.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进一步构建我们的应用程序结构，并专注于作为我们任务管理系统基础的数据架构。到目前为止，我们已经从我们在上一章中创建的任务服务同步获取了任务数据。然而，在现实世界的场景中，这种情况很少发生。在实际应用中，我们会以异步方式获取数据，我们需要管理客户端状态，并确保我们的状态和数据始终保持完整性。在本章中，我们将探讨如何重新构建我们的应用程序以使用
    Angular 中的 HTTP 客户端模块处理 RESTful 接口。我们将使用内存数据库来模拟我们的 HTTP 后端。此外，我们还将探讨一些关键概念，如响应式编程、不可变性和“纯”组件，以帮助我们构建一个在小规模和大规模上都能发光的数据架构。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Reactive programming, the basics of RxJS, and its operators to deal with asynchronous
    data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程、RxJS 的基础知识及其操作符，用于处理异步数据
- en: Restructuring our application to deal with simulated HTTP calls to an in-memory
    database
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新构建我们的应用程序以处理对内存数据库的模拟 HTTP 调用
- en: The concept of immutability
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性的概念
- en: Using pure components in Angular
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Angular 中使用纯组件
- en: The introduction of container components to separate our user interface from
    application state
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入容器组件以将我们的用户界面与应用程序状态分离
- en: Using `ChangeDetectionStrategy.OnPush` for pure components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为纯组件使用 `ChangeDetectionStrategy.OnPush`
- en: Reactive programming with RxJS
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RxJS 进行响应式编程
- en: So far, we have used simple array data structures in the task list that we created.
    That is not really what we'll find in real-world scenarios. In real applications,
    we have to deal with asynchronous data coming from a server.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在创建的任务列表中使用了简单的数组数据结构。这并不是我们在现实世界场景中会遇到的。在实际应用中，我们必须处理来自服务器的异步数据。
- en: 'Handling data in applications behaves very similarly to streams. You take input,
    transform it, combine it, merge it, and finally, write it into the output. In
    systems such as this, it''s also very likely that input is in a continuous form
    and sometimes even of infinite duration. Just take a live feed as an example;
    this type of data flows continuously, and the data also flows infinitely. Functional
    and reactive programming are paradigms to help us deal with this kind of data
    more cleanly:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中处理数据的行为与流非常相似。你接收输入，转换它，组合它，合并它，最后将其写入输出。在这样的系统中，输入通常是连续的，有时甚至是无限期的。以实时流为例；这种类型的数据是连续流动的，数据也是无限流动的。函数式和响应式编程是帮助我们更干净地处理这类数据的范式：
- en: '![](img/857c6a52-fa81-44e7-ac6d-39dc549bc8fa.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/857c6a52-fa81-44e7-ac6d-39dc549bc8fa.png)'
- en: A simple observable subscription with value emission and a transformation
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的可观察订阅，带有值发射和转换
- en: Angular is reactive at its very core, and the whole change detection and bindings
    are built using a reactive architecture. The input and output of components, which
    we've learned about in the previous chapter, is nothing but a data flow that is
    established using a reactive event-driven approach. Angular uses RxJS, a functional
    and reactive programming library for JavaScript, to implement this data flow.
    In fact, the `EventEmitter`, which we've used to send output from within our components,
    is just a wrapper around a RxJS observable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 在其核心是响应式的，整个变更检测和绑定都是使用响应式架构构建的。我们在上一章中学到的组件的输入和输出，实际上就是一个使用响应式事件驱动方法建立的数据流。Angular
    使用 RxJS，这是一个用于 JavaScript 的函数式和响应式编程库，来实现这种数据流。实际上，我们用来从组件内部发送输出的 `EventEmitter`，只是
    RxJS 可观察对象的一个包装器。
- en: 'Before we mess around with RxJS within our task management system, let''s take
    a look at a straightforward RxJS example first to see how we can deal with observable
    streams in general:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们在任务管理系统内玩弄 RxJS 之前，让我们先看看一个简单的 RxJS 示例，看看我们如何处理可观测流：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This simple script will generate an observable sequence from an array of numbers.
    We pass each number through the observable stream, item by item. We're using two
    simple operators before we subscribe to the observable and print the resulting
    items to the console. The map operator is squaring each number, which flows through
    the observable stream. The filter operator is then filtering out items which are
    greater or equal to `10`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的脚本将从数字数组生成一个可观测序列。我们逐个将数字通过可观测流传递，使用两个简单的算子在我们订阅可观测量并打印结果到控制台之前。`map` 算子将每个数字平方，这些数字通过可观测流流动。然后，`filter`
    算子过滤掉大于或等于 `10` 的项。
- en: Observables provide a large number of so-called operators that allow you to
    transform the data stream that originated at the source observable. You might
    already know about some of these functional operators from the ECMAScript 5 array
    extra functions, such as `map` and `filter`. Using operators, you can model a
    whole transformation flow until you finally subscribe to the data.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可观测量提供了一大批所谓的算子，这些算子允许你转换源自源可观测量的数据流。你可能已经从 ECMAScript 5 数组扩展函数中了解到一些这些函数算子，例如
    `map` 和 `filter`。使用算子，你可以模拟整个转换流程，直到你最终订阅数据。
- en: I often use the analogy of water pipes when talking about RxJS observables.
    If you think of your transformation operators as pieces within a pipeline, then
    the `subscribe` function is the final drain valve within the pipe. If you don't
    open the drain of a water pipe, no water will flow. The behaviour of RxJS is very
    similar. Without the final subscribe call, RxJS will not perform any of the operators.
    Only if you subscribe to an observable will it become active. Within the subscribe
    callback, you can then use the resulting items which flow through the stream.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常在谈论 RxJS 可观测量时使用水管的类比。如果你认为你的转换算子是管道中的部件，那么 `subscribe` 函数就是管道中的最终排水阀。如果你不打开水管的排水口，水就不会流动。RxJS
    的行为非常相似。如果没有最后的订阅调用，RxJS 不会执行任何算子。只有当你订阅一个可观测量时，它才会变得活跃。在订阅回调中，你可以使用通过流流动的结果项。
- en: Now, building pipelines come with a significant advantage. A transformation
    system which is built like a pipe is expecting input, and it will deliver some
    output. However, we don't perform anything immediately. Instead, we're setting
    up a system which knows how to deal with the data, when there's data flowing through
    it. This pipeline system is entirely stateless and reactive—reactive in the sense
    that it will react to incoming data and produce a new output of each input.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，构建管道带来了显著的优势。像管道一样构建的转换系统期待输入，并将产生一些输出。然而，我们不会立即执行任何操作。相反，我们正在设置一个系统，该系统知道如何处理通过它的数据，当有数据流动时。这个管道系统是完全无状态的并且是响应式的——响应式意味着它会对外来数据进行响应，并为每个输入产生新的输出。
- en: 'We can treat any source which emits items over time as an observable. Let''s
    take a look at another example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将任何随时间发出项的源视为可观测量。让我们看看另一个例子：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we're using the `fromEvent` observable helper to create an
    observable source from the mouse move event on the window object. For each mouse
    move event, the event object will be emitted through the observable stream. We
    will then use the `throttleTime` operator to limit the amount of event emitted
    by the stream. This operator will block subsequent emissions within a given time
    frame, therefore throttling the steam. Within a `map` operator, we then format
    the emitted mouse event and finally subscribe to write the results to the console.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `fromEvent` 可观测量辅助函数从窗口对象的鼠标移动事件创建一个可观测源。对于每个鼠标移动事件，事件对象将通过可观测流发出。然后，我们将使用
    `throttleTime` 算子限制流发出的事件数量。这个算子将在给定的时间框架内阻止后续的发出，因此减缓了流。在 `map` 算子中，我们格式化发出的鼠标事件，并最终订阅将结果写入控制台。
- en: Using only a few lines of code, we've implemented an excellent little pipeline
    which transforms a source into a usable result. There lies the power of observables,
    reactive programming, and RxJS. We can solve difficult problems regarding building
    a reactive system in a very lovely and declarative way.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 仅用几行代码，我们就实现了一个优秀的管道，它将源转换成可用的结果。这就是观察者、响应式编程和 RxJS 的力量。我们可以以非常优雅和声明性的方式解决有关构建响应式系统的一些难题。
- en: HTTP client and in-memory web APIs
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 客户端和内存中的 Web API
- en: At the beginning of this chapter, we decided that we'd like to change the way
    how we handle data within our application. Currently, our task data is embedded
    within our task service and retrieving as well as manipulating are both happening
    synchronously. Going forward, we want to change that and come as close as possible
    to a real-world situation. At the same time, we should keep an eye on the complexity
    costs of our solution.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们决定我们想要改变我们在应用程序中处理数据的方式。目前，我们的任务数据嵌入在我们的任务服务中，检索以及操作都是同步发生的。从现在开始，我们想要改变这一点，尽可能接近现实世界的情况。同时，我们还应该关注我们解决方案的复杂性成本。
- en: Angular comes with a very nice utility for these use cases. Using the in-memory
    web API module, we can create a mock back-end service which will allow us to use
    a RESTful interface the same way as if we would connected to a real server. All
    remote calls using the Angular HTTP client will, however, be redirected to our
    local in-memory database. The way we deal with our data will be entirely authentic.
    At some point, we could even create a real backend server and connect our application
    to it, while our frontend code would stay the same.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 为这些用例提供了一个非常棒的实用工具。使用内存中的 Web API 模块，我们可以创建一个模拟的后端服务，这将允许我们以连接到真实服务器相同的方式使用
    RESTful 接口。然而，所有使用 Angular HTTP 客户端进行的远程调用都将重定向到我们的本地内存数据库。我们处理数据的方式将完全真实。在某个时候，我们甚至可以创建一个真正的后端服务器，并将我们的应用程序连接到它，同时我们的前端代码保持不变。
- en: 'Let''s look into the necessary changes in order to implement our data layer
    using the in-memory web API. As a first step, we need to install the package using
    npm. Open a command line and navigate to your project directory. Then, execute
    the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现我们的数据层所需的内存中 Web API 的必要更改。作为第一步，我们需要使用 npm 安装该包。打开命令行并导航到您的项目目录。然后，执行以下命令：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Running this command will install the in-memory web API package and save it
    to our project `package.json` file. As a next step, we want to create our application''s
    in-memory database. We''re creating a new TypeScript file on the path `src/app/database.ts`
    and adding the following content:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将安装内存中的 Web API 包并将其保存到我们的项目 `package.json` 文件中。作为下一步，我们想要创建我们应用程序的内存数据库。我们在路径
    `src/app/database.ts` 上创建一个新的 TypeScript 文件，并添加以下内容：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using the Angular in-memory web API, we can create a class which holds all our
    initial data. The class is implementing the `InMemoryDbService` interface, which
    demands that we create a method named `createDb`. Within this function, we can
    create resources which will be made available for use with the Angular HTTP client
    in a RESTful style.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Angular 内存中的 Web API，我们可以创建一个类来存储所有初始数据。这个类实现了 `InMemoryDbService` 接口，要求我们创建一个名为
    `createDb` 的方法。在这个函数中，我们可以创建资源，这些资源将以 RESTful 风格提供给 Angular HTTP 客户端使用。
- en: 'Next, we''re going to update our main application module located in the path
    `src/app/app.module.ts`, and set up our application for using the in-memory web
    API with our newly created database. You should only add the highlighted parts
    of the following code excerpt. The ellipsis character is indicating that there''s
    more code existing, which is irrelevant for the changes you need to apply to your
    code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新位于路径 `src/app/app.module.ts` 的主应用程序模块，并设置应用程序以使用我们新创建的内存中的 Web API
    和数据库。你应该只添加以下代码摘录中突出显示的部分。省略号字符表示存在更多代码，但这些代码对你需要应用到代码中的更改不相关：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We've added two more modules to the import section of our main application module.
    We've added the Angular HTTP client module which we'll use to call our simulated
    REST endpoint in our database. As discussed earlier, this library would also be
    used in the same way if we were to call a remote server.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的主应用程序模块的导入部分添加了两个额外的模块。我们添加了 Angular HTTP 客户端模块，我们将使用它来调用数据库中的模拟 REST
    端点。如前所述，如果我们要调用远程服务器，这个库也会以相同的方式使用。
- en: The second module we are importing is the HTTP client adapter of the in-memory
    web API module. This module will intercept all HTTP calls executed by the Angular
    HTTP client and redirect the requests to our local database. We're using the factory
    method `HttpClientInMemoryWebApiModule.forRoot` to configure the adapter module
    before we import it. In the first argument to the factory function, we're passing
    the database class we've created. In the second argument, we can provide some
    additional options for the adapter. In our case, we're setting the delay to zero.
    Using higher values will artificially delay the responses from our database, which
    is nice if you want to simulate a network delay.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入的第二个模块是内存中 Web API 模块的 HTTP 客户端适配器。此模块将拦截 Angular HTTP 客户端执行的所有 HTTP 调用，并将请求重定向到我们的本地数据库。我们使用工厂方法`HttpClientInMemoryWebApiModule.forRoot`在导入之前配置适配器模块。在工厂函数的第一个参数中，我们传递我们创建的数据库类。在第二个参数中，我们可以为适配器提供一些额外的选项。在我们的例子中，我们将延迟设置为零。使用更高的值将人为地延迟数据库的响应，如果你想要模拟网络延迟，这会很有用。
- en: Using behaviour subjects
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用行为主题
- en: 'The HTTP client is using RxJS to return observable streams for all HTTP request
    methods. The response body will then be emitted through the observable streams,
    and we can subscribe to the streams to retrieve the results:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 客户端正在使用 RxJS 为所有 HTTP 请求方法返回可观察流。响应体将通过可观察流发射，我们可以订阅这些流以检索结果：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since we know how to deal with observable streams within our components, we
    could go ahead and directly return the observable resulting from the HTTP client
    call.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道如何在组件中处理可观察流，我们可以继续直接返回 HTTP 客户端调用产生的可观察流。
- en: 'However, instead, we want to make use of a RxJS class called `BehaviorSubject`.
    The problem with directly returning the observable from the HTTP client is that
    we''re always returning a new observable when the tasks are loaded from the server.
    That would be impractical, and after reloading tasks when performing updates or
    adding new tasks, we''d like to be able to reuse the same observable stream to
    re-emit the updated task list. This way, all components of our system will be
    notified when we reload our tasks. You can use a behaviour subject whenever you
    want to create your own source of an observable stream. You can control what should
    be emitted and when. Let''s look at a simplified example of how a behaviour subject
    can be used:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，相反，我们想要利用一个名为`BehaviorSubject`的 RxJS 类。直接从 HTTP 客户端返回可观察流的问题在于，当任务从服务器加载时，我们总是返回一个新的可观察流。这将是不可行的，并且在重新加载任务以执行更新或添加新任务后，我们希望能够重用相同的可观察流来重新发射更新的任务列表。这样，当我们的任务重新加载时，系统中的所有组件都将被通知。你可以使用行为主题来创建自己的可观察流源。你可以控制应该发射什么以及何时发射。让我们看看一个简化的例子，看看如何使用行为主题：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Within the constructor of a behaviour subject, we can specify the initial value
    or item which will be emitted initially to all subscribers. Behaviour subjects
    are also always emitting the most recent item they have to their new subscribers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在行为主题的构造函数中，我们可以指定初始值或项目，这些值或项目将被最初发射给所有订阅者。行为主题也总是向新订阅者发射它们最新的项目。
- en: A behaviour subject is both an observer as well as an observable. Therefore,
    it would be possible to directly call the `subscribe` method on the subject. However,
    if you'd like to convert your subject into a plain observable again, you can use
    the `asObservable` method. This is especially useful for encapsulation. When you're
    returning your observable stream to be used outside of your immediate program
    logic, you don't want to give the outside world the power to emit items. It should
    only be possible to observe the stream.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 行为主题既是观察者也是可观察的。因此，你可以在主题上直接调用`subscribe`方法。然而，如果你想将你的主题再次转换为普通的可观察流，你可以使用`asObservable`方法。这对于封装特别有用。当你返回你的可观察流以在你的程序逻辑之外使用时，你不想给外部世界发射项目的权力。应该只能观察流。
- en: Finally, whenever you want to emit a new item through the observable stream,
    you can use the `next` method on the subject.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，无论何时你想通过可观察流发射新的项目，你都可以在主题上使用`next`方法。
- en: Loading data in the task service
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在任务服务中加载数据
- en: 'It''s time to change our task service and make use of the Angular HTTP client
    to obtain the task data from our database. Let''s open up the `src/app/tasks/task.service.ts`
    file and change the file content to the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候改变我们的任务服务并利用 Angular HTTP 客户端从我们的数据库中获取任务数据了。让我们打开`src/app/tasks/task.service.ts`文件，并将文件内容更改为以下内容：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We are injecting the Angular HTTP client into our constructor so we can use
    it within our service. In the `loadTasks` method, we're executing a GET call on
    the RESTful tasks resource which is provided by our database.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的构造函数中注入Angular HTTP客户端，以便我们可以在服务中使用它。在`loadTasks`方法中，我们正在对由我们的数据库提供的RESTful任务资源执行GET调用。
- en: The `tasks` member of our service is holding a behaviour subject which is initialised
    with an empty array. Whenever we call the internal `loadTasks` method, the resulting
    task list array is emitted through our behaviour subject by calling the next method.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们服务的`tasks`成员持有初始化为空数组的行为主题。每次我们调用内部的`loadTasks`方法时，结果的任务列表数组将通过调用`next`方法通过我们的行为主题发出。
- en: The `loadTasks` method is first called within the service constructor. That
    will ensure that the resulting task list obtained from the HTTP call is initially
    emitted through our behaviour subject. We also call the `loadTasks` method right
    after we've completed the POST requests within the `addTask` and `updateTask`
    methods. That will guarantee that we're reloading the updated task list from the
    "server" and emitting it through our behaviour subject.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadTasks`方法首先在服务构造函数中被调用。这将确保从HTTP调用中获得的结果任务列表最初通过我们的行为主题发出。我们还在`addTask`和`updateTask`方法完成POST请求后调用`loadTasks`方法。这将保证我们从“服务器”重新加载更新后的任务列表并通过我们的行为主题发出。'
- en: Within the `getTasks` method, we're converting our subject to an observable
    and returning it. This way, we can ensure that no one outside of the service will
    have the power to emit items through our subject. Using the observable of our
    behaviour subject, we can have hundreds of components subscribing, which will
    all receive the most recent task list whenever there is a change in our data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getTasks`方法中，我们将主题转换为可观察对象并返回它。这样，我们可以确保服务外部没有人有权力通过我们的主题发出项。使用行为主题的可观察对象，我们可以有数百个组件订阅，当数据发生变化时，所有这些组件都将接收到最新的任务列表。
- en: The in-memory web API will automatically generate IDs for our tasks when we
    add new tasks by executing a post request to the tasks resource. This means that
    when we call the `addTask` method with a task object, we can skip adding the ID
    property and the in-memory database will take care of finding the next possible
    ID value for us.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过向任务资源执行POST请求添加新任务时，内存中的Web API将自动为我们生成任务ID。这意味着当我们用任务对象调用`addTask`方法时，我们可以跳过添加ID属性，内存数据库将为我们找到下一个可能的ID值。
- en: 'Now, let''s use our updated task service in the task list component. Open up
    the `src/app/tasks/task-list/task-list.component.ts` file and apply the following
    changes. Again, effective changes are in bold:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的任务列表组件中使用更新的任务服务。打开`src/app/tasks/task-list/task-list.component.ts`文件并应用以下更改。同样，有效的更改以粗体显示：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have changed the type of our `tasks` member, which is now holding an observable
    with a task array generic type. In TypeScript, RxJS makes use of generics to specify
    what type of items will be emitted through the observable stream. The `tasks`
    member will store the observable stream which we obtain by calling our task service.
    It will make the basis for our filtering inside of the component.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更改了`tasks`成员的类型，现在它持有带有任务数组泛型类型的可观察对象。在TypeScript中，RxJS使用泛型来指定将通过可观察流发出的项的类型。`tasks`成员将存储我们通过调用任务服务获得的可观察流，它将成为我们在组件内部过滤的基础。
- en: In the constructor of our task list component, we're still calling the `getTasks`
    method of our service. However, this time, we won't receive a list of tasks synchronously.
    Instead, we're an observable stream which will emit a list of tasks when we subscribe.
    Since we're using a behaviour subject inside of the task service, we will never
    need to call the task service again to obtain tasks. If there are updates to the
    task list data, we will receive a new item through the connected observable stream
    containing the most recent task list.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的任务列表组件构造函数中，我们仍然在调用我们的服务中的`getTasks`方法。然而，这次，我们不会同步接收到任务列表。相反，我们是一个可观察的流，当订阅时将发出任务列表。由于我们在任务服务内部使用了一个行为主题，我们将永远不需要再次调用任务服务来获取任务。如果任务列表数据有更新，我们将通过连接的可观察流接收到一个新项目，其中包含最新的任务列表。
- en: We have also changed our `activeTaskFilterType` member to a behavior subject.
    That will help us in building a consistent reactive data flow within our component.
    Instead of storing the active filter type directly, we're using a subject to emit
    the filter type. Within the `activateFilterType` method, we do precisely this.
    When this method is called from our view, as a filter toggle button is clicked,
    we will emit the new active filter type using the behavior subject.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将我们的`activeTaskFilterType`成员更改为行为主题。这将帮助我们在我们组件内构建一致的反应性数据流。我们不是直接存储活动过滤器类型，而是使用主题来发射过滤器类型。在`activateFilterType`方法中，我们正是这样做的。当这个方法从我们的视图中被调用，作为一个过滤器切换按钮被点击时，我们将使用行为主题发射新的活动过滤器类型。
- en: Our `tasks` observable will always emit the latest list when the underlying
    data is changed. Also, the `activeTaskFilterType` subject is emitting an item
    when we change the active task filter. Now, we can combine both streams to implement
    our filter logic reactively. Again, think of a pipeline system. Instead of filtering
    immediately, we are building a network of pipes which will filter whenever new
    data arrives. So, how can we combine two observable streams into one? There are
    many ways to do this using the broad variety of operators RxJS provides. However,
    in our current situation, the `combineLatest` operator will work best.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`tasks`可观察对象在底层数据发生变化时始终会发射最新的列表。此外，当改变活动任务过滤器时，`activeTaskFilterType`主题会发射一个项。现在，我们可以将这两个流合并以实现我们的过滤逻辑反应性。再次，想象一个管道系统。我们不是立即过滤，而是在构建一个网络，该网络将在新数据到达时进行过滤。那么，我们如何将两个可观察流合并成一个呢？使用RxJS提供的广泛操作符有很多种方法可以做到这一点。然而，在我们的当前情况下，`combineLatest`操作符将工作得最好。
- en: 'Let''s look at a small illustration of how this operator combines multiple
    observable streams into one single observable stream:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个操作符如何将多个可观察流组合成一个单一的可观察流的小示例：
- en: '![](img/66f0af12-df90-4861-bc4d-68c8203391a4.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/66f0af12-df90-4861-bc4d-68c8203391a4.png)'
- en: Combining two observables into one by using the combineLatest operator
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`combineLatest`操作符将两个可观察合并成一个
- en: The `combineLatest` operator is combining two or more input observables into
    a single output observable. The first item will be emitted on the output observable
    when all input observables have emitted at least one item. The emitted item on
    the output observable is always an array which contains the most recent, or latest
    items of all input observables. In the preceding example, you can see that the
    first item is emitted when **Observable 2** emits its item labelled with **(a)**.
    The emitted item is an array containing both values **(1)** from **Observable
    1** and **(a)** from **Observable 2**. After the first combined item was emitted,
    if one of the input streams is emitting a new item, the output observable by `combineLatest`
    will emit an updated item which again contains the latest items of all input observables.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`combineLatest`操作符将两个或多个输入可观察对象组合成一个输出可观察对象。当所有输入可观察对象都至少发射了一个项时，输出可观察对象将发射第一个项。输出可观察对象上发射的项始终是一个数组，包含所有输入可观察对象的最新的或最新的项。在前面的示例中，你可以看到当**Observable
    2**发射带有**（a）**标记的项时，第一个项被发射。发射的项是一个包含**（1）**从**Observable 1**和**（a）**从**Observable
    2**的值的数组。在第一个组合项被发射之后，如果输入流中的任何一个正在发射一个新项，`combineLatest`的输出可观察对象将发射一个更新的项，该项再次包含所有输入可观察对象的最新项。'
- en: This is exactly the behaviour we're looking for when we're building our filter
    observable. Just switch **Observable 1** from the preceding example with our tasks
    observable and **Observable 2** with our active filter type. Now, if we either
    input an observable, the tasks observable, the active filter subject, or emit
    a new item, our filtered output observable will also produce a new item. This
    is reactive programming at its best. We never need to be concerned about updating
    our state anymore. It's all taken care of using reactive streams.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们在构建我们的过滤可观察对象时想要的精确行为。只需将前一个示例中的**Observable 1**替换为我们的任务可观察对象，**Observable
    2**替换为我们的活动过滤器类型。现在，如果我们输入一个可观察对象、任务可观察对象、活动过滤器主题或发射一个新项，我们的过滤输出可观察对象也将产生一个新项。这是反应式编程的最佳实践。我们再也不需要担心更新我们的状态了。这一切都是通过反应流来处理的。
- en: Since `combineLatest` will just produce an array of all the latest values emitted
    by the input observables, we need to use an additional map operator to provide
    the desired filtered list output. We're destructuring the value pair emitted by
    `combineLatest` into a `tasks` and `activeTaskFilterType` variable and performing
    the filtering based on that data. The resulting filtered list is returned and
    will be emitted by the output observable of the map operator.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `combineLatest` 只会生成由输入可观察对象发出的所有最新值的数组，我们需要使用一个额外的 `map` 操作符来提供所需的过滤列表输出。我们将
    `combineLatest` 发出的值对解构为 `tasks` 和 `activeTaskFilterType` 变量，并根据该数据进行过滤。结果过滤列表被返回，并将由
    `map` 操作符的输出可观察对象发出。
- en: Subscribing in the view using the async pipe
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步管道在视图中订阅
- en: We have learned about RxJS observables and that they will not start to emit
    items if we don't subscribe to them. You can compare this to the analogy of the
    drain valve of a water pipe. If you don't open the drain, the water will not flow.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了 RxJS 的可观察对象，并且知道如果我们不订阅它们，它们就不会开始发出项目。你可以将这个类比于水管排水阀。如果你不打开排水阀，水就不会流动。
- en: Within our updated task list component, we now have a `filteredTasks` observable
    to which we can subscribe to and obtain the latest filtered tasks. However, there's
    a slightly better way to handle RxJS subscriptions, which we're going to take
    a look at now.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更新的任务列表组件中，我们现在有一个 `filteredTasks` 可观察对象，我们可以订阅它并获取最新的过滤后的任务。然而，处理 RxJS 订阅有一个稍微更好的方法，我们现在将要看看。
- en: The problem with subscriptions is that they always want to be cleaned up too.
    Imagine your subscription is causing many event handlers to be added and other
    resources which might get allocated for observing your stream. Calling the `subscribe`
    method will return a subscription object, and on that subscription object, you
    will find a method called `unsubscribe`. Usually, it's always a good idea to call
    this method when you don't need the observable subscription anymore. In the case
    of Angular components, we can say that when a component gets removed from the
    view, it's a good time to clean up the observable subscriptions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅的问题在于它们总是想要被清理。想象一下，你的订阅正在导致许多事件处理程序被添加，以及其他可能为观察你的流而分配的资源。调用 `subscribe`
    方法将返回一个订阅对象，在该订阅对象上，你会找到一个名为 `unsubscribe` 的方法。通常，当你不再需要可观察对象订阅时，调用这个方法总是一个好主意。在
    Angular 组件的情况下，我们可以这样说，当组件从视图中移除时，清理可观察对象订阅是一个好时机。
- en: 'Luckily, there''s a life cycle hook called `OnDestroy` for detecting when a
    component is removed from the view. We can use this hook to clean up any subscriptions
    to RxJS observables. Let''s take a look at a straightforward example of a component
    subscribing to an observable and unsubscribing within the `OnDestroy` life cycle
    hook:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个名为 `OnDestroy` 的生命周期钩子，用于检测组件何时从视图中移除。我们可以使用这个钩子来清理对 RxJS 可观察对象的任何订阅。让我们看看一个组件在
    `OnDestroy` 生命周期钩子中订阅可观察对象并取消订阅的简单示例：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding example, we''re creating an observable stream from the mouse
    move events on the window object. All we''d like to do is display the most recent
    mouse position, which was emitted by the observable stream, within our component
    view. You can immediately see that this is quite a bit of code just for dealing
    with one observable. We need to store three things for each observable:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们正在从窗口对象的鼠标移动事件创建一个可观察对象流。我们想要做的只是显示由可观察对象流发出的最新鼠标位置，在我们的组件视图中。你可以立即看到，仅仅为了处理一个可观察对象，就需要编写大量的代码。对于每个可观察对象，我们需要存储三件事：
- en: The observable itself
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察对象本身
- en: A property to store the most recent emitted item by the stream
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于存储流最近发出的项目的属性
- en: The subscription object which allows us to unsubscribe and clean up when our
    component gets destroyed
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅对象，允许我们在组件被销毁时取消订阅并清理
- en: This might be okay if we're only dealing with one single observable, however,
    imagine if your component needs to deal with several observables at the same time.
    This is going to be quite a mess.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只处理一个单一的可观察对象，这可能没问题，但是想象一下，如果你的组件需要同时处理多个可观察对象。这将变得相当混乱。
- en: Another problematic thing is that we need to manually unsubscribe when our component
    gets destroyed using the `OnDestroy` life cycle hook. This is a manual, error-prone
    process and we can lose track over our subscriptions quite easily.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是我们需要手动使用 `OnDestroy` 生命周期钩子来取消组件的订阅。这是一个手动且容易出错的流程，我们很容易就会失去对订阅的跟踪。
- en: Luckily, Angular comes with a genius solution for this problem. Instead of dealing
    with the subscription manually, we will use a view pipe with the name `AsyncPipe`
    to subscribe directly within the view of our component. This means that we don't
    need to subscribe in our component class and extract the latest emitted item manually.
    Instead, the async pipe will extract the item for us and update our view automatically
    whenever there's a new item coming through the stream. The async pipe will also
    store the subscription internally and automatically unsubscribe for us if it detects
    that the component has been destroyed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Angular 为这个问题提供了一个天才的解决方案。我们不需要手动处理订阅，我们将使用一个名为 `AsyncPipe` 的视图管道直接在我们的组件视图中进行订阅。这意味着我们不需要在我们的组件类中进行订阅并手动提取最新发出的项目。相反，异步管道将为我们提取项目，并在有新项目通过流传入时自动更新我们的视图。异步管道还将内部存储订阅，并在检测到组件已被销毁时自动为我们取消订阅。
- en: 'Let''s look at the same example from before, but now using the async pipe.
    The component class would look like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看之前的相同示例，但现在使用异步管道。组件类将看起来像这样：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Wow! That''s a radical simplification, isn''t it? All we need to store now
    is the observable itself. Extracting the latest emitted item as well as unsubscribing
    from the stream is all handled by the async pipe. Let''s take a look at how we
    would need to change our view to use the async pipe:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这是一个激进的简化，不是吗？我们现在只需要存储可观察对象本身。提取最新发出的项目以及从流中取消订阅都由异步管道处理。让我们看看我们如何需要更改我们的视图来使用异步管道：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How cool is that! By only using the async pipe in our view, we can create a
    subscription to the observable, render the latest item emitted by the stream,
    and unsubscribe when our component gets destroyed. Additionally, from a functional
    and reactive standpoint, we also enhanced our code in a way that we don't create
    any side effects within our component class. We don't hold any intermediate state,
    and all we store is the observable stream itself. The async pipe is an excellent
    addition to your toolset when dealing with asynchronous data, and you should always
    make use of it when working with RxJS observables.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这有多酷！仅通过在我们的视图中使用异步管道，我们就可以创建对可观察对象的订阅，渲染流发出的最新项目，并在我们的组件被销毁时取消订阅。此外，从功能和响应式角度来看，我们还以我们不在我们的组件类中创建任何副作用的方式增强了我们的代码。我们不保留任何中间状态，我们存储的只是可观察对象流本身。异步管道是处理异步数据时你工具集的一个优秀补充，你应该始终在工作与
    RxJS 可观察对象一起时使用它。
- en: Okay, I hope you felt the power and simplicity of using the async pipe within
    the previous example. Now, we'll use that knowledge and refactor our task list
    component to use the async pipe to subscribe to our observables within the component
    view.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我希望你感受到了在前一个示例中使用异步管道的强大和简单。现在，我们将使用这些知识重构我们的任务列表组件，以便在组件视图中使用异步管道来订阅我们的可观察对象。
- en: 'Since we''ve already updated our component logic to expose an observable to
    emit our filtered task list, we can go directly to the view of our task list component
    and apply the changes to use the async pipe. Let''s open the `src/app/tasks/task-list/task-list.component.html`
    file and implement the following changes:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经更新了我们的组件逻辑以公开一个可观察对象来发出我们的过滤任务列表，我们可以直接进入我们的任务列表组件视图并应用更改以使用异步管道。让我们打开`src/app/tasks/task-list/task-list.component.html`文件并实现以下更改：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We've added two async pipes. The first one is to subscribe to our `activeTaskFilterType`
    behaviour subject. The async pipe will create a subscription directly from the
    view, and it will update our binding automatically whenever there's a new item
    emitted through the stream.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了两个异步管道。第一个是订阅我们的 `activeTaskFilterType` 行为主题。异步管道将直接从视图创建订阅，并且每当有新项目通过流发出时，它将自动更新我们的绑定。
- en: The second async pipe is used directly in the binding of the `NgFor` directive.
    We're subscribing to our `filteredTasks` observable, which will always emit the
    latest result of our filtered task list.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个异步管道直接用于 `NgFor` 指令的绑定。我们正在订阅我们的 `filteredTasks` 可观察对象，它将始终发出过滤任务列表的最新结果。
- en: Recap
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'Congratulations! We''ve successfully updated our code to establish a reactive
    data flow within our application using the in-memory web API and the Angular HTTP
    client. We are using RxJS observables, transforming them using operators, and
    resolving our data directly within the view using the Angular async pipe. This
    refactoring was quite a technical but significant change. We''re now following
    a very clean approach on how to react to application state changes. Our observable
    streams are router down directly into the view where we then subscribe using the
    async pipe. If Angular destroys our task list component, the async pipe will also
    take care of the necessary unsubscriptions. We''ve learned about the following
    topics:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们已经成功更新了我们的代码，使用内存 Web API 和 Angular HTTP 客户端在我们的应用中建立反应性数据流。我们正在使用 RxJS
    可观察对象，使用操作符转换它们，并使用 Angular 异步管道直接在视图中解决数据。这次重构是一个相当技术性但重要的变化。我们现在遵循一个非常干净的方法来响应应用状态的变化。我们的可观察流直接路由到视图，然后我们使用异步管道进行订阅。如果
    Angular 销毁我们的任务列表组件，异步管道也将处理必要的取消订阅。我们已经学习了以下主题：
- en: The Angular in-memory API to simulate a RESTful backend and using HTTP client
    to obtain data
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular 内存 API 模拟 RESTful 后端，并使用 HTTP 客户端获取数据
- en: RxJS basics, basic operators, as well as behaviour subject and the `combineLatest`
    operator
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJS 基础，基本操作符，以及行为主题和 `combineLatest` 操作符
- en: Using the async pipe to subscribe from the view of our components
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步管道从组件视图订阅
- en: Establishing an end-to-end reactive data architecture within our application
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的应用中建立端到端反应性数据架构
- en: Immutability
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不变性
- en: Within this section, we're going to learn about the concept of immutability.
    This knowledge will help us for the upcoming refactoring exercises of our application.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习不变性的概念。这些知识将帮助我们进行应用即将到来的重构练习。
- en: Immutable data has initially been a core concept of functional programming.
    This section will not cover immutable data in much depth, but it will explain
    the core concept so that we can talk about how to apply this idea to Angular components.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 不变数据最初是函数式编程的核心概念。本节不会深入探讨不变数据，但会解释这一核心概念，以便我们能够讨论如何将这一理念应用于 Angular 组件。
- en: Immutable data structures force you to create a full copy of the data before
    you modify it. You'll never operate on the data directly, but on a copy of this
    same data. This approach has many benefits over mutable data operations, the most
    obvious probably being clean application state management. When you always operate
    on new copies of data, there's no chance that you're messing up data that you
    didn't want to modify.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 不变数据结构迫使你在修改数据之前创建数据的完整副本。你永远不会直接操作数据，而是操作这个相同数据的副本。这种方法相对于可变数据操作有许多优点，最明显的大概是干净的应用状态管理。当你始终操作新的数据副本时，你就不可能弄乱你不想修改的数据。
- en: 'Let''s take this simple example, which illustrates the issues object references
    can cause:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的例子，它说明了对象引用可能引起的问题：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Although this seems odd at first, it makes sense that the output of this case
    is valid. `Array.reverse()` is a mutable operation, and it will modify the innards
    of the array. The actual reference will stay the same because JavaScript will
    not create a copy of the array to reverse it. Although technically this makes
    a lot of sense, this is not what we expected in the first place when we looked
    at this code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这乍一看似乎很奇怪，但这个案例的输出有效是有道理的。`Array.reverse()` 是一个可变操作，它将修改数组的内部结构。实际的引用将保持不变，因为
    JavaScript 不会创建数组的副本来反转它。虽然从技术上讲这很有道理，但这并不是我们在查看这段代码时最初预期的。
- en: 'We can quickly change this example to an immutable procedure by creating a
    copy of the array before we reverse it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在反转数组之前创建数组的副本，快速将这个例子改为一个不可变过程：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The issue with references is that they can cause a lot of unexpected side effects.
    Also, if we come back to our encapsulation topic from [Chapter 1](237031a7-f616-4811-8486-08b5113d316f.xhtml),
    *Component-Based User Interfaces*, object references are entirely against the
    concept of encapsulation. Although we might think that it would be safe to pass
    complex data types into a capsule, it''s not. As we''re dealing with references
    here, the data can still be modified from the outside, and our capsule will not
    have complete ownership. Consider the following example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 引用的问题在于它们可以引起很多意外的副作用。此外，如果我们回到[第1章](237031a7-f616-4811-8486-08b5113d316f.xhtml)的封装主题，即*基于组件的用户界面*，对象引用完全违反了封装的概念。尽管我们可能认为将复杂的数据类型传递到胶囊中是安全的，但这并不正确。因为我们在这里处理的是引用，数据仍然可以从外部被修改，我们的胶囊将不会拥有完全的所有权。考虑以下示例：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Even if we only wanted to store the data internally in our `Sum` class, we would
    have created the unwanted side effect of referencing and modifying the data object
    which is outside the instance. Multiple `sum` instances would also share the same
    data from outside and cause more side effects. As a developer, you've learned
    to treat object references correct, but they still can cause a lot of problems.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的目标只是在我们自己的`Sum`类中内部存储数据，我们也会产生引用和修改外部数据对象的副作用，这会带来不希望的结果。多个`sum`实例也会共享外部相同的数据并引起更多的副作用。作为一个开发者，你已经学会了正确地处理对象引用，但它们仍然可以引起很多问题。
- en: 'We don''t have these problems with immutable data, which can be illustrated
    easily with primitive data types in JavaScript. Primitive data types don''t use
    references, and they are immutable by design:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不可变数据，我们不会遇到这些问题，这可以通过JavaScript中的原始数据类型轻松说明。原始数据类型不使用引用，并且按设计是不可变的：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There's no way we can modify an instance of a string. Every modification that
    we perform on a string will generate a new string, and this prevents the unwanted
    side effects.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法修改字符串的一个实例。我们对字符串进行的任何修改都会生成一个新的字符串，这可以防止不希望出现的副作用。
- en: So, why do we still have object references within programming languages, even
    though they cause so many issues? Why aren't we performing all these operations
    on immutable data, and why aren't we only dealing with values rather than object
    references?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们仍然在编程语言中有对象引用，尽管它们会引起很多问题？为什么我们不只在不可变数据上执行所有这些操作，而不是只处理值而不是对象引用？
- en: Of course, mutable data structures also come with their benefits, and it always
    depends on the context if immutable data brings value.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可变数据结构也有其好处，并且是否带来价值总是取决于上下文。
- en: One of the main reasons that is often used against immutable data is its lousy
    performance. Of course, it costs some performance if we need to create tons of
    copies of our data every time we want to modify it. However, there are significant
    optimization techniques which eliminate the performance issues that we would usually
    expect from immutable data structures. Using a tree data structure that allows
    internal structural sharing, copies of the data will be shared internally. This
    technique allows for very efficient memory management, which in some situations
    even outperforms mutable data structures. I can highly recommend the paper by
    Chris Okasaki about *Purely Functional Data Structures* if you would like to read
    more about performance in immutable data structures.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 人们经常反对不可变数据的一个主要原因是其糟糕的性能。当然，如果我们每次想要修改数据时都需要创建大量数据的副本，这会消耗一些性能。然而，有一些显著的优化技术可以消除我们从不可变数据结构中通常期望的性能问题。使用允许内部结构共享的树数据结构，数据副本将在内部共享。这项技术允许非常高效的内存管理，在某些情况下甚至可以超越可变数据结构。如果你想了解更多关于不可变数据结构中的性能的信息，我强烈推荐阅读Chris
    Okasaki关于*纯函数数据结构*的论文。
- en: JavaScript does not support immutable data structures out of the box. However,
    you can use libraries, such as `Immutable.js` by Facebook, which provide you with
    an excellent API to deal with immutable data. `Immutable.js` even implements structural
    sharing and makes it a perfect power tool if you decide to build on an immutable
    architecture in your application.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript本身不支持不可变的数据结构。然而，你可以使用库，例如Facebook的`Immutable.js`，它为你提供了一个出色的API来处理不可变数据。`Immutable.js`甚至实现了结构共享，如果你决定在你的应用程序中构建不可变架构，它将是一个完美的强大工具。
- en: 'As with every paradigm, there are pros and cons, and depending on the context,
    one concept may fit better than another one. In our application, we won''t use
    immutable data structures that are provided by third-party libraries, but we''ll
    borrow some of the benefits that you get from immutable data by going by the following
    immutable idioms:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如每个范式一样，都有其优缺点，并且根据上下文，一个概念可能比另一个更适合。在我们的应用中，我们不会使用第三方库提供的不可变数据结构，但我们会借鉴以下不可变习惯用法中获得的一些好处：
- en: '**It''s much easier to reason about immutable data**: You can always tell why
    your data is in a given state because you know the exact transformation path.
    This may sound irrelevant, but in practice, this is a huge benefit not only for
    humans to write code but also for compilers and interpreters to optimize it.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解不可变数据更容易**：你总能知道你的数据为什么处于某种状态，因为你知道确切的转换路径。这可能听起来无关紧要，但在实践中，这对人类编写代码以及编译器和解释器优化代码来说都是巨大的好处。'
- en: '**Using immutable objects makes change detection much faster**: If we rely
    on immutable patterns to treat our data, we can rely on object reference checks
    to detect change. We no longer need to perform complex data analysis and comparison
    for dirty checking, and can fully rely on checking references. We have the guarantee
    that object properties don''t change without the object identity changing as well.
    This makes change detection as easy as `oldObject === newObject`.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用不可变对象使变更检测变得更快**：如果我们依赖不可变模式来处理我们的数据，我们可以依赖对象引用检查来检测变更。我们不再需要执行复杂的数据分析和比较来进行脏检查，而可以完全依赖引用检查。我们有保证，只有当对象身份发生变化时，对象属性才不会发生变化。这使得变更检测变得和
    `oldObject === newObject` 一样简单。'
- en: Immutability with TypeScript
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TypeScript的不可变性
- en: With TypeScript 2, new type features were added which help you to embrace immutable
    operations. Using the `readonly` type modifier, we can achieve a compile-time
    immutability guard.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript 2中，添加了新的类型特性，这些特性可以帮助你拥抱不可变操作。使用 `readonly` 类型修饰符，我们可以实现编译时不可变性保护。
- en: 'Let''s look at the following example of how to use the `readonly` modifier
    to define some immutable data structures:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下如何使用 `readonly` 修饰符来定义一些不可变数据结构的示例：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see from the preceding example, we can use the `readonly` modifier
    to prevent object properties from being modified. Instead, if we''d like to modify
    the `person` object, we''ll need to create a copy of that object. There are many
    ways to do this, however, using the object property spread operator is probably
    the most convenient of all. Let''s see how we can update our person object in
    an immutable way using the object property spread operator:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，我们可以使用 `readonly` 修饰符来防止对象属性被修改。相反，如果我们想修改 `person` 对象，我们需要创建该对象的副本。然而，有许多方法可以做到这一点，但使用对象属性展开操作符可能是最方便的。让我们看看我们如何使用对象属性展开操作符以不可变的方式更新我们的
    `person` 对象：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Using the object property spread operator, we can spread all existing properties
    and their values of the existing person object into a new object literal. In the
    same step, we can then override any properties, right after the spread operation.
    This allows us to easily create a copy of an existing object and add or override
    specific properties. The preceding code could also be written by using `Object.assign`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象属性展开操作符，我们可以将现有的人对象的所有现有属性及其值展开到新对象字面量中。在相同步骤中，我们还可以在展开操作之后覆盖任何属性。这使我们能够轻松地创建现有对象的副本并添加或覆盖特定属性。前面的代码也可以通过使用
    `Object.assign` 来编写：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Actually, this is how the object spread operator is desugaring to JavaScript.
    However, it's much more convenient to use the spread operator than `Object.assign`.
    The object spread operator is proposed to the future JavaScript standard and is
    currently at stage 3.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这就是对象展开操作符在JavaScript中解构的方式。然而，使用展开操作符比使用 `Object.assign` 更方便。对象展开操作符已被提出作为未来的JavaScript标准，目前处于第3阶段。
- en: Pure components
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯组件
- en: The idea of a "pure" component is that its whole state is represented by its
    inputs, where all inputs are immutable. This is effectively a stateless component,
    but additionally, all the inputs are immutable.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: “纯”组件的想法是，其整个状态由其输入表示，其中所有输入都是不可变的。这实际上是一个无状态组件，但除此之外，所有输入都是不可变的。
- en: 'I like to call such components "pure" because their behaviour can be compared
    to the concept of pure functions in functional programming. A pure function is
    a function which has the following properties:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢称这样的组件为“纯”组件，因为它们的行为可以与函数式编程中纯函数的概念相比较。纯函数具有以下特性：
- en: It does not rely on any state outside of the function scope
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不依赖于函数作用域之外的状态
- en: It always behaves the same and returns the same result if input parameters don't
    change
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入参数没有改变，它总是表现相同并返回相同的结果
- en: It never changes any state outside the function scope (side effect)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它永远不会在函数作用域之外改变任何状态（副作用）
- en: With pure components, we have a simple guarantee. A pure component will never
    change without its input parameters being changed. Sticking to this idea about
    components gives us several advantages. Besides having a complete trust in your
    component state, we can also gain some performance benefits by optimizing the
    change detection of Angular. We know that a component will render exactly the
    same if its inputs don't change. This means that we can ignore all components
    and their subcomponents in change detection if there are no input changes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯组件，我们有一个简单的保证。纯组件在没有其输入参数改变的情况下永远不会改变。坚持这种关于组件的想法给我们带来了几个优点。除了对你的组件状态有完全的信任之外，我们还可以通过优化Angular的变更检测来获得一些性能上的好处。我们知道，如果组件的输入没有改变，它将渲染出完全相同的结果。这意味着，如果没有输入变化，我们可以忽略所有组件及其子组件的变更检测。
- en: 'It''s very easy to reason about pure components. Their behaviour can be predicted
    very easily. Let''s look at a simple illustration of a component tree with only
    pure components:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 理解纯组件非常简单。它们的行为可以很容易地预测。让我们看看一个只有纯组件的组件树的简单示例：
- en: '![](img/4ecbe63d-591d-4b00-9fff-f10b11700f8a.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![纯函数示例](img/4ecbe63d-591d-4b00-9fff-f10b11700f8a.png)'
- en: A component tree with immutable components
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 具有不可变组件的组件树
- en: Usually, Angular performs change detection for every single binding in all of
    your components within the component tree. It does that on every browser event,
    which could change your system state. This eventually comes with a large performance
    overhead.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Angular会对组件树中所有组件的每个绑定执行变更检测。它会在每个浏览器事件上执行，这些事件可能会改变你的系统状态。这最终会带来很大的性能开销。
- en: 'If we have the guarantee that each component in our tree has a stable state
    until an immutable input property changes, we can safely ignore change detection
    that would usually be triggered by Angular. The only way that such a component
    could change is if an input of the component changes. Let''s say that there''s
    an event that causes the root component (**A**) to change the input binding value
    of component (**B**), which will change the value of a binding on component (**E**).
    This event and the resulting procedure would mark a certain path in our component
    tree to be checked by change detection:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们保证树中的每个组件在不可变的输入属性改变之前都有一个稳定的状态，我们就可以安全地忽略Angular通常会触发的变更检测。这种组件唯一可能改变的方式是如果组件的输入发生了变化。假设有一个事件导致根组件（**A**）改变组件（**B**）的输入绑定值，这将改变组件（**E**）上的绑定值。这个事件和由此产生的程序将标记我们的组件树中的某个路径以供变更检测检查：
- en: '![](img/53dd7069-784c-4b89-8b69-541b23283468.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![组件树示例](img/53dd7069-784c-4b89-8b69-541b23283468.png)'
- en: A marked path for change detection (in black) with "pure" components
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 变更检测的标记路径（黑色）与“纯”组件
- en: Although the state of the root component changed, which also changed input properties
    of the subcomponents on two levels, we only need to be concerned about a given
    path when thinking about possible changes in the system. Pure components give
    us the promise that they will not change if their inputs don't change. Immutability
    plays a big role here. Imagine that you're binding a mutable object to component
    (**B**), and component (**A**) would change a property of this object. As we use
    object references and mutable objects, the property would also be changed for
    component (**B**). However, there's no way for component (**B**) to notice this
    change and it would leave our component tree in an unstable state. Basically,
    we'd need to go back to the regular dirty checking of the whole tree again.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管根组件的状态发生了变化，这也导致了两个级别的子组件的输入属性发生变化，但在考虑系统可能的变化时，我们只需要关注给定路径。纯组件给我们一个承诺，即如果它们的输入没有变化，它们就不会改变。不可变性在这里起着重要作用。想象一下，你正在将一个可变对象绑定到组件（**B**），而组件（**A**）会改变这个对象的属性。由于我们使用对象引用和可变对象，该属性也会为组件（**B**）改变。然而，组件（**B**）无法注意到这种变化，并且它会使我们的组件树处于不稳定状态。基本上，我们需要再次回到整个树的常规脏检查。
- en: By knowing that all our components are pure and that their inputs are immutable,
    we can tell Angular to disable change detection until an input property value
    changes. This makes our component tree very efficient, and Angular can optimize
    change detection effectively. When thinking about large component trees, this
    can make the difference between a stunningly fast application and a slow one.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道所有组件都是纯组件，并且它们的输入是不可变的，我们可以告诉 Angular 在输入属性值发生变化之前禁用变更检测。这使得我们的组件树非常高效，Angular
    可以有效地优化变更检测。当考虑大型组件树时，这可能会在惊人的快速应用程序和慢速应用程序之间产生差异。
- en: The change detection of Angular is very flexible, and each component gets its
    own change detector. We can configure the change detection of a component by specifying
    the `changeDetection` property of the component decorator.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的变更检测非常灵活，每个组件都有自己的变更检测器。我们可以通过指定组件装饰器的 `changeDetection` 属性来配置组件的变更检测。
- en: Using `ChangeDetectionStrategy`, we can choose from two strategies that apply
    for the change detection of our component. In order to tell Angular that our component
    should only be checked if an immutable input was changed, we can use the `OnPush`
    strategy. This change detection mode is specifically designed for the purpose
    of pure components.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ChangeDetectionStrategy`，我们可以从适用于我们组件变更检测的两个策略中选择。为了告诉 Angular，我们的组件只有在不可变输入发生变化时才应该被检查，我们可以使用
    `OnPush` 策略。这种变更检测模式是专门为纯组件设计的。
- en: 'Let''s take a look at the two different configuration possibilities of component
    change-detection strategies and some possible use cases:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看组件变更检测策略的两种不同配置可能性以及一些可能的用例：
- en: '| **Change-detection strategy** | **Description** |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| **变更检测策略** | **描述** |'
- en: '| --- | --- |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `OnPush` | This strategy tells Angular that a given component subtree will
    only change under one of the following conditions:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '| `OnPush` | 这种策略告诉 Angular，给定的组件子树只有在以下条件之一成立时才会改变：'
- en: One of the input properties changes where changes need to be immutable. Inputs
    are always checked for reference changes (using the triple-equals operator `===`)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中一个输入属性发生变化，需要保持不可变。输入始终会检查引用变化（使用三元等号运算符 `===`）
- en: An event binding within the component subtree is receiving an event. This condition
    tells Angular that there might be a change inside of the component itself and
    it will trigger change detection, even if none of the inputs have changed.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件子树内的一个事件绑定正在接收一个事件。这种条件告诉 Angular，组件内部可能发生了变化，并且它将触发变更检测，即使没有任何输入发生变化。
- en: '|'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Default | The default strategy of Angular''s change detection will perform
    change detection for every single browser event which occurs within your application.
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 默认 | Angular 的变更检测默认策略将对应用程序内发生的每个浏览器事件执行变更检测。 |'
- en: Introducing container components
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入容器组件
- en: 'The main topic of this book is to learn how to create scalable user interfaces
    using Angular components. You can probably already see a trend within this chapter.
    From a simple task list component holding its own state, we''re slowly moving
    into a more serious and maintainable application architecture. We''ve already
    been going through some major refactorings which can be summarized as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的主要主题是学习如何使用 Angular 组件创建可扩展的用户界面。你可能已经在这个章节中看到了一个趋势。从一个拥有自身状态的简单任务列表组件，我们正逐渐过渡到一个更严肃且可维护的应用程序架构。我们已经进行了一些主要的重构，可以总结如下：
- en: Creating a simple task list component to list some tasks coming from a simple
    list of plain objects
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的任务列表组件来列出一些来自简单对象列表的任务
- en: Splitting the task list component into various subcomponents and finding the
    right size for our components (task list, task, checkbox, toggle)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将任务列表组件拆分为各种子组件，并找到我们组件的正确大小（任务列表、任务、复选框、切换）
- en: Introducing a service in order to store our task data and remove any data which
    was directly embedded into our components
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入一个服务来存储我们的任务数据，并移除任何直接嵌入到我们的组件中的数据
- en: Using the Angular HTTP client and the in-memory web API to simulate asynchronous
    data fetching and using RxJS observables in our service and components
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular HTTP 客户端和内存中的 Web API 来模拟异步数据获取，并在我们的服务和组件中使用 RxJS 可观察对象
- en: 'Within this section, we''re going to learn about another concept which will
    enhance our maintainability even further. The concept of container components
    helps us to separate our user interface from our application state. This might
    sound difficult at the beginning but it''s actually a concept which blends really
    nicely into our existing approach. With the introduction of container components,
    we''re setting clear responsibilities when it comes to state management. Let''s
    look at the following illustration to see the concept in action:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习另一个概念，这将进一步增强我们的可维护性。容器组件的概念帮助我们分离用户界面和应用状态。这可能在开始时听起来有些困难，但实际上这是一个很好地融入我们现有方法的理念。随着容器组件的引入，我们在状态管理方面明确了责任。让我们看一下以下插图，以了解这一概念的实际应用：
- en: '![](img/76242032-1ff5-46bb-9c26-f662dd4781e6.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/76242032-1ff5-46bb-9c26-f662dd4781e6.png)'
- en: Container component and interactions with regular UI components
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 容器组件与常规 UI 组件的交互
- en: Container components are in charge of your application state. They are the only
    components of your system which are allowed to manipulate state and data. They
    are passing this state and data down into your user interface component through
    component input. Within the preceding illustration, we have a container component
    surrounding **Component A**. **Component A** is again consisting of a subcomponent,
    **B**. Data is flowing down from our container component into component **A**
    and **B**. Whenever the container provides new data, that data is seeping down
    into your user interface components through their inputs.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 容器组件负责您的应用程序状态。它们是系统中唯一允许操作状态和数据的组件。它们通过组件输入将状态和数据传递到您的用户界面组件中。在前面的插图中，我们有一个围绕**组件
    A**的容器组件。**组件 A**再次由一个子组件**B**组成。数据从我们的容器组件流向组件**A**和**B**。每当容器提供新的数据时，这些数据就会通过它们的输入渗透到您的用户界面组件中。
- en: 'Now, here comes the tricky part of this concept. User interface components,
    like component **A** and **B** within our illustration, are never, ever manipulating
    data directly. They will always delegate to their parent component. I often explain
    this concept as a kind of **inversion of control** (**IoC**). Instead of performing
    the action which was triggered by a user controlling the user interface directly,
    we just delegate to the parent component and tell it to perform this action. If
    the parent component is a simple UI component too, we delegate again. This goes
    on until we reach a container component. The container component then has the
    ability to effectively perform the desired operation on the application state.
    Once performed, the updated data will then seep back down the component tree.
    This approach of building user interfaces comes with an amazing list of positive
    effects on your application architecture:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里是这个概念中棘手的部分。用户界面组件，如我们插图中的组件**A**和**B**，永远不会直接操作数据。它们总是会委托给父组件。我经常将这个概念解释为一种**控制反转**（**IoC**）。我们不是直接执行由用户控制的用户界面触发的操作，而是委托给父组件，并告诉它执行这个操作。如果父组件也是一个简单的UI组件，我们再次委托。这样一直进行，直到我们达到容器组件。容器组件然后能够有效地在应用程序状态上执行所需的操作。一旦执行，更新的数据就会通过组件树向下渗透。这种构建用户界面的方法给您的应用程序架构带来了惊人的积极影响：
- en: '**All your data manipulation is handled in a central location**:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有您的数据操作都在一个中心位置处理**：'
- en: This is really beneficial since we can always go to one single place if we need
    to change the way we manipulate our state and data.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这非常有好处，因为如果我们需要更改处理状态和数据的方式，我们总是可以只去一个地方。
- en: '**All user interface components can be "pure"**:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有用户界面组件都可以是"纯"组件**：'
- en: Since we won't have any user interface components which manipulate data directly,
    and they are only dependent on the data which is flowing down the component tree
    into their inputs, we can build "pure" components in most cases. This gives all
    the benefits of "pure" components, including the performance boost.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们不会有任何直接操作数据的用户界面组件，并且它们只依赖于流入其输入的组件树中的数据，我们大多数情况下可以构建"纯"组件。这带来了"纯"组件的所有好处，包括性能提升。
- en: '**Container components act as adapter layers**:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器组件作为适配层**：'
- en: Since the container components are the only components which interact with your
    data services, database, state machine, or whatever else you're using to manage
    your state and data, we can see them as adapters of your application user interface
    to your data layer. When you decide to go differently about your state management
    and data sources, the only place where you need to apply changes is your container
    components.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于容器组件是唯一与您的数据服务、数据库、状态机或您用于管理状态和数据的任何其他组件交互的组件，我们可以将它们视为您的应用程序用户界面到数据层的适配器。当您决定改变您的状态管理和数据源时，您唯一需要应用更改的地方就是您的容器组件。
- en: '**Separation of state and user interface**:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态和用户界面的分离**：'
- en: The separation of your application's state from your user interface is underestimated
    by far. By building a simple UI component which just accepts data through its
    inputs, we can build highly flexible and reusable components. If we would like
    to include them in a completely different context of state and data, we simply
    create another container component.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将您应用程序的状态与您的用户界面分离被远远低估了。通过构建一个简单的UI组件，它只通过其输入接受数据，我们可以构建高度灵活和可重用的组件。如果我们想将它们包含在完全不同的状态和数据上下文中，我们只需创建另一个容器组件。
- en: Purifying our task list
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯化我们的任务列表
- en: In the previous three sections, we looked into the basics of using immutable
    data structures and that Angular can be configured to assume that components only
    change when their input changes. We learned about the concept of "pure" components
    and how we can configure Angular's change detection to gain some performance benefits.
    We also learned about the concept of container components to separate our UI components
    from our application state.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的三个部分中，我们探讨了使用不可变数据结构的基本方法，以及Angular可以被配置为假设组件只有在它们的输入发生变化时才会改变。我们学习了"纯"组件的概念以及我们如何配置Angular的变更检测以获得一些性能优势。我们还学习了容器组件的概念，以将我们的UI组件与应用程序状态分离。
- en: Within this section, we would like to refactor our application to include our
    newly learned skills about immutability, "pure" components, and container components.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们希望重构我们的应用程序，以包括我们新学的关于不可变性、"纯"组件和容器组件的技能。
- en: Let's start with our existing task list component. Currently, this component
    is directly interacting with data coming from the task service. However, we have
    learned that "pure" UI components should never directly retrieve or manipulate
    the state or data of our application. Instead, they should only depend on their
    inputs to retrieve data.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从现有的任务列表组件开始。目前，这个组件直接与来自任务服务的数据交互。然而，我们已经了解到，“纯”UI组件永远不应该直接检索或操作应用程序的状态或数据。相反，它们应该只依赖于它们的输入来检索数据。
- en: 'Open up the `src/app/tasks/task-list/task-list.component.ts` file and apply
    the following changes. The code changes are highlighted in bold:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`src/app/tasks/task-list/task-list.component.ts`文件并应用以下更改。代码更改以粗体显示：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can immediately see that our component is now much simpler. Instead of it
    containing all the filter logic, we're just relying on the tasks passed to the
    component using the `tasks` input. Our task list component is now assuming that
    the tasks coming into the component input are already filtered and that it's no
    longer in control of the filtering itself. It still renders the filters, however,
    as you can see from the `activateFilterType` method, we're now using output properties
    to delegate the filter action to the parent component. We've also added outputs
    for adding a task as well as for updating a task. We've learned from the previous
    section about container components that our UI components use inversion of control.
    That's exactly what is happening here. We're no longer manipulating our state,
    but instead delegating the manipulation to our parent component using output properties.
    The `addTask` method, as well as the `updateTask` method, are both just emitting
    output, nothing else.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以立即看出，我们的组件现在要简单得多。不再包含所有过滤逻辑，我们只是依赖于通过`tasks`输入传递给组件的任务。我们的任务列表组件现在假定传入组件输入的任务已经过过滤，并且它不再控制过滤过程本身。然而，它仍然渲染过滤条件，正如从`activateFilterType`方法中可以看到的，我们现在使用输出属性将过滤操作委托给父组件。我们还添加了添加任务以及更新任务的输出。我们从上一节关于容器组件的内容中了解到，我们的UI组件使用控制反转。这正是这里发生的事情。我们不再直接操作我们的状态，而是通过输出属性将操作委托给父组件。`addTask`方法和`updateTask`方法都只是发出输出，没有其他操作。
- en: The same principle which we used for the tasks is also applied to the filter
    type list and the active filter type. We're using the input properties `taskFilterTypes`
    and `activeTaskFilterType` so that we can pass this information down from the
    parent component. The task list is no longer in charge of controlling the state
    of the active filter type and we can control this state from the parent container
    component.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于任务的原则也应用于过滤类型列表和活动过滤类型。我们使用输入属性`taskFilterTypes`和`activeTaskFilterType`，以便我们可以从父组件传递这些信息。任务列表不再负责控制活动过滤类型的状态，我们可以从父容器组件控制这个状态。
- en: 'Since we''re now assuming that tasks passed into the component using the task''s
    input property are already filtered, we need to apply a small change to our component
    template, too. Also, we no longer need the async pipe in our task list component,
    since our component will receive the resolved array of filtered tasks directly.
    We''ll let our container component deal with the observables. Let''s open the
    `src/app/tasks/task-list/task-list.component.html` file and apply some changes.
    Changed code is highlighted in bold and the ellipsis symbol is indicating more
    hidden but irrelevant code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在假定通过任务输入属性传递给组件的任务已经过过滤，因此我们需要对我们的组件模板进行一些小的修改。此外，我们不再需要在任务列表组件中使用异步管道，因为我们的组件将直接接收过滤任务的解析数组。我们将让容器组件处理可观察对象。让我们打开`src/app/tasks/task-list/task-list.component.html`文件并应用一些更改。更改的代码以粗体显示，省略号符号表示更多隐藏但无关的代码：
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That's already it in our task list component. We're now only relying on input
    properties for obtaining the data required to render our component. This makes
    our component so much simpler, doesn't it?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的任务列表组件中，这已经足够了。我们现在只依赖于输入属性来获取渲染组件所需的数据。这使我们的组件变得如此简单，不是吗？
- en: Let's continue with the container component for our task list. We're creating
    a new component using the Angular CLI. This time, we're creating the component
    into a separate subfolder called `container`. As our application grows, and we
    have more container components that need to be created, we will put them all into
    this folder.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续处理我们的任务列表容器组件。我们正在使用Angular CLI创建一个新的组件。这次，我们将组件创建到一个名为`container`的单独子文件夹中。随着我们的应用程序的增长，我们需要创建更多的容器组件，我们将它们全部放入这个文件夹中。
- en: 'Also, note that we''re now starting to use the `-cd onpush` option for generating
    components using the Angular CLI. This will add the change detection strategy
    `OnPush` onto our generated component stubs for us:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们现在开始使用Angular CLI的`-cd onpush`选项来生成组件。这将为我们生成的组件存根添加`OnPush`更改检测策略：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The task list container is now responsible for dealing with the data necessary
    to render a task list component. It will also perform all the state and data manipulation
    required to cover the behaviour of our task list. Let''s open the generated component
    class file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 任务列表容器现在负责处理渲染任务列表组件所需的数据。它还将执行所有必要的状态和数据操作，以覆盖我们的任务列表的行为。让我们打开生成的组件类文件：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When looking at the code of our new task list container component, you should
    notice something. The code is an exact copy of the code we had in our task list
    component before we turned it into a "pure" UI component. Well, does this look
    right? If you look at the code again, now that we have learned about separating
    the user interface concerns from our application state, you will notice that none
    of this code is actually the responsibility of a UI task list component. It's
    code that is mainly concerned with data manipulation and retrieval. It should
    actually never have been part of our task list UI component. This code clearly
    belongs to a container component.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看我们的新任务列表容器组件的代码时，你应该会注意到一些东西。代码是我们之前在任务列表组件中拥有的代码的精确副本。嗯，这看起来对吗？如果你再次查看代码，现在我们已经了解了如何将用户界面关注点从我们的应用程序状态中分离出来，你会注意到这些代码实际上并不是UI任务列表组件的责任。这是主要关注数据操作和检索的代码。实际上，这些代码永远不应该成为我们任务列表UI组件的一部分。这些代码显然属于容器组件。
- en: 'The next step is to create the view template of our container component. A
    container component should actually never contain much code in the template. Ideally,
    the only thing you want to do within the view of a container component is to render
    the UI component which you''re concerned with in that specific container. Let''s
    open the `src/app/container/task-list-container/task-list-container.component.html`
    file and change its content to the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建我们的容器组件的视图模板。实际上，容器组件的模板中不应包含太多代码。理想情况下，你希望在容器组件的视图中做的唯一事情是渲染你在这个特定容器中关心的UI组件。让我们打开`src/app/container/task-list-container/task-list-container.component.html`文件，并将其内容更改为以下内容：
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you will have noticed, the only things we're concerned about in the view
    of our task list container component is to render a task list UI component. We're
    passing the list of filtered tasks into the task list component. Since we're using
    an observable within our container component, we use the async pipe again to subscribe
    and resolve to the most recently filtered task list. Similarly, we're passing
    the list of filter types and the currently active filter, which we both now store
    in our container, down into the task list component.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所注意到的，在我们任务列表容器组件的视图中，我们唯一关心的事情是渲染任务列表UI组件。我们将过滤后的任务列表传递给任务列表组件。由于我们在容器组件中使用了一个可观察对象，我们再次使用异步管道来订阅并解析最新的过滤后的任务列表。同样，我们传递过滤类型列表和当前活动过滤器，我们两者现在都存储在容器中，并将其传递到任务列表组件中。
- en: On the other hand, we're binding the outputs of the task list UI component and
    calling the necessary method within the container when we get notified about updated
    tasks, filter changes, and newly added tasks. The task list UI component just
    tells us **what** to do, and inside of the container component, that we know **how**
    to do it.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当我们在收到任务更新、过滤器更改和新添加的任务的通知时，我们将绑定任务列表UI组件的输出，并在容器中调用必要的函数。任务列表UI组件只是告诉我们**做什么**，而在容器组件内部，我们知道**如何**去做。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to deal with data and application state
    in a way which is best for the maintainability of our application. We have switched
    our task service from synchronous operations on tasks stored within the service
    directly to using the Angular in-memory web API and the HTTP client.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何以最适合我们应用程序可维护性的方式处理数据和应用程序状态。我们将任务服务从直接在服务内存储的任务上的同步操作切换到使用Angular内存网络API和HTTP客户端。
- en: We learned about how we can profit from concepts, such as reactive programming,
    observable data structures, and immutable objects, in order to make our application
    perform better, and most importantly, simple and easy to reason about.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何从概念中获利，例如响应式编程、可观察的数据结构和不可变对象，以便使我们的应用程序性能更佳，最重要的是，简单且易于推理。
- en: We have also learned about the separation of user interface from application
    state and implemented the concept of container components into our application.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了将用户界面与应用程序状态分离，并将容器组件的概念应用到我们的应用程序中。
- en: In the next chapter, we're going to organize our application on a larger scale.
    By introducing a new project layer, we can start organizing tasks within projects.
    We will create the necessary state and UI components in order to view and edit
    tasks within projects.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将以更大的规模组织我们的应用程序。通过引入一个新的项目层，我们可以开始组织项目内的任务。我们将创建必要的状态和UI组件，以便在项目内查看和编辑任务。
