- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Redux: The Best State Management Solution'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the requirements of your JavaScript single-page applications become more
    complicated, it will become challenging to maintain the application state. This
    application state can be created from server or API responses, the local component
    state, and the UI state such as pagination controls, active routes, and selected
    tabs. The state can be changed with the help of direct or indirect models or UI
    interactions in your application. At some point, you may lose control over when,
    why, and how the state has been changed. This issue has been resolved by state
    management design patterns and libraries such as Flux, Redux, MobX, Recoil, Rematch,
    Vuex, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right state management solution is crucial for any medium- to large-scale
    React application. After reading this chapter, you will be able to answer questions
    fluently about the Flux pattern and Redux architecture, core principles, main
    components, handling asynchronous data flow, middleware such as Saga and Thunk,
    and Redux DevTools for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Flux pattern and Redux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core principles of Redux, components, and APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redux middleware – Saga and Thunk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standardizing Redux logic using RTK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging applications using Redux DevTools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redux was initially created for React applications and it is quite popular among
    all the state management libraries available. Let’s learn more about the Flux
    pattern, Redux fundamentals, and core concepts in the next section for a better
    understanding of the Redux library.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Flux pattern and Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flux has been created as a design pattern to manage the data flow in React applications.
    This is a slight modification of the *Observer* pattern, which defines a subscription
    mechanism in which any state change to one object notifies all other objects ([https://en.wikipedia.org/wiki/Observer_pattern](https://en.wikipedia.org/wiki/Observer_pattern)).
  prefs: []
  type: TYPE_NORMAL
- en: In 2015, the Redux library was introduced. It was inspired by Flux architecture
    but implemented differently. The next couple of questions focus on Flux and Redux
    core concepts for the strong foundation of the Redux state management library.
  prefs: []
  type: TYPE_NORMAL
- en: What is the Flux pattern? Can you explain the data flow?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flux is a pattern for managing the unidirectional data flow in your application
    and acts as a replacement for the traditional MVC pattern. It is neither a framework
    nor a library but a new kind of architecture to resolve the state management complexities
    in client-side web applications. It has been developed and used by Facebook internally
    while working with React applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flux has four major components in its data flow: Action, Dispatcher, Store,
    and View. Here’s a little more about them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Action**: This represents a JavaScript object that is sent to the dispatcher
    to trigger the data flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dispatcher**: This is a singleton registry of callbacks to update the store,
    and it works as a central hub of the data flow in the Flux application. It has
    no real intelligence and simply dispatches the payload from the action to the
    store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Store**: This is the place where the application state and logic are maintained.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: This receives the data from the store and re-renders the app. The
    view is going to trigger the action for any user interactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The step-by-step data flow of the Flux architecture based on the preceding
    components looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: If any user performs any UI interactions, an event will be generated, and the
    views will send actions to the dispatcher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dispatchers send those actions to the respective stores.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stores update the state and notify the views to re-render.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram describes how the data flow happens in a Flux-based web
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Flux data flow](img/Figure_06.01_B18603.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Flux data flow'
  prefs: []
  type: TYPE_NORMAL
- en: In most applications, we will also create *action creators* as a library of
    helper methods that not only create action objects but also pass the action to
    the dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: What are the advantages of Flux?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Flux architecture comes with the following advantages and is helpful to
    use in client-side web applications:'
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to understand because of its unidirectional data flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Flux components are decoupled, and each component has its own responsibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is an open source architecture rather than a framework or a library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runtime errors will be reduced because of its design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easy to maintain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Flux architecture helps move the implementation of API communication, caching,
    and localization code out from the view or UI layer.
  prefs: []
  type: TYPE_NORMAL
- en: How do you differentiate Flux from MVC?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Model, View, Controller** (**MVC**) design pattern was introduced in 1976
    in the Smalltalk programming language. As the application grows, this pattern
    becomes complex with its multi-data flow. The Facebook team solved this problem
    by introducing the Flux architecture. The major differences between MVC and Flux
    design patterns are listed in the following table.
  prefs: []
  type: TYPE_NORMAL
- en: '| **MVC** | **Flux** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| The data flow direction is bi-directional | The data flow direction is unidirectional
    |'
  prefs: []
  type: TYPE_TB
- en: '| The controller handles the logic | The store handles the logic |'
  prefs: []
  type: TYPE_TB
- en: '| There is no store concept in MVC | There can be multiple stores in Flux |'
  prefs: []
  type: TYPE_TB
- en: '| It is synchronous | It is asynchronous |'
  prefs: []
  type: TYPE_TB
- en: '| Debugging is difficult due to the bi-directional data flow | Debugging is
    easier with the dispatcher |'
  prefs: []
  type: TYPE_TB
- en: '| It is used for both client-side and server-side frameworks | It is used for
    client-side frameworks only |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.1: MVC versus Flux'
  prefs: []
  type: TYPE_NORMAL
- en: Flux is not totally a different approach from MVC, but it is an improved MVC
    pattern. If the application is complex and has a complicated data model, it’s
    better to opt for Flux over MVC.
  prefs: []
  type: TYPE_NORMAL
- en: What is Redux?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Redux is a popular and predictable state container library designed to write
    JavaScript applications that behave consistently across client, server, and native
    environments, and at the same time, is easy to test. It is inspired by Facebook’s
    Flux architecture. The unnecessary complexities that existed in the Flux pattern
    have been eliminated by it.
  prefs: []
  type: TYPE_NORMAL
- en: It is quite straightforward to use a component state when the application contains
    fewer components. As the number of components increases and the application becomes
    larger, it will be challenging to maintain the state of each component in your
    application. In this case, Redux comes to the rescue to manage the state of large
    applications by creating a global store, and all the needed components use this
    global store without passing down props from one component to the other.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Redux is a lightweight library with a size of around 2 KB, including its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: What are the differences between Flux and Redux?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though Redux is inspired by the Flux architecture, there are a few major
    differences, as listed in the following table.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Flux** | **Redux** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| This was developed by Facebook | This was developed by Dan Abramov and Andrew
    Clark |'
  prefs: []
  type: TYPE_TB
- en: '| It is an application architecture to manage the application state | It is
    an open source JavaScript library to manage the state |'
  prefs: []
  type: TYPE_TB
- en: '| Flux provides multiple stores in the application | The intended pattern in
    Redux is to have only one store in the application |'
  prefs: []
  type: TYPE_TB
- en: '| It consists of four major components:ActionDispatcherStoreView | It consists
    of three major components:ActionReducerStore |'
  prefs: []
  type: TYPE_TB
- en: '| The store manages the logic handling | Reducers manage the logic handling
    |'
  prefs: []
  type: TYPE_TB
- en: '| It has a singleton dispatcher | It won’t use any dispatcher |'
  prefs: []
  type: TYPE_TB
- en: '| The store’s state can be mutable | The store’s state is immutable |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.2: Flux versus Redux'
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the preceding differences, Redux reduces complexity via functional
    composition, unlike Flux, which uses callback registration.
  prefs: []
  type: TYPE_NORMAL
- en: When do you need to use Redux?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Redux is used to maintain and update the data across your application with a
    shared state for multiple components. But it may not be needed for all kinds of
    applications. It comes with a big learning curve and the need to write more code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of use cases where Redux is useful:'
  prefs: []
  type: TYPE_NORMAL
- en: You have large amounts of application state that needs to be shared by many
    components in the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to follow a single source of truth for your application state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application state needs to be updated frequently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logic of updating the application state is complex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to monitor how the state update happens over a period
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application code is not a small-scale code base and many team members need
    to work on it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, if you can manage state within React or any other frontend framework
    itself, then you don’t need to use Redux.
  prefs: []
  type: TYPE_NORMAL
- en: Redux is not just a tiny library; it is also a pattern based on core principles,
    a working system with three major components, and provides several add-ons and
    vast APIs to cover common use cases in Redux applications. Let’s dive deep into
    all these topics in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Core principles of Redux, components, and APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though Redux is inspired by the important qualities of Flux architecture,
    it has its own foundation principles and various components that make the Redux
    system handle state management in massive applications. As part of this section,
    you will get a clear understanding of Redux internals and their usage to answer
    medium- to advanced-level questions.
  prefs: []
  type: TYPE_NORMAL
- en: What are the core principles of Redux?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Redux is based on three core principles. These principles are helpful to understand
    the library in a better way:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getState()` function, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This single tree is also helpful to persist the state in development for a faster
    development cycle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The one-store approach of Redux is one of the major differences from the multi-store
    approach of Flux.
  prefs: []
  type: TYPE_NORMAL
- en: '**The state is read-only**: The only possible way to modify the state is to
    emit an action, an object form that describes what happened. That means an application
    cannot change the state directly, but instead, expresses an intent to change the
    state by passing an action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since the preceding action is a plain JavaScript object, it can be serialized,
    stored, logged, and replayed for debugging purposes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`cities` state variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Initially, your application can start with a single reducer. Once your application
    grows, you can split the large reducer into multiple small reducers that manage
    specific parts of the state tree. Moreover, you can also control the order of
    reducers invoked, passing the additional data, and making them reusable in the
    application for common tasks.
  prefs: []
  type: TYPE_NORMAL
- en: How does Redux work? What are the main components of Redux?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Redux system works by holding the entire state of the application in a
    central store. Each UI component that is a child of the Redux''s provider can
    access this stored state instead of sending the props from one component to the
    other. The entire process of the Redux workflow is based on three main core components:
    **Actions**, **Reducers**, and **the Store**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The workflow of Redux using the core components is explained with a simple
    todo example for better understanding in the following code. In the example, daily
    activities such as eating and running are considered as todos and added to the
    store using the Redux workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type` fields that denote what kind of action to perform, and other data fields
    that are used to change the state. They are the only way to send the application
    data (for example, through form data, user interaction, or API calls) to the Redux
    store. All these actions are created via action creators, which are just functions
    that return actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding action also contains todo details as a payload. It will be executed
    by the `store.dispatch(addTodo)` method, which sends this action to the store.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`todo`, which looks like the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding reducer takes the initial state and action as arguments. If the
    switch case matches with the `ADD_TODO` action type, it copies the existing todos
    from the state, updates the todos with a new `todo` value, and returns the todo
    new list. Otherwise, the existing state with unchanged todos will be returned.
    You can add more functional cases based on possible actions such as updating,
    deleting, and filtering todos in the application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is not restricted to using switch-case code blocks only to decide what the
    new state should be. You can also use `if/else` loops or any other programming
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: '`createStore` or `configureStore`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dispatch(action)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getState()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These helper methods are going to be used to create or update the todos state
    in the store, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As the application grows, the specific parts of the state information from the
    store’s state can be accessed using functions known as *selectors*. The reselect
    library is popular for memoized selector functions.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to extend the store functionality by adding store enhancers
    and middleware. These topics will be covered in the upcoming questions in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Can I use Redux with non-React UI libraries?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though Redux is mostly used with React and React Native libraries, it can
    be used with any other UI library (i.e., Redux works as a data store for various
    UI libraries). But you need to use the UI binding library to integrate Redux with
    your UI framework or library. For example, React Redux is the official binding
    library to tie Redux together with the React library. There are bindings available
    for AngularJS, Angular, Vue, Mithril, Ember, and many other frameworks too. Redux
    provides a subscription mechanism that can be used by any other code, but it is
    mostly useful when you integrate with declarative views or UIs created via React
    or other similar libraries.
  prefs: []
  type: TYPE_NORMAL
- en: What are the rules followed by reducers?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Redux, the reducer component should follow some specific rules. Those rules
    are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Reducers should only derive the new state value based on the current state and
    action arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducers shouldn’t modify the existing state. However, they can perform immutable
    updates by copying the existing state and making changes to the copied values
    instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are not allowed to perform any asynchronous logic, calculate random values,
    or any side effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The functions that follow the preceding rules are also known as **pure functions**.
    In other words, reducers are simply pure functions. By following these rules,
    reducers make Redux code and state predictable without any bugs.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between the mapStateToProps() and mapDispatchToProps()
    methods?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `mapStateToProps()` method is a utility function used to select the part
    of the data from the store that the connected component needs. The selected state
    is going to be passed as props to the component to which `connect()` is applied.
    In this way, this method is helpful to avoid passing the entire application state
    to the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example passes a `city` value as a prop to the `WeatherReport`
    component to find the weather information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `WeatherReport` component only accepts `city` as a prop. You can easily
    use this component anywhere else in the application by decoupling Redux code from
    React components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The shorthand notation for this function is `mapState` and this function is
    called every time the store state changes.
  prefs: []
  type: TYPE_NORMAL
- en: The `mapDispatchToProps()` method is a utility function that is used to specify
    which actions your component might need to dispatch. This function provides action
    dispatching functions as props.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function specifies the actions required for the `WeatherReport`
    React component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet performs a city change action. This is done by invoking
    the `props.changeCity(city)` action directly in the component instead of calling
    the `props.dispatch(changeCity(city))` verbose expression.
  prefs: []
  type: TYPE_NORMAL
- en: There is a recommended object shorthand notation for the `mapDispatchToProps`
    function. In this approach, Redux wraps it in another function that looks like
    `(…args) => dispatch(changeCity(…args))` and passes that wrapper function as a
    prop to your component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the preceding code can be simplified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In summary, the `mapStateToProps` function is used to render the stored data
    to the component and `mapDispatchToProps` is used to provide the action creators
    as props to the component.
  prefs: []
  type: TYPE_NORMAL
- en: What is a store enhancer?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A store enhancer is a higher-order function that accepts a store creator function
    (i.e., `createStore`) and returns a new enhanced store creator function. This
    is helpful to customize the original Redux store, and it will override the store
    methods such as `dispatch`, `getState`, and `subscribe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following snippet to see how the store enhancer implementation
    looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Store enhancer is quite similar to the concept of **higher-order component**
    (**HOC**) in React. So you can also call the HOC as **component enhancer**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Middleware provides additional functionality to the Redux dispatch function
    and enhancers provide additional functionality to the Redux store.
  prefs: []
  type: TYPE_NORMAL
- en: Real-time applications contain logic that involves side effects such as external
    API calls, generating random values, saving files, and updating local storage.
    By default, Redux has no support for these kinds of side effects to be executed.
    However, Redux middleware makes it possible to intercept the dispatched actions
    and inject additional complex behavior, including side effects. Next, we will
    get a better idea about that.
  prefs: []
  type: TYPE_NORMAL
- en: Redux middleware – Saga and Thunk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic Redux store can only perform simple synchronous state updates by dispatching
    an action. Middleware such as **Redux Thunk** and **Redux Saga** help extend the
    store capabilities by writing the async logic to interact with the store. These
    middleware are helpful to avoid directly causing side effects in our actions,
    action creators, or components.
  prefs: []
  type: TYPE_NORMAL
- en: What is Redux middleware? How do you create middleware?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Redux middleware provides a third-party extension to intercept every action
    sent to the reducer by modifying the action or canceling the action. It is helpful
    for logging, error reporting, routing, and making asynchronous API calls. Although
    Redux middleware is like Node.js middleware (for example, Express and Koa), it
    solves different problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, let’s demonstrate the creation of a custom middleware
    named `loggerMiddleware` to log the various actions in the console with step-by-step
    instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first step, you need to import the `applyMiddleware` function from the
    Redux library as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a middleware named `loggerMiddleware` to intercept the action for logging
    purposes with the following structured syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the `loggerMiddleware` function has been created, it needs to be passed
    to the `applyMiddleware` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to pass the custom middleware to the `createStore` function.
    Even though the middleware is assigned as a third argument to the store, the `createStore`
    function automatically identifies the middleware based on the type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before the action is dispatched to the store, the middleware gets executed by
    logging the action details in the console. Since the next function has been invoked
    inside the middleware, the reducer will also be executed to update the state in
    the store.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to create multiple middleware by passing them to `applyMiddleware`
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, all these middleware are executed one after the other.
  prefs: []
  type: TYPE_NORMAL
- en: How do you handle asynchronous tasks in Redux?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most modern web applications need to deal with asynchronous tasks. In React,
    there are two popular libraries available to handle them: **Redux Thunk** and
    **Redux Saga**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Redux Thunk middleware is used to write an action creator that returns a function
    instead of just an action object in the Redux application. The functions returned
    from the action creator are called thunk functions and are used to delay the computation.
    These functions accept two arguments – the `dispatch` and `getState` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: All thunk functions are invoked through the store’s `dispatch` method but not
    from the application code. The same behavior can be seen with the preceding code
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to action creators generating actions for dispatching, you can use
    Thunk action creators to generate thunk functions. For example, the list of posts
    created by a specific user can be retrieved using the thunk action creator named
    `getPostsByAuthor`, which generates anonymous thunk functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, you can access the action creator inside the UI component for any
    user interaction. The following `AuthorComponent` accesses the list of posts on
    the lazy loading event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The last important step is configuring the `redux-thunk` middleware to the Redux
    store to dispatch the thunk functions. There are two possible options available.
    Thunk middleware needs to be passed to the `applyMiddleware()` method to add thunk
    middleware to the store manually. But if you are using RTK, the `configureStore`
    API automatically adds the thunk middleware during the store creation (i.e., it
    doesn’t require any additional configuration).
  prefs: []
  type: TYPE_NORMAL
- en: What are the use cases of Redux Thunk?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Redux Thunk can have any arbitrary logic and it can be used for a variety of
    purposes. The most common use cases of Redux Thunk are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When you’re trying to move complex logic out of React components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you are making async requests such as Ajax calls and other async logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you need to create a logic that needs to dispatch multiple distinct actions
    in a row
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you are planning to write a logic that needs to access `getState` or other
    state values to make decisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, the main use case of Redux Thunk middleware is for handling actions
    that are not synchronous.
  prefs: []
  type: TYPE_NORMAL
- en: What is Redux Saga?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Redux Saga is a popular competitor for Redux Thunk middleware for handling asynchronous
    side effects. Redux Saga uses an ES6 feature known as **generators** that helps
    in writing asynchronous code. These generators are functions that can be paused,
    resumed, exited in the middle of execution, and re-entered later during the operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The side effects will be generated using special helper functions from the
    `redux-saga` package. Some of those commonly used functions are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Call`: An effect description that instructs the middleware to call other functions
    in Saga'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Put`: Used to dispatch an action to the store'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Yield`: A built-in function that allows the use of generator functions sequentially'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`takeLatest`: Invokes the function handler only once at a time and cancels
    the previous tasks by running again with the latest data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`takeEvery`: Invokes the function handler every time infinitely and concurrently
    whenever the action fires'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Saga functions listen for the actions that got dispatched and trigger side
    effects written in your code. For example, the following `postsSaga` function
    listens for the `GET_POSTS` action and invokes the Posts API to retrieve the author''s
    posts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, either the successful response or failed response dispatched
    to the store. This response depends on API call happened through the `call` helper
    function.
  prefs: []
  type: TYPE_NORMAL
- en: How do you choose between Redux Saga and Redux Thunk?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both Redux Thunk and Redux Saga middleware are helpful in allowing the Redux
    store to interact with external API calls (or side effects) asynchronously. But
    the decision to choose one of them totally depends on your project requirements
    and personal preference. Redux Thunk is a good choice if you are new to the React
    or Redux ecosystem and the project is small in size. Moreover, Redux Thunk requires
    less boilerplate code and is easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, Redux Saga is suitable for big projects where you need to
    split the logic into multiple files. However, the main advantage of Redux Saga
    over Redux Thunk is the ability to write clean and readable tests for asynchronous
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The plain Redux requires a lot of boilerplate code to fulfill the state management
    requirements. Developers need to implement common tasks such as store setup, writing
    reducers and actions, and so on. Also, you may need to import APIs from other
    packages based on needs. So, this entire process makes it difficult for developers
    to learn and implement the Redux solution. RTK is going to standardize the process
    and simplify it with its helpers.
  prefs: []
  type: TYPE_NORMAL
- en: Standardizing Redux logic using RTK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The RTK package provides the necessary tools to ease Redux development. This
    package not only eases development but also prevents common mistakes, provides
    suggested best practices, and many more features.
  prefs: []
  type: TYPE_NORMAL
- en: What is RTK?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`@reduxjs/toolkit`, which is wrapped around the core `redux` package. In summary,
    this package provides utilities and common dependencies that are required for
    building a Redux application.'
  prefs: []
  type: TYPE_NORMAL
- en: This tool helps cover common use cases such as setting up the store, creating
    the reducers and actions, writing immutable update logic, and creating entire
    slices of state at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, RTK automatically supports the following officially recommended
    set of tools or libraries to cover most of the common use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Redux DevTools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redux Thunk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reselect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RTK supports TypeScript through which APIs provide excellent type safety and
    reduce the number of types used in the code.
  prefs: []
  type: TYPE_NORMAL
- en: What are the problems solved by RTK?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'RTK is helpful to speed up the development process and apply the recommended
    best practices automatically. It solves the following three major issues found
    in the Redux library:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Redux store that is too complicated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This Redux library requires a lot of dependencies for building a large-scale
    application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redux requires too much boilerplate code, which impacts the efficiency and quality
    of the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The toolkit provides certain options to configure the global store, creating
    actions and reducers that make the development simpler by abstracting the Redux
    API.
  prefs: []
  type: TYPE_NORMAL
- en: What is RTK Query? How do you use it?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RTK Query is a powerful data fetching and client-side caching tool to simplify
    common use cases in Redux applications. For example, this tool supports use cases
    such as loading data in the web application, avoiding the need for hand-written
    data fetching and caching logic, and so on. If you are using the RTK package,
    this query feature is going to be available as an optional add-on. Also, this
    feature is built-in on top of the RTK API methods such as `createSlice` and `createAsyncThunk`
    for its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explain the usage of RTK Query with a data fetching use case in the web
    application.
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to import the `createAPI` and `fetchBaseQuery` API methods from
    the RTK Query package. This `createAPI` method accepts an object that includes
    the `baseQuery` configuration created by the `fetchBaseQuery` API and a list of
    API endpoints to interact with the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, two endpoints are going to be created – one for creating the
    user and the other one for listing the users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, RTK Query auto-generates React Hooks for each
    endpoint that is available to use in function components through export declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the store needs to be configured by mapping RTK Query’s generated slice
    reducer into root reducer along with a custom middleware that handles data fetching.
    The `setupListners` API is an optional utility to enable `refreshOnFocus` and
    `refreshOnReconnect` behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, you need to wrap our application with the `Provider` component
    from the `react-redux` package to pass the store as a prop to all the child components,
    just like any Redux application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once that is done, you can make requests in your component through queries.
    The list of users on the second page can be retrieved as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In addition to users `data`, `error` and `isLoading` fields, the preceding query
    also provides other Boolean utilities such as `isFetching`, `isError`, and `isSuccess`,
    which might be of use, depending on functional requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Redux is the best state solution for large-scale applications. However, it will
    be challenging to debug the bugs that arise in these kinds of applications. Redux
    DevTools makes the development and debugging experience easy by tracing when,
    where, and how your application’s state has been changed.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging applications using Redux DevTools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like Chrome DevTools is used to manipulate the content of the web page
    on the fly, Redux DevTools allows you to directly manipulate Redux operations
    in the web application. Nowadays, this tool has become a standard development
    tool for developing any kind of Redux application.
  prefs: []
  type: TYPE_NORMAL
- en: What is Redux DevTools?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Redux DevTools is a development-purpose-only tool for debugging an application’s
    state changes. It is used to perform time-travel debugging and live editing for
    Redux with hot reloading, actions history, undo, and replay features. If you don’t
    want to install Redux DevTools as a standalone app or integrate it as a React
    component in the client app, it can be used as a browser extension for Chrome,
    Firefox, or Edge browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example DevTools snapshot representing the sequence of
    fetching todos, completing, and deleting todo operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: Redux DevTools UI](img/Figure_06.02_B18603.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Redux DevTools UI'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, the left panel represents the list of actions with
    *Skip* and *Jump* options on selecting the particular action and the right panel
    describes the current state, differences in state, and other useful features.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: RTK’s `configureStore` API automatically sets up integration with Redux DevTools.
  prefs: []
  type: TYPE_NORMAL
- en: What are the major features of Redux DevTools?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some of the major features of Redux DevTools are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides the ability to inspect every state and action payload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can go back in time by canceling the actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the reducer code changes, each staged action will be re-evaluated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is an error thrown from the reducer, you can trace which action caused
    the error and what the error is about
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can persist debug sessions across page reloads using the `persistState()`
    store enhancer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also possible to dispatch actions without writing any code in the application
    using the **dispatch** option of Redux DevTools.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has offered comprehensive knowledge of Redux state management solutions
    for React applications. We began this chapter with a brief introduction to Flux,
    its architecture, differences with the MVC pattern, and use cases, followed by
    Redux fundamentals, differences with Flux, and its advantages as a state management
    solution. We also covered topics such as the core principles of Redux, their components,
    various add-ons, and data flows. After that, we went through understanding async
    tasks, popular middleware libraries in Redux, how to use them in React applications,
    and their use cases. Finally, we covered the debugging techniques and Redux DevTools
    to track the state changes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will understand the various approaches to applying CSS
    in React applications. First, we will start with a regular CSS styling approach
    in React using inline styles and external styles. Then, we will go through advanced
    techniques such as locally scoped CSS using CSS Modules and the `styled-components`
    library based on the CSS-in-JS solution.
  prefs: []
  type: TYPE_NORMAL
