- en: Keep Your App Healthy with Tests and Jest
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用测试和 Jest 保持你的应用程序健康
- en: An important part of any application developer's life is making sure that their
    application runs properly the first time, every time. That can be a difficult
    thing to do as applications get more complicated; what might have previously required
    just a few minutes and a single line of code to clean up or fix might instead
    start taking hours, days, or even weeks (or longer) to try to fix! In addition,
    if you're trying to build up your application and make it work cleanly and effectively.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序开发者的生活中一个重要的部分是确保他们的应用程序第一次运行就正确无误，每次都如此。随着应用程序变得更加复杂，这可能是一个困难的事情去做；之前可能只需要几分钟和一行代码来清理或修复的问题，现在可能需要数小时、数天，甚至数周（或更长）来尝试修复！此外，如果你试图构建你的应用程序并使其工作干净、有效。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The history of testing React applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 React 应用程序的历史
- en: Different ways to run React tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 React 测试的不同方式
- en: A brief introduction to Jest
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jest 的简要介绍
- en: A brief introduction to the test watcher
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试监视器的简要介绍
- en: How to write tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写测试
- en: The why and when of testing
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试的“为什么”和“何时”
- en: You might be wondering why we've started tackling our tests so late in our application.
    Generally speaking, when you're just starting out in your projects, you might
    wait a little bit to see how your application shakes out before you start verifying
    its behavior with tests. That being said, we're now also at a really good point
    to start shoring up our project and make it something that we can deploy to production
    with confidence!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们在应用程序开发的这么晚才开始处理测试。一般来说，当你刚开始你的项目时，你可能会等待一段时间，看看你的应用程序如何发展，然后再开始用测试来验证其行为。但话虽如此，我们现在也已经到了一个很好的时机，开始巩固我们的项目，使其成为我们可以自信地部署到生产环境中的东西！
- en: The history of testing React
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 React 的历史
- en: Again, it's great to understand the history of the toolset to understand why
    certain features or libraries are being used. When people were just getting started
    with React, ideas and standards around testing were absolutely all over the place.
    Some people used weird combinations of libraries that had all sorts of names,
    such as night-something, mocha, or some other random framework. You had to figure
    out mocking libraries, test harnesses, and user interface test frameworks.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，了解工具集的历史对于理解为什么使用某些功能或库是非常有帮助的。当人们刚开始使用 React 时，关于测试的想法和标准四处散落。有些人使用各种各样名字的库的组合，比如
    night-something、mocha 或其他随机的框架。你必须弄清楚模拟库、测试框架和用户界面测试框架。
- en: It was absolutely *exhausting*, and inevitably any framework and setup you were
    using would either fall out of favor or fall out of date and you'd have to turn
    around and start learning a new one every few weeks! Even worse, if you asked
    a ton of different people what their particular test setup was, you'd get at least
    that many different answers!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是 *令人筋疲力尽*的，不可避免的是，你使用的任何框架和设置都会失去青睐或过时，你不得不每隔几周就重新开始学习一个新的框架！更糟糕的是，如果你问了很多不同的人他们的特定测试设置，你会得到至少那么多不同的答案！
- en: About Jest
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于 Jest
- en: Jest was the React team's answer to the constant question of *what test harness
    should we use for our React application?* You'd always get a different answer
    depending on who you asked, and sometimes you'd have to use multiple harnesses
    just to get features you wanted, which led to a ton of bloat and developer confusion
    about which one was the correct one to use at any given time!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 是 React 团队针对“我们应该为我们的 React 应用程序使用什么测试框架？”这一持续问题的回答。你得到的答案总是因人而异，有时你不得不使用多个框架才能获得你想要的功能，这导致了大量的冗余和开发者对于在任何给定时间应该使用哪个框架的困惑！
- en: Analyzing the structure of Jest tests
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析 Jest 测试的结构
- en: 'The best place for us to get started is to take a look at the default standard
    test that comes with any new Create React App project, and that is the test for
    our `App` component, located at `src/App.test.js`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始的最佳地点是查看任何新的 Create React App 项目中附带的标准测试，那就是对我们 `App` 组件的测试，位于 `src/App.test.js`：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Well, this isn''t a particularly *exciting* test by any stretch of the imagination.
    As the name implies, this test just verifies that the `App` component can be rendered
    on the page without any major hiccups or errors. This test might seem kind of
    superfluous, but it actually serves an incredibly important purpose: it remains
    as a sanity check for your application!'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，从任何想象的角度来看，这不是一个特别**令人兴奋**的测试。正如其名所示，这个测试只是验证了`App`组件可以在页面上渲染，没有任何大的故障或错误。这个测试可能看起来有点多余，但它实际上扮演了一个极其重要的角色：它作为你应用程序的理智检查！
- en: 'Think about it: if your main application or component couldn''t render without
    any other more complicated checks, then your project is very, very broken! It
    helps us check whether we''re accidentally excluding things or introducing significantly
    breaking changes to our project in a way that keeps us all sane! Let''s also verify
    that this actually does work the way we expect even with our changes right now:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 想想看：如果你的主要应用程序或组件在没有其他更复杂的检查的情况下无法渲染，那么你的项目可能非常、非常糟糕！这有助于我们检查我们是否意外地排除了某些内容，或者以保持我们所有人理智的方式对我们的项目引入了重大的破坏性更改！让我们也验证一下，即使现在我们有了一些更改，这也确实按照我们预期的样子工作：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When we run this, we should expect to see some output in our console window
    that tells us a little more about what tests were run, what tests passed, what
    failed, and other metadata about our test run as well:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个时，我们应该在我们的控制台窗口中看到一些输出，它会告诉我们更多关于运行了哪些测试，哪些测试通过，哪些失败，以及关于我们的测试运行的其他元数据：
- en: '![](img/f2b2fb64-8cba-44a9-8349-019c80868546.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f2b2fb64-8cba-44a9-8349-019c80868546.png)'
- en: Just like that, clean and working tests! Now, that by itself is really cool,
    but let's take a few minutes to analyze the previous output window!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，干净且可工作的测试！现在，这本身真的很酷，但让我们花几分钟来分析之前的输出窗口！
- en: Exploring the test output
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索测试输出
- en: 'Right now, if we just look at the previous output without any context, it may
    not make a ton of sense! Let''s start off by taking a look at the first line after
    the test, which talks about our Test Suites:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果我们没有上下文，只看之前的输出可能不太有意义！让我们从查看测试之后的第一个行开始，它讨论了我们的测试套件：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Jest allows us to run and organize our tests in a number of different and helpful
    ways! For example, our tests can be run by suites; suites being larger groupings
    of tests. We''ll explore this line of output a little further later on when we
    have more than a single test, but right now we only have one test suite, and thus
    we''ve only run a single test suite:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 允许我们以多种不同且有用的方式运行和组织我们的测试！例如，我们的测试可以通过套件运行；套件是测试的更大分组。稍后当我们有不止一个测试时，我们会进一步探讨这一输出行，但现在我们只有一个测试套件，所以我们只运行了一个测试套件：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We ran a single test, and that single test passed! This allows us to also keep
    track of what tests were run as our application code changed; we may not need
    to run every single test in every single suite across the board when we make minor
    changes! Instead, we can focus on the tests that would be affected by whatever
    the change was, so you may see this as being less than the total number of tests
    in your suites:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行了一个测试，并且这个测试通过了！这使我们能够跟踪随着应用程序代码的变化，运行了哪些测试；当我们进行小改动时，我们可能不需要在每个套件中运行每个测试！相反，我们可以专注于受更改影响的测试，因此你可能看到这少于套件中的总测试数：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Snapshots are a different feature entirely with Jest. Snapshots are a way to
    tell Jest that *given input X, the rendered component should look exactly like
    this*. We''ll explore this in greater detail later! The following line indicates
    how long our tests took to run:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jest 中，快照是一个完全不同的特性。快照是一种告诉 Jest 的方式：**给定输入 X，渲染的组件应该看起来完全像这样**。我们稍后会更详细地探讨这一点！以下行指示了我们的测试运行所需的时间：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is important to note, as sometimes you might introduce some code to your
    application that makes your application incredibly slow! This can help you catch
    those sneaky performance-ruining bits of code in your application. Your tests
    will essentially be your early-warning system against poorly-performing algorithms!
    We will get the following output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这点很重要，因为有时你可能会向你的应用程序中引入一些代码，使得应用程序变得极其缓慢！这可以帮助你捕捉到应用程序中那些偷偷破坏性能的代码片段。你的测试将基本上是你对性能不佳算法的早期预警系统！我们将得到以下输出：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we get some output that tells us a little bit about what tests ran
    and what else we can do. We can also hit *w* here to get more options about what
    we can do with our test runner and watcher:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们得到了一些输出，告诉我们一些关于运行了哪些测试以及我们可以做些什么的信息。我们也可以在这里按下 *w* 键，以获取更多关于我们可以使用测试运行器和监视器的选项：
- en: '![](img/92a3d97a-e583-4719-9168-686a13069455.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92a3d97a-e583-4719-9168-686a13069455.png)'
- en: A development test workflow with the F key
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 F 键的开发测试工作流程
- en: When we hit *w*, we get a new list of commands that we can run to continue with
    our test suite and do more for it. We've already explored these options a little
    bit, but it's worth reiterating the work that we can (and should) do during development
    and talk a little bit about *when* to use these tests as well!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按下 *w* 键时，我们会得到一个新列表的命令，我们可以运行这些命令来继续我们的测试套件并对其进行更多操作。我们已经探索了这些选项的一些内容，但值得重申的是，我们在开发期间可以（和应该）做的工作，以及谈谈何时使用这些测试！
- en: 'The first major one is the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个主要的问题是以下内容：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We''ll use this one *a lot*. Often when you''re developing complex applications
    you might introduce changes that break your test suite, or you might be going
    with more of a test-driven development approach, in which case you''ll be working
    with broken tests and then fixing things in your application or in your tests
    until the tests pass again! If that''s the case, you''ll be using this command
    a lot, so get comfortable with it early! If we try to run this now without any
    failed tests, we''ll get the following output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会大量使用这个测试。通常在开发复杂的应用程序时，您可能会引入破坏测试套件的变化，或者您可能会采用更多的测试驱动开发方法，在这种情况下，您将使用破坏的测试，然后在应用程序或测试中进行修复，直到测试再次通过！如果这种情况发生，您将大量使用这个命令，所以最好早点熟悉它！如果我们现在在没有失败的测试的情况下尝试运行它，我们会得到以下输出：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This makes sense. We had no failed tests, so of course it wouldn''t find any
    and thus wouldn''t run any tests. We can make this work for us, though, by introducing
    a failing test intentionally and then running our full test suite, followed by
    just the failed tests! We can simulate this very quickly by returning back to
    `src/App.js` and commenting out the `export` statement at the bottom of the code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有道理的。我们没有失败的测试，所以当然找不到任何测试，因此不会运行任何测试。不过，我们可以通过故意引入一个失败的测试，然后运行我们的完整测试套件，接着只运行失败的测试来使这为我们所用！我们可以通过回到
    `src/App.js` 并取消注释代码底部的 `export` 语句来快速模拟这个过程：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now if you restart your tests, you will get one failing test! We should be able
    to hit *F* and it will rerun the single failing test (and we can repeat this process
    over and over, as well). Now if we uncomment that line and save the file, if we
    rerun our test suite (either automatically or manually using *F*), we should be
    back to a fully-working test suite!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果您重新启动测试，您将得到一个失败的测试！我们应该能够按下 *F* 键，然后它会重新运行单个失败的测试（我们也可以反复执行这个过程）。现在如果我们取消注释那一行并保存文件，如果我们重新运行测试套件（无论是自动还是手动使用
    *F* 键），我们应该能够回到一个完全工作的测试套件！
- en: 'There''s another reason to get comfortable with rerunning failed tests: you
    should get comfortable with the idea of writing tests that intentionally fail
    until you make the test pass, or passes unless you comment or intentionally break
    the code! If you make code changes that should break your tests but the test still
    passes, that means your tests aren''t actually testing the behavior of your application
    correctly!'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有另一个原因需要您熟悉重新运行失败的测试：您应该熟悉编写故意失败的测试，直到您使测试通过，或者通过注释或故意破坏代码来使测试通过！如果您做出的代码更改应该破坏您的测试，但测试仍然通过，这意味着您的测试实际上并没有正确地测试您应用程序的行为！
- en: It's time to add some new tests!
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候添加一些新的测试了！
- en: 'We have a pretty good understanding of our initial test, but there''s so much
    more we can learn by writing new tests! We''ll start off by testing the absolute
    simplest component that we''ve written so far: our `Todo` component! You''ll notice
    a pattern with how we have to name our tests to have Jest pick them up appropriately:
    we''ll create a test for our `Todo` component (in `src/Todo.js`) as `src/Todo.test.js`!
    We''ll almost always want to start off our tests by mimicking the structure in
    `App.test.js`, so we''ll start off by doing almost the same things:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对我们的初始测试有相当好的理解，但通过编写新的测试，我们可以学到更多！我们将从测试我们迄今为止编写的最简单的组件开始：我们的 `Todo` 组件！您会注意到我们如何命名测试以便
    Jest 正确地捕获它们：我们将为 `Todo` 组件（在 `src/Todo.js` 中）创建一个测试，命名为 `src/Todo.test.js`！我们几乎总是希望从模仿
    `App.test.js` 中的结构开始我们的测试，所以我们将开始做几乎相同的事情：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After rerunning our Test Suite (you may have to exit out of the test watcher
    with *Q* and rerun `yarn test`), you should get the following output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新运行我们的测试套件之后（你可能需要使用*Q*退出测试监视器并重新运行`yarn test`），你应该会得到以下输出：
- en: '![](img/3bf82bda-648b-4260-8270-fdb8e35861e5.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3bf82bda-648b-4260-8270-fdb8e35861e5.png)'
- en: 'So it ran our `src/Todo.test.js` test that we just added, and it''s a new test
    suite as well! Let''s expand out our tests since right now they''re not really
    doing anything. To do that, however, we''ll need to add a few more libraries to
    our test suite! We''ll want to add `enzyme` (for shallow rendering); `enzyme`
    is a React v16.x adapter, and React''s test `renderer` to our application. We
    can do so with one quick `yarn` command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它运行了我们刚刚添加的`src/Todo.test.js`测试，而且它还是一个全新的测试套件！让我们扩展我们的测试，因为到目前为止，它们实际上并没有做什么。然而，为了做到这一点，我们需要向我们的测试套件中添加几个更多的库！我们希望添加`enzyme`（用于浅渲染）；`enzyme`是React
    v16.x的适配器，以及React的测试`renderer`到我们的应用程序。我们可以通过一个快速的`yarn`命令来实现：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`enzyme` adds a lot to our test suite and makes it that much easier to work
    with, so it''s honestly worth it to include `enzyme` as a baseline to our test
    suite! In fact, it''s so helpful that it''s included on some of the default React/Jest
    test documentation! Now, just including these by themselves won''t do everything
    we need, so we''ll also need to create a test setup file to initialize Enzyme.
    Create `src/setupTests.js` and give it the following body:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`enzyme`为我们的测试套件增添了大量的功能，使得与之工作变得更加容易，所以将`enzyme`作为测试套件的基础确实是值得的！实际上，它如此有用，以至于它被包含在一些默认的React/Jest测试文档中！现在，仅仅包括这些还不足以完成我们所需的一切，所以我们也需要创建一个测试设置文件来初始化Enzyme。创建`src/setupTests.js`并给它以下内容：'
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Having done that, we can start tackling some real test code! We''ll need to
    open up `src/Todo.test.js`, where we can add some code at the top which will give
    us the ability to take advantage of the `enzyme` shallow `renderer`! We''ll also
    need `react-test-renderer` of the `renderer()` function, since we''ll use that
    to create snapshots:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些之后，我们可以开始处理一些真正的测试代码！我们需要打开`src/Todo.test.js`，在那里我们可以在顶部添加一些代码，这将使我们能够利用`enzyme`的浅渲染`renderer`！我们还需要`renderer()`函数的`react-test-renderer`，因为我们将使用它来创建快照：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we have everything we need to begin writing our tests. Before we start
    writing our tests, I generally begin by throwing all of our tests into a big `describe`
    function, so let''s start off there by moving the test that we already wrote inside
    of our `describe` block:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了开始编写测试所需的一切。在我们开始编写测试之前，我通常首先将所有的测试都抛入一个大的`describe`函数中，所以让我们从移动我们已经在`describe`块内部编写的测试开始：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Rerun the tests and we should be back to green and two suites and two tests:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行测试，我们应该回到绿色，两个套件和两个测试：
- en: '![](img/8ec90fbe-3f03-486e-a24e-a9a01c10b22c.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8ec90fbe-3f03-486e-a24e-a9a01c10b22c.png)'
- en: Describe is a way of blocking together related tests, whether by functionality,
    concept, or otherwise. You have a few ways to declare a describe block. You can
    either use a string to specify the name of a test, or you can use a valid `Class`
    or `Component` name.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe`是一种将相关测试组合在一起的方式，无论是通过功能、概念还是其他方式。你有几种方法来声明一个`describe`块。你可以使用一个字符串来指定测试的名称，或者你可以使用一个有效的`Class`或`Component`名称。'
- en: 'Now, if we want to start making our tests a little more complicated, we''ll
    also need to do some basic setup stuff, since if you remember from our `Todo`
    component, we have a few functions that need to get passed down into our child
    component. Let''s take a look at the default `props` of our `Todo`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想使我们的测试变得更加复杂，我们还需要做一些基本的设置工作，因为如果你记得我们的`Todo`组件，我们有一些函数需要传递到我们的子组件中。让我们看看`Todo`的默认`props`：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And the function body of the `removeTodo` prop:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以及`removeTodo`属性的函数体：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Description is easy; that's just a string that we need to pass in. `removeTodo(...)`,
    on the other hand, is more complicated. It's a function that doesn't live as part
    of this component; instead, it lives inside of the parent and is passed in! So,
    how do we deal with that?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 描述很简单；那只是一个我们需要传递的字符串。另一方面，`removeTodo(...)`要复杂得多。它是一个不作为此组件一部分存在的函数；相反，它存在于父组件中，并被传递进来！那么，我们如何处理这种情况呢？
- en: 'Simple, we can *mock* a function with Jest! Mocking a function basically makes
    a fake function that keeps track of when it''s called. We''ll also need to perform
    a **shallow render** of our component to verify how the component appears in the
    DOM overall. We''ll talk a little more about this in a minute, but for right now
    add the following at the top of the describe block:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，我们可以用 Jest 来 *模拟* 一个函数！模拟一个函数基本上创建了一个跟踪其何时被调用的假函数。我们还需要对组件进行 **浅渲染** 以验证它在
    DOM 中的整体外观。我们稍后会详细讨论这个问题，但现在请将以下内容添加到 describe 块的顶部：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see from the previous example, `jest.fn()` allows us to create a
    mocked function. Mocking a function, as mentioned previously, doesn't do anything
    in particular. It pretends to be a function, sees who is trying to use that function,
    and also keeps track of things, such as fake arguments or sets up fake return
    values for the function. This is good if we want to verify that the `removeTodo`
    in our `props` actually does anything at all but we don't care that it performs
    a specific behavior.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，`jest.fn()` 允许我们创建一个模拟函数。正如之前提到的，模拟一个函数并没有做任何特别的事情。它假装是一个函数，看到谁试图使用该函数，并跟踪一些事情，比如伪造的参数或为函数设置伪造的返回值。如果我们想验证我们的
    `props` 中的 `removeTodo` 确实做了些什么，但我们不关心它执行的具体行为，这会很有用。
- en: Writing a generic snapshot test
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个通用的快照测试
- en: 'Talking about writing tests is one thing, but let''s actually start implementing
    our tests. I typically approach test-writing in the following way:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 谈论编写测试是一回事，但让我们实际开始实现我们的测试。我通常以以下方式处理测试编写：
- en: Write a generic snapshot test
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个通用的快照测试
- en: Write some subcomponent-specific tests
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一些子组件特定的测试
- en: Check content
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查内容
- en: Check interactions
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查交互
- en: 'Snapshot tests can be used to verify initial state renders and renders after
    specific conditions are met. This works by grabbing a representation of your component,
    storing that, and then using it for future tests. This can be tricky when you
    have components that are changing constantly, but can be incredibly handy when
    your components are stable and shouldn''t be getting modified often. Let''s write
    our `snapshot` test:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 快照测试可以用来验证初始状态渲染以及满足特定条件后的渲染。这是通过获取组件的表示形式，存储它，然后用于未来的测试来实现的。当你的组件不断变化时，这可能会很棘手，但当你的组件稳定且不应经常修改时，这会非常方便。让我们编写我们的
    `snapshot` 测试：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Remember the `renderer` we had to `import` from `react-test-renderer`? This
    is where we use it! We create a `Todo` component via JSX and pass that into the
    `renderer.create()` function. We then grab the component structure, transform
    it into JSON, and verify that it matches the appropriate snapshot from a previous
    run. This is another early warning system to help catch when someone changes the
    component but doesn''t do anything to update the tests! Let''s take a look at
    the results in our Test Suite:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们之前从 `react-test-renderer` 中 `import` 的 `renderer` 吗？这就是我们使用它的地方！我们通过 JSX
    创建一个 `Todo` 组件，并将其传递给 `renderer.create()` 函数。然后我们获取组件结构，将其转换为 JSON，并验证它是否与之前运行中适当的快照匹配。这是另一个早期预警系统，有助于捕捉到有人更改了组件但未对测试进行任何更新的情况！让我们来看看我们的测试套件中的结果：
- en: '![](img/9dc30b06-4cdd-4310-bfd0-2ec10cd121d9.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9dc30b06-4cdd-4310-bfd0-2ec10cd121d9.png)'
- en: Writing tests for content
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为内容编写测试
- en: We'll also need to make sure that when properties are passed in that modify
    what's displayed to the user, those properties actually make it into the fully-rendered
    function! We have a `description` variable that we already set at the top of our
    describe block. Before we jump too far, we need to write a quick test for our
    shallow render to make sure that is also working functionally!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保当传递的属性会修改用户看到的内容时，这些属性实际上已经进入了完全渲染的函数！我们已经在 describe 块的顶部设置了 `description`
    变量。在我们跳得太远之前，我们需要为我们的浅渲染编写一个快速测试，以确保它也正常工作！
- en: What’s a shallow render?
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是浅渲染？
- en: 'A shallow render is basically just a fake render of the component where it
    only renders the root-level component and nothing else. It''s the most minimal
    rendition of any component that you can use for a test, so we should always use
    that before we jump into anything else! Let''s write our shallow render test first:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 浅渲染基本上就是组件的一个假渲染，其中只渲染根级组件，不渲染其他内容。这是任何组件在测试中可以使用的最简版本，因此我们应该在跳入其他任何内容之前始终使用它！让我们首先编写我们的浅渲染测试：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is a simple test. It just ensures that we render out a `div` with a CSS
    class of `Todo`, which is the root `div` that gets rendered when we instantiate
    our `Todo` component in JSX. Otherwise, there are no major surprises here! Following
    that, we''ll need to write some tests that make sure these `props` passed in make
    it into the `component`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的测试。它只是确保我们渲染出一个带有`Todo` CSS类的`div`，这是当我们使用 JSX 实例化我们的`Todo`组件时渲染的根`div`。否则，这里没有太大的惊喜！在此之后，我们需要编写一些测试来确保这些传入的`props`确实进入了`组件`：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We already created the shallow rendered version of the `component`, so we're
    grabbing that component, analyzing the rendered `text` that would get added to
    the DOM if it were a real render, and then making sure that whatever we put in
    the description made it in there!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了`组件`的浅渲染版本，所以我们正在获取这个组件，分析如果它是一个真实渲染，将会添加到 DOM 中的渲染`文本`，然后确保我们放入描述中的任何内容都包含在内！
- en: Testing interactions
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试交互
- en: 'The last step is to test the actual interactions in your component! We''ll
    need to be able to target each of our buttons, though. If you think back to our
    `Todo` component''s `render()` function, there are two buttons that get created:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是测试组件中的实际交互！我们需要能够定位我们的每个按钮。如果你回想起我们的`Todo`组件的`render()`函数，有两个按钮被创建：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Without any modifications, it would actually be difficult for us to specifically
    target either of the actual buttons. We''ll want a way to target each `button`
    separately from each other, so let''s go into the `Todo` component and add a unique
    `className` to each button! Add `MarkDone className` to the first `button` and
    `RemoveTodo className` to the second `button` in the render function in `src/Todo.js`,
    just like the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何修改，实际上对我们来说很难具体地定位任何一个实际按钮。我们希望有一种方法可以单独地定位每个`按钮`，所以让我们进入`Todo`组件，并为每个按钮添加一个唯一的`className`！在`src/Todo.js`的渲染函数中，将`MarkDone
    className`添加到第一个`button`，将`RemoveTodo className`添加到第二个`button`，就像以下代码所示：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Save this code and the tests will rerun and it fails? But why? We haven''t
    changed the tests yet! Refer the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 保存这段代码，测试将重新运行并且失败？但是为什么？我们还没有修改测试！参考以下截图：
- en: '![](img/ff519430-4309-4b51-b4a4-fe51e57b89d4.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ff519430-4309-4b51-b4a4-fe51e57b89d4.png)'
- en: This is actually doing exactly what it's supposed to! We made some modifications
    to our component that changed how the component got rendered out. In our case,
    we're totally okay with these changes, so we'll use another one of our test-watcher
    commands to update the `snapshot`! Hit *u* and our `snapshot` will get updated
    and our tests will go back to passing! Finally, we can go back to finishing up
    our tests for interaction!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上正是它应该做的！我们对组件进行了一些修改，改变了组件的渲染方式。在我们的例子中，我们对这些修改完全满意，所以我们将使用另一个测试监视器命令来更新`快照`！按*u*键，我们的`快照`将更新，并且测试将重新通过！最后，我们可以回到完成我们的交互测试！
- en: Completing our interactivity tests
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成我们的交互测试
- en: 'Now that we can isolate each of the buttons, we can test what happens when
    each of them is clicked! We''ll need to start off by verifying our `MarkDone button`
    marks that `Todo` as done, which we can do via checking the `state`, as well!
    Let''s take a look at the test and then we''ll talk about what it does:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以隔离每个按钮，我们可以测试当每个按钮被点击时会发生什么！我们需要首先验证我们的`MarkDone button`是否将`Todo`标记为完成，这也可以通过检查`状态`来完成！让我们看看测试，然后我们再讨论它做了什么：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The easiest way to reason about these tests is to say them out loud. If we were
    to test this behavior as a human, we'd say, find the button that marks the `Todo`
    as done, click on that button, and then we should expect that `Todo` to be complete!
    Our code does precisely that! It *finds* the component via a CSS selector that
    grabs the button that has a CSS class attached to it of `MarkDone` (remember our
    `render()` function changes earlier). We then simulate a `"click"` event sent
    to that `button` which targets the `onClick` handler. Finally, we have to use
    the `state()` function to grab a value out of the component's state, which for
    us is the `"done"` property in the `state`! If that's now `true`, then we're golden
    and our tests work!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 思考这些测试的最简单方法就是大声说出来。如果我们像人类一样测试这个行为，我们会说，找到标记`Todo`为完成的按钮，点击那个按钮，然后我们应该期望`Todo`完成！我们的代码正是这样做的！它通过CSS选择器找到了组件，该选择器抓取了附有`MarkDone`
    CSS类的按钮（记得我们之前更改的`render()`函数）。然后我们模拟了一个发送到该`button`的`"click"`事件，该事件针对`onClick`处理程序。最后，我们必须使用`state()`函数从组件的状态中获取一个值，对我们来说就是`state`中的`"done"`属性！如果现在是`true`，那么我们就成功了，我们的测试就通过了！
- en: Returning to our mocked function
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回到我们的模拟函数
- en: 'We talked a lot about our function mocks but then focused on a bunch of other
    tests; now it''s time for us to revisit our mocked function and actually test
    it out! Basically, all we need to do is to use a helper function to verify that
    our mock has been called:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谈了很多关于函数模拟的内容，但后来又关注了一堆其他的测试；现在是我们重新审视我们的模拟函数并实际测试它的时候了！基本上，我们只需要使用一个辅助函数来验证我们的模拟是否被调用：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We had our `mockRemoveTodo` function that we had put back up in the top of
    our describe block:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在describe块顶部放回的`mockRemoveTodo`函数：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We''ve already seen the `simulate` call in a previous test, so all we do is
    create the expectation that our mock function has been called, and that''s it!
    With that, we have a very thorough test suite for our `Todo` component, and everything
    we do from here are just slightly more complicated variations of the same tests! Seven
    total Tests, two Test Suites, and one Snapshots test—all working perfectly! Refer
    the following screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的测试中已经看到了`simulate`的调用，所以我们只需要创建一个期望，即我们的模拟函数已被调用，这就足够了！有了这个，我们就有了针对`Todo`组件的非常全面的测试套件，从这里开始，我们所做的一切都是相同测试的略微复杂的变化！总共七个测试，两个测试套件，以及一个快照测试——一切运行得都很完美！参考以下截图：
- en: '![](img/e1812bab-ea68-4fd4-8536-611a2b305a1d.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1812bab-ea68-4fd4-8536-611a2b305a1d.png)'
- en: 'Before we move on, let''s verify the full test suite for `src/Todo.test.js`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们验证`src/Todo.test.js`的完整测试套件：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's now add some tests for `TodoList` as well!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们也给`TodoList`添加一些测试吧！
- en: Adding tests for TodoList
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为TodoList添加测试
- en: 'We''ll start off by adding a framework to put the rest of our `TodoList` tests
    on! We''ll need our standard imports and tests for rendering, snapshots, and shallow
    components! We''ll start off with this scaffold for `src/TodoList.test.js`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加一个框架来放置我们其余的`TodoList`测试！我们需要标准的导入和渲染、快照和浅渲染组件的测试。我们将从以下`src/TodoList.test.js`的脚手架开始：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We covered these tests previously, so there''s not much we''ll need to jump
    into, but we will want to make sure that, since our `render()` call includes a
    `NewTodo` component and we''ve imported that `component` at the top of our file,
    we have a test that verifies there''s a single `NewTodo` in the tree:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经覆盖了这些测试，所以没有太多需要深入的内容，但我们想确保，由于我们的`render()`调用包括一个`NewTodo`组件，并且我们在文件顶部导入了该`component`，我们有一个测试来验证树中只有一个`NewTodo`：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We''ll also need to verify how many `Todo` components appear in our `TodoList`,
    but there''s a little bit of a more complicated problem we have to solve with
    this test. If you remember, the state''s `"items"` property in `TodoList` determines
    what `Todo`s should appear, so we''ll check the state versus the component''s `find`
    function to see that the two are in sync with each other:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要验证`TodoList`中有多少`Todo`组件，但这个测试有一个更复杂的问题需要解决。如果你记得，`TodoList`中状态的`"items"`属性决定了哪些`Todo`应该出现，所以我们将检查状态与组件的`find`函数是否同步：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Our `component` already gets rendered out via the `shallow()` call, so we''ll
    use the `state()` call to verify the length of the items and find the equal number
    of `Todo` components. We''ll also need to test our `addTodo` function of `TodoList`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`component`已经通过`shallow()`调用被渲染出来，所以我们将使用`state()`调用来验证项目的长度，并找到相同数量的`Todo`组件。我们还需要测试`TodoList`的`addTodo`函数：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There's some new functionality in here that might be slightly complicated, so
    let's talk a little bit about it! We start off by finding out how many Todos already
    exist, since after we add another item we should expect that to be what we started
    with, plus another one! After that, we'll want to call `addTodo()` on the component,
    but to do that we need to jump down into the actual living context of `component`.
    We can do that via the `instance()` call, which allows us to call any function
    on the `component` without having to simulate any button clicks! After we call
    `addTodo`, we grab the list of all of the Todos that exist on the function and
    expect it to be more than what we originally started with! This is a really important
    and great way to write our tests; we never hardcode the number of Todos or anything
    else; instead, we check relative values after events happen! This eliminates weird
    scenarios where someone changes the default or initial state for our components
    and breaks our tests as a direct result!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些新的功能可能稍微复杂一些，所以让我们简单谈谈！我们首先找出已经存在的Todos数量，因为在我们添加另一个项目后，我们应该期望这是我们从前的数量加上一个！之后，我们将在组件上调用`addTodo()`，但为了做到这一点，我们需要跳入`component`的实际生活上下文。我们可以通过`instance()`调用来实现，这允许我们调用`component`上的任何函数，而无需模拟任何按钮点击！在调用`addTodo`之后，我们抓取所有存在的Todos列表并期望它比我们最初开始时更多！这是一种非常重要且非常好的编写测试的方法；我们从不硬编码Todos的数量或其他任何东西；相反，我们在事件发生后检查相对值！这消除了某些奇怪的场景，即有人更改了组件的默认或初始状态，并直接导致我们的测试失败！
- en: 'Finally, we need to implement a `removeTodo` test, which is just the reverse
    operation from the test we previously wrote:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要实现一个`removeTodo`测试，这正好是我们之前写的测试的反向操作：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The only notable difference is the fact that `removeTodo` needs an actual item
    to remove, so we have to grab one of the items out of the list and remove that
    specifically by passing that value into the `removeTodo` function!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一值得注意的区别是`removeTodo`函数需要实际的项目来移除，因此我们必须从列表中抓取一个项目，并通过将此值传递给`removeTodo`函数来具体移除它！
- en: 'After all is said and done, we should have a full test suite for `TodoList.test.js`
    that looks like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都结束后，我们应该有一个完整的`TodoList.test.js`测试套件，如下所示：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Adding tests for NewTodo
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加对新Todo的测试
- en: 'At last, we can add our final test suite and make sure `NewTodo` is covered
    as well. For the most part, we''ll work with the same skeleton we already have
    and have used before. Create `src/NewTodo.test.js` and give it the following skeleton:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以添加我们的最终测试套件并确保`NewTodo`也被覆盖。大部分时间，我们将使用我们之前已经使用过的相同的框架。创建`src/NewTodo.test.js`并给它以下框架：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We''ll also want to modify the tests we wrote that check our content, since
    we should at least make sure that the there''s still a text field and a `button`
    as part of the form:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望修改我们编写的检查内容的测试，因为我们至少应该确保文本字段和`button`作为表单的一部分仍然存在：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We’ll also want to test our mocked `addTodo` function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望测试我们的模拟`addTodo`函数：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is essentially identical to what we did in the `Todo` component suite.
    We''ll need a test for our `handleUpdate` function, which should modify the `"item"
    state` property to the faked `input` value:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上与我们之前在`Todo`组件套件中所做的是一样的。我们需要为我们的`handleUpdate`函数编写一个测试，该测试应将`"item"状态`属性修改为伪造的`input`值：
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The structure of the `handleUpdate` argument is a little wacky, so we need
    to make sure we''re passing in an object that''s compatible with the `handleUpdate`
    function that we wrote, which is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleUpdate`参数的结构有点奇怪，因此我们需要确保我们传递的对象与我们所编写的`handleUpdate`函数兼容，该函数如下所示：'
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We then use the `state` function to verify that `"item"` now matches what we
    passed in! We''ll close out our test-writing escapade by verifying that when the
    button to add an item is clicked that the value in the `"item" state` key is reset
    to blank:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`state`函数来验证`"item"`现在是否与我们传递的相匹配！我们将通过验证当点击添加项目的按钮时，`"item"状态`键的值重置为空白来结束我们的测试编写之旅：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We need to verify that we're being thorough with our test by making sure the
    component has a value first and then is reset to blank. If we don't, we wouldn't
    have any way to verify that our test was working the way we're expecting!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过确保组件首先有一个值然后重置为空白来验证我们的测试是否彻底。如果我们不这样做，我们就无法验证我们的测试是否按预期工作！
- en: 'The full test suite is provided here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的测试套件如下所示：
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The final result of all of our tests, if you''ve been following along, should
    be the following Test Suite results:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一直跟随我们的测试，最终的结果应该是以下测试套件结果：
- en: '![](img/960d844d-732f-4983-8f63-9b2c25383d67.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/960d844d-732f-4983-8f63-9b2c25383d67.png)'
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Testing is something that's absolutely critical to the overall health of your
    application! It ensures your development cycles are sane and your deploys are
    not incredibly dangerous. Your behavior can be tested, verified, and you can be
    confident in what your application is doing at any point in time without ever
    needing to open up a browser!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 测试对于您应用程序的整体健康至关重要！它确保了您的开发周期是合理的，您的部署不会非常危险。您的行为可以被测试和验证，您可以在任何时间点对应用程序正在执行的操作有信心，而无需打开浏览器！
- en: This is something that used to be a nightmare to do. The React test setup was
    a function that people generally hated given how much of a time commitment it
    took and how finicky it ended up being after the setup was done. One misstep or
    bad configuration change and the entire test harness framework could fall apart
    completely!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这曾经是一件令人头疼的事情。React测试设置是一个人们普遍讨厌的功能，因为它需要投入大量的时间，而且在设置完成后变得非常挑剔。一旦出现失误或配置更改不当，整个测试框架可能会完全崩溃！
- en: Be prepared to write a lot of tests if you write a production-ready React application!
    It's a great software engineering practice to be do whenever you're doing anything
    code-wise, and React is no different!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写的是一款生产就绪的React应用程序，那么准备写大量的测试是非常重要的！在编写代码时，这是一个非常好的软件工程实践，React也不例外！
- en: In the next chapter, we'll dive into cleaning up the visual design of our project
    with the new CSS module and the SASS support that's built into Create React App's
    latest version, and we'll incorporate a major CSS framework as well!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨使用最新版本的Create React App中内置的新CSS模块和SASS支持来清理我们项目的视觉设计，并且我们还将引入一个主要的CSS框架！
