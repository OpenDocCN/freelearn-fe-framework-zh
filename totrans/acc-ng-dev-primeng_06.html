<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer040">
			<h1 id="_idParaDest-106"><em class="italic"><a id="_idTextAnchor108"/>Chapter 10</em>: Using the Angular Compatibility Compiler</h1>
			<p>Angular Ivy replaces the previous-generation Angular compiler and rendering runtime known as Angular View Engine. The last version to support the View Engine runtime is Angular version 11.2.</p>
			<p>In this chapter, we are going to learn about the bridge between View Engine-compiled Angular packages on npm and your Angular Ivy application, namely the <strong class="bold">Angular Compatibility Compiler</strong> (<strong class="bold">ngcc</strong>).</p>
			<p>This chapter covers the following topics:</p>
			<ul>
				<li>Introducing the Angular Compatibility Compiler</li>
				<li>Using the Angular Compatibility Compiler</li>
				<li>Improving the Angular Compatibility Compiler in your CI/CD workflow</li>
			</ul>
			<p>If your Angular Ivy application consumes View Engine-compiled libraries from a package registry, you must use the Angular Compatibility Compiler. After learning about the topics covered in this chapter, you will know what is happening in your local development workflow and be able to fine-tune the Angular Compatibility Compiler in your CI/CD workflow.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor109"/>Technical requirements</h1>
			<p>For the techniques demonstrated in this chapter, your application requires at least the following:</p>
			<ul>
				<li>Angular Ivy version 11.1</li>
				<li>TypeScript version 4.0</li>
			</ul>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor110"/>Introducing the Angular Compatibility Compiler</h1>
			<p>The source code of Angular libraries is compiled before it is published on a package registry such as npm. Until Angular version 12.0, it was not possible to compile Angular libraries using partial Angular Ivy compilation; they had to be compiled with the View Engine compiler. As part of a transition period, Angular uses the Angular Compatibility Compiler to allow Angular Ivy applications to use libraries that are compiled using the View Engine compiler and published to a package registry.</p>
			<p>As of Angular version 12.2, the Angular Compatibility Compiler<a id="_idIndexMarker356"/> is still included as part of the Angular CLI, meaning that our Angular Ivy applications can consume libraries that are compiled using either the View Engine or the Angular Ivy compiler.</p>
			<p>In Angular CLI version 12.0, partial Ivy compilation for Angular libraries was introduced. In short, it compiles all Angular-specific code except component templates. However, partial Ivy compilation breaks backward compatibility for libraries in that consumers must also have at least Angular CLI version 12.0. In the period following this release, we will see a transition from View Engine-compiled Angular libraries to partially Ivy-compiled Angular libraries.</p>
			<p>The good news is that we do not have to change anything in our Angular Ivy application except keep Angular packages up to date. As soon as we have at least Angular 12.0, our application supports partially Ivy-compiled Angular<a id="_idIndexMarker357"/> libraries through an internal part of the Angular framework known as the Angular Linker.</p>
			<p>The Angular Linker is a replacement for the Angular Compatibility Compiler in that it converts a partially Ivy-compiled Angular library bundle to a fully Ivy-compiled library bundle before including it in the compilation of our application.</p>
			<p>As such, the Angular Compatibility Compiler will be removed in a version of Angular unknown at the time of writing but later than version 12.2. When this happens, our Angular application will only be able to use partially Ivy-compiled Angular libraries.</p>
			<p>Now that you have an overview of what the Angular Compatibility Compiler and the Angular Linker are and awareness of why they are needed, in the next section, we will discuss how to use the Angular Compatibility Compiler.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor111"/>Using the Angular Compatibility Compiler</h1>
			<p>In some Angular version 9 releases, we had<a id="_idIndexMarker358"/> to run the Angular Compatibility Compiler manually before building, testing, or serving our Angular Ivy application. In later releases, this changed so that the Angular CLI triggers the Angular Compatibility Compiler as needed.</p>
			<p>It is still possible to run the Angular Compatibility Compiler manually. In fact, this allows for fine-tuning it to optimal compilation speed.</p>
			<p>The Angular Compatibility Compiler needs to run at least once before any of the following:</p>
			<ul>
				<li>Starting a development server</li>
				<li>Executing automated tests</li>
				<li>Building our application</li>
			</ul>
			<p>Every time we install a new version of an Angular library or an additional Angular library from a package registry, we must run the Angular Compatibility Compiler again.</p>
			<p>Consider running the Angular Compatibility Compiler as part of your Git repository's <strong class="source-inline">postinstall</strong> hook. When using this technique, we do not have to wait the next time we perform one of the actions mentioned in the previous list. While the Angular Compatibility Compiler is running, we are free to change our source code.</p>
			<p>Alternatively, use the <strong class="source-inline">--target</strong> option, as described in the <em class="italic">Angular Compatibility Compiler options</em> section coming up next.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor112"/>Angular Compatibility Compiler options</h2>
			<p>The Angular Compatibility Compiler bundles<a id="_idIndexMarker359"/> an executable named <strong class="source-inline">ngcc</strong>. When running this command, we can pass the following options:</p>
			<ul>
				<li><strong class="source-inline">--create-ivy-entry-points</strong><p>Create an <strong class="source-inline">__ivy_ngcc_</strong> subdirectory inside each Angular library package directory. Inside this directory, another subdirectory will be created with the name of the output bundle format, for example, <strong class="source-inline">fesm2015</strong>. Inside the bundle format folder, the Ivy-compiled bundles and source maps will be placed. If this option is not passed, the original bundles will instead be overwritten.</p></li>
				<li><strong class="source-inline">--first-only</strong><p>When this option is used in combination with <strong class="source-inline">--properties</strong>, the Angular Compatibility Compiler will only compile the first module format it recognizes in a library package based on the order of the package property names specified by <strong class="source-inline">--properties</strong>.</p></li>
				<li><strong class="source-inline">--properties &lt;package-property-names&gt;</strong><p>This option<a id="_idIndexMarker360"/> specifies the acceptable library package formats to compile using the Angular Compatibility Compiler. The package property names refer to the properties of the JSON configuration in a library package's <strong class="source-inline">package.json</strong> module declaration.</p><p>Example: <strong class="source-inline">--properties es2015 browser module main</strong></p></li>
				<li><strong class="source-inline">--target &lt;package-name&gt;</strong><p>This option only compiles the specified package.</p><p>Example: <strong class="source-inline">--target @angular/material/button</strong></p></li>
				<li><strong class="source-inline">--tsconfig &lt;tsconfig-path&gt;</strong><p>You can use this option with <strong class="source-inline">--use-program-dependencies</strong> to target a specific project in your Angular workspace.</p><p>Example: <strong class="source-inline">--tsconfig projects/music-app/tsconfig.app.json</strong></p></li>
				<li><strong class="source-inline">--use-program-dependencies</strong><p>You can use this option to decide which library packages you want to compile with the Angular Compatibility Compiler based on the source code in your Angular workspace or project.</p></li>
			</ul>
			<p>A few more options exist but are for exceptional use cases.</p>
			<p>Running the Angular Compatibility Compiler manually, for example, after modifying or adding a package dependency, allows us to optimize the compilation speed. When we are triggering compilation of the entire workspace manually, we should generally use the following command:</p>
			<p class="source-code">ngcc --first-only --properties es2015 module fesm2015 esm2015 browser main --create-ivy-entry-points</p>
			<p>The <strong class="source-inline">--first-only</strong> option ensures that only one package format is compiled into an Angular Ivy-compatible<a id="_idIndexMarker361"/> package bundle using the <strong class="source-inline">esm2015</strong> package format. The <strong class="source-inline">--properties</strong> option lists the preferred package format. Research has shown that the <strong class="source-inline">es2015</strong> format is generally the fastest package format to compile from a View Engine-compatible bundle to an Angular Ivy-compatible bundle, closely followed by the <strong class="source-inline">module</strong> format. Finally, the <strong class="source-inline">--create-ivy-entry-points</strong> option is generally faster than in-place bundle replacement.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">If you are using Angular version 9.0 or 11.1, consider leaving out the <strong class="source-inline">--create-ivy-entry-points</strong> option to use in-place bundle replacement. Research has found this option to be slightly faster in these specific versions.</p>
			<p>Consider also adding the <strong class="source-inline">--use-program-dependencies</strong> option to only compile packages that are imported by an application. When using this option, we must run the Angular Compatibility Compiler every time we use a package for the first time in our application.</p>
			<p>The <strong class="source-inline">--use-program-dependencies</strong> option is especially useful when using Angular CDK and Angular Material because they have many sub-packages that are all compiled individually. Additionally, every Angular CDK and Angular Material sub-package is compiled by default, not just the ones used by an application. This impacts compilation speed significantly.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The <strong class="source-inline">ngcc</strong> commands listed in this chapter are meant to be used in pre-defined command listings inside the <strong class="source-inline">scripts</strong> property of <strong class="source-inline">package.json</strong>. To run them from a terminal, prefix them with <strong class="source-inline">npx</strong>, for example, <strong class="source-inline">npx ngcc --create-ivy-entry-points</strong>.</p>
			<p>That is all about options<a id="_idIndexMarker362"/> and common techniques for your local development workflow. In the following section, you will learn how to optimize the Angular Compatibility Compiler for speed in a CI/CD workflow.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor113"/>Improving the Angular Compatibility Compiler in your CI/CD workflow</h1>
			<p>As you can tell from the description<a id="_idIndexMarker363"/> of some of the options supported by the Angular Compatibility Compiler, it maintains<a id="_idIndexMarker364"/> files inside your application's <strong class="source-inline">node_modules</strong> folder. Depending on your CI environment, caching and restoring the entire <strong class="source-inline">node_modules</strong> folder might be too slow. In this case, cache your package manager's package cache folder instead.</p>
			<p>Maybe caching is not enabled at all in your CI/CD workflow. In both cases, we must run the Angular Compatibility Compiler in every CI/CD workflow run. It starts from scratch with the files it manages.</p>
			<p>For this use case, we use guidelines described in <em class="italic">Angular Compatibility Compiler options section</em>. We use the following <strong class="source-inline">postinstall</strong> hook to run <strong class="source-inline">ngcc</strong> in what is overall the fastest combination of parameter options:</p>
			<p class="source-code">ngcc --first-only --properties es2015 module fesm2015 esm2015 browser main --create-ivy-entry-points</p>
			<p>This only compiles a single package format to the Angular Ivy package format and prefers package formats in the order of the formats that are overall the fastest to compile. The package files are compiled to new files in subfolders managed by the Angular Compatibility Compiler rather than replacing the existing, View Engine-compiled package files.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Consider leaving out the <strong class="source-inline">--create-ivy-entry-points</strong> option if you are using Angular versions 9.0 or 11.1. Research has indicated that in-place Ivy compilation is faster in these versions.</p>
			<p>Running the Angular Compatibility Compiler in a separate step rather than on demand has the benefit of allowing<a id="_idIndexMarker365"/> fine-tuning as we just did. Additionally, it allows<a id="_idIndexMarker366"/> us to track the time spent on testing or building our application while excluding the View Engine to Angular Ivy compilation time.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor114"/>Targeting a single application in a monorepo workspace</h2>
			<p>As discussed in the <em class="italic">Angular Compatibility Compiler options</em> section, the Angular CDK and Angular Material<a id="_idIndexMarker367"/> are examples of Angular library packages<a id="_idIndexMarker368"/> with many sub-packages. If we have a monorepo workspace with several Angular applications, perhaps only some of them are using the Angular CDK or Angular Material. Additionally, any single one of these applications is most likely not using every sub-package of the Angular CDK or Angular Material.</p>
			<p>We can take this into account if we have a CI or CD job targeting a single application, for example, a test or build job for a particular application. Imagine that we have a monorepo workspace with two Angular applications, one using the Bootstrap UI component library and the other using Angular Material. In a test or build job for the application using Bootstrap, we use the following command in a step after installing package dependencies:</p>
			<p class="source-code">npx ngcc --first-only --properties es2015 module fesm2015 esm2015 browser main --create-ivy-entry-points --tsconfig projects/bootstrap-app/tsconfig.app.json --use-program-dependencies</p>
			<p>We are targeting the Bootstrap application by passing the path of its TypeScript configuration file to the <strong class="source-inline">--tsconfig</strong> option and finally we are adding the <strong class="source-inline">--use-program-dependencies</strong> option.</p>
			<p>This will save significant compute time in our CI/CD jobs as our CI server will not have to compile any sub-packages of Angular Material.</p>
			<p>Even in the case of the application using Angular Material, we can use a similar command to save time because<a id="_idIndexMarker369"/> it will only compile the Angular Material sub-packages<a id="_idIndexMarker370"/> that are imported by our application instead of all of them. This is shown in the following example command:</p>
			<p class="source-code">npx ngcc --first-only --properties es2015 module fesm2015 esm2015 browser main --create-ivy-entry-points --tsconfig projects/material-app/tsconfig.app.json --use-program-dependencies</p>
			<p>In the preceding command, we changed the path passed to the <strong class="source-inline">--tsconfig</strong> option.</p>
			<p>Now you have learned the most common optimization techniques for Angular application CI/CD workflows.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor115"/>Summary</h1>
			<p>In this chapter, we first discussed how the Angular Compatibility Compiler is a tool needed in the transition phase while Angular library packages are still compiled using the Angular View Engine compiler. The Angular Compatibility Compiler compiles these package bundles into the Angular Ivy format so that they can be used by our Angular Ivy applications.</p>
			<p>Additionally, we discussed how recent versions of Angular support partially Ivy-compiled Angular library packages using the Angular Linker, which eventually fully replaces the Angular Compatibility Compiler.</p>
			<p>After reviewing the use cases that rely on the Angular Compatibility Compiler, we briefly discussed the most useful options for the <strong class="source-inline">ngcc</strong> command-line tool. Following that, we walked through common optimization techniques using these options.</p>
			<p>Finally, this chapter ended by considering how the Angular Compatibility Compiler can be optimized for speed in CI/CD workflows. We discussed solutions for several specific and common use cases.</p>
			<p>Now you know how to take advantage of the Angular Compatibility Compiler and you know when and how to optimize it.</p>
			<p>In the next chapter, you will be guided on migrating your existing Angular application from View Engine to Ivy. You will learn about automated and manual migrations as well as other considerations when migrating from View Engine to Angular Ivy.</p>
		</div>
	</div></body></html>