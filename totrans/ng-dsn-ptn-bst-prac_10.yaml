- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Design for Tests: Best Practices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the best practices in a software project, be it a frontend or backend
    project, is testing. After all, if you and your team don’t rigorously test your
    system, the people who will inevitably test the system and find possible bugs
    are the users, and we don’t want that.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, it is no wonder that the Angular team has, since the first
    versions of the framework, been concerned with creating and integrating automated
    testing tools.
  prefs: []
  type: TYPE_NORMAL
- en: We can notice this with the fact that, by default, the Angular CLI always generates,
    together with the component, its test files as if saying, “*Hey, buddy, don’t
    forget the* *unit test!*”
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore this topic by covering the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What to test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding `TestBed`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E2E tests with Cypress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of the chapter, you will be able to create tests for your components
    and service, improving the quality of your delivery and your team.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the instructions in this chapter, you’ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js 18 or higher ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch10](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch10).
  prefs: []
  type: TYPE_NORMAL
- en: During the study of this chapter, remember to run the backend of the application
    found in the `gym-diary-backend` folder with the `npm` `start` command.
  prefs: []
  type: TYPE_NORMAL
- en: What to test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within a software project, we can do several types of tests to ensure the quality
    of the product. In this discipline, it is very common to categorize tests using
    a pyramid.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Test pyramid](img/B19562_10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Test pyramid
  prefs: []
  type: TYPE_NORMAL
- en: At the base of the pyramid, we have unit tests, whose objective is to verify
    the quality of the smallest elements within a software project, such as functions
    or methods of a class. Due to their narrow scope and atomic nature, they are quickly
    executed by tools and should ideally make up the majority of an application’s
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle layer, we have integration tests, which are focused on verifying
    how the project components interact with each other, being able, for example,
    to test an API through an HTTP request. Because these tests use more elements
    and need certain environmental requirements, they are less performant and have
    a higher execution cost, which is why we see them in smaller quantities compared
    to unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the pyramid, we have **end-to-end tests** (**E2E tests**), which
    validate the system from the user’s point of view, emulating their actions and
    behaviors. These tests require an almost complete environment, including a database
    and servers. In addition, they are slower and therefore there are fewer of them
    compared to the previous ones.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have manual and exploratory tests, which are tests performed by
    quality analysts. Ideally, these tests will serve as a basis for the creation
    of E2E tests, mainly on new features. As they are run by humans, they are the
    most expensive, but they are the best for discovering new bugs in new features.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to highlight that no test is better or more important than another.
    Here, we have the classification by volume of test executions in a period of time.
    You and your team must identify which tests to prioritize based on the capacity
    and resources available for your project. These types of tests can be applied
    to any type of software project, but you must be wondering how we fit this concept
    into an Angular project.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of manual testing can be applied without tools because what we need
    is a quality analyst and an application with a complete environment, that is,
    the backend services responding to our application.
  prefs: []
  type: TYPE_NORMAL
- en: E2E tests are performed by specific tools that simulate user behavior. Up to
    version 14, Angular already had a built-in tool called **Protractor**, but the
    Angular team no longer recommends it because there are more modern, faster alternatives.
    In this chapter, we are going to use **Cypress** for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, unit tests are performed on the methods of our services and components,
    verifying their behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Angular toolbox, we have two tools for creating and running these tests:
    Jasmine and Karma. These tools are installed by default when we start a new project.'
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine is a testing framework that has several checking functions, in addition
    to providing the ability to change the functionality of a method or class at runtime
    with an element called a **spy**. For the execution of unit tests, the Karma tool
    is used, which has the characteristic of running tests in a browser, giving the
    team the ability to analyze the behavior of the application in different types
    of environments. Although rare nowadays, we may have some bugs depending on the
    browser it runs on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use these two tools, we don’t need any configuration of our project; we
    just need to execute the following command in the command line of our operating
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once we execute the preceding command, we get a compilation error. This happens
    because, until then, Angular only compiled the files of our components and ignored
    the test files because they will not be deployed to users in the final version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the test, we notice that we have an error in the `diary.resolver.spec.ts`
    test file, so let’s make a correction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The test generated by the Angular CLI contains all of Jasmine’s boilerplate.
    In the `describe` function, we define our test case, which is a test group that
    we will create.
  prefs: []
  type: TYPE_NORMAL
- en: This function has, in the first parameter, a string that represents the name
    of the test case and will even identify it in reports.
  prefs: []
  type: TYPE_NORMAL
- en: In the second parameter, we have the function where we will have the preparation
    and the tests. Here, we made a correction because the resolver we want to test
    returns an object of type `ExerciseSetList` and not a Boolean as it was before.
  prefs: []
  type: TYPE_NORMAL
- en: On the next line, we have the `TestBed` class, which is the most fundamental
    element of Angular tests.
  prefs: []
  type: TYPE_NORMAL
- en: This framework class has the function of preparing the Angular execution environment
    for the tests to run. We will see in the following sections its use in different
    situations.
  prefs: []
  type: TYPE_NORMAL
- en: The `beforeEach` function has the objective of performing some common action
    before executing the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `it` function is where we will create the tests. Inside a `describe`
    function, we can have numerous functions of the `it type`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run Karma again, the browser will open, and we can follow the execution
    of the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Execution of tests by Karma](img/B19562_10_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Execution of tests by Karma
  prefs: []
  type: TYPE_NORMAL
- en: As this project already had the tests when we created the elements of our application,
    we have some broken tests that we will correct in the next sections, but the important
    thing now is for us to understand how to run the unit tests of our application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll learn how to create tests for our project’s services.
  prefs: []
  type: TYPE_NORMAL
- en: Service tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we studied in detail in [*Chapter 5*](B19562_05.xhtml#_idTextAnchor163),
    *Angular Services and the Singleton Pattern*, the service that works as a repository
    of business rules in an Angular application. Consequently, it is crucial for us
    to develop unit tests for these services. In this section, we will focus on the
    `ExerciseSetsService` service to illustrate the Angular unit testing techniques
    in our project. Let’s begin.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `exercise-sets.service.spec.ts` test file, let’s start by fixing the
    tests automatically created by the Angular CLI that are not running correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we want to work on service testing, at this time, we replace the `describe`
    function with the `fdescribe` function, so the Karma test runner will only execute
    this test case. The `fdescribe` feature is also available for isolating a specific
    test, in this case replacing the `it` function with the `fit` function. To fix
    the error identified by the Angular compiler, we import the `'HttpClientTestingModule'`
    module in the `TestBed` component.
  prefs: []
  type: TYPE_NORMAL
- en: We need to understand how Karma, Jasmine, and Angular work together to run tests.
    Before each test case is defined in `it` functions, Angular sets up an isolated
    environment for the tests. This environment has virtually no module configuration
    at first, as your real application has, and the `TestBed` component comes into
    play, where we configure the minimum necessary dependencies for your test to run.
  prefs: []
  type: TYPE_NORMAL
- en: In this service, as it depends on `HttpClient` to perform HTTP requests, we
    need to import the `HttpClientModule` module to have this dependency. You might
    be wondering, “But here you are using `HttpClientTestingModule`. Is this correct?”
    As we will see in the following code, not only will we want to use `HttpClient`
    but we will also need to simulate HTTP calls, and to make this task easier, the
    Angular team has prepared a specific module for this type of testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our basic “should be created” test case in place, let’s test the methods
    of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code, this service is designed to handle requests
    related to gym diary entries. In the initial method, `getInitialList`, our objective
    is to verify whether the service accurately initiates an HTTP request to the backend
    using the `GET` method. By creating a new case with the `it` function in the first
    parameter, we place a description of the test case that will be important for
    viewing during test execution. The test function, unlike the “should be created”
    test case, is contained within the `fakeAsync` function created by the Angular
    team to facilitate the testing of asynchronous methods, such as an HTTP request.
    Inside the function, we begin to assemble our test. Here, we need to define what
    the structure of a unit test looks like.
  prefs: []
  type: TYPE_NORMAL
- en: 'A unit test consists of three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The test setup, where we prepare all the elements for the tests to take place
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The execution of the method to be executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test assertion, where we compare the execution result with the expected
    return
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this test case, part of the setup was done in the `beforeEach` function,
    but note that, instead, we must put the setup common to all test cases that will
    be executed to avoid slowdowns in the test cases. In the test in question, we
    defined a fake return from our server, since the unit tests must be executed independently
    of the backend service. In the execution phase, we call the service with the `getInitialList`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: We call the `subscribe` method of the observable that the service returns, and
    inside it, we make the assertion that we expect the return to be equal to the
    item element of the `fakeBody` object. Here, the assertion phase can be tricky
    because, to check the return of this observable, we need to simulate the backend
    processing of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the Angular `HttpTestingController` service, with which we can emulate
    a response from our backend service. Here, we also create an assertion to ensure
    that our method is calling the API with the `GET` HTTP verb. In order to simulate
    the HTTP request , we use the `flush` method of the service and what we want to
    send – in this case, the `fakebody` object. But we need to remember that an HTTP
    operation is asynchronous so we use the `tick` function, available within the
    context of the `fakeAsync` function, to simulate the time that would pass for
    an asynchronous execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a test for the same service to simulate the creation of a new
    entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We start with the definition of the new test that will appear in Karma and then
    we create the test function, again within the context of the `fakeAsync` function.
  prefs: []
  type: TYPE_NORMAL
- en: In the test setup, we define an object called `fakeBody` with the payload we
    want to send and make the assertion. In the execution phase of the method we want
    to test, we call the `addNewItem` method and place the assertion inside the `subscribe`
    function. We perform the assertion of the `POST verb`, and finally, we simulate
    the request using the `flush` and `tick` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To end this session, let’s switch the `fdescribe` function to the `describe`
    function. In the test file of the `ExercisesService`, `AuthInterceptor`, and `AuthService`
    services, let’s make the following change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we saw in this section, we need to inform Angular of the test’s dependency,
    that is, declaring `HttpClientTestingModule` in the configuration of the `TestBed`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We still have to correct the test of the `NotificationInterceptor` service,
    which uses an external library as a dependency. We will refactor the `notification.interceptor.spec.ts`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the case of general dependencies that we need to simulate in our tests, we
    can define the service in the `providers` property in the `TestBed` class definition.
    But instead of offering the original `ToastrService` class, we declare an object
    and, using the `useValue` property, it tells Angular which class to provide for
    the test.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we could create a class that has the same original methods, but better
    than that, we are using a feature of the Jasmine test framework, which is the
    spy objects. With them, we can mock entire classes for our tests, thus managing
    to simulate unit test dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll fix all the tests and understand how Angular’s `TestBed`
    component works.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the tests and understanding TestBed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To better understand the use of `TestBed`, we’ll fix the rest of our project’s
    tests by adding dependencies to the test files. We’ll start with the `app.component.spec.ts`
    file and make the fixes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we cleaned up the test cases that had already been created by
    the Angular CLI when we started the project. It has the `router-outlet` component
    so we need to mock Angular’s route services. Like the `HttpClient` service, the
    Angular team has also prepared a specific module for testing, and so we are importing
    the `RouterTestingModule` module here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll change the test in the `login.component.spec.ts` file next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since the `Login` component relies on the `ReactiveFormsModule` module, we also
    need to import it into our test. Furthermore, the component utilizes the `AuthService`
    service, and for our mocking purposes, we employ the `useValue` property, as demonstrated
    earlier. In unit testing, it’s crucial to concentrate on the component itself,
    and we achieve this by isolating it through the mocking of its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next test to tune will be for the `home.component.spec.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When testing the `Home` component, we need to include the `'RouterTestingModule'`
    dependency because we are using route services and we are mocking the `'AuthService'`
    service due to the application’s logout action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s fix the test for the `new-entry-form-template.component.spec.ts`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This page employs template-driven form techniques, so for the test run, we include
    the `'FormsModule'` module by importing it. As it only uses the `'ExerciseSetsService'`
    service, we mocked it with the help of the Jasmine framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll work on testing the `new-entry-form-reactive.component.spec` page next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In [*Chapter 9*](B19562_09.xhtml#_idTextAnchor242), *Exploring Reactivity with
    RxJS*, we incorporated the search exercise into the form, so in this test case,
    we need to import the `'ReactiveFormsModule'` and `'RouterTestingModule'` modules.
    In addition, we need to mock the `'ExerciseSetsService'` and `'``ExercisesService'`
    services.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this test set, let’s go to the last component, `diary.component.spec.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This component, as it is a smart component in our suggested architecture, needs
    to declare the components that compose it in your test. Here, they are `DiaryComponent`,
    `ListEntriesComponent`, and `NewItemButtonComponent`. Finally, we imported the
    `RouterTestingModule` module into the test setup and mocked up the `ExerciseSetsService`
    service, thus correcting all the tests in our project.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how `TestBed` works, let’s create a test case for our component.
  prefs: []
  type: TYPE_NORMAL
- en: Component testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular component unit tests not only examine logic but also assess the values
    that will be presented on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: If your application follows the component architecture recommended by the Angular
    team (more details in [*Chapter 4*](B19562_04.xhtml#_idTextAnchor141), *Components
    and Pages*), you probably won’t have much business logic in your components, delegating
    it to services.
  prefs: []
  type: TYPE_NORMAL
- en: To exemplify, in this section, we will create tests for some methods of the
    `DiaryComponent` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create the test case for the gym diary entry deletion operation and
    check whether the service’s `delete` method is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we are testing the `DiaryComponent` component,
    so we mock the service it depends on with `TestBed`. But for this test, we need
    a reference to this service, and for that, we declare a variable called `exerciseSetsService`.
    With the `TestBed.inject` method, we assign the value to this variable.
  prefs: []
  type: TYPE_NORMAL
- en: In the test setup, we need to use the `createSpy` function to assign the service’s
    `deleteItem` method because the mock generated by the Jasmine framework does not
    have the full implementation of the service and therefore does not return the
    observable that the component is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: In the execution phase, we call the `deleteItem` method of the component.
  prefs: []
  type: TYPE_NORMAL
- en: As this operation is asynchronous, we use the `tick` function to simulate the
    passage of time.
  prefs: []
  type: TYPE_NORMAL
- en: In the assertion phase, we check that the `exerciseSetsService` service method
    was called once and with the expected parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test the `editEntry` method next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To perform the assertion of the route, we are going to use an object of type
    `Location` – that’s why we declare it at the beginning of the test and assign
    it using the `TestBed` component. Note that we want the `@angular/common` library
    object and not the browser’s default `Location` object. Also, in `TestBed`, we
    need to declare a route, because as we are in the context of unit testing, Angular
    does not know the routes available for use.
  prefs: []
  type: TYPE_NORMAL
- en: In the test case, we first create a dummy `ExerciseSet` object and call the
    `editEntry` method. Again, we use the `tick` function to simulate the passage
    of time. Finally, in the assertion, we verify that the path is correct. Note that,
    here, we don’t need to create any mock for the router as the `RouterTestingModule`
    module creates it for us.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore E2E testing with the Cypress framework.
  prefs: []
  type: TYPE_NORMAL
- en: E2E tests with Cypress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**E2E** tests aim to evaluate the system from the user’s point of view, simulating
    operations such as typing in a field, clicking on a button, carrying out the assertion,
    and evaluating the messages on the screen, just as a user would evaluate whether
    the action was successful or not.'
  prefs: []
  type: TYPE_NORMAL
- en: In the Angular ecosystem, in the past, there was a tool called **Protractor**
    to help with this type of testing, but it was discontinued by the Angular team
    in favor of other, more focused open source tools.
  prefs: []
  type: TYPE_NORMAL
- en: Among these new tools, we are going to use one of the most popular ones, called
    Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: The Cypress framework is a tool that aims to help developers create and run
    all types of tests in the test pyramid, from unitary to E2E.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see it in action in our project. For that, we need to install and configure
    it. Follow these steps to install and configure Cypress:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the Angular CLI to install and configure Cypress. In the command
    line of your operating system, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the tool, run the following command at the operating system prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 10.3 – Execution of tests by Cypress](img/B19562_10_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Execution of tests by Cypress
  prefs: []
  type: TYPE_NORMAL
- en: Select the desired browser and click on **Start E2E Testing** and we will have
    the test execution interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice that we already have a file called `spec.cy.ts`. It was generated by
    Cypress to exemplify the creation of the test script. Let’s go back to Visual
    Studio Code and check this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Unlike Angular, Cypress uses Mocha ([https://mochajs.org/](https://mochajs.org/))
    as a testing framework. However, in practice, as we can see in the preceding example,
    it is very similar to the Jasmine framework.
  prefs: []
  type: TYPE_NORMAL
- en: We have the `describe` function to create the test suite and the `it` function
    to create the test cases. The difference here is the `cy` object, which represents
    the browser’s interface, and with this object, we can perform actions and evaluate
    the state of the page, from the user’s point of view. Here, we use the `visit`
    method to go to the initial endpoint and we use the `contains` method to evaluate
    whether the text app is running appears on the page. We are going to delete this
    file because we are going to create the scripts for our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same folder as where the previous file was, we will create the `login.cy.ts`
    file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we used the `get` method to obtain the page element through CSS
    queries so that we could act on them. First, we take the `username` and `password`
    fields and use the `type` method to simulate the user typing in these fields.
    Then we locate the `click` method to simulate the mouse click action.
  prefs: []
  type: TYPE_NORMAL
- en: To assert the test, we used the `contains` method to assess whether the diary
    screen was displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The tricky part of creating this script is the CSS queries needed to get the
    elements we need. But at this point, Cypress helps us a lot.
  prefs: []
  type: TYPE_NORMAL
- en: By running the test, we can see that there is a target icon at the top of the
    screen. By clicking on it and selecting the element we want, Cypress will generate
    the necessary command ready to copy and paste into our script.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 10.4 – Cypress helping with\uFEFF the CSS query](img/B19562_10_4.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Cypress helping with the CSS query
  prefs: []
  type: TYPE_NORMAL
- en: In this script, however, there is a problem in selecting the button, in addition
    to the query not being clear to another person reading the test script. If the
    team needs to change the layout, the test could break unduly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this error, let’s change the `login` component template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With this custom HTML element, we can use the element marked with the `data-cy`
    attribute for our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We replaced the previous CSS query with a simpler one that does not depend on
    layout elements. Use this good practice in your project templates to facilitate
    E2E testing and make the test less likely to break.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll create an E2E test for the new journal entry form, but first, let’s apply
    the best practice to the templates we’ll be using in this test. In the `Home`
    component template, we will refactor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the template, we add the `data-cy` HTML element to the items of the menu.
    Note that as the test is from the user’s point of view, we need to simulate how
    they get to the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `new-entry-form-reactive.component.html` template, we will change the
    submit button like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As with the login screen, we mark the button with the `data-cy` element to facilitate
    the development of the E2E test.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our application better adapted for testing, we will create the `new-entry-form.cy.ts`
    file in the `cypress/e2e` folder of our workspace and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Like Jasmine, the Mocha.js framework also has the `beforeEach` function, but
    here, instead of setting up the environment with `TestBed`, we use the function
    to perform the login, since each test where we are simulating the user is necessary
    for this action.
  prefs: []
  type: TYPE_NORMAL
- en: In the test case of the form, since we are already logged in, we click on the
    menu of the input form and check whether there is a **Date** label. From then
    on, we fill in the form fields with data and click on the button. In the assertion
    phase, we check whether the **Item created** message appears on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note is that at no point do we tell the script how long to wait
    for the backend response, which can vary. This happens because the Cypress framework
    does this work for us and makes this waiting process transparent to our development.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a test case to evaluate the form validations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this test case, we don’t need to worry about the login because the `beforeEach`
    function performs this function and we work directly on the form. We fill in the
    fields, but this time, with information that is not valid. In the assertion phase,
    we check whether the validation messages appear correctly with the `contains`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you’ve learned about Cypress and E2E testing in an Angular application,
    so let’s summarize what we looked at in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to perform tests in an Angular project. We studied
    what types of tests there are, their importance, and how to apply them in our
    daily lives. We worked on our project by first creating tests for the services
    and looking at how to isolate the dependencies for a unit test. Furthermore, we
    explored testing HTTP requests using the `HttpClientTestingModule` module. We
    learned about the `TestBed` component and its important task of setting up the
    environment for each unit test to run. We also looked at component testing and
    how to assert components that use routes. Finally, we explored E2E tests with
    the Cypress tool, which simplifies the creation of scripts that simulate the behavior
    of our application from the client’s point of view.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the concept of the micro frontend using
    the Angular framework.
  prefs: []
  type: TYPE_NORMAL
