<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer021">
<h1 class="chapter-number" id="_idParaDest-101"><a id="_idTextAnchor099"/>6</h1>
<h1 id="_idParaDest-102"><a id="_idTextAnchor100"/>Exploring Test Doubles</h1>
<p>In this chapter, we’ll look at the most involved piece of the TDD puzzle: test doubles.</p>
<p>Jest has a set of convenience functions for test doubles, such as <strong class="source-inline">jest.spyOn</strong> and <strong class="source-inline">jest.fn</strong>. Unfortunately, using test doubles well is a bit of a dark art. If you don’t know what you’re doing, you can end up with complicated, brittle tests. Maybe this is why Jest doesn’t promote them as a first-class feature of its framework.</p>
<p>Don’t be turned off: test doubles are a highly effective and versatile tool. The trick is to restrict your usage to a small set of well-defined patterns, which you’ll learn about in the next few chapters.</p>
<p>In this chapter, we will build our own set of hand-crafted test double functions. They work pretty much just how Jest functions do, but with a simpler (and more clunky) interface. The aim is to take the magic out of these functions, showing you how they are built and how they can be used to simplify your tests.</p>
<p>In the test suites you’ve built so far, some tests didn’t use the normal <strong class="bold">Arrange-Act-Assert</strong> (<strong class="bold">AAA</strong>) test format. These are the tests that start with <strong class="source-inline">expect.hasAssertions</strong>. In a real code base, I would always avoid using this function and instead use test doubles, which help reorder the test into AAA order. We’ll start there: refactoring our existing tests to use our hand-crafted test doubles, and then swapping them out for Jest’s own test double functions.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>What is a test double?</li>
<li>Submitting forms using spies</li>
<li>Spying on the Fetch API</li>
<li>Stubbing <strong class="source-inline">fetch</strong> responses</li>
<li>Migrating to Jest’s built-in test double support</li>
</ul>
<p>By the end of the chapter, you’ll have learned how to make effective use of Jest’s test double functionality.</p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor101"/>Technical requirements</h1>
<p>The code files for this chapter can be found here: </p>
<p><a href="https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter06">https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter06</a></p>
<p>The code samples for this chapter and beyond contain extra commits that add a working backend to the application. This allows you to make requests to fetch data, which you’ll start doing in this chapter.</p>
<p>In the companion code repository, from <strong class="source-inline">Chapter06/Start</strong> onward, the <strong class="source-inline">npm run build</strong> command will automatically build the server.</p>
<p>You can then start the application by using the <strong class="source-inline">npm run serve</strong> command and browsing to <strong class="source-inline">http://localhost:3000</strong> or <strong class="source-inline">http://127.0.0.1:3000</strong>.</p>
<p class="callout-heading">If you run into problems</p>
<p class="callout">Check out the <em class="italic">Troubleshooting</em> section of the repository’s <strong class="source-inline">README.md</strong> file if you’re not able to get the application running.</p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor102"/>What is a test double?</h1>
<p>A <em class="italic">unit</em> in unit <a id="_idIndexMarker547"/>testing <a id="_idIndexMarker548"/>refers to a single function or component that we focus on for the duration of that test. The <strong class="bold">Act</strong> phase <a id="_idIndexMarker549"/>of a test should involve just one action on one unit. But units don’t act in isolation: functions call other functions, and components render child components and call callback props passed in from parent components. Your application can be thought of as a web of dependencies, and test doubles help us to design and test those dependencies. </p>
<p>When we’re writing tests, we <strong class="bold">isolate</strong> the unit under test. Often, that means we avoid exercising any <a id="_idIndexMarker550"/>of the <strong class="bold">collaborating objects</strong>. Why? Firstly, it helps us work toward our goal of independent, laser-focused tests. Secondly, sometimes those collaborating objects have side effects that would complicate our tests.</p>
<p>To give one example, with React components, we sometimes want to avoid rendering child components because they perform network requests when they are mounted.</p>
<p>A <strong class="bold">test double</strong> is an object that acts in place of a collaborating object. In <a href="B18423_04.xhtml#_idTextAnchor062"><em class="italic">Chapter 4</em></a><em class="italic">, Test-Driving Data Input</em>, you saw an example of a collaborator: the <strong class="source-inline">onSubmit</strong> function, which is a prop passed to both <strong class="source-inline">CustomerForm</strong> and <strong class="source-inline">AppointmentForm</strong>. We can swap that out with a test double in our tests. As we’ll see, that helps us define the relationship between the two.</p>
<p>The most important place to use test doubles is at the edges of our system when our code interacts with anything external to the page <a id="_idIndexMarker551"/>content: <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) requests, filesystem access, sockets, local storage, and so on.</p>
<p>Test doubles are <a id="_idIndexMarker552"/>categorized into several different types: spies, stubs, mocks, dummies, and fakes. We normally only use the first two, and that’s what we’ll concentrate on in this chapter.</p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor103"/>Learning to avoid fakes</h2>
<p>A <strong class="bold">fake</strong> is any test <a id="_idIndexMarker553"/>double<a id="_idIndexMarker554"/> that has any kind of logic or control <a id="_idIndexMarker555"/>structure within it, such as conditional statements or loops. Other types of test objects, such as spies and stubs, are made up entirely of variable assignments and function calls.</p>
<p>One type of fake you’ll see is an in-memory repository. You can use this in place of <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>) data <a id="_idIndexMarker556"/>stores, message brokers, and other complex sources of data.</p>
<p>Fakes are useful when testing complex collaborations between two units. We’ll often start by using spies and stubs and then refactor to a fake once the code starts to feel unwieldy. A single fake can cover a whole set of tests, which is simpler than maintaining a whole bunch of spies and stubs.</p>
<p>We avoid fakes for these <a id="_idIndexMarker557"/>reasons:</p>
<ul>
<li>Any logic requires tests, which means we must write tests for fakes, even though they are part of the test code. Spies and stubs don’t require tests.</li>
<li>Often, spies and stubs work in place of fakes. Only a small category of testing is simpler when we use fakes.</li>
<li>Fakes increase test brittleness because they are shared between tests, unlike other test doubles.</li>
</ul>
<p>Now that we’ve <a id="_idIndexMarker558"/>covered <a id="_idIndexMarker559"/>the theory of test doubles, let’s move on to using them in our code.</p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor104"/>Submitting forms using spies</h1>
<p>In this <a id="_idIndexMarker560"/>section, you’ll <a id="_idIndexMarker561"/>hand-craft a reusable spy function and adjust your tests to get them back into AAA order.</p>
<p>Here’s a reminder of how one of those tests looked, from the <strong class="source-inline">CustomerForm</strong> test suite. It’s complicated by the fact it’s wrapped in a test generator, but you can ignore that bit for now—it’s the test content that’s important:</p>
<pre class="source-code">
const itSubmitsExistingValue = (fieldName, value) =&gt;
  it("saves existing value when submitted", () =&gt; {
    expect.hasAssertions();
    const customer = { [fieldName]: value };
    render(
      &lt;CustomerForm
        original={customer}
        onSubmit={(props) =&gt;
          expect(props[fieldName]).toEqual(value)
      }
    /&gt;
  );
  click(submitButton());
});</pre>
<p>There are a couple of issues with this code, as follows:</p>
<ul>
<li>The <strong class="bold">Assert</strong> phase <a id="_idIndexMarker562"/>of the test—the expectation—appears wrapped within<a id="_idIndexMarker563"/> the <strong class="bold">Act</strong> phase. That makes the test difficult to read and understand.</li>
<li>The call to <strong class="source-inline">expect.hasAssertions</strong> is ugly and is only there because our expectation is called as part of the <strong class="source-inline">onSubmit</strong> function, which may or may not be called.</li>
</ul>
<p>We <a id="_idIndexMarker564"/>can fix <a id="_idIndexMarker565"/>both issues by building a spy.</p>
<p class="callout-heading">What is a spy?</p>
<p class="callout">A <strong class="bold">spy</strong> is a type <a id="_idIndexMarker566"/>of test double that records the arguments it is called with so that those values can be inspected later.</p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor105"/>Untangling AAA</h2>
<p>To move the <a id="_idIndexMarker567"/>expectation under the <strong class="bold">Act</strong> phase of the test, we can introduce a variable to store the <strong class="source-inline">firstName</strong> value that’s passed into the <strong class="source-inline">onSubmit</strong> function. We then write the expectation against that stored value.</p>
<p>Let’s do that now, as follows:</p>
<ol>
<li>Modify the <strong class="source-inline">saves existing value when submitted</strong> test-generator function in <strong class="source-inline">test/CustomerForm.test.js</strong>, like so:<p class="source-code">const itSubmitsExistingValue = (fieldName, value) =&gt;</p><p class="source-code">  it("saves existing value when submitted", () =&gt; {</p><p class="source-code"><strong class="bold">    let submitArg;</strong></p><p class="source-code">    const customer = { [fieldName]: value };</p><p class="source-code">    render(</p><p class="source-code">      &lt;CustomerForm</p><p class="source-code">        original={customer}</p><p class="source-code">        onSubmit={<strong class="bold">submittedCustomer =&gt; (</strong></p><p class="source-code"><strong class="bold">          submitArg = submittedCustomer</strong></p><p class="source-code"><strong class="bold">        )</strong>}</p><p class="source-code">      /&gt;</p><p class="source-code">    );</p><p class="source-code">    click(submitButton());</p><p class="source-code">    <strong class="bold">expect(submitArg).toEqual(customer);</strong></p><p class="source-code">  });</p></li>
</ol>
<p>The <strong class="source-inline">submitArg</strong> variable is assigned within our <strong class="source-inline">onSubmit</strong> handler and then asserted in the very <a id="_idIndexMarker568"/>last line of the test. This fixes both the issues we had with the first test: our test is back in AAA order and we got rid of the ugly <strong class="source-inline">expect.hasAssertions()</strong> call.</p>
<ol>
<li value="2">If you run your tests now, they should be green. However, any time you refactor tests in this way, you should verify that you’re still testing the right thing by unwinding the production code and watching the test fail. To check that our tests still work, locate this line in <strong class="source-inline">src/CustomerForm.js</strong>:<p class="source-code">&lt;form id="customer" onSubmit={handleSubmit}&gt;</p></li>
</ol>
<p>Remove the <strong class="source-inline">onSubmit</strong> prop entirely, like so:</p>
<p class="source-code">&lt;form id="customer"&gt;</p>
<ol>
<li value="3">Run <strong class="source-inline">npm test</strong>. You’ll get multiple test failures from various different tests. However, we’re only interested in this one test generator, so update its declaration <a id="_idIndexMarker569"/>to <strong class="source-inline">it.only</strong> rather than <strong class="source-inline">it</strong>, as follows:<p class="source-code">it<strong class="bold">.only</strong>("saves existing value when submitted", () =&gt; {</p></li>
<li>Now, you should have just three failures, one for each of the fields that uses this generator function, as illustrated in the following code snippet. That’s a good sign; any fewer and we would have been generating false positives:<p class="source-code">FAIL test/CustomerForm.test.js</p><p class="source-code">  ● CustomerForm › first name field › saves existing value when submitted</p><p class="source-code">    expect(received).toEqual(expected) // deep equality</p><p class="source-code">    Expected: {"firstName": "existingValue"}</p><p class="source-code">    Received: undefined</p></li>
<li>We’ve proved the test works, so you can go ahead and change the <strong class="source-inline">it.only</strong> declaration <a id="_idIndexMarker570"/>back to <strong class="source-inline">it</strong>, and reinsert the <strong class="source-inline">onSubmit</strong> prop that you removed from <strong class="source-inline">CustomerForm.js</strong>.</li>
</ol>
<p>The code you’ve <a id="_idIndexMarker571"/>written in this test shows the essence of the spy function: we set a variable when the spy is called, and then we write an expectation based on that variable value.</p>
<p>But we don’t yet have an <em class="italic">actual</em> spy function. We’ll create that next.</p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor106"/>Making a reusable spy function</h2>
<p>We still have other<a id="_idIndexMarker572"/> tests within both <strong class="source-inline">CustomerForm</strong> and <strong class="source-inline">AppointmentForm</strong> that use the <strong class="source-inline">expect.hasAssertions</strong> form. How can we reuse what we’ve built in this one test across everything else? We can create a generalized <strong class="source-inline">spy</strong> function that can be used any time we want spy functionality.</p>
<p>Let’s start by defining a function that can stand in for any single-argument function, such as the event handlers we would pass to the <strong class="source-inline">onSubmit</strong> form prop, as follows:</p>
<ol>
<li value="1">Define the following function at the top of <strong class="source-inline">test/CustomerForm.test.js</strong>. Notice how the <strong class="source-inline">fn</strong> definition has a similar format to the <strong class="source-inline">onSubmit</strong> handler we used in the previous test:<p class="source-code">const singleArgumentSpy = () =&gt; {</p><p class="source-code">  let receivedArgument;</p><p class="source-code">  return {</p><p class="source-code">    fn: arg =&gt; (receivedArgument = arg),</p><p class="source-code">    receivedArgument: () =&gt; receivedArgument</p><p class="source-code">  };</p><p class="source-code">};</p></li>
<li>Rewrite your test generator to use this function. Although your tests should still pass, remember to watch your tests fail by unwinding the production code. The code is illustrated <a id="_idIndexMarker573"/>in the following snippet:<p class="source-code">const itSubmitsExistingValue = (fieldName, value) =&gt;</p><p class="source-code">  it("saves existing value when submitted", () =&gt; {</p><p class="source-code"><strong class="bold">    const submitSpy = singleArgumentSpy();</strong></p><p class="source-code">    const customer = { [fieldName]: value };</p><p class="source-code">    render(</p><p class="source-code">      &lt;CustomerForm</p><p class="source-code">        original={customer}</p><p class="source-code"><strong class="bold">        onSubmit={submitSpy.fn}</strong></p><p class="source-code">      /&gt;</p><p class="source-code">    );</p><p class="source-code">    click(submitButton());</p><p class="source-code">    expect(<strong class="bold">submitSpy.receivedArgument()</strong>).toEqual(</p><p class="source-code">      customer</p><p class="source-code">    );</p><p class="source-code">  });</p></li>
<li>Make your spy function work for functions with any number of arguments by replacing <strong class="source-inline">singleArgumentSpy</strong> with the following function:<p class="source-code">const <strong class="bold">spy</strong> = () =&gt; {</p><p class="source-code">  let <strong class="bold">receivedArguments</strong>;</p><p class="source-code">  return {</p><p class="source-code">    fn: <strong class="bold">(...args) =&gt; (receivedArguments = args)</strong>,</p><p class="source-code"> <strong class="bold">   receivedArguments: </strong>() =&gt;<strong class="bold"> receivedArguments</strong>,</p><p class="source-code"><strong class="bold">    receivedArgument: n =&gt; receivedArguments[n]</strong></p><p class="source-code">  };</p><p class="source-code">};</p></li>
</ol>
<p>This uses <a id="_idIndexMarker574"/>parameter destructuring to save an entire array of parameters. We can use <strong class="source-inline">receivedArguments</strong> to return that array or use <strong class="source-inline">receivedArgument(n)</strong> to retrieve the <em class="italic">n</em>th argument.</p>
<ol>
<li value="4">Update your test code to use this new function, as shown in the following code snippet. You can include an extra expectation that <a id="_idIndexMarker575"/>checks <strong class="source-inline">toBeDefined</strong> on <strong class="source-inline">receivedArguments</strong>. This is a way of saying “I expect the function to be called”:<p class="source-code">const itSubmitsExistingValue = (fieldName, value) =&gt;</p><p class="source-code">  it("saves existing value when submitted", () =&gt; {</p><p class="source-code">    const submitSpy = <strong class="bold">spy();</strong></p><p class="source-code">    const customer = { [fieldName]: value };</p><p class="source-code">    render(</p><p class="source-code">      &lt;CustomerForm</p><p class="source-code">        original={customer}</p><p class="source-code">        onSubmit={submitSpy.fn}</p><p class="source-code">      /&gt;</p><p class="source-code">    );</p><p class="source-code">    click(submitButton());</p><p class="source-code"><strong class="bold">    expect(</strong></p><p class="source-code"><strong class="bold">      submitSpy.receivedArguments()</strong></p><p class="source-code"><strong class="bold">    ).toBeDefined();</strong></p><p class="source-code">    expect(submitSpy.<strong class="bold">receivedArgument(0)</strong>).toEqual(</p><p class="source-code">      customer</p><p class="source-code">    );</p><p class="source-code">  });</p></li>
</ol>
<p>That’s really<a id="_idIndexMarker576"/> all there is to a spy: it’s just there to keep track of when it was called, and the arguments it was called with.</p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor107"/>Using a matcher to simplify spy expectations</h2>
<p>Let’s write a<a id="_idIndexMarker577"/> matcher that encapsulates <a id="_idIndexMarker578"/>these expectations into one single statement, like this:</p>
<pre class="source-code">
expect(submitSpy).toBeCalledWith(value);</pre>
<p>This is more <a id="_idIndexMarker579"/>descriptive than<a id="_idIndexMarker580"/> using a <strong class="source-inline">toBeDefined()</strong> argument on the matcher. It also encapsulates the notion that if <strong class="source-inline">receivedArguments</strong> hasn’t been set, then it hasn’t been called.</p>
<p class="callout-heading">Throwaway code</p>
<p class="callout">We’ll <strong class="bold">spike</strong> this <a id="_idIndexMarker581"/>code—in other words, we won’t write tests. That’s because soon, we’ll replace this with Jest’s own built-in spy functionality. There’s no point in going too deep into a “real” implementation since we’re not intending to keep it around for long.</p>
<p>We’ll start by replacing the functionality of the first expectation, as follows:</p>
<ol>
<li value="1">Add the following code at the bottom of <strong class="source-inline">test/domMatchers.js</strong>. It adds the <a id="_idIndexMarker582"/>new <a id="_idIndexMarker583"/>matcher, ready for our tests:<p class="source-code">expect.extend({</p><p class="source-code">  toBeCalled(received) {</p><p class="source-code">    if (received.receivedArguments() === undefined) {</p><p class="source-code">      return {</p><p class="source-code">        pass: false,</p><p class="source-code">        message: () =&gt; "Spy was not called.",</p><p class="source-code">      };</p><p class="source-code">    }</p><p class="source-code">    return {</p><p class="source-code">      pass: true,</p><p class="source-code">      message: () =&gt; "Spy was called.",</p><p class="source-code">    };</p><p class="source-code">  },</p><p class="source-code">});</p></li>
<li>Update the test to use the new matcher, replacing the first expectation that used <strong class="source-inline">toBeDefined</strong>, as <a id="_idIndexMarker584"/>follows:<p class="source-code">const itSubmitsExistingValue = (fieldName, value) =&gt;</p><p class="source-code">  it("saves existing value when submitted", () =&gt; {</p><p class="source-code">    const submitSpy = <strong class="bold">spy();</strong></p><p class="source-code">    const customer = { [fieldName]: value };</p><p class="source-code">    render(</p><p class="source-code">      &lt;CustomerForm</p><p class="source-code">        original={customer}</p><p class="source-code">        onSubmit={submitSpy.fn}</p><p class="source-code">      /&gt;</p><p class="source-code">    );</p><p class="source-code">    click(submitButton());</p><p class="source-code"><strong class="bold">    expect(submitSpy).toBeCalled(customer);</strong></p><p class="source-code">    expect(submitSpy.<strong class="bold">receivedArgument(0)</strong>).toEqual(</p><p class="source-code">      customer</p><p class="source-code">    );</p><p class="source-code">  });</p></li>
<li>Verify the <a id="_idIndexMarker585"/>new <a id="_idIndexMarker586"/>matcher works by commenting out the call to <strong class="source-inline">onSubmit</strong> in your production code and watching the test fail. Then, undo the comment and try the negated form in your <strong class="source-inline">.not.toBeCalled</strong> test.</li>
<li>Now we can work on the second expectation—the one that checks the function arguments. Add <a id="_idIndexMarker587"/>the following code to your new matcher and rename it from <strong class="source-inline">toBeCalled</strong> to <strong class="source-inline">toBeCalledWith</strong>:<p class="source-code">expect.extend({</p><p class="source-code">  toBeCalled<strong class="bold">With</strong>(received<strong class="bold">, ...expectedArguments</strong>) {</p><p class="source-code">    if (received.receivedArguments() === undefined) {</p><p class="source-code">      ...</p><p class="source-code">    }</p><p class="source-code">    <strong class="bold">const notMatch = !this.equals(</strong></p><p class="source-code"><strong class="bold">      received.receivedArguments(),</strong></p><p class="source-code"><strong class="bold">      expectedArguments</strong></p><p class="source-code"><strong class="bold">    );</strong></p><p class="source-code"><strong class="bold">    if (notMatch) {</strong></p><p class="source-code"><strong class="bold">      return {</strong></p><p class="source-code"><strong class="bold">        pass: false,</strong></p><p class="source-code"><strong class="bold">        message: () =&gt;</strong></p><p class="source-code"><strong class="bold">          "Spy called with the wrong arguments: " +</strong></p><p class="source-code"><strong class="bold">          received.receivedArguments() +</strong></p><p class="source-code"><strong class="bold">          ".",</strong></p><p class="source-code"><strong class="bold">      };</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">    return ...;</p><p class="source-code">  },</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Using this.equals in a matcher</p>
<p class="callout">The <strong class="source-inline">this.equals</strong> method <a id="_idIndexMarker588"/>is a special type of equality function that can be used in matchers. It does deep equality matching, meaning it will recurse through hashes and <a id="_idIndexMarker589"/>arrays looking for differences. It also allows the use <a id="_idIndexMarker590"/>of <strong class="source-inline">expect.anything()</strong>, <strong class="source-inline">expect.objectContaining()</strong>, and <strong class="source-inline">expect.arrayContaining()</strong> special <a id="_idIndexMarker591"/>functions.</p>
<p class="callout">If you<a id="_idIndexMarker592"/> were test-driving this matcher and had extracted it into its own file, you wouldn’t use <strong class="source-inline">this.equals</strong>. Instead, you’d <a id="_idIndexMarker593"/>import the <strong class="source-inline">equals</strong> function from the <strong class="source-inline">@jest/expect-utils</strong> package. We’ll do this in <a href="B18423_07.xhtml#_idTextAnchor125"><em class="italic">Chapter 7</em></a><em class="italic">, Testing useEffect and Mocking Components</em>.</p>
<ol>
<li value="5">Update your test to merge both expectations into one, as follows:<p class="source-code">const itSubmitsExistingValue = (fieldName, value) =&gt;</p><p class="source-code">  it("saves existing value when submitted", () =&gt; {</p><p class="source-code">    ...</p><p class="source-code">    click(submitButton());</p><p class="source-code"><strong class="bold">    expect(submitSpy).toBeCalledWith(customer);</strong></p><p class="source-code">  });</p></li>
<li>Make this fail by changing the <strong class="source-inline">onSubmit</strong> call in your <strong class="source-inline">CustomerForm</strong> test suite to send obviously wrong data—for example, <strong class="source-inline">onSubmit(1, 2, 3)</strong>. Then, try the negated form of the matcher too.</li>
</ol>
<p>This completes <a id="_idIndexMarker594"/>our<a id="_idIndexMarker595"/> spy implementation, and you’ve seen how to test callback props. Next, we’ll look at spying on a more difficult function: <strong class="source-inline">global.fetch</strong>.</p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor108"/>Spying on the fetch API</h1>
<p>In this section, we’ll<a id="_idIndexMarker596"/> use the <strong class="source-inline">Fetch</strong> API to send customer data to our backend service. We already have an <strong class="source-inline">onSubmit</strong> prop that is called when the form is submitted. We’ll morph this <strong class="source-inline">onSubmit</strong> call into a <strong class="source-inline">global.fetch</strong> call, in the process of adjusting our existing tests.</p>
<p>In our updated component, when the <strong class="bold">Submit</strong> button is clicked, a <strong class="source-inline">POST</strong> HTTP request is sent to the <strong class="source-inline">/customers</strong> endpoint via the <strong class="source-inline">fetch</strong> function. The body of the request will be a <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) object <a id="_idIndexMarker597"/>representation of our customer.</p>
<p>The server implementation that’s included in the GitHub repository will return an updated <strong class="source-inline">customer</strong> object with an additional field: the customer <strong class="source-inline">id</strong> value.</p>
<p>If the <strong class="source-inline">fetch</strong> request is successful, we’ll call a new <strong class="source-inline">onSave</strong> callback prop with the <strong class="source-inline">fetch</strong> response. If the request isn’t successful, <strong class="source-inline">onSave</strong> won’t be called and we’ll instead render an error message.</p>
<p>You can think of <strong class="source-inline">fetch</strong> as a more advanced form on <strong class="source-inline">onSubmit</strong>: both are functions that we’ll call with our customer object. But <strong class="source-inline">fetch</strong> needs a special set of parameters to define the HTTP request being made. It also returns a <strong class="source-inline">Promise</strong> object, so we’ll need to account for that, and the request body needs to be a string, rather than a plain object, so we’ll need to make sure we translate it in our component and in our test suite.</p>
<p>One final difference: <strong class="source-inline">fetch</strong> is a global function, accessible via <strong class="source-inline">global.fetch</strong>. We don’t need to pass that as a prop. In order to spy on it, we replace the original function with our spy.</p>
<p class="callout-heading">Understanding the Fetch API</p>
<p class="callout">The following code samples show how the <strong class="source-inline">fetch</strong> function expects to be called. If you’re unfamiliar with this function, see the <em class="italic">Further reading</em> section at the end of this chapter.</p>
<p>With all that in <a id="_idIndexMarker598"/>mind, we can plan our route forward: we’ll start by replacing the global function with our own spy, then we’ll add new tests to ensure we call it correctly, and finally, we’ll update our <strong class="source-inline">onSubmit</strong> tests to adjust its existing behavior.</p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor109"/>Replacing global functions with spies</h2>
<p>We’ve seen<a id="_idIndexMarker599"/> how to spy on a callback <a id="_idIndexMarker600"/>prop, by <a id="_idIndexMarker601"/>simply passing the spy as the callback’s prop value. To spy on a global function, we simply overwrite its value before our test runs and reset it back to the original function afterward. </p>
<p>Since <strong class="source-inline">global.fetch</strong> is a required dependency of your component—it won’t function without it—it makes sense to set a default spy in the test suite’s <strong class="source-inline">beforeEach</strong> block so that the spy is primed in all tests. The <strong class="source-inline">beforeEach</strong> block is also a good place for setting default return values of stubs, which we’ll do a little later in the chapter.</p>
<p>Follow these steps to set a default spy on <strong class="source-inline">global.fetch</strong> for your test suite:</p>
<ol>
<li value="1">Add the following declarations at the top of the outer <strong class="source-inline">describe</strong> block in <strong class="source-inline">test/CustomerForm.test.js</strong>:<p class="source-code">describe("CustomerForm", () =&gt; {</p><p class="source-code"><strong class="bold">  const originalFetch = global.fetch;</strong></p><p class="source-code"><strong class="bold">  let fetchSpy;</strong></p><p class="source-code">  ...</p><p class="source-code">})</p></li>
</ol>
<p>The <strong class="source-inline">originalFetch</strong> constant will be used when restoring the spy after our tests are complete. The <strong class="source-inline">fetchSpy</strong> variable will be used to store our <strong class="source-inline">fetch</strong> object so that we can write expectations against it.</p>
<ol>
<li value="2">Change the <strong class="source-inline">beforeEach</strong> block to read as follows. This sets up <strong class="source-inline">global.fetch</strong> as a spy for every test in your test suite:<p class="source-code">beforeEach(() =&gt; {</p><p class="source-code">  initializeReactContainer();</p><p class="source-code"><strong class="bold">  fetchSpy = spy();</strong></p><p class="source-code"><strong class="bold">  global.fetch = fetchSpy.fn;</strong></p><p class="source-code">});</p></li>
<li>Just below the <strong class="source-inline">beforeEach</strong> block, add an <strong class="source-inline">afterEach</strong> block to unset your mock, like so:<p class="source-code">afterEach(() =&gt; {</p><p class="source-code">  global.fetch = originalFetch;</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Resetting global spies with original values</p>
<p class="callout">It’s important to reset any global variables that you replace with spies. This is a common cause of test interdependence: with a “dirty” spy, one test may break because some other test failed to reset its spies.</p>
<p class="callout">In this specific case, the Node.js runtime environment doesn’t actually have a <strong class="source-inline">global.fetch</strong> function, so the <strong class="source-inline">originalFetch</strong> constant will end up as <strong class="source-inline">undefined</strong>. You could argue, then, that this is unnecessary: in our <strong class="source-inline">afterEach</strong> block, we could simply delete the <strong class="source-inline">fetch</strong> property from <strong class="source-inline">global</strong> instead.</p>
<p class="callout">Later in the chapter, we’ll modify our approach to setting global spies when we use Jest’s built-in spy functions.</p>
<p>With the <a id="_idIndexMarker602"/>global <a id="_idIndexMarker603"/>spy <a id="_idIndexMarker604"/>in place, you’re ready to make use of it in your tests.</p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor110"/>Test-driving fetch argument values</h2>
<p>It’s time <a id="_idIndexMarker605"/>to <a id="_idIndexMarker606"/>add <strong class="source-inline">global.fetch</strong> to our<a id="_idIndexMarker607"/> component. When the <strong class="bold">submit</strong> button is clicked, we want to check that <strong class="source-inline">global.fetch</strong> is called with the right arguments. Similar to how we tested <strong class="source-inline">onSubmit</strong>, we’ll split this into a test for each field, specifying that each field must be passed along.</p>
<p>It turns out that <strong class="source-inline">global.fetch</strong> needs a whole bunch of parameters passed to it. Rather than test them all in one<a id="_idIndexMarker608"/> single unit test, we’re going to split up the tests according to their meaning.</p>
<p>We’ll start by checking the basics of the request: that it’s a <strong class="source-inline">POST</strong> request to the <strong class="source-inline">/customers</strong> endpoint. Follow these steps:</p>
<ol>
<li value="1">Add the following new test at the bottom of your <strong class="source-inline">CustomerForm</strong> test suite. Notice how <strong class="source-inline">onSubmit</strong> is given an empty function definition—<strong class="source-inline">() =&gt; {}</strong>—rather than a<a id="_idIndexMarker609"/> spy since we aren’t interested <a id="_idIndexMarker610"/>in that prop in this test:<p class="source-code">it("sends request to POST /customers when submitting the form", () =&gt; {</p><p class="source-code">  render(</p><p class="source-code">    &lt;CustomerForm</p><p class="source-code">      original={blankCustomer}</p><p class="source-code">      onSubmit={() =&gt; {}}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  click(submitButton());</p><p class="source-code">  expect(fetchSpy).toBeCalledWith(</p><p class="source-code">    "/customers",</p><p class="source-code">    expect.objectContaining({</p><p class="source-code">      method: "POST",</p><p class="source-code">    })</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>Run tests with <strong class="source-inline">npm test</strong> and verify that you receive an expectation failure with a <strong class="source-inline">Spy was not called</strong> message, as shown in the following code snippet:<p class="source-code">  ● CustomerForm › sends request to POST /customers when submitting the form</p><p class="source-code">    Spy was not called.</p><p class="source-code">      163 |     );</p><p class="source-code">      164 |     click(submitButton());</p><p class="source-code">    &gt; 165 |     expect(fetchSpy).toBeCalledWith(</p><p class="source-code">          |                      ^</p><p class="source-code">      166 |       "/customers",</p><p class="source-code">      167 |       expect.objectContaining({</p><p class="source-code">      168 |         method: "POST",</p></li>
<li>To make that pass, modify <strong class="source-inline">CustomerForm</strong>’s <strong class="source-inline">handleSubmit</strong> function by adding<a id="_idIndexMarker611"/> a<a id="_idIndexMarker612"/> call to <strong class="source-inline">global.fetch</strong> <em class="italic">above</em> the call to <strong class="source-inline">onSubmit</strong>, as shown in the following code snippet:<p class="source-code">const handleSubmit = (event) =&gt; {</p><p class="source-code">  event.preventDefault();</p><p class="source-code"><strong class="bold">  global.fetch("/customers", {</strong></p><p class="source-code"><strong class="bold">    method: "POST",</strong></p><p class="source-code"><strong class="bold">  });</strong></p><p class="source-code">  onSubmit(customer);</p><p class="source-code">};</p></li>
</ol>
<p class="callout-heading">Side-by-side implementations</p>
<p class="callout">This is a side-by-side <a id="_idIndexMarker613"/>implementation. We leave the “old” implementation—the call to <strong class="source-inline">onSubmit</strong>—in place so that the other tests continue to pass.</p>
<ol>
<li value="4">With that test passing, add the next one. In this test, we test all the plumbing that’s necessary for our request, which we’ll call “configuration,” but you can think of this as batching up all the constant, less relevant information. This test also uses two<a id="_idIndexMarker614"/> new<a id="_idIndexMarker615"/> functions, <strong class="source-inline">expect.anything</strong> and <strong class="source-inline">expect.objectContaining</strong>, which<a id="_idIndexMarker616"/> are <a id="_idIndexMarker617"/>shown in the following code snippet:<p class="source-code">it("calls fetch with the right configuration", () =&gt; {</p><p class="source-code">  render(</p><p class="source-code">    &lt;CustomerForm</p><p class="source-code">      original={blankCustomer}</p><p class="source-code">      onSubmit={() =&gt; {}}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  click(submitButton());</p><p class="source-code">  expect(fetchSpy).toBeCalledWith(</p><p class="source-code">    expect.anything(),</p><p class="source-code">    expect.objectContaining({</p><p class="source-code">      credentials: "same-origin",</p><p class="source-code">      headers: {</p><p class="source-code">        "Content-Type": "application/json",</p><p class="source-code">      },</p><p class="source-code">    })</p><p class="source-code">  );</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Testing a subset of properties with expect.anything and expect.objectContaining</p>
<p class="callout">The <strong class="source-inline">expect.anything</strong> function<a id="_idIndexMarker618"/> is a useful way of saying: “I don’t <a id="_idIndexMarker619"/>care about this argument in this test; I’ve tested it somewhere else.” It’s another great way of keeping your tests independent of each other. In this case, our previous test checks that the first parameter is set to <strong class="source-inline">/customers</strong>, so we don’t need to test that again in this test.</p>
<p class="callout">The <strong class="source-inline">expect.objectContaining</strong> function is just like <strong class="source-inline">expect.arrayContaining</strong>, and <a id="_idIndexMarker620"/>allows us to test just a slice of the full argument value.</p>
<ol>
<li value="5">Run that test and observe the test failure. You can see in the following code snippet that our matcher hasn’t done a great job of printing the message: the second actual parameter is printed as <strong class="source-inline">[object Object]</strong>. Let’s ignore that for now<a id="_idIndexMarker621"/> since <a id="_idIndexMarker622"/>later in the chapter, we’ll move to using Jest’s built-in matcher:<p class="source-code">  ● CustomerForm › calls fetch with the right configuration when submitting the form</p><p class="source-code">    Spy was called with the wrong arguments: /customers,[object Object].</p></li>
<li>To make that pass, simply insert the remaining properties into your call to <strong class="source-inline">global.fetch</strong>:<p class="source-code">const handleSubmit = (event) =&gt; {</p><p class="source-code">  event.preventDefault();</p><p class="source-code">  global.fetch("/customers", {</p><p class="source-code">    method: "POST",</p><p class="source-code"><strong class="bold">    credentials: "same-origin",</strong></p><p class="source-code"><strong class="bold">    headers: { "Content-Type": "application/json" },</strong></p><p class="source-code">  });</p><p class="source-code">  onSubmit(customer);</p><p class="source-code">};</p></li>
</ol>
<p>That gets the plumbing in place for our <strong class="source-inline">global.fetch</strong> call, with each of the constant arguments <a id="_idIndexMarker623"/>defined and in its place. Next, we’ll add<a id="_idIndexMarker624"/> in the dynamic argument: the request body.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor111"/>Reworking existing tests with the side-by-side implementation</h2>
<p>You’ve<a id="_idIndexMarker625"/> already<a id="_idIndexMarker626"/> started to build out the side-be-side implementation by using new tests. Now, it’s time to rework the existing tests. We’ll remove the old implementation (<strong class="source-inline">onSubmit</strong>, in this case) and replace it with the new implementation (<strong class="source-inline">global.fetch</strong>).</p>
<p>Once we’ve completed that, all the tests will point to <strong class="source-inline">global.fetch</strong> and so we can update our implementation to remove the <strong class="source-inline">onSubmit</strong> call from the <strong class="source-inline">handleSubmit</strong> function.</p>
<p>We’ve got two tests to update: the test that checks submitting existing values, and the test that checks submitting new values. They are complicated by the fact that they are wrapped in test-generator functions. That means as we change them, we should expect all the generated tests—one for each field—to fail as a group. It’s not ideal, but the process we’re following would be the same even if it were just a plain test. </p>
<p>Let’s get started with the test you’ve already worked on in this chapter, for submitting existing values. Follow these steps:</p>
<ol>
<li value="1">Move back to the <strong class="source-inline">itSubmitsExistingValue</strong> test-generator function and update it by inserting a new expectation at the bottom. Leave the existing expectation as it is (for now). Run the test and ensure the generated test fails. The code is illustrated in the following snippet:<p class="source-code">const itSubmitsExistingValue = (fieldName, value) =&gt;</p><p class="source-code">  it("saves existing value when submitted", () =&gt; {</p><p class="source-code">    const customer = { [fieldName]: value };</p><p class="source-code">    const submitSpy = spy();</p><p class="source-code">    render(</p><p class="source-code">      &lt;CustomerForm</p><p class="source-code">        original={customer}</p><p class="source-code">        onSubmit={submitSpy.fn}</p><p class="source-code">      /&gt;</p><p class="source-code">    );</p><p class="source-code">    click(submitButton());</p><p class="source-code">    expect(submitSpy).toBeCalledWith(customer);</p><p class="source-code">    <strong class="bold">expect(fetchSpy).toBeCalledWith(</strong></p><p class="source-code"><strong class="bold">      expect.anything(),</strong></p><p class="source-code"><strong class="bold">      expect.objectContaining({</strong></p><p class="source-code"><strong class="bold">        body: JSON.stringify(customer),</strong></p><p class="source-code"><strong class="bold">      })</strong></p><p class="source-code"><strong class="bold">    );</strong></p><p class="source-code">  });</p></li>
<li>To<a id="_idIndexMarker627"/> make <a id="_idIndexMarker628"/>that pass, update the <strong class="source-inline">handleSubmit</strong> function in your <strong class="source-inline">CustomerForm</strong> component, as shown in the following code snippet. After this change, your tests should pass:<p class="source-code">const handleSubmit = (event) =&gt; {</p><p class="source-code">  event.preventDefault();</p><p class="source-code">  global.fetch("/customers", {</p><p class="source-code">    method: "POST",</p><p class="source-code">    credentials: "same-origin",</p><p class="source-code">    headers: { "Content-Type": "application/json" },</p><p class="source-code"><strong class="bold">    body: JSON.stringify(original),</strong></p><p class="source-code">  });</p><p class="source-code">  onSubmit(customer);</p><p class="source-code">};</p></li>
<li>The final test reference to the <strong class="source-inline">onSubmit</strong> prop is the <strong class="source-inline">itSubmitsNewValue</strong> test generator. This test still uses the old <strong class="source-inline">expect.hasAssertions</strong> style; we’ll get round to deleting that later. For now, simply add in a new expectation at the bottom of<a id="_idIndexMarker629"/> the<a id="_idIndexMarker630"/> test, as shown here:<p class="source-code">const itSubmitsNewValue = (fieldName, value) =&gt;</p><p class="source-code">  it("saves new value when submitted", () =&gt; {</p><p class="source-code">    ...</p><p class="source-code">    <strong class="bold">expect(fetchSpy).toBeCalledWith(</strong></p><p class="source-code"><strong class="bold">      expect.anything(),</strong></p><p class="source-code"><strong class="bold">      expect.objectContaining({</strong></p><p class="source-code"><strong class="bold">        body: JSON.stringify({</strong></p><p class="source-code"><strong class="bold">          ...blankCustomer,</strong></p><p class="source-code"><strong class="bold">          [fieldName]: value,</strong></p><p class="source-code"><strong class="bold">        }),</strong></p><p class="source-code"><strong class="bold">      })</strong></p><p class="source-code"><strong class="bold">    );</strong></p><p class="source-code">  });</p></li>
<li>Run the test and verify that this test fails with a <strong class="source-inline">Spy was called with the wrong arguments: /customers,[object Object]</strong> failure message.</li>
<li>To make that pass, it’s a case of changing <strong class="source-inline">original</strong> to <strong class="source-inline">customer</strong> in your <strong class="source-inline">handleSubmit</strong> function, as follows:<p class="source-code">const handleSubmit = (event) =&gt; {</p><p class="source-code">  event.preventDefault();</p><p class="source-code">  global.fetch("/customers", {</p><p class="source-code">    method: "POST",</p><p class="source-code">    credentials: "same-origin",</p><p class="source-code">    headers: { "Content-Type": "application/json" },</p><p class="source-code">    body: JSON.stringify(<strong class="bold">customer</strong>),</p><p class="source-code">  });</p><p class="source-code">  onSubmit(customer);</p><p class="source-code">};</p></li>
<li>Your call to <strong class="source-inline">fetch</strong> is now complete, so you can remove the original implementation. Start<a id="_idIndexMarker631"/> by<a id="_idIndexMarker632"/> removing the <strong class="source-inline">onSubmit</strong> prop and the <strong class="source-inline">submitSpy</strong> variable from the <strong class="source-inline">itSubmitsExistingValue</strong> test generator. The new version looks like this:<p class="source-code">const itSubmitsExistingValue = (fieldName, value) =&gt;</p><p class="source-code">  it("saves existing value when submitted", () =&gt; {</p><p class="source-code">    const customer = { [fieldName]: value };</p><p class="source-code">    render(&lt;CustomerForm original={customer} /&gt;);</p><p class="source-code">    click(submitButton());</p><p class="source-code">    expect(fetchSpy).toBeCalledWith(</p><p class="source-code">      expect.anything(),</p><p class="source-code">      expect.objectContaining({</p><p class="source-code">        body: JSON.stringify(customer),</p><p class="source-code">      })</p><p class="source-code">    );</p><p class="source-code">  });</p></li>
<li>Do the same for <strong class="source-inline">itSubmitsNewValue</strong>—you can get rid of the <strong class="source-inline">hasAssertions</strong> call too. The new version looks like this:<p class="source-code">const itSubmitsNewValue = (fieldName, value) =&gt;</p><p class="source-code">  it("saves new value when submitted", () =&gt; {</p><p class="source-code">    render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">    change(field(fieldName), value);</p><p class="source-code">    click(submitButton());</p><p class="source-code">    expect(fetchSpy).toBeCalledWith(</p><p class="source-code">      expect.anything(),</p><p class="source-code">      expect.objectContaining({</p><p class="source-code">        body: JSON.stringify({</p><p class="source-code">          ...blankCustomer,</p><p class="source-code">          [fieldName]: value,</p><p class="source-code">        }),</p><p class="source-code">      })</p><p class="source-code">    );</p><p class="source-code">  });</p></li>
<li>Remove<a id="_idIndexMarker633"/> the call to <strong class="source-inline">onSubmit</strong> in the <strong class="source-inline">handleSubmit</strong> method.</li>
<li>Remove the <strong class="source-inline">onSubmit</strong> prop from the <strong class="source-inline">CustomerForm</strong> component definition. </li>
<li>Finally, remove the <strong class="source-inline">onSubmit</strong> prop from the <strong class="source-inline">prevents the default action...</strong> test.</li>
<li>Verify that all your tests are passing with <strong class="source-inline">npm test</strong>.</li>
</ol>
<p>You’ve now seen how you can continue your side-by-side implementation by reworking tests. Once all <a id="_idIndexMarker634"/>the tests <a id="_idIndexMarker635"/>are reworked, you can delete the original implementation.</p>
<p>Our tests have gotten pretty long-winded again. Let’s finish this section with a little cleanup.</p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor112"/>Improving spy expectations with helper functions</h2>
<p>When <a id="_idIndexMarker636"/>we’re <a id="_idIndexMarker637"/>writing <a id="_idIndexMarker638"/>expectations for our spies, we aren’t just limited to using the <strong class="source-inline">toBeCalledWith</strong> matcher. We<a id="_idIndexMarker639"/> can pull out arguments and give them names, and then use standard Jest matchers on them <a id="_idIndexMarker640"/>instead. This way, we can avoid all the ceremony <a id="_idIndexMarker641"/>with <strong class="source-inline">expect.anything</strong> and <strong class="source-inline">expect.objectContaining</strong>.</p>
<p>Let’s do that now. Proceed as follows:</p>
<ol>
<li value="1">Add a new helper function, <strong class="source-inline">bodyOfLastFetchRequest</strong>, at the top of <strong class="source-inline">CustomerForm</strong>, as follows:<p class="source-code">const bodyOfLastFetchRequest = () =&gt;</p><p class="source-code">  JSON.parse(fetchSpy.receivedArgument(1).body);</p></li>
<li>Update your <strong class="source-inline">itSubmitsExistingValue</strong> test generator to use this new helper to simplify its expectation. Note here the use of <strong class="source-inline">toMatchObject</strong>, which <a id="_idIndexMarker642"/>takes <a id="_idIndexMarker643"/>the <a id="_idIndexMarker644"/>place of <strong class="source-inline">expect.objectContaining</strong> in the previous version of this test:<p class="source-code">const itSubmitsExistingValue = (fieldName, value) =&gt;</p><p class="source-code">  it("saves existing value when submitted", () =&gt; {</p><p class="source-code">    const customer = { [fieldName]: value };</p><p class="source-code">    render(&lt;CustomerForm original={customer} /&gt;);</p><p class="source-code">    click(submitButton());</p><p class="source-code">    expect(bodyOfLastFetchRequest()).toMatchObject(</p><p class="source-code">      customer</p><p class="source-code">    );</p><p class="source-code">  });</p></li>
<li>Since you’ve modified your test, you should verify that it still tests the right thing: mark it<a id="_idIndexMarker645"/> as <strong class="source-inline">it.only</strong> and then delete the <strong class="source-inline">body</strong> property from the <strong class="source-inline">global.fetch</strong> call. Check the test fails, and then undo the change, getting you back to a passing test.</li>
<li>Repeat for<a id="_idIndexMarker646"/> the <strong class="source-inline">itSubmitsNewValue</strong> test helper, as shown here:<p class="source-code">const itSubmitsNewValue = (fieldName, value) =&gt;</p><p class="source-code">  it("saves new value when submitted", () =&gt; {</p><p class="source-code">    render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">    change(field(fieldName), value);</p><p class="source-code">    click(submitButton());</p><p class="source-code">    expect(bodyOfLastFetchRequest()).toMatchObject({</p><p class="source-code">      [fieldName]: value,</p><p class="source-code">    });</p><p class="source-code">  });</p></li>
</ol>
<p>These tests are now looking very smart!</p>
<p>This has been a complicated change: we’ve replaced the <strong class="source-inline">onSubmit</strong> prop with a call to <strong class="source-inline">global.fetch</strong>. We did that by introducing a global spy in the <strong class="source-inline">beforeEach</strong> block and writing<a id="_idIndexMarker647"/> a side-by-side implementation while <a id="_idIndexMarker648"/>we <a id="_idIndexMarker649"/>reworked <a id="_idIndexMarker650"/>our tests.</p>
<p>In the next part of this chapter, we’ll add to our knowledge of spies, turning them into stubs.</p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor113"/>Stubbing fetch responses</h1>
<p>As with <a id="_idIndexMarker651"/>many HTTP requests, our <strong class="source-inline">POST /customers</strong> endpoint returns data: it will return the customer object together with a newly generated identifier that the backend has chosen for us. Our application will make use of this by taking the new ID and sending it back to the parent component (although we won’t build this parent component until <a href="B18423_08.xhtml#_idTextAnchor147"><em class="italic">Chapter 8</em></a>, <em class="italic">Building an Application Component</em>).</p>
<p>To do that, we’ll create a new <strong class="source-inline">CustomerForm</strong> prop, <strong class="source-inline">onSave</strong>, which will be called with the result of the <strong class="source-inline">fetch</strong> call.</p>
<p>But hold on—didn’t we just remove an <strong class="source-inline">onSubmit</strong> prop? Yes, but this isn’t the same thing. The original <strong class="source-inline">onSubmit</strong> prop received the form values submitted by the user. This <strong class="source-inline">onSave</strong> prop is going to receive the customer object from the server after a successful save.</p>
<p>To write tests for this new <strong class="source-inline">onSave</strong> prop, we’ll need to provide a stub value for <strong class="source-inline">global.fetch</strong>, which essentially says, “This is the return value of calling the <strong class="source-inline">POST /customers</strong> endpoint with <strong class="source-inline">global.fetch.</strong>”</p>
<p class="callout-heading">What is a stub?</p>
<p class="callout">A <strong class="bold">stub</strong> is a<a id="_idIndexMarker652"/> test double that always returns the same value when it is invoked. You decide what this value is when you construct the stub.</p>
<p>In this section, we’ll upgrade our hand-crafted spy function so that it can also stub function return values. Then, we’ll use it to test the addition of the new <strong class="source-inline">onSave</strong> prop to <strong class="source-inline">CustomerForm</strong>. Finally, we’ll<a id="_idIndexMarker653"/> use it to display an error to the user if, for some reason, the server failed to save the new customer object.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor114"/>Upgrading spies to stubs</h2>
<p>A stub is <a id="_idIndexMarker654"/>different from a spy because it’s not<a id="_idIndexMarker655"/> interested<a id="_idIndexMarker656"/> in tracking the call history of the function being stubbed—it just cares about returning a single value.</p>
<p>However, it turns out that our existing tests that use spies will also need to stub values. That’s because as soon as we use the returned value in our production code, the spy must return something; otherwise, the test will break. So, all spies end up being stubs, too.</p>
<p>Since we already have a <strong class="source-inline">spy</strong> function, we can “upgrade” it so that it has the ability to stub values too. Here’s how we can do this:</p>
<ol>
<li value="1">In <strong class="source-inline">test/CustomerForm.test.js</strong>, change the <strong class="source-inline">spy</strong> function to include the following new variable declaration at the top. This variable will store the value, ready to be returned by our function:<p class="source-code">let returnValue;</p></li>
<li>Change the <strong class="source-inline">fn</strong> definition to the one shown here:<p class="source-code">fn: (...args) =&gt; {</p><p class="source-code">  receivedArguments = args;</p><p class="source-code">  return returnValue;</p><p class="source-code">},</p></li>
<li>Add this new function to your spy object, which sets the <strong class="source-inline">returnValue</strong> variable:<p class="source-code">stubReturnValue: value =&gt; returnValue = value</p></li>
</ol>
<p>It’s as simple<a id="_idIndexMarker657"/> as that: your function is now both<a id="_idIndexMarker658"/> a<a id="_idIndexMarker659"/> spy and a stub. Let’s make use of it in our tests.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor115"/>Acting on the fetch response</h2>
<p>So far, the <strong class="source-inline">handleSubmit</strong> function<a id="_idIndexMarker660"/> causes a <strong class="source-inline">fetch</strong> request to be made, but it doesn’t do anything with the response. In particular, it doesn’t <em class="italic">wait</em> for a response; the <strong class="source-inline">fetch</strong> API is asynchronous and returns a promise. Once that promise resolves, we can do something with the data that’s returned.</p>
<p>The next tests we’ll write will specify what our component should do with the resolved data.</p>
<h3>The asynchronous form of act</h3>
<p>When we’re<a id="_idIndexMarker661"/> dealing with promises in React callbacks, we need to use the asynchronous form of <strong class="source-inline">act</strong>. It looks like this:</p>
<pre class="source-code">
await act(async () =&gt; performAsyncAction());</pre>
<p>The <strong class="source-inline">performAsyncAction</strong> function doesn’t necessarily need to return a promise; <strong class="source-inline">act</strong> will wait for the browser’s <strong class="source-inline">async</strong> task queue to complete before it returns.</p>
<p>The action may be a button click, form submission, or any kind of input field event. It could also be a component render that has a <strong class="source-inline">useEffect</strong> hook that performs some asynchronous side effects, such as loading data.</p>
<h3>Adding async tasks to an existing component</h3>
<p>Now, we’ll use<a id="_idIndexMarker662"/> the asynchronous form of <strong class="source-inline">act</strong> to test that the <strong class="source-inline">fetch</strong> promise is awaited. Unfortunately, introducing <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> into our <strong class="source-inline">handleSubmit</strong> function will then require us to update all our submission tests to use the asynchronous form of <strong class="source-inline">act</strong>.</p>
<p>As usual, we start with the test. Proceed as follows:</p>
<ol>
<li value="1">Define a test helper function in <strong class="source-inline">test/CustomerForm.test.js</strong> that builds you a type of <strong class="source-inline">Response</strong> object to mimic what would be returned from the <strong class="source-inline">fetch</strong> API. That means it returns a <strong class="source-inline">Promise</strong> object with an <strong class="source-inline">ok</strong> property with a value of <strong class="source-inline">true</strong>, and a <strong class="source-inline">json</strong> function that returns another <strong class="source-inline">Promise</strong> that, when resolved, returns the JSON we pass in. You can define this just under your <strong class="source-inline">spy</strong> function, like so:<p class="source-code">const fetchResponseOk = (body) =&gt;</p><p class="source-code">  Promise.resolve({</p><p class="source-code">    ok: true,</p><p class="source-code">    json: () =&gt; Promise.resolve(body)</p><p class="source-code">  });</p></li>
</ol>
<p class="callout-heading">fetch return values</p>
<p class="callout">The <strong class="source-inline">ok</strong> property<a id="_idIndexMarker663"/> returns <strong class="source-inline">true</strong> if the HTTP response status code was in the <strong class="source-inline">2xx</strong> range. Any other kind of response, such as <strong class="source-inline">404</strong> or <strong class="source-inline">500</strong>, will cause <strong class="source-inline">ok</strong> to be <strong class="source-inline">false</strong>.</p>
<ol>
<li value="2">Add the following code to <strong class="source-inline">test/reactTestExtensions.js</strong>, just below the <a id="_idIndexMarker664"/>definition of <strong class="source-inline">click</strong>:<p class="source-code">export const clickAndWait = async (element) =&gt;</p><p class="source-code">  act(async () =&gt; click(element));</p></li>
<li>Now, import the new helper function into <strong class="source-inline">test/CustomerForm.test.js</strong>, as follows:<p class="source-code">import {</p><p class="source-code">  ...,</p><p class="source-code">  <strong class="bold">clickAndWait</strong>,</p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>Add the next test to the <strong class="source-inline">CustomerForm</strong> test suite, which checks that the <strong class="source-inline">onSave</strong> prop function is called when the user submits the form, and passes back the customer object. The best place for this test is under the <strong class="source-inline">calls fetch with correct configuration</strong> test. The <a id="_idIndexMarker665"/>code is illustrated in the following snippet:<p class="source-code">it("notifies onSave when form is submitted", async () =&gt; {</p><p class="source-code">  const customer = { id: 123 };</p><p class="source-code">  fetchSpy.stubReturnValue(fetchResponseOk(customer));</p><p class="source-code">  const saveSpy = spy();</p><p class="source-code">  render(</p><p class="source-code">    &lt;CustomerForm</p><p class="source-code">      original={customer}</p><p class="source-code">      onSave={saveSpy.fn}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  await clickAndWait(submitButton());</p><p class="source-code">  expect(saveSpy).toBeCalledWith(customer);</p><p class="source-code">});</p></li>
<li>To make this pass, start by defining a new <strong class="source-inline">onSave</strong> prop for <strong class="source-inline">CustomerForm</strong>, in <strong class="source-inline">src/CustomerForm.js</strong>, as follows:<p class="source-code">export const CustomerForm = ({</p><p class="source-code">  original<strong class="bold">, onSave</strong></p><p class="source-code">}) =&gt; {</p><p class="source-code">  ...</p><p class="source-code">};</p></li>
<li>Add the following code at the end of <strong class="source-inline">handleSubmit</strong>. The function is now declared <strong class="source-inline">async</strong> and <a id="_idIndexMarker666"/>uses <strong class="source-inline">await</strong> to unwrap the promise returned from <strong class="source-inline">global.fetch</strong>:<p class="source-code">const handleSubmit = <strong class="bold">async</strong> (event) =&gt; {</p><p class="source-code">  event.preventDefault();</p><p class="source-code">  <strong class="bold">const result = await </strong>global.fetch(...);</p><p class="source-code"><strong class="bold">  const customerWithId = await result.json();</strong></p><p class="source-code"><strong class="bold">  onSave(customerWithId);</strong></p><p class="source-code">};</p></li>
<li>If you run tests, you’ll notice that although your latest test passes, your previous test fails and there’s a whole bunch of unhandled promise exceptions. In fact, anything that submits the form will fail, because they use the <strong class="source-inline">fetchSpy</strong> variable that’s initialized in the <strong class="source-inline">beforeEach</strong> block, and this is not a stub—it’s just a plain old spy. Fix that now by giving the spy a return value, within <strong class="source-inline">beforeEach</strong>. In this case, we don’t need to give it a customer; an empty object will do, as illustrated in the following code snippet:<p class="source-code">beforeEach(() =&gt; {</p><p class="source-code">  ...</p><p class="source-code"><strong class="bold">  fetchSpy.stubReturnValue(fetchResponseOk({}));</strong></p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Dummy values in beforeEach blocks</p>
<p class="callout">When stubbing out global functions such as <strong class="source-inline">global.fetch</strong>, always set a default dummy value within your <strong class="source-inline">beforeEach</strong> block and then override it in individual tests that need specific stubbed values.</p>
<ol>
<li value="8">Run tests again. You might see some odd behavior at this point; I see my recent test supposedly run six times with failures! What’s happening is that our previous tests are now firing off a whole bunch of promises that continue running even when the tests end. Those asynchronous tasks cause Jest to incorrectly report failures. To<a id="_idIndexMarker667"/> solve this, we need to update all our tests to use <strong class="source-inline">await clickAndWait</strong>. In addition, the tests need <a id="_idIndexMarker668"/>to be marked as <strong class="source-inline">async</strong>. Do this now for every test that calls <strong class="source-inline">click</strong>. An example is shown here:<p class="source-code">it("sends HTTP request to POST /customers when submitting data", <strong class="bold">async</strong> () =&gt; {</p><p class="source-code">  render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">  <strong class="bold">await clickAndWait</strong>(submitButton());</p><p class="source-code">  ...</p><p class="source-code">});</p></li>
<li>Delete<a id="_idIndexMarker669"/> the <strong class="source-inline">click</strong> import, leaving <strong class="source-inline">clickAndWait</strong>.</li>
<li>There’s one more test that has this issue, and that’s the test that submits the form: <strong class="source-inline">prevents the default action when submitting the form</strong>. This test calls our <strong class="source-inline">submit</strong> helper function. We need to wrap that in <strong class="source-inline">act</strong>, too. Let’s create<a id="_idIndexMarker670"/> a <strong class="source-inline">submitAndWait</strong> helper function in our test extensions file. Add the following function just below <strong class="source-inline">submit</strong> to <strong class="source-inline">test/reactTestExtensions.js</strong>:<p class="source-code">export const submitAndWait = async (formElement) =&gt;</p><p class="source-code">  act(async () =&gt; submit(formElement));</p></li>
<li>Add <strong class="source-inline">submitAndWait</strong> into your <strong class="source-inline">import</strong> statements, just below <strong class="source-inline">clickAndWait</strong>, as follows:<p class="source-code">import {</p><p class="source-code">  ...,</p><p class="source-code"><strong class="bold">  submitAndWait,</strong></p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>Now, you can update the test to use the new helper function, like so:<p class="source-code">it("prevents the default action when submitting the form", <strong class="bold">async</strong> () =&gt; {</p><p class="source-code">  render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code"><strong class="bold">  const event = await submitAndWait</strong>(form());</p><p class="source-code">  expect(event.defaultPrevented).toBe(true);</p><p class="source-code">});</p></li>
<li>If you run tests <a id="_idIndexMarker671"/>again, we still have test failures (although thankfully, things look more orderly with the <strong class="source-inline">async</strong> tasks being properly accounted for). You’ll see that you now have a bunch of failures that say <strong class="source-inline">onSave is not a function</strong>. To fix that, we need to ensure we specify the <strong class="source-inline">onSave</strong> prop for every test that submits the form. A blank, no-op function will do. An example is shown here. Go ahead and add this prop to every test that submits the form. After this change, your tests should be passing without any warnings:<p class="source-code">it("calls fetch with correct configuration", async () =&gt; {</p><p class="source-code">  render(</p><p class="source-code">    &lt;CustomerForm</p><p class="source-code">      original={blankCustomer}</p><p class="source-code"><strong class="bold">      onSave={() =&gt; {}}</strong></p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  ...</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Introducing testProps objects when required props are added</p>
<p class="callout">The introduction of this <strong class="source-inline">onSave</strong> no-op function creates noise, which doesn’t help with the readability of our test. This would be a perfect opportunity to introduce a <strong class="source-inline">testProps</strong> object, as covered in <a href="B18423_05.xhtml#_idTextAnchor079"><em class="italic">Chapter 5</em></a>, <em class="italic">Adding Complex Form Interactions</em>.</p>
<ol>
<li value="14">Add another test to ensure that we do not call <strong class="source-inline">onSave</strong> when the <strong class="source-inline">fetch</strong> response has an error status (in other words, when the <strong class="source-inline">ok</strong> property is set to <strong class="source-inline">false</strong>). Start by defining another<a id="_idIndexMarker672"/> helper, <strong class="source-inline">fetchResponseError</strong>, right <a id="_idIndexMarker673"/>under <strong class="source-inline">fetchResponseOk</strong>, as<a id="_idIndexMarker674"/> illustrated in the following code snippet. This one doesn’t need a body as we aren’t interested in it just yet:<p class="source-code">const fetchResponseError = () =&gt;</p><p class="source-code">  Promise.resolve({ ok: false });</p></li>
<li>Use the new function in the next <strong class="source-inline">CustomerForm</strong> test, as follows:<p class="source-code">it("does not notify onSave if the POST request returns an error", async () =&gt; {</p><p class="source-code">  fetchSpy.stubReturnValue(fetchResponseError());</p><p class="source-code">  const saveSpy = spy();</p><p class="source-code">  render(</p><p class="source-code">    &lt;CustomerForm</p><p class="source-code">      original={blankCustomer}</p><p class="source-code">      onSave={saveSpy.fn}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  await clickAndWait(submitButton());</p><p class="source-code">  expect(saveSpy).not.toBeCalledWith();</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Negating toBeCalledWith</p>
<p class="callout">This expectation<a id="_idIndexMarker675"/> is not what we really want: this one would pass if we still called <strong class="source-inline">onSave</strong> but passed the wrong arguments—for example, if we wrote <strong class="source-inline">onSave(null)</strong>. What we really want is <strong class="source-inline">.not.toBeCalled()</strong>, which will fail if <strong class="source-inline">onSave</strong> is called in any form. But we haven’t built that matcher. Later in the chapter, we’ll fix this expectation by moving to Jest’s built-in spy function.</p>
<ol>
<li value="16">To make <a id="_idIndexMarker676"/>this pass, move the <strong class="source-inline">onSave</strong> call into a new conditional in <strong class="source-inline">handleSubmit</strong>, as follows:<p class="source-code">const handleSubmit = async (event) =&gt; {</p><p class="source-code">  ...</p><p class="source-code">  const result = ...;</p><p class="source-code"><strong class="bold">  if (result.ok) {</strong></p><p class="source-code">    const customerWithId = await result.json();</p><p class="source-code">    onSave(customerWithId);</p><p class="source-code">  <strong class="bold">}</strong></p><p class="source-code">};</p></li>
</ol>
<p>As you’ve seen, moving a component from synchronous to asynchronous behavior can really disrupt our test suites. The steps just outlined are fairly typical of the work needed when this happens.</p>
<p class="callout-heading">Async component actions can cause misreported Jest test failures</p>
<p class="callout">If you’re ever surprised to see a test fail and you’re at a loss to explain why it’s failing, double-check all the tests in the test suite to ensure that you’ve used the async form of <strong class="source-inline">act</strong> when it’s needed. Jest won’t warn you when a test finishes with async tasks still to run, and since your tests are using a shared DOM document, those async tasks will affect the results of subsequent tests.</p>
<p>Those are the <a id="_idIndexMarker677"/>basics of dealing with async behavior in tests. Now, let’s add a little detail to our implementation.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor116"/>Displaying errors to the user</h2>
<p>Let’s display an <a id="_idIndexMarker678"/>error to the user if the fetch returns <a id="_idIndexMarker679"/>an <strong class="source-inline">ok</strong> value of <strong class="source-inline">false</strong>. This would occur if the HTTP status code returned was in the <strong class="source-inline">4xx</strong> or <strong class="source-inline">5xx</strong> range, although for our tests we won’t need to worry about the specific status code. Follow these steps:</p>
<ol>
<li value="1">Add the following test to <strong class="source-inline">test/CustomerForm.test.js</strong>. This checks that an area is shown on the page for <a id="_idIndexMarker680"/>errors. It relies on the ARIA role <a id="_idIndexMarker681"/>of <strong class="source-inline">alert</strong>, which is a special signifier <a id="_idIndexMarker682"/>for screen readers that this area could change to hold important information:<p class="source-code">it("renders an alert space", async () =&gt; {</p><p class="source-code">  render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">  expect(element("[role=alert]")).not.toBeNull();</p><p class="source-code">});</p></li>
<li>To make that pass, first, define a new <strong class="source-inline">Error</strong> component, as follows. This can live in <strong class="source-inline">src/CustomerForm.js</strong>, just above the <strong class="source-inline">CustomerForm</strong> component itself:<p class="source-code">const Error = () =&gt; (</p><p class="source-code">  &lt;p role="alert" /&gt;</p><p class="source-code">);</p></li>
<li>Then, add an instance of that component into the <strong class="source-inline">CustomerForm</strong>’s JSX, just at the top of the <strong class="source-inline">form</strong> element, as follows:<p class="source-code">&lt;form&gt;</p><p class="source-code"><strong class="bold">  &lt;Error /&gt;</strong></p><p class="source-code">  ...</p><p class="source-code">&lt;/form&gt;</p></li>
<li>Back in <strong class="source-inline">test/CustomerForm.test.js</strong>, add the next test, which checks the<a id="_idIndexMarker683"/> error<a id="_idIndexMarker684"/> message in the alert, as follows:<p class="source-code">it("renders error message when fetch call fails", async () =&gt; {</p><p class="source-code">  fetchSpy.mockReturnValue(fetchResponseError());</p><p class="source-code">  render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">  await clickAndWait(submitButton());</p><p class="source-code">  expect(element("[role=alert]")).toContainText(</p><p class="source-code">    "error occurred"</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>To make that pass, all we need to do is hardcode the string in the <strong class="source-inline">Error</strong> component. We’ll use another test to triangulate to get to the real implementation, as follows:<p class="source-code">const Error = () =&gt; (</p><p class="source-code">  &lt;p role="alert"&gt;</p><p class="source-code"><strong class="bold">    An error occurred during save.</strong></p><p class="source-code">  &lt;/p&gt;</p><p class="source-code">);</p></li>
<li>Add the final test to <strong class="source-inline">test/CustomerForm.test.js</strong>, like so:<p class="source-code">it("initially hano text in the alert space", async () =&gt; {</p><p class="source-code">  render(&lt;CustomerForm original={blankCustomer} /&gt;);</p><p class="source-code">  expect(element("[role=alert]")).not.toContainText(</p><p class="source-code">    "error occurred"</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>To make<a id="_idIndexMarker685"/> this pass, introduce a new <strong class="source-inline">error</strong> state<a id="_idIndexMarker686"/> variable at the top of the <strong class="source-inline">CustomerForm</strong> definition, like so:<p class="source-code">const [error, setError] = useState(false);</p></li>
<li>Change the <strong class="source-inline">handleSubmit</strong> function, as follows:<p class="source-code">const handleSubmit = async (event) =&gt; {</p><p class="source-code">  ...</p><p class="source-code">  if (result.ok) {</p><p class="source-code">    ...</p><p class="source-code">  }<strong class="bold"> else {</strong></p><p class="source-code"><strong class="bold">    setError(true);</strong></p><p class="source-code"><strong class="bold">  }</strong></p><p class="source-code">}</p></li>
<li>In the component’s JSX, update the <strong class="source-inline">Error</strong> instance to include a new <strong class="source-inline">hasError</strong> prop and set it to the <strong class="source-inline">error</strong> state, like so:<p class="source-code">&lt;form&gt;</p><p class="source-code">  &lt;Error <strong class="bold">hasError={error}</strong> /&gt;</p><p class="source-code">  ...</p><p class="source-code">&lt;/form&gt;</p></li>
<li>All that remains is to complete the <strong class="source-inline">Error</strong> component with the new prop, as follows:<p class="source-code">const Error = (<strong class="bold">{ hasError }</strong>) =&gt; (</p><p class="source-code">  &lt;p role="alert"&gt;</p><p class="source-code">    <strong class="bold">{hasError ? "An error occurred during save." : ""}</strong></p><p class="source-code">  &lt;/p&gt;</p><p class="source-code">); </p></li>
</ol>
<p>That’s it <a id="_idIndexMarker687"/>for<a id="_idIndexMarker688"/> our <strong class="source-inline">CustomerForm</strong> implementation. Time for a little cleanup of our tests.</p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor117"/>Grouping stub scenarios in nested describe contexts</h2>
<p>A common <a id="_idIndexMarker689"/>practice<a id="_idIndexMarker690"/> is to <a id="_idIndexMarker691"/>use nested <strong class="source-inline">describe</strong> blocks to set up stub values as scenarios for a group of tests. We have just written four tests that deal with the scenario of the <strong class="source-inline">POST /customers</strong> endpoint returning an error. Two of these are good candidates for a nested <strong class="source-inline">describe</strong> context.</p>
<p>We can then pull up the stub value into a <strong class="source-inline">beforeEach</strong> block. Let’s start with the <strong class="source-inline">describe</strong> block. Follow these steps:</p>
<ol>
<li value="1">Look at the last four tests you’ve written. Two of them are about the alert space and are not related to the error case. Leave those two in place, and move the other two into a new <strong class="source-inline">describe</strong> block named <strong class="source-inline">when POST requests return an error</strong>, as shown here:<p class="source-code">it("renders an alert space", ...)</p><p class="source-code">it("initially has no text in the alert space", ...)</p><p class="source-code"><strong class="bold">describe("when POST request returns an error", () =&gt; {</strong></p><p class="source-code">  it("does not notify onSave if the POST request returns an error", ...)</p><p class="source-code">  it("renders error message when fetch call fails", ...)</p><p class="source-code"><strong class="bold">});</strong></p></li>
<li>Notice how the two of the test descriptions repeat themselves, saying the same thing as the <strong class="source-inline">describe</strong> block but in slightly different ways? Remove the <strong class="source-inline">if</strong>/<strong class="source-inline">when</strong> statements<a id="_idIndexMarker692"/> from <a id="_idIndexMarker693"/>the<a id="_idIndexMarker694"/> two test descriptions, as follows:<p class="source-code">describe("when POST request returns an error", () =&gt; {</p><p class="source-code">  it("does not notify onSave", ...)</p><p class="source-code">  it("renders error message ", ...)</p><p class="source-code">});</p></li>
<li>The two tests have identical <strong class="source-inline">global.fetch</strong> stubs. Pull that stub up into a new <strong class="source-inline">beforeEach</strong> block, as<a id="_idIndexMarker695"/> shown here:<p class="source-code">describe("when POST request returns an error", () =&gt; {</p><p class="source-code"> <strong class="bold"> beforeEach(() =&gt; {</strong></p><p class="source-code"><strong class="bold">    fetchSpy.stubReturnValue(fetchResponseError());</strong></p><p class="source-code"><strong class="bold">  });</strong></p><p class="source-code">  ...</p><p class="source-code">})</p></li>
<li>Finally, delete the stub call from the two tests, leaving just the stub call in the <strong class="source-inline">beforeEach</strong> block.</li>
</ol>
<p>You’ve now seen how to use nested <strong class="source-inline">describe</strong> blocks to describe specific test scenarios, and that covers all the basic stubbing techniques. In the next section, we’ll continue our<a id="_idIndexMarker696"/> cleanup <a id="_idIndexMarker697"/>by<a id="_idIndexMarker698"/> introducing Jest’s own spy and stub functions, which are slightly simpler than the ones we’ve built ourselves.  </p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor118"/>Migrating to Jest’s built-in test double support</h1>
<p>So far in this <a id="_idIndexMarker699"/>chapter, you’ve built your own hand-crafted spy function, with support for stubbing values and with its own matcher. The purpose of that has been to teach you how test doubles work and to show the essential set of spy and stub patterns that you’ll use in your component tests.</p>
<p>However, our spy function <a id="_idIndexMarker700"/>and the <strong class="source-inline">toBeCalledWith</strong> matcher are far from complete. Rather than investing any more time in our hand-crafted versions, it makes sense to switch to Jest’s own functions now. These work in essentially the same way as our <strong class="source-inline">spy</strong> function but have a couple of subtle differences.</p>
<p>This section starts with a rundown of Jest’s test double functionality. Then, we’ll migrate the <strong class="source-inline">CustomerForm</strong> test suite away from our hand-crafted spy function. Finally, we’ll do a little more cleanup by extracting more test helpers.</p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor119"/>Using Jest to spy and stub</h2>
<p>Here’s<a id="_idIndexMarker701"/> a <a id="_idIndexMarker702"/>rundown<a id="_idIndexMarker703"/> of Jest test double<a id="_idIndexMarker704"/> support:</p>
<ul>
<li>To create a new spy function, call <strong class="source-inline">jest.fn()</strong>. For example, you might write <strong class="source-inline">const fetchSpy = jest.fn()</strong>.</li>
<li>To override an existing<a id="_idIndexMarker705"/> property, call <strong class="source-inline">jest.spyOn(object, property)</strong>. For example, you might write <strong class="source-inline">jest.spyOn(global, "fetch")</strong>.</li>
<li>To set a return value, call <strong class="source-inline">spy.mockReturnValue()</strong>. You can also pass this value directly to the <strong class="source-inline">jest.fn()</strong> call.</li>
<li>You can set multiple return values by chaining calls to <strong class="source-inline">spy.mockReturnValueOnce()</strong>.</li>
<li>When your<a id="_idIndexMarker706"/> function returns promises, you can use <strong class="source-inline">spy.mockResolvedValue()</strong> and <strong class="source-inline">spy.mockRejectedValue()</strong>.</li>
<li>To check that your spy was called, use <strong class="source-inline">expect(spy).toBeCalled()</strong>.</li>
<li>To check the arguments passed to your spy, you can use <strong class="source-inline">expect(spy).toBeCalledWith(arguments)</strong>. Or, if your spy is called multiple<a id="_idIndexMarker707"/> times and you want to check the last time it was called, you can use <strong class="source-inline">expect(spy).toHaveLastBeenCalledWith(arguments)</strong>.</li>
<li>Calling <strong class="source-inline">spy.mockReset()</strong> removes all mocked implementations, return values, and existing call history from a spy.</li>
<li>Calling <strong class="source-inline">spy.mockRestore()</strong> will remove the mock and give you back the original implementation.</li>
<li>In Jest’s <a id="_idIndexMarker708"/>configuration section of your <strong class="source-inline">package.json</strong> file, you can set <strong class="source-inline">restoreMocks</strong> to <strong class="source-inline">true</strong> and all spies that were created with <strong class="source-inline">jest.spyOn</strong> will be automatically restored after each test.</li>
<li>When<a id="_idIndexMarker709"/> using <strong class="source-inline">toBeCalledWith</strong>, you can pass an argument value of <strong class="source-inline">expect.anything()</strong> to say that<a id="_idIndexMarker710"/> you don’t care what the value of that argument is.</li>
<li>You can use <strong class="source-inline">expect.objectMatching(object)</strong> to check that an argument has all the properties of the object you pass in, rather than being exactly equal to the object.</li>
<li>When your spy is called multiple times, you can check the parameters passed to specific calls by using <strong class="source-inline">spy.mock.calls[n]</strong>, where <strong class="source-inline">n</strong> is the call number (for example, <strong class="source-inline">calls[0]</strong> will return the arguments for the first time it was called).</li>
<li>If you need to perform complex matching on a specific argument, you can use <strong class="source-inline">spy.mock.calls[0][n]</strong>, where <strong class="source-inline">n</strong> is in the argument number.</li>
<li>You can stub out and spy on entire modules using the <strong class="source-inline">jest.mock()</strong> function, which we’ll look at in the next chapter.</li>
</ul>
<p>There’s a lot<a id="_idIndexMarker711"/> more<a id="_idIndexMarker712"/> available <a id="_idIndexMarker713"/>with the Jest API, but these are the core<a id="_idIndexMarker714"/> features and should cover most of your test-driven use cases.</p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor120"/>Migrating the test suite to use Jest’s test double support</h2>
<p>Let’s <a id="_idIndexMarker715"/>convert our <strong class="source-inline">CustomerForm</strong> tests <a id="_idIndexMarker716"/>away from our hand-crafted spy function. We’ll start with the <strong class="source-inline">fetchSpy</strong> variable.</p>
<p>We’ll <a id="_idIndexMarker717"/>use <strong class="source-inline">jest.spyOn</strong> for this. It essentially creates a spy with <strong class="source-inline">jest.fn()</strong> and then <a id="_idIndexMarker718"/>assigns it to the <strong class="source-inline">global.fetch</strong> variable. The <strong class="source-inline">jest.spyOn</strong> function keeps track of every object that has been spied on so that it can auto-restore them without our intervention, using the <strong class="source-inline">restoreMock</strong> configuration property.</p>
<p>It also has a feature that blocks us from spying on any property that isn’t already a function. That will affect us because Node.js doesn’t have a default implementation of <strong class="source-inline">global.fetch</strong>. We’ll see how to solve that issue in the next set of steps.</p>
<p>It’s worth pointing out a really great feature of <strong class="source-inline">jest.fn()</strong>. The returned spy object acts as both the function itself and the mock object. It does this by attaching a special <strong class="source-inline">mock</strong> property to the returned function. The upshot of this is that we no longer need a <strong class="source-inline">fetchSpy</strong> variable to store our spy<a id="_idIndexMarker719"/> object. We can just refer to <strong class="source-inline">global.fetch</strong> directly, as we’re about to see.</p>
<p>Follow these steps:</p>
<ol>
<li value="1">Update the <strong class="source-inline">beforeEach</strong> block to read<a id="_idIndexMarker720"/> as follows. This uses <strong class="source-inline">mockResolvedValue</strong> to<a id="_idIndexMarker721"/> set a return value wrapped in<a id="_idIndexMarker722"/> a promise (as opposed to <strong class="source-inline">mockReturnedValue</strong>, which <a id="_idIndexMarker723"/>just <a id="_idIndexMarker724"/>returns a value with no promise involved):<p class="source-code">beforeEach(() =&gt; {</p><p class="source-code">  initializeReactContainer();</p><p class="source-code"><strong class="bold">  jest</strong></p><p class="source-code"><strong class="bold">    .spyOn(global, "fetch")</strong></p><p class="source-code"><strong class="bold">    .mockResolvedValue(fetchResponseOk({}));</strong></p><p class="source-code">});</p></li>
<li>There are two lines in the <strong class="source-inline">CustomerForm</strong> test suite that follow the pattern shown here:<p class="source-code">fetchSpy.stubResolvedValue(...);</p></li>
</ol>
<p>Go ahead and replace them with the following code:</p>
<p class="source-code"><strong class="bold">global.fetch.mock</strong>ResolvedValue(...);</p>
<ol>
<li value="3">There are two expectations that check <strong class="source-inline">fetchSpy</strong>. Go ahead and replace <strong class="source-inline">expect(fetchSpy)</strong> with <strong class="source-inline">expect(global.fetch)</strong>. Removing the <strong class="source-inline">fetchSpy</strong> variable gives you greater readability and understanding of what’s happening. Here’s one of the expectations:<p class="source-code">expect(global.fetch).toBeCalledWith(</p><p class="source-code">  "/customers",</p><p class="source-code">  expect.objectContaining({</p><p class="source-code">    method: "POST",</p><p class="source-code">  })</p><p class="source-code">);</p></li>
<li>The <strong class="source-inline">bodyOflastFetchRequest</strong> function needs to be updated to use the <strong class="source-inline">mock</strong> property of the Jest spy object. Update it to read as follows:<p class="source-code">const bodyOfLastFetchRequest = () =&gt; <strong class="bold">{</strong></p><p class="source-code"><strong class="bold">  const allCalls = global.fetch.mock.calls;</strong></p><p class="source-code"><strong class="bold">  const lastCall = allCalls[allCalls.length - 1];</strong></p><p class="source-code"><strong class="bold">  return JSON.parse(lastCall[1].body);</strong></p><p class="source-code"><strong class="bold">};</strong></p></li>
<li>Open <strong class="source-inline">package.json</strong> and<a id="_idIndexMarker725"/> add <a id="_idIndexMarker726"/>the <strong class="source-inline">restoreMocks</strong> property, which <a id="_idIndexMarker727"/>ensures the <strong class="source-inline">global.fetch</strong> spy is reset to its original setting after each test. The code is illustrated in the following snippet:<p class="source-code">"jest": {</p><p class="source-code">  ...<strong class="bold">,</strong></p><p class="source-code"><strong class="bold">  "restoreMocks": true</strong></p><p class="source-code">}</p></li>
<li>That should be it for your <strong class="source-inline">global.fetch</strong> spy. You can delete the <strong class="source-inline">afterEach</strong> block, the <strong class="source-inline">fetchSpy</strong> variable declaration, and the <strong class="source-inline">originalFetch</strong> constant definition.</li>
<li>Let’s move on to <strong class="source-inline">saveSpy</strong>. Back in your <strong class="source-inline">CustomerForm</strong> test suite, find the <strong class="source-inline">notifies onSave when form it submitted</strong> test. Update it as shown in the following code snippet. We’re replacing the use of <strong class="source-inline">spy()</strong> with <strong class="source-inline">jest.fn()</strong>. Notice how we no longer need to set the <strong class="source-inline">onSave</strong> prop to <strong class="source-inline">saveSpy.fn</strong> but just <strong class="source-inline">saveSpy</strong> itself:<p class="source-code">it("notifies onSave when form is submitted", async () =&gt; {</p><p class="source-code">  const customer = { id: 123 };</p><p class="source-code">  global.fetch.mockResolvedValue(</p><p class="source-code">    fetchResponseOk(customer)</p><p class="source-code">  );</p><p class="source-code">  const saveSpy = <strong class="bold">jest.fn</strong>();</p><p class="source-code">  render(</p><p class="source-code">    &lt;CustomerForm</p><p class="source-code">      original={blankCustomer}</p><p class="source-code">      onSave={<strong class="bold">saveSpy</strong>}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  await clickAndWait(submitButton());</p><p class="source-code">  expect(saveSpy).toBeCalledWith(customer);</p><p class="source-code">});</p></li>
<li>Repeat<a id="_idIndexMarker728"/> for the <strong class="source-inline">does not notify onSave if the POST request returns an error</strong> test.</li>
<li>Delete your <strong class="source-inline">spy</strong> function definition at the top of the test suite.</li>
<li>Delete<a id="_idIndexMarker729"/> your <strong class="source-inline">toBeCalledWith</strong> matcher in <strong class="source-inline">test/domMatchers.js</strong>.</li>
<li>We’re now close to a working test suite. Try running your tests—you’ll see the following error:<p class="source-code">Cannot spy the fetch property because it is not a function; undefined given instead</p></li>
<li>To fix this, we need to let Jest think that <strong class="source-inline">global.fetch</strong> is indeed a function. The simplest way to do this is to set a dummy implementation when your test suite launches. Create a <strong class="source-inline">test/globals.js</strong> file and add the following definition to it:<p class="source-code">global.fetch = () =&gt; Promise.resolve({});</p></li>
<li>Now, back in <strong class="source-inline">package.json</strong>, add that<a id="_idIndexMarker730"/> file<a id="_idIndexMarker731"/> to<a id="_idIndexMarker732"/> the <strong class="source-inline">setupFilesAfterEnv</strong> property, like so:<p class="source-code">"setupFilesAfterEnv": [</p><p class="source-code">  "./test/domMatchers.js"<strong class="bold">,</strong></p><p class="source-code"><strong class="bold">  "./test/globals.js"</strong></p><p class="source-code">],</p></li>
<li>Run all tests with <strong class="source-inline">npm test</strong>. They should be passing.</li>
<li>There’s just one final cleanup to do. Find the following expectation:<p class="source-code">expect(saveSpy).not.toBeCalledWith();</p></li>
</ol>
<p>As mentioned earlier in the chapter, this expectation is not correct, and we only used it because our hand-rolled matcher didn’t fully support this use case. What we want is for the expectation to fail if <strong class="source-inline">onSave</strong> is called in any form. Now that we’re using Jest’s own matchers, we can solve this more elegantly. Replace this expectation with the following code:</p>
<p class="source-code">expect(saveSpy).not.toBeCalled();</p>
<p>Your <strong class="source-inline">CustomerForm</strong> test <a id="_idIndexMarker733"/>suite is now fully <a id="_idIndexMarker734"/>migrated. We’ll end this chapter by extracting some more helpers.</p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor121"/>Extracting fetch test functionality</h2>
<p><strong class="source-inline">CustomerForm</strong> is not the <a id="_idIndexMarker735"/>only component <a id="_idIndexMarker736"/>that will call <strong class="source-inline">fetch</strong>: one of the exercises is to update <strong class="source-inline">AppointmentForm</strong> to also submit appointments to the server. It makes sense to reuse the common code we’ve used by pulling it out into its own module. Proceed as follows:</p>
<ol>
<li value="1">Create a file named <strong class="source-inline">test/spyHelpers.js</strong> and add the following function definition, which is the same as the function in your test suite, except this time it’s marked as an export:<p class="source-code">export const bodyOfLastFetchRequest = () =&gt; {</p><p class="source-code">  const allCalls = global.fetch.mock.calls;</p><p class="source-code">  const lastCall = allCalls[allCalls.length - 1];</p><p class="source-code">  return JSON.parse(lastCall[1].body);</p><p class="source-code">};</p></li>
<li>Create a file named <strong class="source-inline">test/builders/fetch.js</strong> and add the following two functions to it:<p class="source-code">export const fetchResponseOk = (body) =&gt;</p><p class="source-code">  Promise.resolve({</p><p class="source-code">    ok: true,</p><p class="source-code">    json: () =&gt; Promise.resolve(body),</p><p class="source-code">  });</p><p class="source-code">export const fetchResponseError = () =&gt;</p><p class="source-code">  Promise.resolve({ ok: false });</p></li>
<li>Delete those definitions from within <strong class="source-inline">test/CustomerForm.test.js</strong> and replace them with an <strong class="source-inline">import</strong> statement, as illustrated in the following code snippet. After this change, run your tests and check they are still passing:<p class="source-code">import { bodyOfLastFetchRequest } from "./spyHelpers";</p><p class="source-code">import {</p><p class="source-code">  fetchResponseOk,</p><p class="source-code">  fetchResponseError,</p><p class="source-code">} from "./builders/fetch";</p></li>
<li>Finally, we<a id="_idIndexMarker737"/> can<a id="_idIndexMarker738"/> simplify <strong class="source-inline">fetchResponseOk</strong> and <strong class="source-inline">fetchResponseError</strong> by <a id="_idIndexMarker739"/>removing the call to <strong class="source-inline">Promise.resolve</strong> shown here. That’s because<a id="_idIndexMarker740"/> Jest’s <strong class="source-inline">mockResolvedValue</strong> function<a id="_idIndexMarker741"/> will automatically wrap the value in a promise:<p class="source-code">export const fetchResponseOk = (body) =&gt; ({</p><p class="source-code">  ok: true,</p><p class="source-code">  json: () =&gt; Promise.resolve(body),</p><p class="source-code">});</p><p class="source-code">export const fetchResponseError = () =&gt; ({</p><p class="source-code">  ok: false,</p><p class="source-code">});</p></li>
<li>Ensure<a id="_idIndexMarker742"/> you’ve run<a id="_idIndexMarker743"/> all tests and you’re on green before continuing.</li>
</ol>
<p>You’re now ready to reuse these functions in the <strong class="source-inline">AppointmentForm</strong> test suite.</p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor122"/>Summary</h1>
<p>We’ve just explored test doubles and how they are used to verify interactions with collaborating objects, such as component props (<strong class="source-inline">onSave</strong>) and browser API functions (<strong class="source-inline">global.fetch</strong>). We looked in detail at spies and stubs, the two main types of doubles you’ll use. You also saw how to use a side-by-side implementation as a technique to keep your test failures under control while you switch from one implementation to another.</p>
<p>Although this chapter covered the primary patterns you’ll use when dealing with test doubles, we have one major one still to cover, and that’s how to spy on and stub out React components. That’s what we’ll look at in the next chapter.</p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor123"/>Exercises</h1>
<p>Try the following exercises:</p>
<ol>
<li value="1">Add a test to the <strong class="source-inline">CustomerForm</strong> test suite to specify that the error state is cleared when the form is submitted a second time with all validation errors corrected.</li>
<li>Update the <strong class="source-inline">AppointmentForm</strong> test suite to use <strong class="source-inline">jest.fn()</strong> and <strong class="source-inline">jest.spyOn()</strong>.</li>
<li>Extend <strong class="source-inline">AppointmentForm</strong> so that it submits an appointment using a <strong class="source-inline">POST</strong> request to <strong class="source-inline">/appointments</strong>. The <strong class="source-inline">/appointments</strong> endpoint returns a <strong class="source-inline">201 Created</strong> response without a body, so you don’t need to call <strong class="source-inline">json</strong> on the response object or send back any parameters to <strong class="source-inline">onSave</strong>. </li>
</ol>
<h1 id="_idParaDest-126"><a id="_idTextAnchor124"/>Further reading</h1>
<p>For more information, refer to the following sources:</p>
<ul>
<li>A cheat sheet showing all the Jest mocking constructs you’ll need for testing React code bases</li>
</ul>
<p><a href="https://reacttdd.com/mocking-cheatsheet">https://reacttdd.com/mocking-cheatsheet</a></p>
<ul>
<li>A good introduction to the different kinds of test doubles</li>
</ul>
<p><a href="https://martinfowler.com/articles/mocksArentStubs.xhtml">https://martinfowler.com/articles/mocksArentStubs.xhtml</a></p>
<ul>
<li>An introduction to using the Fetch API</li>
</ul>
<p><a href="https://github.github.io/fetch">https://github.github.io/fetch</a></p>
<ul>
<li>Information on the ARIA alert role: <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/alert_role">https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/alert_role</a></li>
</ul>
</div>
<div>
<div id="_idContainer022">
</div>
</div>
</div></body></html>