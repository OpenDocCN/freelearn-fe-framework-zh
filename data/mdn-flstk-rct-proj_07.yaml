- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Deploying the Application with Docker and CI/CD
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 和 CI/CD 部署应用程序
- en: Now that we have successfully developed our first full-stack application with
    a backend service and a frontend, we are going to package our app into Docker
    images and learn how to deploy them using **continuous integration** (**CI**)
    and **continuous delivery** (**CD**) principles. We have already learned how to
    start Docker containers in [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028), *Getting
    to Know Node.js and MongoDB*. In this chapter, we will learn how to create our
    own Docker images to instantiate containers from. Then, we are going to manually
    deploy our application to a cloud provider. Finally, we are going to configure
    CI/CD to automate the deployment of our application. At the end of this chapter,
    we will have successfully deployed our first full-stack **MongoDB Express React
    Node.js** (**MERN**) application, and set it up for future automated deployments!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功开发了一个包含后端服务和前端的全栈应用程序，我们将把我们的应用程序打包成 Docker 镜像，并学习如何使用**持续集成**（**CI**）和**持续交付**（**CD**）原则来部署它们。我们已经学习了如何在[*第
    2 章*](B19385_02.xhtml#_idTextAnchor028)“了解 Node.js 和 MongoDB”中启动 Docker 容器。在本章中，我们将学习如何创建自己的
    Docker 镜像以实例化容器。然后，我们将手动将我们的应用程序部署到云服务提供商。最后，我们将配置 CI/CD 以自动化应用程序的部署。在本章结束时，我们将成功部署我们的第一个全栈**MongoDB
    Express React Node.js**（**MERN**）应用程序，并为其设置未来的自动化部署！
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Creating Docker images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Docker 镜像
- en: Deploying our full-stack application to the cloud
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的全栈应用程序部署到云端
- en: Configuring CI to automate testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 CI 以自动化测试
- en: Configuring CD to automate the deployment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 CD 以自动化部署
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before we start, please install all requirements from [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016),
    *Preparing For Full-Stack Development*, and [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028),
    *Getting to Know Node.js* *and MongoDB*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请从[*第 1 章*](B19385_01.xhtml#_idTextAnchor016)“为全栈开发做准备”和[*第 2 章*](B19385_02.xhtml#_idTextAnchor028)“了解
    Node.js 和 MongoDB”中安装所有要求。
- en: The versions listed in those chapters are the ones used in the book. While installing
    a newer version should not be an issue, please note that certain steps might work
    differently on a newer version. If you are having an issue with the code and steps
    provided in this book, please try using the versions mentioned in [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016)
    and [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那些章节中列出的版本是书中使用的版本。虽然安装较新版本不应有问题，但请注意，某些步骤在较新版本上可能工作方式不同。如果您在使用本书中提供的代码和步骤时遇到问题，请尝试使用[*第
    1 章*](B19385_01.xhtml#_idTextAnchor016)和[*第 2 章*](B19385_02.xhtml#_idTextAnchor028)中提到的版本。
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch5](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch5).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章节的代码：[https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch5](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch5)。
- en: 'The CiA video for this chapter can be found at: [https://youtu.be/aQplfCQGWew](https://youtu.be/aQplfCQGWew)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的 CiA 视频可以在以下网址找到：[https://youtu.be/aQplfCQGWew](https://youtu.be/aQplfCQGWew)
- en: Creating Docker images
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Docker 镜像
- en: In [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028), *Getting to Know Node.js
    and MongoDB*, we learned that in the Docker platform, we use Docker images to
    create containers, which can then run services. We have already learned how to
    use the existing `mongo` image to create a container for our database service.
    In this section, we are going to learn how to create our own image to instantiate
    a container from. To do so, we first need to create a **Dockerfile**, which contains
    all the instructions needed to build the Docker image. First, we will create a
    Docker image for our backend service and run a container from it. Then, we will
    do the same for our frontend. Finally, we will create a **Docker Compose file**
    to start our database and backend services together with our frontend.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 2 章*](B19385_02.xhtml#_idTextAnchor028)“了解 Node.js 和 MongoDB”中，我们了解到在 Docker
    平台上，我们使用 Docker 镜像来创建容器，然后可以运行服务。我们已经学习了如何使用现有的 `mongo` 镜像来创建数据库服务的容器。在本节中，我们将学习如何创建自己的镜像以实例化容器。为此，我们首先需要创建一个**Dockerfile**，它包含构建
    Docker 镜像所需的所有指令。首先，我们将为我们的后端服务创建一个 Docker 镜像并从中运行一个容器。然后，我们将对前端执行相同的操作。最后，我们将创建一个**Docker
    Compose 文件**，以启动我们的数据库和后端服务以及前端服务。
- en: Creating the backend Dockerfile
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建后端 Dockerfile
- en: 'A Dockerfile tells Docker step by step how to build the image. Each line in
    the file is an instruction telling Docker what to do. The format of a Dockerfile
    is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile告诉Docker如何逐步构建镜像。文件中的每一行都是一个指令，告诉Docker要做什么。Dockerfile的格式如下：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Every Dockerfile must begin with a `FROM` instruction, which specifies which
    image the newly created image should be based on. You can extend your image from
    existing images, such as `ubuntu` or `node`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Dockerfile都必须以一个`FROM`指令开始，该指令指定了新创建的镜像应该基于哪个镜像。你可以从现有的镜像扩展你的镜像，例如`ubuntu`或`node`。
- en: 'Let’s get started by creating the Dockerfile for our backend service:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建我们后端服务的Dockerfile：
- en: 'Copy the **ch4** folder to a new **ch5** folder, as follows:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**ch4**文件夹复制到一个新的**ch5**文件夹，如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Create a new **backend/Dockerfile** file inside the **ch5** folder.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**ch5**文件夹内创建一个新的**backend/Dockerfile**文件。
- en: 'In this file, we first define a base image for our image, which will be version
    20 of the **node** image:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件中，我们首先定义了我们镜像的基础镜像，它将是**node**镜像的版本20：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This image is provided by Docker Hub, similar to the `ubuntu` and `mongo` images
    we created containers from before.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该镜像由Docker Hub提供，类似于我们之前创建容器时使用的`ubuntu`和`mongo`镜像。
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: Be careful to only use official images and images created by trusted authors.
    The **node** image, for example, is officially maintained by the Node.js team.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，只使用官方镜像和由可信作者创建的镜像。例如，**node**镜像由Node.js团队官方维护。
- en: 'Then, we set the working directory, which is where all files of our service
    will be placed inside the image:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们设置工作目录，这是我们服务中所有文件在镜像内部放置的位置：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `WORKDIR` instruction is similar to using `cd` in the terminal. It changes
    the working directory so that we do not have to prefix all the following commands
    with the full path. Docker creates the folder for us if it does not exist yet.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`WORKDIR`指令类似于在终端中使用`cd`。它更改工作目录，这样我们就不需要将所有后续命令的前缀设置为完整路径。如果文件夹不存在，Docker会为我们创建它。'
- en: 'Next, we copy the **package.json** and **package-lock.json** files from our
    project to the working directory:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将**package.json**和**package-lock.json**文件从我们的项目复制到工作目录：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `COPY` instruction copies files from your local file system into the Docker
    image (relative to the local working directory). Multiple files can be specified,
    and the last argument to the instruction is the destination (in this case, the
    current working directory of the image).
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`COPY`指令将文件从你的本地文件系统复制到Docker镜像中（相对于本地工作目录）。可以指定多个文件，指令的最后一个参数是目标位置（在这种情况下，是镜像的当前工作目录）。'
- en: The `package-lock.json` file is needed to ensure that the Docker image contains
    the same versions of the `npm` packages as our local build.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`package-lock.json`文件是必需的，以确保Docker镜像包含与我们的本地构建相同的`npm`包版本。'
- en: 'Now, we run **npm install** to install all dependencies in the image:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们运行**npm install**来在镜像中安装所有依赖项：
- en: '[PRE5]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `RUN` instruction executes a command in the working directory of the image.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`RUN`指令在镜像的工作目录中执行一个命令。'
- en: 'Then, we copy the rest of our application from the local file system to the
    Docker image:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将应用程序的其余部分从本地文件系统复制到Docker镜像中：
- en: '[PRE6]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: Are you wondering why we initially just copied **package.json** and **package-lock.json**?
    Docker images are built layer by layer. Each instruction forms a layer of the
    image. If something changes, only the layers following the change are rebuilt.
    So, in our case, if any of the code changes, only this last **COPY** instruction
    is re-executed when rebuilding the Docker image. Only if dependencies change are
    the other **COPY** instruction and **npm install** re-executed. Using this order
    of instruction reduces the time required to rebuild the image immensely.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你想知道为什么我们最初只复制了**package.json**和**package-lock.json**吗？Docker镜像是一层层构建的。每个指令形成一个镜像层。如果有什么变化，只有变化之后的层需要重新构建。所以，在我们的例子中，如果代码有任何变化，只有这个最后的**COPY**指令在重新构建Docker镜像时会被重新执行。只有当依赖项发生变化时，其他的**COPY**指令和**npm
    install**才会被重新执行。使用这种指令顺序可以极大地减少重新构建镜像所需的时间。
- en: 'Finally, we run our application:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们运行我们的应用程序：
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `CMD` instruction is not executed while building the image. Instead, it
    stores information in the metadata of the image, telling Docker which command
    to run when a container is instantiated from the image. In our case, the container
    is going to run `npm start` when using our image.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CMD`指令在构建镜像时不会执行。相反，它将信息存储在镜像的元数据中，告诉Docker当从镜像实例化容器时要运行哪个命令。在我们的例子中，当使用我们的镜像时，容器将运行`npm
    start`。'
- en: Note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: You may have noticed that we passed a JSON array to the **CMD** instruction
    instead of simply writing **CMD npm start**. The JSON array version is called
    **exec form** and, if the first argument is an executable, will run the command
    directly without invoking a shell. The form without the JSON array is called **shell
    form** and will execute the command with a shell, prefixing it with **/bin/sh
    -c**. Running a command without a shell has the advantage of allowing the application
    to properly receive signals, such as a **SIGTERM** or **SIGKILL** signal when
    the application is terminated. Alternatively, the **ENTRYPOINT** instruction can
    be used to specify which executable should be used to run a certain command (it
    defaults to **/bin/sh -c**). In some cases, you may even want to run the script
    directly using **CMD ["node", "src/index.js"]**, so that the script can properly
    receive *all* signals. However, this would require us to implement the **SIGINT**
    signal in our backend server to allow closing the container via *Ctrl* + *C*,
    so, to keep things simple, we just use **npm** **start** instead.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们向 **CMD** 指令传递了一个 JSON 数组，而不是简单地写入 **CMD npm start**。这种包含 JSON 数组的版本被称为
    **exec 形式**，如果第一个参数是一个可执行文件，它将直接运行命令而不调用 shell。没有 JSON 数组的版本被称为 **shell 形式**，它将使用
    shell 执行命令，并在前面加上 **/bin/sh -c**。在没有 shell 的情况下运行命令的优点是允许应用程序正确接收信号，例如当应用程序被终止时发出的
    **SIGTERM** 或 **SIGKILL** 信号。或者，可以使用 **ENTRYPOINT** 指令来指定运行特定命令时应使用的可执行文件（默认为
    **/bin/sh -c**）。在某些情况下，你可能甚至想直接使用 **CMD ["node", "src/index.js"]** 来运行脚本，这样脚本就可以正确接收
    *所有* 信号。然而，这需要我们在后端服务器中实现 **SIGINT** 信号，以便通过 *Ctrl* + *C* 来关闭容器，因此为了保持简单，我们只是使用
    **npm start**。
- en: After creating our Dockerfile, we should also create a `.dockerignore` file
    to make sure unnecessary files are not copied into our image.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的 Dockerfile 之后，我们还应该创建一个 `.dockerignore` 文件，以确保不必要的文件不会被复制到我们的镜像中。
- en: Creating a .dockerignore file
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 .dockerignore 文件
- en: 'The `COPY` command, where we copy all files, would also copy the `node_modules`
    folder and other files, such as the `.env` file, which we do not want to go into
    our image. To prevent certain files from being copied into our Docker image, we
    need to create a `.dockerignore` file. Let’s do that now:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY` 命令，其中我们复制所有文件，也会复制 `node_modules` 文件夹和其他文件，例如我们不希望进入镜像的 `.env` 文件。为了防止某些文件被复制到我们的
    Docker 镜像中，我们需要创建一个 `.dockerignore` 文件。现在让我们来做这件事：'
- en: Create a new **backend/.dockerignore** file.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **backend/.dockerignore** 文件。
- en: 'Open it and enter the following contents to ignore the **node_modules** folder
    and all **.****env** files:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开它并输入以下内容以忽略 **node_modules** 文件夹和所有 **.****env** 文件：
- en: '[PRE8]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we have defined a `.dockerignore` file, the `COPY` instructions will
    ignore these folders and files. Let’s build the Docker image now.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了 `.dockerignore` 文件，`COPY` 指令将忽略这些文件夹和文件。现在让我们构建 Docker 镜像。
- en: Building the Docker image
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Docker 镜像
- en: 'After successfully creating the backend Dockerfile and a `.dockerignore` file
    to prevent certain files and folders from being added to our Docker image, we
    can now get started building our Docker image:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功创建后端 Dockerfile 和一个 `.dockerignore` 文件以防止某些文件和文件夹被添加到我们的 Docker 镜像之后，我们现在可以开始构建我们的
    Docker 镜像：
- en: Open a Terminal.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端。
- en: 'Run the following command to build the Docker image:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来构建 Docker 镜像：
- en: '[PRE9]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After running the command, Docker will start by reading the Dockerfile and `.dockerignore`
    file. Then, it will download the `node` image and run our instructions one by
    one. Finally, it will export all layers and metadata into our Docker image.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，Docker 将首先读取 Dockerfile 和 `.dockerignore` 文件。然后，它将下载 `node` 镜像并逐条执行我们的指令。最后，它将所有层和元数据导出到我们的
    Docker 镜像中。
- en: 'The following screenshot shows the output of creating a Docker image:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了创建 Docker 镜像的输出：
- en: '![Figure 5.1 – The output when creating a Docker image](img/B19385_05_1.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 创建 Docker 镜像时的输出](img/B19385_05_1.jpg)'
- en: Figure 5.1 – The output when creating a Docker image
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 创建 Docker 镜像时的输出
- en: Now that we have successfully created our own image, let’s create and run a
    container based on it!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功创建了我们的镜像，接下来让我们基于它创建并运行一个容器！
- en: Creating and running a container from our image
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从我们的镜像创建和运行容器
- en: 'We have already created Docker containers based on the `ubuntu` and `mongo`
    images in [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028), *Getting to Know Node.js
    and MongoDB*. Now, we are going to create and run a container from our own image.
    Let’s get started doing that now:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第2章*](B19385_02.xhtml#_idTextAnchor028)，“了解Node.js和MongoDB”中创建了基于`ubuntu`和`mongo`镜像的Docker容器。现在，我们将从我们自己的镜像创建并运行一个容器。让我们现在开始做这件事：
- en: 'Run the following command to list all available images:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来列出所有可用的镜像：
- en: '[PRE10]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Make sure the **dbserver** container with our database is already running.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保我们的数据库的**dbserver**容器已经运行。
- en: 'Then, start a new container, as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按照以下步骤启动一个新的容器：
- en: '[PRE11]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The **blog-backend** container is now running, which looks very similar to running
    the backend directly on our host in the Terminal. Go to **http://localhost:3001/api/v1/posts**
    to verify that it is running properly like before and returning all posts.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**blog-backend**容器现在正在运行，这看起来与在终端上直接运行后端非常相似。转到**http://localhost:3001/api/v1/posts**以验证它是否像以前一样正常运行并返回所有帖子。'
- en: Keep the container running for now.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前请保持容器运行。
- en: We have successfully packaged our backend as a Docker image and started a container
    from it! Now, let’s do the same for our frontend.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地将后端打包为Docker镜像，并从中启动了一个容器！现在，让我们为前端做同样的事情。
- en: Creating the frontend Dockerfile
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建前端Dockerfile
- en: After creating a Docker image for the backend service, we are now going to repeat
    the same process to create an image for the frontend. We will do so by first creating
    a Dockerfile, then the `.dockerignore` file, building the image, and then running
    a container. Now, we will start with creating the frontend Dockerfile.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在为后端服务创建Docker镜像后，我们现在将重复相同的步骤来创建前端镜像。我们将首先创建Dockerfile，然后创建`.dockerignore`文件，构建镜像，然后运行容器。现在，我们将从创建前端Dockerfile开始。
- en: 'In the Dockerfile for our frontend, we are going to use two images:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前端的Dockerfile中，我们将使用两个镜像：
- en: A **build** image to build our project using **Vite** (which will be discarded,
    with only the build output kept)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于使用**Vite**（构建完成后将被丢弃，只保留构建输出）的**构建**镜像
- en: A **final** image, which will serve our static site using nginx
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**最终**的镜像，该镜像将用于我们的静态网站，通过nginx服务
- en: 'Let’s make the Dockerfile now:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在创建Dockerfile：
- en: Create a new Dockerfile in the root of our project.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们项目的根目录下创建一个新的Dockerfile。
- en: 'In this newly created file, first, use the **node** image again, but this time
    we tag it **AS build**. Doing so enables multi-stage builds in Docker, which means
    that we can use another base image later for our **final** image:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新创建的文件中，首先，再次使用**node**镜像，但这次我们将其标记为**AS build**。这样做使得Docker中的多阶段构建成为可能，这意味着我们可以稍后使用另一个基础镜像来创建我们的**最终**镜像：
- en: '[PRE12]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'During build time, we also set the **VITE_BACKEND_URL** environment variable.
    In Docker, we can use the **ARG** instruction to define environment variables
    that are only relevant when the image is being built:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建时，我们还设置了**VITE_BACKEND_URL**环境变量。在Docker中，我们可以使用**ARG**指令来定义仅在构建镜像时相关的环境变量：
- en: '[PRE13]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While the **ARG** instruction defines an environment variable that can be changed
    at build time using the **--build-arg** flag, the **ENV** instruction sets the
    environment variable to a fixed value, which will persist when a container is
    run from the resulting image. So, if we want to customize environment variables
    during build time, we should use the **ARG** instruction. However, if we want
    to customize environment variables during runtime, **ENV** is better suited.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**ARG**指令定义了一个可以在构建时通过**--build-arg**标志更改的环境变量，但**ENV**指令将环境变量设置为固定值，当从生成的镜像运行容器时，该值将保持不变。因此，如果我们想在构建时自定义环境变量，我们应该使用**ARG**指令。然而，如果我们想在运行时自定义环境变量，**ENV**则更为合适。
- en: 'We set the working directory to **/build** for the **build** stage, and then
    repeat the same instructions that we defined for the backend to install all necessary
    dependencies and copy over the necessary files:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将工作目录设置为**/build**，然后重复为后端定义的相同指令来安装所有必要的依赖项并复制必要的文件：
- en: '[PRE14]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Additionally, we execute **npm run build** to create a static build of our
    Vite app:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们执行**npm run build**来创建我们的Vite应用的静态构建：
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, our **build** stage is completed. We use the **FROM** instruction again
    to create the **final** stage. This time, we base it off the **nginx** image,
    which runs an nginx web server:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的**构建**阶段已完成。我们再次使用**FROM**指令来创建**最终**阶段。这次，我们基于**nginx**镜像，该镜像运行nginx网络服务器：
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We set the working directory for this stage to **/var/www/html**, which is
    the folder that nginx serves static files from:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将此阶段的当前工作目录设置为 **/var/www/html**，这是 nginx 从中提供静态文件的文件夹：
- en: '[PRE17]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Lastly, we copy everything from the **/build/dist** folder (which is where
    Vite puts the built static files) from the **build** stage into the **final**
    stage:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将从 **/build/dist** 文件夹（这是 Vite 放置构建的静态文件的地方）从 **build** 阶段复制所有内容到 **final**
    阶段：
- en: '[PRE18]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A `CMD` instruction is not needed in this case, as the `nginx` image already
    contains one to run the web server properly.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下不需要 `CMD` 指令，因为 `nginx` 镜像已经包含了一个用于正确运行 web 服务器的指令。
- en: We successfully created a multi-stage Dockerfile for our frontend! Now, let’s
    move on to creating the `.``dockerignore` file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功地为前端创建了一个多阶段 Dockerfile！现在，让我们继续创建 `.dockerignore` 文件。
- en: Creating the .dockerignore file for the frontend
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为前端创建 .dockerignore 文件
- en: 'We also need to create a `.dockerignore` file for the frontend. Here, we also
    exclude, in addition to the `node_modules/` folder and `.env` files, the `backend/`
    folder containing our backend service and the `.vscode`, `.git`, and `.husky`
    folders. Let’s create the `.dockerignore` file now:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为前端创建一个 `.dockerignore` 文件。在这里，除了排除 `node_modules/` 文件夹和 `.env` 文件外，我们还要排除包含我们的后端服务的
    `backend/` 文件夹以及 `.vscode`、`.git` 和 `.husky` 文件夹。现在让我们创建 `.dockerignore` 文件：
- en: Create a new **.dockerignore** file in the root of our project.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们项目的根目录下创建一个新的 **.dockerignore** 文件。
- en: 'Inside this newly created file, enter the following contents:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新创建的文件中，输入以下内容：
- en: '[PRE19]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we have ignored the files not necessary for the Docker image, let’s
    build it!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经忽略了构建 Docker 镜像不需要的文件，让我们构建它！
- en: Building the frontend Docker image
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Docker 前端镜像
- en: 'Just like before, we execute the `docker build` command to build the image,
    giving it the name `blog-frontend` and specifying the root directory as the path:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们执行 `docker build` 命令来构建镜像，给它命名为 `blog-frontend`，并指定根目录作为路径：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: nginx image runs the web server on port 80, so, if we want to use the port 3000
    on our host, we need to forward from port 80 to 3000 by passing -p 3000:80.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: nginx 镜像在端口 80 上运行 web 服务器，因此，如果我们想在主机上使用端口 3000，我们需要通过传递 -p 3000:80 将端口 80
    转发到 3000。
- en: After running this command and navigating to `http://localhost:3000` in your
    browser, you should see the frontend being served properly and showing blog posts
    from the backend.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令并在浏览器中导航到 `http://localhost:3000` 后，你应该能看到前端被正确提供并显示来自后端的博客文章。
- en: Now that we have created images and containers for the backend and frontend,
    we are going to learn about a way to manage multiple images more easily.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了后端和前端的镜像和容器，我们将学习一种更轻松地管理多个镜像的方法。
- en: Managing multiple images using Docker Compose
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 管理多个镜像
- en: 'Docker Compose is a tool that allows us to define and run multi-container applications
    with Docker. Instead of manually building and running the backend, frontend, and
    database containers, we can use Compose to build and run them all together. To
    get started using Compose, we need to create a `compose.yaml` file in the root
    of our project, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 是一个工具，允许我们使用 Docker 定义和运行多容器应用程序。我们不需要手动构建和运行后端、前端和数据库容器，我们可以使用
    Compose 一起构建和运行它们。要开始使用 Compose，我们需要在我们的项目根目录中创建一个 `compose.yaml` 文件，如下所示：
- en: Create a new **compose.yaml** file in the root of our project.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们项目的根目录下创建一个新的 **compose.yaml** 文件。
- en: 'Open the newly created file and start by defining the version of the Docker
    Compose file specification:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新创建的文件，首先定义 Docker Compose 文件规范的版本：
- en: '[PRE21]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '3.  Now, define a **services** object, in which we are going to define all
    the services that we want to use:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.  现在，定义一个 **services** 对象，我们将在这里定义我们想要使用的所有服务：
- en: '[PRE22]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '4.  First, we have **blog-database**, which uses the **mongo** image and forwards
    port **27017**:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4.  首先，我们有 **blog-database**，它使用 **mongo** 镜像并转发端口 **27017**：
- en: '[PRE23]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In YAML files, the indentation of lines is very important to distinguish where
    properties are nested, so please be careful to put in the correct amount of spaces
    before each line.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 YAML 文件中，行的缩进非常重要，用于区分属性嵌套的位置，因此请务必在每行之前正确放置空格。
- en: 'Next, we have **blog-backend**, which uses the Dockerfile defined in the **backend/**
    folder, defines the environment variables for **PORT** and **DATABASE_URL**, forwards
    the port to the host, and depends on **blog-database**:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有 **blog-backend**，它使用 **backend/** 文件夹中定义的 Dockerfile，定义了 **PORT** 和
    **DATABASE_URL** 环境变量，转发端口到主机，并依赖于 **blog-database**：
- en: '[PRE24]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '2.  Lastly, we have **blog-frontend**, which uses the Dockerfile defined in
    the root, defines the **VITE_BACKEND_URL** build argument, forwards the port to
    the host, and depends on **blog-backend**:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.  最后，我们有 **blog-frontend**，它使用根目录中定义的 Dockerfile，定义了 **VITE_BACKEND_URL**
    构建参数，将端口转发到主机，并依赖于 **blog-backend**：
- en: '[PRE25]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 3.  After defining the services, save the file.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.  在定义服务后，保存文件。
- en: Then, stop the backend and frontend containers running in the terminal by using
    the *Ctrl* + *C* key combination.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过在终端中使用 *Ctrl* + *C* 键组合来停止运行的后端和前端容器。
- en: 'Also, stop the already running **dbserver** container, as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要停止已经运行的 **dbserver** 容器，如下所示：
- en: '[PRE26]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '6.  Finally, run the following command in the Terminal to start all services
    using Docker Compose:'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 6.  最后，在终端中运行以下命令以使用 Docker Compose 启动所有服务：
- en: '[PRE27]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Docker Compose will now create containers for the database, backend, and frontend
    and start all of them. You will start seeing logs being printed from the different
    services. If you go to `http://localhost:3000`, you can see that the frontend
    is running. Create a new post to verify that the connection to the backend and
    database works as well.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 将现在为数据库、后端和前端创建容器，并启动所有容器。您将开始看到来自不同服务的日志输出。如果您访问 `http://localhost:3000`，您可以看到前端正在运行。创建一个新的帖子来验证后端和数据库的连接是否正常工作。
- en: 'The following screenshot shows the output of `docker compose up` creating and
    starting all containers:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了 `docker compose up` 命令创建和启动所有容器的输出：
- en: '![Figure 5.2 – Creating and running multiple containers with Docker Compose](img/B19385_05_2.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 使用 Docker Compose 创建和运行多个容器](img/B19385_05_2.jpg)'
- en: Figure 5.2 – Creating and running multiple containers with Docker Compose
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 使用 Docker Compose 创建和运行多个容器
- en: The output in the screenshot is then followed by log messages from the various
    services, including the MongoDB database service and our backend and frontend
    services.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 截图输出之后，是来自各种服务的日志消息，包括 MongoDB 数据库服务和我们的后端和前端服务。
- en: Just like always, you can press *Ctrl* + *C* to stop all Docker Compose containers.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 就像往常一样，您可以按 *Ctrl* + *C* 来停止所有 Docker Compose 容器。
- en: Now that we have set up Docker Compose, it’s very easy to start all services
    at once and manage them all in one place. If you look at your Docker containers,
    you may notice that there are lots of stale containers still left over from previously
    building the `blog-backend` and `blog-frontend` containers. Let’s now learn how
    to clean up those.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了 Docker Compose，一次性启动所有服务并统一管理它们变得非常容易。如果您查看您的 Docker 容器，您可能会注意到还有很多过时的容器仍然留在之前构建
    `blog-backend` 和 `blog-frontend` 容器时。现在让我们学习如何清理这些容器。
- en: Cleaning up unused containers
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 清理未使用的容器
- en: 'After experimenting with Docker for a while, there will be lots of images and
    containers that are not in use anymore. Docker generally does not remove objects
    unless you explicitly ask it to, causing it to use a lot of disk space. If you
    want to remove objects, you can either remove them one by one or use one of the
    `prune` commands provided by Docker:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Docker 进行了一段时间的实验后，将会有很多不再使用的镜像和容器。Docker 通常不会删除对象，除非您明确要求它这样做，这会导致它占用大量磁盘空间。如果您想删除对象，您可以选择逐个删除，或者使用
    Docker 提供的 `prune` 命令之一：
- en: '**docker container prune**: This removes all stopped containers'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**docker container prune**：这将删除所有已停止的容器'
- en: '**docker image prune**: This removes all dangling images (images not tagged
    and not referenced by any container)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**docker image prune**：这将删除所有悬空镜像（未标记且未被任何容器引用的镜像）'
- en: '**docker image prune -a**: This removes all images not used by any containers'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**docker image prune -a**：这将删除所有未被任何容器使用的镜像'
- en: '**docker volume prune**: This removes all volumes not used by any containers'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**docker volume prune**：这将删除所有未被任何容器使用的卷'
- en: '**docker network prune**: This cleans up networks not used by any containers'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**docker network prune**：这将清理所有未被任何容器使用的网络'
- en: '**docker system prune**: This prunes everything except volumes'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**docker system prune**：这将删除除卷之外的所有内容'
- en: '**docker system prune --volumes**: This prunes everything'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**docker system prune --volumes**：这将删除所有内容'
- en: So, if you want to, for example, remove all unused containers, you should first
    make sure that all of the containers that you still want to use are running. Then,
    execute `docker container prune` in the terminal.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您想删除所有未使用的容器，您应该首先确保所有您还想使用的容器都在运行。然后，在终端中执行 `docker container prune`。
- en: Now that we have learned how to use Docker locally to package our services as
    images and run them in containers, let’s move on to deploying our full-stack application
    to the cloud.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何在本地使用 Docker 将我们的服务打包成镜像并在容器中运行，接下来让我们继续将我们的全栈应用程序部署到云端。
- en: Deploying our full-stack application to the cloud
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的全栈应用程序部署到云端
- en: After creating Docker images and containers locally, it’s time to learn how
    to deploy them to the cloud so that everyone can access our services. In this
    book, we are going to use **Google Cloud** as an example, but the general process
    also applies to other providers such as **Amazon Web Services** (**AWS**) and
    **Microsoft Azure**. For the MongoDB database, we are going to use **MongoDB Atlas**
    but feel free to use any provider that can host a MongoDB database for you.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地创建 Docker 镜像和容器之后，现在是时候学习如何将它们部署到云端，以便每个人都能访问我们的服务。在这本书中，我们将以 **Google Cloud**
    为例，但一般的流程也适用于其他提供商，例如 **Amazon Web Services** （**AWS**）和 **Microsoft Azure**。对于
    MongoDB 数据库，我们将使用 **MongoDB Atlas**，但请随意使用任何可以为您托管 MongoDB 数据库的提供商。
- en: Creating a MongoDB Atlas database
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 MongoDB Atlas 数据库
- en: 'To host our database, we are going to use the official cloud solution provided
    by the MongoDB team called MongoDB Atlas. Let’s get started with registering and
    setting up a database now:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了托管我们的数据库，我们将使用 MongoDB 团队提供的官方云解决方案，名为 MongoDB Atlas。现在让我们开始注册和设置数据库：
- en: Go to [https://www.mongodb.com/atlas](https://www.mongodb.com/atlas) and press
    **Try Free** to create a new account, or sign in with your existing account.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [https://www.mongodb.com/atlas](https://www.mongodb.com/atlas) 并按 **免费试用**
    创建新账户，或使用现有账户登录。
- en: Note
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The following instructions may vary slightly due to updates in the MongoDB Atlas
    UI. If the options are not available exactly as listed, try to follow the instructions
    on the website instead to create a database and a user to access it. This applies
    to all cloud services that we are going to set up throughout this chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下说明可能因 MongoDB Atlas UI 的更新而略有不同。如果选项与列表中列出的不完全一致，请尝试按照网站上的说明进行操作，以创建数据库和用户来访问它。这适用于我们将在本章中设置的所有云服务。
- en: Select **Database** from the sidebar, then press **Create** to create a new
    database deployment. If you made a new account, you should be asked to create
    a new database deployment automatically.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从侧边栏选择 **数据库**，然后按 **创建** 以创建一个新的数据库部署。如果您创建了新账户，您应该会自动被要求创建新的数据库部署。
- en: Select **Shared / M0 Sandbox** (free instance) on Google Cloud and your preferred
    region.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Google Cloud 上选择 **共享 / M0 沙盒**（免费实例）和您首选的区域。
- en: Give your cluster a name of your choice.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给您的集群起一个您喜欢的名字。
- en: Press **Create** to create your M0 sandbox cluster. It will take some time for
    the database to be accessible (typically around a minute). However, you can continue
    setting up the user while waiting for the cluster to be set up.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 **创建** 以创建您的 M0 沙盒集群。数据库变得可访问需要一些时间（通常大约一分钟）。然而，您可以在等待集群设置的同时继续设置用户。
- en: Go to the **Database** section in the sidebar and click on the **Connect** button
    next to your newly created cluster.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在侧边栏的 **数据库** 部分点击你新创建的集群旁边的 **连接** 按钮。
- en: In the popup, select **Allow Access from Anywhere** and then press **Add** **IP
    Address**.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的窗口中，选择 **允许从任何地方访问**，然后按 **添加** **IP 地址**。
- en: Set a username and password for your database user and press **Create** **database
    user**.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的数据库用户设置用户名和密码，然后按 **创建** **数据库用户**。
- en: Press **Choose a connection method** and select **Drivers**.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 **选择连接方法** 并选择 **驱动程序**。
- en: 'A connection string will be shown; copy it and save it for later, inserting
    your previously set password instead of the **<password>** string. The connection
    string should have the following format:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将显示一个连接字符串；将其复制并保存以备后用，用您之前设置的密码替换 **<password>** 字符串。连接字符串应具有以下格式：
- en: '[PRE28]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '10.  Verify that the connection string works by opening a terminal and connecting
    to it using **mongo** shell:'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 10. 通过在终端中打开并使用 **mongo** 壳连接到它来验证连接字符串是否有效：
- en: '[PRE29]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following screenshot shows how the **Database Deployments** tab looks in
    MongoDB Atlas:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 MongoDB Atlas 中的 **数据库部署** 选项卡的外观：
- en: '![Figure 5.3 – A fresh M0 Sandbox database cluster deployed on MongoDB Atlas](img/B19385_05_3.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 在 MongoDB Atlas 上部署的新 M0 沙盒数据库集群](img/B19385_05_3.jpg)'
- en: Figure 5.3 – A fresh M0 Sandbox database cluster deployed on MongoDB Atlas
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 在 MongoDB Atlas 上部署的新 M0 沙盒数据库集群
- en: Now that we have successfully created our MongoDB database in the cloud, we
    can move on to setting up Google Cloud to deploy our backend and frontend.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在云中成功创建了我们的MongoDB数据库，我们可以继续设置Google Cloud以部署我们的后端和前端。
- en: Creating an account on Google Cloud
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在Google Cloud上创建一个账户
- en: 'Let’s get started with Google Cloud by creating an account now. When creating
    an account, you need to enter billing information, but you will get $300 in free
    credits to trial using Google Cloud for free:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从现在开始创建Google Cloud账户。在创建账户时，你需要输入账单信息，但你将获得300美元的免费信用额度，可以免费试用Google Cloud：
- en: Go to [https://cloud.google.com](https://cloud.google.com) in your browser.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中访问[https://cloud.google.com](https://cloud.google.com)。
- en: Press **Get started for free** if you do not have an account yet or press **Sign
    in** if you already have an account.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有账户，请点击**免费开始**，如果你已经有了账户，请点击**登录**。
- en: Log in with your Google account and follow the instructions until you have access
    to the Google Cloud console.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的Google账户登录并按照指示操作，直到你能够访问Google Cloud控制台。
- en: 'You should now see a screen similar to the following figure:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该会看到一个类似于以下图所示的屏幕：
- en: '![Figure 5.4 – The Google Cloud console after registering](img/B19385_05_4.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – 注册后的Google Cloud控制台](img/B19385_05_4.jpg)'
- en: Figure 5.4 – The Google Cloud console after registering
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 注册后的Google Cloud控制台
- en: Now that you have an account set up and ready, let’s start deploying our services.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置好账户并准备就绪，让我们开始部署我们的服务。
- en: Deploying our Docker images to a Docker registry
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的Docker镜像部署到Docker仓库
- en: 'Before we can deploy a service on a cloud provider, we first need to deploy
    our Docker image to a **Docker registry** so that the cloud provider can access
    it from there and create a container from it. Follow these steps to deploy our
    Docker images to Docker Hub, the official Docker registry:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以在云服务提供商上部署服务之前，我们首先需要将我们的Docker镜像部署到一个**Docker仓库**，以便云服务提供商可以从那里访问它并从中创建一个容器。按照以下步骤将我们的Docker镜像部署到Docker
    Hub，官方Docker仓库：
- en: Go to [https://hub.docker.com](https://hub.docker.com) and log in or register
    an account there.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://hub.docker.com](https://hub.docker.com)并登录或注册账户。
- en: Press the **Create repository** button to create a new repository. The repository
    will contain our image.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建仓库**按钮以创建一个新的仓库。该仓库将包含我们的镜像。
- en: Enter **blog-frontend** as the repository name and leave the description empty
    and visibility **public**. Then press the **Create** button.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将仓库名称输入为**blog-frontend**，留空描述，并将可见性设置为**公开**。然后点击**创建**按钮。
- en: Repeat *Steps 2* and *3*, but this time, enter **blog-backend** as the repository
    name.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤2*和*步骤3*，但这次，将**blog-backend**作为仓库名称输入。
- en: 'Open a new terminal and enter the following command to log in to your Docker
    Hub account:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端并输入以下命令以登录到你的Docker Hub账户：
- en: '[PRE30]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Enter your username and password from Docker Hub and press the *Return* key
    or *Enter*.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输入你的Docker Hub用户名和密码，然后按*Return*键或*Enter*键。
- en: '6.  Rebuild your image for Linux (to be able to deploy it to Google Cloud later),
    tag your image with your repository name (replace **[USERNAME]** with your Docker
    Hub username), and push it to the repository:'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 6.  重新构建你的Linux镜像（以便稍后能够部署到Google Cloud），使用你的仓库名称标记你的镜像（将**[USERNAME]**替换为你的Docker
    Hub用户名），并将其推送到仓库：
- en: '[PRE31]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '7.  Navigate to **backend/** in the terminal and repeat *Step 6* for the **blog-backend**
    image:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 7.  在终端中导航到**backend/**，并为**blog-backend**镜像重复*步骤6*：
- en: '[PRE32]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that both repositories are set up and the images are pushed to them, they
    should show up in Docker Hub with the following information: **Contains: Image
    | Last pushed: a few** **seconds ago**:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在两个仓库都已设置好，镜像也已推送到它们，它们应该会在Docker Hub上显示以下信息：**包含：镜像 | 最后推送：几秒钟前**：
- en: '![Figure 5.5 – Docker Hub giving an overview of our repositories](img/B19385_05_5.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5 – Docker Hub展示我们的仓库概览](img/B19385_05_5.jpg)'
- en: Figure 5.5 – Docker Hub giving an overview of our repositories
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – Docker Hub展示我们的仓库概览
- en: Now that our Docker images are published on a public Docker registry (Docker
    Hub), we can continue setting up Google Cloud to deploy our services.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将Docker镜像发布到公共Docker仓库（Docker Hub），我们可以继续设置Google Cloud以部署我们的服务。
- en: Note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The repositories created on Docker Hub in this book are *public*. You can also
    choose to create up to one private repository on Docker Hub for free. Otherwise,
    you either need to have a Docker Hub subscription, use a different registry, or
    host your own registry. For example, **Google Artifact Registry** could be used
    to deploy private Docker images on **Cloud Run**.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本书在Docker Hub上创建的仓库是**公开的**。您也可以选择在Docker Hub上免费创建最多一个私有仓库。否则，您可能需要拥有Docker
    Hub订阅，使用不同的注册表，或者托管自己的注册表。例如，可以使用**Google Artifact Registry**在**Cloud Run**上部署私有Docker镜像。
- en: Deploying the backend Docker image to Cloud Run
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将后端Docker镜像部署到Cloud Run
- en: After successfully publishing our Docker images on the Docker Hub registry,
    it’s time to deploy them using Google Cloud Run. Cloud Run is a managed compute
    platform. It allows us to run containers directly on the Google Cloud infrastructure,
    making app deployment simple and fast. The alternatives to Cloud Run would be
    Kubernetes-based infrastructure, such as AWS ECS Fargate or DigitalOcean.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker Hub注册表成功发布我们的Docker镜像后，是时候使用Google Cloud Run来部署它们了。Cloud Run是一个托管计算平台。它允许我们在Google
    Cloud基础设施上直接运行容器，使应用程序部署变得简单快捷。Cloud Run的替代方案将是基于Kubernetes的基础设施，例如AWS ECS Fargate或DigitalOcean。
- en: 'Follow these steps to deploy the backend to Google Cloud Run:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将后端部署到Google Cloud Run：
- en: Go to [https://console.cloud.google.com/](https://console.cloud.google.com/).
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[https://console.cloud.google.com/](https://console.cloud.google.com/)。
- en: In the search bar at the top, enter **Cloud Run** and select the **Cloud Run
    – Serverless for containerized** **applications** product.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部搜索栏中输入**Cloud Run**，并选择**Cloud Run – 适用于容器化****应用程序**产品。
- en: Press the **Create Service** button to create a new service.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建服务**按钮以创建新服务。
- en: Note
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may need to first create a project before you can create a service. In that
    case, just follow the instructions on the website to create a new project with
    a name of your choice. Afterward, press the **Create Service** button to create
    a new service.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在您能够创建服务之前，您可能需要首先创建一个项目。在这种情况下，只需按照网站上的说明创建一个您选择的名称的新项目。之后，点击**创建服务**按钮以创建新服务。
- en: Enter **[USERNAME]****/blog-backend** in the **Container image** **URL** box.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**容器镜像**URL框中输入**[USERNAME]****/blog-backend**。
- en: Enter **blog-backend** in the **Service name** box, select a region of your
    choice, leave **CPU is only allocated during request processing** selected, and
    select **All – Allow direct access to your service from the Internet** and **Authentication
    – Allow** **unauthenticated invocations**.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**服务名称**框中输入**blog-backend**，选择您选择的区域，保留**CPU仅在请求处理期间分配**选中，并选择**所有 – 允许从互联网直接访问您的服务**和**身份验证
    – 允许****未经验证的调用**。
- en: Expand the **Container, Networking, Security** section, scroll down to **Environment
    variables**, and click on **Add Variable**.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**容器、网络、安全**部分，滚动到**环境变量**，然后点击**添加变量**。
- en: Name the new environment variable **DATABASE_URL** and, as the value, enter
    the connection string from MongoDB Atlas, which you saved earlier.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新环境变量命名为**DATABASE_URL**，作为值，输入您之前保存的MongoDB Atlas的连接字符串。
- en: Note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For simplicity, we are using a regular environment variable here. To make variables
    that contain credentials more secure, it should instead be added as a secret,
    which requires enabling the **Secrets API**, adding the secret to the secret manager,
    and then referencing the secret and choosing it to be exposed as an environment
    variable.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们在这里使用常规环境变量。为了使包含凭证的变量更安全，应将其作为秘密添加，这需要启用**Secrets API**，将秘密添加到秘密管理器中，然后引用秘密并将其选择为要公开的环境变量。
- en: Leave the rest of the options as the default options and press **Create**.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其余选项保留为默认选项，然后点击**创建**。
- en: You will get redirected to the newly created service, where the container is
    currently being deployed. Wait until it finishes deploying, which can take up
    to a couple of minutes.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将被重定向到新创建的服务，其中容器正在部署。等待部署完成，这可能需要几分钟。
- en: When the service finishes deploying, you should see a checkmark and a URL. Click
    the URL to open the backend and you will see our **Hello World from Express!**
    message, which means that our backend was successfully deployed in the cloud!
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当服务完成部署后，您应该看到一个勾选标记和一个URL。点击URL以打开后端，您将看到我们的**Hello World from Express!**消息，这意味着我们的后端已成功在云端部署！
- en: 'A deployed service looks as follows in Google Cloud Run:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在Google Cloud Run中部署的服务如下所示：
- en: '![Figure 5.6 – A successfully deployed service on Google Cloud Run](img/B19385_05_6.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 在 Google Cloud Run 上成功部署的服务](img/B19385_05_6.jpg)'
- en: Figure 5.6 – A successfully deployed service on Google Cloud Run
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 在 Google Cloud Run 上成功部署的服务
- en: Deploying the frontend Docker image to Cloud Run
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将前端 Docker 镜像部署到 Cloud Run
- en: 'For the frontend, we first need to rebuild the container to change the `VITE_BACKEND_URL`
    environment variable, which is statically built into our project. Let’s do that
    first:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前端，我们首先需要重新构建容器以更改 `VITE_BACKEND_URL` 环境变量，该变量被静态构建到我们的项目中。让我们先做这个：
- en: 'Open a terminal and run the following command to rebuild the frontend with
    the environment variable set:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行以下命令以使用环境变量重新构建前端：
- en: '[PRE33]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '2.  Tag it with your Docker Hub username and deploy the new version of the
    image to Docker Hub:'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.  使用您的 Docker Hub 用户名标记它，并将新版本的镜像部署到 Docker Hub：
- en: '[PRE34]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we can repeat similar steps as we did to deploy the backend to deploy
    our frontend as well:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以重复我们用于部署后端的类似步骤来部署我们的前端：
- en: Create a new Cloud Run service, enter **[USERNAME]****/blog-frontend** in the
    **Container image URL** box and **blog-frontend** in the **Service** **name**
    box.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Cloud Run 服务，在 **容器镜像 URL** 框中输入 **[USERNAME]****/blog-frontend**，在 **服务名称**
    框中输入 **blog-frontend**。
- en: Pick a region of your choice and enable **Allow** **unauthenticated invocations**.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您喜欢的区域并启用 **允许** **未认证调用**。
- en: Expand **Container, Networking, Security** and change the container port from
    **8080** to **80**.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开 **容器、网络、安全** 并将容器端口从 **8080** 更改为 **80**。
- en: Press **Create** to create the service and wait for it to be deployed.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **创建** 以创建服务，并等待其部署。
- en: Open the URL in your browser and you should see the deployed frontend. Adding
    and listing blog posts also works now by sending a request to the deployed backend,
    which then stores the posts in our MongoDB Atlas cluster.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开此 URL，您应该能看到已部署的前端。通过向部署的后端发送请求，现在也可以添加和列出博客文章，然后这些文章会存储在我们的 MongoDB
    Atlas 集群中。
- en: We have successfully manually deployed our first full-stack React and Node.js
    application with a MongoDB database in the cloud! In the next sections, we are
    going to focus on automating testing and deployment using CI/CD.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功手动部署了我们的第一个全栈 React 和 Node.js 应用程序，其中包含云中的 MongoDB 数据库！在下一节中，我们将专注于使用 CI/CD
    自动化测试和部署。
- en: Configuring CI to automate testing
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 CI 以自动化测试
- en: '**Continuous Integration** (**CI**) covers the automation of integrating code
    changes to find bugs quicker and keep the code base easily maintainable. Usually,
    this is facilitated by having scripts run automatically when a developer makes
    a pull/merge request before the code is merged into the main branch. This practice
    allows us to detect problems with our code early by, for example, running the
    linter and tests before the code can be merged. As a result, CI gives us more
    confidence in our code and allows us to make and deploy changes faster and more
    frequently.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成** (**CI**) 涵盖了将代码更改自动集成以更快地发现错误并保持代码库易于维护的过程。通常，这是通过在代码合并到主分支之前，当开发者提交拉取/合并请求时自动运行脚本来实现的。这种做法使我们能够在代码合并之前通过例如运行代码检查器和测试来早期发现代码中的问题。因此，CI
    使我们对代码更有信心，并允许我们更快、更频繁地做出和部署更改。'
- en: 'The following figure shows a simple overview of a possible CI/CD pipeline:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了可能的 CI/CD 管道的简单概述：
- en: '![Figure 5.7 – Simple overview of a CI/CD pipeline](img/B19385_05_7.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – CI/CD 管道简单概述](img/B19385_05_7.jpg)'
- en: Figure 5.7 – Simple overview of a CI/CD pipeline
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – CI/CD 管道简单概述
- en: Note
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this book, we are going to use **GitHub Actions** for CI/CD. While the syntax
    and configuration files might look and work differently on other systems, such
    as GitLab CI/CD or CircleCI, the general principles are similar.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用 **GitHub Actions** 进行 CI/CD。虽然语法和配置文件可能在其他系统上看起来和工作方式不同，例如 GitLab
    CI/CD 或 CircleCI，但基本原理是相似的。
- en: In GitHub Actions, **workflows** can be triggered when **events** occur in the
    repository, such as pushing to a branch, opening a new pull request, or creating
    a new issue. Workflows can contain one or multiple **jobs**, which can either
    run in parallel or sequentially. Each job runs inside its own **runner**, which
    takes instructions from the CI definition and executes them within a specified
    container. Inside jobs, **actions** can be performed, which are either existing
    actions provided on GitHub, or we can write our own actions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub Actions中，**workflows**可以在仓库中发生**事件**时触发，例如向分支推送、打开新的拉取请求或创建新的问题。工作流程可以包含一个或多个**jobs**，这些作业可以并行或顺序执行。每个作业在其自己的**runner**内运行，该runner从CI定义中获取指令并在指定的容器内执行它们。在作业内，可以执行**actions**，这些actions可以是GitHub上提供的现有actions，或者我们可以编写自己的actions。
- en: Adding CI for the frontend
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为前端添加持续集成
- en: 'Let’s get started creating a workflow that will build the frontend when a pull
    request is created, or a push is made to the `main` branch:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建一个工作流程，当创建拉取请求或向`main`分支推送时，它将构建前端：
- en: Create a new **.github/** folder in the root of our project. Inside it, create
    a **workflows/** folder.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们项目的根目录下创建一个新的**.github/**文件夹。在其内部，创建一个**workflows/**文件夹。
- en: Inside the **.github/workflows/** folder, create a new file called **frontend-ci.yaml**.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**.github/workflows/**文件夹内，创建一个名为**frontend-ci.yaml**的新文件。
- en: 'Open the **.github/workflows/frontend-ci.yaml** file and start by giving the
    workflow a name:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**.github/workflows/frontend-ci.yaml**文件，并首先给工作流程起一个名字：
- en: '[PRE35]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '4.  Then, listen to events by using the **on** keyword. We are going to execute
    the jobs when a new pull request or push is made to the **main** branch:'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4.  然后，使用**on**关键字监听事件。我们将在新拉取请求或向**main**分支推送时执行作业：
- en: '[PRE36]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '5.  Now, we define a job that will run the linter and build the frontend:'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 5.  现在，我们定义一个将运行代码检查器和构建前端的作业：
- en: '[PRE37]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '6.  We run the job on an **ubuntu-latest** container:'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 6.  我们在**ubuntu-latest**容器上运行作业：
- en: '[PRE38]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '7.  We can make use of the matrix strategy to run our tests multiple times
    with different variables. In our case, we want to run it on multiple Node.js versions:'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 7.  我们可以使用矩阵策略来使用不同的变量多次运行我们的测试。在我们的情况下，我们希望在多个Node.js版本上运行它：
- en: '[PRE39]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '8.  Now, we define the steps inside our job. Make sure the **steps** are defined
    on the same indentation level as **strategy**:'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 8.  现在，我们在作业内定义步骤。确保**steps**与**strategy**处于相同的缩进级别：
- en: '[PRE40]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '9.  First, we use the **actions/checkout** action, which checks out our repository:'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 9.  首先，我们使用**actions/checkout**操作，它将检出我们的仓库：
- en: '[PRE41]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '10.  Then, we use the **actions/setup-node** action, which sets up Node.js
    inside our container. Here, we make use of the **node-version** variable we defined
    earlier:'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 10.  然后，我们使用**actions/setup-node**操作，它在我们的容器内设置Node.js。在这里，我们使用之前定义的**node-version**变量：
- en: '[PRE42]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `cache` option specifies a package manager to be used for caching dependencies.
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`cache`选项指定用于缓存依赖项的包管理器。'
- en: '11.  Finally, we install dependencies, run the linter, and build our frontend:'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 11.  最后，我们安装依赖项，运行代码检查器并构建我们的前端：
- en: '[PRE43]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Adding CI for the backend
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为后端添加持续集成
- en: 'Now that we have added CI for the frontend, let’s also add CI for the backend
    by building and testing it when a pull request is created or a push is made to
    the `main` branch:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为前端添加了持续集成，让我们也通过在创建拉取请求或向`main`分支推送时构建和测试后端来添加后端持续集成：
- en: Inside the **.github/workflows/** folder, create a new file called **backend-ci.yaml**.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**.github/workflows/**文件夹内，创建一个名为**backend-ci.yaml**的新文件。
- en: 'Open the **.github/workflows/backend-ci.yaml** file, start by giving it a name,
    and listen to the same events as we did for the frontend CI:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**.github/workflows/backend-ci.yaml**文件，首先给它起一个名字，并监听与前端CI相同的事件：
- en: '[PRE44]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '3.  Now, we define a job that will build and test the backend. We set the default
    working directory to the **backend/** folder to run all actions inside that folder:'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.  现在，我们定义一个将构建和测试后端的作业。我们将默认工作目录设置为**backend/**文件夹，以便在该文件夹内运行所有操作：
- en: '[PRE45]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '4.  Then, we use the same actions as for the frontend to check out the repository
    and set up Node.js:'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4.  然后，我们使用与前端相同的操作来检出仓库并设置Node.js：
- en: '[PRE46]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '5.  Finally, we run the linter on our backend and run the tests:'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 5.  最后，我们在后端运行代码检查器并运行测试：
- en: '[PRE47]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 6.  Save the workflow files and commit and push them to a GitHub repository
    by creating a new repository on GitHub and following their instructions to push
    an existing repository to GitHub.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 6.  保存工作流程文件，并通过在GitHub上创建一个新的仓库并将现有仓库推送到GitHub来提交和推送它们。
- en: Go to the repository on GitHub and select the **Actions** tab. You should see
    your workflows running here.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 GitHub 上的仓库并选择 **操作** 选项卡。您应该在这里看到您的工作流程正在运行。
- en: 'The following screenshot shows our CI workflows successfully running on GitHub:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的 CI 工作流程在 GitHub 上成功运行：
- en: '![Figure 5.8 – Backend and frontend CI workflows successfully running in GitHub
    Actions](img/B19385_05_8.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – 后端和前端 CI 工作流程在 GitHub Actions 中成功运行](img/B19385_05_8.jpg)'
- en: Figure 5.8 – Backend and frontend CI workflows successfully running in GitHub
    Actions
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 后端和前端 CI 工作流程在 GitHub Actions 中成功运行
- en: 'If we make a new pull request to the `main` branch, we can also see that our
    CI workflows are running properly on the new code. For example, if we added a
    way to tag posts from the frontend and accidentally made tags required in the
    backend without considering our previous rule of only the title being required,
    we will see that the corresponding tests failed:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对 `main` 分支创建一个新的拉取请求，我们还可以看到我们的 CI 工作流程在新代码上运行正常。例如，如果我们为前端添加了标记帖子的方式，并且不小心在后台要求标记（而没有考虑我们之前只要求标题的规则），我们将看到相应的测试失败：
- en: '![Figure 5.9 – Backend CI workflow failing in a pull request](img/B19385_05_9.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – 后端 CI 工作流程在拉取请求中失败](img/B19385_05_9.jpg)'
- en: Figure 5.9 – Backend CI workflow failing in a pull request
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 后端 CI 工作流程在拉取请求中失败
- en: We can also see that GitHub Actions automatically cancels the jobs running for
    other Node.js versions after one of them already failed, to avoid wasting time.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到 GitHub Actions 在其中一个版本失败后自动取消其他 Node.js 版本运行的作业，以避免浪费时间。
- en: Now that we have successfully set up our CI workflows, let’s continue by setting
    up CD to automate the deployment of our full-stack application.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功设置了 CI 工作流程，让我们继续设置 CD 以自动化我们的全栈应用程序的部署。
- en: Configuring CD to automate the deployment
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 CD 以自动化部署
- en: After the pull/merge request is merged, **continuous delivery** (**CD**) comes
    into play. CD automates the release process by automatically deploying the services
    and applications for us. Usually, this involves a multi-stage process, where code
    is first automatically deployed to a staging environment and can then be manually
    deployed to other environments, up until production. If deployment to production
    is also an automated process, it is called **continuous deployment** instead of
    continuous delivery.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在拉取/合并请求合并后，**持续交付**（**CD**）开始发挥作用。CD 通过自动部署服务和应用程序为我们自动化发布过程。通常，这涉及一个多阶段过程，其中代码首先自动部署到预发布环境，然后可以手动部署到其他环境，直到生产环境。如果生产环境的部署也是一个自动化过程，则称为
    **持续部署** 而不是持续交付。
- en: First, we need to get the credentials to authenticate with Docker Hub and Google
    Cloud. Then, we can set up the workflow for deploying our blog.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要获取凭据以验证 Docker Hub 和 Google Cloud。然后，我们可以设置部署我们博客的工作流程。
- en: Getting Docker Hub credentials
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 Docker Hub 凭据
- en: 'Let’s start by getting the credentials to access Docker Hub:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从获取访问 Docker Hub 的凭据开始：
- en: Go to [https://hub.docker.com/](https://hub.docker.com/).
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [https://hub.docker.com/](https://hub.docker.com/)。
- en: Click on your profile and go to your account settings.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击您的个人资料并转到您的账户设置。
- en: Click on the **Security** tab and press the **New Access** **Token** button.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **安全** 选项卡并按下 **新建访问** **令牌** 按钮。
- en: As a description, write **GitHub Actions** and press the **Generate** button.
    Give **Read, Write,** **Delete** permissions.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在描述中写 **GitHub Actions** 并按下 **生成** 按钮。给予 **读取、写入、删除** 权限。
- en: Copy the access token and store it in a safe place.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制访问令牌并将其存储在安全的地方。
- en: Go to your GitHub repository and then go to **Settings** | **Secrets and variables**
    | **Actions**.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往您的 GitHub 仓库，然后转到 **设置** | **密钥和变量** | **操作**。
- en: Press the **New repository secret** button to add a new secret. As a name, write
    **DOCKERHUB_USERNAME**, and as a secret value, use your username on Docker Hub.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 **新建仓库密钥** 按钮以添加新的密钥。作为名称，写 **DOCKERHUB_USERNAME**，并将 Docker Hub 上的用户名用作密钥值。
- en: Add another secret with the name **DOCKERHUB_TOKEN** and paste your previously
    created access token as the secret value.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个名为 **DOCKERHUB_TOKEN** 的密钥，并将之前创建的访问令牌粘贴为密钥值。
- en: Getting Google Cloud credentials
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 Google Cloud 凭据
- en: 'Now, we are going to create a service account to access Google Cloud Run:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个服务账户以访问 Google Cloud Run：
- en: Go to [https://console.cloud.google.com/](https://console.cloud.google.com/).
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [https://console.cloud.google.com/](https://console.cloud.google.com/)。
- en: In the search box on the top, enter **Service accounts** and go to the **IAM
    and admin – Service** **accounts** page.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部的搜索框中输入**服务帐户**，然后转到**IAM和admin – 服务** **帐户**页面。
- en: Press the **Create Service** **Account** button.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建服务帐户**按钮。
- en: In the **Service account name** box, enter **GitHub Actions**. The ID should
    automatically be generated as **github-actions**. Press **Create** **and Continue**.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**服务帐户名称**框中输入**GitHub Actions**。ID应该自动生成为**github-actions**。点击**创建** **并继续**。
- en: Grant the service access to the **Cloud Run Admin** role and press **Continue**.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授予服务对**Cloud Run管理员**角色的访问权限并点击**继续**。
- en: Press **Done** to finish creating the service account.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**完成**以完成创建服务帐户。
- en: On the overview list, copy the email of your newly created service account and
    save it for later use.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在概览列表中，复制你新创建的服务帐户的电子邮件并保存以备后用。
- en: Go to the default compute service account by clicking on its email address.
    Go to the **Permissions** tab and press **Grant Access**.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击默认计算服务帐户的电子邮件地址。转到**权限**选项卡并点击**授予访问权限**。
- en: Paste the email of your newly created service account into the **New principals**
    field and assign the **Cloud Run Service Agent** role. Press **Save** to confirm.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你新创建的服务帐户的电子邮件粘贴到**新主体**字段中，并分配**Cloud Run服务代理**角色。点击**保存**以确认。
- en: On the overview list, press the three dots icon to open actions on your **github-actions**
    service account and select **Manage keys**.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在概览列表中，点击三个点图标以打开你的**github-actions**服务帐户上的操作，并选择**管理密钥**。
- en: On the new page, press **Add Key** | **Create New Key**, and press **Create**
    in the popup. A JSON file should be downloaded.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新页面上，点击**添加密钥** | **创建新密钥**，然后在弹出窗口中点击**创建**。应该会下载一个JSON文件。
- en: Go to your GitHub repository, and go to **Settings** | **Secrets and variables**
    | **Actions**. Press the **New repository secret** button to add a new secret.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往你的GitHub仓库，然后转到**设置** | **秘密和变量** | **操作**。点击**新建仓库秘密**按钮以添加新的秘密。
- en: Add a new secret on your GitHub repository called **GOOGLECLOUD_SERVICE_ACCOUNT**
    and paste the previously copied email of your newly created service account as
    a secret value.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的GitHub仓库中添加一个新的秘密，命名为**GOOGLECLOUD_SERVICE_ACCOUNT**，并将之前复制的你新创建的服务帐户的电子邮件作为秘密值粘贴。
- en: Add a new secret on your GitHub repository called **GOOGLECLOUD_CREDENTIALS**
    and as the secret, paste in the contents of the downloaded JSON file.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的GitHub仓库中添加一个新的秘密，命名为**GOOGLECLOUD_CREDENTIALS**，并将下载的JSON文件内容粘贴为秘密。
- en: Add a new secret on your GitHub repository called **GOOGLECLOUD_REGION** and
    set the secret value to the region you selected when creating the Cloud Run services.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的GitHub仓库中添加一个新的秘密，命名为**GOOGLECLOUD_REGION**，并将秘密值设置为创建Cloud Run服务时选择的区域。
- en: Note
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For better security, Google recommends using **workload identity federation**
    instead of exporting service account key JSON credentials. However, setting up
    workload identity federation is a bit more complicated. More information on how
    to set it up can be found here: [https://github.com/google-github-actions/auth#setup](https://github.com/google-github-actions/auth#setup).'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好的安全性，Google建议使用**工作负载身份联合**而不是导出服务帐户密钥JSON凭据。然而，设置工作负载身份联合要复杂一些。有关如何设置的更多信息，请参阅此处：[https://github.com/google-github-actions/auth#setup](https://github.com/google-github-actions/auth#setup)。
- en: Defining the deployment workflow
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 定义部署工作流程
- en: 'Now that the credentials are available as secret values to our CI/CD workflows,
    we can get started defining the deployment workflow:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在凭据作为秘密值可用，我们可以开始定义部署工作流程：
- en: Inside the **.github/workflows/** folder, create a new file called **cd.yaml**.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**.github/workflows/**文件夹内，创建一个名为**cd.yaml**的新文件。
- en: 'Open the **.github/workflows/cd.yaml** file and start by giving it a name:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**.github/workflows/cd.yaml**文件，首先给它起一个名字：
- en: '[PRE48]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '3.  For CD, we only execute the workflow when pushing to the **main** branch:'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3. 对于CD，我们只在推送**main**分支时执行工作流程：
- en: '[PRE49]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '4.  We start defining a **deploy** job, in which we set **environment** to
    **production** and point the URL to the deployed frontend URL:'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4. 我们开始定义一个**部署**作业，其中我们将**环境**设置为**生产**，并将URL指向已部署的前端URL：
- en: '[PRE50]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We will define a step with the `deploy-frontend` ID later, which stores a variable
    in `steps.deploy-frontend.outputs.url`.
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在稍后定义一个具有`deploy-frontend` ID的步骤，该步骤在`steps.deploy-frontend.outputs.url`中存储一个变量。
- en: '5.  For the steps, as we did before, we first need to check out our repository:'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 5. 对于步骤，就像我们之前做的那样，我们首先需要检出我们的仓库：
- en: '[PRE51]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '6.  Then, we log in to Docker Hub using the credentials we set earlier in our
    secrets:'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 6. 然后，我们使用之前在secrets中设置的凭据登录Docker Hub：
- en: '[PRE52]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '7.  Next, we log in to Google Cloud using the credentials we set earlier:'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 7. 接下来，我们使用之前设置的凭据登录到Google Cloud：
- en: '[PRE53]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '8.  Now, we build and push the backend Docker image using **docker/build-push-action**,
    which builds and pushes an image to a Docker registry:'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 8. 现在，我们使用**docker/build-push-action**构建并推送后端Docker镜像到Docker仓库：
- en: '[PRE54]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '9.  After pushing the Docker image for the backend, we can now deploy it on
    Cloud Run, using the **google-github-actions/deploy-cloudrun** action:'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 9. 在推送后端Docker镜像之后，我们现在可以使用**google-github-actions/deploy-cloudrun**操作在Cloud
    Run上部署它：
- en: '[PRE55]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We gave this step the `deploy-backend` ID, as we need to use it to reference
    the backend URL to build the frontend image in the next step.
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们给这个步骤分配了`deploy-backend` ID，因为我们需要使用它来引用后端URL，以便在下一步构建前端镜像。
- en: '10.  After building and deploying the backend, we build the frontend in a similar
    way, making sure to pass **VITE_BACKEND_URL** as **build-args**:'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 10. 在构建和部署后端之后，我们以类似的方式构建前端，确保将**VITE_BACKEND_URL**作为**build-args**传递：
- en: '[PRE56]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '11.  Finally, we can deploy the frontend, giving this step the **deploy-frontend**
    ID, such that our environment URL can be set properly:'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 11. 最后，我们可以部署前端，给这个步骤分配**deploy-frontend** ID，以便正确设置我们的环境URL：
- en: '[PRE57]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 12.  Save the file and commit and push your changes to the **main** branch.
    You will see **Deploy Blog Application** being triggered on GitHub Actions.
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 12. 保存文件并提交您的更改到**main**分支。您将在GitHub Actions上看到**部署博客应用程序**被触发。
- en: 'The following screenshot shows the result of our blog application being successfully
    deployed via GitHub Actions:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的博客应用程序通过GitHub Actions成功部署的结果：
- en: '![Figure 5.10 – A successful deployment of our full-stack application using
    GitHub Actions](img/B19385_05_10.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图5.10 – 使用GitHub Actions成功部署我们的全栈应用程序](img/B19385_05_10.jpg)'
- en: Figure 5.10 – A successful deployment of our full-stack application using GitHub
    Actions
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10 – 使用GitHub Actions成功部署我们的全栈应用程序
- en: You can click on the URL to open the deployed frontend and will see that it
    works the same way as the manually deployed version.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以点击URL打开已部署的前端，您会看到它以与手动部署版本相同的方式工作。
- en: Congratulations! You have successfully automated the integration and deployment
    of your first full-stack application!
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功自动化了您的第一个全栈应用程序的集成和部署！
- en: Note
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this book, we only created a single-stage deployment, deploying automatically
    directly to production. In a real-world application, you may want to define multiple
    stages. For example, CD could automatically deploy to a staging environment. Deploying
    to production could then be configured to require manual confirmation.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们只创建了一个阶段的部署，自动直接部署到生产环境。在实际应用中，您可能希望定义多个阶段。例如，CD可以自动部署到测试环境。然后，将生产部署配置为需要手动确认。
- en: Summary
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started by learning how to create Docker images and how
    to instantiate local containers from them. Then, we automated this process by
    using Docker Compose. Next, we published our images on the Docker Hub registry
    to be able to deploy them on Google Cloud Run. We then manually deployed our full-stack
    application on Cloud Run. Finally, we learned how to set up CI/CD workflows with
    GitHub Actions to automate the running of the linter, tests, and deploying the
    blog application.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先学习了如何创建Docker镜像以及如何从它们实例化本地容器。然后，我们通过使用Docker Compose自动化了这个过程。接下来，我们在Docker
    Hub注册表中发布了我们的镜像，以便能够在Google Cloud Run上部署它们。然后，我们手动在Cloud Run上部署了我们的全栈应用程序。最后，我们学习了如何使用GitHub
    Actions设置CI/CD工作流程来自动运行lint、测试和部署博客应用程序。
- en: Up until now, everything in our application has been publicly accessible. With
    no user management, anyone can just create posts as any author. In the next chapter,
    [*Chapter 6*](B19385_06.xhtml#_idTextAnchor119), *Adding Authentication with JWT*,
    we are going to learn how to implement user accounts and authentication in our
    full-stack blog application. We are going to learn what **JSON Web Tokens** (**JWTs**)
    are and implement multiple routes for logging in and signing up.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应用程序中的所有内容都是公开可访问的。由于没有用户管理，任何人都可以像任何作者一样创建帖子。在下一章，[*第6章*](B19385_06.xhtml#_idTextAnchor119)，*使用JWT添加身份验证*中，我们将学习如何在我们的全栈博客应用程序中实现用户账户和身份验证。我们将学习**JSON
    Web Tokens**（**JWTs**）是什么，并实现多个登录和注册的路由。
- en: '[PRE58]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
