- en: Chapter 3. TypeScript Crash Course
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will start working with TypeScript, the language Google recommends
    for using with Angular. All the features ECMAScript 2015 and ECMAScript 2016 provide,
    such as functions, classes, modules, and decorators, are already implemented in
    or added to the roadmap of TypeScript. Because of the extra type annotations,
    there are some syntactical additions compared to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: For a smoother transition from the language which is fully supported by modern
    browsers at the time of writing, that is, ES5, we will start with some common
    features between ES2016 and TypeScript. Where there are differences between the
    ES2016 syntax and TypeScript, we'll explicitly mention it. In the second half
    of the chapter, we'll add the type annotations to everything we've learned until
    this point.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will explain the extra features TypeScript provides,
    such as static typing and extra syntax. We will discuss the different consequences
    based on these features, which will help us to be more productive and less error-prone.
    Let's get going!
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript is an open source programming language that is developed and maintained
    by Microsoft. Its initial public release was in October 2012\. TypeScript is a
    superset of ECMAScript, supporting all of the syntax and semantics of JavaScript
    with some extra features on top, such as static typing and richer syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1* shows the relationships among ES5, ES2015, ES2016, and TypeScript.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to TypeScript](img/5081_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1
  prefs: []
  type: TYPE_NORMAL
- en: As TypeScript is statically typed, it can provide a number of benefits to us
    as JavaScript developers. Let's take a quick look at those benefits now.
  prefs: []
  type: TYPE_NORMAL
- en: Compile-time type checking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most common mistakes we make while writing JavaScript code is to
    misspell a property or a method name. Usually, we find out about the mistake when
    we get a runtime error. This can happen during development as well as during production.
    Hoping that we will know about the error before we deploy our code to the production
    environment isn't a comfortable feeling! However, this is not a problem specific
    to JavaScript; it is something common to all the dynamic languages. Even with
    lots of unit tests, these errors can slip by.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript provides a compiler, which takes care of such mistakes for us by
    using static code analysis. If we take advantage of static typing, TypeScript
    will be aware of the existing properties a given object has, and if we misspell
    any of them, the compiler will warn us with a compile-time error.
  prefs: []
  type: TYPE_NORMAL
- en: Another great benefit of TypeScript is that it allows large teams to collaborate
    since it provides formal, verifiable naming. This way, it allows us to write easy-to-understand
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Better support by text editors and IDEs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of tools, such as Tern, that are trying to bring better autocompletion
    support for JavaScript in text editors and IDEs. However, as JavaScript is a dynamic
    language, it is impossible for the IDEs and text editors to make sophisticated
    suggestions without any metadata. Google Closure Compiler, for instance, uses
    type annotations provided in the JSDoc in order to provide static typing to the
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Annotating the code with such metadata is a built-in feature of TypeScript known
    as type annotations. Based on them, text editors and IDEs can perform a better
    static analysis on our code. This provides better refactoring tools and autocompletion,
    which increases our productivity and allows us to make fewer mistakes while writing
    the source code for our applications.
  prefs: []
  type: TYPE_NORMAL
- en: There's even more to TypeScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript by itself has a number of other benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**It is a superset of JavaScript**: All JavaScript programs (for example, ES5
    and ES2015) are already valid TypeScript ones. In essence, you have already been
    writing TypeScript code. Since it is based on the latest version of the ECMAScript
    standard, it allows us to take advantage of the latest bleeding-edge syntax provided
    by the language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supports optional type checking**: If, for any reason, we decide that we
    don''t want to explicitly define the type of a variable or a method, we can just
    skip the type definition. However, we should be aware that this means we are no
    longer taking advantage of the static typing, so we are giving up on all the benefits
    mentioned earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Developed and maintained by Microsoft**: The quality of the implementation
    of the language is very high, and it is unlikely that support will be dropped
    unexpectedly. TypeScript is based on the work of some of the world''s best experts
    in programming language development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It is open source**: This allows the community to freely contribute to the
    language and suggest features, which are discussed in an open manner. The fact
    that TypeScript is open source makes the development of third-party extensions
    and tools easier. This extends the scope of its usage even further.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since modern browsers do not support TypeScript natively, there is a compiler
    that translates the TypeScript code we write into readable JavaScript in a predefined
    target version of ECMAScript. Once the code is compiled, all the type annotations
    are removed.
  prefs: []
  type: TYPE_NORMAL
- en: Using TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start writing some TypeScript!
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will take a look at different snippets showing
    some of the features of TypeScript. In order to be able to run the snippets and
    play with them yourself, you'll need to install the TypeScript compiler on your
    computer. Let's take a look at how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript is best installed using **Node Package Manager** (**npm**). I'd recommend
    that you use npm's version 3.0.0 or newer. If you don't have node.js and npm installed
    already, you can visit [https://nodejs.org](https://nodejs.org) and follow the
    instructions there.
  prefs: []
  type: TYPE_NORMAL
- en: Installing TypeScript with npm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have npm installed and running, verify that you have the latest version
    by opening your terminal window and running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command in order to install TypeScript 2.1.0 or newer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will install the TypeScript compiler and add its executable
    (`tsc`) as global.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to verify that everything works properly, you can use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The output should be similar to the preceding one, though possibly with a different
    version.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we install TypeScript by prefixing the version with caret. This means
    that `npm` will download any version in the range 2.x.x, but below 3.0.0.
  prefs: []
  type: TYPE_NORMAL
- en: Running our first TypeScript program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s compile our first TypeScript program! Create a file called `hello.ts`
    and enter the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we''ve already installed the TypeScript compiler, you should have a global
    executable command called `tsc`. You can use it in order to compile the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you should see the file `hello.js` in the same directory where `hello.ts`
    is. `hello.js` is the output of the TypeScript compiler; it contains the JavaScript
    equivalent to the TypeScript you wrote. You can run this file using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you''ll see the string **Hello world!** printed on the screen. In order
    to combine the process of compiling and running the program, you can use the `ts-node` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You should see the same result, but without the `ts-node` file stored on the
    disk.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the code for this book at [https://github.com/mgechev/getting-started-with-angular](https://github.com/mgechev/getting-started-with-angular). Most
    code snippets have a comment as the first line, which shows where you can find
    the complete example in the directory structure of the samples repository. Note
    that the paths are relative to the `app` directory.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript syntax and features introduced by ES2015 and ES2016
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As TypeScript is a superset of JavaScript, before we start learning about its
    syntax, it'll be easier to start by introducing some of the bigger changes in
    ES2015 and ES2016; to understand TypeScript, we first must understand ES2015 and
    ES2016\. We will have a whistle-stop tour through these changes before diving
    into TypeScript properly later.
  prefs: []
  type: TYPE_NORMAL
- en: 'A detailed explanation of ES2015 and ES2016 is outside the scope of this book.
    In order to get familiar with all the new features and syntaxes, I strongly recommend
    that you take a look at *Exploring ES6: Upgrade to the next version of JavaScript*
    by *Dr. Axel Rauschmayer*.'
  prefs: []
  type: TYPE_NORMAL
- en: The next couple of pages will introduce new standards and allow you to take
    advantage of most of the features you will need during the development of Angular
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: ES2015 arrow functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript has first-class functions, which means that they can be passed around
    like any other value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax is great; however, it is a bit too verbose. ES2015 introduced a
    new syntax to define anonymous functions called the arrow function syntax. Using
    it, we can create anonymous functions, as seen in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, we got the total sum of the elements in the array `[1,
    2, 3]`. In the second example, we got all the even numbers inside the array `[3,
    1, 56, 7]`. In the third example, we sorted an array by the properties' `price`
    and `total` in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrow functions have a few more features that we need to look at. The most
    important feature is that they keep the context (`this`) from the surrounding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For example, when we invoke the `MyComponent` function with the operator `new`;
    this will point to the new object instantiated by the call. The arrow function
    will keep the context (`this`), in the callback of `setTimeout`, and print **43**
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: This is extremely useful in Angular since the binding context for a given component
    is its instance (that is, its `this` instance). If we define `MyComponent` as
    an Angular component and we have a binding to the `age` property, the preceding
    code will be valid and all the bindings will work (note that we don't have the
    scope, neither do we have explicit calls to the `$digest` loop, although we have
    called `setTimeout` directly).
  prefs: []
  type: TYPE_NORMAL
- en: Using the ES2015 and ES2016 classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When developers new to JavaScript hear that the language empowers the **object-oriented**
    (**OO**) paradigm, they're normally confused when they discover that there's no
    syntax for the definition of classes. This perception was born by the fact that
    some of the most popular programming languages, such as Java, C#, and C++, have
    the concept of classes used for the construction of objects. However, JavaScript
    implements the OO paradigm differently. JavaScript has a prototype-based, object-oriented
    programming model, where we can instantiate objects using the object literal syntax
    or functions (also known as the constructor functions), and we can take advantage
    of the inheritance using the so-called prototype chain.
  prefs: []
  type: TYPE_NORMAL
- en: Although this is a valid way to implement the OO paradigm, and the semantics
    are similar to the one in the classical object-oriented model, it is confusing
    for inexperienced JavaScript developers who are not sure how to process this properly.
    This is one of the reasons TC39 decided to provide an alternative syntax to use the
    object-oriented paradigm in the language. Behind the scenes, the new syntax has
    the same semantics as the one we're used to, like using the constructor functions
    and the prototype-based inheritance. However, it provides a more convenient syntax
    to empower the OO paradigm's features with less boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: ES2016 adds some extra syntax to the ES2015 classes, such as static and instance
    property declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that demonstrates the syntax used to define the classes
    in ES2016:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In ES2015, the explicit declaration of the `_name` property is not required;
    however, since the TypeScript compiler should be aware during compile time of
    the existing properties of the instances of a given class, we would need to add
    the declaration of the property to the class declaration itself.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding snippet is both a valid TypeScript and JavaScript code. In it,
    we defined a class called `Human`, which adds a single property to the objects
    instantiated by it. It does this by setting the property's value to the value
    of the parameter `name` passed to its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `ch3/es6-classes/sample-classes.ts` file and play around with
    it! You can create different instances of the classes in the same way you create
    objects using constructor functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to execute the code, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Classes are commonly used in Angular. You can use them to define your components,
    directives, services, and pipes. However, you can also use the alternative ES5
    syntax, which takes advantage of the constructor functions. Under the hood, once
    the TypeScript code is compiled, there would be no such significant difference
    between both the syntaxes, because the ES2015 classes are being transpiled to
    constructor functions anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Defining variables with block scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another confusing point of JavaScript for developers with a different background
    is the variable scope in the language. In Java and C++, for example, we're used
    to the block lexical scope. This means that a given variable defined inside a
    specific block will be visible only inside that block and all of the nested blocks
    inside of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in JavaScript, things are a little bit different. ECMAScript defines
    a functional lexical scope that has similar semantics to the block lexical scope,
    but it uses functions instead of blocks. Lets take a look at the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This has some weird implications. Once the code is executed, it will log five
    times the number `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES2015 added a new syntax to define variables with block scope visibility.
    The syntax is similar to the current one, however, instead of `var`, it uses the
    keyword `let`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Meta-programming with ES2016 decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript is a dynamic language that allows us to easily modify and/or alter
    the behavior to suit the programs we write. Decorators are a proposal to ES2016,
    which according to the design document [https://github.com/wycats/javascript-decorators](https://github.com/wycats/javascript-decorators):'
  prefs: []
  type: TYPE_NORMAL
- en: '*"...make it possible to annotate and modify classes and properties at design
    time."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Their syntaxes are quite similar to the annotations in Java, and they are even
    closer to the decorators in Python. ES2016 decorators are used commonly in Angular
    to define components, directives, and pipes, and to take advantage of the dependency
    injection mechanism of the framework. Most use cases of decorators involve altering
    the behavior to a predefined logic or adding some metadata to different constructs.
  prefs: []
  type: TYPE_NORMAL
- en: ES2016 decorators allow us to do a lot of fancy things by changing the behavior
    of our programs. Typical use cases could be to annotate the given methods or properties
    as deprecated or read-only. A set of predefined decorators that can improve the
    readability of the code we produce can be found in a project by *Jay Phelps* called
    *core-decorators.js*. Another use case is taking advantage of the proxy-based,
    aspect-oriented programming using a declarative syntax. The library providing
    this functionality is *aspect.js*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, ES2016 decorators are just another syntax sugar, which translates
    to JavaScript code we''re already familiar with from the previous versions of
    the language. Let''s take a look at a simple example from the proposal''s draft:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we have an ES2015 class called `Person` with a single getter
    called `kidCount`. Over the `kidCount` getter, we have applied the `@nonenumerable`
    decorator. The decorator is a function that accepts a target (the `Person` class),
    the name of the target property we intend to decorate (`kidCount`), and the descriptor
    of the target property. After we change the descriptor, we need to return it in
    order to apply the modification. Basically, the decorator''s application could
    be translated into ECMAScript 5 in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Using configurable decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is an example of using the decorators defined by Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When decorators accept arguments (just like `Component` in the preceding example),
    they need to be defined as functions that accept arguments and return the actual
    decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we defined a function `Component` that accepts a single argument
    called `config` and returns a decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Writing modular code with ES2015
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another problem that JavaScript professionals have experienced over the years
    is the lack of a module system in the language. Initially, the community developed
    different patterns, aiming to enforce the modularity and the encapsulation of
    the software we produce. Such patterns included the module pattern, which takes
    advantage of the functional lexical scope and closures. Another example is the
    namespace pattern, which represents the different namespaces as nested objects.
    AngularJS introduced its own module system that unfortunately doesn't provide
    features, such as lazy module loading. However, these patterns were more like
    workarounds rather than real solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '**CommonJS** (used in node.js) and **AMD** (**Asynchronous Module Definition**)
    were later invented. They are still widely used today and provide features such
    as handling of circular dependencies, asynchronous module loading (in AMD), and
    so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'TC39 took the best of the existing module systems and introduced this concept
    on a language level. ES2015 provides two APIs to define and consume modules. They
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Declarative API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imperative API using a module loader.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular takes full advantage of the ES2015 module system, so let's dive into
    it! In this section, we will take a look at the syntax used for the declarative
    definition and consumption of modules. We will also take a peek at the module
    loader's API in order to see how we can programmatically load modules in an explicit
    asynchronous manner.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ES2015 module syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we defined a simple ES2015 module in the `math.ts` file.
    We can think of it as a sample math Angular utility module. Inside it, we define
    and export the `square` and `log10` functions and the constant `PI`. The `const`
    keyword is another keyword brought by ES2015 that is used to define constants.
    As you can see, what we do is nothing more than prefixing the function''s definitions
    with the keyword `export`. If we want to export the entire functionality in the
    end and skip the duplicate explicit usage of `export`, we can use the following
    approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax on the last line is nothing more than an enhanced object literal
    syntax, introduced by ES2015\. Now, let''s take a look at how we can consume this
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As an identifier of the module, we use its relative path to the current file.
    Using destructuring, we import the required functions – in this case, `square`
    and `log10`.
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of the modules' implicit asynchronous behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to note that the ES2015 module syntax has implicit asynchronous
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '![Taking advantage of the modules'' implicit asynchronous behavior](img/2-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we have modules `A`, `B`, and `C`. Module `A` uses
    modules `B` and `C`, so it depends on them. Once the user requires module `A`,
    the JavaScript module loader would need to load modules `B` and `C` before being
    able to invoke any of the logic that resides in module `A` because of the dependencies
    they have. Modules `B` and `C` will be loaded asynchronously. Once they are loaded
    completely, the JavaScript virtual machine will be able to execute module `A`.
  prefs: []
  type: TYPE_NORMAL
- en: Using aliases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another typical situation is when we want to use an alias for a given export.
    For example, if we use a third-party library, we may want to rename any of its
    exports in order to escape name collisions or just to have a more convenient naming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Importing all the module exports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can import the entire `math` module using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The semantics behind this syntax is quite similar to CommonJS, although, in
    the browser, we have implicit asynchronous behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Default exports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a given module defines an export, which would quite likely be used by any
    of its consumer modules, we can take advantage of the default export syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to consume this module, we can use the following `app.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if we want to import the default export and perform some other
    exports, we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, the default export is nothing more than a named export named with
    the reserved word `default`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: ES2015 module loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The new version of the standard defines a programmatic API to work with modules.
    This is the so-called module loader API. It allows us to define and import modules,
    or configure the module loading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose we have the following module definition in the file `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'From the `init.js` file, we can programmatically load the `app` module and
    invoke its `main` function using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The global object `System` has a method called `import` that allows us to import
    modules using their identifier. In the preceding snippet, we import the module
    `app` defined in `app.js`. `System.import` returns a promise that could be resolved
    on success or rejected in case of an error. Once the promise is resolved as the
    first parameter of the callback passed to `then`, we will get the module instance.
    The first parameter of the callback registered in case of rejection is an object
    representing the error that happened.
  prefs: []
  type: TYPE_NORMAL
- en: The code from the last snippet does not exist in the GitHub repository since
    it requires some additional configuration. We will apply the module loader more
    explicitly in the Angular examples in the later chapters of the book.
  prefs: []
  type: TYPE_NORMAL
- en: ES2015 and ES2016 recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! We're more than halfway toward learning TypeScript. All the
    features we just saw are a part of TypeScript since it implements a superset of
    JavaScript; since all these features are an upgrade on top of the current syntax,
    they are easy for experienced JavaScript developers to grasp.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we will describe all the amazing features of TypeScript
    that are outside the intersection with ECMAScript.
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of static typing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static typing is what can provide better tooling for our development process.
    While writing JavaScript, the most that IDEs and text editors can do is syntax
    highlight and provide some basic autocompletion suggestions based on sophisticated
    static analysis of our code. This means that we can only verify that we haven't
    made any typos by running the code.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous sections, we described only the new features provided by ECMAScript
    expected to be implemented by browsers in the near future. In this section, we
    will take a look at what TypeScript provides in order to help us be less error-prone
    and more productive. At the time of writing this book, there were no plans to
    implement built-in support for static typing in the browsers.
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript code goes through intermediate preprocessing that performs the
    type checking and drops all the type annotations in order to provide valid JavaScript
    supported by modern browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Using explicit type definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like Java and C++, TypeScript allows us to explicitly declare the type
    of the given variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line defines the variable `foo` in the current block using the
    `let` syntax. We explicitly declare that we want `foo` to be of the type `number`
    and we set the value of `foo` to `42`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to change the value of `foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, after the declaration of `foo`, we will set its value to the string `''42''`.
    This is a perfectly valid JavaScript code; however, if we compile it using the
    TypeScript''s compiler, we will get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `foo` is associated with the given type, we cannot assign it values belonging
    to different types. This is one of the reasons we can skip the explicit type definition
    in case we assign a value to the given variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The semantics of this code will be the same as the one with the explicit type
    definition because of the type inference of TypeScript. We'll further take a look
    at it at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The type any
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All the types in TypeScript are subtypes of a type called `any`. We can declare
    variables belonging to the `any` type using the `any` keyword. Such variables
    can hold the value of any type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a valid TypeScript, and it will not throw any error during
    compilation or runtime. If we use the type `any` for all of our variables, we
    will be basically writing the code with dynamic typing, which drops all the benefits
    of the TypeScript's compiler. That's why we have to be careful with `any` and
    use it only when it is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the other types in TypeScript belong to one of the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Primitive types**: These include Number, String, Boolean, Void, Null, Undefined,
    and Enum types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Union types**: These types are out of the scope of this book. You can take
    a look at them in the specification of TypeScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object types**: These include Function types, classes and interface type
    references, array types, tuple types, function types, and constructor types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type parameters**: These include Generics that will be described in the *Writing
    generic code by using type parameters* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Primitive types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the primitive types in TypeScript are the ones we are already familiar
    with in JavaScript: Number, String, Boolean, Null, and Undefined. So, we will
    skip their formal explanation here. Another set of types that is handy while developing
    Angular applications is the Enum types defined by users.'
  prefs: []
  type: TYPE_NORMAL
- en: The Enum types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Enum types are primitive user-defined types that, according to the specification,
    are subclasses of Number. The concept of enums exists in the Java, C++, and C#
    languages, and it has the same semantics in TypeScript-user-defined types consisting
    of sets of named values called elements. In TypeScript, we can define an enum using
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be translated to the following JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the enum type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Understanding the Object types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will take a look at the Array types and Function types,
    which belong to the more generic class of Object types. We will also explore how
    we can define classes and interfaces. Tuple types were introduced by TypeScript
    1.3, and their main purpose is to allow the language to begin typing the new features
    introduced by ES2015, such as destructuring. We will not describe them in this
    book. For further reading, you can take a look at the language's specification
    at [http://www.typescriptlang.org](http://www.typescriptlang.org).
  prefs: []
  type: TYPE_NORMAL
- en: The Array types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In TypeScript, arrays are JavaScript arrays with a common element type. This
    means that we cannot have elements from different types in a given array. We have
    different array types for all the built-in types in TypeScript, plus all the custom
    types that we define.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define an array of numbers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to have an array, which seems heterogeneous, similar to the arrays
    in JavaScript, we can use the type reference to `any`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is possible since the types of all the values we're pushing to the array
    are subtypes of the `any` type and the array we've declared contains values of
    the type `any`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the array methods we''re familiar with in JavaScript with all the
    TypeScript Array types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have the square-brackets operator that gives us random access to the
    array''s elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The Function types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''re already familiar with how to define a new function in JavaScript. We
    can use function expression or function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use the new arrow function syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing TypeScript alters is the feature to define the types of the
    function''s arguments and the type of its return result (i.e. the function''s
    signature). After the compiler of the language performs its type checking and
    transpilation, all the type annotations will be removed. If we use function expression
    and assign a function to a variable, we will be able to define the variable type
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to define a method in an object literal, we can do it in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we defined an object literal with method called `squareRoot`
    using the ES2015 syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case we want to define a function that produces some side effects instead
    of returning a result, we can declare it''s return type as `void`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Defining classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript classes are similar to what ES2015 offers. However, it alters the
    type declarations and adds more syntax sugar. For example, let''s take the `Human`
    class we defined earlier and make it a valid TypeScript class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no difference between the current TypeScript definition with the one
    we already introduced; however, in this case, the declaration of the `_name` property
    is mandatory. Here is how we can use the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Using access modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similarly, for most conventional object-oriented languages that support classes,
    TypeScript allows a definition of access modifiers. In order to deny direct access
    to the `_name` property outside the class it is defined in, we can declare it
    as private:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The supported access modifiers by TypeScript are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Public**: All the properties and methods declared as public can be accessed
    from anywhere.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private**: All the properties and methods declared as private can be accessed
    only from inside the class'' definition itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protected**: All the properties and methods declared as protected can be
    accessed from inside the class'' definition or the definition of any other class
    extending the one that owns the property or the method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Access modifiers are a great way to implement Angular services with good encapsulation
    and a well-defined interface. In order to understand it better, let''s take a
    look at an example using the class'' hierarchy defined earlier, which is ported
    to TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Just like ES2015, TypeScript supports the `extends` keyword and desugars it
    to the prototypal JavaScript inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we set the access modifiers of the `name` and `age`
    properties directly inside the constructor function. The semantics behind this
    syntax differs from the one used in the previous example. It has the following
    meaning: define a protected property called `name` of the type `string` and assign
    the first value passed to the constructor call to it. It is the same for the private
    `age` property. This saves us from explicitly setting the value in the constructor
    itself. If we take a look at the constructor of the `Developer` class, we can
    see that we can use the mixture between these syntaxes. We can explicitly define
    the property in the constructor''s signature, or we can only define that the constructor
    accepts a parameters of the given types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a new instance of the `Developer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'During compilation, TypeScript will throw an error telling us that: **Property
    languages is private and only accessible inside the class "Developer"**. Now,
    let''s see what will happen if we create a new `Human` class and try to access
    its properties from outside its definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we''ll get the following two errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Property age is private and is only accessible inside the class "Human"**,
    and the **Property name is a protected and only accessible inside class "Human"
    and its subclasses**.'
  prefs: []
  type: TYPE_NORMAL
- en: However, if we try to access the `_name` property from inside the definition
    of `Developer`, the compiler won't throw any errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get a better sense of what the TypeScript compiler will produce
    out of a type-annotated class, let''s take a look at the JavaScript produced by
    the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting ECMAScript 5 will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The defined property is added directly to the objects instantiated by calling
    the constructor function with the operator `new`. This means that once the code
    is compiled, we can directly access the private members of the created objects.
    In order to wrap this up, access modifiers are added in the language in order
    to help us enforce better encapsulation and get compile-time errors in case we
    violate it.
  prefs: []
  type: TYPE_NORMAL
- en: Defining interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Subtyping** in programming languages allows us to treat objects in the same
    way based on the observation that they are specialized versions of a generic object.
    This doesn''t mean that they have to be instances of the same class of objects,
    or that they have a complete intersection between their interfaces. The objects
    might have only a few common properties and still be treated the same way in a
    specific context. In JavaScript, we usually use duck typing. We may invoke specific
    methods for all the objects passed to a function based on the assumption that
    these methods exist. However, all of us have experienced the ***undefined is not
    a function*** error thrown by the JavaScript interpreter.'
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming and TypeScript come with a solution. They allow
    us to make sure that our objects have similar behavior if they implement interfaces
    that declare the subset of the properties they own.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can define our interface `Accountable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can make sure that both `Individual` and `Firm` implement this interface
    by performing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In case we implement a given interface, we need to provide an implementation
    for all the methods defined inside it, otherwise, the TypeScript compiler will
    throw an error. The methods we implement must have the same signature as the ones
    declared in the interface definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript interfaces also support properties. In the `Accountable` interface,
    we can include a field called `accountNumber` with a type of string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We can define it in our class as a field or a getter.
  prefs: []
  type: TYPE_NORMAL
- en: Interface inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Interfaces may also extend each other. For example, we may turn our `Individual`
    class into an interface that has a social security number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Since interfaces support multiple inheritances, `Individual` may also extend
    the interface `Human` that has the `name` and `age` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Implementing multiple interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In case the class''s behavior is a union of the properties defined in a couple
    of interfaces, it may implement all of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we need to provide the implementation of all the methods declared
    inside the interfaces our class implements, otherwise, the compiler will throw
    a compile-time error.
  prefs: []
  type: TYPE_NORMAL
- en: Further expressiveness with TypeScript decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In ES2015, we are able to decorate only classes, properties, methods, getters,
    and setters. TypeScript takes this further by allowing us to decorate functions
    or method parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that the parameter decorators should not alter any additional behavior.
    Instead, they are used to generate metadata. The most typical use case of these
    decorators is the dependency injection mechanism of Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Writing generic code by using type parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the beginning of the section on using static typing, we mentioned the type
    parameters. In order to get a better understanding of them, let''s begin with
    an example. Let''s suppose that we want to implement the classical data structure
    `BinarySearchTree`. Let''s define its interface using a class without applying
    any method implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we defined a class called `Node`. The instances of
    this class represent the individual nodes in our tree. Each `node` has a left
    and a right child node and a value of the type `any`; we use `any` in order to
    be able to store data of any type inside our nodes and respectively inside `BinarySearchTree`.
  prefs: []
  type: TYPE_NORMAL
- en: Although the earlier implementation looks reasonable, we're giving up on using
    the most important feature that TypeScript provides, that is, static typing. Using
    `any` as a type of the value field inside the `Node` class, we can't take complete
    advantage of the compile-time type checking. This also limits the features that
    IDEs and text editors provide when we access the `value` property of the instances
    of the `Node` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript comes with an elegant solution that is already widely popular in
    the world of static typing-type parameters. Using generics, we can parameterize
    the classes we create with the type parameters. For example, we can turn our `Node`
    class into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '`Node<T>` indicates that this class has a single type parameter called `T`
    that is used somewhere inside the class''s definition. We can use `Node` by performing
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we created three nodes: `numberNode`, `stringNode`,
    and another node of the type `Node<number>`, assigning its value to the right
    child of `numberNode`. Note that since `numberNode` is of the type `Node<number>`,
    we can set its value to `42`, but we can''t use the string `''42''`. The same
    is applicable to its left child. In the definition, we''ve explicitly declared
    that we want the left and right children to be of the type `Node<number>`. This
    means that we cannot assign values of the type `Node<string>` to them; that''s
    why, we get the second compile-time error.'
  prefs: []
  type: TYPE_NORMAL
- en: Using generic functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another typical use of generics is for defining functions that operate over
    a set of types. For example, we may define an `identity` function that accepts
    an argument of type `T` and returns it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in some cases, we may want to use only the instances of the types
    that have some specific properties. For achieving this, we can use an extended
    syntax that allows us to declare that we want the types used as type parameters
    to be subtypes of given type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: For example, here, we defined an interface called `Comparable`. It has a single
    operation called `compare`. The classes that implement the `Comparable` interface
    need to implement the `compare` operation. When `compare` is called with a given
    argument, it returns `1` if the target object is bigger than the passed argument,
    `0` if they are equal, and `-1` if the target object is smaller than the passed
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: Having multiple type parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript allows us to use multiple type parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we can create an instance of the class `Pair<K, V>` using the
    following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Writing less verbose code with TypeScript's type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static typing has a number of benefits; however, it makes us write a more verbose
    code by adding all the type annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, the TypeScript''s compiler is able to guess the types of expressions
    inside our code; let''s consider this example, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we defined a variable `answer` and assigned the value
    `42` to it. Since TypeScript is statically typed and the type of a variable cannot
    change once declared, the compiler is smart enough to guess that the type of `answer`
    is `number`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we don''t assign a value to a variable within its definition, the compiler
    will set its type to `any`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet will compile without any compile-time errors.
  prefs: []
  type: TYPE_NORMAL
- en: Best common type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, the type inference could be a result of several expressions. Such
    is the case when we assign a heterogeneous array to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the type of `x` will be `any[]`. However, suppose we have the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The type of `x` will then be `number[]` since the type `Number` is a subtype
    of `Null`.
  prefs: []
  type: TYPE_NORMAL
- en: Contextual type inference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Contextual typing occurs when the type of an expression is implied from its
    location; let''s take this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the type of the argument of the callback `e` is *guessed* by the
    compiler based on the context in which it is used. The compiler understands that
    the type of `e` is based on the call of `addEventListener` and the arguments passed
    to the method. In case we were using a keyboard event (`keydown`, for example),
    TypeScript would have been aware that `e` is of the type `KeyboardEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference is a mechanism that allows us to write less verbose code by taking
    advantage of the static analysis performed by TypeScript. Based on the context,
    TypeScript's compiler is able to guess the type of a given expression without
    explicit definition.
  prefs: []
  type: TYPE_NORMAL
- en: Using ambient type definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although static typing is amazing, most of the frontend libraries we use are
    built with JavaScript, which is dynamically typed. Since we'd want to use TypeScript
    in Angular, not having type definitions in the code that uses external JavaScript
    libraries is a big issue; it prevents us from taking advantage of the compile-time
    type checking.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript was built keeping these points in mind. In order to allow the TypeScript
    compiler to take care of what it does best, we can use the so-called ambient type
    definitions. They allow us to provide external type definitions of the existing
    JavaScript libraries. This way, they provide hints to the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Using predefined ambient type definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fortunately, we don't have to create ambient type definitions for all JavaScript
    libraries and frameworks we use. The community and/or the authors of these libraries
    have already published such definitions online; the biggest repository resides
    at [https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped). During
    the last couple of months, the community developed a few tools for managing ambient
    type definitions, such as `tsd` and `typings`.
  prefs: []
  type: TYPE_NORMAL
- en: Later, Microsoft introduced an official way to manage them, using **`npm`**
     by providing an additional configuration in `tsconfig.json`. The type definitions
    are now distributed as scoped packages under the namespace `@types` and installed
    in `node_modules`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a directory and add a `package.json` file to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'After we provide the default values for the questions that `npm` asks us, our
    `package.json` in the `types-test` directory should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We can install new type definition using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will download the type definitions for AngularJS and save
    them in `node_modules/@types/angular`. Note that we provided the `--save-dev`
    flag to `npm` in order to save the type definition under `devDependencies` of
    `package.json`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When installing ambient type definitions we would usually use `--save-dev` instead
    of `--save`, because the definitions are mostly used in development.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the preceding command, your `package.json` file should look similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in order to use AngularJS with TypeScript, create `app.ts` and enter the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile `app.ts`, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The TypeScript compiler will output the compiled content into `app.js`. In order
    to add extra automation and invoke the TypeScript compiler each time you change
    any of the files in your project, you can use a task runner, such as gulp or grunt,
    or pass the `-w` option to `tsc`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since using the `reference` element for including type definitions is considered
    bad practice, we can use a `tsconfig.json` file instead. There, we can configure
    which directories need to be included in the compilation process by `tsc`. For
    more information, visit [http://www.typescriptlang.org/docs/handbook/tsconfig-json.html](http://www.typescriptlang.org/docs/handbook/tsconfig-json.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a file called `tsconfig.json` in the same directory, with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: In this configuration file, we provide the `compilerOptions` property so that
    we don't have to pass parameters, such as `outDir` and `module` formats, as flags
    to `tsc`. Note that in the `files` property, we also list the files that we want
    to be compiled. TypeScript will compile all of them plus all their transitive
    dependencies!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s modify our preceding simple snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The only change we made was to add the line where we declare and initialize
    a new constant with the returned result by the invocation of the `Set` constructor
    function, with `any` as the type parameter. By having `tsconfig.json` in the same
    directory where our `app.ts` file and `node_modules` are, we can compile the project
    by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we''ll get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '**demo.ts(4,22): error TS2304: Cannot find name ''Set''.**'
  prefs: []
  type: TYPE_NORMAL
- en: '`Set` implements the set data structure and is part of the ES2015 standard.
    Since using the ambient type definitions for ES2015 is a very common practice
    in all TypeScript projects, Microsoft added them as part of TypeScript itself.
    To the `compilerOptions` property inside `tsconfig.json`, add the following `lib`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '`lib` has value an array, which includes both `"es2015"` and `"dom"` because
    we need ES2015 Set, and Angular''s type definitions require the type definitions
    for the **Document Object Model** (**DOM**). Now when you run `tsc` in the directory
    where your `tsconfig.json` file is located, the compilation process should pass
    successfully and the output file should be located in `./dist/demo.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom ambient type definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how everything works together, let''s take a look at an example.
    Suppose we have the following interface of a JavaScript library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We have an object literal assigned to a variable called `DOM`. The object has
    the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`selectElements`: This accepts a single argument with type string and returns
    a set of `DOM` elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hide`: This accepts a `DOM` node as an argument and returns nothing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show`: This accepts a `DOM` node as an argument and returns nothing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In TypeScript, the preceding definition would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that we can define our library''s interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have the interface of our library, it will be easy to create the ambient
    type definition; we just have to create a file with an extension `d.ts` called
    `dom` and enter the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we defined the interface called `DOMLibraryInterface`
    and declared the `DOM` variable of the type `DOMLibraryInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing left before being able to use static typing with our JavaScript
    library is including the external type definition in the script files we want
    to use our library in. We can do it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet hints the compiler on where to find the ambient type definitions.
    An alternative, and better, way to provide a reference to the `d.ts` file is to
    use `tsconfig.json` as described above.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we peeked at the TypeScript language that is used for the implementation
    of Angular. Although we can develop our Angular applications using ECMAScript
    5, Google's recommendation is to use TypeScript in order to take advantage of
    the static typing it provides.
  prefs: []
  type: TYPE_NORMAL
- en: While exploring the language, we looked at some of the core features of ES2015
    and ES2016\. We explained the ES2015 and ES2016 classes, arrow functions, block
    scope variable definitions, destructuring, and modules. Since Angular takes advantage
    of the ES2016 decorators, and more accurately their extension in TypeScript, a
    section was dedicated to them.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we took a look at how we can take advantage of static typing using
    explicit type definitions. We described some of the built-in types in TypeScript
    and how we can define classes in the language by specifying access modifiers for
    their members. Our next stop was the interfaces. We ended our adventures in TypeScript
    by explaining the type parameters and the ambient type definitions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start exploring Angular in depth using the framework's
    components and directives.
  prefs: []
  type: TYPE_NORMAL
