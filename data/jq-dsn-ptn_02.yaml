- en: Chapter 2. The Observer Pattern
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. 观察者模式
- en: In this chapter, we will showcase the Observer Pattern and the convenient way
    in which we can utilize it in our pages using jQuery. Later on, we will also explain
    the Delegated Event Observer Pattern variant, which when properly applied to web
    pages can lead to code simplifications and also lessen the memory consumption
    that a page requires.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示观察者模式以及我们如何使用 jQuery 在我们的页面中方便地利用它。随后，我们还将解释委托事件观察者模式的变体，当正确应用于网页时，可以简化代码并减少页面所需的内存消耗。
- en: 'In this chapter, we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Introduce the Observer Pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍观察者模式
- en: See how the Observer Pattern is used by jQuery
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看 jQuery 如何使用观察者模式
- en: Compare the Observer Pattern with using the event attributes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将观察者模式与使用事件属性进行比较
- en: Learn how to avoid memory leaks from observers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何避免观察者引起的内存泄漏
- en: Introduce the Delegated Event Observer Pattern and showcasing its benefits
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍委托事件观察者模式并展示其好处
- en: Introducing the Observer Pattern
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍观察者模式
- en: The key concept of the Observer Pattern is that there is an object, often referred
    to as the observable or the subject, whose internal state changes during its lifetime.
    There are also several other objects, referred as the observers, that want to
    be notified in the event that the state of the observable/subject changes, in
    order to execute some operations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式的关键概念是有一个对象，通常称为可观察对象或主体，在其生命周期内其内部状态会发生变化。还有其他几个对象，被称为观察者，它们希望在可观察对象/主体的状态发生变化时被通知，以执行一些操作。
- en: The observers may need to be notified about any kind of state change of the
    observable or only specific types of changes. In the most common implementation,
    the observable maintains a list with its observers and notifies them when an appropriate
    state change occurs. In case a state change occurs to the observable, it iterates
    through the list of observers that are interested for that type of state change
    and executes a specific method that they have defined.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者可能需要被通知关于可观察对象的任何状态改变，或者仅特定类型的改变。在最常见的实现中，可观察对象维护一个观察者列表，并在适当的状态改变发生时通知它们。如果可观察对象发生状态改变，它会遍历对那种类型的状态改变感兴趣的观察者列表，并执行它们定义的特定方法。
- en: '![Introducing the Observer Pattern](img/00007.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![介绍观察者模式](img/00007.jpeg)'
- en: According to the definition of the Observer Pattern and the reference implementation
    in Computer Science books, the observers are described as objects that implement
    a well-known programming interface, in most cases, specific to each observable
    they are interested in. In the case of a state change, the observable will execute
    the well-known method of each observer as it is defined in the programming interface.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 根据观察者模式的定义和计算机科学书籍中的参考实现，观察者被描述为实现了众所周知的编程接口的对象，大多数情况下，该接口对于它们感兴趣的每个可观察对象都是特定的。在状态改变的情况下，可观察对象将执行每个观察者的众所周知方法，因为它在编程接口中被定义。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on how the Observer Pattern is used in traditional, object-oriented
    programming, you can visit [http://www.oodesign.com/observer-pattern.html](http://www.oodesign.com/observer-pattern.html).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在传统的面向对象编程中如何使用观察者模式的更多信息，您可以访问 [http://www.oodesign.com/observer-pattern.html](http://www.oodesign.com/observer-pattern.html)。
- en: In the web stack, the Observer Pattern often uses plain anonymous callback functions
    as observers instead of objects with well-known methods. An equivalent result,
    as defined by the Observer Pattern, can be achieved since the callback function
    keeps references to the variables of the environment that it was defined in—a
    pattern commonly referenced as a **Closure**. The main benefit of using the Observer
    Pattern over callbacks as invocation or initialization parameters is that the
    Observer Pattern can support several independent handlers on a single target.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 堆栈中，观察者模式通常使用普通的匿名回调函数作为观察者，而不是具有众所周知方法的对象。可以通过等效结果实现观察者模式，因为回调函数保留了对其定义所在环境的变量的引用——这种模式通常被称为**闭包**。使用观察者模式而不是回调作为调用或初始化参数的主要优点是观察者模式可以支持单个目标上的几个独立处理程序。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on closures, you can visit [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有关闭包的更多信息，您可以访问 [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)。
- en: Tip
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Defining a simple callback**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义简单回调**'
- en: A callback can be defined as a function that is passed as an argument to another
    function/method or is assigned to a property of an object and expected to be executed
    at some later point of time. In this way, the piece of code that was handed our
    callback will invoke or call it, propagating the results of an operation or event
    back to the context where the callback was defined.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 回调可以定义为作为另一个函数/方法的参数传递或分配给对象的属性，并且期望在稍后的某个时间点执行的函数。通过这种方式，将我们的回调交给的代码将调用它，将操作或事件的结果传播回定义回调的上下文。
- en: Since the pattern of registering functions as observers has proven to be more
    flexible and straightforward to program, it can be found in programming languages
    outside the web stack as well. Other programming languages provide an equivalent
    functionality through language features or special objects such as subroutines,
    lambda expressions, blocks, and function pointers. For example, Python also defines
    functions as first-class objects such as JavaScript, enabling them to be used
    as callbacks, while C# defines Delegates as a special object type in order to
    achieve the same result.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于将函数注册为观察者的模式被证明更灵活和更简单直接的编程，它在网页堆栈之外的编程语言中也可以找到。其他编程语言通过语言特性或特殊对象（如子例程、lambda表达式、块和函数指针）提供了等效的功能。例如，Python也像JavaScript一样将函数定义为一等对象，使它们能够被用作回调函数，而C#则定义了委托作为特殊对象类型，以实现相同的结果。
- en: The Observer Pattern is an integral part of developing web interfaces that respond
    to user actions, and every web developer has used it to some degree, even without
    noticing it. This is because the first thing that a web developer needs to do
    while creating a rich user interface is to add event listeners to page elements
    and define how the browser should respond to them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式是开发响应用户操作的Web界面的一个组成部分，每个Web开发人员都在某种程度上使用它，即使在不知情的情况下也是如此。这是因为创建丰富用户界面时，Web开发人员需要做的第一件事是向页面元素添加事件侦听器，并定义浏览器应该如何响应它们。
- en: This is traditionally achieved by using the `EventTarget.addEventListener()`
    method on the page elements that we need to listen to for events such as a "click",
    and providing a callback function with the code that needs to be executed when
    that event occurs. It is worth mentioning that in order to support older versions
    of Internet Explorer, testing for the existence of `EventTarget.attachEvent()`,
    and using that instead, is required.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，这是通过在需要监听事件的页面元素上使用`EventTarget.addEventListener()`方法实现的，例如“点击”，并提供一个回调函数，其中包含需要在事件发生时执行的代码。值得一提的是，为了支持旧版本的Internet
    Explorer，需要测试`EventTarget.attachEvent()`的存在，并使用它来代替。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the `addEventListener()` and `attachEvent()` methods,
    you can visit [https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)
    and [https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/attachEvent](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/attachEvent).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`addEventListener()`和`attachEvent()`方法的更多信息，您可以访问[https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)和[https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/attachEvent](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/attachEvent)。
- en: How it is used by jQuery
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery如何使用它
- en: The jQuery library heavily uses the Observer Pattern in several parts of its
    implementation, either directly by using the `addEventListener` method or creating
    its own abstraction over it. Moreover, jQuery offers a series of abstractions
    and convenient methods to make working with the Observer Pattern easier on the
    web and also uses some of them internally to implement other methods as well.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery库在其实现的几个部分中大量使用观察者模式，直接使用`addEventListener`方法或创建其自己的抽象来实现。此外，jQuery提供了一系列抽象和方便的方法，使在Web上使用观察者模式变得更容易，并且还在内部使用其中一些方法来实现其他方法。
- en: The jQuery on method
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: jQuery的on方法
- en: The `jQuery.fn.on()` method is the central jQuery method for attaching event
    handlers to elements, providing an easy way to adopt the Observer Pattern, while
    keeping our code easy to read and reason. It attaches the requested event handler
    over all the elements of a composite jQuery collection object returned by the
    `$()` function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`jQuery.fn.on()`方法是将事件处理程序附加到元素的中央jQuery方法，提供了一种简单的方法来采用观察者模式，同时保持我们的代码易于阅读和理解。它将所请求的事件处理程序附加到由`$()`函数返回的复合jQuery集合对象的所有元素上。'
- en: 'Searching for `jQuery.fn.on` in jQuery''s Source Viewer (which is available
    at [http://james.padolsey.com/jquery](http://james.padolsey.com/jquery)), or directly
    searching jQuery''s source code for `on: function` (the first character is a tab),
    will lead us to the method''s definition, which counts 67 lines of code. Actually,
    the first 55 lines of the internal `on` function are just handling all the different
    ways that the `jQuery.fn.on()` method can be invoked; near its end, we can see
    that it actually uses the internal method `jQuery.event.add()`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '在 jQuery 源码查看器中搜索 `jQuery.fn.on`（可在 [http://james.padolsey.com/jquery](http://james.padolsey.com/jquery)
    找到），或直接在 jQuery 源代码中搜索 `on: function`（第一个字符是制表符），将引导我们找到方法的定义，代码共有 67 行。事实上，在内部
    `on` 函数的前 55 行只是处理 `jQuery.fn.on()` 方法可以被调用的不同方式；接近末尾，我们能看到它实际上使用了内部方法 `jQuery.event.add()`：'
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, let's see how the Observer Pattern is implemented by `jQuery.event.add()`,
    by referring to the preceding highlighted code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过引用前面高亮的代码，了解 `jQuery.event.add()` 如何实现观察者模式。
- en: The `handler` variable in the arguments of the `jQuery.event.add()` method stores
    the function that was originally passed as an argument to the `jQuery.fn.on()`
    method. We can refer to this function as our observer function, since it is executed
    when the appropriate event fires on the element that it was attached to.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`jQuery.event.add()` 方法的参数中的 `handler` 变量存储最初作为参数传递给 `jQuery.fn.on()` 方法的函数。我们可以称这个函数为我们的观察器函数，因为它在附加到的元素上触发相应事件时被执行。'
- en: In the first highlighted code area, jQuery creates and assigns a `guid` property
    to the observer function that is stored in the `handler` variable. Keep in mind
    that assigning properties to functions is possible in JavaScript, since functions
    are first-class objects. The `jQuery.guid++` statement is executed right after
    the assignment of the old value and is required since `jQuery.guid` is a page-wide
    counter used by jQuery and jQuery plugins internally. The `guid` property on the
    observer function is used as a way to identify and locate the observer function
    inside the observer list that jQuery has for each element. For example, it is
    used by the `jQuery.fn.off()` method to locate and remove an observer function
    from the observer list associated with an element.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个高亮的代码区域中，jQuery 创建并给存储在 `handler` 变量中的观察器函数分配了一个 `guid` 属性。记住，在 JavaScript
    中，可以给函数赋值属性，因为函数是一流对象。`jQuery.guid++` 语句在分配旧值之后执行，这是因为 `jQuery.guid` 是 jQuery
    和 jQuery 插件在内部使用的全局计数器。观察器函数上的 `guid` 属性用作标识和定位 jQuery 为每个元素维护的观察器函数列表中的观察器函数的一种方式。例如，`jQuery.fn.off()`
    方法使用它来定位并从与元素关联的观察器函数列表中删除观察器函数。
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`jQuery.guid` is a page-wide counter that is used by the plugins and jQuery
    itself as a centralized way to retrieve unique integer IDs. It is often used to
    assign unique IDs to elements, objects, and functions, in order to make it easier
    to locate them in collections. It is the responsibility of each implementer that
    retrieves and uses the current value of `jQuery.guid` to also increase the property
    value (by one) after each use. Otherwise, and since this is a page-wide counter
    that is used by both jQuery plugins and jQuery themselves for identification,
    the page will probably face malfunctions that are hard to debug.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`jQuery.guid` 是一个页面范围的计数器，它被插件和 jQuery 本身用作集中的方式来检索唯一的整数 ID。它通常用于给元素、对象和函数分配唯一的
    ID，以便更容易地在集合中定位它们。每个检索和使用 `jQuery.guid` 当前值的实现者都有责任在每次使用后也增加属性值（加一）。否则，由于这是一个页面范围的计数器，被
    jQuery 插件和 jQuery 自己用于标识，页面可能会面临难以调试的故障。'
- en: In the second and third highlighted code areas, jQuery initializes an array
    to hold the observer lists for each individual event that may fire on that element.
    One thing to note in the second highlighted code area is that the observer lists
    found in the `elemData` variable are not a property on the actual DOM element.
    As shown in the `dataPriv.get( elem )` statement, near the start of the `jQuery.event.add()`
    method, jQuery uses separate mapping objects to hold the associations between
    DOM elements and their observer lists. By using this data cache mechanism, jQuery
    is able to avoid polluting the DOM elements with the extra properties that are
    needed by its implementation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个和第三个突出显示的代码区域中，jQuery 初始化一个数组来保存每个可能在该元素上触发的事件的观察者列表。需要注意的是，第二个突出显示的代码区域中的观察者列表并不是实际
    DOM 元素的属性。正如 `jQuery.event.add()` 方法开头附近的 `dataPriv.get( elem )` 语句所示，jQuery 使用单独的映射对象来保存
    DOM 元素与其观察者列表之间的关联。通过使用这种数据缓存机制，jQuery 能够避免向 DOM 元素添加额外属性，这些属性是其实现所需要的。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can easily locate the data cache mechanism implementation in the source
    code of jQuery by searching for `function Data()`. This will bring you to the
    constructor function of the `Data` class that is also followed by the implementation
    of the class methods that are defined in the `Data.prototype` object. For more
    information, you can visit [http://api.jquery.com/data](http://api.jquery.com/data).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过搜索 `function Data()` 在 jQuery 源代码中轻松找到数据缓存机制的实现。这将带您到 `Data` 类的构造函数，该构造函数后面跟随着在
    `Data.prototype` 对象中定义的类方法的实现。有关更多信息，您可以访问 [http://api.jquery.com/data](http://api.jquery.com/data)。
- en: The next highlighted code area is where jQuery checks whether the `EventTarget.addEventListener()`
    method is actually available for that element and then uses it to add the event
    listener to the element. In the final highlighted code area, jQuery adds the observer
    function to its internal list, which holds all the observers of the same event
    type that are attached to that specific element.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个突出显示的代码区域是 jQuery 检查 `EventTarget.addEventListener()` 方法是否实际上对该元素可用，然后使用它将事件监听器添加到该元素。在最后一个突出显示的代码区域中，jQuery
    将观察者函数添加到其内部列表中，该列表保存了附加到该特定元素的相同事件类型的所有观察者。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Depending on the version you are using, you might get different results to some
    degree. The most recent stable jQuery version released and used as reference while
    writing this book was v2.2.0.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您所使用的版本，可能会在某种程度上获得不同的结果。编写本书时发布和使用的最新稳定的 jQuery 版本是 v2.2.0。
- en: In case you need to provide support for older browsers, for example, Internet
    Explorer lower than version 9, then you should use the v1.x versions of jQuery.
    The latest version as of the writing of this book was v1.12.0, which offers the
    exact same API as the v2.2.x versions, but also has the required code to work
    on older browsers.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要为旧版浏览器（例如低于版本 9 的 Internet Explorer）提供支持，则应使用 jQuery 的 v1.x 版本。编写本书时的最新版本是
    v1.12.0，它提供与 v2.2.x 版本完全相同的 API，但也具有在旧版浏览器上运行所需的代码。
- en: In order to cover the implementation inconsistencies of older browsers, the
    implementation of `jQuery.event.add()` in jQuery v1.x is a bit longer and more
    complex. One of the reasons for this is because jQuery also needs to test whether
    `EventTarget.addEventListener()` is actually available in the browser that it
    is running and try to use `EventTarget.attachEvent()` if this is not the case.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了涵盖旧版浏览器的实现不一致性，jQuery v1.x 中 `jQuery.event.add()` 的实现要长一些，更复杂一些。其中一个原因是因为
    jQuery 还需要测试浏览器是否实际上支持 `EventTarget.addEventListener()`，如果不是，则尝试使用 `EventTarget.attachEvent()`。
- en: As we saw in the preceding code, the jQuery implementation follows the operation
    model that the Observer Pattern describes, but it also incorporates some implementation
    tricks in order to make it work more efficiently with the APIs available to web
    browsers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中看到的，jQuery 的实现遵循观察者模式描述的操作模型，但也融入了一些实现技巧，以使其与 Web 浏览器可用的 API 更有效地配合工作。
- en: The document-ready observer
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档准备就绪的观察者
- en: Another convenient method that jQuery offers, which is widely used by developers,
    is the `$.fn.ready()` method. This method accepts a function parameter and executes
    it only after the DOM tree of the page has been fully loaded. Such a thing can
    be useful in case your code is not loaded last in the page and you don't want
    to block the initial page render, or the elements that it needs to manipulate
    are defined later than its own `<script>` tag.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery提供的另一个方便的方法，是被开发人员广泛使用的`$.fn.ready()`方法。此方法接受一个函数参数，仅在页面的DOM树完全加载后才执行它。这在以下情况下可能会有用：如果您的代码不是最后加载到页面上，而且您不想阻塞初始页面呈现，或者它需要操作的元素被定义在其自身`<script>`标签之后。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that the `$.fn.ready()` method works slightly differently than
    the `window.onload` callback and the "load" event of the page, which wait until
    all the resources of the page are loaded. For more information, you can visit
    [http://api.jquery.com/ready](http://api.jquery.com/ready).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`$.fn.ready()`方法的工作方式与`window.onload`回调和页面的"load"事件稍有不同，它们会等待页面的所有资源加载完毕。有关更多信息，您可以访问[http://api.jquery.com/ready](http://api.jquery.com/ready)。
- en: 'The following code demonstrates the most common way to use the `$.fn.ready()`
    method:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了`$.fn.ready()`方法的最常见使用方式：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we try to locate the implementation of `jQuery.fn.ready`, we will see that
    it actually uses `jQuery.ready.promise` internally to work:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试找到`jQuery.fn.ready`的实现，我们会看到它实际上在内部使用`jQuery.ready.promise`来工作：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see in the preceding highlighted code areas of the implementation,
    jQuery uses `addEventListener` to observe when the `DOMContentLoaded` event is
    fired on the `document` object. Moreover, to ensure that it will work across a
    wide range of browsers, it also observes for the `load` event to be fired on the
    `window` object.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在实现中前面高亮显示的代码区域中所见，jQuery使用`addEventListener`来观察`document`对象上的`DOMContentLoaded`事件何时触发。另外，为了确保它在各种浏览器中都能工作，它还注意到`window`对象上的`load`事件何时被触发。
- en: The jQuery library also provides shorter methods to add the above functionality
    in your code. Since the aforementioned implementation does not actually need a
    reference to the document, we can instead just write `$().ready(function() {/*
    ... */ })`. There also exists an overload of the `$()` function that achieves
    the same result, which is used like `$(function() {/* ... */ })`. These two alternative
    ways to use `jQuery.fn.ready` have been heavily criticized among developers, since
    they commonly lead to misunderstandings. The second, shorter version in particular
    can lead to confusion, since it looks like an **Immediately Invoked Function Expression**
    (**IIFE**), a pattern that JavaScript developers use heavily and have learned
    to recognize. In fact, it only differs by one character (`$`) and as a result,
    its use is not suggested before a discussion with the rest of your developer team.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery库还提供了在代码中添加上述功能的更短的方法。由于上述实现实际上不需要对文档的引用，因此我们可以用`$().ready(function()
    {/* ... */ })`来代替。还存在一个`$()`函数的重载，它能够达到相同的效果，它的使用方式是`$(function() {/* ... */ })`。这两种替代方法使用`jQuery.fn.ready`在开发者中受到了严重批评，因为它们通常会导致误解。尤其是第二种更为简短的版本会引起混淆，因为它看起来像一个**立即调用的函数表达式**（**IIFE**），这是JavaScript开发人员大量使用和已学会识别的一种模式。实际上，它只有一个字符(`$`)的不同，因此在与开发团队讨论之前不建议使用它。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `$.fn.ready()` method is also characterized as a method that provides an
    easy way to implement the Lazy Initialization/Execution Pattern in our code. The
    core concept of this pattern is to postpone the execution of a piece of code or
    load a remote resource at a later point of time. For example, we can wait for
    the page to be fully loaded until we add our observers or wait for a certain event
    to happen before downloading a web resource.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`$.fn.ready()`方法也被称为为我们的代码实现惰性初始化/执行模式提供了一种简单的方法。该模式的核心概念是推迟执行一段代码或在以后的时间点加载远程资源。例如，我们可以等待页面完全加载后再添加观察者，或者在下载网页资源之前等待某个特定事件发生。'
- en: Demonstrate a sample use case
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 演示一个样本用例
- en: In order to see the Observer Pattern in action, we will create an example showcasing
    a skeleton implementation of a dashboard. In our example, the user will be able
    to add information boxes to his dashboard related to some sample items and categories
    that are available for selection on the header.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到观察者模式的实际效果，我们将创建一个示例来展示控制面板的骨架实现。在我们的示例中，用户将能够向其控制面板添加与标题栏中可供选择的一些示例项目和类别相关的信息框。
- en: 'Our example will have three predefined categories for our items: **Products**,
    **Sales**, and **Advertisements**. Each of these categories will have a series
    of related items that will appear in the area right below the category selector.
    The user will be able to select the desired category by using a drop-down selector
    and this will change the visible selection items of the dashboard.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例将为我们的项目设有三个预定义的类别：**产品**、**销售**和**广告**。每个类别都将有一系列相关项目，这些项目将出现在类别选择器正下方的区域。用户可以通过使用下拉选择器选择所需的类别，这将更改仪表板的可见选择项目。
- en: '![Demonstrate a sample use case](img/00008.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![演示一个使用案例](img/00008.jpeg)'
- en: Our dashboard will initially contain a hint information box about the dashboard
    usage. Whenever a user clicks on one of the category items, a new information
    box will appear in our three-column layout dashboard. In the preceding image,
    the user has added two new information boxes for **Product B** and **Product D**
    by clicking on the associated buttons.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的仪表板最初将包含关于仪表板用法的提示信息框。每当用户点击类别项之一时，一个新的信息框将出现在我们的三列布局仪表板中。在前述图像中，用户通过点击相关按钮为**产品B**和**产品D**添加了两个新的信息框。
- en: '![Demonstrate a sample use case](img/00009.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![演示一个使用案例](img/00009.jpeg)'
- en: The user will also be able to dismiss any of these information boxes by clicking
    on a red close button on the top-right of each information box. In the preceding
    image, the user dismissed the **Product D** information box, then added information
    boxes for the **Advertisement 3** and later the 1st, 2nd, and 3rd week items of
    the **Sales** category.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 用户还可以通过点击每个信息框顶部右侧的红色关闭按钮来取消这些信息框中的任何一个。在前述图像中，用户取消了**产品D**信息框，然后添加了**广告3**以及**销售**类别的第1、2和3周项目的信息框。
- en: By just reading the above description, we can easily isolate all the user interactions
    that are required for the implementation of our dashboard. We will need to add
    observers for each one of these user interactions and write code inside the callback
    functions that execute the appropriate DOM manipulations.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仅仅阅读上述描述，我们可以轻松地分离出所有实现我们仪表板所需的用户交互。我们将需要为每一个这些用户交互添加观察者，并在回调函数中编写执行适当DOM操作的代码。
- en: 'In detail, our code will need to:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们的代码将需要：
- en: Observe changes done to the currently selected element and respond to such event
    by hiding or revealing the appropriate items
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察当前选定元素所做的更改，并通过隐藏或显示相应项目来响应此类事件
- en: Observe the clicks on each item button and respond by adding a new information
    box
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察每个项目按钮的点击并通过添加新的信息框来响应
- en: Observe the clicks on the close button of each information box and respond by
    removing it from the page
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察每个信息框的关闭按钮的点击并通过将其从页面中移除来响应
- en: 'Now let''s proceed and review the HTML, CSS, and JavaScript code required for
    the preceding example. Let''s start with the HTML code and for reference, let''s
    say that we saved it in a file named `Dashboard Example.html`, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续并查看所需的HTML、CSS和JavaScript代码，以完成前面的示例。让我们从HTML代码开始，假设我们将其保存在名为`Dashboard
    Example.html`的文件中，代码如下：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding HTML, we placed all our dashboard-related elements inside a
    `<div>` element with the `dashboardContainer` CSS class . This will enable us
    to have a centric starting point to search for our dashboard's elements and also
    scope our CSS. Inside it, we define two `<section>` elements in order to divide
    the dashboard into logical areas using some HTML5 semantic elements.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述HTML中，我们将所有与仪表板相关的元素放在带有`dashboardContainer` CSS类的`<div>`元素内。这将使我们能够有一个中心起点来搜索我们仪表板的元素，并且作用域我们的CSS。在它内部，我们使用一些HTML5语义元素定义了两个`<section>`元素，以便使用逻辑区域划分仪表板。
- en: The first `<section>` with the `dashboardCategories` class is used to hold the
    categories selector of our dashboard. Inside it, we have a `<select>` element
    with the ID `categoriesSelector` that is used to filter the visible category items
    and three subsections with the `dashboardCategory` class that are used to wrap
    the `<button>` elements that will populate the dashboard with information boxes
    when clicked. Two of them also have the `hidden` class so that only the first
    one is visible when the page loads by matching the initially selected option (`<option>`)
    of the category selector. Also, at the end of the first section, we also added
    a `<div>` with the `clear` class that, as we saw in the first chapter, will be
    used to clear the floated `<button>` elements.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个带有`dashboardCategories`类的`<section>`用于保存我们仪表板的类别选择器。在其中，我们有一个带有ID `categoriesSelector`的`<select>`元素，用于过滤可见的类别项目，以及三个带有`dashboardCategory`类的子部分，用于包装在单击时将用信息框填充仪表板的`<button>`元素。其中两个还具有`hidden`类，以便在页面加载时仅显示第一个，通过匹配类别选择器的最初选择选项(`<option>`)。此外，在第一节的末尾，我们还添加了一个带有`clear`类的`<div>`，正如我们在第一章中看到的那样，它将用于清除浮动的`<button>`元素。
- en: The second `<section>` with the `boxContainer` class is used to hold the information
    boxes of our dashboard. Initially, it contains only one with a hint about how
    to use the dashboard. We use a `<div>` element with the `boxsizer` class to set
    the box dimensions and an HTML5 `<article>` element with the `box` class to add
    the required border padding and shadow, similar to the box elements from the first
    chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`boxContainer`类的第二个`<section>`用于保存我们仪表板的信息框。最初，它仅包含一个关于如何使用仪表板的提示。我们使用带有`boxsizer`类的`<div>`元素来设置框尺寸，以及带有`box`类的HTML5
    `<article>` 元素来添加所需的边框填充和阴影，类似于第一章中的框元素。
- en: Each information box, besides its content, also contains a `<header>` element
    with the `boxHeader` class and a `<button>` element with the `boxCloseButton`
    class that, when clicked, removes the information box that contains it. We also
    used the `&#10006;` HTML character code as the button's content in order to get
    a better-looking "x" mark and avoid using a separate image for that purpose.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每个信息框除了其内容之外，还包含一个带有`boxHeader`类的`<header>`元素和一个带有`boxCloseButton`类的`<button>`元素，当点击时，会移除包含它的信息框。我们还使用了`&#10006;`
    HTML 字符代码作为按钮的内容，以获得更漂亮的“x”标记，并避免使用单独的图像来实现此目的。
- en: Lastly, since the information boxes are also floated, we also need a `<div>`
    with the `clear` class at the end of the `boxContainer`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于信息框也是浮动的，我们还需要一个带有`clear`类的`<div>`放置在`boxContainer`的末尾。
- en: 'In the `<head>` of the preceding HTML, we also reference a CSS file named as
    `dashboard-example.css` with the following content:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述HTML的`<head>`中，我们还引用了一个名为`dashboard-example.css`的CSS文件，其内容如下：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see in our CSS file, first of all we add some space below the element
    with the `dashboardCategories` class and also define the same styling for the
    `<select>` element and the buttons inside it. In order to differentiate it from
    the default browser styling, we add some padding, a border with rounded corners,
    a different background color when hovering the mouse pointer, and some space in
    between them. We also define that our `<select>` element should be displayed alone
    in its row as a block and that the category item buttons should float next to
    each other. We again use the `boxsizer` and `box` CSS classes, as we did in [Chapter
    1](part0014_split_000.html#DB7S2-e8d3cd3d052d4ee0b4673af57a64ddef "Chapter 1. A
    Refresher on jQuery and the Composite Pattern"), *A Refresher on jQuery and the
    Composite Pattern*; the first one to create a three-column layout and the second
    one to actually provide the styling of an information box. We continue by defining
    the `boxHeader` class that is applied to the `<header>` elements of our information
    boxes, and define some padding, a grey background color, a light shadow, and also
    some negative margins so that it counterbalances the effect of the box's paddings
    and places itself next to its border.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在我们的CSS文件中所看到的，首先我们在具有`dashboardCategories`类的元素下面添加了一些空间，并且为`<select>`元素和其中的按钮定义了相同的样式。为了使其与默认浏览器样式区分开来，我们添加了一些填充，圆角边框，悬停鼠标指针时的不同背景颜色以及它们之间的一些空间。我们还定义了我们的`<select>`元素应该作为块独自显示在其行中，以及分类项目按钮应该相邻浮动。我们再次使用了`boxsizer`和`box`
    CSS类，就像在[第1章](part0014_split_000.html#DB7S2-e8d3cd3d052d4ee0b4673af57a64ddef "Chapter 1. A
    Refresher on jQuery and the Composite Pattern")，*jQuery和组合模式复习*中所做的一样；第一个用于创建三列布局，第二个实际提供信息框的样式。我们继续定义`boxHeader`类，应用于我们信息框的`<header>`元素，并定义一些填充，灰色背景颜色，轻微阴影，以及一些负边距，以抵消框填充的效果并将其放置在其边框旁边。
- en: To complete the styling of the information boxes, we also define the `boxCloseButton`
    CSS class that (i) floats the box's close buttons to the upper-right corner inside
    the box `<header>`, (ii) defines a `20px` width and height, (iii) overrides the
    default browser's `<button>` styling to zero padding, and (iv) adds a single-pixel
    black border with rounded corners and a red background color. Lastly, like in
    [Chapter 1](part0014_split_000.html#DB7S2-e8d3cd3d052d4ee0b4673af57a64ddef "Chapter 1. A
    Refresher on jQuery and the Composite Pattern"), *A Refresher on jQuery and the
    Composite Pattern* we define the `clear` utility CSS class to prevent the element
    from being placed next to the previous floating elements and also define the `hidden`
    class as a convenient way of hiding elements of the page.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成信息框的样式设计，我们还定义了`boxCloseButton` CSS类，它（i）将框的关闭按钮浮动到框的`<header>`内的右上角，（ii）定义了`20px`的宽度和高度，（iii）覆盖了默认浏览器的`<button>`样式以零填充，并且（iv）添加了一个单像素的黑色边框，圆角和红色背景颜色。最后，就像在[第1章](part0014_split_000.html#DB7S2-e8d3cd3d052d4ee0b4673af57a64ddef
    "Chapter 1. A Refresher on jQuery and the Composite Pattern")，*jQuery和组合模式复习*中，我们定义了`clear`实用的CSS类以防止元素被放置在前面浮动元素的旁边，并且还定义了`hidden`类作为隐藏页面元素的方便方式。
- en: 'In our HTML file, we reference the jQuery library itself and also a JavaScript
    file named as `dashboard-example.js` that contains our dashboard implementation.
    Following the best practices of creating performant web pages, we have placed
    them right before the `</body>` tag, in order to avoid delaying the initial page
    rendering:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的HTML文件中，我们引用了jQuery库本身以及一个名为`dashboard-example.js`的JavaScript文件，其中包含我们的仪表板实现。遵循创建高性能网页的最佳实践，我们将它们放在了`</body>`标签之前，以避免延迟初始页面渲染：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have placed all our code inside a `$(document).ready()` call, in order to
    delay its execution until the DOM tree of the page is fully loaded. This would
    be absolutely required if we placed our code in the `<head>` element, but it is
    also a best practice that is good to follow in any case.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有代码放在了一个`$(document).ready()`调用中，以延迟其执行直到页面的DOM树完全加载。如果我们将代码放在`<head>`元素中，这将是绝对必要的，但在任何情况下遵循的最佳实践也是很好的。
- en: We first add an observer for the `change` event on the `categoriesSelector`
    element using the ``$.fn.change()`` method, which is actually a shorthand method
    for the `$.fn.on('change', /* … */)` method. In jQuery, the value of the `this`
    keyword inside a function that is used as an observer holds a reference to the
    DOM element that the event was fired. This applies to all jQuery methods that
    register observers, from the core `$.fn.on()` to the `$.fn.change()` and `$.fn.click()`
    convenient methods. So we use the `$()` function to make a jQuery object with
    the `<select>` element and store it in the `$selector` variable. Then, we use
    `$selector.val()` to retrieve the value of the selected `<option>` and cast it
    to a numeric value by using the `+` operator. Right after this, we retrieve the
    `<section>` elements of `dashboardCategory` and cache the result to the `$dashboardCategories`
    variable. Then, we proceed by finding and revealing the category whose position
    is equal to the value of the `selectedIndex` variable and also store the resulting
    jQuery object to the `$selectedItem` variable. Finally, we are using the `$selectedItem`
    variable with the `$.fn.not()` method to retrieve and hide all the category elements,
    except from the one we just revealed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`$.fn.change()`方法为`categoriesSelector`元素的`change`事件添加了一个观察者。实际上，这是`$.fn.on('change',
    /* … */)``方法的一种简写方法。在jQuery中，作为观察者使用的函数内的`this`关键字的值保存着被触发事件的DOM元素的引用。这适用于所有注册观察者的jQuery方法，从核心的`$.fn.on()`到方便的`$.fn.change()`和`$.fn.click()`方法。所以我们使用`$()`函数用`<select>`元素创建一个jQuery对象，并将其存储在`$selector`变量中。然后，我们使用`$selector.val()`来检索所选`<option>`的值，并通过使用`+`运算符将其转换为数值。紧接着，我们检索`dashboardCategory`的`<section>`元素，并将结果缓存到`$dashboardCategories`变量中。然后，我们通过找到并显示位置等于`selectedIndex`变量值的类别来继续，并将结果的jQuery对象存储到`$selectedItem`变量中。最后，我们使用`$.fn.not()`方法使用`$selectedItem`变量检索并隐藏除了刚刚显示的类别元素之外的所有类别元素。
- en: In the next code section, we define the `setupBoxCloseButton` function that
    will be used to initialize the functionality of the close button. It expects a
    jQuery object with the box elements as a parameter, and for each of them, searches
    their descendants for the `boxCloseButton` CSS class that we use on the close
    buttons. Using `$.fn.click()`, which is a convenient method for `$.fn.on('click',
    /* fn */)`, we register an anonymous function to be executed whenever a click
    event is fired that uses the `$.fn.closest()` method to find the first ancestor
    element with the `boxsizer` class and removes it from the page. Right after this,
    we call this function once for the box elements that already existed in the page
    at the time when the page was loaded. In this case, the box element with the usage
    hint.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码部分中，我们定义了`setupBoxCloseButton`函数，该函数将用于初始化关闭按钮的功能。它期望一个带有盒子元素的jQuery对象作为参数，并且对于每一个盒子元素，搜索它们的后代以找到我们在关闭按钮上使用的`boxCloseButton`
    CSS类。使用`$.fn.click()`，这是`$.fn.on('click', /* fn */)`的一个方便方法，我们注册一个匿名函数，以便在每次点击事件被触发时执行，该函数使用`$.fn.closest()`方法来查找具有`boxsizer`类的第一个祖先元素，并将其从页面中删除。紧接着，我们对已经存在于页面中在页面加载时的盒子元素调用此函数一次。在这种情况下，使用提示的盒子元素。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An extra thing to keep in mind when using the `$.fn.closest()` method is that
    it begins testing the given selector from the current element of the jQuery collection
    before proceeding with its ancestor elements. For more information, you can visit
    its documentation at [http://api.jquery.com/closest](http://api.jquery.com/closest).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`$.fn.closest()`方法时需要注意的另一件事情是，它从jQuery集合的当前元素开始测试给定的选择器，然后再进行其祖先元素的测试。有关更多信息，您可以访问其文档
    [http://api.jquery.com/closest](http://api.jquery.com/closest)。
- en: In the final code section, we use the `$.fn.on()` method to add an observer
    for the click event on each of the category buttons. In this case, inside the
    anonymous observer function, we use the `this` keyword, which holds the DOM element
    of the `<button>` that was clicked, and use the `$()` method to create a jQuery
    object and cache its reference in the `$button` variable. Right after this, we
    retrieve the button's text content using the `$.fn.text()` method and along with
    it, construct the HTML code for the information box. For the close button, we
    use the `&#10006` HTML character code that will be rendered as a prettier "**X**"
    icon. The template we created is based on the HTML code of the initially visible
    hint box; for the needs of this chapter's example, we use plain string concatenation.
    Lastly, we append the generated HTML code for our box to the `boxContainer`, and
    since we expect it to be the last element, we use the `$()` function to find it
    and provide it as a parameter to the `setupBoxCloseButton`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终的代码部分中，我们使用`$.fn.on()`方法在每个类别按钮上添加点击事件的观察者。在这种情况下，在匿名观察者函数内部，我们使用`this`关键字，它保存了被点击的`<button>`的DOM元素，并使用`$()`方法创建一个jQuery对象，并将其引用缓存在`$button`变量中。紧接着，我们使用`$.fn.text()`方法获取按钮的文本内容，并结合它构建信息框的HTML代码。对于关闭按钮，我们使用`&#10006`
    HTML字符代码，它将被渲染为更漂亮的“**X**”图标。我们创建的模板基于最初可见提示框的HTML代码；在本章的示例中，我们使用纯字符串拼接。最后，我们将生成的HTML代码附加到`boxContainer`，由于我们期望它是最后一个元素，我们使用`$()`函数查找它，并将其作为参数传递给`setupBoxCloseButton`。
- en: How it is compared with event attributes
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与事件属性相比如何
- en: Before the `EventTarget.addEventListener()` was defined in the DOM Level 2 Events
    specification, the event listeners were registered either by using the event attributes
    that are available for HTML elements or the element event properties that are
    available for DOM nodes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在DOM Level 2 Events规范中定义`EventTarget.addEventListener()`之前，事件监听器的注册方法是通过使用可用于HTML元素的事件属性或可用于DOM节点的元素事件属性。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the DOM Level 2 Event specification and event attributes,
    you can visit [http://www.w3.org/TR/DOM-Level-2-Events](http://www.w3.org/TR/DOM-Level-2-Events)
    and [https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Event_attributes](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Event_attributes),
    respectively.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有关DOM Level 2事件规范和事件属性的更多信息，您可以访问[http://www.w3.org/TR/DOM-Level-2-Events](http://www.w3.org/TR/DOM-Level-2-Events)和[https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Event_attributes](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Event_attributes)。
- en: The event attributes are a set of attributes that are available to HTML elements
    and provide a declarative way of defining pieces of JavaScript code (preferably
    function calls) that should be executed when a specific event is triggered on
    that element. Because of their declarative nature and how simply they can be used,
    this is often the first way that new developers get introduced to events in web
    development.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 事件属性是一组可用于HTML元素的属性，提供了一种声明性的方法来定义应在触发该元素上特定事件时执行的JavaScript代码片段（最好是函数调用）。由于它们的声明性特质和简单易用的方式，这通常是新开发者首次接触网页开发中的事件的方式。
- en: 'If we used event attributes in the above example, then the HTML code for the
    close buttons in the information boxes will look as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在上面的示例中使用了事件属性，那么信息框中关闭按钮的HTML代码将如下所示：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Also, we should change the template that is used to create new information
    boxes and expose the `closeInfoBox` function on the `window` object, in order
    for it to be accessible from the HTML event attribute:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '另外，我们应该更改用于创建新信息框的模板，并将`closeInfoBox`函数暴露在`window`对象上，以便可以从HTML事件属性中访问:'
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Some of the disadvantages of using event attributes over the Observer Pattern
    are:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件属性而不是观察者模式的一些缺点包括：
- en: It makes it harder to define multiple separate actions that have to be executed
    when an event fires on an element
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得更难定义在元素上触发事件时需要执行的多个单独操作
- en: It makes the HTML code of the page bigger and less readable
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这会使页面的HTML代码变得更大，且不易读取
- en: It is against the separation of concerns principle, since it adds JavaScript
    code inside our HTML, possibly making a bug harder to track and fix
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它违反了关注点分离原则，因为它在我们的HTML中添加了JavaScript代码，可能会使错误更难跟踪和修复
- en: Most of the time, it leads to the functions being called in the event attribute
    getting exposed to the global `window` object, thereby "polluting" the global
    namespace
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数情况下，这会导致事件属性中调用的函数暴露给全局的 `window` 对象，从而“污染”全局命名空间。
- en: 'Using the element event properties would not require any changes to our HTML,
    keeping all the implementation in our JavaScript files. The changes required in
    our `setupBoxCloseButton` function will make it look as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用元素事件属性不需要对我们的 HTML 进行任何更改，所有的实现都保留在我们的 JavaScript 文件中。我们在 `setupBoxCloseButton`
    函数中需要进行的更改将使它看起来如下所示：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that, for convenience, we are still using jQuery for DOM manipulations,
    but the resulting code still has some of the aforementioned disadvantages. More
    importantly, in order to avoid memory leaks, we are also required to remove the
    function assigned to the `onclick` property before removing the element from the
    page, if it contains references to the DOM element that it is applied on.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了方便起见，我们仍然在 DOM 操作中使用 jQuery，但生成的代码仍然具有前述的一些缺点。更重要的是，为了避免内存泄漏，我们还需要在从页面中移除元素之前删除分配给
    `onclick` 属性的函数，如果它包含对其应用的 DOM 元素的引用。
- en: 'Using the tools that today''s browsers offer, we can even match the convenience
    that the declarative nature of event attributes offers. In the following image,
    you can see how the Firefox developer tools provide us with helpful feedback when
    we use them to inspect a page element that has an event listener attached:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用当今浏览器提供的工具，我们甚至可以达到事件属性声明性质所提供的便利程度。在下图中，您可以看到 Firefox 开发者工具在我们使用它们来检查附加了事件侦听器的页面元素时为我们提供了有用的反馈：
- en: '![How it is compared with event attributes](img/00010.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![与事件属性相比如何](img/00010.jpeg)'
- en: As you can see in the preceding image, all the elements that have observers
    attached also have an **ev** sign right next to them, which when clicked, displays
    a dialog showing all the event listeners that are currently attached. To make
    our developing experience even better, we can directly see the file and the line
    that these handlers were defined in. Moreover, we can click on them in order to
    expand and reveal their code, or click on the sign in front of them to navigate
    to their source and add breakpoints.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，所有附加了观察者的元素旁都有一个 **ev** 标志，单击该标志将显示一个对话框，显示当前附加的所有事件侦听器。为了使我们的开发体验更好，我们可以直接看到这些处理程序所在的文件和行。此外，我们可以单击它们以展开并显示它们的代码，或者单击它们前面的标志以导航到其源并添加断点。
- en: 'One of the biggest benefits of using the Observer Pattern over event attributes
    is clearly visible in the case where we need to take more than one action when
    a certain event happens. Suppose that we also need to add a new feature in our
    example dashboard, which would prevent a user from accidentally double-clicking
    a category item button and adding the same information box twice to the dashboard.
    The new implementation should ideally be completely independent from the existing
    one. Using the Observer Pattern, all we need to do is add the following code that
    observes for button clicks and disables that button for 700 milliseconds:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用观察者模式而不是事件属性的最大好处之一，在于当某个事件发生时需要执行多个操作的情况下清晰可见。假设我们还需要在示例仪表板中添加一个新功能，该功能可以防止用户意外双击类别项目按钮并将相同的信息框两次添加到仪表板。新的实现理想上应完全独立于现有的实现。使用观察者模式，我们只需添加以下代码来观察按钮点击并在
    700 毫秒内禁用该按钮：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code is indeed completely independent from the basic implementation
    and we could place it inside the same or a different JS file and load it to our
    page. This would be more difficult when using event attributes, since it would
    require us to define both actions at the same time inside the same event handler
    function; as a result, it would strongly couple the two independent actions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码确实完全独立于基本实现，我们可以将其放在同一个或不同的 JS 文件中，并将其加载到我们的页面中。这在使用事件属性时会更加困难，因为它要求我们在同一个事件处理程序函数中同时定义两个动作；结果，它会强烈地耦合两个独立的动作。
- en: Avoid memory leaks
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免内存泄漏
- en: As we saw earlier, there are some strong advantages of using the Observer Pattern
    to handle events on a web page. When using the `EventTarget.addEventListener()`
    method to add an observer to an element, we also need to keep in mind that in
    order to avoid memory leaks, we also have to call the `EventTarget.removeEventListener()`
    method before removing such elements from the page so that the observers are also
    removed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所见，使用观察者模式处理网页上的事件有一些强大的优势。当使用`EventTarget.addEventListener()`方法向元素添加观察者时，我们还需要记住，为了避免内存泄漏，我们在将这些元素从页面中移除之前，还必须调用`EventTarget.removeEventListener()`方法，以便观察者也被移除。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on removing event listeners from elements, you can visit
    [https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener),
    or for the jQuery equivalent method, visit [http://api.jquery.com/off/](http://api.jquery.com/off/).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有关从元素中移除事件侦听器的更多信息，您可以访问[https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/removeEventListener](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/removeEventListener)，或者查看
    jQuery 等效方法，请访问[http://api.jquery.com/off/](http://api.jquery.com/off/)。
- en: The jQuery library developers understood that such an implementation concern
    could easily be forgotten or not handled properly, thereby making the adoption
    of the Observer Pattern look more complex, so they decided to encapsulate the
    appropriate handling inside the `jQuery.event` implementation. As a result, when
    using any event handling jQuery method, such as the core `$.fn.on()` or any of
    the convenient methods such as `$.fn.click()` or `$.fn.change()`, the observer
    functions are tracked by jQuery itself and are properly unregistered if we later
    decide to remove the element from the page. As we saw earlier in the implementation
    of `jQuery.event`, jQuery stores a reference to the observers of each element
    in a separate mapping object. Every time we a use a jQuery method that removes
    DOM elements from the page, it first makes sure to remove any observers attached
    to those elements or any of the descendant elements, by checking the mapping object.
    As a result, the example code we used earlier is not causing memory leaks even
    though we are not using any method that explicitly removes the observers we add
    to the created elements.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 库的开发者意识到这样一个实现上的关注点可能会被轻易地忘记或者没有正确处理，从而使得观察者模式的采用看起来更加复杂，因此他们决定将适当的处理封装在`jQuery.event`实现中。因此，当使用任何
    jQuery 的事件处理方法，比如核心的`$.fn.on()`或者任何方便的方法，比如`$.fn.click()`或`$.fn.change()`时，观察者函数由
    jQuery 本身跟踪，并且如果我们后来决定将元素从页面中移除，它们将被正确取消注册。正如我们之前在`jQuery.event`的实现中看到的那样，jQuery
    将每个元素的观察者存储在一个单独的映射对象中。每次我们使用一个 jQuery 方法来从页面中移除 DOM 元素时，它首先通过检查映射对象来确保移除这些元素或任何后代元素上附加的任何观察者。因此，即使我们不使用任何显式移除我们添加到创建的元素上的观察者的方法，我们之前使用的示例代码也不会造成内存泄漏。
- en: Tip
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Be careful when mixing jQuery and plain DOM manipulations**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**在混合使用 jQuery 和纯 DOM 操作时要小心**'
- en: Even though all jQuery methods keep you safe from memory leaks caused from observers
    that are never unregistered, keep in mind it can't protect you if you remove elements
    using plain methods from the DOM API. If methods such as `Element.remove()` and
    `Element.removeChild()` are used and the removed elements or their descendants
    have observers attached, then they are not going to be unregistered automatically.
    The same applies when assigning to the `Element.innerHTML` property.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 即使所有 jQuery 方法都可以确保您免受由从未取消注册的观察者引起的内存泄漏，但请记住，如果使用纯 DOM API 的方法从文档中移除元素，则无法保护您。如果使用`Element.remove()`和`Element.removeChild()`等方法，并且被移除的元素或其后代有附加的观察者，则它们将不会被自动取消注册。当分配给`Element.innerHTML`属性时也是如此。
- en: Introducing the Delegated Event Observer Pattern
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍委托事件观察者模式
- en: Now that we have learned some advanced details about how to use the Observer
    Pattern using jQuery, we will get introduced to a special variation of it that
    fits perfectly to the web platform and provides some extra benefits. The Delegated
    Event Observer Pattern (or simply Delegate Observer Pattern) is often used in
    web development and it utilizes the bubbling feature that most events that are
    fired on DOM elements have. For example, when we click on a page element, the
    click event is immediately fired on it, and right after this it also fires on
    all its parent elements until it reaches the root of our HTML document. Using
    a slightly different overloaded version of the jQuery's `$.fn.on` method, we can
    easily create and attach observers on page elements for delegated events that
    are fired on specific child elements.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了如何使用 jQuery 使用观察者模式的一些高级细节，我们将介绍一种特殊的变体，它完全适用于 Web 平台并提供了一些额外的好处。委托事件观察器模式（简称委托观察器模式）经常用于
    Web 开发，并利用了大多数在 DOM 元素上触发的事件具有的冒泡特性。例如，当我们单击页面元素时，单击事件立即在其上触发，然后在达到 HTML 文档根之前还会在所有父元素上触发。使用
    jQuery 的 `$.fn.on` 方法的略有不同的重载版本，我们可以轻松地为触发在特定子元素上的委托事件创建和附加观察者。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The term "Event Delegation" describes the programming pattern where the handler
    of an event is not attached directly to the element of interest, but is instead
    attached to one of its ancestor elements.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“事件委托”描述了一种编程模式，其中事件的处理程序不直接附加到感兴趣的元素，而是附加到其祖先元素之一。
- en: How it simplifies our code
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何简化我们的代码
- en: 'Reimplementing our dashboard example using the Delegated Event Observer Pattern
    will require us to change only the code of the included JavaScript file to the
    following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用委托事件观察器模式重新实现我们的仪表板示例将只需要更改包含的 JavaScript 文件的代码如下：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The most obvious difference is that the new implementation is shorter. The benefits
    come by defining just one observer to a common ancestor element, for each action
    that applies to more than one page element. For this reason, we use the `$.fn.on(events,
    selector, handler)` overload variation of the `$.fn.on()` method.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的区别在于新的实现更短。通过仅为适用于多个页面元素的每个操作定义一个观察者，可以获得益处。因此，我们使用 `$.fn.on(events, selector,
    handler)` 方法的重载变体。
- en: Specifically, we add an observer to the page element with the `dashboardCategories`
    CSS class and listen for the `click` events that originate from any of its `<button>`
    descendants. Similarly, we add a single observer to the `boxContainer` element
    that will be executed whenever a click event fires on any of its descendants that
    match the `.boxCloseButton` CSS selector.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们向具有 `dashboardCategories` CSS 类的页面元素添加一个观察者，并监听其任何 `<button>` 后代触发的 `click`
    事件。类似地，我们向 `boxContainer` 元素添加一个观察者，该观察者将在其匹配 `.boxCloseButton` CSS 选择器的任何后代上触发单击事件时执行。
- en: Since the above observers apply not only to the elements that existed in the
    page at the moment they were registered, but also to any element that is added
    at any later point of time and matches the specified CSS selector; we are able
    to decouple the code that handles the clicks on the close buttons and place it
    in a separate observer, instead of registering a new one every time a new information
    box is added. As a result, the observer that adds the new information boxes in
    the dashboard is simpler and only has to deal with creating the HTML of the box
    and insert it into the dashboard, leading to a greater separation of concerns.
    Moreover, we no longer need to handle the registration of the observer for the
    close button of the hint box in a separate piece of code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上述观察者不仅适用于在注册时存在于页面上的元素，还适用于以后任何时间添加的匹配指定 CSS 选择器的任何元素；我们能够将处理关闭按钮点击的代码解耦，并将其放在一个单独的观察者中，而不是每次添加新信息框时都注册一个新观察者。因此，负责在仪表板中添加新信息框的观察者更简单，只需处理信息框的
    HTML 创建和插入到仪表板中，从而实现了更大的关注点分离。此外，我们不再需要在单独的代码片段中处理提示框关闭按钮的观察者注册。
- en: Compare the memory usage benefits
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较内存使用优势
- en: We will now compare the difference in memory usage when using the `$.fn.on()`
    method with the simple and Delegated Event Observer Pattern variation. To achieve
    this we will open the two implementations of our dashboard example and compare
    their memory usage on Chrome. To open Chrome's developer tools, just press *F12*
    and then navigate to the **Timeline** tab. We press the "record" button in the
    Chrome's **Timeline** tab and then press each category item button 10 times, resulting
    in the addition of 120 information boxes to our dashboard. After adding all the
    boxes, we end up with 121 open boxes in total, since the hint box will still be
    open and then stop the timeline recording.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将比较使用`$.fn.on()`方法与简单和委托事件观察者模式变体时的内存使用差异。为了实现这一点，我们将打开我们仪表板示例的两个实现，并在 Chrome
    上比较它们的内存使用情况。要打开 Chrome 的开发者工具，只需按下*F12*，然后导航到**Timeline**选项卡。我们在 Chrome 的**Timeline**选项卡中按下"record"按钮，然后按下每个类别项按钮
    10 次，将 120 个信息框添加到我们的仪表板。在添加所有框之后，我们总共有 121 个打开的框，因为提示框仍然打开，然后停止时间线记录。
- en: 'The results in the timeline for our initial Observer Pattern implementation
    will look as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始观察者模式实现的时间线结果如下：
- en: '![Compare the memory usage benefits](img/00011.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![比较内存使用优势](img/00011.jpeg)'
- en: 'Repeating the same process for the Delegated Event Observer Pattern implementation
    will give a smoother timeline, revealing less object allocations and Garbage Collections,
    as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为委托事件观察者模式实现重复相同的过程将提供更平滑的时间线，显示较少的对象分配和垃圾收集，如下所示：
- en: '![Compare the memory usage benefits](img/00012.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![比较内存使用优势](img/00012.jpeg)'
- en: As you can see in the preceding images, we end up with 1192 page elements in
    both cases, but in the first implementation we are using 134 event listeners,
    as compared to the implementation with event delegation where we initially created
    three event listeners and never actually added another.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在前面的图片中所示，我们最终在两种情况下都有 1192 个页面元素，但在第一种实现中，我们使用了 134 个事件侦听器，而在使用事件委托的实现中，我们最初创建了三个事件侦听器，并且实际上从未添加过其他事件侦听器。
- en: Finally, as you can see from the blue line in the graph, the memory consumption
    of the delegate version stayed relatively the same, adding up to just around 200
    KB. On the other hand, in the original implementation, the heap size increased
    more than five times, gaining more than 1 MB of increase.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如你在图表中看到的蓝线所示，委托版本的内存消耗保持相对稳定，仅增加了约 200 KB。另一方面，在原始实现中，堆大小增加了五倍多，增加了超过 1
    MB。
- en: Adding so many elements may not be an actual use case, but the dashboard will
    probably not be the only dynamic part of your page. As a result, in a relatively
    complex web page, we could get similar improvements if we reimplemented every
    applicable part of it using the Delegated Event Observer Pattern variant.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这么多元素可能并不是一个实际的使用情况，但是仪表板可能不会是你页面上唯一的动态部分。因此，在一个相对复杂的网页中，如果我们使用委托事件观察者模式的变体重新实现了它的每个适用部分，我们可能会得到类似的改进。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the Observer Pattern, how it can make the
    HTML code of our web pages cleaner, and the way that decouples it from our application's
    code. We learned how jQuery adds a protection layer to its methods in order to
    protect us from undetected memory leaks, which may occur by adding observers to
    elements, when not using the jQuery DOM manipulation methods.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了观察者模式，以及它如何使我们网页的 HTML 代码更清晰，以及它如何将其与我们应用程序的代码解耦。我们了解了 jQuery 如何在其方法中添加保护层，以保护我们免受未检测到的内存泄漏的影响，这可能会在不使用
    jQuery DOM 操作方法时，通过向元素添加观察者而发生。
- en: We also tried the Delegated Event Observer Pattern variant and used it to rewrite
    our initial example. We compared the two implementations and saw how it simplifies
    writing code that applies to many page elements when they are generated after
    the page has been loaded. Finally, we had a comparison regarding the memory consumption
    of the plain Observer Pattern with its delegate variant and highlighted how it
    also lessens the memory consumption of our page by reducing the required number
    of attached observers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还尝试了委托事件观察者模式变体，并将其用于重写我们的初始示例。我们比较了这两种实现，并看到它如何简化了在页面加载后应用于许多页面元素的代码编写。最后，我们就普通观察者模式与其委托变体的内存消耗进行了比较，并强调了它如何通过减少所需的附加观察者数量来减少页面的内存消耗。
- en: Now that we have completed our introduction on how the Observer Pattern is used
    to listen to user actions, we can move on to the next chapter where we will learn
    about custom events and the Publish/Subscribe Pattern and the way they can lead
    to a more decoupled implementation.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了关于观察者模式如何用于监听用户操作的介绍，我们可以继续下一章，了解自定义事件、发布/订阅模式以及它们如何导致更解耦的实现方式。
