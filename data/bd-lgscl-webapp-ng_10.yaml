- en: Prepare Angular App for Production Release
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备 Angular 应用程序进行生产发布
- en: If you don't ship it, it never happened. In the previous chapter, you created
    a local weather application that can retrieve current weather data. You have created
    some amount of value; however, if you don't put your app on the web, you end up
    creating zero value. Delivering something is difficult, delivering something to
    production is even more difficult. You want to follow a strategy that results
    in a reliable, high quality, and flexible release.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有上线它，那就好像它从来没有发生过。在前一章中，你创建了一个可以检索当前天气数据的本地天气应用程序。你已经创造了一定的价值；然而，如果你不将你的应用程序上线，最终你将得不到任何价值。交付某物很困难，将其投入生产甚至更加困难。你希望遵循一个能够产生可靠、高质量和灵活发布的策略。
- en: The app we created in [Chapter 9](7c897af2-bc94-4c2f-a5ad-8ae0b4bc0508.xhtml), *Create
    a Local Weather Web Application*, is fragile. We need to be able to deliver the
    frontend app separately from the backend app, which is a very important decoupling
    to retain the flexibility of being able to push separate app and server updates.
    In addition, decoupling will ensure that as the various tools and technologies
    in your application stack inevitably fall out of support or favor, you will be
    able to replace your frontend or backend without a full rewrite of your system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 9 章](7c897af2-bc94-4c2f-a5ad-8ae0b4bc0508.xhtml)中创建的应用程序，*创建本地天气 Web 应用程序*，比较脆弱。我们需要能够单独交付前端应用程序，而不必与后端应用程序一起处理，这是保持灵活性的重要解耦，以便能够推送独立的应用程序和服务器更新。此外，解耦将确保当应用程序堆栈中的各种工具和技术不可避免地不受支持或不受欢迎时，您将能够替换前端或后端，而无需全面重写系统。
- en: 'In this chapter, you will learn to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将学习以下内容：
- en: Guard against null data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防范空数据
- en: Containerize the app using Docker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 容器化应用程序
- en: Deploy the app on the web using Zeit Now
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Zeit Now 将应用程序上线到 Web 上
- en: 'Required software is as listed:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所需软件列举如下：
- en: Docker Community Edition Version 17.12
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 社区版版本 17.12
- en: Zeit Now Account
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zeit Now 账户
- en: Null guarding in Angular
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Angular 中进行空值保护
- en: 'In JavaScript, the `undefined` and `null` values are a persistent issue that
    must be proactively dealt with every step of the way. There are multiple ways
    to guard against `null` values in Angular:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，`undefined` 和 `null` 值是必须主动处理的持久问题。在 Angular 中，有多种方法可以防范 `null`
    值：
- en: Property Initialization
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性初始化
- en: Safe Navigation Operator `?.`
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全导航操作符 `?.`
- en: Null Guarding with `*ngIf`
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `*ngIf` 进行空值保护
- en: Property initialization
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性初始化
- en: 'In statically-typed languages such as Java, it is drilled into you that proper
    variable initialization/instantiation is the key to error free operation. So let''s
    try that in `CurrentWeatherComponent` by initializing current with default values:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在诸如 Java 等静态类型语言中，正确的变量初始化/实例化是无误操作的关键。因此，让我们在 `CurrentWeatherComponent` 中尝试通过使用默认值来初始化当前值：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The outcome of these changes will reduce console errors from 12 to 3, at which
    point you will only be seeing API call related errors. However, the app itself
    will not be in a presentable state, as you can see below:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改的结果将将控制台错误从 12 个减少到 3 个，此时您将只看到 API 调用相关的错误。但是，应用程序本身不会处于可展示状态，如下所示：
- en: '![](img/1f84089f-b267-456c-880f-f229a904a8e2.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f84089f-b267-456c-880f-f229a904a8e2.png)'
- en: Results of Property Initialization
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 属性初始化的结果
- en: To make this view presentable to user, we will have to code for default values
    on every property on the template. So by fixing the null guarding issue by initialization,
    we created a default value handling issue. Both the initialization and the default
    value handling are *O(n)* scale tasks for developers. At its best, this strategy
    will be annoying to implement and at its worst, highly ineffective and error prone,
    requiring, at minimum, *O(2n)* effort per property.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此视图对用户呈现，我们必须对模板上的每个属性编写默认值的代码。因此，通过初始化解决了空保护问题，我们创建了一个默认值处理问题。对于开发人员来说，初始化和默认值处理都是
    *O(n)* 规模的任务。在最好的情况下，这种策略将令人厌烦，而在最坏的情况下，效果极差且容易出错，最低要求每个属性的工作量达到 *O(2n)*。
- en: Safe navigation operator
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全导航操作符
- en: 'Angular implements the safe navigation operation `?.` to prevent unintended
    traversals of undefined objects. So, instead of writing initialization code and
    having to deal with template values, let''s just update the template:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 实现了安全导航操作 `?.` 以防止意外遍历未定义的对象。因此，我们不需要撰写初始化代码并处理模板数值，而是只需更新模板：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This time, we didn''t have to make up defaults, and we let Angular deal with
    displaying undefined bindings. You will note that just like the initialization
    fix, the errors have been reduced from 12 to 3\. The app itself is in a somewhat
    better shape. There''s no more confusing data being displayed; however, it still
    is not in a presentable state, as shown below:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们不必设置默认值，让Angular处理显示未定义的绑定。你会注意到，就像初始化修复一样，错误从12个减少到3个。应用本身的状态也稍微好了一些。不再显示混乱的数据；但现在还不是一个可以展示的状态，如下所示：
- en: '![](img/cf719932-a5c2-4a64-ba10-861ad126010e.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf719932-a5c2-4a64-ba10-861ad126010e.png)'
- en: Results of Safe Navigation Operator
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 安全导航操作符的结果
- en: You can probably imagine ways where the safe navigation operator can come in
    handy, in far more complicated scenarios. However, when deployed at scale, this
    type of coding still requires, at minimum, *O(n)* level of effort to implement.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能能想象出在更复杂的情况下安全导航操作符可以派上用场。然而，当规模化部署时，这种类型的编码仍然需要至少*O(n)*级别的工作量来实现。
- en: Null guarding with *ngIf
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用*ngIf进行null值保护。
- en: The idea strategy will be to use `*ngIf`, which is a structural directive, meaning
    Angular will stop traversing DOM tree elements beyond a falsy statement.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 理想策略是使用`*ngIf`，这是一个结构性指令，意味着Angular会在假语句之后停止遍历DOM树元素。
- en: 'In the `CurrentWeather` component, we can easily check to see whether the `current`
    variable is null or undefined before attempting to render the template:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CurrentWeather`组件中，我们可以在尝试渲染模板之前轻松地检查`current`变量是否为null或undefined：
- en: 'Update the topmost `div` element with `*ngIf` to check whether `current` is
    an object, as shown:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新顶层的`div`元素，用`*ngIf`来检查`current`是否为对象，如下所示：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now observe the console log and that no errors are being reported. You always
    ensure that your Angular application reports zero console errors. If you're still
    seeing errors in the console log, ensure that you have correctly reverted the
    `OpenWeather` URL to its correct state or kill and restart your `npm start` process.
    I highly recommend that you resolve any console errors before moving on. Once
    you've fixed all errors, ensure that you commit your code again.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在观察控制台日志，没有错误报告。你必须确保你的Angular应用程序不会报告任何控制台错误。如果您仍然在控制台日志中看到错误，请确保已经正确恢复了`OpenWeather`网址到其正确的状态，或者关闭并重新启动`npm
    start`进程。我强烈建议你在继续之前解决任何控制台错误。一旦您解决了所有错误，请确保再次提交您的代码。
- en: Commit your code.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交你的代码。
- en: Containerizing the app using Docker
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker容器化应用程序
- en: 'Docker [docker.io](http://docker.io) is an *open platform* for developing,
    shipping, and running applications. Docker combines a *lightweight* container
    virtualization platform with workflows and tooling that help manage and deploy
    applications. The most obvious difference between **Virtual Machines** (**VMs**)
    and Docker containers are that VMs usually are dozens of gigabytes in size and
    require gigabytes of memory, whereas containers are megabytes in disk and memory
    size requirements. Furthermore, the Docker platform abstracts away host **operating
    system** (**OS**) level configuration settings, so every piece of configuration
    that is needed to successfully run an application is encoded within the human-readable
    Dockerfile format, as demonstrated here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Docker [docker.io](http://docker.io) 是一个用于开发、部署和运行应用程序的*开放平台*。Docker结合了*轻量级*的容器虚拟化平台和用于管理和部署应用程序的工作流程和工具。**虚拟机**（**VMs**）和Docker容器之间最明显的区别在于，VMs通常占用数十GB的空间并且需要GB级别的内存，而容器仅需要MB级别的磁盘和内存空间。此外，Docker平台将主机**操作系统**（**OS**）级别的配置设置抽象掉，所以成功运行应用程序所需的每个配置设置都被编码在易读的Dockerfile格式中，如下所示：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding file describes a new container that inherits from a container
    named `duluca/minimal-node-web-server`, changes the working directory to `/usr/src/app`,
    and then copies the contents of `dist` folder from your development environment
    into the container's `public` folder. In this case, the parent image is configured
    with an Express.js server to act as a web server to serve the content inside the
    `public` folder.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的文件描述了一个继承自名为`duluca/minimal-node-web-server`的容器的新容器，将工作目录更改为`/usr/src/app`，然后将开发环境中`dist`文件夹的内容复制到容器的`public`文件夹中。在这种情况下，父镜像配置了一个Express.js服务器，充当Web服务器以提供`public`文件夹中的内容。
- en: 'Refer to the following diagram for a visual representation of what''s happening:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 参考下图，以可视化表示正在发生的事情：
- en: '![](img/e85a11d3-ea47-4e80-804d-ae9267b23407.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e85a11d3-ea47-4e80-804d-ae9267b23407.jpg)'
- en: Context of a Docker Image
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像的上下文
- en: At the base layer is our host OS, such as Windows or macOS that runs the Docker
    runtime, which will be installed in the next section. The Docker runtime is capable
    of running self-contained Docker images, which is defined by the aforementioned
    `Dockerfile`. `duluca/minimal-node-web-server` is based off of the lightweight
    Linux operating system Alpine. Alpine is a completely pared down version of Linux
    that doesn't come with any GUI, drivers or even most CLI tools you may expect
    from a Linux system. As a result, the OS is around only ~5 MB in size. The base
    package then installs Node.js, which itself is around ~10 MB in size and my custom
    Node.js-based Express.js web server, resulting in a tiny ~15 MB image. The Express
    server is configured to serve the contents of the `/usr/src/app` folder. In the
    preceding `Dockerfile`, we merely copy the contents of the `/dist` folder in our
    development environment and place it into the `/usr/src/app` folder. We will later
    build and execute this image, which will run our Express web server containing
    the output of our `dist` folder.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在基础层是我们的宿主操作系统，比如Windows或macOS，运行Docker运行时，这将在下一节中安装。Docker运行时能够运行自包含的Docker镜像，这是由上述的`Dockerfile`定义的。`duluca/minimal-node-web-server`基于轻量级的Linux操作系统Alpine。Alpine是Linux的一个完全简化版本，没有任何图形界面、驱动程序，甚至大部分你可能期望从Linux系统中获得的CLI工具。因此，这个操作系统的大小只有约5MB。基础包然后安装了Node.js，这本身的大小约为10MB，以及我的自定义基于Node.js的Express.js
    Web服务器，最终会产生一个小巧的约15MB的镜像。Express服务器被配置为提供`/usr/src/app`文件夹的内容。在前面的`Dockerfile`中，我们只需将我们开发环境中`/dist`文件夹的内容复制并放入`/usr/src/app`文件夹中。我们将稍后构建和执行这个镜像，这将运行我们的Express
    Web服务器，其中包含了我们`dist`文件夹的输出。
- en: The beauty of Docker is that you can navigate to [https://hub.docker.com](https://hub.docker.com),
    search for `duluca/minimal-node-web-server`, read its `Dockerfile`, and trace
    its origins all the way back to the original base image that is the foundation
    of the web server. I encourage you to vet every Docker image you use in this manner
    to understand what exactly it brings to the table for your needs. You may find
    it either overkill or has features you never knew about that can make your life
    a lot easier. Note that the parent images require a specific version of `duluca/minimal-node-web-server` at `8.11.1`.
    This is quite intentional, and as the reader, you should choose the latest available
    version of a Docker image you find. However, if you don't specify a version number,
    you will always get the latest version of the image. As more versions of an image
    is published, you may pull a future version that may break your application. For
    this reason, always specify a version number for images you're depending on.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的美妙之处在于，你可以访问[https://hub.docker.com](https://hub.docker.com)，搜索`duluca/minimal-node-web-server`，阅读它的`Dockerfile`，并追溯其起源一直到构成web服务器基础的原始基础镜像。我鼓励你以这种方式审核你使用的每个Docker镜像，以了解它究竟为你的需求带来了什么。你可能会发现它要么过度复杂，要么具有你之前不知道的功能，可以让你的生活变得更加容易。请注意，父镜像需要特定版本的`duluca/minimal-node-web-server`，在`8.11.1`处。这是完全有意的，作为读者，你应该选择你发现的Docker镜像的最新可用版本。然而，如果你不指定版本号，你将总是得到镜像的最新版本。随着镜像的发布更多版本，你可能拉取将来会破坏你的应用程序的某个版本。因此，始终为你依赖的镜像指定版本号。
- en: 'One such case is the HTTPS redirection support that is baked into `duluca/minimal-node-web-server`.
    You can spend countless hours trying to set up a nginx proxy to do the same thing,
    when all you need to do is add the following line to your Dockerfile:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个例子就是内置了HTTPS重定向支持的`duluca/minimal-node-web-server`。你可能会花费无数小时尝试设置一个Nginx代理来完成同样的事情，而你只需要在你的Dockerfile中添加以下行即可：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Just like npm packages, Docker can bring great convenience and value, but you
    must take care to understand the tools you are working with.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 就像npm包一样，Docker可以带来极大的便利和价值，但你必须小心，了解你正在使用的工具。
- en: In [Chapter 16](7ccc1261-21e7-44b9-aaf8-0079360288e7.xhtml), *Highly-Available
    Cloud Infrastructure on AWS,* we mention the use of a lower footprint docker image
    based on Nginx. If you're comfortable configuring `nginx`, you can use `duluca/minimal-nginx-web-server`
    as your base image.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第16章](7ccc1261-21e7-44b9-aaf8-0079360288e7.xhtml)中，*AWS上的高可用云基础设施*，我们提到了基于Nginx的低占用资源的docker镜像的使用。如果你熟悉配置`nginx`，你可以以`duluca/minimal-nginx-web-server`作为你的基础镜像。
- en: Installing Docker
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Docker
- en: In order to be able to build and run containers, you must first install the
    Docker execution environment on your computer.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够构建和运行容器，你必须首先在你的计算机上安装Docker执行环境。
- en: Windows support of Docker can be challenging. You must have a PC with a CPU
    that supports virtualization extensions, which is not a guarantee on laptops.
    You must also have a Pro version of Windows with Hyper-V enabled. On the flip
    side, Windows Server 2016 has native support for Docker, which is an unprecedented
    amount of support shown by Microsoft toward the industry initiative to adopt Docker
    and containerization.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 在 Windows 上的支持可能会有挑战。您必须拥有支持虚拟化扩展的 CPU 的 PC，这在笔记本电脑上并非一定能保证。您还必须拥有启用了
    Hyper-V 的 Pro 版 Windows。另一方面，Windows Server 2016 对 Docker 有原生支持，这是微软对业界采用 Docker
    和容器化所展现的空前支持。
- en: 'Install Docker by executing the following command:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令安装 Docker：
- en: 'For Windows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For macOS:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 macOS：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Execute `docker -v` to verify the installation.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `docker -v` 来验证安装。
- en: Setting up Docker scripts
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Docker 脚本
- en: 'Now, let''s configure some Docker scripts that you can use to automated the
    building, testing, and publishing of your container. I have developed a set of
    scripts called **npm Scripts for Docker** that work on Windows 10 and macOS. You
    can get the latest version of these scripts at [bit.ly/npmScriptsForDocker](http://bit.ly/npmScriptsForDocker):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置一些 Docker 脚本，您可以用来自动构建、测试和发布您的容器。我开发了一套名为**npm Scripts for Docker** 的脚本，适用于
    Windows 10 和 macOS。您可以在 [bit.ly/npmScriptsForDocker](http://bit.ly/npmScriptsForDocker) 获取这些脚本的最新版本：
- en: Sign up for a Docker Hub account on [https://hub.docker.com/](https://hub.docker.com/)
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 [https://hub.docker.com/](https://hub.docker.com/) 上注册一个 Docker Hub 帐户
- en: Create a public (free) repository for your application
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的应用程序创建一个公共（免费）仓库
- en: Unfortunately, at the time of publication, Zeit doesn't support private Docker
    Hub repositories, so your only alternative is to publish your container publicly.
    If your image must remain private, I encourage you to set up an AWS ECS environment
    as described in [Chapter 16](7ccc1261-21e7-44b9-aaf8-0079360288e7.xhtml), *Highly-Available
    Cloud Infrastructure on AWS*. You can keep tabs on the issue by visiting Zeit
    Now's documentation at [zeit.co/docs/deployment-types/docker](https://zeit.co/docs/deployment-types/docker).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在出版时，Zeit 不支持私有 Docker Hub 仓库，因此您的唯一选择是公开发布您的容器。如果您的图像必须保持私有，我建议您按照《[第
    16 章](7ccc1261-21e7-44b9-aaf8-0079360288e7.xhtml)》《AWS 上的高可用云基础设施》中描述的方式设置 AWS
    ECS 环境。您可以通过访问 Zeit Now 的文档 [zeit.co/docs/deployment-types/docker](https://zeit.co/docs/deployment-types/docker) 了解问题的情况。
- en: 'Update `package.json` to add a new config property with the following configuration
    properties:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `package.json` 以添加一个新的配置属性，具有以下配置属性：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The namespace will be your DockerHub username. You will be defining what your
    repository is called during creation. An example image repository variable should
    look like `duluca/localcast-weather`. The image name is for easy identification
    of your container, while using Docker commands such as `docker ps`. I will call
    mine just `localcast-weather`. The port will define which port should be used
    to expose your application from inside the container. Since we use `5000` for
    development, pick a different one, like `8080`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间将是您的 DockerHub 用户名。您在创建过程中将定义您的仓库名称。例如，一个示例图像仓库变量应如下所示 `duluca/localcast-weather`。图像名称用于轻松识别您的容器，同时使用类似于 `docker
    ps` 的 Docker 命令。我将自己的命名为 `localcast-weather`。端口将定义从容器内部公开您的应用程序应使用的端口。因为我们在开发中使用
    `5000`，请选择一个不同的端口，比如 `8080`。
- en: Add Docker scripts to `package.json` by copy-pasting the scripts from [bit.ly/npmScriptsForDocker](http://bit.ly/npmScriptsForDocker).
    Here's an annotated version of the scripts that explains each function.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过复制粘贴从 [bit.ly/npmScriptsForDocker](http://bit.ly/npmScriptsForDocker) 中获取的脚本，向
    `package.json` 中添加 Docker 脚本。以下是脚本的注释版本，解释了每个函数：
- en: 'Note that with npm scripts, the `pre` and `post` keywords are used to execute
    helper scripts, respectively, before or after the execution of a given script
    and scripts are intentionally broken into smaller pieces to make it easier to
    read and maintain them:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用 npm 脚本时，`pre` 和 `post` 关键词用于在给定脚本的执行之前或之后，分别执行辅助脚本。脚本故意被分解为更小的部分，以使其更易于阅读和维护：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`npm run docker:build` will build your Angular application in `pre`, then build
    the Docker image using the `docker image build` command and tag the image with
    a version number in post:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `npm run docker:build` 将在 `pre` 中构建您的 Angular 应用程序，然后使用 `docker image build` 命令构建
    Docker 镜像，并在 `post` 中为镜像打上版本号：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`npm run docker:tag` will tag an already built Docker image using the version
    number from the `version` property in `package.json` and the `latest` tag:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm run docker:tag`将使用`package.json`中的`version`属性的版本号和`latest`标签对已构建的Docker镜像进行标记：'
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`npm run docker:run` will remove any existing, prior version of an image and
    run the already built image using the `docker run` command. Note that the `imagePort`
    property is used as the external port of the Docker image, which is mapped to
    the internal port of the image that the Node.js server listens to, port `3000`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm run docker:run`将删除先前版本的镜像，并使用`docker run`命令运行已构建的镜像。请注意，`imagePort`属性将作为Docker镜像的外部端口，映射到Node.js服务器监听的镜像的内部端口`3000`：'
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`npm run docker:publish` will publish a built image to the configured repository,
    in this case, Docker Hub, using the `docker image push` command. First, the versioned
    image is published, followed by one tagged with `latest` in post:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm run docker:publish`将发布构建的镜像到配置的存储库，这种情况下是Docker Hub，使用`docker image push`命令。首先发布带版本号的镜像，然后发布标记为`latest`的镜像。'
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`npm run docker:clean` will remove a previously built version of the image
    from your system, using the `docker rm -f` command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm run docker:clean`将从您的系统中删除先前构建的镜像版本，使用`docker rm -f`命令：'
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`npm run docker:taillogs` will display the internal console logs of a running
    Docker instance using the `docker log -f` command, a very useful tool when debugging
    your Docker instance:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm run docker:taillogs`会使用`docker log -f`命令显示运行中Docker实例的内部控制台日志，这是调试Docker实例时非常有用的工具：'
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`npm run docker:open:win` or `npm run docker:open:mac` will wait for 2 seconds
    and then launch the browser with the correct URL to your application using the
    `imagePort` property:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm run docker:open:win`或`npm run docker:open:mac`将等待2秒，然后使用`imagePort`属性以正确的URL启动浏览器访问您的应用程序：'
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`npm run docker:debug` will build your image and run an instance of it in `pre`,
    open the browser, and then start displaying the internal logs of the container.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm run docker:debug`将构建您的镜像，并在`pre`中运行它的一个实例，打开浏览器，然后开始显示容器的内部日志。'
- en: 'Install two development dependencies that are needed to ensure cross-platform
    functionality of the scripts:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装两个开发依赖项，以确保脚本的跨平台功能：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Customize the pre-build script to execute unit and e2e tests before building
    the image:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建镜像之前，自定义预构建脚本以执行单元测试和e2e测试：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that `npm run build` is provided the `--prod` argument, which achieves
    two things:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`npm run build --prod`提供了`--prod`参数，实现了两件事情：
- en: 1\. Development time payload of ~2.5 MB is optimized down to ~73kb or less
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 开发时间的2.5 MB负载被优化到~73kb或更少
- en: 2\. The configuration items defined in `src/environments/environment.prod.ts`
    is used at runtime
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 在运行时使用`src/environments/environment.prod.ts`中定义的配置项
- en: 'Update `src/environments/environment.prod.ts` to look like using your own `appId`
    from `OpenWeather`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`src/environments/environment.prod.ts`以使用来自`OpenWeather`的自己的`appId`：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We are modifying how `npm test` is executed, so the tests are run only once
    and the tool stops executing. The `--watch=false` option is provided to achieve
    this behavior, as opposed to the development-friendly default continuous execution
    behavior. In addition `npm run build` is provided with `--output-path dist` to
    ensure that `index.html` is published at the root of the folder.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在修改`npm test`的执行方式，以便测试只运行一次，工具停止执行。提供`--watch=false`选项以实现这种行为，与默认的开发友好的持续执行行为相反。此外，提供了`npm
    run build --output-path dist`，以确保`index.html`发布在文件夹的根目录。
- en: Create a new file named `Dockerfile` with no file-extensions
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Dockerfile`的新文件，没有任何文件扩展名
- en: 'Implement the `Dockerfile`, as shown:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现如下`Dockerfile`：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Be sure to inspect the contents of your `dist` folder. Ensure that `index.html`
    is at the root of `dist`. Otherwise ensure that your `Dockerfile` copies the folder
    that has `index.html` at its root.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 确保检查`dist`文件夹的内容。确保`index.html`位于`dist`的根目录。否则，请确保您的`Dockerfile`将包含具有`index.html`的文件夹复制到其根目录。
- en: Execute `npm run predocker:build` to ensure that your application changes have
    been successful
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`npm run predocker:build`以确保您的应用程序更改已成功
- en: Execute `npm run docker:build` to ensure that your image builds successfully
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`npm run docker:build`以确保您的镜像成功构建
- en: 'While you can run any of the provided scripts individually, you really only
    need to remember two of them going forward:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以单独运行提供的任何脚本，但实际上只需要记住其中两个：
- en: '**npm run docker:debug **will test, build, tag, run, tail and launch your containerize
    app in a new browser window for testing'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**npm run docker:debug**会测试，构建，标记，运行，在新的浏览器窗口中为测试启动你的容器化应用程序'
- en: '**npm run docker:publish **will publish the image you just built and test to
    the online Docker repository'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**npm run docker:publish**将会把你刚才构建并测试的镜像发布到在线Docker仓库'
- en: 'Execute `docker:debug` in your terminal:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在你的终端中执行`docker:debug`:'
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You will note that the scripts display errors in the Terminal window. These
    are not necessarily indicators of a failure. The scripts are not polished, so
    they attempt both Windows and macOS compatible scripts parallelly, and during
    a first build, the clean command fails, because there's nothing to clean. By the
    time you read this, I may have published better scripts; if not, you're more than
    welcome to submit a pull request.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到脚本在终端窗口显示错误。这些不一定是失败的指标。脚本还不够完善，因此它们同时尝试Windows和macOS兼容的脚本，并且在第一次构建时，清理命令会失败，因为没有需要清理的东西。等你看到这段话的时候，我可能已经发布了更好的脚本；如果没有，你可以随时提交合并请求。
- en: 'A successful `docker:debug` run should result in a new in-focus browser window
    with your application and the server logs being tailed in the terminal, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的`docker:debug`运行会在焦点浏览器窗口中显示你的应用程序，并在终端中显示服务器日志，如下所示：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You should always run `docker ps` to check whether your image is running, when
    it was last updated, or if it is clashing with the existing images claiming the
    same port.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该经常运行`docker ps`来检查你的镜像是否在运行，上次更新时间，或者它是否与现有镜像发生端口冲突。
- en: 'Execute `docker:publish` in your terminal:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在你的终端中执行 `docker:publish` :'
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You should observe a successful run in the Terminal window like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在终端窗口中看到类似这样的成功运行信息：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Over time, your local Docker cache may grow to a significant size, that is,
    on my laptop, roughly 40 GB over two years. You can use the `docker image prune`
    and `docker container prune` commands to reduce the size of your cache. For more
    detailed information, refer to the documentation at [https://docs.docker.com/config/pruning](https://docs.docker.com/config/pruning).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，你本地的Docker缓存可能会增长到相当大的规模，在我笔记本上大约是两年时间内增长了大约40 GB。你可以使用 `docker image
    prune` 和 `docker container prune` 命令来减小缓存的大小。更详细的信息，请参考[https://docs.docker.com/config/pruning](https://docs.docker.com/config/pruning)的文档。
- en: Let's look into an easier way to interact with Docker next.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们看一种更简单的与Docker进行交互的方式。
- en: Docker extension in VS Code
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VS Code中的Docker扩展
- en: 'Another way to interact with Docker images and containers is through VS Code.
    If you have installed the `PeterJausovec.vscode-docker` Docker extension, as suggested
    in [Chapter 9](7c897af2-bc94-4c2f-a5ad-8ae0b4bc0508.xhtml)*, Create a Local Weather
    Web Application*, you will see an expandable title named DOCKER in the Explorer
    pane of VS Code, as pointed out with an arrow in the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '与Docker镜像和容器进行交互的另一种方式是通过VS Code。如果你按照[第9章](7c897af2-bc94-4c2f-a5ad-8ae0b4bc0508.xhtml)*，创建本地天气Web应用程序*中建议的安装了`PeterJausovec.vscode-docker` Docker扩展，你会在VS
    Code的资源管理器窗格中看到一个名为DOCKER的可展开标题，如下截图所示所指出的部分:'
- en: '![](img/40d5e5e1-2f87-4b8e-af8a-fccc3466b3c1.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40d5e5e1-2f87-4b8e-af8a-fccc3466b3c1.png)'
- en: Docker extension in VS Code
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code中的Docker扩展
- en: 'Let''s go through some of the functionality provided by the extension:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们来看看该扩展提供的一些功能:'
- en: '**Images** contains a list of all the container snapshots that exist on your
    system'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Images**包含系统上存在的所有容器快照的列表'
- en: Right-clicking on a Docker image brings up a context menu to run various operations
    on it, like run, push and tag
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Docker镜像上右键单击会弹出上下文菜单，以运行各种操作，比如run，push和tag
- en: '**Containers** list all executable Docker containers that exist on your system,
    which you start, stop or attach to'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Containers**列出了系统上所有存在的可执行Docker容器，你可以启动、停止或连接到它们'
- en: '**Registries** display the registries that you''re configured to connect to,
    like DockerHub or AWS Elastic Container Registry'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Registries**显示你配置的连接到的注册表，比如DockerHub或AWS Elastic Container Registry'
- en: While the extension makes it easier to interact with Docker, **npm Scripts for
    Docker** automate a lot of the chores related to building, tagging and testing
    and image. They are cross-platform and will work equally well in a continuous
    integration environment.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然该扩展使与Docker进行交互更容易，但**用于Docker的npm脚本**可以自动化许多与构建、标记和测试镜像相关的琐事。它们是跨平台的，而且在持续集成环境中同样有效。
- en: You may find it confusing to interact with npm scripts in general through the
    CLI. Let's look at VS Code's npm script support next.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过CLI与npm脚本进行交互可能会让你感到困惑。接下来让我们看一下VS Code的npm脚本支持。
- en: NPM Scripts in VS Code
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VS Code 中的 NPM 脚本
- en: 'VS Code provides support for npm scripts out of the box. In order to enable
    npm script explorer, open VS Code settings and ensure that the `"npm.enableScriptExplorer":
    true` property is present. Once you do, you will see an expandable title named NPM
    SCRIPTS in the Explorer pane, as pointed out with an arrow here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 'VS Code 提供了对 npm 脚本的支持。 为了启用 npm 脚本资源管理器，打开 VS Code 设置，并确保存在 `"npm.enableScriptExplorer":
    true` 属性。 一旦你这样做，你将在资源管理器窗格中看到一个可扩展的名称为 NPM SCRIPTS 的标题，如下箭头所示：'
- en: '![](img/86f456ab-00f5-4eed-aff6-74117f03454c.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86f456ab-00f5-4eed-aff6-74117f03454c.png)'
- en: NPM Scripts in VS Code
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 中的 NPM 脚本
- en: You can click on any script to launch the line that contains the script in `package.json`
    or right-click and select Run to execute the script.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以单击任何脚本来启动包含脚本的 `package.json` 文件中的行，或者右键单击并选择运行以执行脚本。
- en: Deploying containerized app
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署容器化应用
- en: If delivering something to production is difficult from a coding perspective,
    it is extremely difficult to do it right from an infrastructure perspective. In
    the later chapters, I will cover how to provision a world-class AWS **Elastic
    Container Service** (**ECS**) infrastructure for your applications, but that won't
    help if you need to quickly demonstrate an idea. Enter, Zeit Now.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从编码角度交付产品很困难，那么从基础设施角度来看，做到正确更是极其困难。 在后面的章节中，我将讨论如何为您的应用程序提供世界一流的 AWS **弹性容器服务**（**ECS**）基础设施，但如果您需要快速展示一个想法，这是没有帮助的。
    这就是 Zeit Now 的作用。
- en: Zeit Now
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zeit Now
- en: Zeit Now, [https://zeit.co/now](https://zeit.co/now), is a multi-cloud service
    that enables real-time global deployments of applications directly from the CLI.
    Now works with applications that either correctly implement `package.json` or
    a `Dockerfile`. Even though we have done both, we will prefer to deploy our Docker
    image, because a lot more magic is applied behind the scenes to make a `package.json`
    deployment work, whereas your Docker image can be deployed anywhere, including
    AWS ECS.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Zeit Now，[https://zeit.co/now](https://zeit.co/now)，是一个多云服务，可以直接从 CLI 实现应用程序的实时全球部署。
    Now 适用于正确实现 `package.json` 或 `Dockerfile` 的应用程序。 即使我们两者都做了，我们仍然更喜欢部署我们的 Docker
    image，因为在幕后会应用更多的魔法来使 `package.json` 的部署工作，而您的 Docker image 可以部署到任何地方，包括 AWS ECS。
- en: Configuring the Now CLI tool
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Now CLI 工具
- en: 'Now, let''s configure Zeit Now to work on your repository:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置 Zeit Now 在您的存储库上运行：
- en: Install Zeit Now by executing `npm i -g now`
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`npm i -g now`安装 Zeit Now
- en: Ensure correct installation by executing `now -v`
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行 `now -v` 确保正确安装
- en: Create a new folder under `local-weather-app` called `now`
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `local-weather-app` 下创建一个名为 `now` 的新文件夹
- en: Create a new `Dockerfile` under the new `now` folder
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的 `now` 文件夹下创建一个新的 `Dockerfile`
- en: 'Implement the file to pull from the image you just published:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现从您刚刚发布的镜像中提取文件：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, execute the `now` command in your terminal and follow the instructions
    to the finish configuration:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在您的终端中执行 `now` 命令并按照说明完成配置：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Deploying
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: 'Deploying on Zeit Now is very easy:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Zeit Now 上部署非常容易：
- en: 'Change your working directory to `now` and execute the command:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将工作目录更改为 `now` 并执行命令： '
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the Terminal window, the tool will report its progress and the URL from
    which you can access your now published app:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端窗口中，该工具将报告其进度和您可以访问您现在发布的应用程序的 URL：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Navigate to the URL listed on the second line and verify the publication of
    your app.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到第二行列出的 URL 并验证您的应用程序的发布。
- en: Note that if you've made a configuration error along the way, your browser may
    display an error saying This page is trying to load unsafe scripts, allow and
    reload to see your app.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您在配置过程中出现错误，您的浏览器可能会显示一个错误，指示此页面正在尝试加载不安全的脚本，请允许并重新加载以查看您的应用程序。
- en: You can explore Zeit Now's paid features, which allow for advanced features
    such as automated scaling for your application.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以探索 Zeit Now 的付费功能，这些功能允许为您的应用程序提供高级功能，例如自动缩放。
- en: Congratulations, you are app is live on the internet!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您的应用程序已经在互联网上启动了！
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to best avoid Angular console errors by guarding
    against null data. You configured your system to work with Docker and successfully
    containerized your web application with its own dedicated web server. You configured
    your project with npm scripts for Docker that can be leveraged by any team member.
    Finally, you have successfully delivered a web application in the cloud.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何通过防范空数据来最好地避免 Angular 控制台错误。你已经配置好系统以便与 Docker 协同工作，并成功地将你的 Web 应用程序与专用的
    Web 服务器容器化。你还为 Docker 配置了项目并利用了 npm 脚本，这些脚本可以被任何团队成员利用。最后，你成功地将 Web 应用程序交付到了云端。
- en: Now you know what takes to build a production-ready Angular application that
    is reliable, resilient, and containerized to allow for a flexible deployment strategy.
    In the next chapter, we will improve the apps feature set and make it look great
    using Angular Material.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何构建一个可靠、弹性、并且容器化的生产就绪 Angular 应用程序，以允许灵活的部署策略。在下一章中，我们将改善应用程序的功能集，并使用
    Angular Material 使其看起来更加出色。
