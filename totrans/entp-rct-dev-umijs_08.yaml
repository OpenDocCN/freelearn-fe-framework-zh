- en: 'Chapter 6: Testing Front-End Applications'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：测试前端应用程序
- en: Testing software is an essential part of software development. We can prevent
    errors and ensure that new features don't introduce bugs by implementing well-designed
    tests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试是软件开发的一个关键部分。通过实施精心设计的测试，我们可以预防错误并确保新功能不会引入错误。
- en: In this chapter, you'll understand software testing by learning how to design
    integration and end-to-end tests and apply them in the development process. After
    that, you'll learn how to write tests using **Jest**, a JavaScript test framework
    focused on simplicity that works well with React. You'll also learn how to test
    interfaces by simulating user actions with **Puppeteer** and **Headless Chrome**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将通过学习如何设计集成和端到端测试并将它们应用于开发过程来理解软件测试。之后，你将学习如何使用**Jest**（一个专注于简单性且与React配合良好的JavaScript测试框架）编写测试。你还将学习如何通过使用**Puppeteer**和**Headless
    Chrome**模拟用户操作来测试接口。
- en: 'In this chapter, we''ll cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Understanding software testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解软件测试
- en: Writing tests with Jest
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jest编写测试
- en: Testing interfaces with Puppeteer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Puppeteer测试接口
- en: By the end of this chapter, you'll have learned how to design integration and
    end-to-end tests and how to apply them to improve software quality. You'll have
    learned how to write tests using Jest, a tool to write and run tests in JavaScript
    projects. You'll also know how to test interfaces with Puppeteer and Headless
    Chrome.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何设计集成和端到端测试，以及如何将它们应用于提高软件质量。你将学会如何使用Jest编写测试，Jest是一个用于JavaScript项目的编写和运行测试的工具。你还将了解如何使用Puppeteer和Headless
    Chrome测试接口。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this chapter's exercises, you just need a computer with any OS (I
    recommend Ubuntu 20.04 or higher) and the software installed in [*Chapter 1*](B18503_01_Final_JM_ePub.xhtml#_idTextAnchor014),
    *Environment Setup and Introduction to UmiJS* (Visual Studio Code, Node.js, and
    Yarn).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的练习，你只需要一台安装了任何操作系统（我推荐Ubuntu 20.04或更高版本）的计算机，以及安装在[*第1章*](B18503_01_Final_JM_ePub.xhtml#_idTextAnchor014)、“环境设置和UmiJS简介”的软件（Visual
    Studio Code、Node.js和Yarn）。
- en: 'You can find the complete project in the `Chapter06` folder in the GitHub repository
    available at the following link: [https://github.com/PacktPublishing/Enterprise-React-Development-with-UmiJs](https://github.com/PacktPublishing/Enterprise-React-Development-with-UmiJs)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接提供的GitHub仓库的`Chapter06`文件夹中找到完整的项目：[https://github.com/PacktPublishing/Enterprise-React-Development-with-UmiJs](https://github.com/PacktPublishing/Enterprise-React-Development-with-UmiJs)
- en: Understanding software testing
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解软件测试
- en: In this section, we'll discuss software testing and how to design **integration**
    and **end-to-end tests** to ensure your application works as expected.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论软件测试以及如何设计**集成**和**端到端测试**以确保你的应用程序按预期工作。
- en: 'There are numerous types of software testing, which we can divide into two
    categories: functional tests, which ensure that functional requirements and specifications
    are satisfied, and non-functional tests, which focus on testing the behavior and
    performance of the system. We''ll talk about two types of functional tests in
    this section:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试有众多类型，我们可以将其分为两大类：功能测试，确保功能需求和规范得到满足，以及非功能测试，专注于测试系统的行为和性能。在本节中，我们将讨论两种类型的功能测试：
- en: '**Integration tests**: We write this type of test to ensure that different
    software components integrate and work correctly to deliver the specified feature.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：我们编写此类测试以确保不同的软件组件能够集成并正确工作，以提供指定的功能。'
- en: '**End-to-end tests**: We write this type of test to cover complete user flows,
    ensuring that features satisfy user expectations.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试**：我们编写此类测试以覆盖完整的用户流程，确保功能满足用户期望。'
- en: It's important to mention that coding the test is only one task of implementing
    software testing, and it's not worth it if you don't have solid feature specifications
    and test plans.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要提到，编写测试代码只是实施软件测试的一个任务，如果没有坚实的功能规范和测试计划，那么这并不值得。
- en: Let's start discussing integration tests.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始讨论集成测试。
- en: Understanding integration testing
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解集成测试
- en: We perform integration tests to ensure that the different modules present in
    the application work correctly and communicate to deliver the requested feature.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行集成测试以确保应用中存在的不同模块能够正确工作并通信以提供所需的功能。
- en: 'Let''s take our CRM application as an example. We implemented a feature to
    show the application in different languages by configuring the Umi locale plugin.
    We could execute an integration test to ensure that the `SelectLang` component
    works correctly with `plugin-locale` to show the application in the language selected.
    In that case, we would need to follow these steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以我们的CRM应用程序为例。我们通过配置Umi本地化插件实现了显示不同语言的应用程序的功能。我们可以执行一个集成测试来确保`SelectLang`组件与`plugin-locale`正确工作，以显示所选语言的应用程序。在这种情况下，我们需要遵循以下步骤：
- en: Hover over the user's name in the upper-right corner.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在右上角的用户名上。
- en: Select **English** from the drop-down menu.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择**英语**。
- en: Check whether the page is in English.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查页面是否为英语。
- en: We can manually execute the integration test following a test plan depending
    on the test strategy. Still, a better option is to write our tests using automated
    testing tools for repeating the tests, as necessary, with more agility.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据测试策略遵循测试计划手动执行集成测试。然而，更好的选择是使用自动化测试工具编写我们的测试，以便在必要时以更高的敏捷性重复测试。
- en: We'll learn how to use automated test tools to develop integration and end-to-end
    tests in the upcoming sections. Next, let's learn more about end-to-end tests.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中学习如何使用自动化测试工具来开发集成和端到端测试。接下来，让我们更深入地了解端到端测试。
- en: Understanding end-to-end testing
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解端到端测试
- en: As the name suggests, an end-to-end test covers the user journey to execute
    a task from beginning to end. We need to perform the same actions an actual user
    must perform, validating the system integrity and alignment with requirements.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，端到端测试涵盖了从开始到结束执行任务的整个用户旅程。我们需要执行实际用户必须执行的同一步骤，验证系统的完整性和与要求的对齐。
- en: 'For example, imagine that our CRM application has a feature to print the report
    on the reposts page. An end-to-end test to validate this scenario should cover
    the following steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们的CRM应用程序有一个在帖子页面打印报告的功能。为了验证这个场景，端到端测试应该包括以下步骤：
- en: Log into the application.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录应用程序。
- en: Click on the reports menu.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击报告菜单。
- en: Wait for the charts to load and validate whether they were correctly rendered.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待图表加载并验证它们是否正确渲染。
- en: Click on the print button.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击打印按钮。
- en: Open the generated PDF and validate the report.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开生成的PDF并验证报告。
- en: As you can see, this type of test involves several steps depending on the complexity
    of the system and the task. We can perform end-to-end tests manually following
    a test plan or automate this process using automated testing tools.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这种类型的测试涉及多个步骤，具体取决于系统的复杂性和任务的性质。我们可以根据测试计划手动执行端到端测试，或者使用自动化测试工具自动化此过程。
- en: End-to-end tests usually require robust testing tools and are written by **quality
    assurance** (**QA**) professionals. Still, we can write end-to-end tests during
    the development phase. This approach will reduce the issues during the QA phase
    and accelerate the fixing of issues.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试通常需要强大的测试工具，并由**质量保证**（**QA**）专业人员编写。然而，我们可以在开发阶段编写端到端测试。这种方法将减少QA阶段的问题，并加速问题的修复。
- en: We'll learn how to use Puppeteer to write and automate end-to-end tests in the
    upcoming sections.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习如何使用Puppeteer编写和自动化端到端测试。
- en: Implementing software testing is an extensive subject. If you want to learn
    more about this topic, I recommend the article at [https://www.ibm.com/topics/software-testing](https://www.ibm.com/topics/software-testing).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试是一个广泛的主题。如果您想了解更多关于这个主题的信息，我推荐阅读[https://www.ibm.com/topics/software-testing](https://www.ibm.com/topics/software-testing)上的文章。
- en: In this section, we discussed software testing by learning how to design integration
    and end-to-end tests. Next, you'll learn how to write tests in JavaScript projects
    using Jest.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过学习如何设计集成和端到端测试来讨论软件测试。接下来，您将学习如何在JavaScript项目中使用Jest编写测试。
- en: Writing tests with Jest
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jest编写测试
- en: "In this section, you'll learn how to write tests using the **Jest framework**\
    \ in \LJavaScript projects."
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何在JavaScript项目中使用**Jest框架**编写测试。
- en: Jest is a fast and reliable test framework for JavaScript projects focusing
    on simplicity. It works with Babel, TypeScript, Node, React, Angular, Vue, and
    other tools.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Jest是一个针对JavaScript项目的快速且可靠的测试框架，注重简洁性。它与Babel、TypeScript、Node、React、Angular、Vue和其他工具兼容。
- en: After installing it, we can start using Jest without any extra configuration.
    In our case, we can write a test and run the `test` command configured in our
    project without even installing Jest, as Umi already provides Jest with the `umi-test`
    package.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，我们可以开始使用 Jest 而无需任何额外配置。在我们的例子中，我们甚至不需要安装 Jest，因为 Umi 已经通过 `umi-test` 包提供了
    Jest。
- en: 'Consider this end-to-end test written with Jest to test the login flow:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下使用 Jest 编写的端到端测试，以测试登录流程：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this test, all instructions are written inside the `it` method. You can also
    use the `test` method instead if you want. The difference between these two methods
    is just semantics.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，所有指令都写在 `it` 方法内部。如果您愿意，也可以使用 `test` 方法。这两种方法之间的区别只是语义上的。
- en: 'Here, the `it` method receives two arguments: the first argument is the test
    name and the second is an async function that executes the test instructions.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`it` 方法接收两个参数：第一个参数是测试名称，第二个是一个执行测试指令的异步函数。
- en: Notice the `expect` method combined with the `toBeTruthy` `loggeduser` ID exists
    on the page.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意查看页面上的 `expect` 方法与 `toBeTruthy` `loggeduser` ID 的组合。
- en: We use matchers to test values against different conditions. You can find a
    complete list of available Jest matchers at [https://jestjs.io/docs/expect](https://jestjs.io/docs/expect).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用匹配器来测试值与不同条件的一致性。您可以在 [https://jestjs.io/docs/expect](https://jestjs.io/docs/expect)
    找到可用的所有 Jest 匹配器的完整列表。
- en: Next, you'll see how to organize related tests by creating a test suite.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将看到如何通过创建测试套件来组织相关测试。
- en: Understanding the describe method
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 `describe` 方法
- en: 'When writing multiple related tests, you should organize them within a test
    suite using the `describe` method, as in the following example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写多个相关测试时，您应该使用 `describe` 方法在测试套件中组织它们，如下例所示：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we used the `describe` method to create a group for two tests
    related to math problems.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了 `describe` 方法为与数学问题相关的两个测试创建了一个组。
- en: Let's see how we can execute some setup work before and after the entire test
    suite or each test run.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在整个测试套件或每个测试运行之前和之后执行一些设置工作。
- en: Executing instructions before and after tests
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在测试前后执行指令
- en: 'Sometimes, you''ll have some setup to do before running tests, such as initializing
    a database connection or generating mock data. You can do that by defining the
    instructions in the `beforeAll` method to execute before all the tests run or
    the `beforeEach` method to execute instructions before each test run. Consider
    the following example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在运行测试之前，您可能需要进行一些设置，例如初始化数据库连接或生成模拟数据。您可以通过在 `beforeAll` 方法中定义指令来在所有测试运行之前执行，或者通过在
    `beforeEach` 方法中定义指令来在每个测试运行之前执行。考虑以下示例：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, before all the tests ran, we opened the database connection,
    and before each test run, we used the connection to query the product in the database.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，在所有测试运行之前，我们打开了数据库连接，在每个测试运行之前，我们使用该连接查询数据库中的产品。
- en: 'Also, in this example, we need to close the database connection after running
    the test suite. We can do that by adding the `afterAll` method, as shown in the
    next example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在这个例子中，我们需要在运行测试套件后关闭数据库连接。我们可以通过添加 `afterAll` 方法来实现，如下一个示例所示：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Like the `afterAll` method, you can use the `afterEach` method to execute instructions
    after each test run.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `afterAll` 方法类似，您可以使用 `afterEach` 方法在每个测试运行后执行指令。
- en: In this section, you learned how to write tests using the Jest framework. You
    learned how to create test suites and execute instructions before and after the
    tests run.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何使用 Jest 框架编写测试。您学习了如何创建测试套件以及在测试运行前后执行指令。
- en: Next, let's learn about Puppeteer and write integration and end-to-end tests
    for our application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们了解 Puppeteer 并为我们的应用程序编写集成和端到端测试。
- en: Testing interfaces with Puppeteer
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Puppeteer 测试接口
- en: In this section, you'll learn how to write integration and end-to-end tests
    using **Puppeteer** and the **Headless Chrome browser**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何使用 **Puppeteer** 和 **无头 Chrome 浏览器** 编写集成和端到端测试。
- en: Puppeteer is a Node library to control the Chrome, Chromium, or Firefox browser
    over the DevTools protocol (or remote protocol for Firefox), which makes it an
    excellent tool for simulating real scenarios during tests.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer 是一个 Node 库，它通过 DevTools 协议（或 Firefox 的远程协议）控制 Chrome、Chromium 或 Firefox
    浏览器，这使得它成为在测试期间模拟真实场景的绝佳工具。
- en: When we launch a new browser instance, Puppeteer will default to using **Chrome's
    headless mode**. Chrome's headless mode only includes the browser engine, with
    no user interface. Puppeteer uses the Chrome DevTools protocol to control the
    browser.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动一个新的浏览器实例时，Puppeteer 将默认使用 **Chrome 的无头模式**。Chrome 的无头模式仅包括浏览器引擎，没有用户界面。Puppeteer
    使用 Chrome DevTools 协议来控制浏览器。
- en: With Puppeteer, we can take screenshots of the page, test responsiveness by
    simulating numerous mobile devices, such as tablets and smartphones, and more.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Puppeteer，我们可以对页面进行截图，通过模拟多种移动设备（如平板电脑和智能手机）来测试响应性，等等。
- en: You can learn more about Puppeteer on the document page available at [https://developers.google.com/web/tools/puppeteer](https://developers.google.com/web/tools/puppeteer).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://developers.google.com/web/tools/puppeteer](https://developers.google.com/web/tools/puppeteer)
    的文档页面了解更多关于 Puppeteer 的信息。
- en: We'll write an integration test and an end-to-end test to demonstrate the use
    of Puppeteer and Jest.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个集成测试和一个端到端测试来展示 Puppeteer 和 Jest 的使用。
- en: Testing the access and layout plugins
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试访问和布局插件
- en: 'Let''s start by installing Puppeteer by running the following command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从运行以下命令来安装 Puppeteer 开始：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Puppeteer's configuration is as simple as Jest's. By running this command, Puppeteer
    will install the latest version of the Chromium browser, and we can start using
    it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer 的配置与 Jest 一样简单。通过运行此命令，Puppeteer 将安装最新版本的 Chromium 浏览器，然后我们可以开始使用它。
- en: 'Now, follow these steps to create the integration test:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下步骤创建集成测试：
- en: Create a new folder named `tests` in the project's root folder.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录下创建一个名为 `tests` 的新文件夹。
- en: In the `tests` folder, create a new file named `integration.test.ts`. Jest will
    execute all files with a name that includes `.test.ts`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `tests` 文件夹中，创建一个名为 `integration.test.ts` 的新文件。Jest 将执行所有名称包含 `.test.ts` 的文件。
- en: 'In the `integration.test.ts` file, create a test suite, as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `integration.test.ts` 文件中，创建一个测试套件，如下所示：
- en: '[PRE5]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, before all tests run, we launch Puppeteer and store the instance in the
    `browser` variable. By default, Puppeteer will launch Chromium in headless mode.
    Still, you can launch the full browser version by setting the `headless` option,
    as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在所有测试运行之前，我们启动 Puppeteer 并将实例存储在 `browser` 变量中。默认情况下，Puppeteer 将以无头模式启动
    Chromium。不过，你可以通过设置 `headless` 选项来启动完整浏览器版本，如下所示：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By setting the `headless` option to `false`, you can see Puppeteer opening windows
    and executing the tests.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `headless` 选项设置为 `false`，你可以看到 Puppeteer 打开窗口并执行测试。
- en: '![Figure 6.1 – Running an integration test in the full browser version'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.1 – 在完整浏览器版本中运行集成测试'
- en: '](img/Figure_6.01_B18503.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.01_B18503.jpg)'
- en: Figure 6.1 – Running an integration test in the full browser version
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 在完整浏览器版本中运行集成测试
- en: We create an anonymous browser context by opening an incognito window before
    each test run to execute them in an isolated environment and store the incognito
    window in the `context` variable. After each test run, we close the incognito
    window, and after the entire suite run, we close the browser.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次测试运行之前，我们通过打开一个隐身窗口来创建一个匿名浏览器上下文，以在隔离环境中执行它们，并将隐身窗口存储在 `context` 变量中。在每次测试运行之后，我们关闭隐身窗口，在整个测试套件运行之后，我们关闭浏览器。
- en: 'You''ll notice that TypeScript can''t find Jest types. We must install the
    declaration file by running the following command:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到 TypeScript 找不到 Jest 类型。我们必须通过运行以下命令来安装声明文件：
- en: '[PRE7]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, let's create an integration test to ensure that the Umi access plugin correctly
    works with the layout plugin to show the 403 error page when unauthorized users
    try to access a restricted page.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个集成测试来确保 Umi 访问插件能够正确地与布局插件协同工作，在未经授权的用户尝试访问受限制的页面时显示 403 错误页面。
- en: 'Add the following test to the test suite in the `integration.test.ts` file
    under the `tests` folder:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试添加到 `tests` 文件夹下的 `integration.test.ts` 文件中的测试套件：
- en: '[PRE8]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this test, after opening a page and setting the default timeout for `async`
    operations to `10000` milliseconds, Puppeteer performs the following steps:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，在打开页面并将 `async` 操作的默认超时设置为 `10000` 毫秒之后，Puppeteer 执行以下步骤：
- en: Logs into the application as John Doe
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 John Doe 的身份登录应用程序
- en: Goes to the workflow page
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳转到工作流程页面
- en: Selects the element with the `unauthorized` ID
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择具有 `unauthorized` ID 的元素
- en: Evaluates the text message inside the element and tests whether the message
    is correct
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估元素内的文本消息并测试消息是否正确
- en: Notice that we used the `waitForSelector` method to ensure that the element
    is already rendered when selecting it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了 `waitForSelector` 方法来确保在选中元素时它已经被渲染。
- en: 'Next, we need to create the `login` function. Add the `login` function before
    the `describe` method, as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建 `login` 函数。在 `describe` 方法之前添加 `login` 函数，如下所示：
- en: '[PRE9]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function will perform the steps to log in to the application as John Doe.
    We can reuse the `login` function in other tests within the test suite. Notice
    we used the `waitForNavigation` method to ensure that the components are rendered
    before performing the steps.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将执行以约翰·多伊（John Doe）身份登录应用程序的步骤。我们可以在测试套件中的其他测试中重用 `login` 函数。注意我们使用了 `waitForNavigation`
    方法来确保在执行步骤之前组件已渲染。
- en: Now, we need to add the `unauthorized` ID to the element containing the text
    that we'll validate when running the test.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将 `unauthorized` ID 添加到包含我们将验证的文本的元素中。
- en: 'Open the `app.tsx` file located in the `src` folder and modify the layout `unAccessible`
    configuration option, as follows:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于 `src` 文件夹中的 `app.tsx` 文件，并修改布局 `unAccessible` 配置选项，如下所示：
- en: '[PRE10]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We enclosed the text with a `span` tag containing the `id` property we need.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将包含所需 `id` 属性的文本包裹在一个 `span` 标签中。
- en: We also need to add the `id` properties to the login form inputs.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将 `id` 属性添加到登录表单输入中。
- en: 'Open the `index.tsx` file located under `src/pages/Login/LoginForm` and modify
    the username input by adding the `username` ID, as follows:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于 `src/pages/Login/LoginForm` 下的 `index.tsx` 文件，并通过添加 `username` ID 来修改用户名输入，如下所示：
- en: '[PRE11]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, modify the password input by adding the `password` ID, as follows:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过添加 `password` ID 来修改密码输入，如下所示：
- en: '[PRE12]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, add the `loginbtn` ID to the login button, as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将 `loginbtn` ID 添加到登录按钮中，如下所示：
- en: '[PRE13]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can execute the test by running the `yarn test` command. The result should
    look as in the following screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行 `yarn test` 命令来执行测试。结果应如下截图所示：
- en: '![Figure 6.2 – Integration test result'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.2 – Integration test result]'
- en: '](img/Figure_6.02_B18503.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_6.02_B18503.jpg]'
- en: Figure 6.2 – Integration test result
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 集成测试结果
- en: Now, let's create an end-to-end test to ensure that the feature for editing
    an opportunity works as expected.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个端到端测试来确保编辑机会的功能按预期工作。
- en: Testing the opportunity editing feature
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试机会编辑功能
- en: 'Follow these steps to create the end-to-end test to ensure the editing feature
    works as expected on the opportunities page:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建端到端测试，以确保在机会页面上编辑功能按预期工作：
- en: 'We''ll create a separate file for end-to-end tests. In the `tests` folder,
    create a file named `end2end.test.ts`, and create the `describe` method, as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在 `tests` 文件夹中创建一个名为 `end2end.test.ts` 的单独文件，并创建 `describe` 方法，如下所示：
- en: '[PRE14]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, add the end-to-end test to the `describe` method, as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将端到端测试添加到 `describe` 方法中，如下所示：
- en: '[PRE15]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have written the instructions for Puppeteer to open a new page and set the
    default timeout to `1000`, go to the login page, and wait for the page to load.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为 Puppeteer 编写了打开新页面并设置默认超时为 `1000` 的说明，转到登录页面，并等待页面加载。
- en: 'Add the instructions to log into the application, as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加登录应用程序的说明，如下所示：
- en: '[PRE16]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Puppeteer will type the user's email address in the input with the `username`
    ID and the password in the input with the `password` ID, then click on the button
    with the `loginbtn` ID. Finally, Puppeteer will navigate to the opportunities
    page.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer 将在具有 `username` ID 的输入中输入用户的电子邮件地址，并在具有 `password` ID 的输入中输入密码，然后点击具有
    `loginbtn` ID 的按钮。最后，Puppeteer 将导航到机会页面。
- en: 'Add the steps to edit the opportunity topic, as follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加编辑机会主题的步骤，如下所示：
- en: '[PRE17]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Puppeteer will wait for the element with the id equal to `editopportunity` to
    be rendered before clicking on it and selecting the text by triple-clicking the
    input element. Next, Puppeteer will type new text in the topic input and save
    the opportunity.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer 将等待具有 id 等于 `editopportunity` 的元素渲染，然后点击它并通过三击输入元素选择文本。接下来，Puppeteer
    将在主题输入中输入新文本并保存机会。
- en: 'Now, let''s add the steps to evaluate the result, as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加评估结果的步骤，如下所示：
- en: '[PRE18]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Puppeteer will select the topic cell in the first row of the opportunities table
    and evaluate its text content. Next, Jest will test the value to ensure it's correct.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer 将选择机会表的第一行的主题单元格并评估其文本内容。接下来，Jest 将测试该值以确保其正确性。
- en: 'Finally, let''s add the `id` property to the elements we need to find during
    the test. In the `columns.tsx` file, under the `pages/Opportunities` folder, add
    the `id` property to the edit option anchor, as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将 `id` 属性添加到测试期间需要查找的元素中。在 `columns.tsx` 文件中，在 `pages/Opportunities` 文件夹下，将
    `id` 属性添加到编辑选项锚点中，如下所示：
- en: '[PRE19]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the `index.ts` file, in the same folder, add the `saveText` property to
    the editable attribute of the `ProTable` component, as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件夹中的`index.ts`文件中，将`saveText`属性添加到`ProTable`组件的可编辑属性中，如下所示：
- en: '[PRE20]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Before executing the test, let''s add the `--runInBand` flag to the `umi-test`
    command in the `package.json` file, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行测试之前，让我们将`--runInBand`标志添加到`package.json`文件中的`umi-test`命令中，如下所示：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This flag will prevent a race condition between these two tests as we are using
    the mock API to simulate the backend.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此标志将防止这两个测试之间的竞争条件，因为我们正在使用模拟API来模拟后端。
- en: 'Now, you can execute the test by running the `yarn test` command. The result
    should look like the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过运行`yarn test`命令来执行测试。结果应该如下所示：
- en: '![Figure 6.3 – End-to-end test result'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.3 – End-to-end test result'
- en: '](img/Figure_6.03_B18503.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.03 – End-to-end test result](img/Figure_6.03_B18503.jpg)'
- en: Figure 6.3 – End-to-end test result
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 6.3 – End-to-end test result
- en: In this section, you learned how to write integration tests and end-to-end tests
    using Puppeteer. To demonstrate the use of Puppeteer with Jest, we created an
    integration test to ensure the Umi locale plugin works correctly with the layout
    plugin to render the 403 error page. We also created an end-to-end test to ensure
    the feature to edit an opportunity works as expected.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何使用Puppeteer编写集成测试和端到端测试。为了演示如何使用Puppeteer与Jest结合，我们创建了一个集成测试来确保Umi本地化插件与布局插件正确协同工作以渲染403错误页面。我们还创建了一个端到端测试来确保编辑机会的功能按预期工作。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed software testing by learning how to design integration
    and end-to-end tests. You learned how to use the Jest framework to write tests
    in React projects. You saw how to use the `describe` and `test` (or `it`) methods
    to write and organize related tests. You also learned how to execute instructions
    before and after tests run using the `beforeAll`, `beforeEach`, `afterAll`, and
    `afterEach` methods.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过学习如何设计集成和端到端测试来讨论软件测试。你学习了如何在React项目中使用Jest框架编写测试。你看到了如何使用`describe`和`test`（或`it`）方法来编写和组织相关测试。你还学习了如何在测试运行前后使用`beforeAll`、`beforeEach`、`afterAll`和`afterEach`方法执行指令。
- en: You then learned how to write tests using Puppeteer and Headless Chrome by simulating
    user interaction on your interface. To demonstrate the use of Puppeteer with Jest,
    we created an integration test to ensure the Umi locale plugin works correctly
    with the layout plugin and also created an end-to-end test to ensure the feature
    to edit an opportunity works as expected.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你学习了如何通过模拟用户界面上的用户交互来使用Puppeteer和Headless Chrome编写测试。为了演示如何使用Puppeteer与Jest结合，我们创建了一个集成测试来确保Umi本地化插件与布局插件正确协同工作，并创建了一个端到端测试来确保编辑机会的功能按预期工作。
- en: In the next chapter, we will learn how to compile and deploy our applications
    to online services.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何编译和部署我们的应用程序到在线服务。
