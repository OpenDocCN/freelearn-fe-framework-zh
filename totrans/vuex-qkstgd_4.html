<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Coding the EveryNote App Using Vuex State Management</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we will develop an application to take notes, called <em>EveryNote</em>, from scratch. In the first part of the chapter we will analyze and design the application, as well as preparing the folder structure for the project.</p>
<p class="mce-root">After that, we will build the application incrementally through tests and code. This application will be developed while writing this chapter, providing a real-world Vuex development example. </p>
<p>The application can be downloaded by cloning the <kbd>https://github.com/PacktPublishing/-Vuex-Condensed</kbd> Git repository. Each section of this chapter has a corresponding Git tag that can be used to download the code that has been written for that section.</p>
<p>While reading this chapter, you will learn how to do the following:</p>
<ul>
<li>Design and develop an application exploiting Vuex features</li>
<li>Use Vuex inside Vue components</li>
<li>Test Vue/Vuex components effectively</li>
<li>Use actions to handle asynchronous operations</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You will be required to have Node.js installed on a system. <span>Finally, to use the Git repository of this book, the user needs to install Git. </span></p>
<p>The code files of this chapter can be found on GitHub:<br/>
<a href="https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-4" target="_blank">https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-4</a></p>
<p>Check out the following video to see the code in action:<br/>
<a href="https://goo.gl/QaPP1Q" target="_blank">https://goo.gl/QaPP1Q</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing the EveryNote web app</h1>
                </header>
            
            <article>
                
<p>One way to start designing an application is by creating mock-ups of the user interfaces. This way, you can present your mock-ups to your stakeholders, discuss them, update your mock-ups accordingly, and resubmit them to stakeholders. This can be done before you start developing.</p>
<p>The <span class="packt_screen">EveryNote</span> app will look like the following mock-up:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/dbfb3a8a-4524-4637-bd18-ef9729a75f07.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 3.2: EveryNote mock-up interface</div>
<p>The application will have the following features:</p>
<ul>
<li>Create new notes</li>
<li>Show all notes</li>
<li>Update an existing note</li>
<li>Delete a note</li>
<li>Save notes to <kbd>LocalStorage</kbd></li>
</ul>
<p>After basic features are implemented, we will also add two more features:</p>
<ul>
<li>Search among notes</li>
<li>Pin a note</li>
</ul>
<p>In a real-world application, you may need user stories to <span>better</span><span> </span><span>define what the behaviors expected are and, thus, what programmers should code. These stories can be tested, and this type of test is called an acceptance test.</span></p>
<p><span>In this case, the EveryNote features are simple and well defined, so we can begin by picking a feature and starting to develop it.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application structure</h1>
                </header>
            
            <article>
                
<p>Vuex proposes an application-generic structure, which we will adopt. The following is the folder structure:</p>
<pre>test # test folder<br/>├── test_file.spec.js # a test file<br/>└── ...<br/>src # app main folder<br/>├── index.html<br/>├── main.js<br/>├── api<br/>│ └── ... # abstractions for making API requests<br/>├── components<br/>│ ├── App.vue<br/>│ └── ...<br/>└── store<br/>    ├──index.js #here we assemble modules and export the store<br/>    ├── actions.js # root actions<br/>    ├── mutations.js # root mutations<br/>    └── modules<br/>        ├── module_a.js # a module<br/>        └── module_b.js # another module</pre>
<p>We are now going to create the project scaffold by adding some files to the <kbd>notes-app</kbd> folder we created at the beginning of this chapter.</p>
<p>The first file to be created is <kbd>index.html</kbd>. As for any Vue.js application, we need to put the root container for the Vue/Vuex application inside the body as follows:</p>
<pre>&lt;!-- src/index.html --&gt;<br/>&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>  &lt;meta charset="UTF-8"&gt;<br/>  &lt;title&gt;Packt: Vuex condensed EveryNote&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/><strong>&lt;div id="app"&gt;&lt;/div&gt;</strong><br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>The second file is <kbd>main.js</kbd>. It contains the code to startup the Vue.js part of the application:</p>
<pre><span>// src/main.js<br/></span><span>import </span>Vue <span>from </span><span>'vue'</span><span>;<br/></span><span>import </span>App <span>from </span><span>'./components/App.vue'</span><span>;<br/></span><span>import </span>store <span>from </span><span>'./store'</span><span>;<br/></span><span><br/></span><strong>new Vue({</strong><br/><strong>  el: '#app',</strong><br/><strong>  store,</strong><br/><strong>  render: h =&gt; h(App),</strong><br/><strong>})</strong><span>;<br/></span></pre>
<p>Now that the Vue application is ready, we can add Vuex to it by creating <kbd>index.js </kbd><span>inside the </span><kbd>store</kbd> <span>folder</span><span>:</span></p>
<pre><span>// src/store/index.js</span><span><br/></span><span>import </span>Vuex <span>from </span><span>'vuex'</span><span>;<br/></span><span>import </span>Vue <span>from </span><span>'vue'</span><span>;<br/></span><span><br/></span><strong>Vue.use(Vuex);<br/></strong><span><br/></span><span>const </span>debug = <span>process</span>.<span>env</span>.<span>NODE_ENV </span>!== <span>'production'</span><span>;<br/></span><span>const </span>store = <strong>new Vuex.Store</strong>({<br/> <span>state</span>: {}<span>,<br/></span><span> </span><span>strict</span>: debug<span>,<br/></span>})<span>;<br/></span><span><br/></span><span>export default </span>store<span>;<br/></span></pre>
<p>Finally, we create the root Vue component of the <em>EveryNote</em> app as follows:</p>
<pre>// src/components/App.vue<br/><span>&lt;template&gt;<br/></span><span> &lt;div </span><span>class=</span><span>"app"</span><span>&gt;</span>EveryNote app<span>&lt;/div&gt;<br/></span><span>&lt;/template&gt;<br/></span><span>&lt;script&gt;<br/></span><span> </span><span>export default </span>{}<span>;<br/></span><span>&lt;/script&gt;<br/></span><span>&lt;style&gt;<br/></span><span> </span>.<span>app </span>{<br/> <span>font-family</span>: <span>"Times New Roman"</span><span>, </span><span>Times</span><span>, </span><span>serif</span><span>;<br/></span><span> </span><span>background-image</span>: <span>url</span>(<span>"background.jpeg"</span>)<span>;<br/></span><span> </span>}<br/><span>&lt;/style&gt;</span></pre>
<p>Clone the <kbd>book</kbd> repository and use <kbd>git checkout step-0_project-scaffold</kbd> to see all the project files for this step.</p>
<p>Now that the project scaffold is ready, we can start coding the first feature.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing the EveryNote app</h1>
                </header>
            
            <article>
                
<p>In the following paragraphs, I will develop the application using test-driven development. You don't need to know TDD to understand what I will be doing. You will <span>first</span><span> </span><span>be presented with a test asserting what the code should do as if it were already implemented, and then, just after, you will see the implementation.</span></p>
<p>But why use TDD in this book?</p>
<p>One reason is that I think it is easier to understand what the code is supposed to do by reading assertions about its behavior inside the test code, rather than inferring its behavior from implementation code.</p>
<p>Another reason is that it is easier to understand how to test a component while writing the component rather than having a (boring) chapter on testing components.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a to-do list to help the development process</h1>
                </header>
            
            <article>
                
<p>I find that writing a to-do list in a file is useful for reminding me what needs to be done. I also find it helpful to note down doubts and simple notes on things I need to deal with.</p>
<p>This to-do list is a simple<span> </span><kbd>.txt</kbd><span> </span>file that changes over time, and will hopefully <span>be</span><span> </span><span>empty when the app is finished. I also put this file under <kbd>Git revision</kbd>.</span></p>
<p>The initial <kbd>To-do</kbd> list looks like this:</p>
<pre>To-do:<br/>Show all notes*<br/>Create new notes<br/>Update an existing note<br/>Delete a note<br/>Save notes to LocalStorage<br/><br/>Extra:<br/>Search among notes<br/>Pin a note<br/><br/>Done:</pre>
<p><span>I use the <kbd>*</kbd> </span><span>symbol</span><span> </span><span>to mark the current feature under development.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Displaying a list of notes</h1>
                </header>
            
            <article>
                
<p><span>I will start by displaying a list of notes because the other features depend on it. Another possible feature to start with is the ability to create a new note.</span></p>
<p>In order to display a list of notes, we need to add that list to the application's <kbd>Vuex.Store</kbd>. Then we need a Vue component that uses the store to display the notes.</p>
<p>The first test is about defining a note list inside the application's main store:</p>
<pre><span>// test/store/store.spec.js<br/>import store from '../../src/store';<br/><br/>describe('EveryNote main store', () =&gt; {<br/>  it('<strong>should have a list of notes</strong>', () =&gt; {<br/>    expect(Array.isArray(store.state.noteList)).toBe(true);<br/>  });<br/>});<br/></span></pre>
<p>Next, define the implementation:</p>
<pre>// src/store/index.js<br/><br/>import ...<br/>// ...<br/>const store = new Vuex.Store({<br/>  state: {<br/>    <strong>noteList: []</strong>,<br/>  },<br/>  strict: debug,<br/>});<br/>...</pre>
<p>From now on, you will <span>first</span><span> </span><span>see a frame detailing a component's tests, and, just after, a frame with the code implementation. You will be provided with a description of test-driven development later on in this chapter. For now, it is important that you understand that TDD has a pace: one test, one piece of production code, one test, one piece of production code, and so on.</span></p>
<p>This is also referred to as red, green, refactor:</p>
<ul>
<li><strong>Red</strong>: You write a small test and the result of executing it is a test failing—you'll see  red in the test console.</li>
<li><strong>Green</strong>: You make the test pass in the easiest way<span>—you'll see  green in the test console. </span>Duplicating code in this step is allowed.</li>
<li><strong>Refactor</strong>: You remove code duplication and improve code quality if you feel it is necessary.</li>
</ul>
<p>The next step is creating a Vue component <kbd>noteList</kbd> to show the list of notes.</p>
<p>Test code:</p>
<pre><span>// test/components/NoteList.spec.js<br/>import Vue from 'vue';<br/>import Vuex from 'vuex';<br/>import NoteList from '../../src/components/NoteList.vue';<br/><br/>describe('NoteList.vue', () =&gt; {<br/>  let store;<br/>  let noteList;<br/><br/>  function newNoteListCmp() {<br/>    const Constructor = Vue.extend(NoteList);<br/>    return new Constructor({<br/>      store,<br/>    }).$mount();<br/>  }<br/><br/>  beforeEach(() =&gt; {<br/>    Vue.use(Vuex);<br/><br/>    noteList = [];<br/>    store = new Vuex.Store({<br/>      state: { noteList },<br/>    });<br/>  });<br/><br/>  it('<strong>should expose store.noteList</strong>', () =&gt; {<br/>    const noteListCmp = newNoteListCmp();<br/><br/>    expect(noteListCmp.notes).toBe(noteList);<br/>  });<br/><br/>  it('<strong>should cycle through noteList</strong>', () =&gt; {<br/>    noteList.push({});<br/>    noteList.push({});<br/><br/>    const noteListCmp = newNoteListCmp();<br/><br/>    const contents =<br/>      noteListCmp.$el.querySelectorAll('.content');<br/>    expect(contents.length).toBe(2);<br/>  });<br/><br/>  it('<strong>should render notes inside noteList</strong>', () =&gt; {<br/>    const title = 'Note title';<br/>    const content = 'Note content';<br/>    noteList.push({ title, content });<br/><br/>    const noteListCmp = newNoteListCmp();<br/><br/>    const { $el } = noteListCmp;<br/>    const titleEl = $el.querySelector('.title');<br/>    const contentEl = $el.querySelector('.content');<br/>    expect(titleEl.textContent).toBe(title);<br/>    expect(contentEl.textContent).toBe(content);<br/>  });<br/>});</span></pre>
<p><span>Application code:</span></p>
<pre>// src/components/NoteList.vue<br/><span>&lt;template&gt;<br/></span><span>  &lt;div </span><span>class=</span><span>"container"</span><span>&gt;<br/></span><span>    &lt;div </span><strong>v-for="note in notes"</strong><span>&gt;<br/></span><span>      &lt;div </span><span>class=</span><span>"title"</span><span>&gt;</span>{{<strong>note.title</strong>}}<span>&lt;/div&gt;<br/></span><span>      &lt;div </span><span>class=</span><span>"content"</span><span>&gt;</span>{<strong>{note.content</strong>}}<span>&lt;/div&gt;<br/></span><span>    &lt;/div&gt;<br/></span><span>  &lt;/div&gt;<br/></span><span>&lt;/template&gt;<br/></span><span>&lt;script&gt;<br/></span><span>  </span><span>import </span>{ mapState } <span>from </span><span>'vuex'</span><span>;<br/></span><span><br/></span><span>  </span><span>export default </span>{<br/>    <span>computed</span>: mapState({<br/>      <strong>notes: 'noteList'</strong><span>,<br/></span><span>    </span>})<span>,<br/></span><span>  </span>}<span>;<br/></span><span>&lt;/script&gt;<br/></span><span>&lt;style&gt;<br/></span><span>&lt;/style&gt;</span></pre>
<p><span>Even though I put together all of these tests in one place for better readability, I didn't write the three tests and then the code. I wrote the first test, then the code, then the next test, and so on. Remember the red-green-refactor pattern!</span></p>
<p>In order to write the <kbd>NoteList</kbd> code I needed three tests:</p>
<ul>
<li>The first test checks that there is a computed property named <kbd>notes</kbd> that exposes <kbd>state.store.NoteList</kbd></li>
<li>The second test ensures that each note inside <kbd>notes</kbd> is rendered in the template section</li>
<li>Finally, the last test ensures that the note's title and content are rendered</li>
</ul>
<p>In addition, there is some code to set up the test environment in order to mock the store and create the component. Each item being tested should be isolated. This means that we cannot use the real store, and we need to provide a mocked one for each component being tested.</p>
<p>There is a framework, <kbd>vue-test-utils</kbd>, that can be used to test Vue components. I decided not to use it for the sake of keeping the examples in this book simple. You may want to use it when writing your applications.</p>
<p>We can now proceed to the next feature, but I would <span>first</span><span> </span><span>like to see some notes actually shown in the browser before moving on. To achieve this, we can</span> temporarily add two notes to the store and add the <kbd>NoteList</kbd> component to <kbd>App.vue</kbd>.</p>
<p>Test code:</p>
<pre>// src/store/index.js<br/>import Vuex from 'vuex';<br/>import Vue from 'vue';<br/><br/>Vue.use(Vuex);<br/><br/>const debug = process.env.NODE_ENV !== 'production';<br/>const store = new Vuex.Store({<br/>  state: {<br/>    noteList: [<br/><strong>      { title: 'title A', content: 'content 1' },</strong><br/><strong>      { title: 'title B', content: 'content 2' },</strong><br/>    ],<br/>  },<br/>  strict: debug,<br/>});<br/><br/>export default store;</pre>
<p>Application code:</p>
<pre>// src/components/App.vue<br/>&lt;template&gt;<br/>  &lt;div class="app"&gt;<br/>    &lt;div&gt;EveryNote app&lt;/div&gt;<br/>    <strong>&lt;note-list&gt;&lt;/note-list&gt;</strong><br/>  &lt;/div&gt;<br/>&lt;/template&gt;<br/>&lt;script&gt;<br/>  import NoteList from './NoteList.vue';<br/><br/>  export default {<br/>    components: {<br/>      NoteList,<br/>    },<br/>  };<br/>&lt;/script&gt;<br/>&lt;style&gt;<br/>  .app {<br/>    font-family: "Times New Roman", Times, serif;<br/>    background-image: url("background.jpeg");<br/>  }<br/>&lt;/style&gt;</pre>
<p>The following is a screenshot of the result:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/538f970e-6aad-49d0-8b8e-ac8a05d2e794.png" style=""/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 3.3: List of notes</div>
<p>Right now, the result is ugly; I will add some CSS to make it much better looking after all the main features are implemented.</p>
<p>You can download the code at this stage by typing:</p>
<pre><strong>git checkout step-1_note-list</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating new notes</h1>
                </header>
            
            <article>
                
<p>At this point, the <kbd>To-do</kbd> list looks like this:</p>
<pre>To-do:<br/>Create new notes*<br/>- NoteEditor component<br/>- Update current note mutation<br/>- Add note to noteList mutation<br/>- Add note action<br/><br/>Update an existing note<br/>Delete a note<br/>Save notes to LocalStorage<br/><br/>Extra:<br/>Search among notes<br/>Pin a note<br/><br/>Done:<br/>Show all notes<br/>  - Add note list to the store<br/>  - Note list vue component<br/>  -- Add a temporary note list to the store</pre>
<p>The next feature I will implement is the ability to create new notes. For this feature, we need a <kbd>NoteEditor </kbd><span>component</span><span>, a store property named </span><kbd>currentNote</kbd><span>, an action named</span> <kbd>addNote</kbd><span>, and two mutations:</span> <kbd>UPDATE_CURRENT_NOTE</kbd> <span>and </span><kbd>ADD_NOTE</kbd><span>.</span></p>
<p>The idea is that when a user writes in the note editor, the <kbd>currentNote</kbd> store property gets updated. When he taps on the <span class="packt_screen">Add note</span> button, the <kbd>addNote</kbd> <span>action</span><span> </span><span>is fired, resulting in the new note added to the note list. </span>Let's add the <kbd>currentNote</kbd> property to the application store.</p>
<p>Test code:</p>
<pre><span>// test/store/store.spec.js<br/>import store from '../../src/store';<br/><br/>describe('EveryNote main store', () =&gt; {<br/>  it('should have a list of notes', () =&gt; {<br/>    expect(Array.isArray(store.state.noteList)).toBe(true);<br/>  });<br/><br/>  it('should have currentNote property', () =&gt; {<br/>    const { state } = store;<br/>    expect(state.currentNote.title).not.toBe(undefined);<br/>    expect(state.currentNote.content).not.toBe(undefined);<br/>  });<br/>});</span></pre>
<p><span>Application code:</span></p>
<pre><span>// src/store/index.js<br/></span><span><br/>//...<br/><br/></span><span>const </span>store = <span>new </span>Vuex.Store({<br/>  <span>state</span>: {<br/>    <span>noteList</span>: [<br/>      { <span>title</span>: <span>'title A'</span><span>, </span><span>content</span>: <span>'content 1' </span>}<span>,<br/></span><span>      </span>{ <span>title</span>: <span>'title B'</span><span>, </span><span>content</span>: <span>'content 2' </span>}<span>,<br/></span><span>    </span>]<span>,<br/></span><span>    </span><strong>currentNote: { title: '', content: '' }</strong><span><strong>,</strong><br/></span><span>  </span>}<span>,<br/>  mutations,<br/></span><span>  </span><span>strict</span>: debug<span>,<br/></span>})<span>;</span><span><br/></span></pre>
<p>You may wonder why I added a test just to verify that the <kbd>currentNote</kbd> field is inside the app store. The idea here is that I am not writing tests to test that the application works properly—I am writing tests to write production code. In order to modify any line of the application code, I need a test to justify the fact that I am writing production code.</p>
<p>This is the first of the three TDD rules (by <span>Robert C. Martin, aka Uncle Bob</span>):</p>
<ul>
<li>You are not allowed to write any production code unless it makes a failing unit test pass</li>
</ul>
<p>The other two are as follows:</p>
<ul>
<li>You are not allowed to write any more of a unit test that is sufficient to fail, and compilation failures are failures</li>
<li>You are not allowed to write any more production code that is sufficient to pass the one failing unit test</li>
</ul>
<p>So why didn't I write any tests when I added two fake notes to the store and modified <kbd>App.vue</kbd> to use the <kbd>NoteList</kbd> component? Because that is temporary code and not production code. I will remove those modifications before the app is completed.</p>
<p>Now that <kbd>currentNote</kbd> is defined, I can write an <kbd>UPDATE_CURRENT_NOTE</kbd> mutation.</p>
<p>Test code:</p>
<pre>// test/store/mutations.spec.js<br/>import { mutations, types } from '../../src/store/mutations';<br/><br/>describe('EveryNote root mutations', () =&gt; {<br/>  it('<strong>should update current note</strong>', () =&gt; {<br/>    const updateCurrentNote<br/>      = mutations[types.UPDATE_CURRENT_NOTE];<br/>    const state = { currentNote: { title: '', content: '' } };<br/>    const newNote = { title: 'title', content: 'some text' };<br/><br/>    updateCurrentNote(state, newNote);<br/><br/>    expect(state.currentNote).toEqual(newNote);<br/>  });<br/>});</pre>
<p>Application code:</p>
<pre><span>// src/store/mutations.js<br/>export const types = {<br/>  UPDATE_CURRENT_NOTE: 'UPDATE_CURRENT_NOTE',<br/>};<br/><br/>export const mutations = {<br/>  <strong>[types.UPDATE_CURRENT_NOTE](state, { title, content }) {</strong><br/><strong>    state.currentNote = { title, content };</strong><br/><strong>  }</strong>,<br/>};<br/></span></pre>
<p>Next, create the <kbd>NoteEditor</kbd> component.</p>
<p>Test code:</p>
<pre><span>// test/components/NoteEditor.spec.js<br/>import Vue from 'vue';<br/>import Vuex from 'vuex';<br/>import NoteEditor from '../../src/components/NoteEditor.vue';<br/>import { types, mutations } from '../../src/store/mutations';<br/>import actions from '../../src/store/actions';<br/><br/>const { UPDATE_CURRENT_NOTE } = types;<br/>describe('NoteEditor component', () =&gt; {<br/>  let store;<br/>  let currentNote;<br/><br/>  function newNoteEditorCmp() {<br/>    const Constructor = Vue.extend(NoteEditor);<br/>    store = new Vuex.Store({<br/>            state: { currentNote, noteList: [] },<br/>      mutations,<br/>      actions,<br/>    });<br/>    return new Constructor({<br/>      store,<br/>    }).$mount();<br/>  }<br/><br/>  beforeEach(() =&gt; {<br/>    Vue.use(Vuex);<br/>    currentNote = { title: 'title', content: 'content' };<br/>  });<br/><br/>  it('<strong>should expose currentNote.content as content</strong>', () =&gt; {<br/>    const editorCmp = newNoteEditorCmp();<br/><br/>    expect(editorCmp.content).toBe(currentNote.content);<br/>  });<br/><br/>  it('<strong>should expose currentNote.content setter</strong>', () =&gt; {<br/>    const editorCmp = newNoteEditorCmp();<br/>    store.commit = jasmine.createSpy('commit spy');<br/>    const newContent = 'A new content';<br/><br/>    editorCmp.content = newContent;<br/><br/>    const expected = {<br/>      title: currentNote.title,<br/>      content: newContent,<br/>    };<br/>    expect(store.commit)<br/>      .toHaveBeenCalledWith(UPDATE_CURRENT_NOTE, expected);<br/>  });<br/><br/>  it('<strong>should expose currentNote.title as title</strong>', () =&gt; {<br/>    const editorCmp = newNoteEditorCmp();<br/><br/>    expect(editorCmp.title).toBe(currentNote.title);<br/>  });<br/><br/>  it('<strong>should expose currentNote.title setter</strong>', () =&gt; {<br/>    const editorCmp = newNoteEditorCmp();<br/>    store.commit = jasmine.createSpy('commit spy');<br/>    const newTitle = 'A new title';<br/><br/>    editorCmp.title = newTitle;<br/><br/>    const expected = {<br/>      title: newTitle,<br/>      content: currentNote.content,<br/>    };<br/>    expect(store.commit)<br/>      .toHaveBeenCalledWith(UPDATE_CURRENT_NOTE, expected);<br/>  });<br/><br/>  it('<strong>should render current note inside the editor</strong>', () =&gt; {<br/>    const editorCmp = newNoteEditorCmp();<br/><br/>    const { $el } = editorCmp;<br/>    const contentEl = $el.querySelector('.content');<br/>    const titleEl = $el.querySelector('.title');<br/>    expect(contentEl.value).toBe(currentNote.content);<br/>    expect(titleEl.value).toBe(currentNote.title);<br/>  });<br/>});</span></pre>
<p><span>Application code:</span></p>
<pre>// src/components/NoteEditor.vue<br/>&lt;template&gt;<br/>  &lt;div&gt;<br/>    &lt;input <strong>v-model="title"</strong> type="text" class="title"/&gt;<br/>    &lt;input <strong>v-model="content"</strong> type="text" class="content"/&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;<br/>&lt;script&gt;<br/>  import { types } from '../store/mutations';<br/><br/>  const { UPDATE_CURRENT_NOTE } = types;<br/>  export default {<br/>    computed: {<br/>      <strong>content</strong>: {<br/>        get() {<br/>          return this.$store.state.currentNote.content;<br/>        },<br/>        set(value) {<br/>          const newContent = {<br/>            title: this.title,<br/>            content: value,<br/>          };<br/>          this.$store.commit(UPDATE_CURRENT_NOTE, newContent);<br/>        },<br/>      },<br/>      <strong>title</strong>: {<br/>        get() {<br/>          return this.$store.state.currentNote.title;<br/>        },<br/>        set(value) {<br/>          const newContent = {<br/>            title: value,<br/>            content: this.content,<br/>          };<br/>          this.$store.commit(UPDATE_CURRENT_NOTE, newContent);<br/>        },<br/>      },<br/>    },<br/>  };<br/>&lt;/script&gt;<br/>&lt;style&gt;&lt;/style&gt;</pre>
<p>In order to code the <kbd>NoteEditor</kbd> component, I tested that the computed <kbd>content</kbd> and <kbd>title</kbd> <span>properties we</span><span>re properly linked to</span> <kbd>$store.state.currentNote</kbd><span>, and that these properties were used in the <kbd>template</kbd> section.</span></p>
<p>As with the tests for the <kbd>NoteList</kbd> component, the first part of the <kbd>test</kbd> file is just some code to create the component under <kbd>test</kbd>. I will avoid repeating that part from now on.</p>
<p>The next step is creating the <kbd>addNote</kbd> action and the corresponding mutation so that I can update <kbd>NoteEditor</kbd> to dispatch this action when a user presses the <span class="packt_screen">Add note</span> button. Following is the <kbd>ADD_NOTE</kbd> mutation.</p>
<p>Test code:</p>
<pre>// test/store/mutations.spec.js<br/>import { mutations, types } from '../../src/store/mutations';<br/><br/>describe('EveryNote root mutations', () =&gt; {<br/>  it('should update current note', () =&gt; {<br/>    // ...<br/>  });<br/><br/>  it('<strong>should add a note to noteList</strong>', () =&gt; {<br/>    const ADD_NOTE = mutations[types.ADD_NOTE];<br/>    const state = { noteList: [] };<br/>    const newNote = { title: 'title', content: 'some text' };<br/><br/>    ADD_NOTE(state, newNote);<br/><br/>    expect(state.noteList['0']).toBe(newNote);<br/>  });<br/>});</pre>
<p>Application code:</p>
<pre>// src/store/mutations.js<br/>export const types = {<br/>  UPDATE_CURRENT_NOTE: 'UPDATE_CURRENT_NOTE',<br/>  <strong>ADD_NOTE: 'ADD_NOTE'</strong>,<br/>};<br/><br/>export const mutations = {<br/>  [types.UPDATE_CURRENT_NOTE](state, { title, content }) {<br/>    state.currentNote = { title, content };<br/>  },<br/>  <strong>[types.ADD_NOTE](state, aNote) {</strong><br/><strong>    state.noteList.push(aNote);</strong><br/><strong>  }</strong>,<br/>};</pre>
<p>Following is the <kbd>addNote</kbd> action tests:</p>
<pre>// test/store/actions.spec.js<br/><br/>import actions from '../../src/store/actions';<br/>import { types } from '../../src/store/mutations';<br/><br/>describe('EveryNote root actions', () =&gt; {<br/>  it('<strong>should have addNote action</strong>', () =&gt; {<br/>    const { addNote } = actions;<br/>    const mockContext = {<br/>      commit: jasmine.createSpy('commit'),<br/>    };<br/>    const aNote = {};<br/><br/>    addNote(mockContext, aNote);<br/><br/>    expect(mockContext.commit)<br/>      .toHaveBeenCalledWith(types.ADD_NOTE, aNote);<br/>  });<br/>});</pre>
<p>Following is the application code:</p>
<pre><span>// src/store/actions<br/>import </span>{ types } <span>from </span><span>'./mutations'</span><span>;<br/></span><span><br/></span><span>export default </span>{<br/>  <strong>addNote({ commit }, aNote) {</strong><br/><strong>    commit(types.ADD_NOTE, aNote);<br/>  }</strong><span>,<br/></span>}<span>;<br/></span></pre>
<p>Finally, I can update <kbd>NoteEditor</kbd> to dispatch the <kbd>addNote</kbd> action and see that the note list gets updated. First, let's update <kbd>NoteEditor</kbd>.</p>
<p>Test code:</p>
<pre>// test/components/NoteEditor.spec.js<br/>import // ...<br/><br/>const { UPDATE_CURRENT_NOTE } = types;<br/>describe('NoteEditor component', () =&gt; {<br/>  let store;<br/>  let currentNote;<br/><br/>  function newNoteEditorCmp() {<br/>    // ...<br/>  }<br/><br/>  // ...<br/><br/>  it('<strong>should have addNote method</strong>', () =&gt; {<br/>    const editorCmp = newNoteEditorCmp();<br/>    spyOn(store, 'dispatch');<br/><br/>    editorCmp.addNote();<br/><br/>    expect(store.dispatch)<br/>      .toHaveBeenCalledWith('addNote', currentNote);<br/>  });<br/><br/>  it('<strong>should not add empty notes</strong>', () =&gt; {<br/>    const editorCmp = newNoteEditorCmp();<br/>    spyOn(store, 'dispatch');<br/>    currentNote.title = '';<br/>    currentNote.content = '';<br/><br/>    editorCmp.addNote();<br/><br/>    expect(store.dispatch).not.toHaveBeenCalled();<br/>  });<br/><br/>  it('<strong>should reset title and content on addNote</strong>', () =&gt; {<br/>    const editorCmp = newNoteEditorCmp();<br/><br/>    editorCmp.addNote();<br/><br/>    expect(editorCmp.title).toBe('');<br/>    expect(editorCmp.content).toBe('');<br/>  });<br/>});</pre>
<p>Application code:</p>
<pre>// src/components/NoteEditor.vue<br/>&lt;template&gt;<br/>  &lt;div&gt;<br/>    &lt;input v-model="title" type="text" class="title"<br/>           placeholder="title"/&gt;<br/>    &lt;input v-model="content" type="text" class="content"<br/>           placeholder="content"/&gt;<br/>    <strong>&lt;button @click="addNote"&gt;Add note&lt;/button&gt;</strong><br/>  &lt;/div&gt;<br/>&lt;/template&gt;<br/>&lt;script&gt;<br/>  import { types } from '../store/mutations';<br/><br/>  const { UPDATE_CURRENT_NOTE } = types;<br/>  export default {<br/>    computed: {<br/>      content: {<br/>        // ...<br/>      },<br/>      title: {<br/>        // ...<br/>      },<br/>    },<br/>    methods: {<br/>      <strong>addNote()</strong> {<br/>        if (this.title !== '' || this.content !== '') {<br/>          const newNote = {<br/>            title: this.title,<br/>            content: this.content,<br/>          };<br/><br/>          this.$store.dispatch('addNote', newNote);<br/>        }<br/>        this.title = '';<br/>        this.content = '';<br/>      },<br/>    },<br/>  };<br/>&lt;/script&gt;</pre>
<p>Now let's add <kbd>actions</kbd> to the store:</p>
<pre><span>// src/store/index.js<br/></span><span>import // ...</span><span><br/></span><span>import </span>actions <span>from </span><span>'./actions'</span><span>;<br/></span><span><br/>// ...<br/><br/></span><span>const </span>store = <span>new </span>Vuex.Store({<br/>  <span>state</span>: { // ...<span> </span>}<span>,<br/></span><span>  </span>mutations<span>,<br/></span><span>  </span><strong>actions</strong><span>,<br/></span><span>  </span><span>strict</span>: debug<span>,<br/></span>})<span>;</span></pre>
<p><span>and <kbd>NoteEditor</kbd> to <kbd>App.vue</kbd></span><span><br/></span></p>
<pre>// src/components/App.vue<br/><span>&lt;template&gt;<br/></span><span>  &lt;div </span><span>class=</span><span>"app"</span><span>&gt;<br/></span><span>    &lt;div&gt;</span>EveryNote app<span>&lt;/div&gt;<br/></span><span><strong>    &lt;note-editor&gt;&lt;/note-editor&gt;</strong><br/></span><span>    &lt;note-list&gt;&lt;/note-list&gt;<br/></span><span>  &lt;/div&gt;<br/></span><span>&lt;/template&gt;<br/></span><span>&lt;script&gt;<br/></span><span>  </span><span>import </span>NoteList <span>from </span><span>'./NoteList.vue'</span><span>;<br/></span><span>  </span><strong>import NoteEditor from './NoteEditor.vue'</strong><span><strong>;</strong><br/></span><span><br/></span><span>  </span><span>export default </span>{<br/>    <span>components</span>: {<br/>      NoteList<span>,<br/></span><span>      </span><strong>NoteEditor</strong><span>,<br/></span><span>    </span>}<span>,<br/></span><span>  </span>}<span>;<br/></span><span>&lt;/script&gt;<br/></span><span>&lt;style&gt;<br/></span>    // ...<br/><span>&lt;/style&gt;</span></pre>
<p>After having added some CSS to the components and restyling the application <span>a bit</span><span>, it now looks like the following figure:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/831c78fb-1eda-4d3e-8e19-5f3d3626785a.png" style=""/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 3.4: EveryNote restyled</div>
<p>You can download the code at this stage by typing the following:</p>
<pre><strong>git checkout step-2_create-notes</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting existing notes</h1>
                </header>
            
            <article>
                
<p>The next feature I am going to implement is the ability to delete notes. The following is the updated <kbd>To-do</kbd> list:</p>
<pre>To-do:<br/>Delete a note*<br/>- delete action<br/>- delete mutation<br/>- create Note component and use it in NoteList component<br/><br/>Update an existing note<br/>Save notes to LocalStorage<br/><br/>Extra:<br/>Search among notes<br/>Pin a note<br/><br/>Done:<br/>Show all notes<br/>Create new notes</pre>
<p>In order to let users delete notes, I need to update the note frame to have a <span class="packt_screen">delete</span> button, add a <kbd>deleteNote</kbd> action, and add a <kbd>DELETE_NOTE</kbd> mutation. Finally, I will extract the note frame code from <kbd>NoteList</kbd> and create a <kbd>Note</kbd> component. Let's create the <kbd>DELETE_NOTE</kbd> mutation.</p>
<p>Test code:</p>
<pre><span>// test/store/mutations.spec.js<br/></span><span>import </span>{ mutations<span>, </span>types } <span>from </span><span>'../../src/store/mutations'</span><span>;<br/></span><span><br/></span><span>describe</span>(<span>'EveryNote root mutations'</span><span>, </span>() =&gt; {<br/>   // ...<span><br/></span><span><br/></span><span>  </span><span>it</span>(<span>'<strong>should delete a note</strong>'</span><span>, </span>() =&gt; {<br/>    <span>const </span>DELETE_NOTE = mutations[types.<span>DELETE_NOTE</span>]<span>;<br/></span><span>    </span><span>const </span>aNote = {}<span>;<br/></span><span>    </span><span>const </span>state = { <span>noteList</span>: [aNote] }<span>;<br/></span><span><br/></span><span>    </span>DELETE_NOTE(state<span>, </span>aNote)<span>;<br/></span><span><br/></span><span>    </span><span>expect</span>(state.<span>noteList</span>.length).<span>toBe</span>(<span>0</span>)<span>;<br/></span><span>  </span>})<span>;<br/></span><span><br/></span><span>  </span><span>it</span>(<span>'<strong>should NOT delete a note if not inside noteList</strong>'</span><span>, </span>()=&gt;{<br/>    <span>const </span>DELETE_NOTE = mutations[types.<span>DELETE_NOTE</span>]<span>;<br/></span><span>    </span><span>const </span>aNote = {}<span>;<br/></span><span>    </span><span>const </span>state = { <span>noteList</span>: [aNote] }<span>;<br/></span><span>    </span><span>const </span>anotherNote = {}<span>;<br/></span><span><br/></span><span>    </span>DELETE_NOTE(state<span>, </span>anotherNote)<span>;<br/></span><span><br/></span><span>    </span><span>expect</span>(state.<span>noteList</span>.length).<span>toBe</span>(<span>1</span>)<span>;<br/></span><span>  </span>})<span>;<br/></span>})<span>;</span></pre>
<p><span>Application code:</span></p>
<pre><span>// src/store/mutations.js<br/></span><span>export const </span>types = {<br/>  <span>UPDATE_CURRENT_NOTE</span>: <span>'UPDATE_CURRENT_NOTE'</span><span>,<br/></span><span>  </span><span>ADD_NOTE</span>: <span>'ADD_NOTE'</span><span>,<br/></span><span>  </span><strong>DELETE_NOTE: 'DELETE_NOTE'</strong><span>,<br/></span>}<span>;<br/></span><span><br/></span><span>export const </span>mutations = {<br/>  // ...<span><br/></span><strong>  [types.DELETE_NOTE](state, aNote)</strong> {<br/>    <span>const </span>index = state.<span>noteList</span>.<span>indexOf</span>(aNote)<span>;<br/></span><span>    </span><span>if </span>(index &gt;= <span>0</span>) {<br/>      state.<span>noteList</span>.<span>splice</span>(index<span>, </span><span>1</span>)<span>;<br/></span><span>    </span>}<br/>  }<span>,<br/></span>}<span>;<br/></span></pre>
<p>Then let's add <kbd>deleteNote</kbd> to the actions.</p>
<p>Test code:</p>
<pre><span>// test/store/actions.spec.js</span><span><br/></span><span>import </span>actions <span>from </span><span>'../../src/store/actions'</span><span>;<br/></span><span>import </span>{ types } <span>from </span><span>'../../src/store/mutations'</span><span>;<br/></span><span><br/></span><span>describe</span>(<span>'EveryNote root actions'</span><span>, </span>() =&gt; {<br/>  // ..<span><br/></span><span>  </span><span>it</span>(<span>'<strong>should have deleteNote action</strong>'</span><span>, </span>() =&gt; {<br/>    <span>const </span>{ <span>deleteNote </span>} = actions<span>;<br/></span><span>    </span><span>const </span>mockContext = {<br/>      <span>commit</span>: jasmine.<span>createSpy</span>(<span>'commit'</span>)<span>,<br/></span><span>    </span>}<span>;<br/></span><span>    </span><span>const </span>aNote = {}<span>;<br/></span><span><br/></span><span>    </span><span>deleteNote</span>(mockContext<span>, </span>aNote)<span>;<br/></span><span><br/></span><span>    </span><span>expect</span>(mockContext.<span>commit</span>)<br/>      .<span>toHaveBeenCalledWith</span>(types.<span>DELETE_NOTE</span><span>, </span>aNote)<span>;<br/></span><span>  </span>})<span>;<br/></span>})<span>;</span></pre>
<p><span>Application code:</span></p>
<pre><span>// src/store/actions<br/></span><span>import </span>{ types } <span>from </span><span>'./mutations'</span><span>;<br/></span><span><br/></span><span>export default </span>{<br/>  // ...<span><br/></span><span>  </span><strong>deleteNote({ commit }, aNote)</strong> {<br/>    commit(types.<span>DELETE_NOTE</span><span>, </span>aNote)<span>;<br/></span><span>  </span>}<span>,<br/></span>}<span>;<br/></span></pre>
<p>Now let's refactor the <kbd>NoteList</kbd> component to use a new component named <kbd>Note</kbd>:</p>
<pre>// src/components/NoteList.vue<br/>&lt;template&gt;<br/>  &lt;div class="container"&gt;<br/>    <strong>&lt;note v-for="(note, i) in notes" :note="note" :key="i"&gt;</strong><br/><strong>    &lt;/note&gt;</strong><br/>  &lt;/div&gt;<br/>&lt;/template&gt;<br/>&lt;script&gt;<br/>  // ...<br/>&lt;/script&gt;<br/>&lt;style scoped&gt;<br/>  // ...</pre>
<p>Then we move the test of the note rendering from the <kbd>NoteList</kbd> to the <kbd>Note</kbd> component:</p>
<pre>// test/components/Note.spec.js<br/>import Vue from 'vue';<br/>import Vuex from 'vuex';<br/>import Note from '../../src/components/Note.vue';<br/><br/>describe('Note.vue', () =&gt; {<br/>  let note;<br/>  let store;<br/>  beforeEach(() =&gt; {<br/>    Vue.use(Vuex);<br/>    note = { title: 'title', content: 'content' };<br/>  });<br/><br/>  function newNoteCmp() {<br/>    const Constructor = Vue.extend(Note);<br/>    store = new Vuex.Store({<br/>      state: {},<br/>    });<br/>    return new Constructor({<br/>      propsData: { note },<br/>      store,<br/>    }).$mount();<br/>  }<br/><br/>  it('<strong>should render a note</strong>', () =&gt; {<br/>    const { title, content } = note;<br/><br/>    const noteCmp = newNoteCmp();<br/><br/>    const { $el } = noteCmp;<br/>    const titleEl = $el.querySelector('.title');<br/>    const contentEl = $el.querySelector('.content');<br/>    expect(titleEl.textContent.trim()).toBe(title);<br/>    expect(contentEl.textContent.trim()).toBe(content);<br/>  });<br/>});</pre>
<p>Next, let's write the new <kbd>Note</kbd> component:</p>
<pre>// src/components/Note.vue<br/><span>&lt;template&gt;<br/></span><strong>  </strong><strong>&lt;div class="note"&gt;<br/>    &lt;div class="title"&gt;{{note.title}}&lt;/div&gt;<br/>    &lt;div class="content" v-text="note.content"&gt;</strong><span><strong>&lt;/div&gt;<br/></strong></span><span>  &lt;/div&gt;<br/></span><span>&lt;/template&gt;<br/></span><span>&lt;script&gt;<br/></span><span>  </span><span>export default </span>{<br/>    <strong>props: ['note']</strong><span>,<br/></span><span>  </span>}<span>;<br/></span><span>&lt;/script&gt;<br/></span><span>&lt;style </span><span>scoped</span><span>&gt;</span><br/>  /* ... */<br/><span>&lt;/style&gt;</span></pre>
<p>Finally, we can add a delete button to the <kbd>Note</kbd> component, which will dispatch a <kbd>deleteNote</kbd> action upon being clicked:</p>
<pre>// test/components/Note.spec.js<br/>import Vue from 'vue';<br/>import Vuex from 'vuex';<br/>import Note from '../../src/components/Note.vue';<br/><br/>describe('Note.vue', () =&gt; {<br/>  let note;<br/>  let store;<br/>  beforeEach(() =&gt; {<br/>    Vue.use(Vuex);<br/>    note = { title: 'title', content: 'content' };<br/>  });<br/><br/>  function newNoteCmp() {<br/>   // ...<br/>  }<br/><br/>  it('should render a note', () =&gt; {<br/>    // ...<br/>  });<br/><br/>  it('<strong>should emit deleteNote on delete tap</strong>', () =&gt; {<br/>    const noteCmp = newNoteCmp();<br/>    spyOn(store, 'dispatch');<br/><br/>    noteCmp.onDelete();<br/><br/>    expect(store.dispatch)<br/>      .toHaveBeenCalledWith('deleteNote', note);<br/>  });<br/>});</pre>
<p>Following is the updated <kbd>Note.vue</kbd> code that will make the test pass:</p>
<pre>// src/components/Note.vue<br/><span>&lt;template&gt;<br/></span><span>  &lt;div </span><span>class=</span><span>"note"</span><span>&gt;<br/></span><span>    &lt;div </span><span>class=</span><span>"title"</span><span>&gt;</span>{{note.<span>title</span>}}<span>&lt;/div&gt;<br/></span><span>    &lt;div </span><span>class=</span><span>"content" </span><span>v-text=</span><span>"</span>note.<span>content</span><span>"</span><span>&gt;<br/></span><span>    &lt;/div&gt;<br/></span><span>    &lt;div </span><span>class=</span><span>"icons"</span><span>&gt;<br/></span><strong>      &lt;img class="delete" src="./delete.svg"<br/>           @click="onDelete"</strong><span><strong>/&gt;</strong><br/></span><span>    &lt;/div&gt;<br/></span><span>  &lt;/div&gt;<br/></span><span>&lt;/template&gt;<br/></span><span>&lt;script&gt;<br/></span><span>  </span><span>export default </span>{<br/>    <span>props</span>: [<span>'note'</span>]<span>,<br/></span><span>    </span><span>methods</span>: {<br/>      <strong>onDelete() {</strong><br/><strong>        this.$store.dispatch('deleteNote', this.note);<br/>      }</strong><span>,<br/></span><span>    </span>}<span>,<br/></span><span>  </span>}<span>;<br/></span><span>&lt;/script&gt;<br/></span><span>&lt;style </span><span>scoped</span><span>&gt;<br/></span><span>  // ...</span><br/><span>&lt;/style&gt;</span></pre>
<p>In order to run the preceding code, you need a <kbd>delete.svg</kbd> file. You can find it in the Git repository of this book, or you can use another image.</p>
<p>You can download the code at this stage by typing the following:</p>
<pre><strong>git checkout step-3_delete-notes</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating existing notes</h1>
                </header>
            
            <article>
                
<p>In order to edit an existing note, we could reuse the <kbd>NoteEditor</kbd> component. Right now, this component is linked to the <kbd>currentNote</kbd> property of the main store, but we could use a property to pass the note to be edited, thereby removing its dependency from the main store. This kind of generalization is common while developing Vuex applications, and often leads to two kinds of components:</p>
<ul>
<li><strong>Dumb components</strong>: These do not alter or handle application states; they just receive input through properties and dispatch events</li>
<li><strong>Smart components</strong>: These serve as containers for the dumb components; they handle interactions between child components and are dependent on Vuex elements, such as application states and actions</li>
</ul>
<p>A dumb component should be designed to be reusable, whereas a smart component should be designed to be application dependent.</p>
<p><kbd>NoteEditor</kbd> can be refactored into a <kbd>dumb</kbd> component, letting its parent link it to the application's state.</p>
<p>I noted down these considerations on the <kbd>To-do</kbd> list:</p>
<pre>To-do:<br/>Update an existing note*<br/>- re-use NoteEditor with an existing note<br/><br/>Considerations:<br/>- NoteList could be refactored into a dumb component<br/><br/>Save notes to LocalStorage<br/><br/>Extra:<br/>Search among notes<br/>Pin a note<br/><br/>Done:<br/>Show all notes<br/>Create new notes<br/>Delete a note</pre>
<p>As you may have noticed, I am also considering transforming <kbd>NoteList</kbd> into a dumb component so that it can be used to show different lists of notes, such as the pinned notes or the notes that match certain search keywords.</p>
<p>Let's start by refactoring <kbd>NoteEditor</kbd> into a <kbd>dumb</kbd> component:</p>
<pre><span>// test/components/NoteEditor.spec.js<br/></span><span>import </span>Vue <span>from </span><span>'vue'</span><span>;<br/></span><span>import </span>NoteEditor <span>from </span><span>'../../src/components/NoteEditor.vue'</span><span>;<br/></span><span><br/></span><span>describe</span>(<span>'NoteEditor component'</span><span>, </span>() =&gt; {<br/>  <span>let </span>note<span>;<br/></span><span><br/></span><span>  </span><span>function </span><span>newNoteEditorCmp</span>() {<br/>    <span>const </span>Constructor = Vue.<span>extend</span>(NoteEditor)<span>;<br/></span><span>    </span><span>return new </span>Constructor({<br/>      <strong>propsData: { note }</strong><span>,<br/></span><span>    </span>}).<span>$mount</span>()<span>;<br/></span><span>  </span>}<br/><br/>  <span>beforeEach</span>(() =&gt; {<br/>    note = { <span>title</span>: <span>'title'</span><span>, </span><span>content</span>: <span>'content' </span>}<span>;<br/></span><span>  </span>})<span>;<br/></span><span><br/></span><span>  </span><span>it</span>(<span>'<strong>should init title and content to note prop</strong>'</span><span>, </span>() =&gt; {<br/>    <span>const </span>editorCmp = <span>newNoteEditorCmp</span>()<span>;<br/></span><span><br/></span><span>    </span><span>expect</span>(editorCmp.<span>title</span>).not.<span>toBe</span>(<span>undefined</span>)<span>;<br/></span><span>    </span><span>expect</span>(editorCmp.<span>title</span>).<span>toBe</span>(note.<span>title</span>)<span>;<br/></span><span>    </span><span>expect</span>(editorCmp.<span>content</span>).not.<span>toBe</span>(<span>undefined</span>)<span>;<br/></span><span>    </span><span>expect</span>(editorCmp.<span>content</span>).<span>toBe</span>(note.<span>content</span>)<span>;<br/></span><span>  </span>})<span>;<br/></span><span><br/></span><span>  </span><span>it</span>(<span>'<strong>should have onEditDone method ' </strong></span><strong>+</strong><br/>    <span><strong>'that emits the edited note</strong>'</span><span>, </span>() =&gt; {<br/>    <span>const </span>editorCmp = <span>newNoteEditorCmp</span>()<span>;<br/></span><span>    </span><span>spyOn</span>(editorCmp<span>, </span><span>'$emit'</span>)<span>;<br/></span><span>    </span><span>const </span>newNote = { <span>title</span>: <span>'a'</span><span>, </span><span>content</span>: <span>'b' </span>}<span>;<br/></span><span><br/></span><span>    </span>editorCmp.<span>title </span>= newNote.<span>title</span><span>;<br/></span><span>    </span>editorCmp.<span>content </span>= newNote.<span>content</span><span>;<br/></span><span>    </span>editorCmp.<span>onEditDone</span>()<span>;<br/></span><span><br/></span><span>    </span><span>expect</span>(editorCmp.<span>$emit</span>)<br/>      .<span>toHaveBeenCalledWith</span>(<span>'editDone'</span><span>, </span>newNote)<span>;<br/></span><span>  </span>})<span>;<br/></span><span><br/></span><span>  </span><span>it</span>(<span>'<strong>should not emit empty notes</strong>'</span><span>, </span>() =&gt; {<br/>    note.<span>title </span>= <span>''</span><span>;<br/></span><span>    </span>note.<span>content </span>= <span>''</span><span>;<br/></span><span>    </span><span>const </span>editorCmp = <span>newNoteEditorCmp</span>()<span>;<br/></span><span>    </span><span>spyOn</span>(editorCmp<span>, </span><span>'$emit'</span>)<span>;<br/></span><span><br/></span><span>    </span>editorCmp.<span>onEditDone</span>()<span>;<br/></span><span><br/></span><span>    </span><span>expect</span>(editorCmp.<span>$emit</span>).not.<span>toHaveBeenCalled</span>()<span>;<br/></span><span>  </span>})<span>;<br/></span><span><br/></span><span>  </span><span>it</span>(<span>'<strong>should reset title, content after onEditDone</strong>'</span><span>, </span>() =&gt; {<br/>    <span>const </span>editorCmp = <span>newNoteEditorCmp</span>()<span>;<br/></span><span><br/></span><span>    </span>editorCmp.<span>onEditDone</span>()<span>;<br/></span><span><br/></span><span>    </span><span>expect</span>(editorCmp.<span>title</span>).<span>toBe</span>(<span>''</span>)<span>;<br/></span><span>    </span><span>expect</span>(editorCmp.<span>content</span>).<span>toBe</span>(<span>''</span>)<span>;<br/></span><span>  </span>})<span>;<br/></span>})<span>;<br/></span></pre>
<p>As you can see, the tests do not need to use Vuex anymore, and the tests regarding the <kbd>currentNote</kbd> state property will be moved to its container, which will be developed just after this component.</p>
<p>Also, I decided not to test the <kbd>&lt;template&gt;</kbd> part of <kbd>NoteEditor.vue</kbd> because the views change often, and I don't want the tests to slow me down when changing some part of the UI. In my opinion, it is better to reduce the number of unit tests regarding the UI to very few or none. Remember that TDD is about writing code, not about testing existing code. You can write automated tests on a piece of UI when that piece has settled down and is unlikely to change soon. If you agree with me on not testing the views, remember to avoid putting a lot of logic in the <kbd>&lt;template&gt;</kbd> part of a Vue component.</p>
<p>The new <kbd>NoteEditor</kbd> implementation looks like the following:</p>
<pre>// src/components/NoteEditor.vue<br/>&lt;template&gt;<br/>  &lt;div class="container"&gt;<br/>    &lt;div class="centered"&gt;<br/>      &lt;input v-model="title" type="text" class="title"<br/>             placeholder="title"/&gt;&lt;br&gt;<br/>      &lt;textarea v-model="content" class="content"<br/>                rows="3" placeholder="content"&gt;&lt;/textarea&gt;&lt;br&gt;<br/>      &lt;div class="buttons"&gt;<br/>        &lt;button @click="<strong>onEditDone</strong>" class="done"&gt;Done&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;<br/>&lt;script&gt;<br/>  export default {<br/>    <strong>props: ['note']</strong>,<br/>    <strong>data() {</strong><br/><strong>      return {</strong><br/><strong>        title: this.note.title,</strong><br/><strong>        content: this.note.content,</strong><br/><strong>      }</strong>;<br/>    },<br/>    methods: {<br/>      <strong>onEditDone()</strong> {<br/>        if (this.title !== '' || this.content !== '') {<br/>          this.$emit('editDone', {<br/>            title: this.title,<br/>            content: this.content,<br/>          });<br/>        }<br/>        this.title = '';<br/>        this.content = '';<br/>      },<br/>    },<br/>  };<br/>&lt;/script&gt;<br/>&lt;style scoped&gt;<br/>  // ...<br/>&lt;/style&gt;</pre>
<p>We now <span>need</span><span> </span><span>a container for this component, which </span><span>is</span><span> </span><span>the </span><kbd>App.vue</kbd><span> component, plus the code that links</span> <kbd>NoteEditor</kbd> <span>to the </span><kbd>currentNote</kbd> <span>state property:</span></p>
<pre><span>// test/components/App.spec.js<br/></span><span>import </span>Vue <span>from </span><span>'vue'</span><span>;<br/></span><span>import </span>Vuex <span>from </span><span>'vuex'</span><span>;<br/></span><span>import </span>App <span>from </span><span>'../../src/components/App.vue'</span><span>;<br/></span><span><br/></span><span>describe</span>(<span>'App.vue'</span><span>, </span>() =&gt; {<br/>  <span>let </span>store<span>;<br/></span><span>  </span><span>let </span>noteList<span>;<br/></span><span>  </span><span>let </span>currentNote<span>;<br/></span><span><br/></span><span>  </span><span>function </span><span>newAppCmp</span>() {<br/>    <span>const </span>Constructor = Vue.<span>extend</span>(App)<span>;<br/></span><span>    </span>store = <span>new </span>Vuex.Store({<br/>      <span>state</span>: { currentNote<span>, </span>noteList }<span>,<br/></span><span>    </span>})<span>;<br/></span><span><br/></span><span>    </span><span>return new </span>Constructor({<br/>      store<span>,<br/></span><span>    </span>}).<span>$mount</span>()<span>;<br/></span><span>  </span>}<br/><br/>  <span>beforeEach</span>(() =&gt; {<br/>    Vue.<span>use</span>(Vuex)<span>;<br/></span><span>    </span>noteList = []<span>;<br/></span><span>    </span>currentNote = { <span>title</span>: <span>''</span><span>, </span><span>content</span>: <span>'' </span>}<span>;<br/></span><span>  </span>})<span>;<br/></span><span><br/></span><span>  </span><span>it</span>(<span>'<strong>should update store.currentNote ' </strong></span><strong>+</strong><br/>    <span><strong>'on onAddDone event</strong>'</span><span>, </span>() =&gt; {<br/>    <span>const </span>app = <span>newAppCmp</span>()<span>;<br/></span><span>    </span><span>spyOn</span>(app.$store<span>, </span><span>'dispatch'</span>)<span>;<br/></span><span>    </span><span>const </span>aNote = {}<span>;<br/></span><span><br/></span><span>    </span>app.onAddDone(aNote)<span>;<br/></span><span><br/></span><span>    </span><span>expect</span>(app.$store.<span>dispatch</span>)<br/>      .<span>toHaveBeenCalledWith</span>(<span>'addNote'</span><span>, </span>aNote)<span>;<br/></span><span>  </span>})<span>;<br/></span>})<span>;<br/></span></pre>
<p>Following is the code that will make the test pass:</p>
<pre>// src/components/App.vue<br/><span>&lt;template&gt;<br/></span><span>  &lt;div </span><span>class=</span><span>"app"</span><span>&gt;<br/></span><span>    &lt;div </span><span>class=</span><span>"header"</span><span>&gt;</span>EveryNote<span>&lt;/div&gt;<br/></span><span>    &lt;div </span><span>class=</span><span>"body"</span><span>&gt;<br/></span><strong>      &lt;note-editor :note="$store.state.currentNote"<br/>                   @editDone="onAddDone"</strong><span><strong>/&gt;</strong><br/></span><span>      &lt;note-list/&gt;<br/></span><span>    &lt;/div&gt;<br/></span><span>  &lt;/div&gt;<br/></span><span>&lt;/template&gt;<br/></span><span>&lt;script&gt;<br/></span><span>  </span><span>import </span>NoteList <span>from </span><span>'./NoteList.vue'</span><span>;<br/></span><span>  </span><span>import </span>NoteEditor <span>from </span><span>'./NoteEditor.vue'</span><span>;<br/></span><span><br/></span><span>  </span><span>export default </span>{<br/>    <span>components</span>: {<br/>      NoteList<span>,<br/></span><span>      </span>NoteEditor<span>,<br/></span><span>    </span>}<span>,<br/></span><span>    </span><span>methods</span>: {<br/>      <strong>onAddDone(note) {</strong><br/><strong>        this.$store.dispatch('addNote', note);<br/>      }</strong><span>,<br/></span><span>    </span>}<span>,<br/></span><span>  </span>}<span>;<br/></span><span>&lt;/script&gt;<br/></span><span>&lt;style </span><span>scoped</span><span>&gt;<br/></span><span>  // ...</span><br/><span>&lt;/style&gt;</span></pre>
<p>Finally, we need the <kbd>editNote</kbd> and <kbd>updateNote</kbd> actions and the corresponding mutations. The first one will set the current note under editing and the last one will persist changes to the <span>note we </span><span>just edited.</span></p>
<p>Test code:</p>
<pre>// src/store/actions<br/>import { types } from './mutations';<br/><br/>export default {<br/>  addNote({ commit }, aNote) {<br/>    commit(types.ADD_NOTE, aNote);<br/>  },<br/>  deleteNote({ commit }, aNote) {<br/>    commit(types.DELETE_NOTE, aNote);<br/>  },<br/>  <strong>editNote({ commit }, aNote) {</strong><br/><strong>    commit(types.EDIT_NOTE, aNote);</strong><br/><strong>  },</strong><br/><strong>  updateNote({ commit }, aNote) {</strong><br/><strong>    commit(types.UPDATE_NOTE, aNote);</strong><br/><strong>  }</strong>,<br/>};</pre>
<p>Application code:</p>
<pre>// src/store/mutations.js<br/>export const types = {<br/>  UPDATE_CURRENT_NOTE: 'UPDATE_CURRENT_NOTE',<br/>  ADD_NOTE: 'ADD_NOTE',<br/>  DELETE_NOTE: 'DELETE_NOTE',<br/>  <strong>EDIT_NOTE: 'EDIT_NOTE',</strong><br/><strong>  UPDATE_NOTE: 'UPDATE_NOTE',</strong><br/>};<br/><br/>export const mutations = {<br/>  // ...<br/>  <strong>[types.EDIT_NOTE](state, aNote)</strong> {<br/>    const index = state.noteList.indexOf(aNote);<br/>    if (index &gt;= 0) {<br/>      state.editIndex = index;<br/>      state.editNote = state.noteList[index];<br/>    }<br/>  },<br/>  [<strong>types.UPDATE_NOTE](state, aNote)</strong> {<br/>    const index = state.editIndex;<br/>    if (index &gt;= 0) {<br/>      state.editNote = null;<br/>      state.noteList.splice(index, 1, aNote);<br/>      state.editIndex = -1;<br/>    }<br/>  },<br/>};</pre>
<p>The tests are similar to the other action tests that we completed, so I will not repeat them.</p>
<p>The last step is to update the <kbd>Note</kbd> component to dispatch an <kbd>editNote</kbd> action when the user presses the edit icon of a note:</p>
<pre>// src/components/Note.ue<br/>&lt;template&gt;<br/>  &lt;div class="note"&gt;<br/>    &lt;div class="title"&gt;{{note.title}}&lt;/div&gt;<br/>    &lt;div class="content"<br/>         style="white-space: pre-line;" v-text="note.content"&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="icons"&gt;<br/>      <strong>&lt;img class="edit" src="./edit.svg"</strong><br/><strong>           @click="onEdit"/&gt;</strong><br/>      &lt;img class="delete" src="./delete.svg"<br/>           @click="onDelete"/&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;<br/>&lt;script&gt;<br/>  export default {<br/>    props: ['note'],<br/>    methods: {<br/>      onDelete() {<br/>        this.$store.dispatch('deleteNote', this.note);<br/>      },<br/>      <strong>onEdit() {</strong><br/><strong>        this.$store.dispatch('editNote', this.note);</strong><br/><strong>      },</strong><br/>    },<br/>  };<br/>&lt;/script&gt;<br/>&lt;style scoped&gt;<br/>  // ...<br/>&lt;/style&gt;</pre>
<p><span> After that, we modify the </span><kbd>App</kbd><span> </span>component to show the note to be edited when<span> </span><kbd>editNote</kbd><span> is dispatched:</span></p>
<pre>// src/components/App.vue<br/>&lt;template&gt;<br/>  &lt;div class="app"&gt;<br/>    &lt;div class="header"&gt;EveryNote&lt;/div&gt;<br/>    &lt;div class="body"&gt;<br/>      &lt;note-editor :note="$store.state.currentNote"<br/>                   @editDone="onAddDone"/&gt;<br/>      &lt;note-list/&gt;<br/>    &lt;/div&gt;<br/>    <strong>&lt;div class="overlay" v-if="$store.state.editNote"&gt;</strong><br/><strong>      &lt;note-editor class="note-editor" @editDone="onEditDone"</strong><br/><strong>                   :note="$store.state.editNote"/&gt;</strong><br/><strong>    &lt;/div&gt;</strong><br/>  &lt;/div&gt;<br/>&lt;/template&gt;<br/>&lt;script&gt;<br/>  import NoteList from './NoteList.vue';<br/>  import NoteEditor from './NoteEditor.vue';<br/><br/>  export default {<br/>    components: {<br/>      NoteList,<br/>      NoteEditor,<br/>    },<br/>    methods: {<br/>      onAddDone(note) {<br/>        this.$store.dispatch('addNote', note);<br/>      },<br/>      <strong>onEditDone(note) {</strong><br/><strong>        this.$store.dispatch('updateNote', note);</strong><br/><strong>      },</strong><br/>    },<br/>  };<br/>&lt;/script&gt;<br/>&lt;style scoped&gt;<br/>  // ...<br/>&lt;/style&gt;</pre>
<p>You can download the code at this stage by typing the following:</p>
<pre><strong>git checkout step-4_edit-notes</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other features</h1>
                </header>
            
            <article>
                
<p><span>Following is</span> the updated <kbd>To-do</kbd> list that shows what we've done and what's remaining:</p>
<pre>To-do:<br/>Save notes to LocalStorage<br/><br/>Considerations:<br/>- NoteList could be refactored into a dumb component<br/><br/>Extra:<br/>Search among notes<br/>Pin a note<br/><br/>Done:<br/>Show all notes<br/>Create new notes<br/>Delete a note<br/>Update an existing note</pre>
<p>I will not discuss the other features in this book because I think it is now clear how Vuex development works and how Vuex applications can be tested. You can find the complete application code in the book's repository at <kbd>https://github.com/PacktPublishing/-Vuex-Condensed</kbd>.</p>
<p>When persisting notes to <kbd>localStorage</kbd>, instead of saving only the list of notes, we will use a Vuex plugin to save all the application states. You will read about this in the last chapter of this book, which will introduce you to <kbd>vuex-persistedstate</kbd>, a plugin to persist the Vuex application state with <kbd>localStorage</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recap and some considerations</h1>
                </header>
            
            <article>
                
<p>We implemented the so-called CRUD functions, create, read, update, and delete.</p>
<p>The <span class="packt_screen">EveryNote</span> application, at this stage, looks like the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/701b0ccc-04f1-4bfc-ae15-a33242d583b7.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 3.5: EveryNote app with CRUD operations</div>
<p>When tapping on the pencil icon, the note editor opens. The following is a screenshot of the application in editing mode:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/dd40c9f4-9abf-4957-b93e-ebad593f2715.png" style=""/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"><span>Figure 3.6: EveryNote editing dialog</span></div>
<p>In order to reach this stage of <em>EveryNote</em> development, we used a TDD approach and an incremental design and development process. As I promised in the introduction, I developed this application while writing this chapter. This means that I did not follow an optimal development path—in fact, I had to change some code and even delete some tests. That is normal while developing. At any rate, spend more time during the design phase in order to avoid architectural mistakes and save time during the development phase. In fact, a good design is fundamental, but it is also important not to go into too <span>much detail while in this phase. Sometimes, people think that TDD bypasses design. That's completely false—in fact, you will pay twice for a mistake: Once in the production code and once in the test code.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Synchronizing with a remote server</h1>
                </header>
            
            <article>
                
<p>While developing the <em>EveryNote</em> application, I decided to write an action for each mutation. If an action only commits a mutation, you may avoid writing this action and commit the corresponding mutation inside the components. Like Google Keep, the <em>EveryNote</em> application can be empowered by persisting notes to a remote server so that a user can read his or her notes from any computer or mobile device. In that case, actions come in handy because they can perform asynchronous operations to keep the application state synchronized with a server.</p>
<p>I will not implement the code to persist the application state with a remote server, but I would like to show you an example of how the list of notes can be fetched from a remote server when the app gets loaded.</p>
<p>The idea is that when <kbd>App.vue</kbd> is loaded, we can fire a <kbd>loadNotesFromServer</kbd> action that will update the <span>saved</span><span> </span><span>state into the</span> <kbd>localStorage</kbd> <span>with the list of notes from the server.</span></p>
<p>Let's start with the <kbd>loadNotesFromServer</kbd><span> action tests:</span></p>
<pre>// test/store/actions.spec.js<br/>import actions from '../../src/store/actions';<br/>import { types } from '../../src/store/mutations';<br/><strong>import api from '../../src/api/api-mock'</strong>;<br/><br/>describe('EveryNote root actions', () =&gt; {<br/>  // ...<br/><br/>  it('<strong>should have loadNotesFromServer action</strong>', (done) =&gt; {<br/>    const { loadNotesFromServer } = actions;<br/>    const mockContext = {<br/>      commit: jasmine.createSpy('commit'),<br/>    };<br/>    const aNote = {};<br/>    spyOn(api, 'fetchAllNotes').and.returnValue(Promise.resolve([aNote]));<br/><br/>    loadNotesFromServer(mockContext).then(() =&gt; {<br/>      expect(mockContext.commit)<br/>        .toHaveBeenCalledWith(types.ADD_NOTE, aNote);<br/>      done();<br/>    });<br/>  });<br/>});</pre>
<p>The action code is as follows:</p>
<pre><span>// src/store/actions.js<br/></span><span>import </span>{ types } <span>from </span><span>'./mutations'</span><span>;<br/></span><span>import </span>api <span>from </span><span>'../api/api-mock'</span><span>;<br/></span><span><br/></span><span>export default </span>{<br/>  // ...<span><br/></span><span>  </span><strong>loadNotesFromServer({ commit })</strong> {<br/>    <span>return </span>api.<span>fetchAllNotes</span>().<span>then</span>((notes) =&gt; {<br/>      notes.forEach(note =&gt; commit(types.<span>ADD_NOTE</span><span>, </span>note))<span>;<br/></span><span>    </span>})<span>;<br/></span><span>  </span>}<span>,<br/></span>}<span>;<br/></span></pre>
<p>It is a simplistic implementation—in a real case, you may need to merge the list of notes from the server with the notes saved in the <kbd>localStorage</kbd>.</p>
<p>Then, we alter <kbd>App.vue</kbd> to dispatch the action:</p>
<pre>// src/components/App.vue<br/><span>&lt;template&gt;<br/></span><span>  // ..</span><span><br/></span><span>&lt;/template&gt;<br/></span><span>&lt;script&gt;<br/></span><span>  </span><span>import </span>NoteList from <span>'./NoteList.vue'</span><span>;<br/></span><span>  </span><span>import </span>NoteEditor from <span>'./NoteEditor.vue'</span><span>;<br/></span><span><br/></span><span>  </span><span>export default </span>{<br/>    <strong>created() {</strong><br/><strong>      this.$store.dispatch('loadNotesFromServer');<br/>    }</strong><span>,<br/></span><span>    </span><span>components</span>: {<br/>      NoteList<span>,<br/></span><span>      </span>NoteEditor<span>,<br/></span><span>    </span>}<span>,<br/></span><span>    </span><span>methods</span>: {<br/>     // ...<span><br/></span><span>    </span>}<span>,<br/></span><span>  </span>}<span>;<br/></span><span>&lt;/script&gt;<br/></span><span>&lt;style </span><span>scoped</span><span>&gt;<br/></span><span> // ...</span><br/><span>&lt;/style&gt;</span></pre>
<p>Finally, we create a mock implementation of the API, moving the two notes from the store to the mock API:</p>
<pre><span>// src/api/api-mock.js<br/>export default {<br/>  fetchAllNotes() {<br/>    return Promise.resolve([<br/>      { title: 'title A', content: 'content 1' },<br/>      { title: 'title B', content: 'content 2' },<br/>    ]);<br/>  },<br/>};<br/></span></pre>
<p>You can download the code at this stage by typing the following:</p>
<pre><strong>git checkout step-5_remote-mock-server</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we developed the <em>EveryNote</em> application, going through the Vuex concepts and looking at how to use Vuex in a real application's development. We also looked at the TDD basics and saw how Vue/Vuex elements can be tested.</p>
<p>But what about debugging? Even with tests, a debug is sometimes needed. The next chapter will explain how web applications can be debugged using browser developer tools, as well as how to use <kbd>vue-devtools</kbd> to easily debug Vue/Vuex applications.</p>


            </article>

            
        </section>
    </body></html>