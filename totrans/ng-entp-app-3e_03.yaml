- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Architecting an Enterprise App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 2*, *Forms, Observables, Signals, and Subjects*, we used the LocalCast
    Weather app to demonstrate various features of Angular to learn as well as experiment
    with and inform us if these features are suitable for more complex enterprise
    applications. Building enterprise applications is as much about the people building
    them as it is the technology used to build them. An over-eager approach to consuming
    and rolling out unproven tech is guaranteed to create the **sinkhole effect**
    in your project. If you’re unfamiliar with sinkholes, they are a natural phenomenon
    that occurs due to the dissolution of underlying ground material. At some point,
    usually suddenly, the ground collapses to devastating effect, revealing a giant
    hole in the ground.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, I’ve done my best only to include tried and true, mature, and
    well-supported technologies and practices. LocalCast Weather includes all the
    cutting-edge features of Angular, like a root-level standalone project with standalone
    components, signals, and control flow syntax. With standalone components, we shed
    the concept of shared modules, helping resolve circular dependency issues and
    unnecessary bloat due to overstuffed shared modules. However, frustrations exist.
    Standalone projects require libraries to support providers instead of modules;
    when a provider is missing, applying a library to a project with feature modules
    becomes tedious guesswork.
  prefs: []
  type: TYPE_NORMAL
- en: Control flow syntax, in preview, produces easier-to-read templates and removes
    the need to import structural directives, which reduces boilerplate. Meanwhile,
    Angular Signals, in partial preview, won’t bring major value until signal-based
    components are rolled out. Regardless, Angular Signals draws from new JavaScript
    primitives, covered later, in the *Minimalist JavaScript solutions* section, you
    should know and learn to use outside of Angular. Before diving into specifics,
    let’s consider the bigger picture.
  prefs: []
  type: TYPE_NORMAL
- en: The most common type of app built in an enterprise is a **Line-of-Business**
    (**LOB**) application. LOB apps are the bread and butter of the software development
    world. As Wikipedia defines it, LOB is a general term that refers to a product
    or a set of related products that serve a particular customer transaction or business
    need. LOB apps present an excellent opportunity to demonstrate various features
    and functionality without getting into the contorted or specialized scenarios
    that large enterprise applications usually need to address.
  prefs: []
  type: TYPE_NORMAL
- en: The Pareto principle, also known as the 80-20 rule, states that we can accomplish
    80% of our goals with 20% of the overall effort. We will apply the 80-20 rule
    to the design and architecture of our LOB app. Given the common use cases LOB
    apps cover, they are perfect for the 80-20 learning experience. With only 20%
    of the effort, you can learn about 80% of what you need to deliver high-quality
    experiences to your users.
  prefs: []
  type: TYPE_NORMAL
- en: LOB apps have a curious property to them. If you build a semi-useful app, its
    demand grows uncontrollably, and you quickly become the victim of your success.
    It’s challenging to balance the architectural needs of a project; you want to
    avoid potentially devastating under-engineering and, on the flip side, avoid costly
    over-engineering for an app that will never need it.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’m going to introduce you to ingredients that will allow you
    to be successful in your enterprise, things you should consider as an architect,
    various tools you should consider when building a performant app, how to design
    a large app using router-first architecture, and the 80-20 design solution to
    address the challenges of delivering a modern web application incrementally and
    iteratively.
  prefs: []
  type: TYPE_NORMAL
- en: As you read in *Chapter 1*, *Angular’s Architecture and Concepts*, software
    architecture doesn’t stay static. It’s essential to experiment with new ideas
    by using coding katas, proof-of-concept apps, and reference projects to practice
    getting better at creating more flexible architectures.
  prefs: []
  type: TYPE_NORMAL
- en: In this and the remaining chapters of the book, we’ll set up a new application
    with rich features that can meet the demands of an LOB application with scalable
    architecture and engineering best practices that will help you start small and
    be able to grow your solution quickly if there’s demand. We will follow the **Router-First
    Architecture**, a design pattern relying on reusable components to create a grocery
    store LOB application named **LemonMart**. We’ll discuss designing around major
    data entities and the importance of completing high-level mock-ups for your application
    before implementing various conditional navigation elements, which may change
    significantly during the design phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Succeeding as a technical lead or architect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ingredients for succeeding in your enterprise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kanban planning using GitHub projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools for building high-performance apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the 80-20 solution to software development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to build router-first apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by covering non-technical aspects of a project that you must have
    a grasp of, so you can set up your team for success.
  prefs: []
  type: TYPE_NORMAL
- en: Succeeding as a technical lead or architect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I will be using the terms **technical lead** and **architect** interchangeably.
    Depending on the size of your organization, this may be two separate roles or
    one. But no matter which specific role you fulfill, in these roles, it is up to
    you to ensure the success of your project and, most importantly, the well-being
    of your team members.
  prefs: []
  type: TYPE_NORMAL
- en: Understand the business impact
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your first task should be to understand the business impact of your project.
    Some questions to ask are:'
  prefs: []
  type: TYPE_NORMAL
- en: How critical is the success of this project to the business?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the consequences of failure?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does it mean to fail?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which features will deliver the most value?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the parameters you must operate under?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s negotiable and what’s not?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The answers you get to these questions will vary how your project should operate
    significantly. If the survival or reputation of the business is at stake, you
    must amplify the aspects of the project that’ll ensure the business survives or
    its reputation isn’t tarnished. If a certain feature set will bring the most value,
    then focus all attention on getting performant and high-quality UX in that section
    and simplify the rest for the initial release. If certain personnel or technology
    is being dictated, weigh that against other factors. Expend all your energy and
    capital ensuring that the technology picked by your **Chief Technology Officer**
    (**CTO**) is a good fit for a project that will be a sink or swim moment for the
    company. Don’t fight unnecessary battles.
  prefs: []
  type: TYPE_NORMAL
- en: Set parameters of success
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a general principle, it’s advisable to leverage the strengths and passions
    of your team members. This is critical if resources or time is tight. People will
    work harder to invest in your project if they’re also investing their time in
    a technology that they’re passionate about. But don’t do this at the cost of failure
    – going back to my point on over-eager use of new tech at the beginning of the
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to establish clear parameters for success for your team. This
    will only be possible if you *yourself* have a clear understanding of the business
    impact. You and your team members are on a journey. You’re all walking on a path.
    Falling off the path means peril, either for individual team members or the project’s
    success. It is up to you to vary how wide or narrow this path is. If you leave
    it too narrow, your team members will suffocate and be frustrated due to the lack
    of freedom or intense scrutiny. On the contrary, if you leave it too wide, you’ll
    have more experimentation than any real work to do. You must set guard rails on
    the path at just the right amount to match the team and project needs.
  prefs: []
  type: TYPE_NORMAL
- en: Elastic leadership
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your leadership style can’t be static. It must be *elastic*. All teams and projects
    have a lifecycle. They can go through periods of survival, learning, or self-organizing.
    Depending on deadlines or outside factors, teams can be forced from one state
    to another.
  prefs: []
  type: TYPE_NORMAL
- en: Check out Roy Osherove’s excellent content on elastic leadership at [https://www.elasticleadership.com](https://www.elasticleadership.com).
  prefs: []
  type: TYPE_NORMAL
- en: Understand what state your team is in and vary your leadership style accordingly.
    Survival mode requires a dictator- or protector-style leader, where you’re heavily
    involved with all team activities and are directing individual tasks and actions.
    Your goal should be to move teams in this state to learning mode. This is where
    you become a coach, where you are not as involved in daily activities but instead
    focus on what team members should learn and how they should grow. The next step
    up would be a team in *self-organizing* mode. These teams are resilient, they
    grow on their own, and they can take general direction and strategy and execute
    them. At this point, you need to be a facilitator or a servant leader. If you
    dictate to a mature team, you’ll quickly lose that team.
  prefs: []
  type: TYPE_NORMAL
- en: Google’s **DevOps Research and Assessment** (**DORA**) program contains 30 capabilities
    across technical, process, and cultural topics that your team and organization
    can master to become a high-performing team. The research program has been running
    since 2014, considering input from 33,000 professionals from various industries
    and governments. Learn more about the program at [https://dora.dev](https://dora.dev).
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t understand these concepts, you’re likely to put your team members
    in situations where they’ll burn out, working overtime and with low morale, which
    could also impact family life and cause stress and high turnover. In that case,
    you may need to look in the mirror, with so many people standing there. All factors
    lead to a vicious cycle that is not good for running a healthy organization. As
    the saying goes, it’s not a sprint but a marathon. It’s as much about the journey
    as reaching the end goal. Don’t fail your team.
  prefs: []
  type: TYPE_NORMAL
- en: Ingredients of a successful project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You understand the business impact of your project and you have a team eager
    to start; now what? You must have a plan, of course. As the German field marshal
    Moltke the Elder put it (or at least the modern paraphrase of it), *“No plan survives
    first contact with the enemy.”*
  prefs: []
  type: TYPE_NORMAL
- en: Half a century later, Winston Churchill and Dwight D. Eisenhower added, *“Plans
    are of little importance [or are worthless], but planning is essential [or indispensable].”*
  prefs: []
  type: TYPE_NORMAL
- en: Agile software development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Over the past decade, Agile software management has taken over the world, replacing
    waterfall project execution with Scrum and Gantt charts with Kanban boards and
    iterative and incremental delivery every two weeks instead of multi-year development
    cycles with long lead times and expensive **Quality Assurance** (**QA**) and support
    cycles. Statistics show that Agile projects have a higher success rate than waterfall
    projects. This intuitively makes sense because iterative and incremental delivery
    ensures success happens as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Agile Manifesto, located at [http://agilemanifesto.org](http://agilemanifesto.org),
    published in 2001, highlights the key ingredients for becoming Agile:'
  prefs: []
  type: TYPE_NORMAL
- en: Individuals and interactions over processes and tools
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Working software over comprehensive documentation
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Customer collaboration over contract negotiation
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Responding to change over following a plan
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Most individuals are introduced to Agile when they join a Scrum team, and because
    of this most people conflate Agile and Scrum. Scrum is a management framework.
    Concepts like sprints, planning meetings, retrospectives, and other optional elements
    like user stories and story points have nothing to do with Agile. It is possible
    to execute Scrum and abuse every Agile value possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the *deliver:Agile 2018* conference in Austin, Texas, I listened to a talk
    by Ron Jeffries (a signatory of the 2001 Agile Manifesto) and Chet Hendrickson
    (a guy with an incredible sense of humor who rightly picked on me for having all
    sorts of JavaScript stickers on the lid of my MacBook) about Agile development.
    They focused on the “working software” component of the Agile Manifesto to drive
    home an important point. No amount of process, management oversight, or meetings
    will result in software delivery. As I aptly put it in my 2018 talk titled, Ship
    It or It Never Happened:'
  prefs: []
  type: TYPE_NORMAL
- en: ”It’s not up to them [the managers]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: it’s up to us [the developers].”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s not about creating pretty diagrams with endless iterations over imaginary
    architecture. It’s not about delivering story points, checking boxes, and moving
    cards from one column to another. In short, don’t be a process monkey. Focus on
    delivering working code.
  prefs: []
  type: TYPE_NORMAL
- en: Agile engineering best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The best way to accomplish this is by delivering and adhering to Agile engineering
    best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test-Driven Development** (**TDD**): Writing tests before writing actual
    code to ensure code meets requirements.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Continuous Integration** (**CI**): Running automated builds and tests on
    code commits frequently to catch issues early.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Continuous Delivery** (**CD**): Ensure every product iteration is in a releasable
    state.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Pair programming**: Team members learn from each other as they work on tasks
    together.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Refactoring**: Continuously improve the codebase as part of daily work.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Simple and evolutionary design**: Designs should be as simple as possible
    to achieve current requirements without over-engineering and be flexible or open-ended
    enough that they can evolve over time.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Behavior-Driven Development** (**BDD**): Use tests based on the expected
    behavior of software, backed with concrete examples, in a syntax like Gherkin
    (`Given`, `When`, `Then` format) so technical and non-technical people can collaborate.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Frequent releases**: Deliver software in small batches frequently.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**High cohesion and low coupling**: Modules or components focus on a single
    task, while these modules or components have minimal dependencies on each other.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Adhere to SOLID principles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Single responsibility principle**: A function or class should only be responsible
    for one task.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Open/closed principle**: Code should be open for extension (i.e., extensible)
    but closed for modification (i.e., extensible without having to rewrite the algorithm).'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Liskov substitution principle**: Inheriting from a super/base class shouldn’t
    result in unexpected behavior.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Interface segregation principle**: Expose the most minimal interface required.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Dependency inversion principle**: Modules/components should depend on abstractions
    instead of concrete implementations.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**DRY principle**: Don’t repeat yourself. Applying DRY helps make code easier
    to maintain. If you need to change something, you only have to change it in one
    place instead of many places. However, taking DRY too far can sometimes overcomplicate
    code, so use judgment to find the right balance. The principle is about sensibly
    reducing duplication, not eliminating it entirely.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Engineering excellence and craftsmanship
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adhering to these principles requires engineering excellence and a craftsmanship
    mindset. People on your team need to care about their work, be proud of the code
    they write, and be satisfied with the results they produce.
  prefs: []
  type: TYPE_NORMAL
- en: Translating requirements and designs to working code is not easy. Doing it iteratively
    and incrementally requires a deep understanding of technology, tools, and business
    requirements. However, being able to write code simultaneously without over-engineering
    it while also keeping it flexible is not only possible, but it should also be
    the goal of every engineer.
  prefs: []
  type: TYPE_NORMAL
- en: Oh, and pick a component library and stick to it, but also avoid vendor lock-in.
    Good luck!
  prefs: []
  type: TYPE_NORMAL
- en: Angular in an enterprise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular is not appropriate for use on every project. However, Angular is preferred
    in an enterprise because of the advanced concepts supported by the framework,
    such as **Dependency Injection** (**DI**), native TypeScript support, a modular
    architecture, robust packaging, testing, accessibility tools, and a commitment
    to release new versions regularly. The amalgamation of these tools helps applications
    scale beyond small apps to truly large-scale applications with 1,000+ views.
  prefs: []
  type: TYPE_NORMAL
- en: 'For **Content Management System** (**CMS**) style use cases and simple applications,
    you should consider using Analog. Analog is a meta-framework for building apps
    and websites with Angular: [https://analogjs.org](https://analogjs.org). Analog
    comes pre-configured with **Server-Side Rendering** (**SSR**), **Static Site Generation**
    (**SSG**), Vite ([https://vitejs.dev](https://vitejs.dev)) tooling, and convention-based
    routing and API routes for a no-frills, all-excitement development experience.'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, [https://AngularForEnterprise.com](https://AngularForEnterprise.com)
    was created using Analog.
  prefs: []
  type: TYPE_NORMAL
- en: Diverse coding paradigm support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular allows for different styles of programming. You can choose between imperative
    and reactive coding, leverage OOP concepts or completely ignore them, have inline
    and compact single-file components, or use up to four files to contain the same
    code. This variety is a strength when supporting a diverse population of developers,
    but it can also be a weakness by allowing multiple implementation styles within
    the same project. It is important to control this by establishing team norms around
    which programming style and paradigm to use. Linting and code-style tools like
    ESLint can help keep the code’s appearance uniform but are ineffective at detecting
    or preventing paradigm shifts in code.
  prefs: []
  type: TYPE_NORMAL
- en: Community support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular has a great and engaged community filled with brilliant, respectful,
    and positive individuals who collaborate to build tools around Angular and evangelize
    it across the tech community. Google also supports Angular with the Google Developer
    Expert program, which I’ve been lucky to have been a part of, where the Angular
    team meets with active community members, gives them early access, listens to
    their feedback, and encourages collaboration. This means that when your enterprise
    needs support, there’s a trustworthy community of individuals out there that you
    can tap into for advice.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in the introduction and *Future of Angular* sections of *Chapter
    1*, *Angular’s Architecture and Concepts*, as the size of a web application grows,
    performance issues begin cropping up in rendering the application, the tooling
    struggles to support the number of contributors to the project, and the architecture
    becomes inadequate in handling the complexity and variety of requirements. More
    on architecture when we discuss the 80-20 solution and router-first architecture
    later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You can find and contribute to a community-curated list of tools for building
    enterprise applications using Angular at [https://angularforenterprise.com/enterprise-tools](https://angularforenterprise.com/enterprise-tools).
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s dive into tools that can support building high-performance apps
    with good UX and DevEx.
  prefs: []
  type: TYPE_NORMAL
- en: Tools and techniques for high-performance apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will cover topics related to building high-performance
    apps. While some of these tools are specific to Angular, the general sentiment
    and advice apply to all web applications. This means that a complicated and large
    application should still be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Hit a smooth 60 FPS rendering target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Respond to user clicks within 340 ms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide fast feedback loops to developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run builds and automated tests as quickly as possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s first talk about runtime performance.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bad performance has real consequences for a business. In 2008, it was reported
    that a latency increase of 100 ms reduced Amazon’s sales by 1%. In 2006, Google
    observed that an additional 0.5 seconds in generating a search page led to a 20%
    decrease in traffic. These are astounding numbers at Amazon and Google’s scales,
    where milliseconds translate to millions of dollars. This may mean thousands or
    hundreds of thousands of dollars at your organization’s scale. Considering performance
    trends over time, these smaller numbers can still multiply to millions.
  prefs: []
  type: TYPE_NORMAL
- en: The browser is a complicated runtime environment, and the frameworks we use
    to develop web applications obfuscate the runtime in exchange for rich features
    and easier-to-maintain code. This obfuscation introduces performance issues specific
    to framework code on top of native browser-related optimization requirements.
    And in 2024, the frameworks we use have become incredibly complicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand what kind of indicators we can use to understand the runtime
    performance of a web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**First Contentful Paint** (**FCP**): Measures the time from page start to
    the first visual content displayed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time to Interactive** (**TTI**): Measures a page’s load responsiveness and
    helps identify where a page looks interactive but isn’t'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Latency**: The delay between a user’s action and its response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frame drops**: Occurrences when frames can’t be generated fast enough to
    render a UI smoothly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use the profiling tools in our browser’s DevTools to discover these
    issues. Below is an annotated example of a **flame chart** (often referred to
    as a flame graph) created by Michael Hladky, which highlights the various stages
    of the bootstrap process of an Angular app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18047_03_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Flame chart of Angular Bootstrap phase. Credit Michael Hladky'
  prefs: []
  type: TYPE_NORMAL
- en: The x axis of the chart shows times, and the y-axis shows the stack of function
    calls. A wide bar indicates a function taking a long time to execute or being
    called frequently. A tall stack includes a deep chain of function calls. You may
    use these visual clues to zoom into the chart and investigate performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re unfamiliar with using Chrome’s profiling features, please refer to
    [https://developer.chrome.com/docs/devtools/performance/reference](https://developer.chrome.com/docs/devtools/performance/reference).
  prefs: []
  type: TYPE_NORMAL
- en: Root cause of performance bottlenecks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What’s slowing us down? During the bootstrap process of an application or when
    loading a new page, several things happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Downloading JavaScript**: This includes application, framework, and third-party
    library code. The larger the size, the slower it is.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Executing JavaScript**: Code needs to be unzipped and loaded into memory,
    then parsed by the JavaScript engine for just-in-time execution; DOM elements
    and framework hooks need to be scaffolded.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hydrating app code**: The framework must compute the application’s state
    (visual and data), connect event listeners to the DOM, and render.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Change detection**: The framework must traverse the component tree to determine
    if the UI should be updated due to a state change.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Executing these steps sequentially, presuming your application or API code is
    free of major issues, is the main root cause of performance issues with large
    web applications. In the current state of SPA frameworks, these issues are inescapable
    and/or very expensive to overcome.
  prefs: []
  type: TYPE_NORMAL
- en: An example of an inescapable issue would be rendering too many interactive components
    on the screen. A very expensive solution to this might be to patch every single
    component with custom code to circumvent the normal lifecycle of the framework
    and coerce it to behave in a way that could only benefit the application you’re
    building.
  prefs: []
  type: TYPE_NORMAL
- en: Minimalist JavaScript solutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ECMAScript 2022, widely supported by all major browsers, has built-in fundamentals
    that allow us to build performant and reactive web applications from scratch.
    For only 1-2 kb of “framework” code, we can vastly improve the DevEx and create
    modern and fast websites.
  prefs: []
  type: TYPE_NORMAL
- en: ArrowJS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At the Frontrunners 2023 conference in Washington DC, I attended a talk by
    Justin Schroeder about his frontend library named ArrowJS, Reactivity without
    the framework. More information can be found at [https://www.arrow-js.com](https://www.arrow-js.com).
    In his talk, Justin covered the fundamentals that made his library possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '**WeakMap**: A WeakMap is a collection of key-value pairs where the keys are
    objects with arbitrary values. The keys are weakly referenced, meaning they can
    be garbage collected if no other references exist. Normally the map itself would
    count as a reference and thus remain in memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proxy**: A proxy is an object that wraps another object or function and allows
    you to intercept and define custom behavior for fundamental operations. They are
    like middleware for your objects. Signals use a proxy under the covers. They are
    also useful in form validation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Set**: A set is a collection of values where each value must be unique, meaning
    the same value cannot appear more than once. They are useful for tracking dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tagged** template literals: These allow parsing template literals with a
    function, enabling custom string interpolation and processing. They are like middleware
    for strings. They are useful for parsing templated HTML code as a function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When all these concepts are put together, observe how you can replicate a to-do
    list app in ArrowJS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code doesn’t require any compilation or further processing. The next solution,
    however, leverages similar technologies under the covers but also tackles all
    the big problems.
  prefs: []
  type: TYPE_NORMAL
- en: Qwik.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The father of Angular, Miško Hevery, along with industry veteran Adam Bradley
    (jQuery Mobile, Ionic, Stencil.js) and whizbang coder Manu Almeida, created Qwik.js
    as a response to address the fundamental issues baked into popular SPA frameworks
    like Angular, React, and Vue. You can check out this framework at [https://qwik.builder.io](https://qwik.builder.io).
  prefs: []
  type: TYPE_NORMAL
- en: 'Feeling adventurous? Execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Qwik.js was built from the ground up to enforce a reactive coding paradigm,
    leveraging the signal primitive and resumability as a built-in feature to ensure
    that apps of any size or scale always do a full-page load under 1 second and perform
    5-10x faster overall. All with a library that is ~1 kb in size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qwik ships “batteries included” with rich user controls, a Vite dev server,
    testing with Vitest and Playwright, extendable styling, and server-side rendering,
    and it doesn’t require hydration. To understand the difference between hydration
    and resumability, see the following graphic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18047_03_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Hydration vs resumability. Adapted from Miško Hevery'
  prefs: []
  type: TYPE_NORMAL
- en: At the top, you can see the hydration steps to load a traditional SPA. Each
    individual box takes longer the more your application grows. However, a resumable
    app is downloaded as a ready-to-render HTML payload, with its state embedded,
    bringing the complexity from O(![](img/B20960_03_001.png)) down to O(1).
  prefs: []
  type: TYPE_NORMAL
- en: If you find O(![](img/B20960_03_002.png)) intimidating, don’t worry. It’s meant
    to be a joke.
  prefs: []
  type: TYPE_NORMAL
- en: After the initial load, Qwik pre-fetches only the required amount of JavaScript
    to enable interactivity. This can mean downloading individual functions at a time.
    Qwik is also aggressive about lazily executing code. So, only the elements that
    the user interacts with come alive, keeping performance concerns in check. Naturally,
    there are some smart pre-fetching algorithms working in the background to make
    this a seamless experience.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to learn more about Qwik, check out my talk on YouTube at
    [https://www.youtube.com/watch?v=QDqp_qTa4Ww&t=40s](https://www.youtube.com/watch?v=QDqp_qTa4Ww&t=40s)
    and the slides at [https://slides.com/doguhanuluca/intro-to-qwik](https://slides.com/doguhanuluca/intro-to-qwik).
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s see what tools we can use to address these issues in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Angular performance solutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two categories of issues at play, one regarding the initial load of
    the application and the second ensuring smooth rendering by keeping change detection
    in check.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with **Server-Side Rendering** (**SSR**).
  prefs: []
  type: TYPE_NORMAL
- en: Server-side rendering and hydration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Angular server-side rendering** enables rendering the SPA, an otherwise client-side
    technology with code executing in the browser on a server. The server can pre-bake
    the initial state of a view as simple HTML and JavaScript that the browser doesn’t
    have to spend a lot of time interpreting. As a result, the downloaded content
    renders very quickly, solving delays caused by downloading and executing large
    amounts of JavaScript. This is especially critical in mobile or outdated devices
    with limited processing and bandwidth. The server can perform this task consistently
    regardless of user hardware.'
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of SSR is to facilitate web crawlers to enable **Search Engine
    Optimization** (**SEO**) on your website.
  prefs: []
  type: TYPE_NORMAL
- en: While the user is gawking at your landing page – since it is largely static
    at this point, they can only look, but not touch – Angular uses **web workers**
    to load the rest of the application.
  prefs: []
  type: TYPE_NORMAL
- en: The most logical way to incorporate SSR into your project is at the very beginning,
    so you can tackle and test for configuration issues incrementally.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new project with SSR, execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Woke up in a good mood? Try adding SSR to your existing project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After all the assets are loaded, and your SPA is ready to be fully interactive,
    the app must transition from a static state to a dynamic one. This transition
    can be jarring. As we learned when covering Qwik, hydration is essential to seamlessly
    transition from a static to a dynamic state.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using `FlexLayout`, use `FlexLayoutServerModule` to enable the framework
    in an SSR configuration. More details can be found at [https://github.com/angular/flex-layout/wiki/Using-SSR-with-Flex-Layout](https://github.com/angular/flex-layout/wiki/Using-SSR-with-Flex-Layout).
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter stage left **client hydration**. You can enable client hydration by using
    its provider in your `AppComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With client hydration, your SPA can reuse already rendered server-side DOM structures,
    application state, downloaded data, and other processes for a smooth transition.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about using Angular SSR at [https://angular.dev/guide/ssr](https://angular.dev/guide/ssr)
    and Angular hydration at [https://angular.dev/guide/hydration](https://angular.dev/guide/hydration).
  prefs: []
  type: TYPE_NORMAL
- en: App shell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An app shell is like SSR conceptually, but instead of the server rendering your
    page, you can pre-render a route or a page at build time. This way, you can craft
    a static landing experience on the landing page or when lazy loading a large feature
    module and then have Angular transition to an interactive state when ready.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-rendering is conceptually and mechanically easier to handle. However, you
    may have to simplify certain aspects of your landing pages for them to work with
    prerendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Are you about to miss your project delivery deadline but still need a solution
    for loading issues? Try adding an app shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As the saying goes, try it, but your mileage may vary. Learn more about app
    shell at [https://angular.dev/ecosystem/service-workers/app-shell](https://angular.dev/guide/hydration).
  prefs: []
  type: TYPE_NORMAL
- en: App shells are also useful in offline apps. Next, let’s see how service workers
    can help with performance.
  prefs: []
  type: TYPE_NORMAL
- en: Service workers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also leverage service workers to make your web application feel like
    a native application. Service workers enable **Progressive Web Application** (**PWA**)
    features, like offline support, push notifications, and background data syncing
    for web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Running these tasks in a background thread frees up the main thread to perform
    tasks related to rendering and user interactivity. This is low-hanging fruit to
    improve the performance of your application. Read more about service workers at
    [https://angular.dev/ecosystem/service-workers](https://angular.dev/ecosystem/service-workers).
  prefs: []
  type: TYPE_NORMAL
- en: 'You know you want to do it. Add PWA support today:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The technical reviewer of this book, Jurgen Van de Moere, also recommends Workbox
    by Google, a set of production-ready service worker libraries and tools regularly
    used in enterprises for complex scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Read more about Workbox at [https://developer.chrome.com/docs/workbox](https://developer.chrome.com/docs/workbox).
  prefs: []
  type: TYPE_NORMAL
- en: Alas, it is finally time to peel to the core of the onion, change detection.
  prefs: []
  type: TYPE_NORMAL
- en: RxAngular
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Michael Hladky and co. created RxAngular to overcome performance issues with
    large Angular applications. RxAngular “offers a comprehensive toolset for handling
    fully reactive Angular applications, focusing mainly on runtime performance and
    template rendering.”
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram details the lifecycle of an Angular change detection
    event:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18047_03_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Default change detection in Angular. Adapted from Michael Hladky'
  prefs: []
  type: TYPE_NORMAL
- en: 'Allow me to go over it step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: First, user interaction triggers an event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Angular then marks the element for a dirty check.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Zone.js is utilized to transition between the Angular app state and DOM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Angular engine “ticks,” triggering the execution of pending tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The change detection algorithm avoids branches that are not dirty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The algorithm identifies the topmost level component that must be re-rendered
    to react to the event triggered in *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Angular’s default change detection process is a computationally expensive process
    that can force the re-rendering of larger-than-necessary portions of the application.
    Angular also offers an `OnPush` change detection strategy.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a diagram  Description automatically generated](img/B18047_03_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: OnPush change detection in Angular. Adapted from Michael Hladky'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnPush` disables automatic change detection until manually reactivated. We
    can use this strategy only to activate component sub-trees that the user interacts
    with, limiting the amount and scope of change detection Angular must perform.
    You can read more about this at [https://angular.dev/best-practices/skipping-subtrees](https://angular.dev/best-practices/skipping-subtrees).'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, using RxAngular’s directives and pipes, like `RxLet`, `RxFor`, and
    `RxIf`, we can trick the Angular engine to only detect changes when observables
    tied to these directives change.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a diagram  Description automatically generated](img/B18047_03_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: Change detection using RxAngular’s directives. Adapted from Michael
    Hladky'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the figure above, we can ensure only the element that needs to change
    is updated without going through an expensive change detection process. If you
    already have a large Angular application where a rewrite is not an option, RxAngular
    may be your only option to resolve performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dive deeper into Angular performance at scale with Michael’s talk at Angular
    DC: [https://www.youtube.com/watch?v=HTU4WYWGTIk](https://www.youtube.com/watch?v=HTU4WYWGTIk).'
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about RxAngular at [https://www.rx-angular.io](https://www.rx-angular.io).
  prefs: []
  type: TYPE_NORMAL
- en: Angular Signals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Angular Signals can deliver the same kind of fine-grained change detection as
    shown in *Figure 3.5* in the *RxAngular* section. As you can imagine, this can
    potentially solve Angular’s most egregious performance and scaling issues. However,
    as of Angular 17, signals are still in partial preview, and signal-based components
    are expected to be delivered and become stable around Angular 19\. When this happens,
    we’ll still need to rewrite significant portions of our applications to take advantage
    of the performance benefits.
  prefs: []
  type: TYPE_NORMAL
- en: A pure signals-based application won’t require heavy RxJS use to enable reactivity.
    I predict its use will be rare, as most service and API calls can be converted
    into async/await-enabled promise-based calls. This would be revolutionary in making
    Angular very easy to learn.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Rewriting Angular Apps with NgRx/SignalStore* section of *Chapter 9*,
    *Recipes – Master/Detail, Data Tables, and NgRx*, I demonstrate how far you can
    go with signals with Angular 17.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s talk about build issues that large applications can create.
  prefs: []
  type: TYPE_NORMAL
- en: Build performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like runtime performance issues, the codebase size can play a major role in
    the quality of DevEx. When more code is present in a project, building the code
    and running tests on it becomes slower. This lengthens the developer feedback
    cycle. A slow feedback cycle results in a slow development process with more bugs
    and fewer quality features delivered.
  prefs: []
  type: TYPE_NORMAL
- en: While minimalist solutions like ArrowJS or Qwik.js handle this by requiring
    none to minimalist state-of-the-art tooling, existing SPA frameworks can’t do
    this easily, given a large install base and complicated requirements. But this
    doesn’t mean there aren’t great solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The tools described in the following sections can speed up your development
    process and improve DevEx.
  prefs: []
  type: TYPE_NORMAL
- en: Nx
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Nx** is a next-generation build system with first-class monorepo support
    and powerful integrations. Nx allows you to break up your application code into
    libraries and utilize build caching only to re-build portions of the app that
    need it. So, a small change doesn’t have to trigger a full build, but instead
    a short 30-second build and only re-running tests that are impacted. The great
    thing about this is that the cache can be shared remotely across servers and dev
    machines.'
  prefs: []
  type: TYPE_NORMAL
- en: Nx also offers an opinionated architecture, which is welcome for very large
    teams and enterprises. Nx also automates dependency updates, a critical and time-consuming
    maintenance task for all modern web projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a new Nx application by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can migrate your existing apps to Nx by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can learn more about Nx at [https://nx.dev/](https://nx.dev/).
  prefs: []
  type: TYPE_NORMAL
- en: esbuild
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**esbuild** is an extremely fast bundler for the web. It runs 40x faster than
    webpack 5, which Angular currently relies on to pack up the SPA, contributing
    significantly to slow build times.'
  prefs: []
  type: TYPE_NORMAL
- en: As of Angular 17, the esbuild-based **ES Module** (**ESM**) build system is
    the default builder. You can read more about it at [https://angular.dev/tools/cli/esbuild](https://angular.dev/tools/cli/esbuild).
  prefs: []
  type: TYPE_NORMAL
- en: The webpack-based legacy build system is still considered stable and fully supported.
  prefs: []
  type: TYPE_NORMAL
- en: To migrate to the new build system, follow the instructions at [https://angular.dev/tools/cli/esbuild#using-the-browser-esbuild-builder](https://angular.dev/tools/cli/esbuild#using-the-browser-esbuild-builder).
  prefs: []
  type: TYPE_NORMAL
- en: The new esbuild-based build system also enables next-generation frontend tooling
    with Vite. Learn more about Vite at [https://vitejs.dev/](https://vitejs.dev/).
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about esbuild at [https://esbuild.github.io/](https://esbuild.github.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Test automation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Karma and Jasmine tools are showing their age. Karma was never built with
    headless unit tests in mind. The original **end-to-end (e2e)** testing tool for
    Angular, Protractor, has already been deprecated and replaced by Cypress. This
    is covered in depth in *Chapter 4*, *Creating a Router-First Line-of-Business
    App*. Cypress is great to work with and a great replacement for Protractor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go over a few alternatives to Karma and Jasmine for faster unit testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Jest, [https://jestjs.io](https://jestjs.io), is a near drop-in replacement
    for Jasmine with a built-in test runner. I’ve had a great experience leveraging
    Jest with my CLI tools; however, Jest was never built with supporting ES modules.
    This results in significant compatibility issues when using CommonJS modules and
    ES modules together, which is often the case in any existing application. The
    issues were so opaque and significant I had to abandon an effort to upgrade the
    sample code for the book to Jest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As of the time of publication, Angular supports Jest in preview. However, I
    don’t recommend that you use it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Vitest, [https://vitest.dev/](https://vitest.dev/), powered by Vite, is a blazing-fast
    unit test framework and represents an acceptable future state. However, to seamlessly
    leverage Vitest, you should also use the esbuild-based build configuration that
    also comes with Vite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cypress, [https://www.cypress.io/](https://www.cypress.io/), is generally known
    for its e2e testing capabilities. However, you can also write component tests
    with Cypress. Once you configure Cypress for an Angular project, any time you
    generate a new component, a new Cypress component test file will also be added.
    Cypress’s black-box approach to component testing makes it easier to write new
    tests, but they can’t be referred to as unit tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once (and if) all the half-dozen or more in-preview pieces of tech graduate
    to Angular production status, the heavy-hitting SPA framework will be ready for
    the future. In the meantime, don’t discount alternatives like Qwik.js for extremely
    performance-sensitive applications.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know where the monsters are hiding, you’re ready to tackle the
    execution of your project. But wait, don’t start coding just yet. Having a plan
    in place is indispensable.
  prefs: []
  type: TYPE_NORMAL
- en: Planning using Kanban and GitHub projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a roadmap before getting on the road is critical in reaching your destination.
    Similarly, building a rough plan of action before you start coding is crucial
    in ensuring project success. Building a plan early on enables your colleagues
    or clients to be aware of what you’re planning to accomplish. However, any initial
    plan is guaranteed to change over time.
  prefs: []
  type: TYPE_NORMAL
- en: Agile software development aims to account for changing priorities and features
    over time. Kanban and Scrum are the two most popular methodologies that you can
    use to manage your project. Each methodology has a concept of a backlog and lists
    that capture planned, in progress, and completed work. A backlog, which contains
    a prioritized list of tasks, establishes a shared understanding of what needs
    to be worked on next. Lists that capture the status of each task act as information
    radiators, where stakeholders can get updates without interrupting your workflow.
    Whether you’re building an app for yourself or someone else, keeping a live backlog
    and tracking the progress of tasks pays dividends and keeps the focus on the goal
    you’re trying to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: You can leverage a GitHub project to act as a Kanban board. In an enterprise,
    you can use ticketing systems or tools to keep a backlog, implement the Scrum
    methodology, and display Kanban boards. In GitHub, issues represent your backlog.
    You can leverage the built-in **Projects** tab to define a scope of work representing
    a release or a sprint to establish a Kanban board. A GitHub project directly integrates
    with your GitHub repository’s issues and keeps track of the status of issues via
    labels. This way, you can keep using the tool of your choice to interact with
    your repository and still effortlessly radiate information.
  prefs: []
  type: TYPE_NORMAL
- en: An **information radiator** is a dynamic tool used in agile project management
    and software development to display critical project information in a highly visible
    area. Designed to promote transparency and facilitate passive communication, it
    ensures that team members are continuously and effortlessly informed about key
    aspects of the project, such as progress, goals, deadlines, and potential issues.
    Typically placed in a common workspace, an information radiator might take the
    form of a large whiteboard or digital display, showing easy-to-understand visuals
    like charts, graphs, or Kanban boards. Its primary function is to keep the information
    current and relevant, providing a real-time snapshot of the project’s status.
    By doing so, it enhances collaboration, helps in identifying bottlenecks quickly,
    and allows for prompt decision-making. The information radiator, therefore, serves
    as both a focal point for team interaction and a catalyst for a more engaged and
    informed team dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will set up a project to achieve this goal.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a GitHub project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s set up a GitHub project:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to your GitHub repository in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch over to the **Projects** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **New project**.![A screenshot of a computer  Description automatically
    generated](img/B18047_03_06.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.6: Creating a new project in GitHub'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Provide a name in the **Project name** box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the project template named **Team backlog**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We just created a Kanban board, a lightweight methodology to organize your
    work you might choose over other methodologies like Scrum. Observe your Kanban
    board, which should appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B18047_03_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: The Kanban board for your project'
  prefs: []
  type: TYPE_NORMAL
- en: 'The default configuration of the board includes the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**New**: Should be used for adding new issues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backlog**: A prioritized list of tasks to work on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ready**: Tasks that meet the definition of ready and can be immediately worked
    on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In progress**: Tasks that are in progress; using the triple-dot menu, you
    can set an item limit, enforcing a **Work-in-Progress** (**WIP**) limit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In review**: Work that’s under code review, QA testing, and **Product Owner**
    (**PO**) approval'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Done**: Work that meets the definition of done'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Definition of Ready defines *“criteria to know when a Backlog item is refined
    enough to start working on it”* and the Definition of Done defines *“criteria
    to know when a Backlog item is completed.”* It is critical to define these criteria
    as part of team norms. To learn more about running successful Kanban projects,
    check out this article by my colleague Nicole Spence-Goon: [https://www.excella.com/insights/successful-agile-project-with-transient-teams](https://www.excella.com/insights/successful-agile-project-with-transient-teams).'
  prefs: []
  type: TYPE_NORMAL
- en: If you have existing GitHub issues or pull requests in your repository, you
    can add them to your project individually or in bulk using the **+ Add item**
    button. You can also combine issues from different repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the Kanban board
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your board is configured as a Kanban board with all the necessary columns out
    of the box. By default, issues created and **Pull Requests** (**PRs**) opened
    in your project will be automatically added to the board.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do this by opening the **Workflows** screen from the triple-dot menu
    marked as **1** in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B18047_03_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: Kanban board workflows'
  prefs: []
  type: TYPE_NORMAL
- en: Number **2** shows a list of the default workflows listed. You can select one
    and use the **Edit** button, marked with **3**, to change the automated behavior.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub projects also have a concept of milestones. You can create milestones
    and assign them to issues or PRs to set up a sprint or a release and track percentage
    completion or other stats via the **Insights** screen, accessed next to the triple-dot
    menu, marked with number **1**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also add a roadmap using the on **+ New View** button to get a different
    view. The most powerful feature of GitHub projects is the integration with developer
    workflows. See the following PR:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B18047_03_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: Pull request with project integration'
  prefs: []
  type: TYPE_NORMAL
- en: Number **1** shows that the PR is in the **In progress** column of the **LemonMart**
    project. Developers get glanceable information and the ability to manipulate project
    files within the PR. At number **2**, we can see the PR is assigned to the **3rd
    Edition** milestone, where we can see a progress bar showing percentage completion.
    And finally, number **3** shows one or more issues that this PR can resolve.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a prioritized backlog for your app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Get together with your team and create a backlog of issues to keep track of
    your progress as you implement the design of your application. When creating issues,
    you should focus on delivering functional iterations that bring some value to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: Refrain from creating purely technical tasks. The technical hurdles you must
    clear to achieve those results are of no interest to your users or clients. Bug
    tickets are okay because they impact your users. However, technical tasks become
    part of the functional problem you’re trying to solve, so address them within
    that context. This way, you’ll always be ready to translate the work being done
    into value being delivered when approached by business leaders at your organization.
  prefs: []
  type: TYPE_NORMAL
- en: As you add items to the backlog, be sure to prioritize them. The first items
    to be worked on go to the top and descend in order of importance. New items go
    into the **New** column and are only added to the backlog in a grooming session
    so their necessity and priority can be properly assessed. With a prioritized backlog,
    you have your roadmap in hand, and your team is ready to start work.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, GitHub projects provide an easy-to-use GUI so that non-technical
    people can easily interact with GitHub issues. By allowing non-technical people
    to participate in the development process on GitHub, you unlock the benefits of
    GitHub becoming the single source of information for your entire project. Questions,
    answers, and discussions about features and issues are tracked as part of GitHub
    issues instead of being lost in emails. You can also store wiki-type documentation
    on GitHub. So, by centralizing all project-related information, data, conversations,
    and artifacts on GitHub, you are greatly simplifying the potentially complicated
    interaction of multiple systems that require continued maintenance at a high cost.
    GitHub has a very reasonable cost for private repositories and on-premises enterprise
    installations. If you’re sticking with open source, as we are in this chapter,
    all these tools are free.
  prefs: []
  type: TYPE_NORMAL
- en: With a roadmap in place, let’s investigate the philosophy of how to prioritize
    work and execute the design and architecture of our apps.
  prefs: []
  type: TYPE_NORMAL
- en: The 80-20 solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whether we develop apps at home, for passion projects, or at the office, for
    work, we must remain mindful of our purpose: to deliver value. If we don’t deliver
    value with our passion projects, we won’t feel fulfilled or happy. If we fail
    to deliver value at work, we may not get paid.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Delivering a modern web application is difficult. There are numerous challenges
    that we need to overcome to be successful:'
  prefs: []
  type: TYPE_NORMAL
- en: Deliver iteratively and incrementally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be scalable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serve dozens of screens and input types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be usable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be accessible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage a team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Groom a prioritized backlog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure acceptance criteria are clear, concise, and concrete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’ve ever led a project or tried to implement and deliver a project on
    your own, you’ll have realized that there’s never enough time and resources to
    cover the wide variety of stakeholder, team, and technical needs on any given
    project. Remember that the Pareto principle, also known as the 80-20 rule, implies
    that we can accomplish 80% of our goals with 20% of the overall effort.
  prefs: []
  type: TYPE_NORMAL
- en: If we apply the 80-20 rule to our work, we can maximize our output, quality,
    and happiness. Line-of-business applications are the bread and butter of our industry.
    Applying the 80-20 rule, we can surmise that most of us will earn most of our
    income by delivering such applications. Therefore, we should keep our engineering
    overhead to a minimum and reduce the delivery risk of our project. By limiting
    experimentation in production code, we create a predictable environment for our
    team members and only introduce changes that we had a chance to vet in proof-of-concept
    or small apps.
  prefs: []
  type: TYPE_NORMAL
- en: Our 80-20 strategy, combined with discipline, can help us deliver the same project
    at the same time with more features and better quality. By treating your career
    as a marathon and not a series of sprints, you can find yourself in a position
    to deliver high-quality solutions, project after project, without feeling burned
    out.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding line-of-business apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'According to Wikipedia, line-of-business applications are a *“set of critical
    computer applications perceived as vital to running an enterprise.”* LOB apps
    are what most developers end up developing, even though we may think we develop
    small apps or large enterprise apps. Consider the following illustration, which
    demonstrates the kinds of apps we might develop, placed on an axis relative to
    their size and scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18047_03_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: Relative size and scope of four kinds of apps'
  prefs: []
  type: TYPE_NORMAL
- en: 'From my perspective, we think about four kinds of apps when we begin developing
    software:'
  prefs: []
  type: TYPE_NORMAL
- en: Small apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LOB apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large enterprise apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Billion-user-scale apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Billion-user-scale apps are completely niche implementations that rarely have
    needs that align with most apps out there. For this reason, we must classify these
    apps as outliers.
  prefs: []
  type: TYPE_NORMAL
- en: Small apps start small. Architecturally, they’re likely to be initially under-engineered.
    As you add features and team members to work on a small app, at some point, you’re
    going to run into trouble. As your team size and feature set grow, or the overall
    complexity of the app increases, the architectural needs of the application grow
    exponentially.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you cross the inflection point of the complexity your architecture can
    bear, you’re left with a costly reengineering effort to get back on track. See
    the following graph illustrating this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18047_03_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.11: Architectural journey of a small app'
  prefs: []
  type: TYPE_NORMAL
- en: 'The area under the feature line represents under-engineering, which introduces
    risk to your project. The area above the feature line shows the required engineering
    overhead to support the features needed. In comparison, large enterprise apps
    start with a massive over-engineering effort, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18047_03_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.12: Architectural journey of a large enterprise app'
  prefs: []
  type: TYPE_NORMAL
- en: As time goes on and the system’s overall complexity increases, large enterprise
    apps can also face a similar inflection point, where the original architecture
    can become inadequate. With careful planning and management, you can avoid trouble
    and protect the significant initial investment made. Such large enterprise apps
    require hundreds of developers, with multiple levels of managers and architects,
    to execute successfully. Like billion-user-scale apps, these apps can also have
    niche architectural needs. In between the small apps and the large enterprise
    apps that we develop lie LOB apps.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18047_03_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.13: Dynamic nature of software evolution'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding diagram, small apps can grow and morph into LOB apps,
    and large enterprise apps can become under-utilized as users ignore the features
    they never need but keep the app to serve a singular purpose as a LOB app. In
    either case, despite our best efforts, we ultimately deliver an inefficient solution
    for the problem we’re solving. None of us have a crystal ball to see the future,
    and planning and engineering can only do so much for us in an unpredictable business
    setting; we need to rely on the 80-20 rule to come up with an architecture that
    is flexible to change, but adequate to meet most business requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Router-first architecture, covered in a later section, aims to maintain optimal
    architectural overhead so that costly re-engineering or late-stage crunch can
    be avoided in the rush to deliver all required features. Let’s see how.
  prefs: []
  type: TYPE_NORMAL
- en: 'I coined the term router-first architecture in 2018 with the first edition
    of this book. Since then, I’ve spoken about it at a dozen conferences and executed
    it on multi-million dollar projects successfully. Here’s my first presentation
    at the Angular DC meetup in June 2018: [https://www.youtube.com/watch?v=XKuFNiV-TWg](https://www.youtube.com/watch?v=XKuFNiV-TWg).'
  prefs: []
  type: TYPE_NORMAL
- en: Disciplined and balanced approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We covered the *what* of software development, but we must also consider the
    *why*, *when*, *where*, and *who* before we can get to the *how*. We usually under-engineer
    our projects when we develop apps for learning or passion projects. If your passion
    project somehow becomes an overnight success, it becomes costly to maintain or
    keep adding features to your app. In this case, you will have to bear the ongoing
    maintenance cost or face a rewrite of your application.
  prefs: []
  type: TYPE_NORMAL
- en: When we develop apps for work, we tend to be more conservative and will likely
    over-engineer our solution. However, if you only code for work, you will likely
    experiment with production-bound code. It is dangerous to experiment in a codebase
    with other team members. You may be introducing a new pattern without your team
    understanding the consequences of your choices. You’re also less likely to know
    the mid-to-long-term risks or benefits of the technologies you introduce.
  prefs: []
  type: TYPE_NORMAL
- en: Reckless experimentation can also have a severe negative impact on your team
    members. In a team of senior and experienced software engineers, you can likely
    get away with experimenting in a moving car. However, we will likely have team
    members of varying backgrounds and learning styles on our teams. Some of us have
    computer science degrees, some of us are lone wolves, and some of us depend a
    bit too much on Stack Overflow. Some of us work at companies that are great at
    supporting professional growth, but some of us work at places that won’t give
    us a day to learn something new. So, when experimenting, we must consider our
    environment; otherwise, we can cause our colleagues to work overtime or feel helpless
    and frustrated.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a disciplined and balanced approach, we can reduce the number of bugs
    delivered, avoid costly rework, and work with a group of people moving in the
    same direction. We also need the right architecture, tools, and patterns/practices
    to deliver successfully. In summary, our approach must consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The size of our app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reason we are developing the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The skill level of developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterative and incremental delivery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constant forward flow of features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud architecture, operational costs, and cybersecurity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ideally, we need to maintain optimal engineering overhead. Our architecture
    should support our short-term needs while being extensible, so we can pivot in
    different directions if our mid- or long-term needs change without having to rewrite
    large swathes of code. Consider the following diagram, in contrast to the ones
    about small and large enterprise apps in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18047_03_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.14: Ideal architectural journey of an LOB app'
  prefs: []
  type: TYPE_NORMAL
- en: Router-first architecture aims to help you find the balance between your codebase’s
    engineering overhead, feature delivery, and flexibility. However, you are responsible
    for managing the discipline side of things.
  prefs: []
  type: TYPE_NORMAL
- en: Shu Ha Ri is a concept that can help bring discipline to your work. It is a
    way of thinking that instructs you first to master the basics without worrying
    about the underlying theory, then master the theory, and finally be able to adapt
    what you mastered to your needs. However, if you skip steps 1 or 2, you will find
    yourself adapting the wrong thing incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: Having covered the *what*, *why*, *when*, *where*, and *who*, let’s jump into
    the *how* in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Router-first architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Router-first architecture is a way to:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enforce** high-level thinking'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ensure** consensus on features *before* you start coding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plan** for your codebase/team to grow'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Introduce** little engineering overhead'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are seven steps to implementing the router-first architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: Develop a roadmap and scope (*Chapter 4*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design with lazy loading in mind (*Chapter 4*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a walking-skeleton navigation experience (*Chapter 4*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Achieve a stateless, data-driven design (*Chapters 4*-*5*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enforce a decoupled component architecture (*Chapters 6-9*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Differentiate between user controls and components (*Chapter 8*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Maximize code reuse with TypeScript and ES features (*Chapters 5-9*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As noted previously, each step will be covered in more detail in this and coming
    chapters. Before we go over these steps at a high level, let’s first cover feature
    modules in Angular, which are important fundamental technical concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Feature modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Chapter 1*, *Angular’s Architecture and Concepts*, we covered Angular’s
    architecture at a high level and introduced the concepts of lazy loading and routing.
    Feature modules are a key component in implementing lazy loading. There are two
    kinds of modules: the root module and the feature module. Modules are implemented
    by the class `NgModule`. `NgModule` contains all the necessary metadata to render
    components and inject services. Before the introduction of standalone components,
    a component without a module couldn’t do much. But now, a standalone component
    can import its dependent modules, components, and providers without needing a
    module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An Angular application is defined by `NgModule` that sits at the root of the
    application. This is called the root module. Starting with Angular 17, standalone
    projects are enabled by default. So, instead of a root module, an `AppConfig`
    object is created, which fulfills a similar role to the root module during the
    bootstrap process. The root module renders what appears in the `<app-root>` element
    in your `index.html` file. Locate the root module, which is interchangeable with
    `AppConfig`, in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, diagram, plan, line  Description automatically
    generated](img/B18047_03_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.15: Major architectural components of Angular'
  prefs: []
  type: TYPE_NORMAL
- en: '`NgModule` can contain many other `NgModules`. An Angular app can only have
    one root module or none. This means `NgModule` you implement is a feature module.
    In the preceding diagram, you can see that you can organize a group of components
    (**Cmp**) and services (**Svc**) into feature modules. Grouping functionality
    into modules allows us to organize our code into chunks, which can be separated
    from the initial bundle of our application.'
  prefs: []
  type: TYPE_NORMAL
- en: This idea of root and feature modules represents a parent/child relationship,
    which is a concept that extends to other functionality and frameworks. For example,
    note that the preceding diagram injects a root router into the root module. A
    root router can have child routes. Child routes can be configured to load feature
    modules. Similarly, NgRx has root and feature module-level stores to organize
    the state data of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any mention of a sub-module, child module, or feature module in this book refers
    to the same thing: a module that is not the root module.'
  prefs: []
  type: TYPE_NORMAL
- en: Feature modules and child routes allow for a separation of concerns between
    major components of your application. Two teams can work on two different modules
    without interfering with each other. This separation means that any dependency
    required by a feature module must be explicitly added to the imports, declarations,
    or providers of that module. In the case of standalone components, these imports
    and providers must be added to every single component. This can seem repetitive
    and annoying, but it is a necessary evil.
  prefs: []
  type: TYPE_NORMAL
- en: 'As explained in *Chapter 2*, *Forms, Observables, Signals, and Subjects*, services,
    by default, are singletons – one instance per module. However, you can remove
    the `providedIn: ''root''` property from the `@Injectable` annotation and use
    the service within different injection contexts. You can provide copies of a service
    at the feature module or component level. When doing this, be aware that if you
    provide the same service in multiple contexts within the same inheritance chain,
    e.g., in the root and a feature module or a component, you will end up having
    multiple instances of that service that could be injected, which breaks the expectations
    of the dependency injection system.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can appreciate, modules introduce a complicated and often unnecessary
    abstraction layer in most scenarios. This is the main reason Angular now generates
    standalone projects by default.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s review the seven steps of router-first architecture at a high level.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a roadmap and scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developing a roadmap and establishing the scope of your project early on is
    critical to getting the high-level architecture right. Creating a backlog, wireframes,
    mock-ups, and interactive prototypes will help you define the map before getting
    on the road and capture the vision concretely. It is important to remember to
    use tools only when necessary. Don’t start with Photoshop when a piece of paper
    and a pencil will do. If stakeholders and team members understand what is being
    developed, it will be possible to deliver your solution iteratively and incrementally.
    However, don’t fall into the perfection trap. Save the tweaking and furniture
    rearranging until after the fundamentals are in place and agreed upon.
  prefs: []
  type: TYPE_NORMAL
- en: Document every artifact you create. *Chapter 4*, *Creating a Router-First Line-Of-Business
    App*, we cover how to leverage GitHub wikis to store your artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will go over how to develop a roadmap and a technique
    to define your scope, building on the roadmap-building techniques covered in the
    *Planning using Kanban and GitHub projects* section.
  prefs: []
  type: TYPE_NORMAL
- en: Designing with lazy loading in mind
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your first paint matters a lot! According to Google Analytics data from the
    Angular team in 2018, 53% of mobile users abandoned a website when load times
    exceeded 3 seconds. During the same period, most websites were consumed on mobile
    devices – around 70% in the US and 90% in China. UI libraries and static assets
    can add significant size to your application. Since most content is consumed on
    mobile, it’s very important to defer the loading of non-critical assets.
  prefs: []
  type: TYPE_NORMAL
- en: We defer the loading of assets by divvying up the parts of our Angular application
    into feature modules. This way, Angular can load only the assets necessary to
    render the current screen and dynamically download further resources as needed.
    You can start thinking about ways to divide your application into feature modules
    by defining the various user roles your application may use. User roles normally
    indicate a user’s job function, such as a manager or data-entry specialist. In
    technical terms, they can be thought of as a group of actions a particular user
    role can execute. After all, a data-entry specialist won’t ever see most of the
    screens a manager can, so why deliver those assets to those users and slow down
    their experience?
  prefs: []
  type: TYPE_NORMAL
- en: A more definitive strategy to divide your application would be by business function.
    You can think of each job function as a sub-module of your application. Following
    the principle of low coupling and high cohesion, you would want to group related
    functionality into modules that can be lazily loaded. This way, as users execute
    a task within a business function, they’re not interrupted by delays. However,
    as the user switches from one business function to another, we can load the new
    module, and a slight delay would be acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: You can set a preloading strategy to eagerly load all modules in the background
    as the user interacts with your app. This would eliminate any transition delay.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, see [https://angular.dev/guide/ngmodules/lazy-loading#preloading](https://angular.dev/guide/ngmodules/lazy-loading#preloadingv=HTU4WYWGTIk).
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading is critical in creating a scalable application architecture, allowing
    you to deliver high-quality and efficient products. Lazy loading is a low-hanging
    fruit we will tackle as a baseline design goal. It can be costly to implement
    lazy loading after the fact.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to lazy load individual standalone components. Standalone
    components do not require all the bootstrapping that an Angular application requires.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about these components in detail at [https://angular.io/guide/standalone-components#lazy-loading-a-standalone-component](https://angular.io/guide/standalone-components#lazy-loading-a-standalone-component).
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, you will learn how to implement lazy loading using feature
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a walking skeleton
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Configuring lazy loading can be tricky, so it is essential to nail down a walking-skeleton
    navigation experience early on. Implementing a clickable version of your app will
    help you gather feedback from users early on. That way, you’ll be able to work
    out fundamental workflow and integration issues quickly. Additionally, you’ll
    be able to establish a concrete representation of the scope of your current development
    effort. Developers and stakeholders alike will be able to visualize better how
    the product will look.
  prefs: []
  type: TYPE_NORMAL
- en: A walking skeleton also sets the stage for multiple teams to work together.
    Multiple people can start developing different feature modules or components simultaneously
    without worrying about how the puzzle pieces will come together later. By the
    end of this chapter, you will have completed implementing the walking skeleton
    of the sample app LemonMart.
  prefs: []
  type: TYPE_NORMAL
- en: Achieve a stateless, data-driven design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As highlighted in *Chapter 5*, *Designing Authentication and Authorization*,
    stateless design in full-stack architecture is critical to implementing a maintainable
    application. As covered in *Chapter 1*, *Angular’s Architecture and Concepts*,
    and later in *Chapter 9*, *Recipes – Master/Detail, Data Tables, and NgRx*, the
    flux pattern and NgRx make it possible to achieve an immutable state for your
    application. However, the flux pattern is likely to be overkill for most applications.
    NgRx itself leverages a lot of the core technologies present in RxJS.
  prefs: []
  type: TYPE_NORMAL
- en: We will use RxJS and the reactive programming paradigm to implement a minimal,
    stateless, and data-driven pattern for our application. Identifying major data
    entities, such as invoices or people, that your users will work with will help
    you avoid over-engineering your application. Designing around major data entities
    will inform API design early on and help define the `BehaviorSubject` data anchors
    you will use to achieve a stateless, data-driven design. That design will, in
    turn, ensure a decoupled component architecture, as detailed in *Chapter 2*, *Forms,
    Observables, Signals, and Subjects*.
  prefs: []
  type: TYPE_NORMAL
- en: By defining observable data anchors, you can ensure that data across various
    components will be kept in sync. We can implement immutable data streams by writing
    functional reactive code, leveraging RxJS features, and not storing state in components.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover how to design the data models for your application in *Chapter
    5*, *Designing Authentication and Authorization*, and will continue using these
    models in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Enforce a decoupled component architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in *Chapter 1*, *Angular’s Architecture and Concepts*, decoupling
    components of your architecture is critical in ensuring a maintainable codebase.
    You can decouple components in Angular by leveraging `@Input` and `@Output` bindings
    and router orchestration.
  prefs: []
  type: TYPE_NORMAL
- en: Bindings will help you maintain a simple hierarchy of components and avoid using
    dynamic templates in situations where static designs are more effective, such
    as creating multi-page forms.
  prefs: []
  type: TYPE_NORMAL
- en: Router outlets and auxiliary paths allow you to compose your view using the
    router. Resolvers can help load data by consuming router parameters. Auth guards
    can help control access to various modules and components. Using router links,
    you can dynamically customize elements that a user will see in an immutable and
    predictable way, like the way we designed and developed data anchors in the previous
    step.
  prefs: []
  type: TYPE_NORMAL
- en: If you ensure every component is responsible for loading its data, then you
    can compose components via URLs. However, overusing the router can become an anti-pattern.
    If a parent component logically owns a child component, then the effort to decouple
    them will be wasted.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 2*, *Forms, Observables, Signals, and Subjects*, you learned how
    to enable component interactions using `BehaviorSubject` and `Signals`. In *Chapter
    8*, *Recipes – Reusability, Forms, and Caching*, you will learn how to implement
    `@Input` and `@Output` bindings, and in the upcoming chapters, you will learn
    how to implement router features.
  prefs: []
  type: TYPE_NORMAL
- en: Differentiate between user controls and components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another important idea is differentiating user controls from components. A user
    control is like a custom date input or star rater. It is often highly interactive
    and dynamic code that is highly coupled, convoluted, and complicated. Such controls
    may utilize rarely used Angular APIs, like `NgZone`, `Renderer2`, `ViewContainerRef`,
    or `DynamicComponentLoaders`. These highly specialized and specific APIs are out
    of the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: A component is more like a form with fields, which may contain simple date inputs
    or a star rater. Because forms encapsulate business functionality, their code
    must be easily read and understood. Your code should stick to Angular fundamentals
    so it is stable and easy to maintain, like most of the code in this book.
  prefs: []
  type: TYPE_NORMAL
- en: By differentiating between user controls and components, you can make better
    decisions when deciding what kind of reusable code you want to make. Creating
    reusable code is costly. If you create the right reusable code, you can save time
    and resources. If you create the wrong reusable code, then you can waste a lot
    of time and resources.
  prefs: []
  type: TYPE_NORMAL
- en: Wireframing allows you to identify reusable elements early on. User controls
    will help keep user interaction code separate from business logic. Well-crafted
    component reuse will enable you to encapsulate domain-specific behavior and share
    it later.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to identify self-contained user controls that encapsulate unique
    behaviors you wish to create for your app. User controls will likely be created
    as directives or components with data-binding properties and tightly coupled controller
    logic and templates.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, components leverage router lifecycle events to parse parameters
    and perform CRUD operations on data. Identifying these component reuses early
    on will create more flexible components that can be reused in multiple contexts
    (as orchestrated by the router), maximizing code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover creating reusable components and user controls in *Chapter 8*,
    *Recipes – Reusability, Forms, and Caching*.
  prefs: []
  type: TYPE_NORMAL
- en: Maximize code reuse with TypeScript and ES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s essential to remember the underlying features of the language you work
    with before considering the features offered by Angular, RxJS, and all the libraries
    you use. There are decades of software engineering fundamentals that you can leverage
    to write readable and maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First and foremost is the DRY principle, which stands for don’t repeat yourself.
    So, don’t copy-paste code. Don’t just change a variable or two. Proactively refactor
    your code to make your functions stateless and reusable. In a few words: don’t
    repeat yourself, don’t repeat yourself, and don’t repeat yourself.'
  prefs: []
  type: TYPE_NORMAL
- en: Leverage object-oriented design. Move behavior to classes; if the `person` class
    has a `fullName` property, don’t re-implement the logic of assembling a full name
    in a dozen different places. Implement it once in the `person` class.
  prefs: []
  type: TYPE_NORMAL
- en: This means you will need to become familiar with hydration, essentially injecting
    a JSON object into a newly instantiated class and serialization using `toJSON`.
    It is important not to abuse OOP. You should remain stateless and functional by
    avoiding storing state in class parameters.
  prefs: []
  type: TYPE_NORMAL
- en: You can unleash the power of object-oriented design by leveraging generics,
    inheritance, and abstract classes. We will go over concrete examples of these
    techniques later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript introduces the concept of interfaces to JavaScript. Interfaces are
    a concept mostly reserved for statically typed languages. An interface represents
    an abstract notion of what an object can do without specifying implementation
    details. Furthermore, an interface can be used to document the shape of data.
    For example, you can write a partial interface of a third-party API to document
    the fields you’re interested in consuming. When other developers read your code,
    they understand the structure of the data they’re consuming without having to
    read the documentation on another website.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces also allow you to morph the shape of your data in a well-defined
    manner. So, you can write a transform function to transform the shape of external
    data into internal data. TypeScript will catch any errors you may make. Taking
    this concept further, you can also use interfaces to flatten data. If the data
    you receive has a multi-entity relational structure, you can flatten the relationship
    to decouple the data design from your UI code.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t overly flatten your data. Arrays and simple shapes for common objects
    are okay, such as a `name` object (with `first`, `middle`, `last`, `prefix`, and
    `suffix` properties) or commonly used domain-specific objects.
  prefs: []
  type: TYPE_NORMAL
- en: You should also avoid using string literals in your code. Writing business logic
    where you compare `'apples' !== 'Oranges'` results in unmaintainable code. You
    should leverage `enums` in TypeScript, so your code isn’t subject to the spelling
    mistakes of coders or changing business requirements. So, `'``oranges' === Fruit.Oranges`.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond TypeScript and ECMAScript, Angular also offers helpful functions to reuse
    logic. Angular validators, pipes, route resolvers, and route guards allow you
    to share code across components and templates.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter taught you what it takes to succeed as a technical lead or an architect.
    You learned about the ingredients of running a successful project. We went over
    why Angular is a great fit for an enterprise. Then we dove into various tools
    and features to consider for building a high-performance solution. You learned
    how to create a Kanban board and became familiar with the 80-20 rule and the router-first
    architecture method to tackle complicated projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will be creating a far more complicated **LOB** application,
    using a router-first approach to designing and architecting scalable Angular applications
    with first-class authentication and authorization, user experience, and numerous
    recipes that cover a vast majority of requirements that you may find in LOB applications.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Analog, the full-stack Angular meta-framework: [https://analogjs.org/](https://analogjs.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Manifesto for Agile Software Development: [https://agilemanifesto.org](https://agilemanifesto.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DevOps Research and Assessment (DORA) research program: [https://dora.dev/](https://dora.dev/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DORA capability catalog: [https://dora.dev/devops-capabilities](https://dora.dev/devops-capabilities)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What is Scrum and how to get started, Atlassian, 2023: [https://www.atlassian.com/agile/scrum](https://www.atlassian.com/agile/scrum)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to Have a Successful Agile Project with Transient Teams, Nicole Spence-Goon,
    December 14, 2021: [https://www.excella.com/insights/successful-agile-project-with-transient-teams](https://www.excella.com/insights/successful-agile-project-with-transient-teams)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ha, Not Ready to Ri: The Shu Ha Ri Approach to Agile Development*, Brian Sjoberg
    and Ken Furlong, July 29, 2015: [https://www.excella.com/insights/ha-not-ready-to-ri-the-shu-ha-ri-approach-to-agile-development](https://www.excella.com/insights/ha-not-ready-to-ri-the-shu-ha-ri-approach-to-agile-development)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Nx: Smart, Fast Extensible Build System:* [https://nx.dev](https://nx.dev)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RxAngular: Performance & DX:* [https://www.rx-angular.io](https://www.rx-angular.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Webpack module bundler: [https://webpack.js.org/](https://webpack.js.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions as best as possible to ensure you’ve understood
    the key concepts from this chapter without googling anything. Do you know if you
    got all the answers right? Visit [https://angularforenterprise.com/self-assessment](https://angularforenterprise.com/self-assessment)
    for more:'
  prefs: []
  type: TYPE_NORMAL
- en: What three things should you do to succeed as a technical lead or architect?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the ingredients of a successful project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you use Angular in your enterprise?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the most important considerations for building Angular apps for your
    enterprise?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What causes performance issues in web applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we solve performance issues in large web applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an LOB app?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Pareto principle?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the main goals of the router-first architecture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/AngularEnterpise3e](Chapter_3.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1116411172100421421.png)'
  prefs: []
  type: TYPE_IMG
