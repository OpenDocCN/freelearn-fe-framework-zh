- en: Unit Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Let's start this chapter with testing; most people think testing is boring.
    Guess what, they are mostly right! Testing can be fun in that you get to try and
    break your code, but it can sometimes be tedious work. However, it can help you
    catch mistakes before your customers do, and as a bonus, it can prevent you from
    making the same bug occur multiple times. How much is your reputation to your
    clients or customers worth? A little tedious work could mean the difference between
    a Triple-A application, and a mediocre application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从测试开始这一章；大多数人认为测试很无聊。猜猜看，他们大多数是对的！测试可以很有趣，因为你有机会尝试破坏你的代码，但有时也可能是一项繁琐的工作。然而，它可以帮助你在客户之前捕捉到错误，并且作为额外的好处，它可以防止你多次犯同样的错误。你的声誉对你的客户或顾客有多重要？一点繁琐的工作可能意味着Triple-A级应用和普通应用之间的区别。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Angular Testing Framework
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular测试框架
- en: NativeScript Testing Framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NativeScript测试框架
- en: How to write tests using Jasmine
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Jasmine编写测试
- en: How to run Karma tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何运行Karma测试
- en: Unit testing
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit tests are used to test small pieces of application code functionality for
    correctness. This also allows us to verify that the functionality continues to
    work as expected, when you refactor code and/or add new features. Both NativeScript
    and Angular offer unit testing frameworks. We will explore both types of unit
    testing, as they both have pros and cons.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试用于测试应用程序代码功能的小部分，以验证其正确性。这也允许我们在重构代码和/或添加新功能时，验证功能是否仍然按预期工作。NativeScript和Angular都提供了单元测试框架。我们将探讨这两种类型的单元测试，因为它们都有优点和缺点。
- en: Developing tests at any time is good. However, it is preferable to develop them
    alongside your development of the project's code. Your mind will be fresh on the
    new features, modifications, and all the new code you just added. In our case,
    because we are presenting lots of new concepts throughout this book, we haven't
    followed the best practice since it would have complicated the book even more.
    So, although adding tests later is good, adding them before or while adding your
    new code is considered the best practice.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时间开发测试都是好的。然而，最好是在开发项目代码的同时开发它们。你的思维将保持清醒，对新的功能、修改以及你刚刚添加的所有新代码有清晰的认识。在我们的案例中，因为我们在这本书中介绍了许多新的概念，所以我们没有遵循最佳实践，因为这会使书籍更加复杂。所以，尽管后来添加测试是好的，但在添加新代码之前或同时添加测试被认为是最佳实践。
- en: Angular testing
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular测试
- en: The first type of unit testing we will cover is Angular unit testing. It is
    based around **Karma** ([https://karma-runner.github.io/](https://karma-runner.github.io/))
    and **Jasmine** ([http://github.com/pivotal/jasmine](http://github.com/pivotal/jasmine)).
    Karma is a full-featured test runner, which was produced by the Angular team.
    When the team was implementing Angular, they ran into issues , such as figuring
    out how to test Angular, so they built Karma. Karma has ended up becoming an industry-standard
    multipurpose test runner. Jasmine is an open source testing framework that implements
    a number of testing constructs helps you do all your testing easily. It has been
    around a lot longer than Karma. Since it was in use by a lot of people before
    Karma, it became the default testing library in the Angular community. You are
    free to use any of the other frameworks, such as Mocha, Chia, or even your own
    home-grown testing framework. However, since almost everything you will see in
    the Angular community is based around Jasmine, we will use it also.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的第一种单元测试是Angular单元测试。它基于**Karma** ([https://karma-runner.github.io/](https://karma-runner.github.io/))
    和 **Jasmine** ([http://github.com/pivotal/jasmine](http://github.com/pivotal/jasmine))。Karma是一个功能齐全的测试运行器，由Angular团队开发。当团队在实施Angular时，遇到了一些问题，例如如何测试Angular，所以他们开发了Karma。Karma最终成为了一个行业标准的多用途测试运行器。Jasmine是一个开源的测试框架，实现了一系列测试结构，帮助你轻松完成所有测试。它存在的时间比Karma长得多。由于在Karma之前就有很多人在使用它，因此它成为了Angular社区中的默认测试库。你可以自由使用其他框架，如Mocha、Chia，甚至你自己的定制测试框架。然而，由于Angular社区中几乎所有的内容都是基于Jasmine的，所以我们将使用它。
- en: 'Let''s get the pieces you need installed for Angular testing in NativeScript:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装NativeScript测试所需的Angular测试组件：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You also should probably install Karma globally, especially on Windows. However,
    it is helpful to do so on other platforms also so that you can just type `karma`
    and it runs. In order to do that, type the following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还需要全局安装Karma，尤其是在Windows上。然而，在其他平台上这样做也是有帮助的，这样你就可以直接输入`karma`并运行它。为了做到这一点，请输入以下命令：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you don''t have TypeScript installed globally, where you can just type `tsc`,
    and it builds, you should install it globally. You have to transpile your TypeScript
    into JavaScript before running any tests. To install TypeScript globally, type
    the following command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有全局安装TypeScript，您可以直接输入`tsc`并构建，那么您应该全局安装它。在运行任何测试之前，您必须将TypeScript转换为JavaScript。要全局安装TypeScript，请输入以下命令：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Karma was designed to run tests inside a browser; however, NativeScript code
    does not run in a browser at all. So, we have to do a couple of things differently
    to make the standard Karma testing system run with some NativeScript application
    code. The normal Angular-specific Karma configuration won't work in most cases.
    If you are going to do any Angular work with the web side of things, you should
    check out the standard Angular testing QuickStart project ([https://github.com/angular/quickstart/](https://github.com/angular/quickstart/)).
    That project will get everything set up for a traditional Angular application
    that runs in a browser.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Karma被设计为在浏览器中运行测试；然而，NativeScript代码根本不在浏览器中运行。因此，我们必须做一些不同的事情，以便标准的Karma测试系统能够与一些NativeScript应用程序代码一起运行。在大多数情况下，正常的Angular特定Karma配置将不起作用。如果您打算进行任何与Web方面的Angular工作，您应该查看标准的Angular测试QuickStart项目（[https://github.com/angular/quickstart/](https://github.com/angular/quickstart/)）。该项目将为在浏览器中运行的传统的Angular应用程序设置一切。
- en: 'However, in our case, because we are using NativeScript Angular, we will need
    a totally customized `Karma.conf.js` file. We have included it in the custom config
    file in the git repo, or you can type it from here. Save this file as `Karma.ang.conf.js`**.**
    We are giving a different configuration name because the NativeScript testing
    we discuss later will use the default `Karma.conf.js` name:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的情况下，因为我们使用的是NativeScript Angular，我们需要一个完全定制的`Karma.conf.js`文件。我们已经在git仓库中的自定义配置文件中包含了它，或者您可以从这里输入。将此文件保存为`Karma.ang.conf.js`**。**我们给出不同的配置名称，因为稍后讨论的NativeScript测试将使用默认的`Karma.conf.js`名称：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This configuration sets it up so that Karma will use Jasmine, Browserify, and
    Chrome to run all the tests. Since Karma and Angular were designed for browsers
    first, all the testing still has to run inside a browser. This is the major downside
    for the Angular testing system when doing NativeScript code. It won't support
    any NativeScript-specific code. So, this type of testing is better done on files
    that are data models and/or any code that has no NativeScript-specific code in
    it, which unfortunately in some of your apps might not be very much code. However,
    if you are doing both a NativeScript and web application using the same code base,
    then you should have a lot of code that can run through the standard Angular testing
    framework.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置设置Karma使用Jasmine、Browserify和Chrome来运行所有测试。由于Karma和Angular最初是为浏览器设计的，因此所有测试仍然必须在浏览器内运行。这是在执行NativeScript代码时Angular测试系统的重大缺点。它不会支持任何NativeScript特定的代码。因此，这种测试最好在数据模型文件上执行，或者在任何不包含NativeScript特定代码的代码上执行，遗憾的是，在您的某些应用程序中可能代码并不多。然而，如果您正在使用相同的代码库同时进行NativeScript和Web应用程序的开发，那么您应该有很多可以通过标准Angular测试框架运行的代码。
- en: 'For Angular testing, you will create Jasmine specification files, and they
    all end with `.spec.ts`. We must create these files in the same directory as the
    code you are testing. So, let''s take a crack at creating a new specification
    file for testing. Since this type of unit testing does not allow you to use any
    NativeScript code, I chose a random model file to show how easy this type of unit
    testing is. Let''s create a file called `track.model.spec.ts` in the `app/modules/shared/models`
    folder; this file will be used to test the `track.model.ts` file in that same
    folder. Here is our test code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Angular测试，您将创建Jasmine规范文件，并且它们都以`.spec.ts`结尾。我们必须在您正在测试的代码所在的同一目录中创建这些文件。所以，让我们尝试创建一个新的规范文件来测试。由于这种单元测试不允许您使用任何NativeScript代码，我选择了一个随机的模型文件来展示这种类型的单元测试是多么简单。让我们在`app/modules/shared/models`文件夹中创建一个名为`track.model.spec.ts`的文件；这个文件将用于测试同一文件夹中的`track.model.ts`文件。以下是我们的测试代码：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, let's break this down. The first line fixes an issue with testing inside
    a browser with a TypeScript-built file that uses modules. As I noted in the comments,
    this should be added to all your `spec.ts` files. The next line is where we load
    our model that we will test; you can import any files that you need here, including
    the Angular library.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们来分析一下。第一行解决了在浏览器中使用TypeScript构建的模块化文件进行测试时的问题。正如我在注释中提到的，这应该添加到您所有的`spec.ts`文件中。下一行是我们将要测试的模型加载的地方；您可以在这里导入任何需要的文件，包括Angular库。
- en: Remember that a `.spec.js` file is just a normal TypeScript file; the only thing
     that differentiates it is that it has access to Jasmine globalized functions,
    and runs in a browser. So, all your normal TypeScript code will work fine.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`.spec.js`文件只是一个普通的TypeScript文件；唯一区别的是它能够访问Jasmine的全局化函数，并在浏览器中运行。所以，你所有的正常TypeScript代码都将正常工作。
- en: 'The following line is where we start the actual testing framework. It is a
    Jasmine function that is used to create a test. Jasmine uses a `describe` function
    to start a group of tests. Describe has two parameters: the text description to
    print, and then the actual function to run. So, we basically put in the name of
    the model we are testing and then create the function. Inside each `describe`
    function, we add as many `it` functions as we need. Each `it` is used for a subset
    of the tests. You can also have multiple `describes`, if necessary.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行是我们开始实际测试框架的地方。这是一个用于创建测试的Jasmine函数。Jasmine使用`describe`函数开始一组测试。`describe`有两个参数：要打印的文本描述，然后是实际要运行的函数。所以，我们基本上输入我们正在测试的模型名称，然后创建函数。在每个`describe`函数内部，我们添加我们需要的`it`函数。每个`it`用于测试的一个子集。如果需要，你也可以有多个`describes`。
- en: So, in our test here, we have four separate test groups; the first one is really
    just to verify that everything is correct. It simply makes sure that our model
    gets defined properly. So, we are just using the Jasmine `expect` command to test
    for a valid object that was created with the `.toBeDefined()` function. Simple,
    isn't it?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的测试中，我们有四个独立的测试组；第一个实际上只是验证一切是否正确。它只是确保我们的模型被正确定义。所以，我们只是使用Jasmine的`expect`命令来测试使用`.toBeDefined()`函数创建的有效对象。简单，不是吗？
- en: The next test set attempts to make sure that the defaults are set properly from
    the `beforeEach` function. As you can see, we are using the `expect` command again
    with the `.toBe(value)` function. This is actually highly recommended; it seems
    obvious that the values set should match the values read, but you want to treat
    your modules as a black box. Verify all input and output to make sure that it
    really is set the same way you set it. So, even though we know we set ID to 1,
    we are verifying that when we get the ID, it still equals 1.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试集试图确保`beforeEach`函数正确设置了默认值。正如你所见，我们再次使用`expect`命令与`.toBe(value)`函数。这实际上是高度推荐的；看起来很明显设置的值应该与读取的值匹配，但你想将你的模块视为一个黑盒。验证所有输入和输出以确保它们确实以你设置的方式设置。所以，尽管我们知道我们设置了ID为1，但我们正在验证当我们获取ID时，它仍然等于1。
- en: The third test function starts testing the mute capability, and the final one
    tests the volume functionality. Note that both the *mute* and *volume* have several
    states and/or impact multiple variables. Anything that is beyond a simple assignment
    should be tested through every single state you know of, both valid and invalid,
    if possible. In our case, we noted that mute affects volume and vice versa. So,
    we verify that when one has changed, the other changes with it. This is used as
    a contract to make sure that, down the road if this class changes, it will remain
    the same externally, or our tests will break. In this case, this is more of a
    brown-box; we know a side-effect of mute, and we are depending on that side-effect
    in the application, so we will test for that side-effect to make sure that it
    never changes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个测试函数开始测试静音功能，最后一个测试函数测试音量功能。请注意，静音和音量都有几个状态和/或影响多个变量。任何超出简单赋值的内容都应该通过你所知的每个状态进行测试，无论是有效还是无效，如果可能的话。在我们的案例中，我们注意到静音会影响音量，反之亦然。因此，我们验证当一个变量改变时，另一个变量也会随之改变。这被用作一个合约，以确保将来如果这个类发生变化，它在外部保持不变，或者我们的测试将会失败。在这种情况下，这更像是一个灰盒测试；我们知道静音的一个副作用，并且我们在应用程序中依赖于这个副作用，因此我们将测试这个副作用以确保它永远不会改变。
- en: Running the tests
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'Now, let''s run the test by typing `tsc` to create the transpiled JS files,
    and then running the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过输入`tsc`来运行测试，创建转译后的JS文件，然后运行以下命令：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Karma will then find ALL of the `.spec.js` files and then run all of them on
    your Chrome browser, testing all the functionalities that you defined in each
    `.spec.js` file.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Karma将会找到所有的`.spec.js`文件，然后在你的Chrome浏览器上运行所有这些文件，测试你在每个`.spec.js`文件中定义的所有功能。
- en: Unexpected test failure
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试失败异常
- en: '![](img/00055.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00055.jpeg)'
- en: 'Now isn''t it very interesting that one of our tests actually failed; `TrackModel
    Creation Verify mute FAILED` and **`Expected 1 to be 5.`**. This failure was not
    preplanned for the book; it is actually a real corner case that we just found
    because we started to use unit testing. If you want to take a quick look at the
    code, here is the `TrackModel.ts` code stripped down to just show the relevant
    routines:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不是很有趣吗？我们中的一个测试实际上失败了；`TrackModel Creation Verify mute FAILED`和**`Expected
    1 to be 5.`**。这个失败并不是为这本书预先计划的；实际上，这是一个我们刚刚发现的真实边缘情况，因为我们开始使用单元测试。如果你想快速查看代码，这里是将`TrackModel.ts`代码简化到只显示相关例程的代码：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, I'll give you a few minutes to look at the preceding test code and this
    code and check whether you can spot why the test fails.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我会给你几分钟时间看看前面的测试代码和这段代码，检查你是否能找出测试失败的原因。
- en: Good, I see, you are back; did you see where the corner case is? Don't feel
    bad if you couldn't find it quickly; it took me a few minutes to figure out why
    it was failing also.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我看到，你回来了；你看到边缘情况在哪里了吗？如果你不能很快找到它，不要难过；它花了我几分钟才弄清楚为什么它会失败。
- en: 'Well, first, look at the error message; it said `Verify Mute FAILED`, so this
    means it was our mute test that failed. Then, we put `Verify mute` in the `it`
    function that tested our mute functionality. The second clue is the error, `Expected
    1 to be 5`.So, we expected something to be 5, but it was actually 1\. So, this
    specific test and this line of code are failing in the test:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，首先，看看错误信息；它说`Verify Mute FAILED`，这意味着是我们的mute测试失败了。然后，我们在测试mute功能的`it`函数中放入了`Verify
    mute`。第二个线索是错误，`Expected 1 to be 5`。所以，我们期望某物是5，但实际上它是1。因此，这个特定的测试和这一行代码在测试中失败了：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Why did it fail?
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么它会失败？
- en: 'Let''s start by looking at the test initialization, `beforeEach`; you will
    see that `` `mute: false` ``. Well, next, let''s look at the constructor; it basically
    does `this.mute = false` and the mute setter then runs down its `else` path, which
    is `this.volume = this._origVolume`. Guess what? `this._origVolume` has not been
    set yet, so it sets `this.volume = undefined`. Now take a look at the volume routine;
    the new volume comes in `undefined`, it is set to `1`, which overrides our original
    setting of 5\. So, the test `Expected 1 to be 5.` fails.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们从测试初始化，`beforeEach`，开始看起，你会看到`mute: false`。嗯，接下来，让我们看看构造函数；它基本上做了`this.mute
    = false`，然后mute设置器运行其`else`分支，即`this.volume = this._origVolume`。猜猜看？`this._origVolume`还没有被设置，所以它将`this.volume`设置为`undefined`。现在看看音量例程；新的音量传入`undefined`，它被设置为`1`，这覆盖了我们原来的设置5。所以，测试`Expected
    1 to be 5.`失败了。'
- en: Interesting corner case; it wouldn't have happened if we hadn't set `mute` to
    `false` as part of testing the initialization of properties. However this is something
    we should test, because maybe in one of the revisions of the application we will
    store the mute value and restore it on start.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的边缘情况；如果我们没有在测试属性初始化时将`mute`设置为`false`，这种情况就不会发生。然而，这是我们应该测试的事情，因为也许在应用程序的一个修订版本中，我们将存储mute值并在启动时恢复它。
- en: To fix this, we should fix the class a little. We'll let you do the changes
    that you think are necessary to fix this issue. If you get stuck, you can rename
    the `track.model.fixed.ts` based on the `track.model.ts` file; it contains the
    correct code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个问题，我们应该稍微修改一下类。我们将让你做出你认为必要的更改来修复这个问题。如果你卡住了，你可以根据`track.model.ts`文件重命名`track.model.fixed.ts`；它包含正确的代码。
- en: Once you have it fixed, run the same `tsc` and then the `karma start karma.ang.conf.js` command;
    you should see everything is successfull.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 修复后，运行相同的`tsc`，然后是`karma start karma.ang.conf.js`命令；你应该看到一切都很成功。
- en: Test passes
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试通过
- en: '![](img/00056.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00056.jpeg)'
- en: As this example pinpointed, your code might run correctly in some cases, but
    fail in others. Unit testing can pinpoint errors in your logic that you might
    not see readily. This is especially important when adding new features and/or
    fixing bugs. It is highly recommended that you create new tests for both, and
    then you will know at least at a minimum that your new or modified code is behaving
    properly after you make any code changes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个例子所指出的，你的代码在某些情况下可能运行正确，但在其他情况下可能会失败。单元测试可以指出你可能不会立即看到的逻辑错误。在添加新功能或修复错误时，这尤其重要。强烈建议你为这两者都创建新的测试，然后你至少可以确保在做出任何代码更改后，你的新或修改后的代码表现正常。
- en: Let's switch gears slightly, and look at the NativeScript testing framework;
    the Angular framework is pretty cool, but it has the nasty limitation of not having
    NativeScript framework calls available, so it limits a lot of its usefulness.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微转换一下思路，看看 NativeScript 测试框架；Angular 框架相当酷，但它有一个讨厌的限制，就是没有 NativeScript
    框架调用可用，这限制了它的很多用途。
- en: NativeScript testing framework
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NativeScript 测试框架
- en: 'Okay, be ready to play with the NativeScript testing framework. It is fairly
    simple to install, you simply type the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，准备好玩 NativeScript 测试框架吧。安装它相当简单，你只需输入以下命令：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There is no reason to switch testing frameworks, so choose `jasmine` at the
    prompt asking you which testing framework to use with the NativeScript testing
    framework. This will install all the needed resources for the NativeScript testing
    system. NativeScript's testing system also uses Karma, and it supports a couple
    of different testing frameworks, but for consistency, we will want to continue
    to use Jasmine.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要切换测试框架，所以在询问你使用 NativeScript 测试框架时选择 `jasmine`。这将安装 NativeScript 测试系统所需的所有资源。NativeScript
    的测试系统也使用 Karma，并支持几个不同的测试框架，但为了保持一致性，我们希望继续使用 Jasmine。
- en: Remember earlier when I said Karma uses a browser to do all its tests, and I
    also said that NativeScript code doesn't run in a browser? So, why does NativeScript
    use Karma? How does Karma run the NativeScript code? Excellent questions! Karma
    is actually tricked into thinking that your NativeScript application is a browser.
    Karma uploads the tests to the browser (that is, the NativeScript application),
    and it then runs them. So, in effect, your application is a browser to Karma;
    this is a pretty ingenious solution by the NativeScript team.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我之前说过 Karma 使用浏览器来执行所有测试，我也说过 NativeScript 代码不会在浏览器中运行吗？那么，为什么 NativeScript
    会使用 Karma？Karma 是如何运行 NativeScript 代码的？这是很好的问题！实际上，Karma 被欺骗成认为你的 NativeScript
    应用程序是一个浏览器。Karma 将测试上传到浏览器（即 NativeScript 应用程序），然后运行它们。所以，实际上，你的应用程序对 Karma 来说就像是一个浏览器；这是
    NativeScript 团队的一个相当巧妙的解决方案。
- en: Now, the big pro of the NativeScript testing system is that it can actually
    test all your NativeScript code. It will automatically run a special build of
    your application in your emulator (or on a real device) so that it can run all
    the NativeScript code and access the device properly. The biggest con of the NativeScript
    testing system is that it requires a lot more resources because it must use an
    emulator (or real device) to run the tests. So, it can be considerably more time-consuming
    to run testing than the standard unit testing we discussed earlier in this chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，NativeScript 测试系统的最大优点是它实际上可以测试你所有的 NativeScript 代码。它将自动在你的模拟器（或真实设备）上运行一个特殊的构建版本的应用程序，这样它就可以运行所有的
    NativeScript 代码并正确访问设备。NativeScript 测试系统的最大缺点是它需要更多的资源，因为它必须使用模拟器（或真实设备）来运行测试。所以，运行测试可能比我们在本章
    earlier 讨论的标准单元测试要花费更多的时间。
- en: Okay, so now you have it all installed. Let's move on. All of the NativeScript
    testing files will be in the `app/tests` folder. This folder was created when
    you ran the `tns test init`. If you open up that folder, you will see `example.js`.
    Feel free to delete or leave the file. It is just a dummy test to show you how
    to format your tests using Jasmine.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在你已经安装好了所有内容。让我们继续前进。所有的 NativeScript 测试文件都将位于 `app/tests` 文件夹中。这个文件夹是在你运行
    `tns test init` 命令时创建的。如果你打开这个文件夹，你会看到 `example.js` 文件。你可以随意删除或保留这个文件。它只是一个示例测试，用来展示如何使用
    Jasmine 格式化你的测试。
- en: So, for our NativeScript test, I selected a simple service that uses NativeScript
    code. Let's create our `database.service.test.ts` file in the `app/test` folder.
    Your files in this folder can be named anything but, to keep things easier to
    find, we will end it with `.test.ts`. You can also create subdirectories to organize
    all your tests. In this case, we will test the `app/modules/core/services/database.service.ts`
    file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，对于我们的 NativeScript 测试，我选择了一个使用 NativeScript 代码的简单服务。让我们在 `app/test` 文件夹中创建我们的
    `database.service.test.ts` 文件。你在这个文件夹中的文件可以命名为任何名字，但为了更容易找到，我们将以 `.test.ts` 结尾。你还可以创建子目录来组织你所有的测试。在这种情况下，我们将测试
    `app/modules/core/services/database.service.ts` 文件。
- en: 'This specific service, if you look at the code, actually uses the NativeScript
    `AppSettings` module to store and retrieve data from the Android and iOS system-wide
    storage system. So, this is a great file to test. Let''s create our test file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的服务，如果你查看代码，实际上使用了 NativeScript 的 `AppSettings` 模块来存储和检索来自 Android 和 iOS
    系统级存储系统的数据。所以，这是一个很好的测试文件。让我们创建我们的测试文件：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You might already be able to read this test file pretty easily. Basically, it
    calls the database service a couple of times to set the same key with different
    values. Then, it asks the database service to return the values stored and verifies
    that the results match what we stored. Then, we tell the database service to delete
    our storage key and verify that the key is gone, all pretty straightforward. The
    only thing different in this file is the `include 'reflect-metadata'`. This is
    because the database service uses metadata in it, so we have to make sure that
    the metadata class is loaded before we load the database service class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经能够很容易地阅读这个测试文件。基本上，它调用数据库服务几次以设置具有不同值的相同键。然后，它要求数据库服务返回存储的值并验证结果是否与我们存储的相匹配。然后，我们告诉数据库服务删除我们的存储键并验证该键已消失，所有这些都非常直接。这个文件中唯一不同的是
    `include 'reflect-metadata'`。这是因为数据库服务使用了元数据，所以我们必须确保在加载数据库服务类之前加载元数据类。
- en: Running the tests
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'Let''s try testing the application; to run your tests, type the following command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试测试应用程序；要运行您的测试，请输入以下命令：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, you can run the following command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以运行以下命令：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will start the testing, and you should see something like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动测试，您应该会看到类似以下内容：
- en: '![](img/00057.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00057.jpeg)'
- en: Note that there is an `ERROR` on this screen; this is a false error. Basically,
    when the app finishes running its tests, it quits. Karma sees that the application
    has quit unexpectedly and logs it as an `"ERROR" Disconnected`. The import information
    is the line below the error, where it says `Executed 2 of 2 SUCCESS`. This means
    that it ran two different `described` tests (that is, our `test.ts` file and the
    extra `example.js` file).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个屏幕上有一个 `ERROR`；这是一个错误。基本上，当应用程序完成其测试运行后，它会退出。Karma 看到应用程序意外退出并记录为 `"ERROR"
    Disconnected`。导入信息是错误下面的那一行，其中说 `Executed 2 of 2 SUCCESS`。这意味着它运行了两个不同的 `described`
    测试（即我们的 `test.ts` 文件和额外的 `example.js` 文件）。
- en: You might have also noted that our test file is identical to the Angular testing
    file. That is because they both use Jasmine and Karma. So, the test files can
    be set up almost identically. In this specific case, because the testing is actually
    running inside your application, any plugins, code, and modules, including any
    native code are all available to be tested. This is what makes the NativeScript
    testing harness a lot more powerful and useful. However, its greatest strength
    is also its weakness. Since it has to run inside a running NativeScript application,
    it takes a lot more time to build, start, and run all the tests. This is where
    the standard Angular testing framework can prove beneficial over the NativeScript
    testing framework. Anything that is not using any NativeScript-specific code can
    run from your command line almost instantly, with very little overhead. The quicker
    your tests run, the more likely you are to run them frequently.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能也已经注意到，我们的测试文件与 Angular 测试文件完全相同。这是因为它们都使用 Jasmine 和 Karma。因此，测试文件可以几乎以相同的方式设置。在这个特定的情况下，因为测试实际上是在您的应用程序内部运行的，所以任何插件、代码和模块，包括任何原生代码都可以用于测试。这就是
    NativeScript 测试工具包更加强大和有用的原因。然而，它的最大优势也是它的弱点。由于它必须在一个运行的 NativeScript 应用程序内部运行，因此构建、启动和运行所有测试需要更多的时间。这就是标准
    Angular 测试框架可以证明比 NativeScript 测试框架更有益的地方。任何不使用任何 NativeScript 特定代码的内容都可以从您的命令行几乎瞬间运行，几乎没有开销。您的测试运行得越快，您就越有可能频繁地运行它们。
- en: Summary
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed how to do unit tests and the pros and cons of
    two of the methods of doing unit tests. In a nutshell, Angular testing works for
    generic TypeScript code that does not call any NativeScript-specific code, and
    it runs your tests really quickly. The NativeScript testing harness runs inside
    your NativeScript application and has full access to anything you write and anything
    a normal NativeScript application can do. However, it requires the NativeScript
    application to be running to run its tests, so it might require a full build step
    before it can run your tests.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何进行单元测试以及两种单元测试方法的优缺点。简而言之，Angular 测试适用于不调用任何 NativeScript 特定代码的通用
    TypeScript 代码，并且它运行测试非常快。NativeScript 测试工具包在您的 NativeScript 应用程序内部运行，并可以完全访问您所写的内容以及正常
    NativeScript 应用程序所能做到的一切。然而，它需要在 NativeScript 应用程序运行时才能运行其测试，因此可能需要在运行测试之前进行完整的构建步骤。
- en: Now that we have discussed the two types of unit testing, hang on to your testing
    hat. In the next chapter, we will cover how to do end-to-end testing or full screen
    and application testing of your awesome application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了两种单元测试类型，请继续戴上你的测试帽。在下一章中，我们将介绍如何进行端到端测试或全屏及应用程序测试你的出色应用。
