- en: Integrating Backend Data Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成后端数据服务
- en: Welcome to Chapter 12! This is definitely my favorite chapter, as we will be
    building many end-to-end use cases for our application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到第12章！这绝对是我最喜欢的一章，因为我们将为我们的应用构建许多端到端的用例。
- en: A gentle warning—this chapter is dense—it is packed with a ton of information.
    You may have to read it at a slower pace and spend more time at the keyboard than
    you have with the previous chapters, but, I must say, it is well worth the effort.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一个温和的警告——这一章内容密集——充满了大量的信息。你可能需要以较慢的速度阅读，并花更多时间在键盘上，比你在以前的章节中花的时间更多，但我必须说，这是非常值得的努力。
- en: 'Here is a great way to look at the overall progression of this book:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的方式来看待本书的整体进展：
- en: Everything we've looked at so far, including the two most recent chapters ([Chapter
    10](5f27121b-6fb2-4429-aa6e-394aec2152ac.xhtml), *Working with Forms*, and [Chapter
    11](437face8-d59c-42f3-a49a-af43f2892f7a.xhtml), *Dependency Injection and Services*),
    has laid the foundation for this chapter. With that knowledge under our belts,
    we are now ready to put it all together in order to create our application. So,
    in essence, this chapter also serves the purpose of reviewing many of the topics
    we covered in previous chapters.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，我们所看到的一切，包括最近的两章（[第10章](5f27121b-6fb2-4429-aa6e-394aec2152ac.xhtml)，*使用表单*，和[第11章](437face8-d59c-42f3-a49a-af43f2892f7a.xhtml)，*依赖注入和服务*），都为这一章奠定了基础。有了这些知识，我们现在准备好把它们整合起来，以创建我们的应用。因此，从本质上讲，这一章也是为了回顾我们在以前章节中涵盖的许多主题。
- en: This chapter is the pivotal turning point for us because we will take everything
    we've learned thus far to build 95% of our application in this single chapter.
    This is a lot of material for one chapter, but we have spent a good amount of
    time going over all the aspects of Angular that we will need to build our application,
    so we're going to breeze through it. There is some new and slightly off-topic
    material too—learning how to build backend APIs—which is less important than the
    Angular material. However, we need to have an API, so I selected a set of technologies
    that are simple enough to quickly get up to speed with. We are also going over
    this to help you get your mind around the technologies we will be using to construct
    the APIs.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这一章对我们来说是一个关键的转折点，因为我们将把迄今为止学到的一切都用在这一章中构建我们应用的95%。这是一个章节中的大量材料，但我们已经花了很多时间来讨论我们需要构建应用的所有Angular方面，所以我们将轻松地完成它。还有一些新的和略微离题的材料——学习如何构建后端API——这比Angular材料更不重要。然而，我们需要有一个API，所以我选择了一套简单的技术，可以快速上手。我们还要讨论这个问题，以帮助你了解我们将用来构建API的技术。
- en: In the chapters that follow this one, we will add a couple of things to our
    app (such as route guards and custom form validation) and we will learn how to
    test, debug, secure, and deploy our application.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将为我们的应用添加一些东西（如路由守卫和自定义表单验证），并学习如何测试、调试、保护和部署我们的应用。
- en: So, from that perspective, we're good to go. Many sections in this chapter are
    bonus material that I deem important to learn about because I want you to succeed,
    not only as an Angular developer, but as a web developer in general. This will
    help you to enhance your skills, and hands-on examples are sure to augment your
    technical knowledge as a web developer.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从这个角度来看，我们已经准备好了。本章中的许多部分都是我认为重要学习的额外材料，因为我希望你不仅作为一个Angular开发者成功，而且作为一个网页开发者成功。这将帮助你提高你的技能，实际示例肯定会增加你作为网页开发者的技术知识。
- en: 'We will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: ListingApp – an overview
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ListingApp - 概述
- en: Fundamental concepts for Angular applications
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular应用的基本概念
- en: ListingApp – technical requirements
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ListingApp - 技术要求
- en: Building APIs for our application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的应用构建APIs
- en: The Google Firestore database
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Firestore数据库
- en: Angular HttpClient
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular HttpClient
- en: Integrating backend services
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成后端服务
- en: We've spent a lot of time in this book discussing a myriad of things—mostly
    Angular-centric (such as components, routing, flex-layout, NG Bootstrap, Angular
    Material, and working with forms), and a few things that were standalone (such
    as wire-framing, ES6, TypeScript, and Bootstrap). It is important to possess all
    that knowledge, of course, but we haven't yet integrated live data to bring our
    Angular application to life. However, as you can see from the previous bullet-point
    list, this is about to change. This is where developing in Angular starts to get
    fun, and also much more practical, since an application that does not create and
    consume data is not much of an application at all.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们花了很多时间讨论了许多事情 - 主要是与Angular相关的（如组件、路由、flex-layout、NG Bootstrap、Angular
    Material和处理表单），还有一些独立的事情（如线框、ES6、TypeScript和Bootstrap）。当然，拥有所有这些知识是很重要的，但我们还没有集成实时数据来使我们的Angular应用程序生动起来。然而，正如你从前面的项目列表中所看到的，这将发生改变。这就是Angular开发开始变得有趣的地方，也更加实用，因为一个不创建和使用数据的应用程序根本就不是一个应用程序。
- en: OK. Let's get right into it by starting with learning about some of the fundamental
    concepts that form the foundation of any application. Then, we'll take a look
    at the steps involved in building our ListingApp.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。让我们立即开始学习构建任何应用程序基础的一些基本概念。然后，我们将看一下构建我们的ListingApp所涉及的步骤。
- en: ListingApp – an overview
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ListingApp - 概述
- en: 'In this chapter, we will be building our `ListingApp` application. In this
    section, we will cover the functional requirement list. Our overall application
    plan can be broken down into three main sections:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建我们的“ListingApp”应用程序。在本节中，我们将介绍功能需求列表。我们的整体应用程序计划可以分为三个主要部分：
- en: '**UI layer**: The UI aspects involve designing or building the forms, displaying
    data, routing, and validations.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI层**：UI方面涉及设计或构建表单、显示数据、路由和验证。'
- en: '**Services or middleware layer**: We will learn how to write shared services,
    which will be responsible for backend integrations with APIs and databases.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务或中间件层**：我们将学习如何编写共享服务，这些服务将负责与API和数据库进行后端集成。'
- en: '**Database or fake API setup**: We will learn how to set up fake APIs using
    JSON Server and we will also learn how to create our NoSQL database using Firestore.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库或虚拟API设置**：我们将学习如何使用JSON Server设置虚拟API，并学习如何使用Firestore创建我们的NoSQL数据库。'
- en: 'Here''s the complete list of functional use cases we will be building as part
    of the learning experience in this chapter:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将在本章学习过程中构建的功能用例的完整列表：
- en: Display all the listings
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示所有列表
- en: View listings by ID
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按ID查看列表
- en: Add a new listing
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新的列表
- en: Edit a listing
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑列表
- en: Delete a listing
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除列表
- en: Add comments
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加评论
- en: Update comments
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新评论
- en: Delete comments
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除评论
- en: Edit comments
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑评论
- en: All the use cases listed will require us to implement HTTP calls. For some,
    we will need to make POST, GET, and PUT HTTP calls.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的所有用例都需要我们实现HTTP调用。对于一些用例，我们需要进行POST、GET和PUT HTTP调用。
- en: Before we proceed any further, now is a good time to bring back all the learning
    and functionality we have implemented throughout the course of this book. We will
    need to recollect how we designed and developed our forms, how we captured the
    form data, how we displayed the data in the component templates, how we implemented
    routing with parameters, and how we call methods implemented in services inside
    components.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步进行之前，现在是一个很好的时机，回顾我们在整本书中实施的所有学习和功能。我们需要回想一下我们如何设计和开发我们的表单，如何捕获表单数据，如何在组件模板中显示数据，如何使用参数实现路由，以及如何在组件内调用服务中实现的方法。
- en: We have a lot of work to do, and a load of fun awaits us, so let's get started!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多工作要做，还有很多乐趣在等着我们，所以让我们开始吧！
- en: Fundamental concepts for Angular applications
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular应用程序的基本概念
- en: We are going to learn and build a lot of interesting things in this chapter,
    but before we start doing that, we should learn about a number of fundamental
    concepts, including strongly typed language concepts, Angular models, observables, NoSQL
    databases, and CRUD operations in general.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习和构建许多有趣的东西，但在开始之前，我们应该了解一些基本概念，包括强类型语言概念、Angular模型、可观察对象、NoSQL数据库和一般的CRUD操作。
- en: Strongly typed languages
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强类型语言
- en: 'A strongly typed programming language refers to the fact that each of the data
    types is predefined and tightly coupled with the variables. Take a look at the
    following variable that''s been defined:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 强类型编程语言指的是每种数据类型都是预定义的，并且与变量紧密耦合。看看下面定义的变量：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We are declaring a variable and explicitly mentioned the fact that the type
    of variable is an integer, which makes it very obvious that the variable cannot
    hold any other data type except an integer. If we try to provide any value that
    is not an integer, TypeScript will throw an error. TypeScript is also a strongly
    typed language and, since we write our Angular applications in TypeScript, we
    can conclude that Angular applications follow strongly typed formats.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个变量，并明确指出变量的类型是整数，这使得很明显变量除了整数之外不能容纳任何其他数据类型。如果我们尝试提供任何不是整数的值，TypeScript会抛出错误。TypeScript也是一种强类型语言，因为我们在TypeScript中编写我们的Angular应用程序，我们可以得出结论，Angular应用程序遵循强类型格式。
- en: Typescript interfaces
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Typescript接口
- en: In this section, we will learn how to create our own data types in TypeScript,
    which we can use in our Angular applications.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在TypeScript中创建我们自己的数据类型，这些类型可以在我们的Angular应用程序中使用。
- en: Angular models are a way to create complex data structures by clubbing multiple
    data types into an object and defining a new object, which can then be used as
    a data type in itself. It's Angular's way of ensuring that complex data objects
    adhere to certain predefined data specs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Angular模型是一种通过将多个数据类型组合成一个对象并定义一个新对象来创建复杂数据结构的方法，然后可以将其作为数据类型本身使用。这是Angular确保复杂数据对象遵守某些预定义数据规范的方式。
- en: 'The TypeScript language provides interfaces that also serve the same purpose.
    We can also make use of ES6 classes to define our data structures. We can extend
    the programming syntax to create our custom data types. Let''s demonstrate this
    by creating a sample model. We are going to create a model and call it `Listing`,
    which will have the following properties:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript语言提供了接口，也具有相同的作用。我们还可以利用ES6类来定义我们的数据结构。我们可以扩展编程语法来创建我们自定义的数据类型。让我们通过创建一个示例模型来演示这一点。我们将创建一个名为`Listing`的模型，它将具有以下属性：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have created an Angular model, which is a class with properties such as `id`,
    `userId`, `title`, `status`, `price`, and `active`. We can now use this model
    as a data type in our application. We can import this class into all of our components
    and services to make sure our data map adheres to the `Listing` data spec.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个Angular模型，这是一个具有属性的类，例如`id`、`userId`、`title`、`status`、`price`和`active`。现在我们可以在我们的应用程序中使用这个模型作为数据类型。我们可以将这个类导入到所有的组件和服务中，以确保我们的数据映射符合`Listing`数据规范。
- en: We will use the previously defined model throughout this chapter while building
    our application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在构建应用程序时使用先前定义的模型。
- en: Observables
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察对象
- en: Most traditional applications work on the request and response architecture,
    which means our application client will make a request for data to the server,
    and, in return, the server will give us a response. While the server is returning
    the response, our application goes into wait mode until all the responses are
    received, which obviously makes applications slow.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数传统应用程序都是基于请求和响应的架构运行的，这意味着我们的应用程序客户端会向服务器发出数据请求，而服务器会返回响应。在服务器返回响应的同时，我们的应用程序会进入等待模式，直到接收到所有响应，这显然会使应用程序变慢。
- en: This architecture has multiple drawbacks. First, the application waits for a
    response, which creates delays in applications. Second, there is no way we can
    handle multiple pieces of data coming in over a period of time. Third, since our
    application waits until it gets the response, which makes synchronous calls, we
    cannot execute asynchronous programming. And finally, event handling becomes a
    nightmare for developers. So, how do we address the preceding issues? The answer
    is by using observables.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构有多个缺点。首先，应用程序等待响应，这会导致应用程序延迟。其次，我们无法处理在一段时间内传入的多个数据。第三，由于我们的应用程序等待直到获得响应，这使得同步调用，我们无法执行异步编程。最后，事件处理对开发人员来说是一场噩梦。那么，我们如何解决上述问题？答案是使用可观察对象。
- en: Observables are a type of array that returns data over a period of time asynchronously.
    Angular uses a third-party library called **Reactive Extensions** (**RxJS**) and
    has observables implemented inside the framework mainly for event handling, tree
    shaking, and so on. We can also easily import, create, and subscribe to custom
    observables.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象是一种在一段时间内异步返回数据的数组类型。Angular使用一个名为**Reactive Extensions** (**RxJS**)的第三方库，在框架内部实现了可观察对象，主要用于事件处理、树摇动等。我们还可以轻松导入、创建和订阅自定义可观察对象。
- en: NoSQL databases concept
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NoSQL数据库概念
- en: In this section, we are going to learn about NoSQL databases. Really? NoSQL?
    Are we not going to use a database to store our critical data? Of course we are
    going to use a database to store our data; however, it won't be a traditional
    relational database, which has a strict predefined schema and columns that have
    a standard data type. With NoSQL databases, everything is document-oriented and
    we can store data in one place without worrying about the data types. NoSQL databases
    hold collections of documents.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习有关NoSQL数据库的知识。真的吗？NoSQL？我们不打算使用数据库来存储我们的关键数据吗？当然我们会使用数据库来存储我们的数据；但是，它不会是传统的关系型数据库，它具有严格的预定义模式和具有标准数据类型的列。使用NoSQL数据库，一切都是面向文档的，我们可以在一个地方存储数据，而不必担心数据类型。NoSQL数据库保存文档集合。
- en: 'We can still perform database activities such as the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以执行以下数据库活动：
- en: Creating a document
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建文档
- en: Inserting a document
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入文档
- en: Editing an existing document
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑现有文档
- en: Deleting a document
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除文档
- en: 'We can also perform a lot of advanced functionality, such as indexing and authentication.
    There are a lot of open source as well as commercial solutions that provide NoSQL
    databases. Here''s a quick list of some of the NoSQL database providers:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以执行许多高级功能，如索引和身份验证。有许多开源和商业解决方案提供NoSQL数据库。以下是一些NoSQL数据库提供商的快速列表：
- en: MongoDB
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB
- en: Redis
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis
- en: RavenDB
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RavenDB
- en: Firestore
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firestore
- en: MemcacheDB
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MemcacheDB
- en: During the course of developing our application in this chapter, we will implement
    Firestore as our backend system. In the next section, we will learn about some
    of the important tasks we will undertake involving these databases.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开发我们的应用程序过程中，我们将实现Firestore作为我们的后端系统。在下一节中，我们将了解一些涉及这些数据库的重要任务。
- en: CRUD operations – overview
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CRUD操作-概述
- en: Whenever we consider using a database as a backend storage system for applications,
    the primary goal is to be able to add, retrieve, search, or modify the data, which
    are more commonly known as CRUD operations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们考虑将数据库作为应用程序的后端存储系统时，主要目标是能够添加、检索、搜索或修改数据，这更常被称为CRUD操作。
- en: 'CRUD stands for Create, Read, Update, and Delete in computer programming, and
    these terms are outlined as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD代表计算机编程中的创建、读取、更新和删除，这些术语如下所述：
- en: '**Create**:Create or add new data to the database. We would usually be running
    an INSERT query in the database. This is associated with the HTTP POST method.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建**：在数据库中创建或添加新数据。我们通常会在数据库中运行INSERT查询。这与HTTP POST方法相关联。'
- en: '**Read**:Read or retrieve data based on a filter or search criteria. We will
    run the SELECT query in the database to do this. This is associated with the HTTP
    GET method.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取**：根据过滤器或搜索条件读取或检索数据。我们将在数据库中运行SELECT查询来执行此操作。这与HTTP GET方法相关联。'
- en: '**Update**: Update or edit an existing record in the database. We will use
    the UPDATE query in the database. This is associated with the HTTP PUT method.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新**：更新或编辑数据库中的现有记录。我们将在数据库中使用UPDATE查询。这与HTTP PUT方法相关联。'
- en: '**Delete**:Delete an existing record in the database. We can either use the
    DELETE query to delete a record, or just set a column indicating that the record
    has been deleted using the UPDATE query. This is associated with the DELETE method.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：删除数据库中的现有记录。我们可以使用DELETE查询来删除记录，或者只是使用UPDATE查询设置一个指示记录已被删除的列。这与DELETE方法相关联。'
- en: In the upcoming sections, we'll use these concepts to build our `ListingApp`
    functionality and the technical requirements of our application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将使用这些概念来构建我们的`ListingApp`功能和我们应用程序的技术要求。
- en: ListingApp – technical requirements
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ListingApp - 技术要求
- en: Any good dynamic application will require us to work with APIs and we will need
    to store the data in a database. This section covers two very important technical
    aspects required for building any dynamic application–JSON APIs and a dynamic
    database. We will be making use of the JSON server and for the database, we will
    use Google's Firestore database.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 任何良好的动态应用程序都需要我们处理API，并且我们需要将数据存储在数据库中。本节涵盖了构建任何动态应用程序所需的两个非常重要的技术方面 - JSON
    API和动态数据库。我们将使用JSON服务器，而对于数据库，我们将使用Google的Firestore数据库。
- en: Building APIs for ListingApp
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为ListingApp构建API
- en: During the development cycle of any project, as a frontend developer, we will
    need to work with APIs and integrate them into our application. We will need to
    define and agree upon the JSON contracts that we expect from our APIs. In this
    section, we will learn about the various options we have to generate the APIs
    that we can use while the backend developers are still working on developing actual
    APIs. When we have fake APIs available, developers can work independently.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何项目的开发周期中，作为前端开发人员，我们将需要处理API并将其集成到我们的应用程序中。我们需要定义并就我们期望从API中得到的JSON合同达成一致。在本节中，我们将了解我们在后端开发人员仍在开发实际API时可以使用的各种生成API的选项。当我们有虚假API可用时，开发人员可以独立工作。
- en: 'There are various tools and libraries (available for free) that we can use
    to work with fake APIs. We will be using the JSON server library to serve our
    APIs. So, let''s begin by taking the following steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种各样的工具和库（可免费使用），我们可以用来处理虚假API。我们将使用JSON服务器库来提供我们的API。所以，让我们从以下步骤开始：
- en: 'To install the `json-server` library, run the following command in the command-line
    interface:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装`json-server`库，请在命令行界面中运行以下命令：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When the command has run successfully, you should see the following output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当命令成功运行时，您应该看到以下输出：
- en: '![](assets/4e3c93b3-afdb-45b8-9161-78dda48b28e0.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4e3c93b3-afdb-45b8-9161-78dda48b28e0.png)'
- en: 'Now that we have installed our `json-server` library, it''s time to create
    our APIs and JSON structure. In our project directory, we will create a new folder
    called APIs and create a new file named `data.json`, which will hold our JSON data.
    Take a look at the folder structure once you have created the folder and files:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经安装了`json-server`库，是时候创建我们的API和JSON结构了。在我们的项目目录中，我们将创建一个名为APIs的新文件夹，并创建一个名为`data.json`的新文件，其中将保存我们的JSON数据。创建文件夹和文件后，查看文件夹结构：
- en: '![](assets/8237c689-9d04-4083-98a3-9e6ede3a2808.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8237c689-9d04-4083-98a3-9e6ede3a2808.png)'
- en: 'Since we have created two JSON files, it''s time to add some JSON data to the
    files for listings, as well as users. Open the `listings.json` file by adding
    the following data to it:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们创建了两个JSON文件，现在是时候向文件添加一些列表和用户的JSON数据了。通过向`listings.json`文件添加以下数据来打开`listings.json`文件：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We are creating dummy data of JSON arrays for listings, users, and cities. Technically,
    in a real application scenario, this data would be retrieved from the database
    at runtime.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在为列表、用户和城市创建JSON数组的虚拟数据。从技术上讲，在实际应用场景中，这些数据将在运行时从数据库中检索。
- en: 'To start serving the fake APIs with data, we need to start and initialize the
    JSON file. We will navigate to the `API` folder where we have created our `data.json`
    file and run the following command:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始提供带有数据的虚假API，我们需要启动和初始化JSON文件。我们将转到我们创建了`data.json`文件的`API`文件夹，并运行以下命令：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When we have run the command successfully, we should see the following output:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们成功运行命令时，应该看到以下输出：
- en: '![](assets/89bc400c-4dc3-4bfa-b467-1bafd834cf43.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/89bc400c-4dc3-4bfa-b467-1bafd834cf43.png)'
- en: Notice that, under Resources, we can see the fake APIs that are listed; that
    is, `http://localhost:3000/listings`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在资源下，我们可以看到列出的虚假API；即`http://localhost:3000/listings`。
- en: 'Try launching the URL in the browser. You should see the JSON data displayed
    for listings, users, and cities. The output is displayed in the following screenshot:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在浏览器中打开URL。您应该看到JSON数据显示为列表、用户和城市。输出显示在以下截图中：
- en: '![](assets/6cf12696-4bd4-49c2-9fec-e7309c1bc69d.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6cf12696-4bd4-49c2-9fec-e7309c1bc69d.png)'
- en: Awesome! We can now use these APIs in our HTTP calls. We will have to wait for
    just one more section before we jump right into learning about HTTP functionality.
    For our friends who are full stack developers and know how to set up databases,
    the next section is certainly for you. We will learn about setting up our Firestore
    database, which will store our data. Later, we will use this to implement our
    application.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们可以在我们的HTTP调用中使用这些API。在我们直接学习HTTP功能之前，我们只需要再等待一个部分。对于那些全栈开发人员并且知道如何设置数据库的朋友来说，下一部分肯定是给你们的。我们将学习如何设置我们的Firestore数据库，用于存储我们的数据。稍后，我们将使用它来实现我们的应用程序。
- en: Google Firestore database
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Firestore数据库
- en: 'The Google Firestore database is part of Google Cloud Platform. The official
    website of Google Cloud describes it as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Google Firestore数据库是Google Cloud平台的一部分。Google Cloud的官方网站描述如下：
- en: '**Cloud Firestore** is a fast, fully managed, serverless, cloud-native NoSQL
    document database that simplifies storing, syncing, and querying data for your
    mobile, web, and IoT apps on a global scale. Reference: [https://cloud.google.com/firestore/](https://cloud.google.com/firestore/)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cloud Firestore** 是一个快速、完全托管的、无服务器的、云原生的NoSQL文档数据库，简化了在全球范围内为移动应用程序、Web应用程序和物联网应用程序存储、同步和查询数据。参考：[https://cloud.google.com/firestore/](https://cloud.google.com/firestore/)'
- en: 'Firestore is a database as a service offered by Google and offers an easy-to-use
    NoSQL document database. Since Firestore is also coming from the makers of Angular,
    it''s natural that there are libraries that support easy integrations between
    the two. In this section, we will learn how to set up the Firestore database.
    So, let''s begin:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Firestore是由Google提供的作为服务的数据库，并提供易于使用的NoSQL文档数据库。由于Firestore也来自Angular的制造商，因此自然会有支持两者之间轻松集成的库。在本节中，我们将学习如何设置Firestore数据库。所以，让我们开始：
- en: 'We will need to log in to our Firebase application using our credentials. Upon
    successful login, we should see the welcome screen, as displayed in the following
    screenshot:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要使用我们的凭据登录到我们的Firebase应用程序。成功登录后，我们应该看到欢迎屏幕，如下面的屏幕截图所示：
- en: '![](assets/f0a7086f-2b95-410c-b9ec-0d48243ad883.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f0a7086f-2b95-410c-b9ec-0d48243ad883.png)'
- en: The home page will list all the projects we created in the Firebase application,
    and you will also notice a big Add project link.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 主页将列出我们在Firebase应用程序中创建的所有项目，您还会注意到一个大的“添加项目”链接。
- en: 'Now, let''s create a new project for our application by clicking on the Add
    project link.We will be prompted by a modal window where we need to enter a Project
    name for our project, as shown in the following screenshot:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过单击“添加项目”链接为我们的应用程序创建一个新项目。我们将收到一个模态窗口的提示，需要为我们的项目输入一个“项目名称”，如下面的屏幕截图所示：
- en: '![](assets/b3635d56-27a4-41d2-ac9a-e7d101d1bbad.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b3635d56-27a4-41d2-ac9a-e7d101d1bbad.png)'
- en: Here, we will enter `Listings` as our project name. Once our project has been
    provisioned, we will be taken to the newly created project page.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将输入“列表”作为我们的项目名称。一旦我们的项目被配置，我们将被带到新创建的项目页面。
- en: 'We now click on Databases in the sidebar menu. We will be prompted to select
    the mode in which we will initialize our database. We will select the test mode
    for our testing, and once we have performed the implementation, we will switch
    the security mode:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在侧边栏菜单中点击“数据库”。我们将被提示选择初始化数据库的模式。我们将为我们的测试选择测试模式，一旦我们执行了实现，我们将切换安全模式：
- en: '![](assets/7899d48c-9591-4553-9148-0102594e5337.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7899d48c-9591-4553-9148-0102594e5337.png)'
- en: As shown in the preceding screenshot, we are using a database in test mode,
    which will allow us to read or write documents easily.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，我们正在使用测试模式中的数据库，这将使我们能够轻松地读取或写入文档。
- en: Do not forget to change the settings of the database if you want to use the
    database in a production environment.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在生产环境中使用数据库，请不要忘记更改数据库的设置。
- en: 'We''ll now move on to create our `comments` collection. We''ll add a unique
    identifier called `commentId`. In addition, we are adding three fields as a schema
    for the documents that will be stored in the collections, as shown here:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将继续创建我们的“评论”集合。我们将添加一个名为“commentId”的唯一标识符。此外，我们正在为将存储在集合中的文档添加三个字段作为模式，如下所示：
- en: '![](assets/143676a1-eaea-42ce-8193-f0e4785ffd31.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/143676a1-eaea-42ce-8193-f0e4785ffd31.png)'
- en: Since Firestore is a NoSQL document database, the schema is not restricted by
    any data types. We can now perform CRUD operations, such as adding a new document,
    editing, or even deleting documents, in the Firestore database.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Firestore是一个NoSQL文档数据库，其模式不受任何数据类型的限制。我们现在可以执行CRUD操作，例如添加新文档，编辑，甚至删除Firestore数据库中的文档。
- en: In the last two sections, we have learned about creating fake APIs using the
    JSON Server, and we have also created a NoSQL document database using Firestore.
    Now that we have reached a stage where we have learned about all the fundamental
    concepts needed to start implementing the end-to-end functionality of our `ListingApp`,
    let's jump into the HTTP world!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的两个部分中，我们已经学习了如何使用JSON Server创建虚拟API，并且还使用Firestore创建了一个NoSQL文档数据库。现在我们已经达到了一个阶段，我们已经学习了开始实现`ListingApp`端到端功能所需的所有基本概念，让我们进入HTTP世界吧！
- en: Angular HttpClient
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular HttpClient
- en: In this section, we will learn about the most important aspect of Angular—`HttpClient`.
    Using the `HttpClient` interface, we can perform HTTP request and response calls. In
    the previous chapter, we learned about dependency injection and services; in this
    chapter, we will learn how to write services, which will include methods so that
    we can make HTTP calls and process responses using `HttpClient`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习Angular最重要的方面——`HttpClient`。使用`HttpClient`接口，我们可以执行HTTP请求和响应调用。在上一章中，我们学习了依赖注入和服务；在本章中，我们将学习如何编写包含方法的服务，以便我们可以使用`HttpClient`进行HTTP调用和处理响应。
- en: '`HttpClient` is a small, easy-to-use, powerful library for performing HTTP
    request and response calls. Using `HttpClient`, we can easily communicate with
    backend services, and the module supports most modern web browsers. `HttpClient`
    comes with a lot of advanced functionality, such as interceptors and progress
    events. `HttpClient` supports various HTTP methods, including GET, POST, PUT,
    PATCH, DELETE, JSONP, and options. Each of these calls always returns an observable.
    We have to subscribe to the observables in order to process the responses. If
    we do not subscribe, nothing will happen.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient`是一个小巧、易于使用、功能强大的库，用于执行HTTP请求和响应调用。使用`HttpClient`，我们可以轻松地与后端服务进行通信，该模块支持大多数现代Web浏览器。`HttpClient`具有许多高级功能，如拦截器和进度事件。`HttpClient`支持各种HTTP方法，包括GET、POST、PUT、PATCH、DELETE、JSONP和options。这些调用中的每一个都会返回一个observable。我们必须订阅这些observable以处理响应。如果我们不订阅，将不会发生任何事情。'
- en: '`HttpClientModule` is available in the `@angular/common/http` library and needs
    to be imported into the `app.module.ts` file; otherwise, we will encounter errors.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClientModule`位于`@angular/common/http`库中，需要被导入到`app.module.ts`文件中；否则，我们将遇到错误。'
- en: 'We now know about the `HttpClient` module, but before we jump into implementing
    the module in our applications, it''s good to know about some of the key functionality
    that got added to `HttpClient`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在了解了`HttpClient`模块，但在我们开始在应用程序中实现该模块之前，了解一些被添加到`HttpClient`中的关键功能是很重要的：
- en: '`HttpClient` provides a strongly typed response body.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpClient`提供了强类型的响应体。'
- en: The request/response objects in `HttpClient` are immutable.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpClient`中的请求/响应对象是不可变的。'
- en: The JSON format response is the default. We no longer have to map it into a
    JSON object.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON格式的响应是默认的。我们不再需要将其映射为JSON对象。
- en: '`HttpClient` provides interceptors that are really helpful in middleware for
    intercepting an `HttpRequest` for transforming or processing a response.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpClient`提供了拦截器，这在中间件中拦截`HttpRequest`以进行转换或处理响应非常有帮助。'
- en: '`HttpClient` includes testability features. We can easily mock the requests
    and process headers more efficiently.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpClient`包括可测试性功能。我们可以轻松模拟请求并更有效地处理标头。'
- en: In the following section, we will learn about the `HttpClient` module, which
    needs to be imported into the component or service where we can make the HTTP
    calls. We will also learn about the HTTP verbs that are available and learn about
    their purpose in modern applications.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将学习`HttpClient`模块，它需要被导入到组件或服务中，我们可以在那里进行HTTP调用。我们还将学习现代应用程序中可用的HTTP动词以及它们的目的。
- en: HttpClient and HTTP verbs
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HttpClient和HTTP动词
- en: If the previous section was an introduction to `HttpClientModule` and `HttpClient`
    and its advantages, in this section, we will dig deeper and also learn how to
    write some sample code for implementing `HttpClient`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前一部分是对`HttpClientModule`和`HttpClient`及其优势的介绍，那么在本节中，我们将深入了解并学习如何编写一些实现`HttpClient`的示例代码。
- en: As we mentioned earlier, `HttpClient` supports GET, POST, PUT, PATCH, DELETE,
    JSONP, and options methods, which will return observables. `HttpClient` also provides
    modules, which can easily pass various options and data using `HttpHeaders` and
    `HttpParams`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，`HttpClient`支持GET、POST、PUT、PATCH、DELETE、JSONP和options方法，这些方法将返回可观察对象。`HttpClient`还提供了模块，可以使用`HttpHeaders`和`HttpParams`轻松传递各种选项和数据。
- en: 'In order to use `HttpClient`, we will need to import `HttpClientModule` into
    our application module (`app.module.ts`) file, and we also need to import `HttpClient`
    into our services or components and inject `HttpClient` inside the constructor
    so that we can use it to make HTTP calls. Add the following line of code to your
    `app.module.ts` file, and don''t forget to add it to the list of import modules
    as well:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`HttpClient`，我们需要将`HttpClientModule`导入到我们的应用程序模块（`app.module.ts`）文件中，还需要将`HttpClient`导入到我们的服务或组件中，并在构造函数中注入`HttpClient`，以便我们可以使用它进行HTTP调用。将以下代码添加到您的`app.module.ts`文件中，并不要忘记将其添加到导入模块的列表中：
- en: '[PRE5]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, let's implement some of the most frequently used HTTP verbs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现一些最常用的HTTP动词。
- en: We will implement the HTTP methods separately for both the JSON server APIs
    and the Firestore database.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分别为JSON服务器API和Firestore数据库实现HTTP方法。
- en: HTTP GET
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP GET
- en: 'We use the HTTP GET method to communicate with backend services to retrieve
    information from a particular URL resource. The sample code to get all listings
    is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用HTTP GET方法与后端服务通信，从特定URL资源中检索信息。获取所有列表的示例代码如下：
- en: '[PRE6]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have created a method named `getAllListings`, and we have explicitly mentioning
    the fact that the method will return an observable value of any data type. We
    have to pass the URL to the GET method. The URL is a mandatory value we need to
    pass. We can also pass optional data such as `Headers`, `Params`, `reportProgress`,
    and `responseType`. The GET method will return an instance of an RxJS observable,
    and we can subscribe to listen to the response.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`getAllListings`的方法，并明确指出该方法将返回任何数据类型的可观察值。我们需要将URL传递给GET方法。URL是我们需要传递的必需值。我们还可以传递可选数据，如`Headers`、`Params`、`reportProgress`和`responseType`。GET方法将返回RxJS可观察对象的实例，我们可以订阅以监听响应。
- en: On similar terms, we can easily create HTTP calls using the POST, PUT, and DELETE
    methods.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似的条件下，我们可以轻松地使用POST、PUT和DELETE方法创建HTTP调用。
- en: HTTP POST
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP POST
- en: 'Whenever we need to send any data or information securely to the server, such
    as a username, password, and email, we always use the POST method. The HTTP POST
    verb is always associated with creating or adding new data. It''s secure and does
    not make data visible in the URL, unlike GET. In the POST method, along with the
    URL as a string, we will need to pass data to the URL. We can also pass options
    to the POST method, such as Headers, and Params. The following is the sample code
    for writing a sample HTTP POST call:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们需要安全地向服务器发送任何数据或信息，例如用户名、密码和电子邮件时，我们总是使用POST方法。HTTP POST动词总是与创建或添加新数据相关联。它是安全的，不像GET方法那样在URL中显示数据。在POST方法中，我们需要将数据传递给URL，以及URL作为字符串。我们还可以向POST方法传递选项，例如Headers和Params。以下是编写示例HTTP
    POST调用的示例代码：
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we are creating a new method called `addNewListing`,
    which is accepting a param listing, which we will use as our data. We are creating
    an instance of `HttpHeaders`, so we create an object of the class, and we are
    setting the value of the `Content-Type` object to be `application/json`. We are
    then creating variable options and formatting them to send headers. Finally, we
    are making use of the `http.post` method to make a POST request.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在创建一个名为`addNewListing`的新方法，它接受一个名为listing的参数，我们将使用它作为我们的数据。我们正在创建一个`HttpHeaders`的实例，所以我们创建了一个类的对象，并且我们正在将`Content-Type`对象的值设置为`application/json`。然后，我们正在创建变量选项并对其进行格式化以发送标头。最后，我们正在使用`http.post`方法进行POST请求。
- en: HTTP PUT
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP PUT
- en: 'In this section, we will learn how to make HTTP PUT calls. The PUT method is
    used to update or edit an existing dataset in the server. The HTTP PUT method
    involves a two-step process. First, we will need to retrieve data that we need
    to update and then pass the updated information back to the server using the POST
    method. The following is the sample code for creating the PUT method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将学习如何进行HTTP PUT调用。PUT方法用于更新或编辑服务器中的现有数据集。HTTP PUT方法涉及一个两步过程。首先，我们需要检索需要更新的数据，然后使用POST方法将更新后的信息传递回服务器。以下是创建PUT方法的示例代码：
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We need to pass the URL as a mandatory parameter for the PUT method. Fortunately,
    there are various options available. For example, we can pass headers, params,
    and suchlike in the options.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将URL作为PUT方法的必需参数传递。幸运的是，有各种可用的选项。例如，我们可以在选项中传递标头、参数等。
- en: HTTP DELETE
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP DELETE
- en: 'DELETE is an important operation of CRUD functionality. We can easily perform
    delete operations using the HTTP DELETE method. The `delete` operation can be
    achieved depending on the use case and the application''s compliance. There are
    two types of deletions we can do—soft delete and hard delete:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: DELETE是CRUD功能的重要操作。我们可以使用HTTP DELETE方法轻松执行删除操作。`delete`操作可以根据用例和应用程序的合规性来实现。我们可以进行两种类型的删除操作——软删除和硬删除：
- en: '**Soft delete**: When using soft delete, we do not delete or erase the records
    from our database systems; instead, we update the records and set a column or
    field and mark it as deleted so that the records are not displayed to the user.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软删除**：在使用软删除时，我们不会从数据库系统中删除或擦除记录；相反，我们会更新记录并设置一个列或字段，并将其标记为已删除，以便用户不会看到这些记录。'
- en: '**Hard delete**: The requested data is deleted permanently from the database
    system. Once the data is erased, it cannot be reverted or restored.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬删除**：请求的数据从数据库系统中永久删除。一旦数据被删除，就无法恢复或恢复。'
- en: Let me give you a good example of both use cases. If you try to delete your
    Google account, it notifies you that you can come back and restore your account
    within *x* number of days, after which the data will be completely erased from
    their servers.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给你举一个很好的例子。如果你试图删除你的谷歌账户，它会通知你，在*x*天内你可以回来恢复你的账户，之后数据将会从他们的服务器上完全删除。
- en: 'Back to our implementation. We can use the `http.delete()` method to implement
    the DELETE functionality in our applications. The sample code is given here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的实现。我们可以使用`http.delete()`方法来实现应用程序中的DELETE功能。示例代码如下：
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We need to pass the URL value as mandatory and options, as the name implies,
    are optional for the `delete` method.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将URL值作为PUT方法的必需参数传递，而选项则是可选的。
- en: HTTP via promises
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过承诺进行HTTP。
- en: Promises are just a technical implementation of what real-world promises do!
    Suppose you had promised your boss that you would complete tasks assigned to you.
    If you do, that means a promise has been resolved and if you don't, it means it's
    been rejected. Similarly, a Promise in HTTP implementation means that we will
    wait for future data, either resolved or rejected, and then we'll do some logical
    processing based on the output received.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Promises只是对现实世界承诺的技术实现！假设你答应了老板你会完成分配给你的任务。如果你做到了，那意味着承诺已经实现，如果你没有，那意味着它被拒绝了。同样，HTTP实现中的Promise意味着我们将等待未来的数据，无论是resolved还是rejected，然后我们将根据收到的输出进行一些逻辑处理。
- en: HTTP promises are a way to keep a placeholder for future data based on the success
    or failed states. Does this sound similar to regular HTTP calls? Yes, they are,
    with a major striking difference—*promises are asynchronous in nature*. When we
    make HTTP calls in Angular, it will wait until the request is completed and we
    receive the response; JavaScript will continue with the execution and, if it encounters
    synchronous assignments/operations, it will execute them immediately and fail
    if they are dependent on previous states or data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP promises是一种基于成功或失败状态的未来数据的占位符。这听起来是否类似于常规的HTTP调用？是的，它们是，但有一个重大的区别——*promises是异步的*。当我们在Angular中进行HTTP调用时，它会等待直到请求完成并收到响应；JavaScript将继续执行，如果遇到同步赋值/操作，它将立即执行并在它们依赖于先前状态或数据时失败。
- en: 'A promise takes a callback method, which will take two parameters—`resolve`
    and `reject`. `resolve` means the method will return a promise object with a given
    message, while `reject` means the promise object is rejected with a reason. Then,
    you can expect `.then` and `.catch` to be called back if all goes well or not,
    respectively. The following is the sample code for writing a promise, showing
    the handling responses of `resolve` and `reject`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一个promise接受一个回调方法，该方法将带有两个参数——`resolve`和`reject`。`resolve`意味着该方法将返回一个带有给定消息的promise对象，而`reject`意味着promise对象被拒绝了。然后，你可以期待`.then`和`.catch`被调用，如果一切顺利或不顺利的话。以下是编写promise的示例代码，展示了对`resolve`和`reject`的处理响应：
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let's analyze the preceding code in detail. We have implemented a promise and,
    as specified, the `callback` method will take two parameters, `resolve` and `reject`.
    We check whether the status of the listing is active; if yes, we resolve the promise;
    otherwise, we reject the promise. By default, the data returned by the resolved
    method will be passed to the `.then` method, and any failures or exceptions will
    be passed to the `.catch` method.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析前面的代码。我们已经实现了一个promise，并且按照规定，`callback`方法将会带有两个参数，`resolve`和`reject`。我们检查列表的状态是否为活动状态；如果是，我们就会resolve这个promise；否则，我们会reject这个promise。默认情况下，resolved方法返回的数据将会传递给`.then`方法，而任何失败或异常将会传递给`.catch`方法。
- en: Since promises are asynchronous, which means we can chain events or methods,
    go ahead and add a method that will be called inside the `.then` method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于promises是异步的，这意味着我们可以链接事件或方法，继续添加一个将在`.then`方法内调用的方法。
- en: Awesome! We are now armed with all the theoretical knowledge about the classes
    and modules provided by Angular for HTTP functionality. We learned about `HttpClientModule`,
    `HttpClient`, and, above all, we learned about the various HTTP verbs we can make
    use of in our application. We also learned about HTTP observables and promises.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在掌握了关于Angular提供的用于HTTP功能的类和模块的所有理论知识。我们了解了`HttpClientModule`，`HttpClient`，最重要的是，我们了解了我们可以在应用程序中使用的各种HTTP动词。我们还了解了HTTP
    observables和promises。
- en: Now, it's time to get our hands dirty with code. We will learn how to create
    our multiple data sources, which we will need to integrate using HTTP calls. The
    first one will be using the fake JSON server APIs, while the second one will be
    using the Firestore database. In the next section, we will learn about, and create,
    the services that we will need before we start our mission of integrating functionality
    end to end.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候动手写代码了。我们将学习如何创建我们需要使用HTTP调用集成的多个数据源。第一个将使用虚假的JSON服务器API，而第二个将使用Firestore数据库。在下一节中，我们将学习并创建我们在开始端对端集成功能之前需要的服务。
- en: Integrating backend services
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成后端服务
- en: We are making really good progress here, so let's keep rolling. One of the best
    practices in software development is to create code that is reusable, generic,
    and maintainable. In most applications that are dynamic in nature, we need to
    make a lot of HTTP calls to create, save, retrieve, edit, or delete data, as per
    the functional requirements of the application. If we do not have commonly shared
    HTTP calls, we may end up with a lot of methods having HTTP implementations, and
    it will be very difficult to maintain them in the long run. How do we address
    this situation? You already know the answer, my friend. That's right—by using
    services. In [Chapter 11](437face8-d59c-42f3-a49a-af43f2892f7a.xhtml)*, Dependency
    Injection and Services, *we learned all about Angular services and best practices
    regarding dependency injection.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里取得了非常好的进展，所以让我们继续前进。软件开发中的最佳实践之一是创建可重用、通用和可维护的代码。在大多数动态应用程序中，我们需要进行大量的HTTP调用来根据应用程序的功能需求创建、保存、检索、编辑或删除数据。如果我们没有共享的HTTP调用，可能会导致有很多具有HTTP实现的方法，并且在长期内很难维护它们。我们如何解决这种情况？你已经知道答案了，我的朋友。没错——通过使用服务。在[第11章](437face8-d59c-42f3-a49a-af43f2892f7a.xhtml)中，依赖注入和服务，我们学习了关于Angular服务和依赖注入的最佳实践。
- en: 'Angular guidelines clearly state that all HTTP calls and functionality should
    be kept in services, which makes it easy to reuse existing code. Angular services
    are shared functions that allow us to access the properties and methods defined
    inside it. We will also create our custom services, in which we will implement
    our HTTP calls and which can be easily reused in various components. Let''s create
    two services—one for working with JSON server APIs, and one for Firestore database
    operations. For working with JSON server APIs, we will call our `DbOperationsService` service,
    and for working with the Firestore database, we will call our `CRUDService` service.
    Each of these services will have the methods to make HTTP calls for creating,
    reading, updating, and deleting the data. Now, let''s run the following `ng` command,
    which will generate our services:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Angular指南明确规定所有HTTP调用和功能应该放在服务中，这样可以轻松地重用现有代码。Angular服务是共享函数，允许我们访问其中定义的属性和方法。我们还将创建自定义服务，在其中实现我们的HTTP调用，并可以在各种组件中轻松重用。让我们创建两个服务——一个用于使用JSON服务器API，另一个用于Firestore数据库操作。对于使用JSON服务器API，我们将调用我们的`DbOperationsService`服务，对于使用Firestore数据库，我们将调用我们的`CRUDService`服务。这些服务中的每一个都将具有用于创建、读取、更新和删除数据的方法。现在，让我们运行以下`ng`命令，它将生成我们的服务：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Upon successful execution of the preceding command, we will execute the following
    command to generate another service. Let's call it `crud`. We will use the following `ng`
    command to generate the service.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功执行上述命令后，我们将执行以下命令来生成另一个服务。让我们称之为`crud`。我们将使用以下`ng`命令来生成该服务。
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Following a successful run, we should see the service files being generated,
    along with their respective spec files. So far, so good. We will need these services
    when we start the end-to-end integration work. It may look complicated, but trust
    me, all of it will make a lot of sense in the sections to follow.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 成功运行后，我们应该看到服务文件和它们各自的规范文件被生成。到目前为止，一切顺利。当我们开始端到端集成工作时，我们将需要这些服务。这可能看起来很复杂，但相信我，接下来的章节中所有这些都会有很多意义。
- en: Integrating Angular HTTP with backend APIs
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Angular HTTP与后端API集成
- en: This section is very important as this is the melting pot for most of the topics
    we have learned about throughout the course of this book. We are going to do complete
    end-to-end integration, from the UI to services, through to data sources.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分非常重要，因为这是我们在整本书中学到的大部分主题的熔炉。我们将进行完整的端到端集成，从UI到服务，再到数据源。
- en: 'We will need to generate the components that we are going to use in our application.
    Let''s run the following `ng` commands to generate four components:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要生成我们将在应用程序中使用的组件。让我们运行以下`ng`命令来生成四个组件：
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When these commands are run successfully, we should see the output shown in
    the following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些命令成功运行时，我们应该看到以下截图中显示的输出：
- en: '![](assets/944fdf72-407c-45c0-95cc-7b26877b9220.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/944fdf72-407c-45c0-95cc-7b26877b9220.png)'
- en: 'Now that we have generated our components, we will make use of the `DbOperationsService` service
    we generated in the previous section. We will also use our fake APIs that we created
    using the JSON server. We will implement methods for getting all the listings,
    viewing a particular listing, editing an existing listing, and finally, deleting
    a listing. In order to achieve this, we will need to import `HttpClientModule`
    into our `app.module.ts` file. We will also need to import `HttpClient` into our `db-operations.service.ts` service
    file. We will also import the `HttpHeaders` module. This is not mandatory, but,
    by way of good practice, we will be importing and using it while making our HTTP
    calls. We will be adding the following code to the `db-operations.service.ts`
    file:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经生成了我们的组件，我们将利用在上一节中生成的`DbOperationsService`服务。我们还将使用我们使用JSON服务器创建的虚拟API。我们将实现获取所有列表、查看特定列表、编辑现有列表以及最后删除列表的方法。为了实现这一点，我们需要将`HttpClientModule`导入到我们的`app.module.ts`文件中。我们还需要将`HttpClient`导入到我们的`db-operations.service.ts`服务文件中。我们还将导入`HttpHeaders`模块。这不是强制性的，但是出于良好的实践，我们将在进行HTTP调用时导入并使用它。我们将向`db-operations.service.ts`文件添加以下代码：
- en: '[PRE14]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's analyze the preceding code in detail. First, we are importing the required
    modules: `Injectable`, `HttpClient`, `HttpHeaders`, and `HttpParams`. We are then
    injecting `HttpClient` into our constructor and creating an instance named `http`.
    We are then creating four methods, namely; `getListings`, `viewListing`, `editListing`,
    and `deleteListing`. In the `getListings` method, we are calling the API URL using
    the HTTP GET method. This will return all the listings from the `data.json` file
    we created earlier. In `viewListing`, we pass the ID of the Listing to retrieve
    the data of the listing using the HTTP GET method. In the `addListing` method,
    we are calling the API and passing the data object using the HTTP POST method.
    This will create a new row in our JSON file. Next up is the `editListing` method,
    which takes two parameters—the ID of the listing and the updated data object,
    which we need to save. The last method is `deleteListing`, to which we will pass
    the ID of the listing we want to delete.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析前面的代码。首先，我们正在导入所需的模块：`Injectable`、`HttpClient`、`HttpHeaders`和`HttpParams`。然后我们将`HttpClient`注入到我们的构造函数中，并创建一个名为`http`的实例。然后，我们创建了四种方法，分别是`getListings`、`viewListing`、`editListing`和`deleteListing`。在`getListings`方法中，我们使用HTTP
    GET方法调用API URL。这将从我们之前创建的`data.json`文件中返回所有列表。在`viewListing`中，我们传递Listing的ID以使用HTTP
    GET方法检索列表的数据。在`addListing`方法中，我们调用API并使用HTTP POST方法传递数据对象。这将在我们的JSON文件中创建一行新数据。接下来是`editListing`方法，它接受两个参数——列表的ID和我们需要保存的更新后的数据对象。最后一个方法是`deleteListing`，我们将传递要删除的列表的ID。
- en: In a more practical world, we would need to pass authentication tokens, additional
    security, cleaning data, and so on.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在更实际的世界中，我们需要传递身份验证令牌、额外的安全性、清理数据等等。
- en: 'We have now made our custom service, which includes the methods that will make
    HTTP calls. Before we start working on our components, we will create a few routes
    where we will map the components we have generated. Open the `app-routing.module.ts` file
    and import all our components inside it. Then, we will need to add the routes
    to it, as shown in the following code block:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经制作了我们的自定义服务，其中包括将进行HTTP调用的方法。在我们开始处理组件之前，我们将创建一些路由，我们将在其中映射我们生成的组件。打开`app-routing.module.ts`文件，并在其中导入我们所有的组件。然后，我们需要将路由添加到其中，如下面的代码块所示：
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, we are updating our `AppRoutingModule` and adding five
    routes. We created the `create-listing` and `view-listing` routes and mapped them
    to `CreateListingComponent` and `ViewListingComponent`, respectively. That's very
    straightforward. For the `delete-listing` and `update-listing` routes, notice
    that we are passing a parameter named ID. We will use these and pass the listing
    ID in order to delete or update the data for a listing.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在更新我们的`AppRoutingModule`并添加五个路由。我们创建了`create-listing`和`view-listing`路由，并将它们分别映射到`CreateListingComponent`和`ViewListingComponent`。这非常直接了当。对于`delete-listing`和`update-listing`路由，注意我们传递了一个名为ID的参数。我们将使用这些参数传递列表ID以便删除或更新列表的数据。
- en: 'Now that we have created our service and routes, they are ready to be implemented
    in our components. Let''s start working on our components. First, we will start
    with `ViewListingComponent`. Open the `view-listing.component.ts` file and add
    functionality to retrieve all the listings, as shown in the following code block:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的服务和路由，它们已经准备好在我们的组件中实现。让我们开始处理我们的组件。首先，我们将从`ViewListingComponent`开始。打开`view-listing.component.ts`文件，并添加检索所有列表的功能，如下面的代码块所示：
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's analyze the preceding code in detail. First, we need to import all the
    required modules and classes. We are importing `DbOperationsService` we created.
    We are also importing the listing interface class we created previously. Since
    we will be working with the `Listing` interface class, we will need to import `Observable`
    from `rxjs`. Next, we are declaring our selector as `app-view-listing`; we will
    call this directive in the template `view-listing.component.html` file. We will
    now create three variables, named `listArr`, `viewList`, and `isViewPage`. Note
    that `listArr` and `viewList` are declared as `Observable`. The difference between
    the `listArr` and `viewList` variables is that `listArr` is an observable of the
    Listing type and is an array, whereas `viewList` is an `Observable` of the Listing
    type and will hold a single list value. Since we have imported a service, we will
    need to create an instance called `dbOps` in our constructor method. We will implement
    the `ngOnInIt` method here; we are calling the `getListings` method using the
    instance of the `dbOps` service. We are subscribing to the method, which means
    we will map the data to the `listArr` variable. We will then use the `listArr` variable
    to display it in the template file. Finally, we are creating a `showListing` method
    to which we are passing the listing object. Using the instance of the service,
    we are calling the `viewListing` method and passing the listing ID. We are subscribing
    to the data and mapping it to the `viewList` variable.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析上述代码。首先，我们需要导入所有必需的模块和类。我们导入了我们创建的`DbOperationsService`。我们还导入了之前创建的listing接口类。由于我们将使用`Listing`接口类，我们需要从`rxjs`中导入`Observable`。接下来，我们将声明我们的选择器为`app-view-listing`；我们将在模板`view-listing.component.html`文件中调用这个指令。我们现在将创建三个变量，名为`listArr`，`viewList`和`isViewPage`。请注意，`listArr`和`viewList`被声明为`Observable`。`listArr`和`viewList`变量之间的区别在于，`listArr`是Listing类型的observable并且是一个数组，而`viewList`是Listing类型的`Observable`并且将保存单个列表值。由于我们导入了一个服务，我们需要在构造方法中创建一个名为`dbOps`的实例。我们将在这里实现`ngOnInIt`方法；我们正在使用`dbOps`服务的实例调用`getListings`方法。我们正在订阅该方法，这意味着我们将把数据映射到`listArr`变量上。然后我们将使用`listArr`变量在模板文件中显示它。最后，我们正在创建一个`showListing`方法，我们正在将列表对象传递给它。使用服务的实例，我们正在调用`viewListing`方法并传递列表ID。我们正在订阅数据并将其映射到`viewList`变量上。
- en: 'Now, we need to update our template in the `view-listing.component.html` file
    and use the `listArr` and `viewList` variables to display the data in the page,
    as shown in the following code block:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新`view-listing.component.html`文件中的模板，并使用`listArr`和`viewList`变量在页面中显示数据，如下面的代码块所示：
- en: '[PRE17]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, we have created a table. Using `ngFor`, we are looping
    the data that we get from the API, and, using interpolation, we are displaying
    the data in the table rows. Note that, for the anchor tags, we are using the `routerLink` directive
    to dynamically create the link, and we are passing the ID for the edit and delete
    links.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们创建了一个表格。使用`ngFor`，我们正在循环从API获取的数据，并使用插值在表格行中显示数据。请注意，对于锚标签，我们使用`routerLink`指令动态创建链接，并传递编辑和删除链接的ID。
- en: 'I am sure you are excited about the end result. Let''s run the `ng serve` command.
    You should see the following output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你对最终结果感到兴奋。让我们运行`ng serve`命令。您应该看到以下输出：
- en: '![](assets/ea6ccfac-c281-415e-806d-ca198cb3ef63.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ea6ccfac-c281-415e-806d-ca198cb3ef63.png)'
- en: Beautiful! Now things are really cooking! There's no better encouragement than
    seeing the code in action. We have added the Add New Listing menu link, so now
    it's time to implement that functionality in our `createListing` component.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在事情真的开始变得有意思了！看到代码在运行中没有比这更好的鼓励了。我们已经添加了“添加新列表”菜单链接，现在是时候在我们的`createListing`组件中实现该功能了。
- en: 'Open `createListingComponent` and modify the `create-listing.component.ts`
    file by adding the following code to it:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`createListingComponent`，并通过向其中添加以下代码来修改`create-listing.component.ts`文件：
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let's analyze the preceding code in detail. We are importing the required modules
    in the file. We are also importing the `DbOperationsService`, which we created
    earlier. We are creating a few variables; that is, `userId`, `newListing`, and
    `successMsg`, and assigning some initial values. We are creating an `addNewList` method,
    and we are passing the `listForm` data. We are also creating a data structure
    similar to our listing model that we created. Next, using the instance of the
    service, we are calling the `addListing` method and passing the data object that
    we need to save. This will create a new record in our `data.json` file. Finally,
    we are mapping the result to the `successMsg` variable. We will use this to display
    the success message to the user.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析上述代码。我们正在文件中导入所需的模块。我们还导入了我们之前创建的`DbOperationsService`。我们创建了一些变量，即`userId`、`newListing`和`successMsg`，并分配了一些初始值。我们创建了一个`addNewList`方法，并传递了`listForm`数据。我们还创建了一个类似于我们创建的列表模型的数据结构。接下来，使用服务的实例，我们调用`addListing`方法并传递我们需要保存的数据对象。这将在我们的`data.json`文件中创建一个新记录。最后，我们将结果映射到`successMsg`变量。我们将使用这个变量向用户显示成功消息。
- en: Since we are using a fake API, we have stubbed the value of the ID. In a more
    real-time scenario, this ID will be auto-incremented on the database side and
    would always be a unique value.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是虚拟API，我们已经存根化了ID的值。在更实时的情况下，这个ID将在数据库端自动递增，并且始终是一个唯一的值。
- en: 'Now, it''s time to update our template file so that we can get data from the
    user using the form. Open the `create-listing.component.html` file and add the
    following code to it:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候更新我们的模板文件，以便我们可以使用表单从用户那里获取数据。打开`create-listing.component.html`文件，并将以下代码添加到其中：
- en: '[PRE19]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, we are creating a form using the template-driven forms.
    We have created a few form fields to capture data, such as title, description,
    price, and active. We are using the template variables for the form and the fields.
    We are also calling the `addNewList` method on the `ngSubmit` event and submitting
    the entire form. By running the `ng serve` command, we should see the following
    output:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们正在使用基于模板的表单创建表单。我们创建了一些表单字段来捕获数据，例如标题、描述、价格和活动状态。我们正在使用模板变量来引用表单和字段。我们还在`ngSubmit`事件上调用`addNewList`方法并提交整个表单。通过运行`ng
    serve`命令，我们应该看到以下输出：
- en: '![](assets/25cfa752-5dbf-406c-9cb5-c36306ff7bf5.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/25cfa752-5dbf-406c-9cb5-c36306ff7bf5.png)'
- en: 'Now, go ahead and add some data to the form fields and then click on the Submit
    button. You should see a success message if the record has been created successfully:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续向表单字段添加一些数据，然后单击“提交”按钮。如果记录已成功创建，您应该会看到成功消息：
- en: '![](assets/45a7f6dd-fc19-4f86-b688-57a958605088.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/45a7f6dd-fc19-4f86-b688-57a958605088.png)'
- en: Now, click on the Get All Listings link in the menu. You should see the newly
    created record in the listings displayed in the table. Do you remember that we
    added the edit and delete links for the listings? It's time to implement them
    now. We will start with the edit functionality first and then implement the delete
    functionality.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击菜单中的“获取所有列表”链接。您应该在表中看到新创建的记录显示在列表中。您还记得我们为列表添加了编辑和删除链接吗？现在是时候实现它们了。我们将首先实现编辑功能，然后再实现删除功能。
- en: 'Open our update listing component, edit the `update-listing.component.ts` file,
    and then add the following code to it:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 打开我们的更新列表组件，编辑`update-listing.component.ts`文件，然后将以下代码添加到其中：
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let's analyze the preceding code in detail. We are importing the required modules
    into our component file. We are importing `ActivatedRoute`, our service, listing
    interface class, and observable into the component file. In order to achieve update
    functionality, we need to do two things. First, we will need to retrieve the data
    of the listing for which the ID is passed. Once the user updates the data and
    clicks on the Submit button, we will persist the data for that listing. We will
    also need to inject the router and service into our constructor. On the `ngOnInit`
    method, using the router snapshot, we are capturing the ID of the listing from
    the URL. Then, using the instance of the service, we are calling the `viewListing` method
    to get details of the listing based on the ID that's passed. Finally, we have
    created an `editListing` method. Using the instance of the service, we are calling
    the `editListing` method, and so we need to pass two parameters, one for passing
    the ID of the listing, and another for passing the updated data of the listings.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析前面的代码。我们正在将所需的模块导入到我们的组件文件中。我们正在导入`ActivatedRoute`，我们的服务，列表接口类和可观察对象到组件文件中。为了实现更新功能，我们需要做两件事。首先，我们需要检索传递了ID的列表的数据。一旦用户更新了数据并单击“提交”按钮，我们将持久化该列表的数据。我们还需要将路由器和服务注入到我们的构造函数中。在`ngOnInit`方法中，使用路由器快照，我们正在从URL中捕获列表的ID。然后，使用服务的实例，我们正在调用`viewListing`方法来获取基于传递的ID的列表的详细信息。最后，我们创建了一个`editListing`方法。使用服务的实例，我们正在调用`editListing`方法，因此我们需要传递两个参数，一个用于传递列表的ID，另一个用于传递列表的更新数据。
- en: 'Now, let''s update our template file. Open the `update-listing.component.html`
    file and add the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新我们的模板文件。打开`update-listing.component.html`文件并添加以下代码：
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code, we are once again creating a form based on the template-driven
    form approach. You will notice that the edit form is very much similar to the
    create listing form. You are almost correct, but there are some important differences.
    Note that we are now using two-way data binding with `ngModel` and binding the
    value to the form field. With this, when we get the initial data, it''s displayed
    in the form field. Now, the user can edit data and, when clicking on the Update
    Listing button, the data is sent to the `addListing` method and persisted in the
    backend API. Now, let''s see it in action. By running the `ng serve` command,
    we should see the following output:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们再次基于模板驱动的表单方法创建了一个表单。您会注意到编辑表单与创建列表表单非常相似。你几乎是正确的，但有一些重要的区别。请注意，我们现在正在使用`ngModel`进行双向数据绑定，并将值绑定到表单字段。有了这个，当我们获取初始数据时，它会显示在表单字段中。现在，用户可以编辑数据，当单击“更新列表”按钮时，数据将被发送到`addListing`方法并持久化在后端API中。现在，让我们看看它的运行情况。通过运行`ng
    serve`命令，我们应该看到以下输出：
- en: '![](assets/a1dd547e-7a4d-4337-9167-8ff0b66d54ad.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a1dd547e-7a4d-4337-9167-8ff0b66d54ad.png)'
- en: Notice that the URL has the ID of the listing that was passed as the parameter.
    The data is retrieved and has been displayed on the page load. Now, when the user
    updates the details in the form and clicks on the Submit button, this will update
    the data of the listings. That's your homework.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，URL 中包含作为参数传递的列表的 ID。数据已被检索并显示在页面加载上。现在，当用户更新表单中的详细信息并单击“提交”按钮时，这将更新列表的数据。这是你的作业。
- en: 'Alright, so we have implemented create, edit, and view functionality. Next,
    we will implement the delete functionality of the listings. Remember that, for
    the delete and edit functionalities, the user will always navigate to the pages
    on click-through anchor tags. Open `DeleteListingComponent` and update the `delete-listing.component.ts`
    file, as shown in the following code block:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们已经实现了创建、编辑和查看功能。接下来，我们将实现列表的删除功能。请记住，对于删除和编辑功能，用户将始终通过单击锚标签导航到页面。打开`DeleteListingComponent`并更新`delete-listing.component.ts`文件，如下面的代码块所示：
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let's analyze the preceding code in detail. We are importing the required modules
    in the component file; that is, `ActivatedRoute`, `DbOperationsService`, `Listing`,
    and `Observable`. We are also creating a few variables—`viewList`, `ListId`, and
    `successMsg`. Then, we are injecting the route and service into the constructor
    method. Finally, with the `ngOnInIt` method, we are passing the ID of the listing
    that needs to be deleted. We are subscribing the data and mapping it to `successMsg`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析上述代码。我们在组件文件中导入所需的模块；即`ActivatedRoute`、`DbOperationsService`、`Listing`和`Observable`。我们还创建了一些变量——`viewList`、`ListId`和`successMsg`。然后，我们将路由和服务注入到构造方法中。最后，使用`ngOnInIt`方法，我们传递需要删除的列表的ID。我们订阅数据并将其映射到`successMsg`。
- en: In this section, we have learned how to implement basic CRUD operations for
    our `ListingApp`. Then, we learned how to make HTTP calls for the GET, POST, PUT,
    and DELETE methods. Finally, we learned how to create fake APIs using the JSON
    Server. In the next section, we will learn how to implement CRUD operations using
    the cloud NoSQL Firestore database.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何为我们的`ListingApp`实现基本的CRUD操作。然后，我们学习了如何对GET、POST、PUT和DELETE方法进行HTTP调用。最后，我们学习了如何使用JSON
    Server创建虚拟API。在下一节中，我们将学习如何使用云NoSQL Firestore数据库实现CRUD操作。
- en: Integrating Angular HTTP with Google Firebase
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Angular HTTP与Google Firebase集成
- en: In this section, we will learn how to implement HTTP functionality for a NoSQL
    Firestore database. We created our Firestore database in an earlier section. Now
    is the right time to integrate the Angular HTTP calls, which will invoke and work
    with the Firestore database.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何为NoSQL Firestore数据库实现HTTP功能。我们在之前的部分中创建了我们的Firestore数据库。现在是集成Angular
    HTTP调用的合适时机，它将调用并与Firestore数据库一起工作。
- en: What are the use cases we will implement? For our `ListingApp`, we will need
    a commenting system. As a user, we should be able to add, edit, delete, and view
    comments. All of these use cases will require us to make HTTP calls to APIs to
    save, retrieve, and delete comments.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现哪些用例？对于我们的`ListingApp`，我们将需要一个评论系统。作为用户，我们应该能够添加、编辑、删除和查看评论。所有这些用例都将需要我们调用API来保存、检索和删除评论。
- en: Angular Fire is the official library for Firebase. The library provides a lot
    of built-in modules that support activities such as authentication, working with
    Firestore databases, observable-based push notifications, and much more.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Fire是Firebase的官方库。该库提供了许多内置模块，支持诸如身份验证、与Firestore数据库的交互、基于observable的推送通知等活动。
- en: 'We will need to install this module under `@angular/fire`. Run the following
    command in the command-line interface to install the library:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`@angular/fire`下安装此模块。在命令行界面中运行以下命令以安装库：
- en: '[PRE23]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When we run the preceding command successfully, we should see the following
    output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们成功运行上述命令时，我们应该看到以下输出：
- en: '![](assets/30d643f3-d22c-424b-8b87-083dfdafaa46.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/30d643f3-d22c-424b-8b87-083dfdafaa46.png)'
- en: Once we have installed the library, we will proceed and create a new custom
    service for our integration pieces with the Firestore database.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完库后，我们将继续创建一个新的自定义服务，用于与Firestore数据库集成。
- en: 'Run the following command to generate a new service:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令生成一个新的服务：
- en: '[PRE24]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When we run the preceding command successfully, we should see the following
    output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们成功运行上述命令时，我们应该看到以下输出：
- en: '![](assets/64a22473-60eb-46b9-8af7-75c4fac4adbe.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/64a22473-60eb-46b9-8af7-75c4fac4adbe.png)'
- en: You will notice that two files are generated. We will implement all our HTTP
    calls inside the service. As we mentioned previously, we will need to create a
    few components that will map to each piece of functionality and will internally
    call the service that has the HTTP implementations.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到生成了两个文件。我们将在服务内实现所有我们的HTTP调用。正如我们之前提到的，我们需要创建一些组件，这些组件将映射到每个功能，并在内部调用具有HTTP实现的服务。
- en: 'Run the following `ng generate` commands to generate components for the comment''s
    functionality:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下`ng generate`命令为评论功能生成组件：
- en: '[PRE25]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When we run the preceding commands successfully, we should see the following
    output:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们成功运行上述命令时，我们应该看到以下输出：
- en: '![](assets/07b0c36b-c14c-493d-b2ae-a4fc5e72edac.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/07b0c36b-c14c-493d-b2ae-a4fc5e72edac.png)'
- en: You will notice that the components have been generated and added to our project
    directory. You will also notice that the `app.module.ts` file has been updated
    with entries for the components.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到组件已经生成并添加到我们的项目目录中。您还会注意到`app.module.ts`文件已经更新，其中包含了组件的条目。
- en: 'We have generated our components and the service that''s required for our integration.
    We have also installed the Angular Fire library. In order to use the Angular Fire
    library in our application, we will need to import the library into our `app.module.ts`
    file. Import the required modules into the app module file and list the modules
    in the import list of our application, as shown here:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经生成了我们的组件和所需的服务，还安装了Angular Fire库。为了在我们的应用程序中使用Angular Fire库，我们需要将该库导入到我们的`app.module.ts`文件中。将所需的模块导入到应用程序模块文件中，并在应用程序的导入列表中列出这些模块，如下所示：
- en: '[PRE26]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'One important thing to note in the preceding code is that we are importing
    the required modules from Angular Fire and also listing them under the import
    module list. Notice that we have imported a file called `firebase-config`. These
    are environment variables, which will hold the API keys for authentication with
    Firebase. We can find the API keys listed under the Firebase account, as shown
    in the following screenshot:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中需要注意的一点是，我们正在从Angular Fire导入所需的模块，并在导入模块列表下列出它们。请注意，我们导入了一个名为`firebase-config`的文件。这些是环境变量，将保存用于与Firebase进行身份验证的API密钥。我们可以在Firebase帐户下找到列出的API密钥，如下面的屏幕截图所示：
- en: '![](assets/8fe5f267-e6da-4265-8b00-f27ae9974cd0.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8fe5f267-e6da-4265-8b00-f27ae9974cd0.png)'
- en: 'We will need to copy the details into the `firebase-config.ts` file. The following
    screenshot displays the settings specified in our `ListingApp`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将详细信息复制到`firebase-config.ts`文件中。以下屏幕截图显示了我们的`ListingApp`中指定的设置：
- en: '![](assets/56f1af0c-5dc6-47e0-b652-87daf31e2832.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/56f1af0c-5dc6-47e0-b652-87daf31e2832.png)'
- en: So far, so good. Now that we have installed the required library, imported the
    modules, and done the configuration settings, it's time to work on our application
    components. We are making great progress here. Let's keep this momentum going.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。现在我们已经安装了所需的库，导入了模块，并完成了配置设置，现在是时候开始处理我们的应用程序组件了。我们在这里取得了很大的进展。让我们保持这种势头。
- en: Now that we have created our components, we will quickly modify our `app-routing.module.ts`
    file and create a new route for each of these components.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的组件，我们将快速修改我们的`app-routing.module.ts`文件，并为每个组件创建一个新的路由。
- en: We have already mastered Angular routing, in [Chapter 4](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml),
    *Routing.* Revisit that chapter if you need a quick refresher.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经掌握了Angular路由，在[第4章](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml) *路由*。如果需要快速复习，请重新阅读该章节。
- en: 'In the following code, we have imported all the required component classes
    into the `app-routing.module.ts` file and added the respective routes to the routing
    file:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们已经将所有所需的组件类导入到`app-routing.module.ts`文件中，并在路由文件中添加了相应的路由：
- en: '[PRE27]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will use the four newly created routes to implement the comment''s functionality
    in `ListingApp`. We are going to add the CRUD operations using the Firestore database.
    We will need to import the `AngularFirestore` module to our service, as shown
    here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用四个新创建的路由来在`ListingApp`中实现评论功能。我们将使用Firestore数据库添加CRUD操作。我们需要将`AngularFirestore`模块导入到我们的服务中，如下所示：
- en: '[PRE28]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After we have imported the module into our file, we will need to inject it
    inside the `constructor` method, as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将模块导入到我们的文件后，我们需要在`constructor`方法中注入它，如下所示：
- en: '[PRE29]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can now make use of the `AngularFirestore` module and implement CRUD operations
    using Firestore. Take a look at the complete updated code in the `crud-service.service.ts`
    file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以利用`AngularFirestore`模块并使用Firestore实现CRUD操作。查看`crud-service.service.ts`文件中的完整更新代码。
- en: '[PRE30]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let's analyze the preceding code in detail. We have imported all the required
    modules, including our Angular Fire module and our `firebase-config` file. Since
    we have imported our `AngularFireStore` module, we will need to inject it into
    our `constructor` method and create an instance of it. We are creating methods
    for each of the actions for the comment's functionality. In the `getComments`
    method, we are retrieving all the data from the *comments *collection. In the `deleteComment`
    method, we are passing the ID of the comment we need to delete. In the `addComment`
    method, we are passing the data that we want to store in our collection. In the
    `updateComment` method, we are passing two parameters; the first is the ID of
    the comment we want to update, and the second is the updated data that we need
    to persist in the database.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析前面的代码。我们已经导入了所有必需的模块，包括我们的Angular Fire模块和我们的`firebase-config`文件。由于我们已经导入了`AngularFireStore`模块，我们需要将其注入到我们的`constructor`方法中并创建一个实例。我们为评论功能的每个操作创建了方法。在`getComments`方法中，我们正在从*comments*集合中检索所有数据。在`deleteComment`方法中，我们正在传递需要删除的评论的ID。在`addComment`方法中，我们正在传递我们想要存储在我们的集合中的数据。在`updateComment`方法中，我们传递了两个参数；第一个是我们想要更新的评论的ID，第二个是我们需要在数据库中持久保存的更新数据。
- en: You may wonder why we did not make any HTTP calls in these methods? The `AngularFireStore`
    module internally makes HTTP calls to the service and will authenticate and get
    account-specific information from the firebase config file.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么我们在这些方法中没有进行任何HTTP调用？`AngularFireStore`模块在内部对服务进行HTTP调用，并将从firebase配置文件中进行身份验证并获取特定于帐户的信息。
- en: In earlier sections, we learned how to send data from components to the service,
    right? Along the same lines, go ahead and try for comments functionality. That's
    your homework.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的章节中，我们学习了如何从组件发送数据到服务，对吧？沿着同样的思路，继续尝试评论功能。这是你的家庭作业。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: How do you feel? You should feel great and you should be proud of yourself!
    This chapter was a lot of work, but we're better off for having done it. It brought
    together all the aspects we have learned so far, such as forms, components, routing,
    services, and more.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你感觉如何？你应该感到很棒，应该为自己感到骄傲！这一章节是很多工作，但我们做完了会变得更好。它汇集了我们迄今为止学到的所有方面，如表单、组件、路由、服务等。
- en: For frontend developers, having a fake API setup in the local development environment
    always helps us to work independently without depending on backend developers
    or APIs. We learned about building fake APIs using the JSON server. We learned
    about the NoSQL document database, particularly the Firestore database provided
    by Google Cloud. We deep dived into Angular HTTP concepts and functionalities.
    We learned how to make HTTP POST, GET, PUT and DELETE calls. We also implemented
    our entire application's functional use cases using both the JSON Server and Firestore
    databases.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前端开发人员来说，在本地开发环境中设置一个虚拟API总是有助于我们独立工作，而不依赖后端开发人员或API。我们学习了如何使用JSON服务器构建虚拟API。我们学习了NoSQL文档数据库，特别是由谷歌云提供的Firestore数据库。我们深入研究了Angular
    HTTP的概念和功能。我们学会了如何进行HTTP POST、GET、PUT和DELETE调用。我们还使用JSON服务器和Firestore数据库实现了整个应用程序的功能用例。
- en: We have made tremendous progress so far. We are now capable of developing Angular
    applications end to end, utilizing all the superpowers that Angular provides,
    including forms, components, services, routing, and much more. At the end of this
    chapter, I am confident that we are able to bring together all the pieces of the
    Angular framework into a single working app.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们取得了巨大的进步。我们现在能够端到端地开发Angular应用程序，利用Angular提供的所有超能力，包括表单、组件、服务、路由等等。在本章结束时，我相信我们能够将Angular框架的所有部分整合到一个正常运行的应用程序中。
- en: Having a working application up and running is a good sign of progress. But
    the important factor in terms of judging the application is to look at the quality
    checks or unit tests.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个正常运行的应用程序是进步的一个好迹象。但在评估应用程序时的重要因素是查看质量检查或单元测试。
- en: In the next chapter, we are going to learn how to write unit tests to make sure
    we catch any defects early in the product development life cycle. Writing test
    scripts ensures quality and is a great sign of handling all use cases, including
    both the happy and negative paths of our application.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何编写单元测试，以确保在产品开发生命周期的早期发现任何缺陷。编写测试脚本可以确保质量，并且是处理应用程序的所有用例的一个很好的标志，包括应用程序的正常和负面路径。
