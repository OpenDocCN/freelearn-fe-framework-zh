- en: Routing and Lazy Loading
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由和懒加载
- en: Routing is essential to the solid usability flow of any app. Let's understand
    the key elements of routing configuration for a mobile app that takes advantage
    of all the flexibility Angular's router gives us.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 路由对于任何应用程序的稳定可用性流程至关重要。让我们了解一个利用Angular路由器所有灵活性的移动应用程序的路由配置的关键元素。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Configuring the Angular Router with a NativeScript app
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在NativeScript应用程序中配置Angular Router
- en: Lazy loading modules by route
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过路由懒加载模块
- en: Provide NSModuleFactoryLoader for Angular's NgModuleFactoryLoader
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Angular的`NgModuleFactoryLoader`提供`NSModuleFactoryLoader`
- en: Understanding how to use router-outlet in conjunction with page-router-outlet
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何结合使用`router-outlet`和`page-router-outlet`
- en: Learn how to share singleton services across multiple lazy loaded modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何在多个懒加载的模块之间共享单例服务
- en: Using auth guards to protect views that require valid authentication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用身份验证守卫来保护需要有效身份验证的视图
- en: Learn about `NavigationButton` to customize back mobile navigation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何自定义返回移动导航的`NavigationButton`
- en: Take advantage of our flexible routing setup by introducing late feature requirements
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过引入后期功能需求来利用我们灵活的路由设置
- en: Get your kicks on Route 66
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Route 66上享受乐趣
- en: 'As we begin our journey down this highway full of adventure, let''s start with
    a pit stop at our local service shop to ensure our vehicle is in tip-top shape.
    Take a turn into the root directory of `app` to build a new add-on to our vehicle''s
    engine: the routing module.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始在这条充满冒险的道路上旅行时，让我们先在我们的当地服务店停下来，确保我们的车辆处于最佳状态。转到`app`的根目录，为我们的车辆引擎构建一个新的附加组件：路由模块。
- en: 'Create a new routing module, `app/app.routing.ts`, with the following contents:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的路由模块，`app/app.routing.ts`，包含以下内容：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Defining the root `''''` path to redirect to a lazy loaded module provides
    a very flexible routing configuration, as you will see throughout this chapter.
    You will see a new module, `MixerModule`, which we will create momentarily. In
    fact, it will largely end up being what `AppComponent` is right now. Here''s a
    list of some advantages you gain with a route configuration similar to this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 定义根`''`路径以重定向到懒加载的模块提供了非常灵活的路由配置，正如您在本章中将会看到的。您将看到一个新模块，`MixerModule`，我们将立即创建它。实际上，它最终将变成现在的`AppComponent`。以下是一些使用类似此配置的路由配置所获得的优势列表：
- en: Keeps app startup time fast by eagerly loading only the bare minimum root module
    configuration, then rapidly loading the first route's module lazily
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过仅预先加载最基本的最小根模块配置，然后快速懒加载第一个路由的模块，保持应用程序启动时间快速
- en: Provides us with the ability to utilize `page-router-outlet` in conjunction
    with `router-outlet` for a combination of master/detail navigation as well as
    the `clearHistory` swap page navigation
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了使用`page-router-outlet`与`router-outlet`结合的能力，以实现主/详细导航以及`clearHistory`页面导航的组合
- en: Isolates routing configuration responsibility to the modules it concerns which
    scales well over time
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将路由配置责任隔离到相关的模块中，这样随着时间的推移可以很好地扩展
- en: Allows us to target different **start pages** easily in the future if we decide
    to change the initial page our users are presented with
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们决定更改用户最初看到的初始页面，我们可以轻松地针对不同的**起始页面**进行目标定位
- en: This uses `NativeScriptRoutingModule.forRoot(routes)`, since this should be
    considered the root of our app's routing configuration.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用`NativeScriptRoutingModule.forRoot(routes)`，因为这将被认为是我们的应用程序路由配置的根。
- en: We also export `NativeScriptRoutingModule`, since we will be importing this
    `AppRoutingModule` into our root `AppModule` in a moment. This makes the routing
    directives available to our root module's root component.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还导出`NativeScriptRoutingModule`，因为我们将在稍后导入这个`AppRoutingModule`到我们的根`AppModule`中。这使得路由指令对根模块的根组件可用。
- en: Providing NSModuleFactoryLoader for NgModuleFactoryLoader
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为`NgModuleFactoryLoader`提供NSModuleFactoryLoader
- en: By default, Angular's built-in module loader uses SystemJS; however, NativeScript provides
    an enhanced module loader called `NSModuleFactoryLoader`. Let's provide this in
    our main routing module to ensure all our modules are loaded with it instead of
    Angular's default module loader.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Angular的内置模块加载器使用SystemJS；然而，NativeScript提供了一个增强的模块加载器，称为`NSModuleFactoryLoader`。让我们在我们的主路由模块中提供这个加载器，以确保所有模块都使用它而不是Angular的默认模块加载器。
- en: 'Make the following modifications to `app/app.routing.ts`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对`app/app.routing.ts`进行以下修改：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, we can use the standard Angular lazy loading syntax via `loadChildren`
    by specifying the default `NgModuleFactoryLoader` but should instead use NativeScript's
    enhanced `NSModuleFactoryLoader`. We won't go into what `NSModuleFactoryLoader`
    provides in detail, since it is explained very well here: [https://www.nativescript.org/blog/optimizing-app-loading-time-with-angular-2-lazy-loading](https://www.nativescript.org/blog/optimizing-app-loading-time-with-angular-2-lazy-loading),
    and we have a lot more we want to cover in this book.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过 `loadChildren` 使用标准的 Angular 懒加载语法，通过指定默认的 `NgModuleFactoryLoader`，但应该使用
    NativeScript 的增强型 `NSModuleFactoryLoader`。我们不会详细介绍 `NSModuleFactoryLoader` 提供的内容，因为它在这里解释得很好：[https://www.nativescript.org/blog/optimizing-app-loading-time-with-angular-2-lazy-loading](https://www.nativescript.org/blog/optimizing-app-loading-time-with-angular-2-lazy-loading)，而且我们在这本书中还有更多内容要介绍。
- en: Excellent. With these upgrades in place, we can leave the service shop and continue
    on our journey down the highway. Let's move on to implementing our new routing
    setup.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 极好。有了这些升级，我们可以离开服务店，继续沿着高速公路前行。让我们继续实施我们的新路由设置。
- en: 'Open `app/app.component.html`; cut its contents to the clipboard and replace
    them with the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `app/app.component.html`；将其内容剪切到剪贴板，并用以下内容替换：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will be the base of our view level implementation. `page-router-outlet`
    allows any Component to insert itself in its place, whether it be a single flat route
    or one with child views of its own. It also allows other Component views to push
    onto the mobile nav stack, allowing master/detail mobile navigation with back
    history.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是视图级别实现的基础。`page-router-outlet` 允许任何组件插入其位置，无论是单个扁平路由还是具有自己子视图的路由。它还允许其他组件视图推送到移动导航堆栈，从而实现带有后退历史记录的主/详细移动导航。
- en: 'In order for this `page-router-outlet` directive to work, we need our root
    `AppModule` to import our new `AppRoutingModule`. We will also take this opportunity
    to remove `PlayerModule`, which was imported here before. Open `app/app.module.ts`
    and make the following modifications:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个 `page-router-outlet` 指令正常工作，我们需要我们的根 `AppModule` 导入新的 `AppRoutingModule`。我们还将利用这个机会移除之前在这里导入的
    `PlayerModule`。打开 `app/app.module.ts` 并进行以下修改：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating MixerModule
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 MixerModule
- en: 'This module really won''t be anything new, as it will serve as a relocation
    of what was previously our root component''s view. However, it will introduce
    an extra nicety: the ability to define its own inner routes.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块实际上不会有什么新内容，因为它将作为之前根组件视图的重新定位。然而，它将引入一个额外的优点：能够定义自己的内部路由。
- en: 'Create `app/modules/mixer/components/mixer.component.html` and paste the contents
    from where we had cut from the  `app.component.html`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `app/modules/mixer/components/mixer.component.html`，并将从 `app.component.html`
    中剪切的内容粘贴进去：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then create a matching `app/modules/mixer/components/mixer.component.ts`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '然后创建一个匹配的 `app/modules/mixer/components/mixer.component.ts`:'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, we will create `BaseComponent`, which will serve as the placeholder for
    not only the preceding `MixerComponent` but also any other child view components we
    may want to present in its place. For example, our mixer may want to allow users
    to pop a single track out of the mixer and into an isolated view to work with
    audio effects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建 `BaseComponent`，它将作为前面 `MixerComponent` 的占位符，以及我们可能希望在它的位置展示的任何其他子视图组件。例如，我们的混音器可能希望允许用户将单个轨道从混音器弹出，进入一个隔离的视图来处理音频效果。
- en: 'Create `app/modules/mixer/components/base.component.ts` with the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `app/modules/mixer/components/base.component.ts`，内容如下：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This provides a slot to insert any child routes our mixer configures, one of
    which is `MixerComponent` itself. Since the view is just a simple `router-outlet`,
    there's really no need to create a separate `templateUrl`, so we have just inlined
    it here.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一个插槽，可以插入我们的混音器配置的任何子路由，其中之一就是 `MixerComponent` 本身。由于视图只是一个简单的 `router-outlet`，实际上没有必要创建一个单独的
    `templateUrl`，所以我们在这里直接内联了它。
- en: 'Now we are ready to implement `MixerModule`; create `app/modules/mixer/mixer.module.ts`
    with the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备实现 `MixerModule`；创建 `app/modules/mixer/mixer.module.ts`，内容如下：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We have imported `PlayerModule` since the mixer uses components/widgets defined
    there (namely, `track-list` and `player-controls`). We are also utilizing the
    `NativeScriptRouterModule.forChild(routes)` method to indicate that these are
    specifically child routes. Our route configuration sets up the BaseComponent at
    the root `'' ''` path, which defines `''home''` as `MixerComponent`. If you recall,
    our app''s `AppRoutingModule` configured the root path of our app, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经导入了 `PlayerModule`，因为混合器使用了那里定义的组件/小部件（即 `track-list` 和 `player-controls`）。我们还在使用
    `NativeScriptRouterModule.forChild(routes)` 方法来指示这些是特定的子路由。我们的路由配置在根 `' '` 路径上设置了
    `BaseComponent`，它将 `'home'` 定义为 `MixerComponent`。如果您还记得，我们的应用 `AppRoutingModule`
    如下配置了应用的根路径：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will route directly to `MixerComponent` here, defined as `'home'`. We could
    easily direct the start page to a different view by pointing `redirectTo` at a
    different child view of our mixer if we wanted. Since `BaseComponent` is simply
    a `router-outlet`, any children defined underneath the root `' '` of our mixer's
    routes (seen by our the overall app's routes as `'/mixer'`) will insert directly
    in that view slot. If you were to run this right now, you should see the same
    start page we had before.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将直接路由到这里定义的 `MixerComponent`，即 `'home'`。如果我们想，我们可以轻松地将启动页面指向不同的视图，只需将 `redirectTo`
    指向我们的混合器中不同的子视图。由于 `BaseComponent` 仅仅是 `router-outlet`，任何定义在混合器路由根 `' '` 下的子组件（在我们的整体应用路由中看起来是
    `'/mixer'`）将直接插入该视图槽。如果您现在运行它，您应该看到我们之前相同的启动页面。
- en: Congrats! Your app's start time is now fast and you have lazily loaded your
    first module!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您应用的启动时间现在很快，您已经懒加载了第一个模块！
- en: 'However, there''s a couple of surprising things to note:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有几个令人惊讶的事情需要注意：
- en: You may notice a quick white flash before the start page appears (on iOS at
    least)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能会在启动页面出现之前注意到一个快速的白色闪烁（至少在iOS上是这样）
- en: You might notice the console log prints `` `Current user:` `` twice
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能会注意到控制台日志打印了两次 `` `当前用户:` ``。
- en: We will address each of these issues respectively.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分别解决这些问题。
- en: Remove the white flash after the splash screen before the start page displays.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动页面显示之前，移除启动屏幕后的白色闪烁。
- en: 'This is normal and is the result of the default Page background color which
    is white. To provide a seamless launch experience, open the `app/common.css` file
    and drop this global `Page` class definition to tint the background-color to the
    same as our `ActionBar` background-color:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正常的，这是默认页面背景颜色为白色造成的。为了提供无缝的启动体验，打开 `app/common.css` 文件，将全局 `Page` 类定义改为与我们的
    `ActionBar` 背景颜色相同：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, there will be no more white flash and the launch of the app will appear
    seamless.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将不再有白色闪烁，应用的启动将看起来无缝。
- en: The console log prints `` `Current user:` `` twice
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制台日志打印了两次 `` `当前用户:` ``。
- en: Angular's dependency injector is causing this due to lazy loading.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于懒加载，Angular 的依赖注入器导致了这个问题。
- en: 'This comes from `app/modules/core/services/auth.service.ts`, where we had a
    private `init` method that was being called from the service''s constructor:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这来自 `app/modules/core/services/auth.service.ts`，在那里我们有一个私有的 `init` 方法，它从服务的构造函数中被调用：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Wait! What?! Does this mean `AuthService` is getting constructed twice??!!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！这是什么意思？`AuthService` 被构建了两次吗？！
- en: Yes. It does. :(
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。它确实如此。 :(
- en: I can hear the sound of the car's wheels squealing, as you veer off this highway
    adventure into a ditch right about now. ;)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我能听到汽车轮胎的尖叫，你现在正偏离这条高速公路冒险进入沟渠。 ;)
- en: This is most certainly a huge problem, as we absolutely intended for `AuthService`
    to be a globally shared Singleton that could be injected anywhere and shared to
    provide the current authenticated state of our app.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这肯定是一个大问题，因为我们绝对希望 `AuthService` 是一个全局共享的单例，可以在任何地方注入并共享，以提供我们应用的当前认证状态。
- en: It is imperative we solve this right now, but let's first take a brief detour
    to understand why this is happening before looking at a solid solution.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须立即解决这个问题，但在寻找一个可靠的解决方案之前，让我们先简要了解一下为什么会发生这种情况。
- en: Understanding Angular's Dependency Injector when lazy loading modules
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在懒加载模块时理解 Angular 的依赖注入器
- en: 'Instead of restating the details, we will paraphrase directly from Angular''s
    official documentation (`https://angular.io/guide/ngmodule-faq#!#q-why-child-injector`),
    which explains this perfectly:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会重复细节，而是直接从 Angular 的官方文档（《https://angular.io/guide/ngmodule-faq#!#q-why-child-injector》）中转述，它完美地解释了这一点：
- en: Angular adds `@NgModule.providers` to the application root injector unless the
    module is lazy loaded. For a lazy-loaded module, Angular creates a child injector
    and adds the module's providers to the child injector.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非懒加载的模块，Angular会将`@NgModule.providers`添加到应用程序根注入器中。对于懒加载的模块，Angular创建一个子注入器并将模块的提供者添加到子注入器中。
- en: This means that a module behaves differently depending on whether it's loaded
    during application start or lazily loaded later. Neglecting that difference can
    lead to adverse consequences.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着模块的行为取决于它是与应用程序启动时一起加载还是稍后懒加载。忽视这种差异可能会导致不良后果。
- en: Why doesn't Angular add lazy-loaded providers to the app root injector as it
    does for eagerly loaded modules?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么Angular不将懒加载的提供者添加到应用程序根注入器，就像它对急切加载的模块所做的那样？
- en: The answer is grounded in a fundamental characteristic of the Angular dependency-injection
    system. An injector can add providers until it's first used. Once an injector
    starts creating and delivering services, its provider list is frozen; no new providers
    are allowed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个答案基于Angular依赖注入系统的基本特性。注入器可以添加提供者，直到它首次使用。一旦注入器开始创建和提供服务，其提供者列表就冻结了；不允许添加新的提供者。
- en: When an application starts, Angular first configures the root injector with
    the providers of all eagerly loaded modules before creating its first component
    and injecting any of the provided services. Once the application begins, the app
    root injector is closed to new providers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，Angular首先使用所有急切加载模块的提供者配置根注入器，然后创建其第一个组件并注入任何提供的服务。一旦应用程序开始，应用程序根注入器对新提供者已关闭。
- en: Time passes and application logic triggers lazy loading of a module. Angular
    must add the lazy-loaded module's providers to an injector somewhere. It can't
    add them to the app root injector because that injector is closed to new providers.
    So Angular creates a new child injector for the lazy-loaded module context.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 时间流逝，应用程序逻辑触发模块的懒加载。Angular必须在某个地方将懒加载模块的提供者添加到注入器中。它不能将它们添加到应用程序根注入器，因为该注入器对新提供者已关闭。因此，Angular为懒加载模块的上下文创建了一个新的子注入器。
- en: 'If we look at our root `AppModule`, we can see it imports `CoreModule`, which
    provides `AuthService`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看我们的根`AppModule`，我们可以看到它导入了`CoreModule`，该模块提供了`AuthService`：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we then look at `PlayerModule`, we can see it also imports `CoreModule`,
    since the components of `PlayerModule` make use of the `OrderByPipe` it declares
    as well as several of the services it provides (that is, `AuthService`, `LogService`,
    and `DialogService`):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`PlayerModule`，我们可以看到它也导入了`CoreModule`，因为`PlayerModule`的组件使用了它声明的`OrderByPipe`以及它提供的几个服务（即`AuthService`、`LogService`和`DialogService`）：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`PlayerModule` is now lazily loaded along with `MixerModule` due to our fancy
    new routing configuration. This causes Angular''s dependency injector to register
    a new child injector for our lazily loaded `MixerModule`, which brings along 
    `PlayerModule`, which also brings along its import of `CoreModule`, which defines
    those providers, including `AuthService`, `LogService`, and so on. When Angular registers
    `MixerModule`, it will register all the providers defined throughout the new module,
    including its imported modules with the new child injector, giving rise to the
    new instances of those services being constructed.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们新奇的路线配置，`PlayerModule`现在与`MixerModule`一起懒加载。这导致Angular的依赖注入器为我们的懒加载`MixerModule`注册了一个新的子注入器，它带来了`PlayerModule`，它也带来了其导入的`CoreModule`，该模块定义了那些提供者，包括`AuthService`、`LogService`等。当Angular注册`MixerModule`时，它将注册新模块中定义的所有提供者，包括其导入的模块，以及新的子注入器，从而产生了那些服务的新实例。
- en: 'Angular''s docs also provide a recommended setup for modules to remedy this
    situation, so let''s paraphrase again from `https://angular.io/guide/ngmodule-faq#!#q-module-recommendations`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的文档还提供了一种推荐的模块设置来解决这个问题，因此让我们再次从`https://angular.io/guide/ngmodule-faq#!#q-module-recommendations`中转述：
- en: SharedModule
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: SharedModule
- en: Create a `SharedModule` with the components, directives, and pipes that you
    use everywhere in your app. This module should consist entirely of declarations,
    most of them exported. The `SharedModule` may re-export other widget modules,
    such as `CommonModule`, `FormsModule`, and modules with the UI controls that you
    use most widely.The `SharedModule` should not have providers for reasons explained
    previously. Nor should any of its imported or re-exported modules have providers.
    If you deviate from this guideline, know what you're doing and why. Import the
    `SharedModule` in your feature modules, both those loaded when the app starts
    and those you lazily load later.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`SharedModule`，其中包含你在应用程序的每个地方都使用的组件、指令和管道。此模块应完全由声明组成，其中大多数都导出。`SharedModule`可以重新导出其他小部件模块，例如`CommonModule`、`FormsModule`以及包含你广泛使用的UI控制的模块。《SharedModule》不应有提供者，如前所述。也不应该有任何导入或重新导出的模块有提供者。如果你偏离了这个指南，要知道你在做什么以及为什么。在你的功能模块中导入`SharedModule`，包括在应用程序启动时加载的模块以及稍后懒加载的模块。
- en: Create a `CoreModule` with providers for the singleton services you load when
    the application starts.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`CoreModule`，其中包含在应用程序启动时加载的单例服务的提供者。
- en: Import `CoreModule` in the root `AppModule` only. Never import `CoreModule`
    in any other module.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在根`AppModule`中导入`CoreModule`。永远不要在其他任何模块中导入`CoreModule`。
- en: Consider making `CoreModule` a pure service module with no declarations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑将`CoreModule`制作成一个没有声明的纯服务模块。
- en: 'OK wow! That is an excellent recommendation. Particularly worthy of note is
    that very last line:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这是一个极好的建议。特别值得注意的是最后一行：
- en: Consider making CoreModule a pure service module with no declarations.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑将`CoreModule`制作成一个没有声明的纯服务模块。
- en: So, we already have `CoreModule`, which is great news, but we will want to make
    it a *pure service module with no declarations*. We will also *Import CoreModule
    in the root AppModule only. Never import CoreModule in any other module. *Then,
    we can create a new `SharedModule` to provide just *...**the components, directives,
    and pipes that [we] use everywhere in [our] app*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经有了一个`CoreModule`，这是一个好消息，但我们将希望将其制作成一个*没有声明的纯服务模块*。我们还将*仅在根`AppModule`中导入`CoreModule`。永远不要在其他任何模块中导入`CoreModule`。*然后，我们可以创建一个新的`SharedModule`，只为*...**我们在应用程序的每个地方都使用的组件、指令和管道*提供。
- en: 'Let''s create `app/modules/shared/shared.module.ts`, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`app/modules/shared/shared.module.ts`，如下所示：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For `PIPES`, we are just moving the pipes directory from `app/modules/core` to
    the `app/modules/shared` folder. Now,  `SharedModule` is the one we can be free
    to import across several different modules that need any pipes or future shared
    components/directives it may provide. It will not define any service providers
    as mentioned by this suggestion:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`PIPES`，我们只是将管道目录从`app/modules/core`移动到`app/modules/shared`文件夹。现在，`SharedModule`是我们可以在需要任何管道或未来共享组件/指令的多个不同模块中自由导入的模块。它将不会定义任何服务提供者，正如这个建议所提到的：
- en: '`SharedModule` should not have providers for reasons explained previously,
    nor should any of its imported or re-exported modules have providers.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedModule`不应有提供者，如前所述，也不应有任何导入或重新导出的模块有提供者。'
- en: 'We can then adjust `CoreModule` (located in `app/modules/core/core.module.ts`)
    as follows to be a pure service module with no declarations:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以按照以下方式调整`CoreModule`（位于`app/modules/core/core.module.ts`）以成为一个没有声明的纯服务模块：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This module now only defines providers as the collection containing `AuthService`,
    `DatabaseService`, `DialogService`, and `LogService`, all of which we created
    earlier in the book, and we want to ensure they are true Singletons used across
    our app, whether they are used in lazy loaded modules or not.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块现在仅定义提供者，即包含`AuthService`、`DatabaseService`、`DialogService`和`LogService`的集合，我们都在本书中较早创建过，我们想确保它们是跨我们的应用程序使用的真正的单例，无论它们是否在懒加载的模块中使用。
- en: Why do we use the `...PROVIDERS` spread notation instead of just assigning the
    collection directly?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们使用`...PROVIDERS`展开符号而不是直接分配集合？
- en: For scalability reasons. In the future, if we need to add an additional provider
    or override a provider, we can do so simply by just adding to the collection right
    in the module. The same goes for imports and exports.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可扩展性的原因。将来，如果我们需要添加一个额外的提供者或覆盖一个提供者，我们只需在模块中直接添加到集合中即可。对于导入和导出也是如此。
- en: We also take this opportunity to import some additional modules that we want
    to ensure are also used globally throughout the app. `NativeScriptModule`, `NativeScriptFormsModule`,
    and `NativeScriptHttpModule` are all essential modules that override certain web
    APIs from Angular's various providers out-of-the-box to enhance our app with native
    APIs. For example, instead of the app using `XMLHttpRequest` (which is a web API),
    it will use native HTTP APIs made available on both iOS and Android for the ultimate
    networking performance. We ensure we export these as well so our root module no
    longer needs to import them and can instead just import this `CoreModule`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还利用这个机会导入了一些我们想要确保在整个应用程序中全局使用的附加模块。`NativeScriptModule`、`NativeScriptFormsModule`
    和 `NativeScriptHttpModule` 都是基本模块，它们会覆盖 Angular 各个提供者中的某些 Web API，以增强我们的应用程序的本地
    API。例如，应用程序将使用在 iOS 和 Android 上可用的本地 HTTP API（而不是 Web API `XMLHttpRequest`），以实现最佳的网络性能。我们确保也导出这些模块，这样我们的根模块就不再需要导入它们，而是可以直接导入这个
    `CoreModule`。
- en: Lastly, we define a constructor that will help safeguard us in the future from accidentally
    importing this `CoreModule` into other lazily loaded modules.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了一个构造函数，这将帮助我们未来避免意外地将此 `CoreModule` 导入其他懒加载模块。
- en: We don't know yet if `PlayerService` provided by `PlayerModule` will be needed
    by `RecorderModule`, which also will be lazily loaded. If that comes up in the
    future, we can also refactor `PlayerService` into `CoreModule` to ensure it's
    a true Singleton shared across our entire app. For now, we will just leave it
    where it is as part of `PlayerModule`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还不知道 `PlayerModule` 提供的 `PlayerService` 是否会被 `RecorderModule` 需要，后者也将是懒加载的。如果将来出现这种情况，我们还可以将
    `PlayerService` 重构到 `CoreModule` 中，以确保它是我们在整个应用程序中共享的真正单例。目前，我们将其保留在 `PlayerModule`
    中作为一部分。
- en: Let's now make our final adjustments to our other modules based on what we have
    done to tighten everything down.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们根据我们所做的一切调整其他模块的最终设置。
- en: 'The `app/modules/player/player.module.ts` file should now look like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/modules/player/player.module.ts` 文件现在应该看起来像这样：'
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `app/modules/recorder/recorder.module.ts` file should now look like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/modules/recorder/recorder.module.ts` 文件现在应该看起来像这样：'
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice we now import `SharedModule` instead of `CoreModule`. This provides us
    with the ability to share directives, components, and pipes (essentially anything
    that would be in the declarations portion of the module) across the entire app
    by importing that `SharedModule`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们现在导入的是 `SharedModule` 而不是 `CoreModule`。这使我们能够通过导入那个 `SharedModule` 在整个应用程序中共享指令、组件和管道（本质上就是模块声明部分中的任何内容）。
- en: 'Our root `AppModule` at `app/app.module.ts` stays the same:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `app/app.module.ts` 中的根 `AppModule` 保持不变：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Any module (lazy loaded or not) can still inject any services that `CoreModule`
    provides, since the root `AppModule` now imports that `CoreModule`. This allows
    Angular's root injector to construct the services provided by `CoreModule` exactly
    once. Then, any time those services are injected anywhere (*in a lazily loaded
    module or not*), Angular will first ask the parent injector (in the case of a
    lazy loaded module, it would be the child injector) for that service and, if not
    found there, it will ask the next parent making its way to the root injector,
    eventually, where those Singletons are provided.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 任何模块（无论是懒加载还是非懒加载）都可以注入 `CoreModule` 提供的任何服务，因为根 `AppModule` 现在导入了那个 `CoreModule`。这允许
    Angular 的根注入器正好一次构建 `CoreModule` 提供的服务。然后，每当这些服务在任何地方注入（无论是懒加载模块还是其他地方），Angular
    首先会询问父注入器（在懒加载模块的情况下，将是子注入器）该服务，如果在那里找不到，它将询问下一个父注入器，最终到达根注入器，在那里提供这些单例。
- en: Well, we've had an amazing time in this desert of a town. Let's cruise on down
    the highway to the ultra secure Area 51, where modules can be locked away for
    years unless proper authorization is presented.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们在这个沙漠小镇度过了一段美好的时光。让我们沿着高速公路驶向超安全的51区，在那里模块可以被锁定数年，除非出示适当的授权。
- en: Creating AuthGuard for RecorderModule
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 RecorderModule 创建 AuthGuard
- en: One of our app's requirements is that recording features should be locked away
    and inaccessible until a user is authenticated. This provides us with the ability
    to have a user base and potentially introduce paid features down the road if we
    so desire.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的一个要求是，录制功能应该在用户认证之前被锁定并不可访问。这使我们能够拥有一个用户基础，并且如果将来我们希望的话，可以引入付费功能。
- en: Angular provides the ability to insert guards on our routes, which would only
    activate under certain conditions. This is exactly what we need to implement this
    feature requirement, since we have isolated the `'/record'` route to lazily load
    `RecorderModule`, which will contain all the recording features. We want to only
    allow access to that `'/record'` route if the user is authenticated.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 提供了在路由上插入守卫的能力，这只有在特定条件下才会激活。这正是我们实现这个功能需求所需要的，因为我们已经将 `'/record'` 路由隔离出来，以懒加载
    `RecorderModule`，它将包含所有录音功能。我们只想允许认证用户访问那个 `'/record'` 路由。
- en: 'Let''s create `app/guards/auth-guard.service.ts` in a new folder for scalability,
    since we could grow and create other guards as necessary here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在新文件夹中创建 `app/guards/auth-guard.service.ts`，以便于扩展，因为我们可能需要在这里创建其他必要的守卫：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We are able to take advantage of `BehaviorSubject` of `AuthService` to grab
    the latest value using `this.authService.authenticated$.getValue()` to determine
    the auth state. We use this to immediately activate the route via the `canActivate`
    hook (or load the module via the `canLoad` hook) if the user is authenticated.
    Otherwise, we display the login prompt via the service's method, but this time
    we wrap it in a reprompt sequence, which will continue to prompt on failed attempts
    until a successful authentication, or ignore it if the user cancels the prompt.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用 `AuthService` 的 `BehaviorSubject` 来获取最新值，使用 `this.authService.authenticated$.getValue()`
    来确定认证状态。我们使用这个值通过 `canActivate` 钩子（或通过 `canLoad` 钩子加载模块）立即激活路由，如果用户已认证。否则，我们通过服务的方法显示登录提示，但这次我们将其包裹在一个重新提示序列中，这样在失败尝试的情况下会继续提示，直到成功认证，或者如果用户取消提示则忽略。
- en: For the book, we aren't wiring up to any backend service to do any real authentication
    with a service provider. We will leave that part up to you in your own app. We
    will just be persisting the e-mail and password you enter into the login prompt
    as a valid user after doing very simple validation on the input.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书，我们不会连接到任何后端服务来进行任何真实的认证。我们将这部分留给你在自己的应用程序中完成。我们将在对输入进行非常简单的验证后，将你输入到登录提示中的电子邮件和密码持久化，作为有效用户。
- en: 'Notice that `AuthGuard` is an Injectable service like other services, so we
    will want to make sure it is added to the providers metadata of `AppRoutingModule`.
    We can now guard our route with the following highlighted modifications to `app/app.routing.ts`
    to use it:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`AuthGuard` 是一个像其他服务一样的可注入服务，因此我们想要确保它被添加到 `AppRoutingModule` 的提供者元数据中。现在我们可以通过以下突出显示的修改来保护我们的路由
    `app/app.routing.ts` 以使用它：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To try this out, we need to add child routes to our `RecorderModule`, since
    we have not done that yet. Open `app/modules/recorder/recorder.module.ts` and
    add the following highlighted sections:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这个功能，我们需要向我们的 `RecorderModule` 添加子路由，因为我们还没有这样做。打开 `app/modules/recorder/recorder.module.ts`
    并添加以下突出显示的部分：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We now have a proper child route configuration that will display the single
    `RecordComponent` when the user navigates to the `'/record'` path. We won't show
    the details of `RecordComponent`, as you can refer to the [Chapter 5](part0064.html#1T1400-289fe2426d594f99a90e4363b2c9c34d), *Routing
    and Lazy Loading* branch on the repo for the book. However, it is just a stubbed
    out component at this point inside `app/modules/recorder/components/record.component.html`,
    which just shows a simple label, so we can try this out.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了适当的子路由配置，当用户导航到 `'/record'` 路径时，将显示单个 `RecordComponent`。我们不会显示 `RecordComponent`
    的详细信息，你可以参考书籍的 [第5章](part0064.html#1T1400-289fe2426d594f99a90e4363b2c9c34d)，*路由和懒加载*
    分支上的代码库。然而，目前它只是 `app/modules/recorder/components/record.component.html` 中的一个占位符组件，只显示一个简单的标签，因此我们可以尝试这个功能。
- en: Lastly, we need a button that will route to our `'/record'` path. If we look
    back at our original sketch, we wanted a Record button to display in the top right
    corner of `ActionBar`, so let's implement that now.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个按钮来路由到我们的 `'/record'` 路径。如果我们回顾我们的原始草图，我们想在 `ActionBar` 的右上角显示一个记录按钮，所以现在让我们实现它。
- en: 'Open `app/modules/mixer/components/mixer.component.html` and add the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `app/modules/mixer/components/mixer.component.html` 并添加以下内容：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, if we were to run this in the iOS Simulator, we would notice that our
    Record button in `ActionBar` does not do anything! This is because `MixerModule`
    only imports the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们要在 iOS 模拟器中运行这个程序，我们会注意到 `ActionBar` 中的记录按钮没有任何反应！这是因为 `MixerModule`
    只导入了以下内容：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `NativeScriptRouterModule.forChild(routes)` method just configures the routes
    but does not make various routing directives, such as `nsRouterLink`, available
    to our components.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`NativeScriptRouterModule.forChild(routes)` 方法仅配置路由，但不会使各种路由指令，如 `nsRouterLink`，对我们的组件可用。'
- en: Since you learned earlier that `SharedModule` should be used to declare various
    directives, components, and pipes you want to share throughout your modules (lazy
    loaded or not), this is a perfect opportunity to take advantage of that.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你之前已经了解到应该使用 `SharedModule` 来声明你想要在模块中（无论是懒加载还是非懒加载）共享的各种指令、组件和管道，这是一个利用它的完美机会。
- en: 'Open `app/modules/shared/shared.module.ts` and make the following highlighted
    modifications:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `app/modules/shared/shared.module.ts` 并进行以下突出显示的修改：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, back in `MixerModule`, we can adjust the imports to use `SharedModule`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到 `MixerModule`，我们可以调整导入以使用 `SharedModule`：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This ensures all the directives exposed via `NativeScriptRouterModule` are now
    included and available for use in  `MixerModule` by utilizing our app-wide `SharedModule`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了通过 `NativeScriptRouterModule` 暴露的所有指令现在都包含在内，并且可以通过我们的全局 `SharedModule`
    在 `MixerModule` 中使用。
- en: 'Running our app again, we now see the login prompt when we tap the Record button
    in `ActionBar`. If we enter a properly formatted e-mail address and any password,
    it will persist the details, log us in, and display `RecordComponent` as follows
    on iOS:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行我们的应用，当我们点击 `ActionBar` 中的 Record 按钮时，现在会看到登录提示。如果我们输入格式正确的电子邮件地址和任何密码，它将持久保存详细信息，登录，并在
    iOS 上显示 `RecordComponent` 如下：
- en: '![](img/00022.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00022.jpeg)'
- en: You might notice something rather interesting. `ActionBar` changed from the
    background color we assigned via CSS and the button color now displays the default
    blue color. This is because `RecordComponent` does not define `ActionBar`; therefore,
    it is reverting to a default styled `ActionBar` with a default back button, which
    takes on the title of the page it just navigated from. The `'/record'` route is
    also using the ability of `page-router-outlet` to push components onto the mobile
    navigation stack. `RecordComponent` is animated into view while allowing the user
    to choose the top left button to navigate back (to pop the navigation history
    back one).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到一些相当有趣的事情。`ActionBar` 从我们通过 CSS 分配的背景颜色和按钮颜色现在显示默认的蓝色。这是因为 `RecordComponent`
    没有定义 `ActionBar`；因此，它正在回退到具有默认样式的 `ActionBar`，带有默认的返回按钮，该按钮承担了它刚刚导航离开的页面的标题。`'/record'`
    路由也正在使用 `page-router-outlet` 将组件推送到移动导航堆栈。`RecordComponent` 正在动画进入视图，同时允许用户选择左上角的按钮进行导航回退（弹出导航历史记录）。
- en: 'To fix `ActionBar`, let''s just add `ActionBar` to the `RecordComponent` view
    with a custom `NavigationButton` (a `NativeScript` view component simulating a
    mobile device''s default back navigation button). We can make the adjustments
    to `app/modules/record/components/record.component.html`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复 `ActionBar`，我们只需将 `ActionBar` 添加到 `RecordComponent` 视图中，并使用自定义的 `NavigationButton`（一个模拟移动设备默认返回导航按钮的
    `NativeScript` 视图组件）。我们可以在 `app/modules/record/components/record.component.html`
    中进行调整：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, this looks a lot better:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这看起来好多了：
- en: '![](img/00023.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00023.jpeg)'
- en: 'If we run this on Android and log in using any e-mail/password combo to persist
    a user, it will display the same `RecordComponent` view; however, you will notice
    another interesting detail. We have set up Android to display a standard back
    arrow system icon as `NavigationButton`, but when tapping that arrow, it does
    not do anything. Android''s default behavior relies on the device''s physical
    hardware back button next to the home button. However, we can provide a consistent
    experience by just adding a tap event to `NavigationButton`, so both iOS and Android
    react the same to tapping the back button. Make the following modification to
    the template:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 Android 上运行此应用并使用任何电子邮件/密码组合登录以持久保存用户，它将显示相同的 `RecordComponent` 视图；然而，你会注意到另一个有趣的细节。我们已经将
    Android 设置为显示标准的返回箭头系统图标作为 `NavigationButton`，但是当你点击那个箭头时，它不会做任何事情。Android 的默认行为依赖于位于主页按钮旁边的设备的物理硬件返回按钮。然而，我们可以通过仅为
    `NavigationButton` 添加点击事件来提供一致的用户体验，这样 iOS 和 Android 对返回按钮的点击反应相同。对模板进行以下修改：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we can implement the `back()` method in `app/modules/recorder/components/record.component.ts`
    using `NativeScript` for Angular''s `RouterExtensions` service:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在 `app/modules/recorder/components/record.component.ts` 中实现 `back()`
    方法，使用 Angular 的 `RouterExtensions` 服务：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, Android''s back button can be tapped to navigate back in addition to the
    hardware back button. iOS simply ignores the tap event handler, since it uses
    the default native behavior for `NavigationButton`. Pretty nice. Here is how `RecordComponent`
    looks on Android:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Android的返回按钮可以点击以返回，除了硬件返回按钮之外。iOS简单地忽略了点击事件处理程序，因为它使用 `NavigationButton`
    的默认原生行为。相当不错。以下是Android上的 `RecordComponent` 的样子：
- en: '![](img/00024.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00024.jpeg)'
- en: We will implement a nice recording view in upcoming chapters.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中实现一个不错的录音视图。
- en: We are surely cruising down Route 66 by now!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在肯定是在66号公路上飞驰了！
- en: We have implemented lazily loaded routes, provided `AuthGuard` to protect unauthorized
    use of our app's recording features, and learned a ton in the process. *However,
    we've just realized we are missing a very important feature late in the game*.
    We need a way to work on several different mixes over time. By default, our app
    may launch the last opened mix, but we would like to create new mixes (let's consider them
    **compositions**) and record entirely new mixes of individual tracks as separate
    compositions. We need a new route to display these compositions that we can name
    appropriately, so we can jump back and forth and work on different material.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了懒加载的路由，提供了 `AuthGuard` 来保护我们应用程序录音功能的未授权使用，并在过程中学到了很多。然而，我们刚刚意识到我们错过了一个非常重要的功能。我们需要一种方法来随着时间的推移处理多个不同的混音。默认情况下，我们的应用程序可能会启动最后打开的混音，但我们会想创建新的混音（让我们考虑它们为**作品**）并记录完全新的单独音轨的混音作为单独的作品。我们需要一个新的路由来显示这些作品，我们可以适当地命名它们，这样我们就可以来回跳转并处理不同的材料。
- en: Handling late feature requirements – managing compositions
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理晚期功能需求 - 管理作品
- en: It's time to deal with unexpected traffic along Route 66\. We have encountered
    a late feature requirement, realizing we need a way to manage any number of different
    mixes so we can work on different material over time. We could refer to each mix
    as a composition of audio tracks.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候处理66号公路上的意外交通了。我们遇到了一个晚期的功能需求，意识到我们需要一种方法来管理任意数量的不同混音，这样我们就可以随着时间的推移处理不同的材料。我们可以将每个混音称为音频音轨的组合。
- en: The good news is we have spent a reasonable amount of time engineering a scalable
    architecture and we are about to reap the fruits of our labor. Responding to late
    feature requirements now becomes a rather enjoyable Sunday stroll around the neighborhood.
    Let's show off the strengths of our app's architecture by taking a moment to work
    on this new feature.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是我们已经花费了相当多的时间来设计一个可扩展的架构，我们即将收获我们的劳动成果。现在应对晚期的功能需求变得像在邻里间的一次愉快的周日散步。让我们通过花点时间来开发这个新功能，来展示我们应用程序架构的优势。
- en: 'Let''s start by defining a new route for a new `MixListComponent` we will create.
    Open `app/modules/mixer/mixer.module.ts` and make the following highlighted modifications:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义我们将要创建的新 `MixListComponent` 的新路由开始。打开 `app/modules/mixer/mixer.module.ts`
    并进行以下突出显示的修改：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We are switching up our initial strategy of presenting `MixerComponent` as the
    home start page, but instead we are going to create a new `MixListComponent` in
    a moment to represent the `'home'` start page, which will be a listing of all
    the compositions we are working on. We could still have the `MixListComponent`
    auto select the last selected composition on the app launch for convenience later.
    We have now defined `MixerComponent` as a parameterized route, since it will always
    represent one of our working compositions identified by the `':id'` param routes,
    which will resolve to a route looking like `'/mixer/1'` for example. We have also
    imported `PROVIDERS`, which we will create in a moment.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在改变最初将 `MixerComponent` 作为主页的策略，相反，我们将在稍后创建一个新的 `MixListComponent` 来表示 `'home'`
    主页，这将是我们正在工作的所有作品的列表。我们仍然可以在应用程序启动时自动选择最后选择的组合，以便以后方便使用。我们已经将 `MixerComponent`
    定义为一个参数化路由，因为它将始终代表我们通过 `':id'` 参数路由标识的一个工作组合，例如解析为 `'/mixer/1'` 这样的路由。我们还导入了
    `PROVIDERS`，我们将在稍后创建它。
- en: 'Let''s modify `DatabaseService` provided by `CoreModule` to help provide a
    constant persistence key for our new data needs. We will want to persist user
    created compositions stored via this constant key name. Open `app/modules/core/services/database.service.ts`
    and make the following highlighted modifications:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改由 `CoreModule` 提供的 `DatabaseService`，以帮助我们为我们的新数据需求提供一个恒定的持久键。我们希望通过这个恒定键名持久化用户创建的作品。打开
    `app/modules/core/services/database.service.ts` 并进行以下突出显示的修改：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s also create a new data model to represent our compositions. Create `app/modules/shared/models/composition.model.ts`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再创建一个新的数据模型来表示我们的组合。创建 `app/modules/shared/models/composition.model.ts`：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, holding strong to our conventions, open `app/modules/shared/models/index.ts`
    and re-export this new model:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，坚持我们的约定，打开 `app/modules/shared/models/index.ts` 并重新导出这个新模型：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can now use this new model and database key in a new data service on which
    to build this new feature. Create `app/modules/mixer/services/mixer.service.ts`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这个新模型和数据库键在一个新的数据服务上构建这个新功能。创建 `app/modules/mixer/services/mixer.service.ts`：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We now have a service that will provide a list to bind our view to display the
    user's saved compositions. It also provides a way to add and edit compositions
    and seed the first app launch with a demo composition for a good first-time user
    experience (*we will add actual tracks to the demo later*).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个服务，它将提供一个列表来绑定我们的视图以显示用户的保存组合。它还提供了一种添加和编辑组合以及为首次启动应用提供演示组合的方法，以获得良好的首次用户体验（稍后我们将添加实际的轨道到演示中）。
- en: 'In keeping with our conventions, let''s also add `app/modules/mixer/services/index.ts`,
    as follows, which we illustrated being imported in `MixerModule` a moment ago:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们的约定，我们还可以添加 `app/modules/mixer/services/index.ts`，如下所示，这是我们之前在 `MixerModule`
    中导入的：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s now create `app/modules/mixer/components/mix-list.component.ts` to consume
    and project our new data service:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建 `app/modules/mixer/components/mix-list.component.ts` 来消费和投影我们的新数据服务：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And, for the view template, `app/modules/mixer/components/mix-list.component.html`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视图模板，`app/modules/mixer/components/mix-list.component.html`：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will render our list of `MixerService` user-saved compositions to the
    view and, when we first launch the app, it will have been seeded with one sample
    **Demo** composition preloaded with two recordings, so the user can play around.
    Here is how things look on iOS upon first launch now:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在视图中渲染 `MixerService` 用户保存的组合列表，并且当我们首次启动应用时，它将预加载一个包含两个录音的示例 **Demo** 组合，以便用户可以尝试。以下是首次启动后在
    iOS 上的样子：
- en: '![](img/00025.jpeg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00025.jpeg)'
- en: 'We can create new compositions and edit the names of existing ones. We can
    also tap the composition''s name to view  `MixerComponent`; however, we need to
    adjust the component to grab the route `'':id''` param and wire its view into
    the selected composition. Open `app/modules/mixer/components/mixer.component.ts`
    and add the highlighted sections:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建新的组合并编辑现有组合的名称。我们还可以点击组合的名称来查看 `MixerComponent`；然而，我们需要调整组件以获取路由 `':id'`
    参数并将其视图连接到选定的组合。打开 `app/modules/mixer/components/mixer.component.ts` 并添加突出显示的部分：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can inject Angular''s `ActivatedRoute` to subscribe to the route''s params,
    which give us access to `id`. Because it will come in as a String by default,
    we use `+params[''id'']` to convert it to a number when we locate the composition
    in our service''s list. We assign a local reference to the selected `composition`,
    which now allows us to bind to it in the view. While we''re at it, we will also
    add a Button labeled `List` for now in `ActionBar` to navigate back to our compositions
    (*later, we will implement font icons to display in their place*). Open `app/modules/mixer/components/mixer.component.html`
    and make the following highlighted modifications:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 Angular 的 `ActivatedRoute` 注入以订阅路由的参数，这使我们能够访问 `id`。由于它默认为字符串，我们在服务列表中定位组合时使用
    `+params['id']` 将其转换为数字。我们为选定的 `composition` 分配一个本地引用，这现在允许我们在视图中绑定到它。在此期间，我们还将向
    `ActionBar` 添加一个标签为 `List` 的按钮，以便导航回我们的组合（稍后，我们将实现字体图标来替换它们）。打开 `app/modules/mixer/components/mixer.component.html`
    并进行以下突出显示的修改：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This allows us to display the selected composition''s name in the title of
    `ActionBar` as well as pass its tracks to `track-list`. We need to add `Input` to
    `track-list`, so it renders the composition''s tracks instead of the dummy data
    it''s bound to now. Let''s open `app/modules/player/components/track-list/track-list.component.ts`
    and add an `Input`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们在 `ActionBar` 的标题中显示所选组合的名字，并将其轨道传递给 `track-list`。我们需要向 `track-list` 添加
    `Input`，以便它渲染组合的轨道，而不是现在绑定到的虚拟数据。让我们打开 `app/modules/player/components/track-list/track-list.component.ts`
    并添加一个 `Input`：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Previously, the `TrackListComponent` view was bound to `playerService.tracks`,
    so let's adjust the view template for the component at `app/modules/player/components/track-list/track-list.component.html`
    to bind to our new `Input`, which will now represent the tracks in the user's
    actual selected composition**:**
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，`TrackListComponent`视图绑定到`playerService.tracks`，所以让我们调整`app/modules/player/components/track-list/track-list.component.html`中的组件视图模板，以绑定到我们新的`Input`，它现在将代表用户实际选择的组合中的曲目**：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We now have the following sequence in our app to meet the needs of this late
    feature requirement and we did it in just a few pages of material here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在我们的应用程序中有了以下序列来满足这个后期功能需求，我们只在这里的几页材料中就完成了它：
- en: '![](img/00026.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00026.jpeg)'
- en: And it works exactly the same on Android while retaining its unique native characteristics.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上，它的工作方式完全相同，同时保留了其独特的本地特性。
- en: '![](img/00027.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00027.jpeg)'
- en: You might notice, however, that `ActionBar` on Android defaults to all `ActionItem`
    on the right-hand side. One last trick we want to show you quickly is the ability
    for platform-specific view templates. Oh and don't worry about those ugly Android
    buttons; we will integrate font icons later for those.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可能会注意到，在Android上，`ActionBar`默认将所有`ActionItem`放置在右侧。我们想快速向您展示的一个最后的技巧是平台特定视图模板的能力。哦，而且不用担心那些丑陋的Android按钮；我们稍后会集成字体图标。
- en: Create platform-specific view templates wherever you see fit. Doing so will
    help you dial views for each platform where necessary and make them highly maintainable.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在你认为合适的地方创建特定平台的视图模板。这样做将帮助你在必要时为每个平台调整视图，并使它们易于维护。
- en: 'Let''s create `app/modules/mixer/components/action-bar/action-bar.component.ts`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`app/modules/mixer/components/action-bar/action-bar.component.ts`：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can then create an iOS-specific view template: `app/modules/mixer/components/action-bar/action-bar.component.ios.html`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以创建一个特定于iOS的视图模板：`app/modules/mixer/components/action-bar/action-bar.component.ios.html`：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And an Android-specific view template: `app/modules/mixer/components/action-bar/action-bar.component.android.html`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以及一个特定于Android的视图模板：`app/modules/mixer/components/action-bar/action-bar.component.android.html`：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then we can use it in `app/modules/mixer/components/mixer.component.html`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在`app/modules/mixer/components/mixer.component.html`中使用它：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Just ensure you add it to the `COMPONENTS` of `MixerModule`  in `app/modules/mixer/mixer.module.ts`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 只确保您将其添加到`MixerModule`的`COMPONENTS`中，在`app/modules/mixer/mixer.module.ts`：
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Voila!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！
- en: '![](img/00028.jpeg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00028.jpeg)'
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have arrived at the end of this amazing journey down Route 66 and hope you
    feel as exhilarated as we do. This chapter has presented some interesting Angular
    concepts, including route configuration with lazy loaded modules to keep the app
    startup time fast; building a custom module loader using native file handling
    APIs; combining the flexibility of `router-outlet` with NativeScript's `page-router-outlet`;
    gaining control and understanding of Singleton services with lazy loaded modules;
    guarding routes dependent on authorized access; and working on late feature requirements
    to show off our wonderfully scalable app design.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了这条66号公路上的奇妙旅程的终点，希望您感到和我们一样兴奋。本章介绍了一些有趣的Angular概念，包括使用懒加载模块配置路由以保持应用程序启动时间快；使用本地文件处理API构建自定义模块加载器；将`router-outlet`的灵活性与NativeScript的`page-router-outlet`相结合；通过懒加载模块获得对单例服务的控制和理解；保护依赖于授权访问的路由；以及处理后期功能需求以展示我们出色的可扩展应用程序设计。
- en: 'This chapter rounds out the general usability flow of our app and, at this
    point, we are ready to venture into the core competency of our app: **Audio Handling
    via iOS and Android''s rich native APIs**.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本章总结了我们的应用程序的一般可用性流程，到目前为止，我们已经准备好进入我们应用程序的核心竞争力：**通过iOS和Android丰富的本地API进行音频处理**。
- en: Before delving into the thick of things, in the next chapter we will take a
    brief moment to inspect NativeScript's various `tns` command-line arguments to
    run our app to lock in a thorough education of the tool belt we can now bring
    to work.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨细节之前，在下一章中，我们将简要检查NativeScript的各种`tns`命令行参数，以运行我们的应用程序，并确保我们对现在可以带到工作中的工具带有一个全面的教育。
