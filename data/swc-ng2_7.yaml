- en: Chapter 7. Explaining Pipes and Communicating with RESTful Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。解释管道和与RESTful服务通信
- en: 'In the last chapter, we covered some very powerful features of the framework.
    However, we can go even deeper into the functionality of Angular''s forms module
    and router. In the next sections, we''ll explain how we can:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了框架的一些非常强大的功能。然而，我们可以更深入地了解Angular的表单模块和路由器的功能。在接下来的章节中，我们将解释如何：
- en: Develop model-driven forms.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发模型驱动的表单。
- en: Define parameterized routes.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义参数化路由。
- en: Define child routes.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义子路由。
- en: Use the `Http` module for communication with RESTful APIs.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Http`模块与RESTful API进行通信。
- en: Transform data with custom pipes.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义管道转换数据。
- en: We will explore all these concepts in the process of extending the functionality
    of the "Coders repository" application. At the beginning of the previous chapter,
    we mentioned that we're going to allow import of developers from GitHub. But before
    we implement this feature, let's extend the functionality of the form.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在扩展“Coders repository”应用程序的功能过程中探索所有这些概念。在上一章的开头，我们提到我们将允许从GitHub导入开发者。但在我们实现这个功能之前，让我们扩展表单的功能。
- en: Developing model-driven forms in Angular 2
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Angular 2中开发模型驱动的表单
- en: These are going to be the last steps in finishing the "Coders repository". You
    can build on top of the code at `ch6/ts/step-1/` (or `ch6/ts/step-2` depending
    on your previous work) in order to extend the application's functionality with
    the new concepts we're going to cover. The complete example is located at `ch7/ts/multi-page-model-driven`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将是完成“Coders repository”最后的步骤。您可以在`ch6/ts/step-1/`（或`ch6/ts/step-2`，具体取决于您之前的工作）的基础上构建，以便使用我们将要介绍的新概念扩展应用程序的功能。完整的示例位于`ch7/ts/multi-page-model-driven`。
- en: 'This is the result that we are going to achieve by the end of this section:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在本节结束时要实现的结果：
- en: '![Developing model-driven forms in Angular 2](../images/00030.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![在Angular 2中开发模型驱动的表单](../images/00030.jpeg)'
- en: 'In the preceding screenshot, there are the following two forms:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，有以下两种表单：
- en: 'A form for importing existing users from GitHub that contains:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于从GitHub导入现有用户的表单，其中包含：
- en: The input for the GitHub handle.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub句柄的输入。
- en: A checkbox that points out whether we want to import the developer from GitHub
    or enter it manually.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指出我们是否要从GitHub导入开发者或手动输入的复选框。
- en: A form for entering new users manually.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于手动输入新用户的表单。
- en: 'The second form looks exactly the way we finished it in the last section. However,
    this time, its definition looks a little bit different:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种形式看起来与我们在上一节中完成的方式完全一样。然而，这一次，它的定义看起来有点不同：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice that this time, we don't have the `submit` handler or the `#f="ngForm"`
    attribute. Instead, we use the `[ngFormModel]` attribute in order to bind to a
    property defined inside the component's controller. By using this attribute, we
    can bind to something called `ControlGroup`. As its name states, the `ControlGroup`
    class consists of a list of controls grouped together with the sets of validation
    rules associated with them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这一次，我们没有`submit`处理程序或`#f="ngForm"`属性。相反，我们使用`[ngFormModel]`属性来绑定到组件控制器内定义的属性。通过使用这个属性，我们可以绑定到一个叫做`ControlGroup`的东西。正如其名称所示，`ControlGroup`类包括一组控件以及与它们关联的验证规则集。
- en: 'We need to use a similar declaration to *import a developer* form. However,
    this time, we will provide a different value of the `[ngFormModel]` attribute,
    since we are going to define a different control group in the component''s controller.
    Place the following snippet above the form we introduced earlier:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用类似的声明来*导入开发者*表单。然而，这一次，我们将提供不同的`[ngFormModel]`属性值，因为我们将在组件控制器中定义一个不同的控件组。将以下片段放在我们之前介绍的表单上方：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s declare the `importDevForm` and `addDevForm` properties in the
    component''s controller:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在组件的控制器中声明`importDevForm`和`addDevForm`属性：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Initially, we imported the `ControlGroup` class from the `angular2` module and,
    later, declared the required properties in the controller. Let's also notice that
    we have one additional parameter of the constructor of `AddDeveloper` called `fb`
    of the type `FormBuilder`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们从`angular2`模块中导入了`ControlGroup`类，然后在控制器中声明了所需的属性。让我们还注意到`AddDeveloper`的构造函数有一个额外的参数叫做`fb`，类型为`FormBuilder`。
- en: '`FormBuilder` provides a programmable API for the definition of `ControlGroups`
    where we can attach validation behavior to each control in the group. Let''s use
    the `FormBulder` instance for the initialization of the `importDevForm` and `addDevForm`
    properties:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormBuilder`提供了一个可编程的API，用于定义`ControlGroups`，在这里我们可以为组中的每个控件附加验证行为。让我们使用`FormBulder`实例来初始化`importDevForm`和`addDevForm`属性：'
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `FormBuilder` instance has a method called `group` that allows us to define
    properties, such as the default values and the validators for the individual controls
    in a given form.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormBuilder`实例有一个名为`group`的方法，允许我们定义给定表单中各个控件的默认值和验证器等属性。'
- en: 'According to the preceding snippet, `importDevForm` has two fields that we
    introduced earlier: `githubHandle` and `fetchFromGitHub`. We declared that the
    value of the `githubHandle` control is required and set the default value of the
    control `fetchFromGitHub` to `false`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的片段，`importDevForm`有两个我们之前介绍的字段：`githubHandle`和`fetchFromGitHub`。我们声明`githubHandle`控件的值是必填的，并将`fetchFromGitHub`控件的默认值设置为`false`。
- en: 'In the second form, `addDevForm`, we declare four controls. For the `realName`
    control as the default value, we set the empty string and use `Validators.requred`
    in order to introduce validation behavior (which is exactly what we did for the
    `githubHandle` control). As a validator for the e-mail input, we will use the
    `validateEmail` function and set its initial value to an empty string. The `validateEmail`
    function used for validation is the one we defined in the previous chapter:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个表单`addDevForm`中，我们声明了四个控件。对于`realName`控件的默认值，我们将其设置为空字符串，并使用`Validators.requred`来引入验证行为（这正是我们为`githubHandle`控件所做的）。作为电子邮件输入的验证器，我们将使用`validateEmail`函数，并将其初始值设置为空字符串。用于验证的`validateEmail`函数是我们在上一章中定义的：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The last two controls we define here are the `technology` control, which value
    is required and has an empty string as its initial value, and the `popular` control
    with its initial value set to `false`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义的最后两个控件是`technology`控件，其值是必填的，初始值为空字符串，以及`popular`控件，其初始值设置为`false`。
- en: Using composition of control validators
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用控件验证器的组合
- en: 'We took a look at how we can apply a single validator to form controls. However,
    in some applications, the domain may require more complex validation logic. For
    example, if we want to apply both the required and the `validateEmail` validators
    to the e-mail control, we should do the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了一下如何将单个验证器应用于表单控件。然而，在一些应用程序中，领域可能需要更复杂的验证逻辑。例如，如果我们想要将必填和`validateEmail`验证器都应用于电子邮件控件，我们应该这样做：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `compose` method of the `Validators` object accepts as an argument an array
    of validators and returns a new validator. The new validator's behavior is going
    to be a composition of the logic defined in the individual validators passed as
    an argument, and they are going to be applied in the same order as they were introduced
    in the array.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Validators`对象的`compose`方法接受一个验证器数组作为参数，并返回一个新的验证器。新的验证器的行为将是由作为参数传递的各个验证器中定义的逻辑组成，并且它们将按照它们在数组中被引入的顺序应用。'
- en: The property names in the object literal passed to the `group` method should
    match with the values that we set to the `ngControl` attributes of the inputs
    in the template.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`group`方法的对象文字的属性名称应与我们在模板中为输入设置的`ngControl`属性的值相匹配。
- en: 'This is the complete template of `importDevForm`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`importDevForm`的完整模板：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding template, you can notice that once the flag submitted has the
    value `true`, so the form will be hidden from the user. Next to the first input
    element, we set the value of the `ngControl` attribute to `githubHandle`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模板中，您可以注意到一旦提交的标志具有值`true`，表单将对用户隐藏。在第一个输入元素旁边，我们将`ngControl`属性的值设置为`githubHandle`。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the value of the `ngControl` attribute of the given input element
    must match the name we used for its corresponding control declaration in the definition
    of `ControlGroup` within the component's controller.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，给定输入元素的`ngControl`属性的值必须与我们在组件控制器中的`ControlGroup`定义中用于相应控件声明的名称相匹配。
- en: 'With regard to the `githubHandle` control, we also set the disabled attribute
    to equal the result of the evaluation of the expression: `!fetchFromGitHub`. This
    way, when the `fetchFromGitHub` checkbox is unchecked, the `githubHandle` control
    will be disabled. Similarly, in case of the example in the previous sections,
    we used the `ControlErrors` component we defined previously. This time, we set
    a single error with the message **The GitHub handle is required**.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`githubHandle`控件，我们还将`disabled`属性设置为等于表达式评估的结果：`!fetchFromGitHub`。这样，当`fetchFromGitHub`复选框未被选中时，`githubHandle`控件将被禁用。类似地，在前几节的示例中，我们使用了先前定义的`ControlErrors`组件。这次，我们设置了一个带有消息**GitHub句柄是必需的**的单个错误。
- en: The markup for the form `addDevForm` looks quite similar, so we won't describe
    it in detail here. If you're not completely sure of how to approach developing
    it, you can take a look at the complete implementation at `ch7/ts/multi-page-model-driven/add_developer.html`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`addDevForm`表单的标记看起来非常相似，因此我们不会在这里详细描述它。如果您对如何开发它的方法不是完全确定，可以查看`ch7/ts/multi-page-model-driven/add_developer.html`中的完整实现。'
- en: 'The last part of the template we''re going to take a look at is the `Submit`
    button:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要查看的模板的最后部分是`Submit`按钮：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Clicking on the button will invoke the `addDeveloper` method defined in the
    component's controller. In the expression set as value of the `[disabled]` attribute,
    we initially check which form is selected by using the value of the property bound
    to the checkbox, that is, we verify whether the user wants to add a new developer
    or import an existing one from GitHub. If the first option is selected (that is,
    if the checkbox is not checked), we verify whether the `ControlGroup` for adding
    a new developer is valid. If it is valid, then the button will be enabled, otherwise
    it will be disabled. We will do the same in cases when the user has checked the
    checkbox for importing a developer from GitHub.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 单击按钮将调用组件控制器中定义的`addDeveloper`方法。在`[disabled]`属性的值设置为的表达式中，我们最初通过使用与复选框绑定的属性的值来检查选择了哪种表单，也就是说，我们验证用户是否想要添加新开发人员或从GitHub导入现有开发人员。如果选择了第一个选项（即，如果复选框未被选中），我们将验证添加新开发人员的`ControlGroup`是否有效。如果有效，则按钮将启用，否则将禁用。当用户选中复选框以从GitHub导入开发人员时，我们也会执行相同的操作。
- en: Exploring the HTTP module of Angular
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Angular的HTTP模块
- en: Now, after we develop the forms for both importing existing and adding new developers,
    it is the time to implement the logic behind it in the controller of the component.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们为导入现有开发人员和添加新开发人员开发表单之后，是时候在组件的控制器中实现其背后的逻辑了。
- en: 'For this purpose, we need to communicate with the GitHub API. Although we can
    do this directly from the component''s controller, by doing it this way, we can
    couple it with the RESTful API of GitHub. In order to enforce further separation
    of concerns, we can extract the logic for communication with GitHub into a separate
    service called `GitHubGateway`. Open a file called `github_gateway.ts` and enter
    the following content:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要与GitHub API进行通信。虽然我们可以直接从组件的控制器中进行此操作，但通过这种方式，我们可以将其与GitHub的RESTful API耦合在一起。为了进一步分离关注点，我们可以将与GitHub通信的逻辑提取到一个名为`GitHubGateway`的单独服务中。打开一个名为`github_gateway.ts`的文件，并输入以下内容：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Initially, we imported the `Http` class from the `angular2/http` module. All
    the HTTP-related functionality is externalized and is outside the Angular's core.
    Since `GitHubGateway` accepts a dependency, which needs to be injected through
    the DI mechanism of the framework, we will decorate it with the `@Injectable`
    decorator.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们从`angular2/http`模块导入了`Http`类。所有与HTTP相关的功能都是外部化的，并且在Angular的核心之外。由于`GitHubGateway`接受一个依赖项，需要通过框架的DI机制进行注入，因此我们将其装饰为`@Injectable`装饰器。
- en: The only functionality from the GitHub's API we're going to use is the one for
    fetching users, so we will define a single method called `getUser`. As an argument,
    it accepts the GitHub handle of the developer.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的GitHub的API中唯一的功能是用于获取用户的功能，因此我们将定义一个名为`getUser`的单个方法。作为参数，它接受开发者的GitHub句柄。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that if you make more than 60 requests per day to the GitHub's API, you
    might get the error **GitHub API Rate limit exceeded**. This is due to the rate
    limits for requests without a GitHub API token. For further information, visit
    [https://github.com/blog/1509-personal-api-tokens](https://github.com/blog/1509-personal-api-tokens).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您每天对GitHub的API发出超过60个请求，您可能会收到错误**GitHub API速率限制已超出**。这是由于没有GitHub API令牌的请求的速率限制。有关更多信息，请访问[https://github.com/blog/1509-personal-api-tokens](https://github.com/blog/1509-personal-api-tokens)。
- en: Inside the `getUser` method, we use the instance of the `Http` service that
    we've received in the `constructor` function. The `Http` service's API stays as
    close to the HTML5 fetch API as possible. However, there are a couple of differences.
    The most significant one of them is that at the moment of writing this content,
    all the methods of the `Http` instances return `Observables` instead of `Promises`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getUser`方法中，我们使用了在`constructor`函数中收到的`Http`服务的实例。`Http`服务的API尽可能接近HTML5 fetch
    API。但是，有一些区别。其中最重要的一个是，在撰写本内容时，`Http`实例的所有方法都返回`Observables`而不是`Promises`。
- en: 'The `Http` service instances have the following API:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Http`服务实例具有以下API：'
- en: '`request(url: string | Request, options: RequestOptionsArgs)`: Makes a request
    to the specified URL. The request can be configured using `RequestOptionsArgs`:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request(url: string | Request, options: RequestOptionsArgs)`: 对指定的URL进行请求。可以使用`RequestOptionsArgs`配置请求：'
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`get(url: string, options?: RequestOptionsArgs)`: Makes a get request to the
    specified URL. The request headers and other options can be configured using the
    second argument.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(url: string, options?: RequestOptionsArgs)`: 对指定的URL进行get请求。可以使用第二个参数配置请求头和其他选项。'
- en: '`post(url: string, options?: RequestOptionsArgs)`: Makes a post request to
    the specified URL. The request body, headers, and other options can be configured
    using the second argument.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post(url: string, options?: RequestOptionsArgs)`: 对指定的URL进行post请求。可以使用第二个参数配置请求体、头和其他选项。'
- en: '`put(url: string, options?: RequestOptionsArgs)`: Makes a put request to the
    specified URL. The request headers and other options can be configured using the
    second argument.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put(url: string, options?: RequestOptionsArgs)`: 对指定的URL进行put请求。可以使用第二个参数配置请求头和其他选项。'
- en: '`patch(url: string, options?: RequestOptionsArgs)`: Makes a patch request to
    the specified URL. The request headers and other options can be configured using
    the second argument.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`patch(url: string, options?: RequestOptionsArgs)`: 发送一个 patch 请求到指定的 URL。请求头和其他选项可以使用第二个参数进行配置。'
- en: '`delete(url: string, options?: RequestOptionsArgs)`: Makes a delete request
    to the specified URL. The request headers and other options can be configured
    using the second argument.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete(url: string, options?: RequestOptionsArgs)`: 发送一个 delete 请求到指定的 URL。请求头和其他选项可以使用第二个参数进行配置。'
- en: '`head(url: string, options?: RequestOptionsArgs)`: Makes a head request to
    the specified URL. The request headers and other options can be configured using
    the second argument.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`head(url: string, options?: RequestOptionsArgs)`: 发送一个 head 请求到指定的 URL。请求头和其他选项可以使用第二个参数进行配置。'
- en: Using Angular's HTTP module
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Angular 的 HTTP 模块
- en: 'Now, let''s implement the logic for importing existing users from GitHub! Open
    the file `ch6/ts/step-2/add_developer.ts` and enter the following imports:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现从 GitHub 导入现有用户的逻辑！打开文件 `ch6/ts/step-2/add_developer.ts` 并输入以下导入：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add `HTTP_PROVIDERS` and `GitHubGateway` to the list of providers of the `AddDeveloper`
    component:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `HTTP_PROVIDERS` 和 `GitHubGateway` 添加到 `AddDeveloper` 组件的提供者列表中：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As the next step, we have to include the following parameters in the constructor
    of the class:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，我们必须在类的构造函数中包含以下参数：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This way, the `AddDeveloper` class' instances will have a private property called
    `githubAPI`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`AddDeveloper` 类的实例将有一个名为 `githubAPI` 的私有属性。
- en: The only thing left is to implement the `addDeveloper` method and allow the
    user to import existing developers by using the `GitHubGateway` instance.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下的就是实现 `addDeveloper` 方法，并允许用户使用 `GitHubGateway` 实例导入现有的开发者。
- en: 'Once the user presses the **Add** button, we need to check whether we need
    to import an existing GitHub user or add a new developer. For this purpose, we
    can use the value of the `fetchFromGitHub` control:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 用户按下 **添加** 按钮后，我们需要检查是否需要导入现有的 GitHub 用户或添加新的开发者。为此，我们可以使用 `fetchFromGitHub`
    控件的值：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If it has a truthy value, then we can invoke the `getUser` method of the `githubAPI`
    property and pass the value of the `githubHandle` control as an argument:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它有一个真值，那么我们可以调用 `githubAPI` 属性的 `getUser` 方法，并将 `githubHandle` 控件的值作为参数传递：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `getUser` method, we delegate the call to the `Http` service''s `get`
    method, which returns an observable. In order to get the result that the observable
    is going to push, we need to pass a callback to its `subscribe` method:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `getUser` 方法中，我们将调用 `Http` 服务的 `get` 方法，该方法返回一个可观察对象。为了获取可观察对象即将推送的结果，我们需要向其
    `subscribe` 方法传递一个回调函数：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding snippet, we first establish the HTTP `get` request. After this,
    we'll get the observable that, in general cases, will emit a series of values
    (in this case, only a single one—the response of the request) and map them to
    the JSON representation of their bodies. If the response fails or its body is
    not a valid JSON string, then we will get an error.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们首先建立了 HTTP `get` 请求。之后，我们将得到一个可观察对象，通常会发出一系列的值（在这种情况下，只有一个值—请求的响应），并将它们映射到它们的主体的
    JSON 表示。如果响应失败或其主体不是有效的 JSON 字符串，那么我们将得到一个错误。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that in order to reduce the size of RxJS, Angular''s core team has included
    only its core. In order to use the methods `map` and `catch`, you need to add
    the following imports at `add_developer.ts`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了减小 RxJS 的体积，Angular 的核心团队只包含了它的核心部分。为了使用 `map` 和 `catch` 方法，您需要在 `add_developer.ts`
    中添加以下导入：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now let''s implement the body of the subscribe callback:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现订阅回调的主体：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding example, we set the properties of a new `Developer` instance.
    Here, we established the mapping between the object returned from GitHub's API
    and the developer's representation in our application. We also considered a developer
    as popular if she or he has above 1,000 followers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们设置了一个新的`Developer`实例的属性。在这里，我们建立了从GitHub的API返回的对象与我们应用程序中开发者表示之间的映射。我们还认为如果开发者拥有超过1,000个粉丝，那么他或她就是受欢迎的。
- en: The entire implementation of the `addDeveloper` method can be found at `ch7/ts/multi-page-model-driven/add_developer.ts`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`addDeveloper`方法的整个实现可以在`ch7/ts/multi-page-model-driven/add_developer.ts`中找到。'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In order to handle failed requests, we can use the `catch` method of the observable
    instances:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理失败的请求，我们可以使用可观察实例的`catch`方法：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Defining parameterized views
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义参数化视图
- en: 'As the next step, let''s dedicate a special page for each developer. Inside
    of it, we''ll be able to take a detailed look at his or her profile. Once the
    user clicks on the name of any of the developers on the home page of the application,
    he or she should be redirected to a page with a detailed profile of the selected
    developer. The end result will look as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，让我们为每个开发者专门创建一个页面。在这个页面内，我们将能够详细查看他或她的个人资料。一旦用户在应用程序的主页上点击任何开发者的名称，他或她应该被重定向到一个包含所选开发者详细资料的页面。最终结果将如下所示：
- en: '![Defining parameterized views](../images/00031.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![定义参数化视图](../images/00031.jpeg)'
- en: 'In order to do this, we need to pass an identifier of the developer to the
    component that shows developer''s detailed profile. Open `app.ts` and add the
    following import:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要将开发者的标识符传递给显示开发者详细资料的组件。打开`app.ts`并添加以下导入：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We haven''t developed the `DeveloperDetails` component yet, so if you run the
    application, you will get an error. We will define the component in the next paragraph,
    but before this, let''s alter the `@RouteConfig` definition of the `App` component:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有开发`DeveloperDetails`组件，所以如果运行应用程序，你会得到一个错误。我们将在下一段定义组件，但在此之前，让我们修改`App`组件的`@RouteConfig`定义：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We added a single route with the `DeveloperDetails` component associated with
    it, and as an alias, we used the string `"DeveloperDetails"`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个单一路由，与`DeveloperDetails`组件相关联，并且作为别名，我们使用了字符串`"DeveloperDetails"`。
- en: The value of the `component` property is a reference to the constructor of the
    component, which should handle the given route. Once the source code of the application
    gets minified for production, the component name may differ from the one we've
    entered. This will create problems when referencing the route within the templates
    using the `routerLink` directive. In order to prevent this from happening, the
    core team introduced the `name` property that, in this case, equals to the name
    of the controller.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`component`属性的值是对组件构造函数的引用，该构造函数应该处理给定的路由。一旦应用程序的源代码在生产中被压缩，组件名称可能会与我们输入的名称不同。这将在使用`routerLink`指令在模板中引用路由时创建问题。为了防止这种情况发生，核心团队引入了`name`属性，在这种情况下，它等于控制器的名称。'
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Although in all the examples so far, we set the alias of the route to be the
    same as the name of the component''s controller, this is not required. This convention
    is used for simplicity, since it could be confusing to introduce two names: one
    for pointing to the route and another one for the controller associated with the
    given route.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管到目前为止的所有示例中，我们将路由的别名设置为与组件控制器的名称相同，但这并不是必需的。这个约定是为了简单起见，因为引入两个名称可能会令人困惑：一个用于指向路由，另一个用于与给定路由相关联的控制器。
- en: In the `path` property, we declare that the route has a single parameter called
    `id`, and with `"..."`, we hint the framework that this route will have nested
    routes inside of it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`path`属性中，我们声明该路由有一个名为`id`的单个参数，并用`"..."`提示框架，这个路由将在其中有嵌套路由。
- en: 'Now, let''s pass the `id` of the current developer as a parameter to the `routerLink`
    directive. Open `home.html` in your working directory and replace the table cell
    where we display the developer''s `realName` property with the following content:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将当前开发人员的`id`作为参数传递给`routerLink`指令。在你的工作目录中打开`home.html`，并用以下内容替换我们显示开发人员的`realName`属性的表格单元格：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The value of the `routerLink` directive is an array with the following three
    elements:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`routerLink`指令的值是一个包含以下三个元素的数组：'
- en: '`''/DeveloperDetails''`: A string that shows the root route'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''/DeveloperDetails''`：显示根路由的字符串'
- en: '`{ ''id'': dev.id }`: An object literal that declares the route parameters'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ ''id'': dev.id }`：声明路由参数的对象文字'
- en: '`''DeveloperBasicInfo''`: The name of a route that shows which component within
    the nested route in the component with the alias `DeveloperDetails` should be
    rendered'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''DeveloperBasicInfo''`：显示在组件别名为`DeveloperDetails`的嵌套路由中应该呈现的组件的路由名称'
- en: Defining nested routes
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义嵌套路由
- en: 'Now let''s jump to the `DeveloperDetails` definition. In your working directory,
    create a file called `developer_details.ts` and enter the following content:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们跳到`DeveloperDetails`的定义。在你的工作目录中，创建一个名为`developer_details.ts`的文件，并输入以下内容：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding snippet, we defined a component with controller called `DeveloperDetails`.
    You can notice that within the controller's constructor, through the DI mechanism
    of Angular 2, we injected a parameter associated with the `RouteParams` token.
    The injected parameter provides us access to the parameters visible by the current
    route. We can access them using the `params` property of the injected object and
    access the target parameter using its name as a key.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们定义了一个带有控制器的组件`DeveloperDetails`。您可以注意到，在控制器的构造函数中，通过Angular 2的DI机制，我们注入了与`RouteParams`令牌相关联的参数。注入的参数为我们提供了访问当前路由可见参数的权限。我们可以使用注入对象的`params`属性访问它们，并使用参数的名称作为键来访问目标参数。
- en: 'Since the parameter we got from `routeParams.params[''id'']` is a string, we
    need to parse it to a number in order to get the developer associated with the
    given route. Now let''s define the routes associated with `DeveloperDetails`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们从`routeParams.params['id']`得到的参数是一个字符串，我们需要将其解析为数字，以便获取与给定路由相关联的开发人员。现在让我们定义与`DeveloperDetails`相关的路由：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding snippet, there is nothing new for us. The route definition
    follows the exact same rules we're already familiar with.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，对我们来说没有什么新的。路由定义遵循我们已经熟悉的完全相同的规则。
- en: 'Now, to the template of the component, let''s add links associated with the
    individual nested routes:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在组件的模板中添加与各个嵌套路由相关的链接：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Within the template, we declare two relative to the current path links. The
    first one points to `DeveloperBaiscInfo`, which is the name of the first route
    defined within `@RouteConfig` of the `DeveloperDetails` component, and respectively,
    the second one points to `DeveloperAdvancedInfo`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，我们声明了两个相对于当前路径的链接。第一个指向`DeveloperBaiscInfo`，这是在`DeveloperDetails`组件的`@RouteConfig`中定义的第一个路由的名称，相应地，第二个指向`DeveloperAdvancedInfo`。
- en: 'Since the implementations of both the components are quite similar, let''s
    take a look only at `DeveloperBasicInfo`. As an exercise, you can develop the
    second one or take a look at its implementation at `ch7/ts/multi-page-model-driven/developer_advanced_info.ts`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个组件的实现非常相似，让我们只看一下`DeveloperBasicInfo`。作为练习，您可以开发第二个，或者查看`ch7/ts/multi-page-model-driven/developer_advanced_info.ts`中的实现：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding snippet, we injected the parent component combining the `@Inject`
    parameter decorator with `@Host`. Inside of `@Inject`, we use `forwardRef`, since
    we have a circular dependency between the packages `developer_basic_info` and
    `developer_details` (inside `developer_basic_info`, we import `developer_details`,
    and within `developer_details`, we import `developer_basic_info`).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们结合了`@Inject`参数装饰器和`@Host`来注入父组件。在`@Inject`内部，我们使用`forwardRef`，因为在`developer_basic_info`和`developer_details`之间存在循环依赖（在`developer_basic_info`中，我们导入`developer_details`，而在`developer_details`中，我们导入`developer_basic_info`）。
- en: We need a reference to the instance of the parent component in order to get
    the instance of the current developer corresponding to the selected route.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个对父组件实例的引用，以便获取与所选路由对应的当前开发者的实例。
- en: Transforming data with pipes
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管道转换数据
- en: It is time for the last building block that Angular 2 provides for the development
    of applications that we haven't covered in detail yet—the pipes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是Angular 2为我们提供的最后一个构建块的时间，这是我们尚未详细介绍的管道。
- en: 'Just like the filters in AngularJS 1.x, pipes are intended to encapsulate all
    the data-transformation logic. Let''s take a look at the template of the home
    page of the application we just developed:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 就像AngularJS 1.x中的过滤器一样，管道旨在封装所有数据转换逻辑。让我们来看看我们刚刚开发的应用程序的主页模板：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding snippet, depending on the value of the `popular` property,
    we showed different data using the `NgSwitch` and `NgSwitchThen` directives. Although
    this works, it is redundant.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，根据`popular`属性的值，我们使用`NgSwitch`和`NgSwitchThen`指令显示了不同的数据。虽然这样可以工作，但是有些冗余。
- en: Developing stateless pipes
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发无状态管道
- en: 'Let''s develop a pipe that transforms the value of the `popular` property and
    uses it in the place of `NgSwitch` and `NgSwitchThen`. The pipe will accept three
    arguments: a value that should be transformed, a string that should be displayed
    when the value is truthy, and another string that should be displayed in case
    of a falsy value.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开发一个管道，转换`popular`属性的值并在`NgSwitch`和`NgSwitchThen`的位置使用它。该管道将接受三个参数：应该被转换的值，当值为真时应该显示的字符串，以及在值为假时应该显示的另一个字符串。
- en: 'With the use of an Angular 2 custom pipe, we will be able to simplify the template
    to:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Angular 2自定义管道，我们将能够简化模板为：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We could even use emojis:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用表情符号：
- en: '[PRE28]ts'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE28]ts'
- en: We apply the pipe to the value the same way we do in AngularJS 1.x. The arguments
    we pass to the pipe should be separated by the colon (`:`) symbol.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将管道应用到值上的方式与在AngularJS 1.x中的方式相同。我们传递给管道的参数应该用冒号（`:`）符号分隔。
- en: 'In order to develop an Angular 2 pipe, we need the following imports:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发一个Angular 2管道，我们需要以下导入：
- en: '[PRE29]ts'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE29]ts'
- en: 'The `Pipe` decorator can be used for adding metadata to the class that implements
    the data transformation logic. The `PipeTransform` is an interface with a single
    method called transform:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pipe`装饰器可用于向实现数据转换逻辑的类添加元数据。`PipeTransform`是一个具有名为transform的单个方法的接口：'
- en: '[PRE30]ts'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE30]ts'
- en: The preceding snippet is the entire implementation of `BooleanPipe`. The name
    of the pipe determines the way it should be used in templates.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段是`BooleanPipe`的整个实现。管道的名称决定了它在模板中的使用方式。
- en: 'The last thing we need to do before being able to use the pipe is to add the
    `BooleanPipe` class to the list of pipes used by the `Home` component (`BooleanPipe`
    already holds the metadata attached to it by the `@Pipe` decorator, so its name
    is attached to it):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在能够使用管道之前，我们需要做的最后一件事是将`BooleanPipe`类添加到`Home`组件使用的管道列表中（`BooleanPipe`已经通过`@Pipe`装饰器附加了元数据，所以它的名称已经附加到它上面）：
- en: '[PRE31]ts'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE31]ts'
- en: Using Angular's built-in pipes
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Angular内置的管道
- en: 'Angular 2 provides the following set of built-in pipes:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2提供了以下一组内置管道：
- en: '`CurrencyPipe`: This pipe is used for formatting currency data. As an argument,
    it accepts the abbreviation of the currency type (that is, `"EUR"`, `"USD"`, and
    so on). It can be used in the following way:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CurrencyPipe`：此管道用于格式化货币数据。作为参数，它接受货币类型的缩写（即`"EUR"`，`"USD"`等）。可以按以下方式使用：'
- en: '[PRE32]ts'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE32]ts'
- en: '`DatePipe`: This pipe is used for the transformation of dates. It can be used
    in the following way:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DatePipe`：此管道用于日期转换。可以按以下方式使用：'
- en: '[PRE33]ts'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE33]ts'
- en: '`DecimalPipe`: This pipe is used for transformation of decimal numbers. The
    argument it accepts is of the following form: `"{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}"`.
    It can be used in the following way:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DecimalPipe`：此管道用于转换十进制数。它接受的参数形式为`"{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}"`。可以按以下方式使用：'
- en: '[PRE34]ts'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE34]ts'
- en: '`JsonPipe`: This transforms a JavaScript object into a JSON string. It can
    be used in the following way:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JsonPipe`：这将JavaScript对象转换为JSON字符串。可以按以下方式使用：'
- en: '[PRE35]ts'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE35]ts'
- en: '`LowerCasePipe`: This transforms a string to lowercase. It can be used in the
    following way:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LowerCasePipe`：将字符串转换为小写。可以按以下方式使用：'
- en: '[PRE36]ts'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE36]ts'
- en: '`UpperCasePipe`: This transforms a string to uppercase. It can be used in the
    following way:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpperCasePipe`：将字符串转换为大写。可以按以下方式使用：'
- en: '[PRE37]ts'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE37]ts'
- en: '`PercentPipe`: This transforms a number into a percentage. It can be used in
    the following way:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PercentPipe`：这将数字转换为百分比。可以按以下方式使用：'
- en: '[PRE38]ts'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE38]ts'
- en: '`SlicePipe`: This returns a slice of an array. The pipe accepts the start and
    the end indexes of the slice. It can be used in the following way:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SlicePipe`：返回数组的一个切片。该管道接受切片的起始和结束索引。可以按以下方式使用：'
- en: '[PRE39]ts'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE39]ts'
- en: '`AsyncPipe`: This is a `stateful` pipe that accepts an observable or a promise.
    We''re going to take a look at it at the end of the chapter.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncPipe`：这是一个`有状态`管道，接受一个observable或一个promise。我们将在本章末尾看一下它。'
- en: Developing stateful pipes
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发有状态的管道
- en: There was one common thing between all the pipes mentioned earlier—all of them
    return exactly the same result each time we apply them to the same value and pass
    them the same set of arguments. Such pipes that hold the referentially transparency
    property are called pure pipes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的所有管道之间有一个共同点——每次将它们应用于相同的值并传递相同的参数集时，它们都会返回完全相同的结果。具有引用透明属性的这种管道称为纯管道。
- en: 'The `@Pipe` decorator accepts an object literal of the following type: `{ name:
    string, pure?: boolean }`, where the default value for the `pure` property is
    `true`. This means that when we decorate a given class using the `@Pipe` decorator,
    we can declare whether we want the pipe it implements the logic for to be either
    stateful or stateless. The pure property is important, because in case the pipe
    is stateless (that is, it returns the same result in case it is applied over the
    same value with the same set of arguments), the change detection can be optimized.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Pipe`装饰器接受以下类型的对象文字：`{ name: string, pure?: boolean }`，其中`pure`属性的默认值为`true`。这意味着当我们使用`@Pipe`装饰器装饰给定的类时，我们可以声明我们希望管道实现的逻辑是有状态的还是无状态的。纯属性很重要，因为如果管道是无状态的（即，对于相同的值和相同的参数集合应用时返回相同的结果），则可以优化变更检测。'
- en: Now let's build a stateful pipe! Our pipe will make an HTTP `get` request to
    a JSON API. For this purpose, we will use the `angular2/http` module.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们构建一个有状态的管道！我们的管道将向JSON API发出HTTP `get`请求。为此，我们将使用`angular2/http`模块。
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that having business logic in a pipe is not considered as a best practice.
    This type of logic should be extracted into a service. The example here is for
    learning purposes only.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在管道中具有业务逻辑并不被认为是最佳实践。这种类型的逻辑应该被提取到一个服务中。这里的示例仅用于学习目的。
- en: 'In this case, the pipe needs to hold a different state depending on the status
    of the request (that is, whether it is pending or completed). We will use the
    pipe in the following way:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，管道需要根据请求的状态（即是否挂起或已完成）来保持不同的状态。我们将以以下方式使用管道：
- en: '[PRE40]ts'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE40]ts'
- en: This way, we apply the `fetchJson` pipe over the URL, and once we have response
    from the remote service and the promise for the request has been resolved, we
    can apply the `json` pipe over the object we got from the response. The example
    also shows how we can chain pipes with Angular 2.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以在URL上应用`fetchJson`管道，一旦我们从远程服务获得响应并且请求的承诺已经解决，我们就可以在响应中得到的对象上应用`json`管道。该示例还展示了如何在Angular
    2中链式应用管道。
- en: 'Similarly, in case of the previous example, for the development of a stateless
    pipe, we have to import `Pipe` and `PipeTransform`. However, this time, because
    of the HTTP request functionality, we also need to import the `Http` and `Response`
    classes from the `''angular2/http''` module:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在前面的示例中，为了开发一个无状态的管道，我们需要导入`Pipe`和`PipeTransform`。然而，这次，由于HTTP请求功能，我们还需要从`'angular2/http'`模块导入`Http`和`Response`类：
- en: '[PRE41]ts'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE41]ts'
- en: 'Each time it happens to apply the `fetchJson` pipe to a different argument
    compared to the one we got in the previous invocation, we need to make a new HTTP
    `get` request. This means that as the state of the pipe, we need to keep at least
    the values of the response of the remote service and the last URL:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 每当将`fetchJson`管道应用于与上一次调用中获得的参数不同的参数时，我们需要发起新的HTTP `get`请求。这意味着作为管道的状态，我们至少需要保留远程服务响应的值和最后的URL：
- en: '[PRE42]ts'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE42]ts'
- en: 'The only piece of logic left is the `transform` method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的逻辑只有`transform`方法：
- en: '[PRE43]ts'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE43]ts'
- en: Inside of it, we initially compared the URL passed as an argument with the one
    we currently keep a reference to. If they are different, we initiate a new HTTP
    `get` request using the local instance of the `Http` class, which was passed to
    the `constructor` function. Once the request is completed, we parse the response
    to JSON and set the `data` property to the result.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，我们最初将作为参数传递的URL与我们当前保留引用的URL进行比较。如果它们不同，我们将使用传递给`constructor`函数的`Http`类的本地实例发起新的HTTP
    `get`请求。一旦请求完成，我们将将响应解析为JSON，并将`data`属性设置为结果。
- en: Now, let's suppose the pipe has started an `Http get` request, and before it
    is completed, the change detection mechanism invokes the pipe again. In this case,
    we will compare the `prevUrl` property with the `url` parameter. In case they
    are the same, we won't perform a new `http` request, and we will immediately return
    the value of the `data` property. In case `prevUrl` has a different value from
    `url`, we will start a new request.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设管道已经开始了`Http get`请求，在请求完成之前，变更检测机制再次调用了管道。在这种情况下，我们将比较`prevUrl`属性和`url`参数。如果它们相同，我们将不会执行新的`http`请求，并立即返回`data`属性的值。如果`prevUrl`的值与`url`不同，我们将开始一个新的请求。
- en: Using stateful pipes
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用有状态的管道
- en: 'Now let''s use the pipe that we developed! The application that we are going
    to implement provides to the user a text input and a button. Once the user enters
    a value in the text input and presses the button, below the text input will appear
    the avatar corresponding to the GitHub user, as shown in the following screenshot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用我们开发的管道！我们将要实现的应用程序为用户提供了一个文本输入和一个按钮。一旦用户在文本输入中输入一个值并按下按钮，文本输入框下方将显示与GitHub用户对应的头像，如下面的屏幕截图所示：
- en: '![Using stateful pipes](../images/00032.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![使用有状态的管道](../images/00032.jpeg)'
- en: 'Now, let''s develop a sample component, which will allow us to enter the GitHub
    user''s handle:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开发一个示例组件，允许我们输入GitHub用户的句柄：
- en: '[PRE44]ts'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE44]ts'
- en: 'In the preceding example, we added `FetchJsonPipe` used by the `App` component.
    The only thing left is to show the GitHub avatar of the user. We can easily achieve
    this by altering the template of the preceding component with the following `img`
    declaration:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们添加了`FetchJsonPipe`用于`App`组件。唯一剩下的就是显示用户的GitHub头像。我们可以通过修改前面组件的模板来轻松实现这一点，使用以下`img`声明：
- en: '[PRE45]ts'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE45]ts'
- en: Initially, we appended the GitHub handle to the base URL used for fetching users
    from the API. Later, we applied the `fetchJson` filter over it, and from the returned
    result, we got the `avatar_url` property.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们将GitHub句柄附加到用于从API获取用户的基本URL上。后来，我们对其应用了`fetchJson`过滤器，并从返回的结果中得到了`avatar_url`属性。
- en: Note
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although the previous example works, it is unnatural to have business logic
    in your pipes. It will be far better to implement the logic for communication
    with the GitHub's API into a service or, at least, invoke the `get` method of
    the instance of the `Http` class in a component.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的例子可以工作，但在管道中放入业务逻辑是不自然的。最好将与GitHub API通信的逻辑实现为一个服务，或者至少在组件中调用`Http`类的实例的`get`方法。
- en: Using Angular's AsyncPipe
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Angular的AsyncPipe
- en: 'Angular''s `AsyncPipe` transform method accepts as an argument an observable
    or a promise. Once the argument pushes a value (that is, the promise has been
    resolved or the `subscribe` callback of the observable is invoked with a value),
    `AsyncPipe` will return it as a result. Let''s take a look at the following example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的`AsyncPipe`转换方法接受observable或promise作为参数。一旦参数推送一个值（即promise已解析或observable的`subscribe`回调被调用并传递了一个值），`AsyncPipe`将返回它作为结果。让我们看看以下例子：
- en: '[PRE46]ts'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE46]ts'
- en: 'Here, we defined an Angular 2 component, which has two properties: `greetingPromise`
    of the type `Promise<string>` and `resolve` of the type `Function`. We initialized
    the `greetingPromise` property with a new `Promise<string>` instance, and as value
    of the `resolve` property, we set the `resolve` callback of the `promise`.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个Angular 2组件，它有两个属性：`greetingPromise`的类型为`Promise<string>`，`resolve`的类型为`Function`。我们用一个新的`Promise<string>`实例初始化了`greetingPromise`属性，并将`resolve`属性的值设置为`promise`的`resolve`回调函数。
- en: In the constructor of the class, we start a timeout with the duration of 3,000
    ms, and inside of its callback, we resolve the promise. Once the promise is resolved,
    the value of the expression `{{ greetingPromise | async }}` will be evaluated
    to the string `Foobar!`. The end result that the user will see on the screen is
    the text **Hello Foobar!**.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的构造函数中，我们启动了一个持续3,000毫秒的超时，在其回调函数中，我们解析了promise。一旦promise被解析，表达式`{{ greetingPromise
    | async }}`的值将被评估为字符串`Foobar!`。用户在屏幕上看到的最终结果是文本**Hello Foobar!**。
- en: The `async` pipe is extremely powerful when we combine it with an `Http` request
    or together with an observable, which pushes a sequence of values.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`async`管道与`Http`请求或与推送值序列的observable结合使用时，`async`管道非常强大。
- en: Using AsyncPipe with observables
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用observables和AsyncPipe
- en: 'We''re already familiar with the concept of observables from the previous chapters.
    We can say that an observable object allows us to subscribe to the emission of
    a sequence of values, for instance:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了前几章中的observables的概念。我们可以说，observable对象允许我们订阅一系列值的发射，例如：
- en: '[PRE47]ts'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE47]ts'
- en: 'Once we subscribe to the observable, it will start emitting values each second,
    which are going to be printed in the console. Let''s combine this snippet with
    the component''s definition and implement a simple timer:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们订阅了可观察对象，它将开始每秒发出值，这些值将被打印在控制台中。让我们将这段代码与组件的定义结合起来，实现一个简单的计时器：
- en: '[PRE48]ts'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE48]ts'
- en: 'The only thing left in order to be able to use the timer component is to add
    its template. We can subscribe to the observable directly in our template by using
    the `async` pipe:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用计时器组件，唯一剩下的事情就是添加它的模板。我们可以通过使用`async`管道直接在我们的模板中订阅可观察对象：
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This way, each second we will get the new value emitted by the observable, and
    the `date` pipe will transform it into a readable form.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每秒我们将得到可观察对象发出的新值，并且`date`管道将把它转换成可读形式。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a deep dive into the Angular 2 forms by developing
    a model-driven one and combining it with the `http` module in order to be able
    to add developers to our repository. We took a look at some advanced features
    of the new component-based router and saw how we can use and develop our customized
    stateful and stateless pipes.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入研究了Angular 2表单，通过开发一个模型驱动的表单，并将其与`http`模块结合起来，以便能够将开发人员添加到我们的存储库中。我们看了一些新的基于组件的路由的高级特性，并了解了如何使用和开发我们定制的有状态和无状态管道。
- en: The next chapter will be dedicated to how we can make our Angular 2 applications
    SEO-friendly by taking advantage of the server-side rendering that the module
    universal provides. We will also take a look at angular-cli and the other tools
    that make our experience as developers better.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将致力于我们如何使我们的Angular 2应用程序对SEO友好，通过利用模块universal提供的服务器端渲染。我们还将看看angular-cli和其他工具，这些工具使我们作为开发人员的体验更好。
