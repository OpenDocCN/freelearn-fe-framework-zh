<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer090">
<h1 class="chapterNumber">12</h1>
<h1 class="chapterTitle" id="_idParaDest-183">Server-Side Rendering</h1>
<p class="normal">The next step in building React applications is learning how <strong class="keyWord">server-side rendering</strong> (<strong class="keyWord">SSR</strong>) works <a id="_idIndexMarker447"/>and what benefits it can give us. By <a id="_idIndexMarker448"/>implementing SSR, we can create <strong class="keyWord">universal applications</strong> that are better for <strong class="keyWord">search engine optimization</strong> (<strong class="keyWord">SEO</strong>) and enable knowledge-sharing <a id="_idIndexMarker449"/>between the frontend and the backend. They can also improve the perceived speed of a web application, which usually leads to increased conversions. However, applying SSR to a React application comes at a cost, and we should think carefully about whether we need it or not.</p>
<p class="normal">In this chapter, you will see how to set up a server-side-rendered application, and by the end of the relevant sections, you will be able to build a universal application and understand the pros and cons of the technique.</p>
<p class="normal">In this chapter, we will cover the following topics:</p>
<ul>
<li class="bulletList">Understanding what a universal application is</li>
<li class="bulletList">Figuring out the reasons why we may want to enable SSR</li>
<li class="bulletList">Creating a simple static server-side-rendered application with React</li>
<li class="bulletList">Adding data fetching to server-side rendering and understanding concepts such as dehydration/hydration</li>
<li class="bulletList">Using <strong class="keyWord">Next.js</strong> by Zeit to easily create a React application that runs on both the server and the client</li>
</ul>
<h1 class="heading-1" id="_idParaDest-184">Technical requirements</h1>
<p class="normal">To complete this chapter, you will require the following:</p>
<ul>
<li class="bulletList">Node.js 19+</li>
<li class="bulletList">Visual Studio Code</li>
</ul>
<p class="normal">You can find the code for this chapter in the book’s GitHub repository at <a href="https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fouth-Edition/tree/main/Chapter12"><span class="url">https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fouth-Edition/tree/main/Chapter12</span></a>. </p>
<h1 class="heading-1" id="_idParaDest-185">Understanding universal applications</h1>
<p class="normal">A universal application is an application that can run both on the server side and client side with the <a id="_idIndexMarker450"/>same code. In this section, we will look at the reasons why we should consider making our applications universal, and we will learn how React components can be easily rendered on the server side.</p>
<p class="normal">When we talk about JavaScript web applications, we usually think of client-side code that lives in the browser. The way they usually work is that the server returns an empty HTML page with a script tag to load the application. When the application is ready, it manipulates the DOM inside the browser to show the UI and interact with users. This has been the case for the last few years, and it is still the way to go for a huge number of applications.</p>
<p class="normal">In this book, we have seen how easy it is to create applications using React components and how they work within the browser. What we have not seen yet is how React can render the same components on the server, giving us a powerful feature called SSR.</p>
<p class="normal">Before going into the details, let’s try to understand what it means to create applications that render both on the server and the client. For years, we used to have completely different applications for the server and client: for example, a Django application to render the views on the server, and some JavaScript frameworks, such as Backbone or jQuery, on the client. Those separate apps usually had to be maintained by two teams of developers with different skill sets. If you needed to share data between the server-side-rendered pages and the client-side application, you could inject some variables into a script tag. Using two different languages and platforms, there was no way to share common information, such as models or views, between the different sides of the application.</p>
<p class="normal">Since Node.js was released in 2009, JavaScript has gained a lot of attention and popularity on the server side as well, thanks to web application frameworks such as <strong class="keyWord">Express</strong>. </p>
<p class="normal">Using the same language on both sides not only makes it easy for developers to reuse their <a id="_idIndexMarker451"/>knowledge but also enables different ways of sharing code between the server and the client.</p>
<p class="normal">With React in particular, the concept of isomorphic web applications became very popular within the JavaScript community. Writing an <strong class="keyWord">isomorphic application</strong> means building <a id="_idIndexMarker452"/>an application that looks the same on the server and the client. The fact that the same language is used to write the two applications means that a big part of the logic can be shared, which opens many possibilities. This makes the code base easier to reason about and avoids unnecessary duplication.</p>
<p class="normal">React brings the concept a step forward, giving us a simple API to render our components on the server and transparently applying all the logic needed to make the page interactive (for example, event handlers) on the browser.</p>
<p class="normal">The term <em class="italic">isomorphic</em> does not fit in this scenario because, in the case of React, the applications are the <a id="_idIndexMarker453"/>same, and that is why one of the creators of React Router, Michael Jackson, proposed a more meaningful name for this pattern: <strong class="keyWord">universal</strong>. </p>
<p class="normal">Before we delve into the specific reasons for implementing universal server-side rendering, let us take a moment to pause and ensure that we possess a solid understanding of when and why this feature might be necessary for our application.</p>
<h1 class="heading-1" id="_idParaDest-186">Reasons for implementing SSR</h1>
<p class="normal">SSR is a great feature, but <a id="_idIndexMarker454"/>we should not jump into it just for <a id="_idIndexMarker455"/>the sake of it. We should have a real, solid reason to start using it.</p>
<p class="normal">Adopting SSR without a clear purpose can introduce unwarranted complexities and issues into your application. The intricacies of SSR can complicate aspects such as managing states, data fetching, and routing, among others. Additionally, SSR puts an increased load on the server as it is responsible for rendering HTML for each request. If not carefully optimized, this can result in slower response times and higher server costs.</p>
<p class="normal">Moreover, the added complexity that SSR brings to an application can slow down the development process, complicate debugging, and require maintenance of specific tools <a id="_idIndexMarker456"/>and configurations. Furthermore, if your application does not have a significant amount of public content, the SEO benefits that often drive the adoption of SSR may not be substantial.</p>
<p class="normal">In essence, while SSR can offer benefits, it is crucial to implement it with a clear understanding of its trade-offs. Carefully assess your application’s needs and consider the advantages against the potential disadvantages before deciding to adopt SSR.</p>
<h2 class="heading-2" id="_idParaDest-187">Implementing SEO</h2>
<p class="normal">One of the main reasons why we may want to render our applications on the server side is SEO. If <a id="_idIndexMarker457"/>we serve an empty HTML skeleton to the crawlers of the main search engines, they <a id="_idIndexMarker458"/>are not able to extract any meaningful information from it. Nowadays, Google seems to be able to run JavaScript, but there are some limitations, and SEO is often a critical aspect of our businesses.</p>
<p class="normal">For years, we used to write two applications: an SSR one for the crawlers, and another one to be used on the client side by users. We used to do that because SSR applications could not give us the level of interactivity users expect, while client-side applications did not get indexed by search engines.</p>
<p class="normal">Maintaining and supporting two applications is difficult and makes the code base less flexible and less prone to changes. Luckily, with React, we can render our components on the server side and serve the content of our applications to the crawlers in such a way that it is easy for them to understand and index the content.</p>
<p class="normal">This is great, not only for SEO but also for social sharing services. Platforms such as Facebook or Twitter give us a way of defining the content of the snippets that is shown when our pages are shared.</p>
<p class="normal">For example, using Open Graph, we can tell Facebook that, for a particular page, we want a certain image to be shown and a particular title to be used as the title of the post. It is almost impossible to do that using client-side-only applications because the engine that extracts the information from the pages uses the markup returned by the server.</p>
<p class="normal">If our server <a id="_idIndexMarker459"/>returns an empty <a id="_idIndexMarker460"/>HTML structure for all the URLs, the result is that when the pages are shared on social networks, the snippets of our web application are empty as well, which affects their virality.</p>
<h2 class="heading-2" id="_idParaDest-188">A common code base</h2>
<p class="normal">Utilizing JavaScript on both the client and server sides of an application offers numerous benefits. Firstly, it <a id="_idIndexMarker461"/>simplifies matters by employing the same language across all components. This streamlines the process of maintaining a well-functioning system and facilitates knowledge sharing among colleagues within the company.</p>
<p class="normal">Moreover, sharing code between the frontend and backend of a website eliminates the need for redundant efforts. As a result, this approach generally reduces the occurrence of mistakes and issues.</p>
<p class="normal">Furthermore, maintaining a single code base is more manageable compared to handling two separate ones. Additionally, incorporating JavaScript on the server side enhances collaboration between frontend and backend developers. By leveraging the same language, they can efficiently reuse code and make prompt decisions, thereby enhancing workflow and productivity.</p>
<h2 class="heading-2" id="_idParaDest-189">Better performance</h2>
<p class="normal">Last but not least, we all love client-side applications because they are fast and responsive, but <a id="_idIndexMarker462"/>there is a problem—the bundle has to be loaded and run before users can take any action on the application.</p>
<p class="normal">This might not be a problem using a modern laptop or a desktop computer with a fast internet connection. However, if we load a huge JavaScript bundle using a mobile device with a 3G connection, users have to wait for a little while before interacting with the application. This is not only bad for the UX in general but it also affects conversions. It has been proven by major e-commerce websites that a few milliseconds added to the page load can have an enormous impact on revenues.</p>
<p class="normal">For example, if we serve our application with an empty HTML page and a script tag on the server and we show a spinner to our users until they can click on anything, the perception of the speed of the website is significantly affected.</p>
<p class="normal">If we render our website on the server side instead and users start seeing some of the content as soon as they hit the page, they are more likely to stay, even if they have to wait <a id="_idIndexMarker463"/>the same amount of time before doing anything for real, because the client-side bundle has to be loaded regardless of the SSR.</p>
<p class="normal">This perceived performance is something we can improve greatly using SSR because we can output our components on the server and return some information to users straight away.</p>
<h2 class="heading-2" id="_idParaDest-190">Don’t underestimate the complexity of SSR</h2>
<p class="normal">Even though React provides an easy API to render components on the server, creating a universal <a id="_idIndexMarker464"/>application has a cost. So, we should consider carefully before enabling it for one of the preceding reasons and check whether our team is ready to support and maintain a universal application.</p>
<p class="normal">SSR can incur additional costs, extending development time and adding complexity. It also increases the server load, potentially necessitating costlier infrastructure. Operationally, SSR requires a well-maintained server with a complete setup, leading to increased operational costs. Additionally, testing may become more time-consuming due to the heightened complexity. </p>
<p class="normal">It is crucial to strike a balance between these costs and the potential benefits of SSR, such as improved SEO and faster initial page loads.</p>
<p class="normal">As we progress through the upcoming sections, we will discover that rendering components is not the sole task involved in creating server-side-rendered applications. We must establish and maintain a server with its routes and logic, manage the server data flow, and perform various other essential tasks to sustain a fully functional universal application. Consider caching content to serve pages more efficiently and address other necessary responsibilities.</p>
<p class="normal">Therefore, my recommendation is to initially focus on constructing the client-side version of your web application. Once it is fully functional and performs well on the server, you can then consider incorporating SSR to enhance the user experience. It is essential to enable SSR only when genuinely required. For instance, if improving your website’s visibility in search engines (SEO) is a priority, that is when you should begin contemplating the implementation of SSR.</p>
<p class="normal">If you realize that <a id="_idIndexMarker465"/>your application takes a lot of time to load fully and you have already done all the optimization (refer to <em class="chapterRef">Chapter 16</em>, <em class="italic">Improving the Performance of Your Applications</em>, for more on this topic), you can consider using SSR to offer a better experience to your users and improve the perceived speed. Now that we have learned what SSR is and the benefits of universal applications, let’s jump into some basic examples of SSR in our next section.</p>
<h1 class="heading-1" id="_idParaDest-191">Creating a basic example of SSR</h1>
<p class="normal">We will now create a very simple server-side application to look at the steps that are needed to <a id="_idIndexMarker466"/>build a basic universal setup. It is going to be a minimal and simple setup on purpose because the goal here is to show how SSR works rather than providing a comprehensive solution or a boilerplate, even though you could use the example application as a starting point for a real-world application.</p>
<div class="note">
<p class="normal">This section assumes that readers have a basic understanding of Node.js and are familiar with the concepts related to JavaScript build tools, such as <strong class="keyWord">webpack</strong> and its loaders.</p>
</div>
<p class="normal">The application will consist of two parts:</p>
<ul>
<li class="bulletList">On the server side, where we will use Express to create a basic web server and serve <a id="_idIndexMarker467"/>an HTML page with the server-side-rendered React application.</li>
<li class="bulletList">On the client side, where we will render the application, as usual, using <code class="inlineCode">react-dom</code>.</li>
</ul>
<h2 class="heading-2" id="_idParaDest-192">Configuring our project from scratch with webpack</h2>
<p class="normal">Both sides of the application will be transpiled with Babel and bundled with webpack <a id="_idIndexMarker468"/>before <a id="_idIndexMarker469"/>being run, which will let us use the full power of ES6 and the modules both on Node.js and on the browser.</p>
<p class="normal">Let’s start by creating a new project folder (you can call it <code class="inlineCode">ssr-project</code>) and running the following command to create a new package:</p>
<pre class="programlisting con"><code class="hljs-con">npm init
</code></pre>
<p class="normal">Once <code class="inlineCode">package.json</code> is created, it is time to install the dependencies. We can start with webpack:</p>
<pre class="programlisting con"><code class="hljs-con">npm install webpack
</code></pre>
<p class="normal">After this is done, it is time to install <code class="inlineCode">ts-loader</code> and the presets that we need to write an ES6 application using React and TSX:</p>
<pre class="programlisting con"><code class="hljs-con">npm install --save-dev @babel/core @babel/preset-env @babel/preset-react ts-loader typescript
</code></pre>
<p class="normal">In order to create the server bundle, we need to install a dependency. Webpack allows us to define a set of externals, which are dependencies that we do not want to include in the bundle. When generating a build for the server, it is preferable not to include all the <code class="inlineCode">Node.js</code> packages used; instead, we only want to bundle our server code. Excluding dependencies from the server bundle offers several advantages, including reduced bundle size, faster compilation, and compatibility with the Node.js environment. By leveraging the native module system of Node.js, the server code can directly access the installed packages without the need for bundling. Tools like <code class="inlineCode">webpack-node-externals</code> assist in defining these dependencies as externals in the webpack configuration, resulting in an optimized server bundle and a streamlined build process. Let’s proceed with the installation of this tool:</p>
<pre class="programlisting con"><code class="hljs-con">npm install --save-dev webpack-node-externals
</code></pre>
<p class="normal">Great. It is now time to create an entry in the npm scripts section of <code class="inlineCode">package.json</code> so that we can easily run the <code class="inlineCode">build</code> command from the terminal:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">"scripts"</span>: {
  <span class="hljs-string">"build"</span>: <span class="hljs-string">"webpack"</span>
}
</code></pre>
<p class="normal">Next, you need to create a <code class="inlineCode">.babelrc</code> file in your root path:</p>
<pre class="programlisting code"><code class="hljs-code">{
  <span class="hljs-string">"</span><span class="hljs-string">presets"</span>: [<span class="hljs-string">"@babel/preset-env"</span>, <span class="hljs-string">"@babel/preset-react"</span>]
}
</code></pre>
<p class="normal">We now have to create the configuration file, called <code class="inlineCode">webpack.config.js</code>, to tell webpack how we want our files to be bundled.</p>
<p class="normal">Let’s start by <a id="_idIndexMarker470"/>importing the <a id="_idIndexMarker471"/>library we will use to set our node externals. We will also define the configuration for <code class="inlineCode">ts-loader</code>, which we will use for both the client and the server:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> nodeExternals = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack-node-externals'</span>)
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
<span class="hljs-keyword">const</span> rules = [{
  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(tsx|ts)$/</span>,
  <span class="hljs-attr">use</span>: <span class="hljs-string">'ts-loader'</span>,
  <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>
}]
</code></pre>
<p class="normal">In <em class="chapterRef">Chapter 6</em>, <em class="italic">Making Your Components Look Beautiful</em>, we looked at how we had to export a configuration object from the configuration file. There is one cool feature in webpack that lets us export an array of configurations as well so that we can define both client and server configurations in the same place and use both in one go.</p>
<p class="normal">The client configuration shown in the following block should be very familiar:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> client = {
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/client.tsx'</span>,
  <span class="hljs-attr">output</span>: {
   <span class="hljs-attr">path</span>: path.<span class="hljs-title">resolve</span>(__dirname, <span class="hljs-string">'./dist/public'</span>),
   <span class="hljs-attr">filename</span>: <span class="hljs-string">'</span><span class="hljs-string">bundle.js'</span>,
   <span class="hljs-attr">publicPath</span>: <span class="hljs-string">'/'</span>
  },
  <span class="hljs-attr">module</span>: {
   rules
  }
}
</code></pre>
<p class="normal">We are telling webpack that the source code of the client application is inside the <code class="inlineCode">src</code> folder, and we want the output bundle to be generated in the <code class="inlineCode">dist</code> folder.</p>
<p class="normal">We also set the module loaders using the previous object we created with <code class="inlineCode">ts-loader</code>. The <a id="_idIndexMarker472"/>server configuration <a id="_idIndexMarker473"/>is slightly different; we need to define a different entry, and add some new nodes, such as <code class="inlineCode">target</code>, <code class="inlineCode">externals</code>, and <code class="inlineCode">resolve</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> server = {
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/server.ts'</span>,
  <span class="hljs-attr">output</span>: {
   <span class="hljs-attr">path</span>: path.<span class="hljs-title">resolve</span>(__dirname, <span class="hljs-string">'./dist'</span>),
   <span class="hljs-attr">filename</span>: <span class="hljs-string">'server.js'</span>,
   <span class="hljs-attr">publicPath</span>: <span class="hljs-string">'/'</span>
  },
  <span class="hljs-attr">module</span>: {
   rules
  },
  <span class="hljs-attr">target</span>: <span class="hljs-string">'node'</span>,
  <span class="hljs-attr">externals</span>: [<span class="hljs-title">nodeExternals</span>()],
  <span class="hljs-attr">resolve</span>: {
   <span class="hljs-attr">extensions</span>: [<span class="hljs-string">".ts"</span>, <span class="hljs-string">"</span><span class="hljs-string">.tsx"</span>, <span class="hljs-string">".js"</span>, <span class="hljs-string">".json"</span>]
  }
}
</code></pre>
<p class="normal">As you can see, <code class="inlineCode">entry</code>, <code class="inlineCode">output</code>, and <code class="inlineCode">module</code> are the same, except for the filenames.</p>
<p class="normal">The new parameters are the target, where we specify the node to tell webpack to ignore all the built-in system packages of Node.js, such as <code class="inlineCode">fs</code>, and <code class="inlineCode">externals</code>, where we use the library we imported earlier to tell webpack to ignore the dependencies.</p>
<p class="normal">Last but not least, we have to export the configurations as an array:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-variable">module</span>.<span class="hljs-property">exports</span> = [client, server]
</code></pre>
<p class="normal">The configuration <a id="_idIndexMarker474"/>is done. We are now ready to write some code, and we will start with the React application, <a id="_idIndexMarker475"/>which we are more familiar with.</p>
<h2 class="heading-2" id="_idParaDest-193">Creating the application</h2>
<p class="normal">Let’s create <a id="_idIndexMarker476"/>an <code class="inlineCode">src</code> folder and an <code class="inlineCode">app.ts</code> file inside it.</p>
<p class="normal">The <code class="inlineCode">app.ts</code> file <a id="_idIndexMarker477"/>should have the following content:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">App</span> = () =&gt; <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>Hello React<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title">App</span>
</code></pre>
<p class="normal">Nothing complex here; we import React, create an <code class="inlineCode">App</code> component, which renders the <code class="inlineCode">Hello React</code> message, and export it.</p>
<p class="normal">Let’s now create <code class="inlineCode">client.tsx</code>, which is responsible for rendering the <code class="inlineCode">App</code> component inside the DOM:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { render } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./app'</span>
<span class="hljs-title">render</span>(<span class="hljs-tag">&lt;</span><span class="hljs-name">App</span><span class="hljs-tag"> /&gt;</span>, <span class="hljs-variable">document</span>.<span class="hljs-title">getElementById</span>(<span class="hljs-string">'root'</span>))
</code></pre>
<p class="normal">Again, this should sound familiar, since we import React, ReactDOM, and the <code class="inlineCode">App</code> component we created earlier, and we use ReactDOM to render it in a DOM element with the app ID.</p>
<p class="normal">Let’s now move to the server.</p>
<p class="normal">The first thing to do is to create a <code class="inlineCode">template.ts</code> file, which exports a function that we will use to return the markup of the page that our server will give back to the browser:</p>
<pre class="programlisting code"><code class="hljs-code">export default body =&gt; `
  <span class="hljs-meta">&lt;!DOCTYPE </span><span class="hljs-keyword">html</span><span class="hljs-meta">&gt;</span>
  <span class="hljs-tag">&lt;</span><span class="hljs-name">html</span><span class="hljs-tag">&gt;</span>
   <span class="hljs-tag">&lt;</span><span class="hljs-name">head</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">meta</span><span class="hljs-tag"> </span><span class="hljs-attr">charset</span><span class="hljs-tag">=</span><span class="hljs-string">"UTF-8"</span><span class="hljs-tag"> /&gt;</span>
   <span class="hljs-tag">&lt;/</span><span class="hljs-name">head</span><span class="hljs-tag">&gt;</span>
   <span class="hljs-tag">&lt;</span><span class="hljs-name">body</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> </span><span class="hljs-attr">id</span><span class="hljs-tag">=</span><span class="hljs-string">"root"</span><span class="hljs-tag">&gt;</span>${body}<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">script</span><span class="hljs-tag"> </span><span class="hljs-attr">src</span><span class="hljs-tag">=</span><span class="hljs-string">"/bundle.js"</span><span class="hljs-tag">&gt;&lt;/</span><span class="hljs-name">script</span><span class="hljs-tag">&gt;</span>
   <span class="hljs-tag">&lt;/</span><span class="hljs-name">body</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">&lt;/</span><span class="hljs-name">html</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">It should be pretty straightforward. The function accepts <code class="inlineCode">body</code>, which we will later see contains the React app, and it returns the skeleton of the page.</p>
<p class="normal">It is worth noting that we load the bundle on the client side even if the app is rendered on the server side. SSR is only half of the job that React does to render our application. We still want our application to be a client-side application, with all the features we can use in the browser, such as event handlers, for example.</p>
<p class="normal">After this, you need to install <code class="inlineCode">express</code>, <code class="inlineCode">react</code>, and <code class="inlineCode">react-dom</code>:</p>
<pre class="programlisting con"><code class="hljs-con">npm install express react react-dom @types/express @types/react @types/react-dom
</code></pre>
<p class="normal">Now it is time <a id="_idIndexMarker478"/>to create <code class="inlineCode">server.tsx</code>, which has more dependencies <a id="_idIndexMarker479"/>and is worth exploring in detail:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> <span class="hljs-title">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> express, { <span class="hljs-title">Request</span>, <span class="hljs-title">Response</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'express'</span>
<span class="hljs-keyword">import</span> { renderToString } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom/server'</span>
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span>
<span class="hljs-keyword">import</span> template <span class="hljs-keyword">from</span> <span class="hljs-string">'./template'</span>
</code></pre>
<p class="normal">The first thing that we import is <code class="inlineCode">express</code>, the library that allows us to create a web server with some routes easily, and which is also able to serve static files.</p>
<p class="normal">Secondly, we import React and ReactDOM to render <code class="inlineCode">App</code>, which we import as well. Notice the <code class="inlineCode">/server</code> path in the <code class="inlineCode">import</code> statement of ReactDOM. The last thing we import is the template we defined earlier.</p>
<p class="normal">Now we create an Express application:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> app = <span class="hljs-title">express</span>()
</code></pre>
<p class="normal">We tell the application where our static assets are stored:</p>
<pre class="programlisting code"><code class="hljs-code">app.<span class="hljs-title">use</span>(express.<span class="hljs-title">static</span>(path.<span class="hljs-title">resolve</span>(__dirname, <span class="hljs-string">'./dist/public'</span>)))
</code></pre>
<p class="normal">As you may have noticed, the path is the same that we used in the client configuration of webpack as the output destination of the client bundle.</p>
<p class="normal">Then, here comes the logic of SSR with React:</p>
<pre class="programlisting code"><code class="hljs-code">app.<span class="hljs-title">get</span>(<span class="hljs-string">'/'</span>, <span class="hljs-function">(</span><span class="hljs-params">req: Request, res: Response</span><span class="hljs-function">) =&gt;</span> {
  <span class="hljs-keyword">const</span> body = <span class="hljs-title">renderToString</span>(<span class="hljs-tag">&lt;</span><span class="hljs-name">App</span><span class="hljs-tag"> /&gt;</span>)
  <span class="hljs-keyword">const</span> html = <span class="hljs-title">template</span>(body)
  res.<span class="hljs-title">send</span>(html)
})
</code></pre>
<p class="normal">We are telling Express that we want to listen to the <code class="inlineCode">/</code> route, and when it gets hit by a client, we render <code class="inlineCode">App</code> to a string using the ReactDOM library. Here comes the magic and simplicity of the SSR of React.</p>
<p class="normal">What <code class="inlineCode">renderToString</code> does is return a string representation of the DOM elements generated by our <code class="inlineCode">App</code> component, the same tree that it would render in the DOM if we were using the ReactDOM <code class="inlineCode">render</code> method.</p>
<p class="normal">The value of the <code class="inlineCode">body</code> variable is something like the following:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> </span><span class="hljs-attr">data-reactroot</span><span class="hljs-tag">=</span><span class="hljs-string">""</span><span class="hljs-tag"> </span><span class="hljs-attr">data-reactid</span><span class="hljs-tag">=</span><span class="hljs-string">"1"</span><span class="hljs-tag"> </span><span class="hljs-attr">data-react-checksum</span><span class="hljs-tag">=</span><span class="hljs-string">"982061917"</span><span class="hljs-tag">&gt;</span>Hello React<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">As you can see, it represents what we defined in the <code class="inlineCode">render</code> method of <code class="inlineCode">App</code>, except for a couple <a id="_idIndexMarker480"/>of data attributes that React uses on <a id="_idIndexMarker481"/>the client to attach the client-side application to the server-side-rendered string.</p>
<p class="normal">Now that we have the SSR representation of our app, we can use the <code class="inlineCode">template</code> function to apply it to the HTML template and send it back to the browser within the Express response.</p>
<p class="normal">Last but not least, we have to start the Express application:</p>
<pre class="programlisting code"><code class="hljs-code">app.<span class="hljs-title">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-string">'Listening on port 3000'</span>)
})
</code></pre>
<p class="normal">We are now ready to go; there are only a few operations left. The first one is to define the start script of npm and set it to run the node server:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">"scripts"</span>: {
  <span class="hljs-string">"build"</span>: <span class="hljs-string">"webpack"</span>,
  <span class="hljs-string">"</span><span class="hljs-string">start"</span>: <span class="hljs-string">"node ./dist/server"</span>
}
</code></pre>
<p class="normal">The scripts are ready, so we can first build the application with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">npm run build
</code></pre>
<p class="normal">When the bundles are created, we can run the following command:</p>
<pre class="programlisting con"><code class="hljs-con">npm start
</code></pre>
<p class="normal">Point the browser to <code class="inlineCode">http://localhost:3000</code> and see the result.</p>
<p class="normal">There are two important things to note here. First, when we use the <strong class="screenText">View Page Source</strong> feature of the browser, we can see the source code of the application being rendered and returned from the server, which we would not see if SSR was not enabled.</p>
<p class="normal">Second, if we open <a id="_idIndexMarker482"/>DevTools and we have the React extension installed, we can see that the <code class="inlineCode">App</code> component has been booted on the client as well.</p>
<p class="normal">The following <a id="_idIndexMarker483"/>screenshot shows the source of the page:</p>
<figure class="mediaobject"><img alt="Graphical user interface, text, application, website  Description automatically generated" height="273" src="../Images/B18414_12_01.png" width="825"/></figure>
<p class="packt_figref">Figure 12.1: Source code page</p>
<p class="normal">Great! Now that you have created your first React application using SSR, let’s learn how to fetch data in the next section.</p>
<h1 class="heading-1" id="_idParaDest-194">Implementing data fetching</h1>
<p class="normal">The example in the previous section should clearly explain how to set up a universal application <a id="_idIndexMarker484"/>in React. It is pretty straightforward, and the main focus is on getting things done. However, in a real-world application, we will likely want to load some data instead of a static React component, such as <code class="inlineCode">App</code> in the example. </p>
<p class="normal">Let’s assume, for example, we want to load Dan Abramov’s gists on the server and return the list of items from the Express app we just created.</p>
<p class="normal">In the data fetching examples in <em class="chapterRef">Chapter 12</em>, <em class="italic">Managing Data</em>, we looked at how we can use <code class="inlineCode">useEffect</code> to fire the data loading. That wouldn’t work on the server because components do not get mounted on the DOM and the life cycle Hook never gets fired.</p>
<p class="normal">Using Hooks that were executed earlier will not work either because the data fetching operation is async, while <code class="inlineCode">renderToString</code> is not. For that reason, we have to find a way to load the data beforehand and pass it to the component as props.</p>
<p class="normal">Let’s look at how we can take the application from the previous section and change it a bit to make it load gists during the SSR phase.</p>
<p class="normal">The first thing to do is to change <strong class="keyWord">App.tsx</strong> to accept a list of <code class="inlineCode">gists</code> as <code class="inlineCode">props</code>, and loop through it in the <code class="inlineCode">render</code> method to display their descriptions:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { <span class="hljs-variable">FC</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">type</span> <span class="hljs-title">Gist</span> = {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">description</span>: <span class="hljs-built_in">string</span>
 }
 <span class="hljs-keyword">type</span> <span class="hljs-title">Props</span> = {
  <span class="hljs-attr">gists</span>: <span class="hljs-title">Gist</span>[]
}
<span class="hljs-keyword">const</span> <span class="hljs-title">App</span>: <span class="hljs-variable">FC</span>&lt;<span class="hljs-title">Props</span>&gt; = <span class="hljs-function">(</span><span class="hljs-params">{ gists }</span><span class="hljs-function">) =&gt;</span> ( 
  <span class="hljs-tag">&lt;</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
   {gists.map(gist =&gt; (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">li</span><span class="hljs-tag"> </span><span class="hljs-attr">key</span><span class="hljs-tag">=</span><span class="hljs-string">{gist.id}</span><span class="hljs-tag">&gt;</span>{gist.description}<span class="hljs-tag">&lt;/</span><span class="hljs-name">li</span><span class="hljs-tag">&gt;</span>
   ))}
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title">App</span>
</code></pre>
<p class="normal">Applying the concept that we learned in the previous chapter, we define a stateless functional component, which receives <code class="inlineCode">gists</code> as <code class="inlineCode">props</code> and loops through the elements to render a list of items. Now, we have to change the server to retrieve <code class="inlineCode">gists</code> and pass them to the component.</p>
<p class="normal">To use the <code class="inlineCode">fetch</code> API on the server side, we have to install a library called <code class="inlineCode">isomorphic-fetch</code>, which <a id="_idIndexMarker485"/>implements the fetch standards. It can be used in Node.js and the browser:</p>
<pre class="programlisting con"><code class="hljs-con">npm install isomorphic-fetch @types/isomorphic-fetch
</code></pre>
<p class="normal">We first import the library into <code class="inlineCode">server.tsx</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> fetch <span class="hljs-keyword">from</span> <span class="hljs-string">'isomorphic-fetch'</span>
</code></pre>
<p class="normal">The API call that we want to make looks as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">fetch</span>(<span class="hljs-string">'https://api.github.com/users/gaearon/gists'</span>) 
  .<span class="hljs-title">then</span>(<span class="hljs-params">response</span><span class="hljs-function"> =&gt;</span> response.<span class="hljs-title">json</span>()) 
  .<span class="hljs-title">then</span>(<span class="hljs-params">gists</span><span class="hljs-function"> =&gt;</span> {})
</code></pre>
<p class="normal">Here, gists are available to be used inside the last <code class="inlineCode">then</code> function. In our case, we want to pass them down to <code class="inlineCode">App</code>.</p>
<p class="normal">Therefore, we can change the <code class="inlineCode">/</code> route as follows:</p>
<pre class="programlisting code"><code class="hljs-code">app.<span class="hljs-title">get</span>(<span class="hljs-string">'/'</span>, <span class="hljs-function">(</span><span class="hljs-params">req, res</span><span class="hljs-function">) =&gt;</span> { 
  <span class="hljs-title">fetch</span>(<span class="hljs-string">'https://api.github.com/users/gaearon/gists'</span>)
   .<span class="hljs-title">then</span>(<span class="hljs-params">response</span><span class="hljs-function"> =&gt;</span> response.<span class="hljs-title">json</span>()) 
   .<span class="hljs-title">then</span>(<span class="hljs-params">gists</span><span class="hljs-function"> =&gt;</span> {
    <span class="hljs-keyword">const</span> body = <span class="hljs-title">renderToString</span>(<span class="hljs-tag">&lt;</span><span class="hljs-name">App</span><span class="hljs-tag"> </span><span class="hljs-attr">gists</span><span class="hljs-tag">=</span><span class="hljs-string">{gists}</span><span class="hljs-tag"> /&gt;</span>)
    <span class="hljs-keyword">const</span> html = <span class="hljs-title">template</span>(body)
    res.<span class="hljs-title">send</span>(html)
    })
})
</code></pre>
<p class="normal">Here, we first fetch <code class="inlineCode">gists</code>, and then we render <code class="inlineCode">App</code> as a string, passing the property.</p>
<p class="normal">Once <code class="inlineCode">App</code> is rendered and we have its markup, we use the template we used in the previous section and return it to the browser.</p>
<p class="normal">Run the following command in the console and point the browser to <code class="inlineCode">http://localhost:3000</code>. You should be able to see a <code class="inlineCode">server-side render</code> list of <code class="inlineCode">gists</code>:</p>
<pre class="programlisting con"><code class="hljs-con">npm run build &amp;&amp; npm start
</code></pre>
<p class="normal">To make sure that the list is rendered from the Express app, you can navigate to <code class="inlineCode">view-source:http://localhost:3000</code> and you will see the markup and the descriptions of gists.</p>
<p class="normal">That is great, and it looks easy, but if we check the DevTools console, we can see <code class="inlineCode">Cannot read property 'map' of undefined error</code>. The reason we see the error is that, on the client, we are rendering <code class="inlineCode">App</code> again, but without passing <code class="inlineCode">gists</code> to it.</p>
<p class="normal">This could sound counter-intuitive in the beginning because we might think that React is smart enough to use <code class="inlineCode">gists</code> rendered within the server-side string on the client. But that is not what happens, so we have to find a way to make <code class="inlineCode">gists</code> available on the client side as well.</p>
<p class="normal">You may consider that you could execute the fetch again on the client. That would work, but it is <a id="_idIndexMarker486"/>not optimal because you would end up firing two HTTP calls, one on the Express server and one in the browser. If we think about it, we already made the call on the server, and we have all the data we need. A typical solution to sharing data between the server and the client is dehydrating the data in the HTML markup and hydrating it back in the browser.</p>
<p class="normal">This seems like a complex concept, but it is not. We will now look at how easy it is to implement. The first thing we must do is inject <code class="inlineCode">gists</code> into the template after we have fetched them on the client.</p>
<p class="normal">To do this, we have to change the template slightly, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">export default (body, gists) =&gt; `
  <span class="hljs-meta">&lt;!DOCTYPE </span><span class="hljs-keyword">html</span><span class="hljs-meta">&gt;</span>
  <span class="hljs-tag">&lt;</span><span class="hljs-name">html</span><span class="hljs-tag">&gt;</span>
   <span class="hljs-tag">&lt;</span><span class="hljs-name">head</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">meta</span><span class="hljs-tag"> </span><span class="hljs-attr">charset</span><span class="hljs-tag">=</span><span class="hljs-string">"UTF-8"</span><span class="hljs-tag"> /&gt;</span> 
   <span class="hljs-tag">&lt;/</span><span class="hljs-name">head</span><span class="hljs-tag">&gt;</span>
   <span class="hljs-tag">&lt;</span><span class="hljs-name">body</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> </span><span class="hljs-attr">id</span><span class="hljs-tag">=</span><span class="hljs-string">"root"</span><span class="hljs-tag">&gt;</span>${body}<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">script</span><span class="hljs-tag">&gt;</span><span class="hljs-variable">window</span>.<span class="hljs-property">gists</span> = ${<span class="hljs-title">JSON</span>.<span class="hljs-title">stringify</span>(gists)}<span class="hljs-tag">&lt;/</span><span class="hljs-name">script</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">script</span><span class="hljs-tag"> </span><span class="hljs-attr">src</span><span class="hljs-tag">=</span><span class="hljs-string">"/bundle.js"</span><span class="hljs-tag">&gt;&lt;/</span><span class="hljs-name">script</span><span class="hljs-tag">&gt;</span>
   <span class="hljs-tag">&lt;/</span><span class="hljs-name">body</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">html</span><span class="hljs-tag">&gt;</span>
`
</code></pre>
<p class="normal">The <code class="inlineCode">template</code> function now accepts two parameters—the <code class="inlineCode">body</code> of the app and the collection of <code class="inlineCode">gists</code>. The first one is inserted into the <code class="inlineCode">app</code> element, while the second is used to define a global <code class="inlineCode">gists</code> variable attached to the <code class="inlineCode">window</code> object so that we can use it in the client.</p>
<p class="normal">Inside the Express route (<code class="inlineCode">server.ts</code>), we just have to change the line where we generate the template passing the body, as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> html = <span class="hljs-title">template</span>(body, gists)
</code></pre>
<p class="normal">Last but not least, we have to use gists attached to a window inside <strong class="keyWord">client.tsx</strong>, which is pretty easy:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">ReactDOM</span>.<span class="hljs-title">hydrate</span>(
  <span class="hljs-tag">&lt;</span><span class="hljs-name">App</span><span class="hljs-tag"> </span><span class="hljs-attr">gists</span><span class="hljs-tag">=</span><span class="hljs-string">{window.gists}</span><span class="hljs-tag"> /&gt;</span>,
  <span class="hljs-variable">document</span>.<span class="hljs-title">getElementById</span>(<span class="hljs-string">'app'</span>) 
)
</code></pre>
<p class="normal">The hydrate method was introduced in React 16 and works similarly to <code class="inlineCode">render</code> on the client side, irrespective of whether the HTML has server-side-rendered markup or not. If there is no markup <a id="_idIndexMarker487"/>previously using SSR, then the <code class="inlineCode">hydrate</code> method will fire a warning, which you can silence by using the new <code class="inlineCode">suppressHydrationWarning</code> attribute. </p>
<p class="normal">We read <code class="inlineCode">gists</code> directly, and we pass them to the <code class="inlineCode">App</code> component that gets rendered on the client.</p>
<p class="normal">Now, run the following command again:</p>
<pre class="programlisting con"><code class="hljs-con">npm run build &amp;&amp; npm start
</code></pre>
<p class="normal">If we point the browser window to <code class="inlineCode">http://localhost:3000</code>, the error is gone, and if we inspect the <code class="inlineCode">App</code> component using React DevTools, we can see how the client-side <code class="inlineCode">App</code> component receives the collection of gists.</p>
<p class="normal">As we have created our first SSR application, let’s now see how we can do this more easily by using an SSR framework called Next.js in the next section.</p>
<h1 class="heading-1" id="_idParaDest-195">Using Next.js to create a React application</h1>
<p class="normal">You have looked at the basics of SSR with React, and you can use the project we created as a <a id="_idIndexMarker488"/>starting point for a real app. However, you may think that there is too much boilerplate and that you are required <a id="_idIndexMarker489"/>to know about too many different tools to run a simple universal <a id="_idIndexMarker490"/>application with React. This is a common feeling called <strong class="keyWord">JavaScript fatigue</strong>, as described in the introduction to this book.</p>
<p class="normal">Luckily, Meta developers and other companies in the React community are working very hard to improve the DX and make the lives of developers easier. You might have used <code class="inlineCode">create-react-app</code> at this point to try out the examples in the previous chapters, and you should understand how it makes it very simple to create React applications without requiring developers to learn about many technologies and tools.</p>
<p class="normal">Now, <code class="inlineCode">create-react-app</code> does not support SSR yet, but there’s a company called <strong class="keyWord">Vercel</strong> that has created a tool called <strong class="keyWord">Next.js</strong>, which <a id="_idIndexMarker491"/>makes it incredibly easy to generate universal <a id="_idIndexMarker492"/>applications without worrying about configuration files. It also reduces the boilerplate a lot.</p>
<p class="normal">It is important to say that using abstractions is always very good for building applications quickly. However, it is crucial to know how the internals work before adding too many layers, and that is why we started with the manual process before learning Next.js. We have looked at how SSR works and how we can pass the state from the server to the client. Now that the base concepts are clear, we can move on to a tool that hides a little bit of complexity and makes us write less code to achieve the same results.</p>
<p class="normal">We will create the same app where all gists from Dan Abramov are loaded, and you will see how clean and simple the code is, thanks to Next.js.</p>
<p class="normal">First of all, create a new project folder (you can call it <code class="inlineCode">next-project</code>) and run the following command:</p>
<pre class="programlisting con"><code class="hljs-con">npm init
</code></pre>
<p class="normal">When this is done, we can install the Next.js library and React:</p>
<pre class="programlisting con"><code class="hljs-con">npm install next react react-dom typescript @types/react @types/node
</code></pre>
<p class="normal">Now that the project is created, we have to add an npm script to run the binary:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">"scripts"</span>: {
  <span class="hljs-string">"dev"</span>: <span class="hljs-string">"next"</span> 
}
</code></pre>
<p class="normal">Perfect! It is now time to generate our <code class="inlineCode">App</code> component. Next.js is based on conventions, with the most important one being that you can create pages to match the browser URLs. The default page is <code class="inlineCode">index</code>, so we can create a folder called <code class="inlineCode">pages</code> and put an <code class="inlineCode">index.js</code> file inside it.</p>
<p class="normal">We start importing the dependencies:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> fetch <span class="hljs-keyword">from</span> <span class="hljs-string">'isomorphic-fetch'</span>
</code></pre>
<p class="normal">Again, we import <code class="inlineCode">isomorphic-fetch</code> because we want to be able to use the <code class="inlineCode">fetch</code> function on the server side.</p>
<p class="normal">We then define a component called <code class="inlineCode">App</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">App</span> = () =&gt; {}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title">App</span>
</code></pre>
<p class="normal">Then we define a static async function, called <code class="inlineCode">getInitialProps</code>, which is where we tell Next.js which data we <a id="_idIndexMarker493"/>want to load, both on the server side and on the client side. The library will make the object returned from the function available as props inside the component.</p>
<p class="normal">The <code class="inlineCode">stati</code>c and <code class="inlineCode">async</code> keywords applied to a class method mean that the function can be accessed <a id="_idIndexMarker494"/>outside the instance of the class <a id="_idIndexMarker495"/>and that the function yields the execution of the <code class="inlineCode">wait</code> instructions inside its body.</p>
<p class="normal">These concepts are pretty advanced, and they are not part of the scope of this chapter, but if you are interested in them, you should check out the ECMAScript proposals (<a href="https://github.com/tc39/proposals"><span class="url">https://github.com/tc39/proposals</span></a>).</p>
<p class="normal">The implementation of the method we just described is as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">App</span>.<span class="hljs-property">getInitialProps</span> = <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> url = <span class="hljs-string">'https://api.github.com/users/gaearon/gists'</span>
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title">fetch</span>(url)
  <span class="hljs-keyword">const</span> gists = <span class="hljs-keyword">await</span> response.<span class="hljs-title">json</span>() 
  <span class="hljs-keyword">return</span> {
   gists
  }
}
</code></pre>
<p class="normal">We are telling the function to fire the <code class="inlineCode">fetch</code> and wait for the response, then we are transforming <a id="_idIndexMarker496"/>the response into JSON, which <a id="_idIndexMarker497"/>returns a promise. When the promise is resolved, we can return the <code class="inlineCode">props</code> object with <code class="inlineCode">gists</code>.</p>
<p class="normal">The render of the component looks pretty similar to the preceding one:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
   {props.gists.map(gist =&gt; (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">li</span><span class="hljs-tag"> </span><span class="hljs-attr">key</span><span class="hljs-tag">=</span><span class="hljs-string">{gist.id}</span><span class="hljs-tag">&gt;</span>{gist.description}<span class="hljs-tag">&lt;/</span><span class="hljs-name">li</span><span class="hljs-tag">&gt;</span> 
   ))}
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span> 
)
</code></pre>
<p class="normal">Before you run the project, you need to configure <code class="inlineCode">tsconfig.json</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
   <span class="hljs-attr">"baseUrl"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"src"</span><span class="hljs-punctuation">,</span>
   <span class="hljs-attr">"esModuleInterop"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
   <span class="hljs-attr">"module"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"esnext"</span><span class="hljs-punctuation">,</span>
   <span class="hljs-attr">"noImplicitAny"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
   <span class="hljs-attr">"outDir"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"dist"</span><span class="hljs-punctuation">,</span>
   <span class="hljs-attr">"resolveJsonModule"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
   <span class="hljs-attr">"</span><span class="hljs-attr">sourceMap"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span>
   <span class="hljs-attr">"target"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"esnext"</span><span class="hljs-punctuation">,</span>
   <span class="hljs-attr">"lib"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"dom"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"dom.iterable"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"esnext"</span><span class="hljs-punctuation">],</span>
   <span class="hljs-attr">"allowJs"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
   <span class="hljs-attr">"skipLibCheck"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
   <span class="hljs-attr">"strict"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
   <span class="hljs-attr">"forceConsistentCasingInFileNames"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
   <span class="hljs-attr">"noEmit"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
   <span class="hljs-attr">"moduleResolution"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"node"</span><span class="hljs-punctuation">,</span>
   <span class="hljs-attr">"isolatedModules"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
   <span class="hljs-attr">"jsx"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"react-jsx"</span>
  <span class="hljs-punctuation">},</span>
  <span class="hljs-attr">"include"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"src/**/*.ts"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"src/**/*.tsx"</span><span class="hljs-punctuation">],</span>
  <span class="hljs-attr">"exclude"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"node_modules"</span><span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p class="normal">Now, open the console and run the following command:</p>
<pre class="programlisting con"><code class="hljs-con">npm run dev
</code></pre>
<p class="normal">We will see the following output:</p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt; </span>Ready on http://localhost:3000
</code></pre>
<p class="normal">If we point the browser to that URL, we can see the universal application in action. It is really impressive how easy it is to set up a universal application with a few lines of code and zero configuration, thanks to Next.js.</p>
<p class="normal">You may also <a id="_idIndexMarker498"/>notice that if you edit the application <a id="_idIndexMarker499"/>inside your editor, you will be able to see the results within the browser instantly without needing to refresh the page. That is another feature of Next.js, which enables hot module replacement. It is incredibly useful in development mode.</p>
<p class="normal">If you liked this chapter, go and give it a star on GitHub: <a href="https://github.com/zeit/next.js"><span class="url">https://github.com/zeit/next.js</span></a>.</p>
<h1 class="heading-1" id="_idParaDest-196">Summary</h1>
<p class="normal">The journey through SSR has come to an end. You are now able to create a server-side-rendered application with React, and it should be clear why it can be useful for you. SEO is certainly one of the main reasons, but social sharing and performance are important factors as well. You learned how it is possible to load the data on the server and dehydrate it in the HTML template to make it available to the client-side application when it boots on the browser.</p>
<p class="normal">Finally, you looked at how tools such as Next.js can help you reduce the boilerplate and hide some of the complexity that setting up a server-side-rendered React application usually brings to the code base.</p>
<p class="normal">In the next chapter, we will talk about how to improve the performance of our React applications.</p>
<h1 class="heading-1" id="_idParaDest-197">Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussion with the author and other readers:</p>
<p class="normal"><a href="https://packt.link/React18DesignPatterns4e"><span class="url">https://packt.link/React18DesignPatterns4e</span></a></p>
<p class="normal"><img alt="" height="177" src="../Images/QR_Code2450023176943770109.png" width="177"/></p>
</div>
</div></body></html>