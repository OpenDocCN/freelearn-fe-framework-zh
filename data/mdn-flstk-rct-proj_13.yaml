- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Aggregating and Visualizing Statistics Using MongoDB and Victory
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MongoDB 和 Victory 聚合和可视化统计数据
- en: In this chapter, we are going to learn how to collect, aggregate, and visualize
    statistics for our blog application using MongoDB and Victory. We start out by
    learning how we can collect events from users viewing blog posts. Then, we randomly
    generate some events to have a dataset to work with. We use this dataset to learn
    how to aggregate data with MongoDB and generate summary statistics, such as the
    number of views per post, or the average session duration on a post. This kind
    of information will help authors know how well their posts are doing. Finally,
    we create some graphs to visualize these aggregated statistics using the Victory
    library.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用 MongoDB 和 Victory 收集、聚合和可视化博客应用的统计数据。我们首先学习如何从查看博客帖子的用户那里收集事件。然后，我们随机生成一些事件以获得可工作的数据集。我们使用这个数据集来学习如何使用
    MongoDB 聚合数据并生成汇总统计数据，例如每篇帖子的观看次数或平均会话持续时间。这类信息将帮助作者了解他们的帖子表现如何。最后，我们使用 Victory
    库创建一些图表来可视化这些聚合统计数据。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Collecting and simulating events
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集和模拟事件
- en: Aggregating data with MongoDB
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MongoDB 聚合数据
- en: Implementing data aggregation in the backend
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后端实现数据聚合
- en: Integrating and visualizing data on the frontend using Victory
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Victory 在前端集成和可视化数据
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before we start, please install all requirements from [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016),
    *Preparing for Full-Stack Development*, and [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028),
    *Getting to Know Node.js* *and MongoDB*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请从 [*第 1* 章准备全栈开发](B19385_01.xhtml#_idTextAnchor016) 和 [*第 2* 章了解 Node.js
    及 MongoDB](B19385_02.xhtml#_idTextAnchor028) 安装所有要求。
- en: The versions listed in those chapters are the ones used in the book. While installing
    a newer version should not be an issue, please note that certain steps might work
    differently on a newer version. If you are having an issue with the code and steps
    provided in this book, please try using the versions mentioned in *Chapters 1*
    and *2.*
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那些章节中列出的版本是书中使用的版本。虽然安装较新版本可能不会有问题，但请注意，某些步骤在较新版本上可能有所不同。如果您在使用本书提供的代码和步骤时遇到问题，请尝试使用第
    *1* 章和 *2* 章中提到的版本。*第 1* 章和 *第 2* 章分别介绍了*为全栈开发做准备*和*了解 Node.js 及 MongoDB*。
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch10](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch10).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的代码：[https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch10](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch10)。
- en: If you cloned the full repository for the book, Husky may not find the `.git`
    directory when running `npm install`. In that case, just run `git init` in the
    root of the corresponding chapter folder.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您克隆了本书的完整仓库，当运行 `npm install` 时，Husky 可能找不到 `.git` 目录。在这种情况下，只需在相应章节文件夹的根目录下运行
    `git init`。
- en: 'The CiA video for this chapter can be found at: [https://youtu.be/DmSq2P_IQQs](https://youtu.be/DmSq2P_IQQs).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 CiA 视频可以在以下网址找到：[https://youtu.be/DmSq2P_IQQs](https://youtu.be/DmSq2P_IQQs)。
- en: Collecting and simulating events
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集和模拟事件
- en: 'Before we can get started aggregating and visualizing statistics, we first
    need to collect (and later simulate) events, which we are going to use to create
    the statistics. We will start by thinking about which data we want to collect,
    and which data would be useful for us. We will focus on post views for now, so
    we would like to show the following statistics per post:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始聚合和可视化统计数据之前，我们首先需要收集（稍后模拟）事件，我们将使用这些事件来创建统计数据。我们将首先考虑我们想要收集哪些数据，以及哪些数据对我们有用。现在我们将专注于帖子观看，因此我们希望按以下方式显示每篇帖子的统计数据：
- en: Total number of views on a post
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帖子的总观看次数
- en: Daily views on a post
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帖子的每日观看次数
- en: Daily average viewing duration on a post
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帖子的每日平均观看时长
- en: Let’s start by creating the database model for events that will allow us to
    show these statistics.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个事件数据库模型，这将使我们能够展示这些统计数据。
- en: Creating the event model
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建事件模型
- en: To create these statistics, we need to collect events from users. Events will
    contain a reference to a post, a session ID to track events from the same viewing,
    an action (started viewing, ended viewing), and a date of when the event happened.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这些统计数据，我们需要从用户那里收集事件。事件将包含对帖子的引用、用于跟踪同一观看事件的会话 ID、一个动作（开始观看、结束观看）以及事件发生的时间。
- en: 'Let’s get started defining the database model for events:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始定义事件的数据库模型：
- en: 'Copy the existing **ch9** folder to a new **ch10** folder, as follows:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的 **ch9** 文件夹复制到一个新的 **ch10** 文件夹中，如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Open the **ch10** folder in VS Code.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开 **ch10** 文件夹。
- en: 'Create a new **backend/src/db/models/event.js** file. Inside this file, define
    a schema that contains a reference to a post:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **backend/src/db/models/event.js** 文件。在此文件中，定义一个包含对帖子引用的模式：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then define a **session**, **action**, and **date**:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后定义 **session**、**action** 和 **date**：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, export the model:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，导出模型：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we have defined the database model, let’s continue by defining a service
    function and route to track events.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了数据库模型，让我们继续定义一个服务函数和路由来跟踪事件。
- en: Defining a service function and route to track events
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个服务函数和路由来跟踪事件
- en: 'Now that we have successfully defined our database model for events, let’s
    create a service function and route to track new events, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功定义了事件的数据库模型，让我们创建一个服务函数和路由来跟踪新事件，如下所示：
- en: 'To generate session IDs, we are going to use the **uuid** library, which generates
    **universally unique identifiers (UUIDs)** for us. Install it by running the following
    commands:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了生成会话ID，我们将使用 **uuid** 库，它为我们生成 **全球唯一标识符（UUIDs）**。通过运行以下命令来安装它：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a new **backend/src/services/events.js** file. Inside it, import the
    **v4** function from **uuid** and the **Event** model and define a function to
    create a new event document, as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **backend/src/services/events.js** 文件。在此文件中，从 **uuid** 中导入 **v4** 函数和
    **Event** 模型，并定义一个创建新事件文档的函数，如下所示：
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the arguments to the function, we set the default session ID to a randomly
    generated UUID and the date to the current date.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在函数的参数中，我们将默认的会话ID设置为随机生成的UUID，并将日期设置为当前日期。
- en: 'Create a new **backend/src/routes/events.js** file. Inside it, import the **trackEvent**
    function and the **getPostById** function:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **backend/src/routes/events.js** 文件。在此文件中，导入 **trackEvent** 函数和 **getPostById**
    函数：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Define a new **POST /api/v1/events** route, in which we get the **postId**,
    **session**, and **action** from the body:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的 **POST /api/v1/events** 路由，其中我们从请求体中获取 **postId**、**session** 和 **action**：
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, we check whether a post with the given ID exists in the database. If
    not, we return a **400 Bad Request** status code:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们检查给定ID的帖子是否存在于数据库中。如果不存在，我们返回一个 **400 Bad Request** 状态码：
- en: '[PRE8]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If the post exists, we get the session ID and use the **trackEvent** function
    to create a new event:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果帖子存在，我们获取会话ID并使用 **trackEvent** 函数创建一个新的事件：
- en: '[PRE9]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Edit **backend/src/app.js** and import **eventRoutes**:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **backend/src/app.js** 并导入 **eventRoutes**：
- en: '[PRE10]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then mount the routes to the app:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将路由挂载到应用上：
- en: '[PRE11]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Start the backend as follows (and keep it running for future development):'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式启动后端（并保持运行以供未来开发使用）：
- en: '[PRE12]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we have successfully defined a backend route to track events, let’s
    implement event collection on the frontend.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功定义了一个后端路由来跟踪事件，让我们在前端实现事件收集。
- en: Collecting events on the frontend
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在前端收集事件
- en: 'After defining the route, let’s create the API function for the frontend and
    define a way to track when a user started and ended viewing a post. Follow these
    steps to collect events on the frontend:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义好路由之后，让我们为前端创建一个API函数，并定义一种跟踪用户何时开始和结束查看帖子的方法。按照以下步骤在前端收集事件：
- en: 'Create a new **src/api/events.js** file and define a **postTrackEvent** function,
    which takes an event object and sends it to the previously defined route:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/api/events.js** 文件，并定义一个 **postTrackEvent** 函数，它接受一个事件对象并将其发送到之前定义的路由：
- en: '[PRE13]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Edit **src/pages/ViewPost.jsx** and import the **useEffect**, **useState**,
    and **useMutation** hooks:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/pages/ViewPost.jsx** 并导入 **useEffect**、**useState** 和 **useMutation**
    钩子：
- en: '[PRE14]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Additionally, import the **postTrackEvent** API function:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，导入 **postTrackEvent** API函数：
- en: '[PRE15]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, inside the **ViewPost** function, define a new state hook to store the
    session ID, and a mutation to track the events. When an event is successfully
    tracked, we get a session ID from the backend. We store this in the state hook:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 **ViewPost** 函数内部，定义一个新的状态钩子来存储会话ID，以及一个突变来跟踪事件。当事件成功跟踪后，我们从后端获取会话ID，并将其存储在状态钩子中：
- en: '[PRE16]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, define a new effect hook in which we track a **startView** event a second
    after the user opened the post (to prevent tracking accidental events, such as
    from quick refreshes), and an **endView** event when the effect hook unmounts.
    We give it no dependencies to ensure the effect hook is only triggered when the
    page mounts and unmounts:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个新的效果钩子，在用户打开帖子后一秒跟踪一个**startView**事件（以防止跟踪意外事件，例如快速刷新），当效果钩子卸载时跟踪**endView**事件。我们不给它任何依赖项，以确保效果钩子仅在页面挂载和卸载时触发：
- en: '[PRE17]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Start the frontend as follows (and keep it running for future development):'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤启动前端（并保持运行以供未来开发使用）：
- en: '[PRE18]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you now open a post in your browser and take a look at the `startView` event
    is tracked. When we navigate away from the page, the `endView` event is tracked.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在在浏览器中打开一个帖子并查看是否跟踪了`startView`事件。当我们离开页面时，会跟踪`endView`事件。
- en: Let’s now move on to simulating events so that we have more data to aggregate
    and visualize later.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在继续模拟事件，以便我们以后有更多数据可以聚合和可视化。
- en: Simulating events
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟事件
- en: Simulating events is a great way to generate sample data to be used for testing
    the aggregations and visualizations. In our simulation, we first clear all current
    users from the database and then create a set of sample users. We repeat the same
    process for posts, and then for events, simulating that a random user creates
    a post and that someone views a random post for a random amount of time.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟事件是生成用于测试聚合和可视化的样本数据的好方法。在我们的模拟中，我们首先从数据库中清除所有当前用户，然后创建一组样本用户。我们对帖子重复相同的步骤，然后对事件进行模拟，模拟一个随机用户创建帖子，以及有人随机查看随机帖子一段时间。
- en: 'Follow these steps to implement a simulation:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现模拟：
- en: 'First of all, we should change the database to avoid losing any data we previously
    created in the other chapters. Edit **backend/.env** and change the following
    line from **blog** to **blog-simulated**:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们应该更改数据库以避免丢失我们在其他章节中创建的任何数据。编辑**backend/.env**并将以下行从**blog**更改为**blog-simulated**：
- en: '[PRE19]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, create a new **backend/simulateEvents.js** file, in which we import **dotenv**,
    the **initDatabase** function, and all the relevant models and service functions:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个新的**backend/simulateEvents.js**文件，在其中我们导入**dotenv**、**initDatabase**函数以及所有相关的模型和服务函数：
- en: '[PRE20]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Define a start time for the simulation, which here is set to 30 days ago (30
    days * 24 hours * 60 minutes * 60 seconds * 1000 milliseconds), and an end time,
    which is now:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义模拟的开始时间，这里设置为30天前（30天 * 24小时 * 60分钟 * 60秒 * 1000毫秒），以及结束时间，即现在：
- en: '[PRE21]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We also define the number of users, posts, and views to simulate:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还定义了要模拟的用户、帖子数和查看次数：
- en: '[PRE22]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, define the **simulateEvents** function, in which we first initialize
    the database:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义**simulateEvents**函数，在其中我们首先初始化数据库：
- en: '[PRE23]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, *delete* all existing users and create new users by initializing an empty
    array with the number of users to be simulated and mapping over it:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，*删除*所有现有用户，并通过初始化一个包含要模拟的用户数的空数组并映射它来创建新用户：
- en: '[PRE24]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Info
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The **Array(X)** function can be used to create an array with **X** entries,
    which then needs to be filled with an initial value before it can be iterated
    over.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**Array(X)**函数可以用来创建一个包含**X**个条目的数组，然后需要用初始值填充它，才能对其进行迭代。'
- en: 'Now, repeat the same process for posts:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为帖子重复相同的步骤：
- en: '[PRE25]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Info
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: We use **Math.floor(Math.random() * maxNumber)** to create a random integer
    between **0** and **maxNumber** (non-inclusive), which is perfect to be used for
    indexing an array.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**Math.floor(Math.random() * maxNumber)**来创建一个介于**0**和**maxNumber**（不包括**maxNumber**）之间的随机整数，这对于索引数组是完美的。
- en: 'Lastly, we repeat the same for events:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们对事件重复相同的步骤：
- en: '[PRE26]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we start the session at a random time within the defined simulation dates:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们在定义的模拟日期内随机开始会话：
- en: '[PRE27]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And we end it randomly after 0 to 5 minutes:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们随机在0到5分钟之后结束：
- en: '[PRE28]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we simulate the event collection, first by creating a **startView** event:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们通过创建一个**startView**事件来模拟事件收集：
- en: '[PRE29]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And then we simulate an **endView** event, where we use the session ID returned
    from the first event:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们模拟一个**endView**事件，其中我们使用从第一个事件返回的会话ID：
- en: '[PRE30]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Lastly, we disconnect from the database and call the function:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们从数据库断开连接并调用函数：
- en: '[PRE31]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Our simulation is now ready to be used! Execute the following command to start
    it:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的模拟现在已准备好使用！执行以下命令以启动它：
- en: '[PRE32]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You will see that the simulation first creates 5 users, then 10 posts, and finally
    simulates 10,000 views.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到模拟首先创建5个用户，然后是10个帖子，最后模拟了10,000次查看。
- en: In the next section, we are going to use this dataset to try out some aggregations
    with MongoDB!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用这个数据集来尝试使用 MongoDB 进行一些聚合操作！
- en: Aggregating data with MongoDB
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MongoDB 聚合数据
- en: Sometimes, we do not just want to simply retrieve data from the database, but
    instead, we want to create some statistics from the data by combining and summarizing
    it. This process is called **data aggregation**, and it can help us understand
    more about the data. For example, we can count the total number of views per post,
    get the number of daily views per post, or calculate the average session duration
    when viewing a post.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们不仅仅想要简单地从数据库中检索数据，而是想要通过组合和汇总数据来创建一些统计数据。这个过程称为 **数据聚合**，它可以帮助我们更好地了解数据。例如，我们可以计算每篇帖子的总浏览量，获取每篇帖子的每日浏览量，或者计算查看帖子时的平均会话时长。
- en: 'MongoDB supports a special aggregation syntax using the `.aggregate()` function
    on a collection. Using this aggregation functionality from MongoDB allows us to
    efficiently query and process documents. The operations it provides are similar
    to what can be done with **Structured Query Language** (**SQL**) queries. Mainly,
    we are going to use the following aggregation operations:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 支持使用集合上的 `.aggregate()` 函数进行特殊聚合语法。使用 MongoDB 的聚合功能允许我们高效地查询和处理文档。它提供的操作类似于可以使用
    **结构化查询语言**（**SQL**）查询完成的操作。我们主要将使用以下聚合操作：
- en: '**$match**: Used to filter documents'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$match**：用于过滤文档'
- en: '**$group**: Used to group documents by a certain property'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$group**：用于按某个属性对文档进行分组'
- en: '**$project**: Used to map properties to different properties, or process them'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$project**：用于将属性映射到不同的属性，或对其进行处理'
- en: '**$sort**: Used to sort documents'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$sort**：用于对文档进行排序'
- en: Info
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: MongoDB provides many more advanced aggregation operations, all of which can
    be found in their documentation ([https://www.mongodb.com/docs/manual/aggregation/](https://www.mongodb.com/docs/manual/aggregation/)).
    They are also constantly adding more operations to make aggregation even more
    powerful.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 提供了许多更高级的聚合操作，所有这些都可以在他们的文档中找到（[https://www.mongodb.com/docs/manual/aggregation/](https://www.mongodb.com/docs/manual/aggregation/))。他们也在不断添加更多操作，使聚合功能更加强大。
- en: The `aggregate` function works by providing an array of objects, each of which
    defines a **stage** of the **aggregation pipeline**. We are going to learn more
    about aggregations in this chapter by using them in practice.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`aggregate` 函数通过提供一个对象数组来工作，每个对象定义了 **聚合管道** 的一个 **阶段**。我们将通过实际使用它们来学习本章中的聚合，以了解更多关于聚合的信息。'
- en: Getting the total number of views per post
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取每篇帖子的总浏览量
- en: The first aggregation that we are going to define is a way to get the total
    number of views per post. For such an aggregation, we are going to need `$match`
    to filter all `startView` actions (otherwise we would be counting views twice,
    because there is also an `endView` action for each blog post view), and `$group`
    to group the results by post ID and then return the number of documents using
    `$count`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要定义的第一个聚合是获取每篇帖子的总浏览量的方法。对于这样的聚合，我们需要 `$match` 来过滤所有 `startView` 动作（否则我们会重复计算浏览量，因为每个博客帖子的查看都有一个
    `endView` 动作），以及 `$group` 来按帖子 ID 分组结果，然后使用 `$count` 返回文档数量。
- en: 'Follow these steps to create your first aggregation pipeline:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建您的第一个聚合管道：
- en: Create a new **backend/playground/** folder for our playground scripts.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的游乐场脚本创建一个新的 **backend/playground/** 文件夹。
- en: Click on the MongoDB extension (the leaf icon) in the VS Code sidebar.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 的侧边栏中点击 MongoDB 扩展（叶子图标）。
- en: Connect to the database, then expand the **Playgrounds** section (if it is not
    expanded already), and click on the **Create New** **Playground** button.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到数据库，然后展开 **Playgrounds** 部分（如果尚未展开），然后点击 **创建新** **Playground** 按钮。
- en: A new file will open up with some code already predefined for us. *Delete* all
    predefined code, as we are going to *replace* it with our own.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将打开一个新文件，其中已经预定义了一些代码。*删除*所有预定义的代码，因为我们将要*替换*它们为我们自己的代码。
- en: 'First, define the **use** and **db** globals, which the MongoDB Playground
    provides for us:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，定义 **use** 和 **db** 全局变量，MongoDB 游乐场为我们提供了这些变量：
- en: '[PRE33]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, use the **blog-simulated** database:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 **blog-simulated** 数据库：
- en: '[PRE34]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, execute the following aggregation function:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，执行以下聚合函数：
- en: '[PRE35]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The first stage of the pipeline will be matching all **startView** actions:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管道的第一阶段将是匹配所有 **startView** 动作：
- en: '[PRE36]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, we group by post. The **$group** stage requires us to define an **_id**,
    which contains the property to be grouped by. We need to use the **$** operator
    to resolve the variable to be used, so **$post** will access the **event.post**
    property (which contains a post ID):'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们按 post 进行分组。**$group** 阶段要求我们定义一个 **_id**，它包含要分组的属性。我们需要使用 **$** 操作符来解析要使用的变量，因此
    **$post** 将访问 **event.post** 属性（它包含一个帖子 ID）：
- en: '[PRE37]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Save the script as a **backend/playground/views-per-post.mongodb.js** file.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本保存为 **backend/playground/views-per-post.mongodb.js** 文件。
- en: 'Click on the **Play** icon at the top right to run the script. A new tab will
    open with the results of the aggregation:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右上角的 **Play** 图标来运行脚本。将打开一个新标签页，显示聚合的结果：
- en: '![Figure 10.1 – Our first MongoDB aggregation result!](img/B19385_10_1.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 我们第一个 MongoDB 聚合结果！](img/B19385_10_1.jpg)'
- en: Figure 10.1 – Our first MongoDB aggregation result!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 我们第一个 MongoDB 聚合结果！
- en: After creating and executing our first simple aggregation, let’s continue practicing
    by writing more advanced aggregations.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建和执行了我们的第一个简单聚合之后，让我们通过编写更高级的聚合来继续练习。
- en: Getting the number of daily views per post
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取每帖每日的查看次数
- en: 'Now that we are already familiar with the general process of writing MongoDB
    aggregations, let’s try writing a bit more complicated aggregation: getting the
    number of daily views per post. Follow these steps to create it:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经熟悉了编写 MongoDB 聚合的一般过程，让我们尝试编写一个更复杂的聚合：获取每帖每日的查看次数。按照以下步骤创建它：
- en: 'Create a new playground file, as before, with the following aggregation function:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，创建一个新的 playground 文件，使用以下聚合函数：
- en: '[PRE38]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Again, we first match only the **startView** actions:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们首先匹配只有 **startView** 动作：
- en: '[PRE39]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then we use **$project** to keep the **post** property, and define a new **day**
    property, which uses the **$dateTrunc** function to simplify the **date** property
    to only cover days (instead of containing the full timestamp):'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用 **$project** 保留 **post** 属性，并定义一个新的 **day** 属性，它使用 **$dateTrunc** 函数将
    **date** 属性简化为仅覆盖日期（而不是包含完整的时间戳）：
- en: '[PRE40]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: An important thing to keep in mind with `$project` is that only properties that
    are listed here will be passed on to further stages in the pipeline, so we need
    to list all properties that we are still going to need later here!
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在使用 `$project` 时需要注意的一个重要事项是，只有这里列出的属性才会传递到管道中的后续阶段，因此我们需要在这里列出我们稍后仍然需要的所有属性！
- en: 'Finally, we use **$group** to group the documents by **post** and **day** by
    passing an object to the **_id** property. We use **$count** again to count the
    number of documents in each group:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用 **$group** 来通过传递一个对象到 **_id** 属性，按 **post** 和 **day** 对文档进行分组。我们再次使用
    **$count** 来计算每个组中的文档数量：
- en: '[PRE41]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Save the script as a **backend/playground/views-per-post-per-day.mongodb.js**
    file.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本保存为 **backend/playground/views-per-post-per-day.mongodb.js** 文件。
- en: 'Run this script by clicking on the **Play** button and you will see that we
    are now getting a list of documents grouped by post and day, and the corresponding
    number of views of a certain post on a certain day:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 **Play** 按钮运行此脚本，你会看到我们现在正在按 post 和 day 分组获取文档列表，以及某个特定日期某个特定帖子的相应查看次数：
- en: '![Figure 10.2 – Showing the number of views per post per day](img/B19385_10_2.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 每日每帖的查看次数](img/B19385_10_2.jpg)'
- en: Figure 10.2 – Showing the number of views per post per day
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 每日每帖的查看次数
- en: After getting the number of daily views per post, let’s continue practicing
    by calculating the average session duration.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取每帖每日的查看次数之后，让我们继续练习，计算平均会话持续时间。
- en: Calculating the average session duration
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算平均会话持续时间
- en: 'As you may remember, we are first sending a `startView` action, and then later
    an `endView` action, both of which have a separate `date`. Let’s use aggregations
    to group these two actions together into a single document, and then compute the
    duration of a session:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记，我们首先发送一个 `startView` 动作，然后稍后发送一个 `endView` 动作，这两个动作都有一个单独的 `date`。让我们使用聚合将这些两个动作组合成一个单独的文档，并计算会话的持续时间：
- en: 'Create a new playground file, and start writing an aggregation that first creates
    some new properties using **$project**, and keeps the **session** property, as
    we will need it later:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 playground 文件，并开始编写一个聚合，首先使用 **$project** 创建一些新的属性，并保留 **session** 属性，因为我们稍后会用到它：
- en: '[PRE42]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here, we are using the `$cond` operator to create a conditional (kind of like
    a ternary/if statement). It accepts an array with three elements: the first being
    a condition, the next a result if the condition matches, and lastly, a result
    if the condition does not match. In our case, we check whether the `action` property
    is `startView` (using the `$eq` operator). If true, then we set the date to the
    `startDate` property. Otherwise, we do not define the `startDate` property. Similarly,
    if the action is `endView`, we create an `endDate` property.'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `$cond` 操作符来创建一个条件（类似于三元/if语句）。它接受一个包含三个元素的数组：第一个是条件，接下来是条件匹配的结果，最后是条件不匹配的结果。在我们的例子中，我们检查
    `action` 属性是否为 `startView`（使用 `$eq` 操作符）。如果是真的，那么我们将日期设置为 `startDate` 属性。否则，我们不定义
    `startDate` 属性。同样，如果操作是 `endView`，我们创建一个 `endDate` 属性。
- en: 'Now, we can group the documents by the session ID and select the lowest start
    date and the highest end date of a session:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以按会话ID对文档进行分组，并选择会话的最低起始日期和最高结束日期：
- en: '[PRE43]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: There should only be one `startView` and `endView` action per session anyway,
    but we cannot guarantee this, so we need to aggregate them down into a single
    value!
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个会话应该只有一个 `startView` 和 `endView` 操作，但我们不能保证这一点，因此我们需要将它们聚合为一个单一值！
- en: 'Finally, we use **$project** again to rename the **_id** property to **session**,
    and calculate the **duration** by subtracting the **startDate** from the **endDate**:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们再次使用 **$project** 来将 **_id** 属性重命名为 **session**，并通过从 **endDate** 减去 **startDate**
    来计算 **duration**：
- en: '[PRE44]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Save the script as a **backend/playground/session-duration.mongodb.js** file.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本保存为 **backend/playground/session-duration.mongodb.js** 文件。
- en: 'Run the script and you will see a list of documents with a session ID and a
    corresponding duration in milliseconds:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本，您将看到包含会话ID和相应毫秒数的持续时间的一个文档列表：
- en: '![Figure 10.3 – Aggregation result of the session durations](img/B19385_10_3.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 会话持续时间的聚合结果](img/B19385_10_3.jpg)'
- en: Figure 10.3 – Aggregation result of the session durations
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 会话持续时间的聚合结果
- en: Now that we are more familiar with how data aggregation works in MongoDB, let’s
    implement similar aggregations in our backend!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对MongoDB中的数据聚合工作更加熟悉了，让我们在我们的后端实现类似的聚合！
- en: Implementing data aggregation in the backend
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在后端实现数据聚合
- en: For our backend, we are going to use very similar aggregation pipelines. However,
    we need to adjust them slightly, as we always want to get the data for a single
    post only. As such, we will first be using `$match` to filter our documents. This
    also ensures that the aggregation stays fast, even if we have millions of events
    in our database, because we are first filtering down to all events of a single
    post!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的后端，我们将使用非常相似的聚合管道。然而，我们需要稍作调整，因为我们总是只想获取单个帖子的数据。因此，我们首先将使用 `$match` 来过滤我们的文档。这也确保了即使我们的数据库中有数百万个事件，聚合操作也能保持快速，因为我们首先将所有事件过滤为单个帖子的所有事件！
- en: Defining aggregation service functions
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义聚合服务函数
- en: 'Follow these steps to implement the aggregation functions in the backend:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在后台实现聚合函数：
- en: 'Edit **backend/src/services/events.js** and define a new function to get the
    total number of views for a post. In this case, we can simplify our code by using
    the **countDocuments** function instead of the aggregate function:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **backend/src/services/events.js** 并定义一个新函数来获取帖子的总浏览次数。在这种情况下，我们可以通过使用 **countDocuments**
    函数而不是聚合函数来简化我们的代码：
- en: '[PRE45]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, define a new function to get the daily views of a post with a given ID.
    We now use the **$match** operation to only get the **startView** actions of a
    certain post:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义一个新函数来获取具有给定ID的帖子的每日浏览次数。我们现在使用 **$match** 操作来仅获取特定帖子的 **startView** 操作：
- en: '[PRE46]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, we use the **$group** operation in combination with **$dateTrunc** to
    get the views per day, just like we did before in the MongoDB Playground script:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用 **$group** 操作与 **$dateTrunc** 结合来获取每日的浏览次数，就像我们在MongoDB Playground脚本中之前所做的那样：
- en: '[PRE47]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Lastly, we use the **$sort** operation to sort the resulting documents by **_id**
    (which contains the day):'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用 **$sort** 操作来按 **_id**（包含天数）对结果文档进行排序：
- en: '[PRE48]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'For the last function, we use our session duration aggregation, but extend
    it a little bit to give the average duration per day. Again, we first need to
    match a post ID:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于最后一个函数，我们使用会话持续时间聚合，但稍作扩展以给出每天的平均持续时间。我们首先需要匹配一个帖子ID：
- en: '[PRE49]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, we use the same **$project** and **$group** operations to get the **session**,
    **startDate**, and **endDate**, just like we did before:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用相同的**$project**和**$group**操作来获取**session**、**startDate**和**endDate**，就像我们之前做的那样：
- en: '[PRE50]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we use the **$project** operation to get **day** from our **startDate**,
    like we did in the previous aggregation where we got the number of daily views
    of a post:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用**$project**操作从我们的**startDate**获取**day**，就像我们在之前的聚合中获取帖子每日观看次数时做的那样：
- en: '[PRE51]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We group the results per day, and calculate the average duration of a day:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们按日分组结果，并计算每日的平均时长：
- en: '[PRE52]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, we sort the results per day:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们按日排序结果：
- en: '[PRE53]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As we can see, aggregation pipelines are extremely powerful and allow us to
    do a lot of data processing directly in the database! In the next section, we
    are going to create routes for these aggregation functions.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，聚合管道非常强大，允许我们在数据库中直接进行大量数据处理！在下一节中，我们将为这些聚合函数创建路由。
- en: Defining the routes
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义路由
- en: 'Defining the routes is pretty straightforward; we simply check whether a post
    with the given ID exists, and if it does, we return the results from the corresponding
    aggregation service function. Let’s start defining the routes:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 定义路由相当直接；我们只需检查给定ID的帖子是否存在，如果存在，就返回相应聚合服务函数的结果。让我们开始定义路由：
- en: 'Edit **backend/src/routes/events.js** and import the **getTotalViews**, **getDailyViews**,
    and **getDailyDurations** functions:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**backend/src/routes/events.js**并导入**getTotalViews**、**getDailyViews**和**getDailyDurations**函数：
- en: '[PRE54]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, inside the **eventRoutes** function, define a new route for getting the
    total number of views of a post, as follows:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在**eventRoutes**函数内部，定义一个新的路由以获取帖子的总观看次数，如下所示：
- en: '[PRE55]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then define a similar route for the number of daily views of a post:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后定义一个类似的路由以获取帖子的每日观看次数：
- en: '[PRE56]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'And finally, define a route for the daily average viewing duration of a post:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义一个用于获取帖子每日平均观看时长的路由：
- en: '[PRE57]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now that we have successfully defined routes for our aggregation functions,
    it’s time to integrate them into the frontend and start visualizing the data we
    have been simulating and collecting!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功定义了聚合函数的路由，是时候将它们集成到前端并开始可视化我们所模拟和收集的数据了！
- en: Integrating and visualizing data on the frontend using Victory
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Victory在前端集成和可视化数据
- en: In this final section, we are going to integrate the aggregation endpoints we
    previously defined. Then, we are going to introduce the Victory library in the
    frontend to create graphs to visualize our aggregated data!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，我们将集成我们之前定义的聚合端点。然后，我们将在前端引入Victory库来创建图表以可视化我们的聚合数据！
- en: Integrating the aggregation API
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成聚合API
- en: 'First of all, we need to integrate the API routes in the frontend, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在前端集成API路由，如下所示：
- en: 'Edit the **src/api/events.js** file and add three new API functions to get
    the total views, daily views, and daily durations of a post:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/api/events.js**文件并添加三个新的API函数以获取帖子的总观看次数、每日观看次数和每日时长：
- en: '[PRE58]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create a new **src/components/PostStats.jsx** file, in which we are going to
    query these new API routes. Start by importing **useQuery**, **PropTypes**, and
    the three API functions:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**src/components/PostStats.jsx**文件，在其中我们将查询这些新的API路由。首先导入**useQuery**、**PropTypes**和三个API函数：
- en: '[PRE59]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Define a new component that takes a **postId** and fetches all the stats that
    we aggregated on the backend using query hooks:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的组件，它接受**postId**并使用查询钩子获取我们在后端聚合的所有统计数据：
- en: '[PRE60]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'While the stats are loading, we display a simple loading message:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当统计数据正在加载时，我们显示一个简单的加载消息：
- en: '[PRE61]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Once the stats are finished loading, we can display them. For now, we simply
    display the total number of views and the JSON responses from the other two API
    requests:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦统计数据加载完成，我们就可以显示它们。目前，我们只显示总观看次数和其他两个API请求的JSON响应：
- en: '[PRE62]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We still need to define the prop types for this component, as follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们仍然需要为此组件定义属性类型，如下所示：
- en: '[PRE63]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now we can render the **PostStats** component in our **ViewPost** page component.
    Edit **src/pages/ViewPost.jsx** and import the **PostStats** component there:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的**ViewPost**页面组件中渲染**PostStats**组件。编辑**src/pages/ViewPost.jsx**并导入**PostStats**组件：
- en: '[PRE64]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then, at the bottom of the component, render the stats as follows:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在组件底部，按照以下方式渲染统计数据：
- en: '[PRE65]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If you open a post on the frontend now (you may need to refresh the frontend
    if you see an error), you will see that all the stats are properly fetched! Now,
    all that’s left to do is visualize the daily stats using Victory!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在在前端打开一个帖子（如果您看到错误，可能需要刷新前端），您将看到所有统计数据都已正确获取！现在，剩下的就是使用 Victory 可视化每日统计数据了！
- en: Visualizing data using Victory
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Victory 可视化数据
- en: Victory is a React library that provides modular components that can be used
    to create charts and all kinds of data visualizations. It even supports interactive
    visualization tools, such as brushing and grouping (where you, for example, select
    a certain section of a graph to more closely inspect it on other graphs). In this
    chapter, we are only going to scratch the surface of what Victory can do, as data
    visualization in React is a big topic on its own.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Victory 是一个 React 库，它提供模块化组件，可用于创建图表和各种数据可视化。它甚至支持交互式可视化工具，例如刷选和分组（例如，您可以选择图表的某个部分，以便在其他图表上更仔细地检查它）。在本章中，我们只将触及
    Victory 能做什么的皮毛，因为 React 中的数据可视化本身就是一个很大的主题。
- en: 'You can find more information about Victory on their official website: [https://commerce.nearform.com/open-source/victory/](https://commerce.nearform.com/open-source/victory/)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在他们的官方网站上找到有关 Victory 的更多信息：[https://commerce.nearform.com/open-source/victory/](https://commerce.nearform.com/open-source/victory/)
- en: Creating a bar chart
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建柱状图
- en: 'Let’s get started visualizing our data using Victory now:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始使用 Victory 可视化我们的数据：
- en: 'Install the library by executing the following command in the root of the project:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录中执行以下命令来安装库：
- en: '[PRE66]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Edit **src/components/PostStats.jsx** and import the following components from
    Victory:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/components/PostStats.jsx** 并从 Victory 导入以下组件：
- en: '[PRE67]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '*Replace* the **<pre>** tags at the end of the component with the following
    charts, starting with the daily views chart:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*替换* 组件末尾的 **<pre>** 标签，开始使用以下图表，首先是每日观看时长图表：'
- en: '[PRE68]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, define a bar chart with **VictoryBar**, using **VictoryTooltip** to display
    the labels:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 **VictoryBar** 定义一个柱状图，并使用 **VictoryTooltip** 显示标签：
- en: '[PRE69]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The tooltip looks like this:'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示信息看起来如下：
- en: '![Figure 10.4 – A tooltip on a bar chart in Victory](img/B19385_10_4.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – Victory 中柱状图上的提示信息](img/B19385_10_4.jpg)'
- en: Figure 10.4 – A tooltip on a bar chart in Victory
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – Victory 中柱状图上的提示信息
- en: 'Now we get to the most important part, the data. Here, we map over our **dailyViews**
    data returned by the query hook to bring it into a format that Victory understands:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来到了最重要的部分，数据。在这里，我们遍历查询钩子返回的 **dailyViews** 数据，将其转换为 Victory 能够理解的格式：
- en: '[PRE70]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We map the **_id** property to the **x**-axis value (parsing it as a date),
    and the **views** property to the **y**-axis value:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 **_id** 属性映射到 **x**-轴值（将其解析为日期），并将 **views** 属性映射到 **y**-轴值：
- en: '[PRE71]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Then we create a label, where we turn the day into a local date string and
    then show the number of views on the given day:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建一个标签，其中我们将日期转换为本地日期字符串，然后显示给定日期的观看次数：
- en: '[PRE72]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We have successfully created our first visualization using Victory! The chart
    will now look as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功使用 Victory 创建了第一个可视化！图表现在将如下所示：
- en: '![Figure 10.5 – Our first chart in Victory – a bar chart!](img/B19385_10_5.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – Victory 中的第一个图表 – 一个柱状图！](img/B19385_10_5.jpg)'
- en: Figure 10.5 – Our first chart in Victory – a bar chart!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – Victory 中的第一个图表 – 一个柱状图！
- en: As you can see, Victory automatically formatted the dates for us and adjusted
    the axes to fit our chart into the allotted space!
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Victory 自动为我们格式化了日期，并调整了坐标轴以适应图表所占的空间！
- en: Let’s visualize the daily average viewing duration next.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们可视化每日平均观看时长。
- en: Creating a line chart
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建折线图
- en: 'Creating a line chart in Victory is pretty similar to creating a bar chart,
    with one exception: the tooltips. In line charts, we cannot use tooltips directly,
    as lines could theoretically be continuous (not discrete blocks of data), so it
    is unclear where to place the tooltip. Instead, we use a **Voronoi container**
    for displaying tooltips on line charts in Victory. The name Voronoi comes from
    mathematics, where a Voronoi diagram partitions a region into multiple sections.
    In simple terms, the Voronoi container makes an intersection between the mouse
    position and the line chart, gets the data from that intersection point, and then
    displays a tooltip there.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在Victory中创建折线图与创建柱状图非常相似，唯一的区别是工具提示。在折线图中，我们无法直接使用工具提示，因为线条在理论上可能是连续的（而不是离散的数据块），所以不清楚工具提示应该放在哪里。相反，我们在Victory中为折线图使用**Voronoi容器**来显示工具提示。Voronoi这个名字来源于数学，其中Voronoi图将区域划分为多个部分。简单来说，Voronoi容器在鼠标位置和折线图之间创建一个交点，从该交点获取数据，然后在那里显示工具提示。
- en: 'With that in mind, let’s now get started creating the line chart for the daily
    average viewing duration:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们现在开始创建每日平均观看时长的折线图：
- en: 'Edit **src/components/PostStats.jsx** and continue where we left off with the
    other chart, adding a new **VictoryChart** after the container of the bar chart:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/components/PostStats.jsx**，并继续处理其他图表，在柱状图的容器之后添加一个新的**VictoryChart**：
- en: '[PRE73]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In the **VictoryChart** component, we now define **containerComponent**, which
    will contain our **VictoryVoronoiContainer**:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**VictoryChart**组件中，我们现在定义**containerComponent**，它将包含我们的**VictoryVoronoiContainer**：
- en: '[PRE74]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We defined it to only intersect with the values on the `x`-axis, meaning that
    the mouse pointer will only intersect with the days on our chart.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将其定义为仅与`x`轴上的值相交，这意味着鼠标指针将仅与图表上的日期相交。
- en: 'We can now define labels for our container, using the **datum** property to
    get the data entry that intersects with the mouse pointer to create a label. Our
    label should display the current date and the viewing duration in minutes, fixed
    to two decimal points:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用**datum**属性定义容器的标签，以获取与鼠标指针相交的数据条目来创建标签。我们的标签应显示当前日期和分钟数，固定到小数点后两位：
- en: '[PRE75]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Again, we use **VictoryTooltip** to display these labels:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们使用**VictoryTooltip**来显示这些标签：
- en: '[PRE76]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now we can finally define the **VictoryLine** chart, in which we map the data
    again, parsing dates and dividing the average duration to convert it from milliseconds
    to minutes:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以最终定义**VictoryLine**图表，在其中再次映射数据，解析日期并将平均持续时间从毫秒转换为分钟：
- en: '[PRE77]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'As you can see, the rest was pretty simple and similar to creating the bar
    chart! It looks as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，其余部分相当简单，类似于创建柱状图！它看起来如下：
- en: '![Figure 10.6 – A line chart using Victory, displaying the daily average viewing
    duration of a post!](img/B19385_10_6.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 使用Victory创建的折线图，显示帖子的每日平均观看时长](img/B19385_10_6.jpg)'
- en: Figure 10.6 – A line chart using Victory, displaying the daily average viewing
    duration of a post!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 使用Victory创建的折线图，显示帖子的每日平均观看时长
- en: 'As you can see, Victory is a pretty powerful library for creating charts with
    React, and we have only scratched the surface of what it can do! You can still
    customize the theme of the charts and create all sorts of complex visualizations.
    In this chapter, however, we focused on the most essential and widely used charts:
    bar and line charts.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Victory是一个相当强大的库，用于使用React创建图表，而我们只是触及了它所能做到的一小部分！您仍然可以自定义图表的主题并创建各种复杂的可视化。然而，在本章中，我们专注于最基本且最广泛使用的图表：柱状图和折线图。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about tracking events using our backend and frontend.
    Then, we simulated events to be used as a sample dataset for our aggregations
    and visualizations. Next, we learned how to aggregate data with MongoDB using
    the MongoDB Playground. Then, we implemented data aggregation functions in our
    backend. Finally, we integrated and visualized the data on the frontend using
    Victory.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了使用后端和前端跟踪事件。然后，我们模拟事件作为样本数据集用于我们的聚合和可视化。接下来，我们学习了如何使用MongoDB Playground使用MongoDB进行数据聚合。然后，我们在后端实现了数据聚合函数。最后，我们使用Victory在前端集成并可视化数据。
- en: In the next chapter, [*Chapter 11*](B19385_11.xhtml#_idTextAnchor213), *Building
    a Backend with a GraphQL API*, we are going to learn how to use an alternative
    to REST, called GraphQL, to query deeply nested objects more easily.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[*第11章*](B19385_11.xhtml#_idTextAnchor213)，*使用GraphQL API构建后端*，我们将学习如何使用REST的替代方案，即GraphQL，以便更轻松地查询深层嵌套的对象。
