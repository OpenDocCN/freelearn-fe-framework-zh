- en: Chapter 11. Optimization Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 优化模式
- en: This chapter presents several optimization techniques that can be used to improve
    the performance of jQuery applications, especially when they become large and
    complex.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了几种优化技术，可用于改善jQuery应用程序的性能，特别是当它们变得庞大和复杂时。
- en: We will start with simple practices like bundling and minifying our JavaScript
    files and discuss the benefits of using **CDN**s to load third-party libraries.
    We will then move on to analyze some simple patterns for writing efficient JavaScript
    code and learn how to write efficient CSS selectors in order to improve the page's
    rendering speed and DOM traversals using jQuery.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从捆绑和最小化我们的JavaScript文件等简单实践开始，并讨论使用**CDN**加载第三方库的好处。然后，我们将继续分析一些简单的编写高效JavaScript代码的模式，并学习如何编写高效的CSS选择器，以提高页面的渲染速度和使用jQuery进行DOM遍历。
- en: We will then study jQuery-specific practices such as the caching of jQuery Composite
    Collection Objects, how to minimize DOM manipulations, and have a reminder of
    the **Delegate Observer Pattern** as a good example of the **Flyweight Pattern**.
    Lastly, we will get an introduction to the advanced technique of **Lazy Loading**
    and have a demonstration of how to load the different modules of an implementation
    progressively, based on user actions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将研究特定于jQuery的实践，如缓存jQuery复合集合对象，如何最小化DOM操作，并将**委托观察者模式**作为**享元模式**的一个好例子。最后，我们将介绍**惰性加载**的高级技术，并演示如何根据用户操作逐步加载实施的不同模块。
- en: By the end of this chapter, we will be able to apply the most common optimization
    patterns to our implementations and use this chapter as a checklist of best practices
    and performance tips before moving the application to a production environment.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将能够在实施中应用最常见的优化模式，并将本章用作将应用程序移至生产环境之前的最佳实践和性能提示的检查表。
- en: 'In this chapter, we shall:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn the benefits of bundling and minifying our JavaScript files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习捆绑和最小化我们的JavaScript文件的好处
- en: Learn how to load third-party libraries through the CDN server
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何通过CDN服务器加载第三方库
- en: Learn some simple JavaScript performance tips
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习一些简单的JavaScript性能提示
- en: Learn how to optimize our jQuery code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何优化我们的jQuery代码
- en: Introduce the Flyweight pattern and showcase some examples of it
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍享元模式并展示一些例子
- en: Learn how to lazyload parts of our application when required by a user action
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习在用户操作时如何按需惰性加载我们应用的部分
- en: Placing scripts near the end of the page
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将脚本放置在页面末尾
- en: The first tip for making your page's initial rendering faster is to gather all
    the required JavaScript files and place their `<script>` tags near the end of
    the page, preferably just before the closing `</body>` tag. This change will have
    a great impact on the time needed for the initial rendering of the page, especially
    for users with low speed connections such as mobile users. If you are already
    using the `$(document).ready()` method for all initialization purposes that relate
    to the DOM, moving the `<script>` tags around should not affect the functionality
    of your implementation at all.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 提高页面初始渲染速度的第一个提示是收集所有所需的JavaScript文件，并将它们的`<script>`标签置于页面末尾，最好就在关闭`</body>`标签之前。这个改变会对页面的初始渲染时间产生很大的影响，特别是对于使用低速连接的用户（如移动用户）。如果您已经为所有与DOM相关的初始化目的使用了`$(document).ready()`方法，将`<script>`标签移动到其他位置不会对您的实施功能产生任何影响。
- en: The main reason for this is that, even though browsers download the page's HTML
    and other resources (CSS, images, and so on) in parallel, when a `<script>` tag
    is encountered, the browser pauses everything else until it is downloaded and
    executed. In order to work around this limitation of the specification, attributes
    like `defer` and `async` from HTLM5 have been introduced as parts of the `<script>`
    tag specification but unfortunately have only started to be adopted by some browsers
    recently. As a result, this practice is still widely used to obtain good page
    loading speeds even on older browsers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 其主要原因是，即使浏览器并行下载页面的HTML和其他资源（CSS、图像等），当遇到`<script>`标签时，浏览器会暂停一切，直到它被下载和执行。为了解决规范的这一限制，HTML5引入了`defer`和`async`等属性作为`<script>`标签规范的一部分，但不幸的是，直到最近才开始被一些浏览器采用。因此，即使在旧版浏览器上仍广泛使用这种做法来获得良好的页面加载速度。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注：
- en: 'For more information about the `<script>` tag you can visit: [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`<script>`标签的更多信息，请访问：[https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script)
- en: Bundling and minifying resources
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捆绑和缩小资源
- en: The first place to look when trying to make a page load faster is for ways to
    reduce the number and total size of HTTP requests. The benefits come from the
    fact that the browser downloads the content in larger chunks instead of spending
    time waiting for a lot of small round-trips to the server to complete. This is
    especially beneficial for users with low speed connections such as mobile users.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要使页面加载速度更快，首先要寻找减少 HTTP 请求的数量和总大小的方法。好处在于浏览器下载内容时可以更大块地下载，而不是花时间等待许多小的往返请求完成。这对于低速连接的用户（如移动用户）尤其有益。
- en: Resource concatenation is a simple concept that does not need any introduction.
    This can be done manually but it is preferable to automate this task with a bundling
    script or introduce a build step for your project. Depending on your development
    environment, there are different bundling solutions to choose from. If you are
    using **grunt** or **gulp** as part of your development stack, you can use solutions
    like `grunt-contrib-concat` ([https://github.com/gruntjs/grunt-contrib-concat](https://github.com/gruntjs/grunt-contrib-concat))
    and `gulp-concat` ([https://github.com/contra/gulp-concat](https://github.com/contra/gulp-concat))
    respectively.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 资源串联是一个简单的概念，无需任何介绍。这可以手动完成，但最好用捆绑脚本自动化此任务，或者为项目引入一个构建步骤。根据您的开发环境，有不同的捆绑解决方案可供选择。如果您在开发栈中使用**grunt**或**gulp**，您可以使用像`grunt-contrib-concat`（[https://github.com/gruntjs/grunt-contrib-concat](https://github.com/gruntjs/grunt-contrib-concat)）和`gulp-concat`（[https://github.com/contra/gulp-concat](https://github.com/contra/gulp-concat)）这样的解决方案。
- en: 'Minifying JavaScript files is a more complex procedure which includes a series
    of code transformations that are applied to the target source code, ranging from
    something as simple as white space removal to more complex tasks like variable
    renaming. Popular solutions for minifying JavaScript include:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 缩小 JavaScript 文件是一个更复杂的过程，包括一系列应用于目标源代码的代码转换，从简单的空格删除到更复杂的任务如变量重命名。流行的缩小 JavaScript
    的解决方案包括：
- en: YUI Compressor available at [http://yui.github.io/yuicompressor/](http://yui.github.io/yuicompressor/)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YUI 压缩器可在[http://yui.github.io/yuicompressor/](http://yui.github.io/yuicompressor/)找到。
- en: Google's Closure Compiler available at [https://developers.google.com/closure/compiler/](https://developers.google.com/closure/compiler/)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谷歌的闭包编译器可在[https://developers.google.com/closure/compiler/](https://developers.google.com/closure/compiler/)找到。
- en: UglifyJS available at [https://github.com/mishoo/UglifyJS2](https://github.com/mishoo/UglifyJS2)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UglifyJS 可在[https://github.com/mishoo/UglifyJS2](https://github.com/mishoo/UglifyJS2)找到。
- en: Once again, various solutions exist that integrate the above libraries nicely
    with your preferred development environment and make minification a simple task.
    Examples of integrations for grunt and gulp include `grunt-contrib-uglify` ([https://github.com/gruntjs/grunt-contrib-uglify](https://github.com/gruntjs/grunt-contrib-uglify))
    and `gulp-uglify` ([https://github.com/terinjokes/gulp-uglify](https://github.com/terinjokes/gulp-uglify))
    respectively.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，有各种解决方案可以很好地将上述库与您喜欢的开发环境集成，使缩小成为一个简单的任务。例如，grunt 和 gulp 的集成示例包括`grunt-contrib-uglify`（[https://github.com/gruntjs/grunt-contrib-uglify](https://github.com/gruntjs/grunt-contrib-uglify)）和`gulp-uglify`（[https://github.com/terinjokes/gulp-uglify](https://github.com/terinjokes/gulp-uglify)）。
- en: As a final word, keep in mind that your code should be as readable and as logically
    structured as possible. Bundling and minifying your JavaScript and CSS files is
    most effectively done as a build step of your development and deployment procedures.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的建议，要记住，你的代码应该尽可能地易读和逻辑结构清晰。将 JavaScript 和 CSS 文件进行捆绑和缩小，最有效的方法是作为开发和部署过程的构建步骤来完成。
- en: Using IIFE parameters
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 IIFE 参数
- en: Apart from helping to avoid polluting the global namespace, using IIFEs to wrap
    your implementation can also be beneficial for the size of your minified JavaScript
    files. Let's take a look at the following code in which the `jQuery`, the `window`,
    and the `document` variables are passed as invocation parameters to the module's
    IIFE.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了有助于避免污染全局命名空间之外，使用 IIFE 来包装您的实现也对缩小后的 JavaScript 文件大小有益。让我们看看下面的代码，其中`jQuery`、`window`和`document`变量作为调用参数传递到模块的
    IIFE 中。
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We saw a similar pattern in the previous chapter, as part of the suggested
    template for creating jQuery plugins. Even though the variable aliasing does not
    affect the functionality of the implementation, it allows the code minifiers to
    apply variable renaming in more places than before, resulting in code like the
    following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中看到了类似的模式，作为创建jQuery插件的建议模板的一部分。尽管变量别名不影响实现的功能，但它允许代码最小化器在更多地方应用变量重命名，导致以下代码：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see in the above code, all the invocation parameters of the IIFE
    were renamed by the minifier to single letter identifiers, which increases the
    gains of the minification especially if the original identifiers are used in several
    places.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上面的代码中可以看到的，所有IIFE的调用参数都被缩小器重命名为单个字母标识符，这尤其增加了最小化的收益，特别是如果原始标识符在多个地方使用。
- en: Tip
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As an added benefit, aliasing also protects our modules from the case that the
    original variables get accidentally assigned a different value. For example, when
    IIFE parameters are not used, an assignment like `$ = {}` or `undefined = 7` from
    within a different module would break all the implementation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 作为附加好处，别名还可以保护我们的模块，防止原始变量意外赋予不同的值。例如，当IIFE参数未被使用时，来自不同模块的赋值，如`$ = {}`或`undefined
    = 7`，会破坏所有实现。
- en: Using CDNs
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CDN
- en: 'Instead of serving all of the JavaScript and CSS files of the third-party libraries
    from your web server, you should consider using a **Content Delivery Network**
    (**CDN**). Using a CDN to serve the static files of the libraries that are used
    by your website can make it load faster since:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 不要从您的网站服务器提供所有的第三方库的JavaScript和CSS文件，您应该考虑使用**内容交付网络**（**CDN**）。使用CDN来提供您的网站所使用的库的静态文件可以使它加载更快，因为：
- en: CDNs have high speed connections and several caching levels.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CDN具有高速连接和多个缓存级别。
- en: CDNs have many geographically distributed servers that can deliver the requested
    files faster since they are closer to the end user.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CDN有许多地理分布的服务器，可以更快地传送所请求的文件，因为它们离最终用户更近。
- en: CDNs help parallelize resource requests, since most browsers can only download
    up to four resources concurrently from any specific domain.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CDN有助于并行化资源请求，因为大多数浏览器只能同时从任何特定域下载最多四个资源。
- en: Moreover, if a user has static resources cached from a previous visit to another
    website that uses the same CDN, he or she will not have to download them again,
    reducing the time that your site needs to load.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，如果用户从使用相同CDN的另一个网站上缓存了静态资源，他或她将不必再次下载它们，减少了您的网站需要加载的时间。
- en: 'Below is a list with the most widely used CDNs for JavaScript libraries which
    you can use in your implementations:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用JavaScript库的最广泛使用的CDN列表，您可以在您的实现中使用它们：
- en: '[https://code.jquery.com/](https://code.jquery.com/)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://code.jquery.com/](https://code.jquery.com/)'
- en: '[https://developers.google.com/speed/libraries/](https://developers.google.com/speed/libraries/)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/speed/libraries/](https://developers.google.com/speed/libraries/)'
- en: '[https://cdnjs.com/](https://cdnjs.com/)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://cdnjs.com/](https://cdnjs.com/)'
- en: '[http://www.jsdelivr.com/](http://www.jsdelivr.com/)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.jsdelivr.com/](http://www.jsdelivr.com/)'
- en: Using JSDelivr API
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JSDelivr API
- en: A newcomer to the CDN world is JSDelivr, which is gaining popularity because
    of its unique features. Beyond simply serving existing static files, JSDelivr
    provides an API ([https://github.com/jsdelivr/api](https://github.com/jsdelivr/api))
    that allows us to create and use custom bundles with the resources that we need
    to load, helping us to minimize the HTTP requests that our site needs. Moreover,
    its API allows us to target libraries with different levels of specificity (major,
    minor, or bug fix releases) and even allows us to load only specific parts of
    a library.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: CDN世界的新来者是JSDelivr，由于其独特的功能而备受欢迎。除了简单地提供现有的静态文件外，JSDelivr还提供一个API（[https://github.com/jsdelivr/api](https://github.com/jsdelivr/api)），允许我们创建和使用带有我们需要加载的资源的自定义捆绑包，帮助我们最小化网站所需的HTTP请求。此外，其API允许我们以不同级别的特定性（主要、次要或错误修复版本）定位库，甚至允许我们只加载库的特定部分。
- en: 'As an example, take a look at the following URL, which allows us to load the
    most recent bug fix releases of jQuery v1.11.x with a single request as well as
    some parts of jQuery-UI v1.10.x and Bootstrap v3.3.x: [http://cdn.jsdelivr.net/g/jquery@1.11,jquery.ui@1.10(jquery.ui.core.min.js+jquery.ui.widget.min.js+jquery.ui.mouse.min.js+jquery.ui.sortable.min.js),bootstrap@3.3](http://cdn.jsdelivr.net/g/jquery@1.11,jquery.ui@1.10(jquery.ui.core.min.js+jquery.ui.widget.min.js+jquery.ui.mouse.min.js+jquery.ui.sortable.min.js),bootstrap@3.3)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看一下以下URL，它允许我们使用单个请求加载jQuery v1.11.x的最新bug修复版本，以及jQuery-UI v1.10.x和Bootstrap
    v3.3.x的一些部分：[http://cdn.jsdelivr.net/g/jquery@1.11,jquery.ui@1.10(jquery.ui.core.min.js+jquery.ui.widget.min.js+jquery.ui.mouse.min.js+jquery.ui.sortable.min.js),bootstrap@3.3](http://cdn.jsdelivr.net/g/jquery@1.11,jquery.ui@1.10(jquery.ui.core.min.js+jquery.ui.widget.min.js+jquery.ui.mouse.min.js+jquery.ui.sortable.min.js),bootstrap@3.3)
- en: Optimizing common JavaScript code
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化常见的JavaScript代码
- en: In this section, we will analyze some performance tips that are not jQuery-specific
    and can be applied to most JavaScript implementations.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分析一些不特定于jQuery的性能提示，并且可以应用于大多数JavaScript实现。
- en: Writing better for loops
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写更好的for循环
- en: 'When iterating over the items of an array or an array-like collection with
    a `for` loop, a simple way to improve the performance of the iteration is to avoid
    accessing the `length` property on every loop. This can easily be done by storing
    the iteration `length` to a separate variable, declared just before the loop or
    even along with it, as shown below:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`for`循环遍历数组或类似数组的集合时，提高迭代性能的一个简单方法是避免在每个循环中访问`length`属性。可以通过将迭代`length`存储到一个单独的变量中，在循环之前声明，甚至与循环一起声明，如下所示：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Moreover, if we need to iterate over the items of an array that does not contain
    **falsy** values, we can use an even better pattern which is commonly applied
    for iterating over arrays that contain objects:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们需要迭代不包含**假值**的数组项，我们可以使用一个更好的模式，通常用于迭代包含对象的数组：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this case, instead of relying on the `length` property of the array, we
    exploit the fact that access to an out-of-bounds position of the array returns
    `undefined` which is falsy and stops the iteration. Another sample case that this
    trick can be used in is when iterating over **Node Lists** or jQuery Composite
    Collection Objects as shown below:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们利用了数组的超出边界位置返回`undefined`的事实，这是假值并且停止迭代。可以在迭代**节点列表**或jQuery复合集合对象时使用此技巧的另一个示例情况如下：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about the **truthy** and **falsy** JavaScript values,
    visit: [https://developer.mozilla.org/en-US/docs/Glossary/Truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy)
    and [https://developer.mozilla.org/en-US/docs/Glossary/Falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有关JavaScript中**真值**和**假值**的更多信息，请访问：[https://developer.mozilla.org/en-US/docs/Glossary/Truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy)
    和 [https://developer.mozilla.org/en-US/docs/Glossary/Falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)
- en: Writing performant CSS selectors
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写高性能的CSS选择器
- en: Even though **Sizzle** (jQuery's selector engine) hides the complexity of DOM
    traversals based on complex CSS selectors, we should have an idea of how our selectors
    are performing. Understanding how CSS selectors are matched against the elements
    of the DOM helps us write more efficient selectors which perform better when used
    with jQuery.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管**Sizzle**（jQuery的选择引擎）隐藏了基于复杂CSS选择器的DOM遍历的复杂性，我们应该了解我们的选择器是如何执行的。了解CSS选择器如何匹配DOM的元素可以帮助我们编写更有效的选择器，在与jQuery一起使用时性能更佳。
- en: The key characteristic of efficient CSS selectors is specificity. According
    to this, ID and Class selectors are always more efficient than selectors with
    many results like `div` and `*`. When writing complex CSS selectors, keep in mind
    that they are evaluated from the right to the left and that a selector gets rejected
    after recursively testing it against every parent element until the root of the
    DOM.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有效CSS选择器的关键特征是特异性。根据这一点，ID和类选择器总是比`div`和`*`这样结果较多的选择器更高效。在编写复杂的CSS选择器时，要记住它们是从右到左进行评估的，并且在递归测试每个父元素直到DOM根元素后，选择器将被拒绝。
- en: As a result, try to be as specific as possible with the rightmost selector in
    order to cut down the matched elements as quickly as possible during the execution
    of the selector.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在执行选择器期间，尽量使最右边的选择器尽可能具体，以尽快减少匹配的元素数量。
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The other performance tip is using the Child Selector ("parent > child") wherever
    applicable, in an effort to eliminate the recursion over all the hierarchy of
    the DOM tree. A great example where this can be applied is in cases where the
    target elements can be found at a specific descendant level of a common ancestor
    element:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个性能提示是在适用的地方使用子选择器（"parent > child"），以消除对 DOM 树层次结构的递归。一个极好的应用案例是目标元素可以在共同祖先元素的特定后代级别找到的情况：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The same tips can also be applied to CSS selectors that are used for styling
    pages. Even though browsers have been trying to optimize any given CSS selector,
    the tips described above can greatly reduce the time that is required to render
    a web page.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的技巧也适用于用于页面样式的 CSS 选择器。尽管浏览器一直在尝试优化任何给定的 CSS 选择器，上述技巧可以极大地减少渲染网页所需的时间。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on jQuery CSS selector performance, you can visit: [http://learn.jquery.com/performance/optimize-selectors/](http://learn.jquery.com/performance/optimize-selectors/)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 jQuery CSS 选择器性能的更多信息，您可以访问：[http://learn.jquery.com/performance/optimize-selectors/](http://learn.jquery.com/performance/optimize-selectors/)
- en: Writing efficient jQuery code
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写高效的 jQuery 代码
- en: 'Let''s now proceed and analyze the most important jQuery-specific performance
    tips. For more information about the most up-to-date performance tips on jQuery,
    keep an eye on the relevant page for jQuery''s Learning Center: [http://learn.jquery.com/performance](http://learn.jquery.com/performance)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续分析最重要的 jQuery 特定性能提示。有关 jQuery 最新性能提示的更多信息，请关注 jQuery 学习中心的相关页面：[http://learn.jquery.com/performance](http://learn.jquery.com/performance)
- en: Minimizing DOM traversals
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少 DOM 遍历
- en: Since jQuery made DOM traversals so simple, many web developers overused the
    `$()` function everywhere, even in subsequent lines of code, making their implementations
    slower by executing unnecessary code. One of the main reasons that the complexity
    of the operation is so often overlooked is the elegant and minimalistic syntax
    that jQuery uses. Despite the fact that JavaScript browser engines became many
    times faster in the last few years, with performance comparable to many compiled
    languages, the DOM API is still one of their slowest components and, as a result,
    developers have to minimize their interactions with it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 jQuery 使 DOM 遍历变得如此简单，许多 web 开发人员在每处都过度使用 `$()` 函数，甚至在后续的代码行中使用，通过执行不必要的代码来使其实现变慢。操作复杂性如此经常被忽视的主要原因之一是
    jQuery 使用优雅和极简的语法。尽管 JavaScript 浏览器引擎在过去几年变得多次更快，性能可与许多编译语言媲美，但是 DOM API 仍然是它们最慢的组件之一，因此开发人员必须尽量减少与它的交互。
- en: Caching jQuery objects
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存 jQuery 对象
- en: Storing the result of the `$()` function to a local variable and subsequently
    using it to operate on the retrieved elements is the simplest way of eliminating
    unnecessary executions of the same DOM traversals.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `$()` 函数的结果存储到本地变量中，并随后在检索到的元素上操作是消除不必要的相同 DOM 遍历执行的最简单方法。
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the previous chapters, we even suggested storing Composite Collection Objects
    of important page elements as properties of our modules and reusing them everywhere
    in our application:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们甚至建议将重要页面元素的组合集合对象作为模块的属性进行存储，并在应用程序的各个地方重复使用：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Caching retrieved elements on modules is a very good practice when the elements
    are not going to be removed from the page. Keep in mind that, when dealing with
    elements with shorter lifespans, in order to avoid memory leaks, you have to either
    ensure that you clear all their references when they are removed from the page
    or have a fresh reference retrieved when required and cache it only inside your
    functions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当元素不会从页面中移除时，将检索到的元素缓存在模块上是一种非常好的做法。请记住，当处理生命周期较短的元素时，为了避免内存泄漏，您必须确保在从页面中删除它们时清除所有引用，或者在需要时重新检索新的引用，并仅在函数内部缓存它。
- en: Scoping element traversals
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作用域元素遍历
- en: 'Instead of writing complex CSS selectors for your traversals like:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是为遍历编写复杂的 CSS 选择器：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can instead have the same result in a more efficient way by using an already
    retried ancestor element to scope the DOM traversal. This way, you are not only
    using simpler CSS selectors that are faster to match against page elements, but
    you are also reducing the number of elements that have to be checked. Moreover,
    the resulting implementations have less code repetitions (are DRYer) and the CSS
    selectors used are simple and as a result more readable.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用已经检索到的祖先元素来限定 DOM 遍历，以更高效的方式获得相同的结果。这样做，不仅使用了更简单的 CSS 选择器来匹配页面元素，而且减少了需要检查的元素数量。此外，生成的实现代码重复性较少（更干净），使用的
    CSS 选择器简单，因此更易读。
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Additionally, this practice works even better with module-wide cached elements
    like those we used in the previous chapters:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，这种做法与整个模块范围的缓存元素一起使用效果更佳，就像我们在前几章中使用的那样：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Chaining jQuery methods
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链式调用 jQuery 方法
- en: One of the characteristics of all jQuery APIs is that they are **Fluent** interface
    implementations that enable us to chain several method invocations on a single
    Composite Collection Object.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 jQuery API 的特点之一是它们是**流式**接口实现，使我们能够在单个组合集合对象上链式调用多个方法。
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we discussed in previous chapters, chaining allows us to reduce the number
    of used variables and leads to more readable implementations with fewer code repetitions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中讨论的，链式调用可以减少所用变量的数量，并且以更少的代码重复实现更易读的实现。
- en: Don't overdo it
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要过度使用
- en: Keep in mind that jQuery also provides the `$.fn.end()` method ([http://api.jquery.com/end/](http://api.jquery.com/end/))
    as a way of moving back from a chained traversal.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，jQuery 还提供了 `$.fn.end()` 方法（[http://api.jquery.com/end/](http://api.jquery.com/end/)）作为从链式遍历中返回的一种方式。
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Even though this is a handy method in many cases, you should avoid overusing
    it since it can damage the readability and performance of your code. In many cases,
    using cached element collections instead of `$.fn.end()` results in faster and
    more readable implementations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这在许多情况下都是一个方便的方法，但你应该避免过度使用它，因为它可能会损害代码的可读性和性能。在许多情况下，使用缓存的元素集合而不是 `$.fn.end()`
    可以获得更快、更可读的实现。
- en: Improving DOM manipulations
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进 DOM 操作
- en: As we said earlier, the extensive use of the DOM API is one of the most common
    things that makes an application slower, especially when used to manipulate the
    state of the DOM tree. In this section, we will showcase some tips to improve
    performance when manipulating the DOM tree.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，广泛使用 DOM API 是使应用程序变慢的最常见因素之一，特别是在用于操作 DOM 树状态时。在本节中，我们将展示一些改进操作 DOM
    树性能的技巧。
- en: Creating DOM elements
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 DOM 元素
- en: 'The most efficient way to create DOM elements is to construct a HTML string
    and append it to the DOM tree using the `$.fn.html()` method. Additionally, since
    this is too limiting in some use cases, you can also use the `$.fn.append()` and
    `$.fn.prepend()` methods, which are slightly slower but may be a better match
    for your implementation. Ideally, if multiple elements need to be created, you
    should try to minimize the invocation of these methods by creating a HTML string
    that defines all the elements and then inserting it into the DOM tree, as shown
    below:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 DOM 元素最有效的方式是构造一个 HTML 字符串并使用 `$.fn.html()` 方法将其附加到 DOM 树中。此外，由于在某些用例中这太过限制，你也可以使用
    `$.fn.append()` 和 `$.fn.prepend()` 方法，虽然稍微慢一些，但可能更适合你的实现。理想情况下，如果需要创建多个元素，你应该尝试通过创建一个定义所有元素的
    HTML 字符串，然后将其插入到 DOM 树中，如下所示：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Another way to achieve the same result, is by using an array to store the HTML
    for each intermediate element and then join them right before the insertion to
    the DOM tree:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现相同结果的方法是使用数组来存储每个中间元素的 HTML，然后在插入到 DOM 树之前将它们连接起来：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is a commonly used pattern since, until recently, it performed better than
    concatenating the intermediate results with "+=".
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 自近些年来，这是一个常用的模式，因为它比使用 "+=" 连接中间结果性能更好。
- en: Styling and animating
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样式和动画
- en: Whenever possible, use CSS classes for your styling manipulations by utilizing
    the `$.fn.addClass()` and `$.fn.removeClass()` methods instead of manually manipulating
    the style of the elements with the `$.fn.css()` method. That's especially useful
    when you need to style a large number of elements since this is the main purpose
    of CSS classes and browsers have already spent years optimizing it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，通过利用`$.fn.addClass()`和`$.fn.removeClass()`方法使用 CSS 类进行样式操作，而不是通过`$.fn.css()`方法手动操纵元素的样式。当你需要为大量元素设置样式时，这特别有用，因为这是
    CSS 类的主要用途，并且浏览器已经花费了数年的时间对其进行优化。
- en: Tip
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'As an extra optimization step to minimize the number of manipulated elements,
    you can apply CSS classes on a single common ancestor element and use a descendant
    CSS selector to apply your styling, as demonstrated here: [https://developer.mozilla.org/en-US/docs/Web/CSS/Descendant_selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Descendant_selectors)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最小化操作元素数量的额外优化步骤，你可以在单个公共祖先元素上应用 CSS 类，并使用后代 CSS 选择器来应用你的样式，如此处所示：[https://developer.mozilla.org/en-US/docs/Web/CSS/Descendant_selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Descendant_selectors)
- en: 'When you still need to use the `$.fn.css()` method, for example, when your
    implementation needs to be imperative, use the invocation overload that accepts
    object parameters: [http://api.jquery.com/css/#css-properties](http://api.jquery.com/css/#css-properties).
    In this way, the required method invocations are minimized when applying multiple
    styles on elements and your code is better organized.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你仍然需要使用`$.fn.css()`方法时，例如，当你的实现需要是命令式的时候，使用接受对象参数的调用重载：[http://api.jquery.com/css/#css-properties](http://api.jquery.com/css/#css-properties)。这样，在为元素应用多个样式时，所需的方法调用将被最小化，而且你的代码组织得更好。
- en: Moreover, avoid mixing methods that manipulate the DOM with methods that read
    from the DOM since this will force a reflow of the page so that the browser can
    calculate the new positions of the page elements.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，避免混合使用操纵 DOM 的方法和从 DOM 中读取数据的方法，因为这会强制页面重新排版，以便浏览器计算页面元素的新位置。
- en: 'Instead of doing something like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是像这样做：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Prefer grouping the non-conflicting manipulations together like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 更好地将非冲突的操作分组在一起，像这样：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The browser can thus skip some re-renderings of the page, resulting in fewer
    pauses of the execution of your code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器因此可以跳过对页面的一些重新渲染，从而减少代码执行时的暂停。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about reflows, visit the following page: [https://developers.google.com/speed/articles/reflow](https://developers.google.com/speed/articles/reflow)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有关重排的更多信息，请访问以下页面：[https://developers.google.com/speed/articles/reflow](https://developers.google.com/speed/articles/reflow)
- en: Lastly, note that all jQuery-generated animations in v1.x and v2.x are implemented
    using the `setTimeout()` function. This is going to change in v3.x of jQuery which
    plans to use the `requestAnimationFrame()` function, which is a better match for
    creating imperative animations. Until then, you can use the **jQuery-requestAnimationFrame**
    plugin ([https://github.com/gnarf/jquery-requestAnimationFrame](https://github.com/gnarf/jquery-requestAnimationFrame))
    which monkey-patches jQuery to use the `requestAnimationFrame()` function for
    its animations when it is available.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，v1.x 和 v2.x 中所有由 jQuery 生成的动画都是使用`setTimeout()`函数实现的。这将在 jQuery 的 v3.x
    中发生变化，该版本计划使用`requestAnimationFrame()`函数，这更适合创建命令式动画。在那之前，你可以使用**jQuery-requestAnimationFrame**插件
    ([https://github.com/gnarf/jquery-requestAnimationFrame](https://github.com/gnarf/jquery-requestAnimationFrame))，它对
    jQuery 进行了猴子补丁，以便在可用时使用`requestAnimationFrame()`函数进行动画。
- en: Manipulating detached elements
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操纵分离的元素
- en: Another way to avoid unnecessary repaints of the page while manipulating DOM
    elements is to detach the element from the page and re-attach it after completing
    your manipulations. Working with a detached in-memory element is much faster and
    does not cause reflows on the page.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 操纵 DOM 元素时避免页面不必要的重绘的另一种方法是将元素从页面中分离，并在完成操作后重新附加它。使用分离的内存中元素要快得多，并且不会导致页面重排。
- en: In order to achieve that, we use the `$.fn.detach()` method which, in contrast
    to `$.fn.remove()`, preserves all event handlers and jQuery data on the detached
    element.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们使用`$.fn.detach()`方法，与`$.fn.remove()`相比，它保留了分离元素上的所有事件处理程序和 jQuery
    数据。
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Additionally, to be able to place the manipulated element back into its original
    position, we can create and insert a hidden placeholder element into the DOM.
    This empty and hidden element does not affect the rendering of the page and is
    removed after the original item is placed back into its original position.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，为了能够将操作过的元素放回其原始位置，我们可以在 DOM 中创建并插入一个隐藏的占位符元素。这个空的隐藏元素不会影响页面的渲染，并在将原始项目放回其原始位置后被移除。
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about the `$.fn.detach()` method, you can read the documentation
    at: [http://api.jquery.com/detach/](http://api.jquery.com/detach/)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解有关 `$.fn.detach()` 方法的更多信息，请阅读文档：[http://api.jquery.com/detach/](http://api.jquery.com/detach/)
- en: Introducing the Flyweight Pattern
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引入 Flyweight 模式
- en: According to Computer Science, a Flyweight is an object that is used as a means
    of reducing the memory consumption of an implementation by providing functionality
    and/or data that are shared with other object instances. The **Prototypes** of
    JavaScript constructor functions can be characterized as Flyweights since every
    object instance can use all of the methods and properties that are defined in
    its prototype until it overwrites them. On the other hand, classical Flyweights
    are separate objects from the object family that they are used with and often
    hold the shared data and functionality in special data structures.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 根据计算机科学的说法，Flyweight 是一种对象，用于通过提供与其他对象实例共享的功能和/或数据来减少实现的内存消耗。JavaScript 构造函数的**原型**可以被定义为
    Flyweights，因为每个对象实例都可以使用其原型中定义的所有方法和属性，直到覆盖它们为止。另一方面，经典的 Flyweights 是与它们一起使用的对象系列中的独立对象，并经常在特殊的数据结构中保存共享的数据和功能。
- en: Using Delegate Observers
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用委托观察者
- en: A great example of Flyweights in jQuery applications is Delegate Observers which,
    as we saw in the Dashboard example in [Chapter 2](part0018_split_000.html#H5A42-e8d3cd3d052d4ee0b4673af57a64ddef
    "Chapter 2. The Observer Pattern"), *The Observer Pattern*, can greatly reduce
    the memory demands of an implementation by working as a centralized event handler
    for a large group of elements. In this way, we can avoid the cost of setting up
    separate observers and event handlers for every element and use the browser's
    event bubbling mechanism to observe for them on a single common ancestor element
    and filter their origin.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 jQuery 应用程序中，委托观察者是 Flyweights 的一个很好的示例，正如我们在[第 2 章](part0018_split_000.html#H5A42-e8d3cd3d052d4ee0b4673af57a64ddef
    "Chapter 2. The Observer Pattern")中看到的*观察者模式*中的仪表板示例一样，它可以通过作为大量元素的集中事件处理程序来大大降低实现的内存需求。通过这种方式，我们可以避免为每个元素设置单独的观察者和事件处理程序的成本，并使用浏览器的事件冒泡机制在单个共同的祖先元素上观察它们并过滤它们的来源。
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The actual Flyweight object is the event handler along with the callback that
    is attached to the ancestor element.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的 Flyweight 对象是与祖先元素附加的回调一起的事件处理程序。
- en: Using $.noop()
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 $.noop() 方法
- en: The jQuery library offers the `$.noop()` method which is actually an empty function
    that can be shared among implementations. Using empty functions as default callback
    values simplifies and improves the readability of an implementation by reducing
    the number of `if` statements. This is handy for jQuery plugins that already encapsulate
    complex functionality.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 库提供了 `$.noop()` 方法，实际上是一个可以在不同实现之间共享的空函数。使用空函数作为默认回调值通过减少 `if` 语句的数量来简化和提高实现的可读性。这对于已经封装了复杂功能的
    jQuery 插件非常方便。
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In such situations, where the implementation requirements or the personal taste
    of the developer has led to using empty functions, the `$.noop()` method is useful
    as a way to lower memory consumption by sharing a single empty function instance
    among all the different parts of an implementation. An added benefit of using
    the `$.noop()` method for every part of an implementation is that we can also
    check whether a passed function reference is the empty function by simply checking
    `callbackFn === $.noop()`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，无论是由于实现需求还是开发者的个人品味，都导致了使用空函数，`$.noop()` 方法都是一种降低内存消耗的有效方式，它通过在整个实现的所有不同部分之间共享一个空函数实例来实现。使用
    `$.noop()` 方法的另一个好处是，我们还可以通过简单检查 `callbackFn === $.noop()` 来检查传递的函数引用是否为空函数。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information, you can find the documentation at: [http://api.jquery.com/jQuery.noop/](http://api.jquery.com/jQuery.noop/)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请参阅文档：[http://api.jquery.com/jQuery.noop/](http://api.jquery.com/jQuery.noop/)
- en: Using the $.single plugin
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 $.single 插件
- en: Another simple example of the Flyweight pattern in jQuery applications is the
    `jQuery.single` plugin as described by *James Padolsey* in his article, *76 bytes
    for faster jQuery,* which tries to eliminate the creation of new jQuery objects
    whenever we need to apply jQuery methods on a single page element. The implementation
    is quite small and creates a single jQuery composite collection object that is
    returned on every invocation of the `jQuery.single()` method, containing the page
    element that was used as an argument.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 jQuery 应用程序中，另一个简单的享元模式示例是 *James Padolsey* 在他的文章 *76 bytes for faster jQuery*
    中描述的 `jQuery.single` 插件，该插件尝试在单个页面元素上应用 jQuery 方法时消除创建新的 jQuery 对象。该实现非常小，创建一个单一的
    jQuery 复合集合对象，在每次调用 `jQuery.single()` 方法时返回，该对象包含用作参数的页面元素。
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `jQuery.single` plugin is useful when used in observers like `$.fn.on()`
    and iterations with methods like `$.each()`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 `$.fn.on()` 这样的观察者和 `$.each()` 这样的方法迭代中使用时，`jQuery.single` 插件非常有用。
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The benefits of using the `jQuery.single` plugin come from the fact that we
    are creating fewer objects and, as a result, the browser's Garbage Collector will
    also have less work to do when freeing up the memory of short lived objects.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `jQuery.single` 插件的好处在于我们创建的对象更少，因此当释放短生命周期对象的内存时，浏览器的垃圾回收器的工作量也会减少。
- en: 'As a side note, keep in mind the side effects of having a single jQuery object
    returned by every invocation of the `$.single()` method and the fact that the
    last invocation argument will be stored until the next invocation of the method:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个副作用，请注意每次调用`$.single()`方法时返回的单个 jQuery 对象以及最后一个调用参数将存储到下一次调用该方法之前的事实：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Additionally, in case that you use something like `$btn1.remove()` then the
    element will not be freed until the next invocation of the `$.single()` method
    which will remove it from the plugin's internal collection object.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果你使用类似 `$btn1.remove()` 这样的方法，那么该元素将一直保留，直到下一次调用 `$.single()` 方法将其从插件的内部集合对象中删除为止。
- en: Another similar but more extensive plugin is the `jQuery.fly` plugin which can
    be invoked with arrays and jQuery objects as parameters.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类似但更全面的插件是 `jQuery.fly` 插件，它可以使用数组和 jQuery 对象作为参数调用。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about `jQuery.single` and `jQuery.fly`, you can visit
    the following URLs: [http://james.padolsey.com/javascript/76-bytes-for-faster-jquery/](http://james.padolsey.com/javascript/76-bytes-for-faster-jquery/)
    and [https://github.com/matjaz/jquery.fly](https://github.com/matjaz/jquery.fly).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `jQuery.single` 和 `jQuery.fly` 的更多信息，请访问以下链接：[http://james.padolsey.com/javascript/76-bytes-for-faster-jquery/](http://james.padolsey.com/javascript/76-bytes-for-faster-jquery/)
    和 [https://github.com/matjaz/jquery.fly](https://github.com/matjaz/jquery.fly)。
- en: On the other hand, the jQuery implementation that handles the invocation of
    the `$()` method with a single page element is not complex at all and only creates
    a single simple object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，处理带有单个页面元素的 `$()` 方法调用的 jQuery 实现并不复杂，只创建一个简单的对象。
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Moreover, the JavaScript engines of modern browsers have already become quite
    efficient when dealing with short-lived objects since such objects are commonly
    passed around an application as method invocation parameters.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，现代浏览器的 JavaScript 引擎在处理短生命周期对象时已经非常高效，因为这些对象通常作为方法调用参数在应用程序中传递。
- en: Lazy Loading Modules
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟加载模块
- en: Finally, we will get an introduction to the advanced technique of Lazy Loading
    Modules. The key concept of this practice is that, during the page load, the browser
    will only download and execute those modules that are required for the initial
    rendering of the page while the rest of the application modules are requested
    after the page is fully loaded and is required to respond to a user action. `RequireJS`
    ([http://requirejs.org/](http://requirejs.org/)) is a popular JavaScript library
    that is used as a module loader but, for simple cases, we can achieve the same
    result with jQuery.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将介绍一种高级技术——**延迟加载模块**。这种实践的关键概念是，在页面加载期间，浏览器仅下载并执行那些在页面的初始渲染过程中所需的模块，而其余的应用程序模块则在页面完全加载后，并且需要响应用户操作时才被请求。`RequireJS`
    ([http://requirejs.org/](http://requirejs.org/)) 是一个常用的 JavaScript 库，用作模块加载器，但对于简单情况，我们可以使用
    jQuery 来实现相同的效果。
- en: 'As an example of this, we will use it to lazy load the `informationBox` module
    of the Dashboard example that we saw in previous chapters, after the first click
    of the user on the Dashboard''s `<button>`. We will abstract the implementation
    that is responsible for downloading and executing JavaScript files into a generic
    and reusable module named `moduleUtils`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 作为此的示例，我们将在用户首次单击仪表板上的 `<button>` 后，使用它来延迟加载我们在以前章节中看到的 Dashboard 示例的 `informationBox`
    模块。我们将抽象出负责下载和执行 JavaScript 文件的实现，成为一个通用且可重用的模块，名为 `moduleUtils`。
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `getModule()` method accepts the module's namespace as a string parameter
    and returns either the Module's **Singleton Object** itself or a falsy value if
    the module is not already loaded. This is done with the `Array.reduce()` method
    which is used to iterate over the different parts of the namespace string, using
    the dot (.) as a delimiter and evaluating each part on the previous object context,
    starting with `window`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`getModule()` 方法接受模块的命名空间作为字符串参数，并返回模块的**单例对象**本身，或者如果模块尚未加载，则返回假值。这是通过使用 `Array.reduce()`
    方法完成的，该方法用于迭代命名空间字符串的不同部分，使用点（.）作为分隔符，并在先前对象上下文中评估每个部分，从`window`开始。'
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about the `Array.reduce()` method, you can visit: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `Array.reduce()` 方法的更多信息，请访问：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)
- en: '`ensureLoaded()` is the primary method of the `moduleUtils` module and is responsible
    for retrieving and executing modules that are not already loaded. It first uses
    the `getModule()` method to check whether the requested module has already been
    loaded and, if so, returns its namespace object as a Resolved Promise.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`ensureLoaded()` 是 `moduleUtils` 模块的主要方法，负责检索并执行尚未加载的模块。它首先使用 `getModule()`
    方法检查请求的模块是否已加载，如果是，则将其命名空间对象作为已解决的 Promise 返回。'
- en: The next step, if a module has not yet been loaded, is to check the `ongoingModuleRequests`
    object to verify whether the requested module is not already being downloaded.
    In order to do that, the `ongoingModuleRequests` object uses the module's namespace
    string as a property and stores the Promises of the AJAX requests that are used
    to retrieve the `.js` files from the server. If a Promise object is available
    then we can infer that the AJAX request is still ongoing and, instead of starting
    a new one, we return the existing Promise.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，如果模块尚未加载，则是检查 `ongoingModuleRequests` 对象，以验证请求的模块是否尚未下载。为了做到这一点，`ongoingModuleRequests`
    对象将模块的命名空间字符串作为属性，并存储用于从服务器检索 `.js` 文件的 AJAX 请求的 Promises。如果有一个 Promise 对象可用，那么我们可以推断出
    AJAX 请求仍在进行中，并且我们不会启动新的请求，而是返回现有的 Promise。
- en: Finally, when none of the above returns a result, we use the lower case module
    file naming convention that we discussed in previous chapters and use jQuery's
    `$.getScript()` method to initiate an AJAX request to retrieve the requested module
    file. The Promise created for the AJAX request is assigned as to the appropriate
    property of the `ongoingModuleRequests` object and is then returned to the caller
    of the method. When, at a later point in time, the Promise is Fulfilled, we re-evaluate
    the module and return it as the final result of the returned Promise. Moreover,
    regardless of the result of the AJAX request, the Promise is also removed from
    the `ongoingModuleRequests` object in order to keep the implementation reusable
    in case of a network failure and also free up the memory that was allocated for
    the request.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当上述任何一个都没有返回结果时，我们使用在之前章节中讨论的小写模块文件命名约定，并使用 jQuery 的 `$.getScript()` 方法发起
    AJAX 请求以检索所请求的模块文件。为 AJAX 请求创建的 Promise 被分配为 `ongoingModuleRequests` 对象的适当属性，并随后返回给方法的调用者。当在以后的时间点，Promise
    被完成时，我们重新评估模块并将其作为返回的 Promise 的最终结果返回。此外，无论 AJAX 请求的结果如何，Promise 也会从 `ongoingModuleRequests`
    对象中删除，以便在网络故障时保持实现的可重用性，并释放为请求分配的内存。
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Keep in mind that the `$.getScript()` method might not work in some browsers
    when the page is loaded through the filesystem, but does work as intended when
    served using a web server like Apache, IIS or nginx. For more information about
    `$.getScript(),` you can visit: [http://api.jquery.com/jQuery.getScript/](http://api.jquery.com/jQuery.getScript/)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当页面通过文件系统加载时，`$.getScript()` 方法可能在某些浏览器中无法工作，但在像Apache、IIS或nginx这样的Web服务器上加载时则可以正常工作。有关
    `$.getScript()` 的更多信息，请访问：[http://api.jquery.com/jQuery.getScript/](http://api.jquery.com/jQuery.getScript/)
- en: The only change that we introduced to the existing implementation of the `informationBox`
    module for this demonstration was to make it self-initializable in an attempt
    to reduce the complexity of the `ensureLoaded()` method.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对现有的 `informationBox` 模块的实现仅做了一个改变，即使其自我初始化，以尝试减少 `ensureLoaded()` 方法的复杂性。
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we also had to change the implementation of the `categories` module
    so that it would use the `ensureLoaded()` method before using the `informationBox`
    module. As you can see below, we had to refactor the code handling the click event
    on the dashboard''s `<button>` since the `ensureLoaded()` method returns a Promise
    as a result:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还必须更改 `categories` 模块的实现，以便在使用 `informationBox` 模块之前使用 `ensureLoaded()`
    方法。正如您下面所见，我们不得不重构处理仪表板 `<button>` 的点击事件的代码，因为 `ensureLoaded()` 方法返回一个Promise作为结果：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned several optimization techniques that can be used
    to improve the performance of jQuery applications, especially when they become
    large and complex.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了几种优化技术，可以用来提高jQuery应用程序的性能，特别是当它们变得庞大和复杂时。
- en: We started with simple practices like bundling and minifying our JavaScript
    files and discussed the benefits of using CDNs to load third-party libraries.
    We then went on to analyze some simple patterns to writing efficient JavaScript
    code and learned how to write efficient CSS selectors to improve the page's rendering
    speed and DOM traversals using jQuery.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从简单的实践开始，比如捆绑和缩小我们的JavaScript文件，并讨论了使用CDN加载第三方库的好处。然后，我们继续分析了一些编写高效JavaScript代码的简单模式，并学习了如何编写高效的CSS选择器来提高页面的渲染速度，并使用jQuery来改进DOM遍历。
- en: We continued with jQuery-specific practices such as caching of jQuery Composite
    Collection Objects, how to minimize DOM manipulations, and had a reminder of the
    Delegate Observer pattern, as a good example of the Flyweight Pattern. Lastly,
    we got an introduction to the advanced technique of Lazy Loading and saw a demonstration
    of how to load the various modules of an implementation progressively, based on
    user actions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续使用jQuery特定的实践，例如缓存jQuery组合集合对象、如何最小化DOM操作，并提醒代理观察者模式，作为享元模式的一个很好的例子。最后，我们介绍了惰性加载的高级技术，并演示了如何根据用户操作逐步加载实现的各个模块。
- en: After completing this chapter, we are now able to apply the most common optimization
    patterns to our implementations and use this chapter as a checklist of best practices
    and performance tips before moving an application to a production environment.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，我们现在能够将最常见的优化模式应用于我们的实现，并在将应用程序移至生产环境之前，将本章用作最佳实践和性能提示的检查清单。
