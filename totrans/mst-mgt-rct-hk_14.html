<html><head></head><body>
		<div id="_idContainer043">
			<h1 id="_idParaDest-133"><em class="italic"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.1.1">Chapter 11</span></em><span class="koboSpan" id="kobo.2.1">: Similarities and Differences between Three Global State Libraries</span></h1>
			<p><span class="koboSpan" id="kobo.3.1">In this book, we introduced three global state libraries: Zustand, Jotai, and Valtio. </span><span class="koboSpan" id="kobo.3.2">Let's discuss some similarities and differences between them. </span><span class="koboSpan" id="kobo.3.3">These three libraries have some comparable features.</span></p>
			<p><span class="koboSpan" id="kobo.4.1">Zustand is similar to Redux (and React Redux) in terms of usage and the store model but, unlike Redux, it's not based on reducers. </span></p>
			<p><span class="koboSpan" id="kobo.5.1">Jotai is similar to Recoil (</span><a href="https://recoiljs.org"><span class="koboSpan" id="kobo.6.1">https://recoiljs.org</span></a><span class="koboSpan" id="kobo.7.1">) in terms of the API, but its goal is more to provide a minimal API for non-selector-based render optimization. </span></p>
			<p><span class="koboSpan" id="kobo.8.1">Valtio is similar to MobX in terms of the mutating update model, but the level of similarity is only minor, and the render optimization implementation is very different. </span></p>
			<p><span class="koboSpan" id="kobo.9.1">All three libraries provide primitive features that fit with micro-state management. </span><span class="koboSpan" id="kobo.9.2">They differ in their coding style and approach to render optimization.</span></p>
			<p><span class="koboSpan" id="kobo.10.1">In this chapter, we discuss each library by pairing it with its comparable library and then discuss the similarities and differences between the three. </span><span class="koboSpan" id="kobo.10.2">We will cover the following topics:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.11.1">Differences between Zustand and Redux</span></li>
				<li><span class="koboSpan" id="kobo.12.1">Understanding when to use Jotai and Recoil</span></li>
				<li><span class="koboSpan" id="kobo.13.1">Using Valtio and MobX</span></li>
				<li><span class="koboSpan" id="kobo.14.1">Comparing Zustand, Jotai, and Valtio</span></li>
			</ul>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.15.1">Technical requirements</span></h1>
			<p><span class="koboSpan" id="kobo.16.1">You are expected to have a moderate knowledge of React, including React hooks. </span><span class="koboSpan" id="kobo.16.2">Refer to the official site, </span><a href="https://reactjs.org"><span class="koboSpan" id="kobo.17.1">https://reactjs.org</span></a><span class="koboSpan" id="kobo.18.1">, to learn more.</span></p>
			<p><span class="koboSpan" id="kobo.19.1">In some code, we use TypeScript (</span><a href="https://www.typescriptlang.org"><span class="koboSpan" id="kobo.20.1">https://www.typescriptlang.org</span></a><span class="koboSpan" id="kobo.21.1">), and you should have a basic knowledge of it.</span></p>
			<p><span class="koboSpan" id="kobo.22.1">The code in this chapter is available on GitHub: </span><a href="https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_11"><span class="koboSpan" id="kobo.23.1">https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_11</span></a><span class="koboSpan" id="kobo.24.1">.</span></p>
			<p><span class="koboSpan" id="kobo.25.1">To run the code snippets, you need a React environment, for example, Create React App (</span><a href="https://create-react-app.dev"><span class="koboSpan" id="kobo.26.1">https://create-react-app.dev</span></a><span class="koboSpan" id="kobo.27.1">) or CodeSandbox (</span><a href="https://codesandbox.io"><span class="koboSpan" id="kobo.28.1">https://codesandbox.io</span></a><span class="koboSpan" id="kobo.29.1">).</span></p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.30.1">Differences between Zustand and Redux</span></h1>
			<p><span class="koboSpan" id="kobo.31.1">In some use cases, the developer experience can be similar in Zustand and Redux. </span><span class="koboSpan" id="kobo.31.2">Both are based on </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.32.1">one-way data flow. </span><span class="koboSpan" id="kobo.32.2">In one-way data flow, we dispatch </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">action</span></strong><span class="koboSpan" id="kobo.34.1">, which represents a command to update a state, and after the state is updated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.35.1">action</span></strong><span class="koboSpan" id="kobo.36.1">, the new state is propagated to where it's needed. </span><span class="koboSpan" id="kobo.36.2">This separation </span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.37.1">of dispatching and propagating simplifies the flow of data and makes the entire system more predictable.</span></p>
			<p><span class="koboSpan" id="kobo.38.1">On the other hand, they differ in how to update states. </span><span class="koboSpan" id="kobo.38.2">Redux is based on reducers. </span><span class="koboSpan" id="kobo.38.3">A reducer is a pure function that takes a previous state and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">action</span></strong><span class="koboSpan" id="kobo.40.1"> object and returns a new state. </span><span class="koboSpan" id="kobo.40.2">While updating states with reducers is a strict method, it leads to more predictability. </span><span class="koboSpan" id="kobo.40.3">Zustand takes a flexible approach and it doesn't necessarily use reducers to update states.</span></p>
			<p><span class="koboSpan" id="kobo.41.1">In this section, we will see a comparison by converting an example with Redux into Zustand. </span><span class="koboSpan" id="kobo.41.2">Then we will see the differences between the two.</span></p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.42.1">Example with Redux and Zustand</span></h2>
			<p><span class="koboSpan" id="kobo.43.1">Let's look </span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.44.1">at one of the official Redux tutorials. </span><span class="koboSpan" id="kobo.44.2">This is the so-called modern Redux with the Redux toolkit: </span><a href="https://redux-toolkit.js.org/tutorials/quick-start"><span class="koboSpan" id="kobo.45.1">https://redux-toolkit.js.org/tutorials/quick-start</span></a><span class="koboSpan" id="kobo.46.1">.</span></p>
			<p><span class="koboSpan" id="kobo.47.1">To create </span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.48.1">a Redux store, we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">configureStore</span></strong><span class="koboSpan" id="kobo.50.1"> from the Redux Toolkit library:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.51.1">// src/app/store.js</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.52.1">import { configureStore } from "@reduxjs/toolkit";</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.53.1">import counterReducer from "../features/counter/counterSlice";</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.54.1">export const store = configureStore({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.55.1">  reducer: {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.56.1">    counter: counterReducer,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.57.1">  },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.58.1">});</span></p>
			<p><span class="koboSpan" id="kobo.59.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">configureStore</span></strong><span class="koboSpan" id="kobo.61.1"> function takes reducers and returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">store</span></strong><span class="koboSpan" id="kobo.63.1"> variable. </span><span class="koboSpan" id="kobo.63.2">In this case, it uses one reducer – </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">counterReducer</span></strong><span class="koboSpan" id="kobo.65.1">.</span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">counterReducer</span></strong><span class="koboSpan" id="kobo.67.1"> is defined </span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.68.1">in a separate file, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">createSlice</span></strong><span class="koboSpan" id="kobo.70.1"> from the Redux Toolkit library. </span><span class="koboSpan" id="kobo.70.2">First, we import </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">createSlice</span></strong><span class="koboSpan" id="kobo.72.1"> and define </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">initialState</span></strong><span class="koboSpan" id="kobo.74.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.75.1">// features/counter/counterSlice.js</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.76.1">import { createSlice } from "@reduxjs/toolkit";</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.77.1">const initialState = {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.78.1">  value: 0,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.79.1">};</span></p>
			<p><span class="koboSpan" id="kobo.80.1">We then define </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">counterSlice</span></strong><span class="koboSpan" id="kobo.82.1"> using </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">createSlice</span></strong><span class="koboSpan" id="kobo.84.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">initialState</span></strong><span class="koboSpan" id="kobo.86.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.87.1">export const counterSlice = createSlice({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.88.1">  name: "counter",</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.89.1">  initialState,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.90.1">  reducers: {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.91.1">    increment: (state) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.92.1">      state.value += 1;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.93.1">    },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.94.1">    decrement: (state) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.95.1">      state.value -= 1;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.96.1">    },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.97.1">    incrementByAmount: (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.98.1">      state,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.99.1">      action: PayloadAction&lt;number&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.100.1">     ) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.101.1">      state.value += action.payload;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.102.1">    },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.103.1">  },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.104.1">});</span></p>
			<p><span class="koboSpan" id="kobo.105.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">counterSlice</span></strong><span class="koboSpan" id="kobo.107.1"> variable created with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">createSlice</span></strong><span class="koboSpan" id="kobo.109.1"> function contains both a reducer and actions. </span><span class="koboSpan" id="kobo.109.2">To make </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.110.1">them easily importable, we extract the reducer and action properties and export them separately:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.111.1">export const {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.112.1">  increment,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.113.1">  decrement,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.114.1">  incrementByAmount</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.115.1">} = counterSlice.actions;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.116.1">export default counterSlice.reducer;</span></p>
			<p><span class="koboSpan" id="kobo.117.1">Next is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">Counter</span></strong><span class="koboSpan" id="kobo.119.1"> component, which uses the created store. </span><span class="koboSpan" id="kobo.119.2">First, we import two hooks from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">react-redux</span></strong><span class="koboSpan" id="kobo.121.1"> library and two actions from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">counterSlice</span></strong><span class="koboSpan" id="kobo.123.1"> file:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.124.1">// features/counter/Counter.jsx</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.125.1">import { useSelector, useDispatch } from "react-redux";</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.126.1">import { decrement, increment } from "./counterSlice";</span></p>
			<p><span class="koboSpan" id="kobo.127.1">We then define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">Counter</span></strong><span class="koboSpan" id="kobo.129.1"> component:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.130.1">export function Counter() {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.131.1">  const count = useSelector((</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.132.1">    state: { counter: { value: number; }; }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.133.1">  ) =&gt; state.counter.value);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.134.1">  const dispatch = useDispatch();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.135.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.136.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.137.1">      &lt;button onClick={() =&gt; dispatch(increment())}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.138.1">        Increment</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.139.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.140.1">      &lt;span&gt;{count}&lt;/span&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.141.1">      &lt;button onClick={() =&gt; dispatch(decrement())}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.142.1">        Decrement</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.143.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.144.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.145.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.146.1">}</span></p>
			<p><span class="koboSpan" id="kobo.147.1">This component uses useSelector and useDispatch hooks from the React Redux library. </span><span class="koboSpan" id="kobo.147.2">We use a selector function to get the count value from the store state. </span><span class="koboSpan" id="kobo.147.3">Notice that this </span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.148.1">component doesn't use the created store directly. </span><span class="koboSpan" id="kobo.148.2">The useSelector hook takes the store from Context.</span></p>
			<p><span class="koboSpan" id="kobo.149.1">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">App</span></strong><span class="koboSpan" id="kobo.151.1"> component looks like the following:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.152.1">// App.jsx</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.153.1">import { Provider } from "react-redux";</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.154.1">import { store } from "./app/store";</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.155.1">import { Counter } from "./features/counter/Counter";</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.156.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.157.1">  &lt;Provider store={store}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.158.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.159.1">      &lt;Counter /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.160.1">      &lt;Counter /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.161.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.162.1">  &lt;/Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.163.1">);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.164.1">export default App;</span></p>
			<p><span class="koboSpan" id="kobo.165.1">We pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">store</span></strong><span class="koboSpan" id="kobo.167.1"> variable we created with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">Provider</span></strong><span class="koboSpan" id="kobo.169.1"> component. </span><span class="koboSpan" id="kobo.169.2">This allows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">useSelector</span></strong><span class="koboSpan" id="kobo.171.1"> hook in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">Counter</span></strong><span class="koboSpan" id="kobo.173.1"> component to access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">store</span></strong><span class="koboSpan" id="kobo.175.1"> variable.</span></p>
			<p><span class="koboSpan" id="kobo.176.1">As shown in </span><em class="italic"><span class="koboSpan" id="kobo.177.1">Figure 11.1</span></em><span class="koboSpan" id="kobo.178.1">, this works as expected. </span><span class="koboSpan" id="kobo.178.2">We have two </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">Counter</span></strong><span class="koboSpan" id="kobo.180.1"> components in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">App</span></strong><span class="koboSpan" id="kobo.182.1"> component, and they share the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">count</span></strong><span class="koboSpan" id="kobo.184.1"> value.</span></p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<span class="koboSpan" id="kobo.185.1"><img src="image/Figure_11.1_B17780.jpg" alt="Figure 11.1 – Screenshot of the app with Redux "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.186.1">Figure 11.1 – Screenshot of the app with Redux</span></p>
			<p><span class="koboSpan" id="kobo.187.1">Now, let's </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.188.1">see how this can be implemented in Zustand.</span></p>
			<p><span class="koboSpan" id="kobo.189.1">First, we create a store with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">create</span></strong><span class="koboSpan" id="kobo.191.1"> function from the Zustand library. </span><span class="koboSpan" id="kobo.191.2">We begin with importing the Zustand library:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.192.1">// store.js</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.193.1">import create from "zustand";</span></p>
			<p><span class="koboSpan" id="kobo.194.1">We then define </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">State</span></strong><span class="koboSpan" id="kobo.196.1"> type for TypeScript:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.197.1">type State = {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.198.1">  counter: {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.199.1">    value: number;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.200.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.201.1">  counterActions: {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.202.1">    increment: () =&gt; void;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.203.1">    decrement: () =&gt; void;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.204.1">    incrementByAmount: (amount: number) =&gt; void;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.205.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.206.1">};</span></p>
			<p><span class="koboSpan" id="kobo.207.1">The following is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">store</span></strong><span class="koboSpan" id="kobo.209.1"> definition. </span><span class="koboSpan" id="kobo.209.2">In Zustand, a hook </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">useStore</span></strong><span class="koboSpan" id="kobo.211.1"> represents a </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">store</span></strong><span class="koboSpan" id="kobo.213.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.214.1">export const useStore = create&lt;State&gt;((set) =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.215.1">  counter: { value: 0 },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.216.1">  counterActions: {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.217.1">    increment: () =&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.218.1">      set((state) =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.219.1">        counter: { value: state.counter.value + 1 },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.220.1">      })),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.221.1">    decrement: () =&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.222.1">      set((state) =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.223.1">        counter: { value: state.counter.value - 1 },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.224.1">      })),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.225.1">    incrementByAmount: (amount: number) =&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.226.1">      set((state) =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.227.1">        counter: { value: state.counter.value + amount },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.228.1">      })),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.229.1">  },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.230.1">}));</span></p>
			<p><span class="koboSpan" id="kobo.231.1">This defines </span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.232.1">both the counter state and counter actions in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">store</span></strong><span class="koboSpan" id="kobo.234.1">. </span><span class="koboSpan" id="kobo.234.2">The reducer logic is implemented in the function body of the actions.</span></p>
			<p><span class="koboSpan" id="kobo.235.1">Next is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">Counter</span></strong><span class="koboSpan" id="kobo.237.1"> component, which uses the created store:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.238.1">// Counter.jsx</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.239.1">import { useStore } from "./store";</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.240.1">export function Counter() {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.241.1">  const count = useStore((state) =&gt; state.counter.value);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.242.1">  const { increment, decrement } = useStore(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.243.1">    (state) =&gt; state.counterActions</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.244.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.245.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.246.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.247.1">      &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.248.1">        &lt;button onClick={increment}&gt;Increment&lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.249.1">        &lt;span&gt;{count}&lt;/span&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.250.1">        &lt;button onClick={decrement}&gt;Decrement&lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.251.1">      &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.252.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.253.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.254.1">}</span></p>
			<p><span class="koboSpan" id="kobo.255.1">We use </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.256.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">useStore</span></strong><span class="koboSpan" id="kobo.258.1"> hook to get the </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">count</span></strong><span class="koboSpan" id="kobo.260.1"> value and the actions to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">count</span></strong><span class="koboSpan" id="kobo.262.1"> value. </span><span class="koboSpan" id="kobo.262.2">Notice that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">useStore</span></strong><span class="koboSpan" id="kobo.264.1"> hook is directly imported from the store file.</span></p>
			<p><span class="koboSpan" id="kobo.265.1">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">App</span></strong><span class="koboSpan" id="kobo.267.1"> component looks like the following:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.268.1">// App.jsx</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.269.1">import { Counter } from "./Counter";</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.270.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.271.1">  &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.272.1">    &lt;Counter /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.273.1">    &lt;Counter /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.274.1">  &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.275.1">);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.276.1">export default App;</span></p>
			<p><span class="koboSpan" id="kobo.277.1">As we </span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.278.1">don't use Context, we don't need a provider component.</span></p>
			<p><span class="koboSpan" id="kobo.279.1">Now, let's discuss a comparison of the two.</span></p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.280.1">Comparing examples of Redux and Zustand</span></h2>
			<p><span class="koboSpan" id="kobo.281.1">While </span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.282.1">two implementations of the example </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.283.1">in the </span><em class="italic"><span class="koboSpan" id="kobo.284.1">Example with Redux and Zustand</span></em><span class="koboSpan" id="kobo.285.1"> section share some common concepts, there are notable differences:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.286.1">One of the biggest differences between the example of Redux and Zustand is the directory structure. </span><span class="koboSpan" id="kobo.286.2">Modern Redux suggests the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">features</span></strong><span class="koboSpan" id="kobo.288.1"> directory structure and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">createSlice</span></strong><span class="koboSpan" id="kobo.290.1"> function is designed to follow the feature directory pattern. </span><span class="koboSpan" id="kobo.290.2">This is a useful pattern for large-scale apps. </span><span class="koboSpan" id="kobo.290.3">Zustand, on the other hand, is unopinionated regarding the structure. </span><span class="koboSpan" id="kobo.290.4">It's up to developers how to organize files and directories. </span><span class="koboSpan" id="kobo.290.5">While it's possible to follow the </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">features</span></strong><span class="koboSpan" id="kobo.292.1"> directory structure with Zustand, there's no specific support from the library. </span><span class="koboSpan" id="kobo.292.2">Our Zustand example shows a pattern with </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">counterActions</span></strong><span class="koboSpan" id="kobo.294.1">, but it's only one possible pattern.</span></li>
				<li><span class="koboSpan" id="kobo.295.1">Another difference in the store creation code is the use of Immer (</span><a href="https://immerjs.github.io/immer/"><span class="koboSpan" id="kobo.296.1">https://immerjs.github.io/immer/</span></a><span class="koboSpan" id="kobo.297.1">). </span><span class="koboSpan" id="kobo.297.2">Immer allows a mutation style such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">state.value += 1;</span></strong><span class="koboSpan" id="kobo.299.1">. </span><span class="koboSpan" id="kobo.299.2">Modern Redux uses Immer by default. </span><span class="koboSpan" id="kobo.299.3">Zustand doesn't use it by default, and neither does our example. </span><span class="koboSpan" id="kobo.299.4">It is possible to use Immer in Zustand, but it's optional.</span></li>
				<li><span class="koboSpan" id="kobo.300.1">In terms of store propagation, Redux uses Context, whereas Zustand uses module imports. </span><span class="koboSpan" id="kobo.300.2">Context allows the store to be injected at runtime, which works better in some use cases. </span><span class="koboSpan" id="kobo.300.3">Zustand optionally supports Context usage.</span></li>
				<li><span class="koboSpan" id="kobo.301.1">Most importantly, Redux Toolkit is based on Redux, which is based on a one-way data flow. </span><span class="koboSpan" id="kobo.301.2">So, updating the state in Redux requires actions to be dispatched. </span><span class="koboSpan" id="kobo.301.3">This limitation is sometimes good for maintainability and scalability. </span><span class="koboSpan" id="kobo.301.4">Zustand is unopinionated regarding the data flow, and while it can be used for one-way data flow, there is no library support and developers need to take care of everything.</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.302.1">In summary, modern </span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.303.1">Redux is more opinionated </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.304.1">about how to manage the state and Zustand is less opinionated about it. </span><span class="koboSpan" id="kobo.304.2">In the end, Zustand is a minimalistic library, while Redux and its family are a set of full-featured libraries. </span><span class="koboSpan" id="kobo.304.3">The usages of both modern Redux and Zustand seem similar, but the philosophies behind them are different.</span></p>
			<p><span class="koboSpan" id="kobo.305.1">In this section, we saw a comparison between modern Redux and Zustand. </span><span class="koboSpan" id="kobo.305.2">Next up, we will compare Recoil and Jotai.</span></p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.306.1">Understanding when to use Jotai and Recoil</span></h1>
			<p><span class="koboSpan" id="kobo.307.1">Jotai's API is </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.308.1">highly inspired by Recoil. </span><span class="koboSpan" id="kobo.308.2">In the beginning, it's intentionally </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.309.1">designed to help migration from Recoil to Jotai. </span><span class="koboSpan" id="kobo.309.2">In this section, we will see a comparison by converting an example with Recoil into Jotai. </span><span class="koboSpan" id="kobo.309.3">Then, we will discuss the differences between the two.</span></p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.310.1">Example with Recoil and Jotai</span></h2>
			<p><span class="koboSpan" id="kobo.311.1">Let's look </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.312.1">at the Recoil tutorial at </span><a href="https://recoiljs.org/docs/introduction/getting-started"><span class="koboSpan" id="kobo.313.1">https://recoiljs.org/docs/introduction/getting-started</span></a><span class="koboSpan" id="kobo.314.1"> and see how an example in the Recoil tutoria</span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.315.1">l is converted to Jotai.</span></p>
			<p><span class="koboSpan" id="kobo.316.1">To start with the Recoil example, we need to import some functions from the Recoil library:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.317.1">import {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.318.1">  RecoilRoot,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.319.1">  atom,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.320.1">  selector,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.321.1">  useRecoilState,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.322.1">  useRecoilValue,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.323.1">} from "recoil";</span></p>
			<p><span class="koboSpan" id="kobo.324.1">There are five of them used in this example.</span></p>
			<p><span class="koboSpan" id="kobo.325.1">The first state for the text string is created with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">atom</span></strong><span class="koboSpan" id="kobo.327.1"> function:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.328.1">const textState = atom({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.329.1">  key: "textState",</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.330.1">  default: "",</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.331.1">});</span></p>
			<p><span class="koboSpan" id="kobo.332.1">It takes two properties – the </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">key</span></strong><span class="koboSpan" id="kobo.334.1"> string and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">default</span></strong><span class="koboSpan" id="kobo.336.1"> value.</span></p>
			<p><span class="koboSpan" id="kobo.337.1">To use the defined state, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">useRecoilState</span></strong><span class="koboSpan" id="kobo.339.1"> hook:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.340.1">const TextInput = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.341.1">  const [text, setText] = useRecoilState(textState);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.342.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.343.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.344.1">      &lt;input</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.345.1">        type="text"</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.346.1">        value={text}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.347.1">        onChange={(event) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.348.1">          setText(event.target.value);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.349.1">        }}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.350.1">      /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.351.1">      &lt;br /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.352.1">      Echo: {text}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.353.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.354.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.355.1">};</span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">useRecoilState</span></strong><span class="koboSpan" id="kobo.357.1"> returns the same value as </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">useState</span></strong><span class="koboSpan" id="kobo.359.1">. </span><span class="koboSpan" id="kobo.359.2">Hence, the rest of the code should be familiar.</span></p>
			<p><span class="koboSpan" id="kobo.360.1">The second </span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.361.1">state is a derived state. </span><span class="koboSpan" id="kobo.361.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">selector</span></strong><span class="koboSpan" id="kobo.363.1"> function to define a derived state:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.364.1">const charCountState = selector({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.365.1">  key: "charCountState",</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.366.1">  get: ({ get }) =&gt; get(textState).length,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.367.1">});</span></p>
			<p><span class="koboSpan" id="kobo.368.1">It takes two properties – a </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">key</span></strong><span class="koboSpan" id="kobo.370.1"> string and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">get</span></strong><span class="koboSpan" id="kobo.372.1"> function. </span><span class="koboSpan" id="kobo.372.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">get</span></strong><span class="koboSpan" id="kobo.374.1"> property is a function that returns a derived value. </span><span class="koboSpan" id="kobo.374.2">Another </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">get</span></strong><span class="koboSpan" id="kobo.376.1"> function within a </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">get</span></strong><span class="koboSpan" id="kobo.378.1"> property returns the value of other states created by other </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">atom</span></strong><span class="koboSpan" id="kobo.380.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">selector</span></strong><span class="koboSpan" id="kobo.382.1"> functions.</span></p>
			<p><span class="koboSpan" id="kobo.383.1">To use the second state, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">useRecoilValue</span></strong><span class="koboSpan" id="kobo.385.1"> hook, which returns only the value part of the state:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.386.1">const CharacterCount = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.387.1">  const count = useRecoilValue(charCountState);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.388.1">  return &lt;&gt;Character Count: {count}&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.389.1">};</span></p>
			<p><span class="koboSpan" id="kobo.390.1">This component will re-render when </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">textState</span></strong><span class="koboSpan" id="kobo.392.1"> changes because </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">charCountState</span></strong><span class="koboSpan" id="kobo.394.1"> is derived from it.</span></p>
			<p><span class="koboSpan" id="kobo.395.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">CharacterCounter</span></strong><span class="koboSpan" id="kobo.397.1"> component is defined as follows to combine two components that are already defined:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.398.1">const CharacterCounter = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.399.1">  &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.400.1">    &lt;TextInput /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.401.1">    &lt;CharacterCount /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.402.1">  &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.403.1">);</span></p>
			<p><span class="koboSpan" id="kobo.404.1">Finally, we </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.405.1">define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">App</span></strong><span class="koboSpan" id="kobo.407.1"> component:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.408.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.409.1">  &lt;RecoilRoot&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.410.1">    &lt;CharacterCounter /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.411.1">  &lt;/RecoilRoot&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.412.1">);</span></p>
			<p><span class="koboSpan" id="kobo.413.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">App</span></strong><span class="koboSpan" id="kobo.415.1"> component, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">RecoilRoot</span></strong><span class="koboSpan" id="kobo.417.1"> component, which holds state values.</span></p>
			<p><span class="koboSpan" id="kobo.418.1">As shown in </span><em class="italic"><span class="koboSpan" id="kobo.419.1">Figure 11.2</span></em><span class="koboSpan" id="kobo.420.1">, this app works like this: if you type something in the text field, the text will be shown below the text field, and also the number of characters is shown as follows:</span></p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<span class="koboSpan" id="kobo.421.1"><img src="image/Figure_11.2_B17780.jpg" alt=""/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.422.1">Figure 11.2 – Screenshot of the app with Recoil</span></p>
			<p><span class="koboSpan" id="kobo.423.1">Now, let's </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.424.1">convert this example code into Jotai.</span></p>
			<p><span class="koboSpan" id="kobo.425.1">We first import two functions from the Jotai library:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.426.1">import { atom, useAtom } from "jotai";</span></p>
			<p><span class="koboSpan" id="kobo.427.1">Jotai's API tries to be minimal, and the minimal usage requires two functions.</span></p>
			<p><span class="koboSpan" id="kobo.428.1">The first atom for the text string is created with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">atom</span></strong><span class="koboSpan" id="kobo.430.1"> function:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.431.1">const textAtom = atom("");</span></p>
			<p><span class="koboSpan" id="kobo.432.1">This is almost the same as Recoil, except that it only has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">default</span></strong><span class="koboSpan" id="kobo.434.1"> value because Jotai doesn't require the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">key</span></strong><span class="koboSpan" id="kobo.436.1"> string. </span><span class="koboSpan" id="kobo.436.2">Suffixing the variable name with </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">Atom</span></strong><span class="koboSpan" id="kobo.438.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">State</span></strong><span class="koboSpan" id="kobo.440.1"> is a convention that is technically unimportant.</span></p>
			<p><span class="koboSpan" id="kobo.441.1">To use the defined atom, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">useAtom</span></strong><span class="koboSpan" id="kobo.443.1"> function:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.444.1">const TextInput = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.445.1">  const [text, setText] = useAtom(textAtom);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.446.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.447.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.448.1">      &lt;input</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.449.1">        type="text"</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.450.1">        value={text}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.451.1">        onChange={(event) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.452.1">          setText(event.target.value);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.453.1">        }}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.454.1">      /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.455.1">      &lt;br /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.456.1">      Echo: {text}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.457.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.458.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.459.1">};</span></p>
			<p><span class="koboSpan" id="kobo.460.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">useAtom</span></strong><span class="koboSpan" id="kobo.462.1"> function works like </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">useState</span></strong><span class="koboSpan" id="kobo.464.1">, and the rest of the code should be familiar to people who are used to </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">useState</span></strong><span class="koboSpan" id="kobo.466.1">.</span></p>
			<p><span class="koboSpan" id="kobo.467.1">The second </span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.468.1">atom is a derived atom, which is defined with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">atom</span></strong><span class="koboSpan" id="kobo.470.1"> function:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.471.1">const charCountAtom = atom((get) =&gt; get(textAtom).length);</span></p>
			<p><span class="koboSpan" id="kobo.472.1">In this case, we pass a function to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">atom</span></strong><span class="koboSpan" id="kobo.474.1"> function. </span><span class="koboSpan" id="kobo.474.2">The internal function computes the derived value.</span></p>
			<p><span class="koboSpan" id="kobo.475.1">To use the second atom, we again use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">useAtom</span></strong><span class="koboSpan" id="kobo.477.1"> function:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.478.1">const CharacterCount = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.479.1">  const [count] = useAtom(charCountAtom);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.480.1">  return &lt;&gt;Character Count: {count}&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.481.1">};</span></p>
			<p><span class="koboSpan" id="kobo.482.1">It's required to get the first part of the returned value with </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">[count]</span></strong><span class="koboSpan" id="kobo.484.1">. </span><span class="koboSpan" id="kobo.484.2">Other than that, the code and the behavior should be similar to Recoil.</span></p>
			<p><span class="koboSpan" id="kobo.485.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">CharacterCounter</span></strong><span class="koboSpan" id="kobo.487.1"> component is defined as follows to combine two components that are already defined:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.488.1">const CharacterCounter = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.489.1">  &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.490.1">    &lt;TextInput /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.491.1">    &lt;CharacterCount /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.492.1">  &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.493.1">);</span></p>
			<p><span class="koboSpan" id="kobo.494.1">Finally, we define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">App</span></strong><span class="koboSpan" id="kobo.496.1"> component:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.497.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.498.1">  &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.499.1">    &lt;CharacterCounter /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.500.1">  &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.501.1">);</span></p>
			<p><span class="koboSpan" id="kobo.502.1">The minimal </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.503.1">use case of Jotai doesn't require a </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">Provider</span></strong><span class="koboSpan" id="kobo.505.1"> component.</span></p>
			<p><span class="koboSpan" id="kobo.506.1">The conversion from the Recoil example to the Jotai example is mostly syntactic, and the behavior is the same.</span></p>
			<p><span class="koboSpan" id="kobo.507.1">Let's discuss some of the differences.</span></p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.508.1">Comparing examples of Recoil and Jotai</span></h2>
			<p><span class="koboSpan" id="kobo.509.1">Although </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.510.1">there are many differences in terms </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.511.1">of features we didn't use in the example, we'll keep our discussion within the scope of the example we showed, as follows:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.512.1">The biggest difference is the existence of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">key</span></strong><span class="koboSpan" id="kobo.514.1"> string. </span><span class="koboSpan" id="kobo.514.2">One of the big motivations of developing Jotai is to omit the </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">key</span></strong><span class="koboSpan" id="kobo.516.1"> string. </span><span class="koboSpan" id="kobo.516.2">Thanks to this feature, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">atom ({ key: "textState", default: "" })</span></strong><span class="koboSpan" id="kobo.518.1"> atom definition in Recoil can be </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">atom("")</span></strong><span class="koboSpan" id="kobo.520.1"> in Jotai. </span><span class="koboSpan" id="kobo.520.2">Technically, it looks straightforward, but this makes a huge difference to the developer experience. </span><span class="koboSpan" id="kobo.520.3">Naming is a hard task in coding, especially because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">key</span></strong><span class="koboSpan" id="kobo.522.1"> property has to be unique. </span><span class="koboSpan" id="kobo.522.2">Implementation-wise, Jotai utilizes </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">WeakMap</span></strong><span class="koboSpan" id="kobo.524.1"> and relies on the reference of atom objects. </span><span class="koboSpan" id="kobo.524.2">On the other hand, Recoil is based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">key</span></strong><span class="koboSpan" id="kobo.526.1"> strings, which don't rely on object references. </span><span class="koboSpan" id="kobo.526.2">The benefit of </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">key</span></strong><span class="koboSpan" id="kobo.528.1"> strings is that they're serializable. </span><span class="koboSpan" id="kobo.528.2">This should facilitate implementing persistence, which requires serialization. </span><span class="koboSpan" id="kobo.528.3">Jotai would require some techniques to overcome serialization.</span></li>
				<li><span class="koboSpan" id="kobo.529.1">Another difference related to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">key</span></strong><span class="koboSpan" id="kobo.531.1"> string is the unified </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">atom</span></strong><span class="koboSpan" id="kobo.533.1"> function. </span><span class="koboSpan" id="kobo.533.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">atom</span></strong><span class="koboSpan" id="kobo.535.1"> function in Jotai works for both </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">atom</span></strong><span class="koboSpan" id="kobo.537.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">selector</span></strong><span class="koboSpan" id="kobo.539.1"> in Recoil. </span><span class="koboSpan" id="kobo.539.2">However, there's a downside. </span><span class="koboSpan" id="kobo.539.3">It can't be fully expressive and may require other functions in Jotai to support other use cases.</span></li>
				<li><span class="koboSpan" id="kobo.540.1">Last but not least, the provider-less mode in Jotai, which allows omission of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">Provider</span></strong><span class="koboSpan" id="kobo.542.1"> component, is technically simple, but very developer-friendly to lower the mental barrier as regards using the library.</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.543.1">Basic </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.544.1">functionalities are the same in both Recoil and </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.545.1">Jotai and developers would need to make a choice based on other requirements or just their preference in terms of the API. </span><span class="koboSpan" id="kobo.545.2">Jotai's API is minimalistic, the same as Zustand.</span></p>
			<p><span class="koboSpan" id="kobo.546.1">In this section, we saw a comparison between Recoil and Jotai. </span><span class="koboSpan" id="kobo.546.2">Next up, we will see a comparison between MobX and Valtio.</span></p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.547.1">Using Valtio and MobX</span></h1>
			<p><span class="koboSpan" id="kobo.548.1">Although the </span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.549.1">motivation is quite different, Valtio is often compared to MobX (</span><a href="https://mobx.js.org"><span class="koboSpan" id="kobo.550.1">https://mobx.js.org</span></a><span class="koboSpan" id="kobo.551.1">). </span><span class="koboSpan" id="kobo.551.2">Usage-wise, there </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.552.1">are some similarities in Valtio and MobX </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.553.1">regarding their React binding. </span><span class="koboSpan" id="kobo.553.2">Both are based on mutable states and developers can directly mutate state, which results in similar usage. </span><span class="koboSpan" id="kobo.553.3">JavaScript is based on mutable objects, so the syntax of mutating an object is very natural and compact. </span><span class="koboSpan" id="kobo.553.4">This is a big win for mutable states compared to immutable states.</span></p>
			<p><span class="koboSpan" id="kobo.554.1">On the other </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.555.1">hand, there is a difference in how they optimize renders. </span><span class="koboSpan" id="kobo.555.2">For render optimization, while Valtio uses a hook, MobX React uses a </span><strong class="bold"><span class="koboSpan" id="kobo.556.1">higher-order component</span></strong><span class="koboSpan" id="kobo.557.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.558.1">HoC</span></strong><span class="koboSpan" id="kobo.559.1">): </span><a href="https://reactjs.org/docs/higher-order-components.html"><span class="koboSpan" id="kobo.560.1">https://reactjs.org/docs/higher-order-components.html</span></a><span class="koboSpan" id="kobo.561.1">.</span></p>
			<p><span class="koboSpan" id="kobo.562.1">In this section, we will convert a simple MobX example into Valtio. </span><span class="koboSpan" id="kobo.562.2">Then we will see the differences between the two.</span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.563.1">Important Note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.564.1">Conceptually, Valtio is </span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.565.1">comparable to Immer (</span><a href="https://immerjs.github.io/immer/"><span class="koboSpan" id="kobo.566.1">https://immerjs.github.io/immer/</span></a><span class="koboSpan" id="kobo.567.1">). </span><span class="koboSpan" id="kobo.567.2">Both try to bridge immutable and mutable states. </span><span class="koboSpan" id="kobo.567.3">Valtio is based on mutable states and converts states to immutable ones, whereas Immer is based on immutable states and uses mutable states (drafts) temporarily.</span></p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.568.1">Example involving MobX and Valtio</span></h2>
			<p><span class="koboSpan" id="kobo.569.1">Let's take </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.570.1">an example from MobX's documentation: </span><a href="https://mobx.js.org/README.html#a-quick-example"><span class="koboSpan" id="kobo.571.1">https://mobx.js.org/README.html#a-quick-example</span></a><span class="koboSpan" id="kobo.572.1">.</span></p>
			<p><span class="koboSpan" id="kobo.573.1">We first </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.574.1">import some functions from the MobX libraries:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.575.1">import { makeAutoObservable } from "mobx";</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.576.1">import { observer } from "mobx-react";</span></p>
			<p><span class="koboSpan" id="kobo.577.1">As the MobX library is framework-agnostic, the React-related function is imported from the MobX React library.</span></p>
			<p><span class="koboSpan" id="kobo.578.1">The next step is to define the business logic, which is a timer. </span><span class="koboSpan" id="kobo.578.2">We create a class and then instantiate it:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.579.1">class Timer {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.580.1">  secondsPassed = 0;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.581.1">  constructor() {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.582.1">    makeAutoObservable(this);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.583.1">  }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.584.1">  increase() {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.585.1">    this.secondsPassed += 1;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.586.1">  }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.587.1">  reset() {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.588.1">    this.secondsPassed = 0;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.589.1">  }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.590.1">}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.591.1">const myTimer = new Timer();</span></p>
			<p><span class="koboSpan" id="kobo.592.1">It has </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.593.1">one property and two functions to mutate the property. </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">makeAutoObservable</span></strong><span class="koboSpan" id="kobo.595.1"> is used to make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">myTimer</span></strong><span class="koboSpan" id="kobo.597.1"> instance an observable object.</span></p>
			<p><span class="koboSpan" id="kobo.598.1">We can </span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.599.1">call the mutating function anywhere within the code. </span><span class="koboSpan" id="kobo.599.2">As an example, let's set an interval:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.600.1">setInterval(() =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.601.1">  myTimer.increase();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.602.1">}, 1000);</span></p>
			<p><span class="koboSpan" id="kobo.603.1">This will increase the </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">secondsPassed</span></strong><span class="koboSpan" id="kobo.605.1"> property every second.</span></p>
			<p><span class="koboSpan" id="kobo.606.1">Now, the component to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">timer</span></strong><span class="koboSpan" id="kobo.608.1"> is the following:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.609.1">const TimerView = observer(({ timer }: { timer: Timer }) =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.610.1">  &lt;button onClick={() =&gt; timer.reset()}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.611.1">    Seconds passed: {timer.secondsPassed}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.612.1">  &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.613.1">));</span></p>
			<p><span class="koboSpan" id="kobo.614.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">observer</span></strong><span class="koboSpan" id="kobo.616.1"> function is an HoC. </span><span class="koboSpan" id="kobo.616.2">It understands </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">timer.secondsPassed</span></strong><span class="koboSpan" id="kobo.618.1"> is used in a render function, and will trigger re-renders when </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">timer.secondsPassed</span></strong><span class="koboSpan" id="kobo.620.1"> changes.</span></p>
			<p><span class="koboSpan" id="kobo.621.1">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">App</span></strong><span class="koboSpan" id="kobo.623.1"> component has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">TimerView</span></strong><span class="koboSpan" id="kobo.625.1"> component with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">myTimer</span></strong><span class="koboSpan" id="kobo.627.1"> instance:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.628.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.629.1">  &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.630.1">    &lt;TimerView timer={myTimer} /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.631.1">  &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.632.1">);</span></p>
			<p><span class="koboSpan" id="kobo.633.1">As </span><em class="italic"><span class="koboSpan" id="kobo.634.1">Figure 11.3</span></em><span class="koboSpan" id="kobo.635.1"> shows, if you run this app, it will show a button with a label showing the number of seconds that have passed. </span><span class="koboSpan" id="kobo.635.2">The label changes every second. </span><span class="koboSpan" id="kobo.635.3">Clicking this button will reset the number.</span></p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<span class="koboSpan" id="kobo.636.1"><img src="image/Figure_11.3_B17780.jpg" alt=""/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.637.1">Figure 11.3 – Screenshot of the app with MobX</span></p>
			<p><span class="koboSpan" id="kobo.638.1">Now, what </span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.639.1">would this look like with Valtio? </span><span class="koboSpan" id="kobo.639.2">Let's see the same example with Valtio.</span></p>
			<p><span class="koboSpan" id="kobo.640.1">We first </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.641.1">import two functions from the Valtio library:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.642.1">import { proxy, useSnapshot } from "valtio";</span></p>
			<p><span class="koboSpan" id="kobo.643.1">Although Valtio is a library for React, it has a vanilla bundle for non-React use cases.</span></p>
			<p><span class="koboSpan" id="kobo.644.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">proxy</span></strong><span class="koboSpan" id="kobo.646.1"> function to define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">myTimer</span></strong><span class="koboSpan" id="kobo.648.1"> instance:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.649.1">const myTimer = proxy({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.650.1">  secondsPassed: 0,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.651.1">  increase: () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.652.1">    myTimer.secondsPassed += 1;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.653.1">  },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.654.1">  reset: () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.655.1">    myTimer.secondsPassed = 0;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.656.1">  },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.657.1">});</span></p>
			<p><span class="koboSpan" id="kobo.658.1">It has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">secondsPassed</span></strong><span class="koboSpan" id="kobo.660.1"> property for a number value and two function properties to update the number value.</span></p>
			<p><span class="koboSpan" id="kobo.661.1">We use one of the function properties to increase the </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">secondsPassed</span></strong><span class="koboSpan" id="kobo.663.1"> property periodically:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.664.1">setInterval(() =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.665.1">  myTimer.increase();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.666.1">}, 1000);</span></p>
			<p><span class="koboSpan" id="kobo.667.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">setInterval</span></strong><span class="koboSpan" id="kobo.669.1"> usage </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.670.1">is exactly the same as MobX.</span></p>
			<p><span class="koboSpan" id="kobo.671.1">Next is </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.672.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">TimerView</span></strong><span class="koboSpan" id="kobo.674.1"> component using </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">useSnapshot</span></strong><span class="koboSpan" id="kobo.676.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.677.1">const TimerView = ({ timer }: { timer: typeof myTimer }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.678.1">  const snap = useSnapshot(timer);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.679.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.680.1">    &lt;button onClick={() =&gt; timer.reset()}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.681.1">      Seconds passed: {snap.secondsPassed}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.682.1">    &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.683.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.684.1">};</span></p>
			<p><span class="koboSpan" id="kobo.685.1">In Valtio, </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">useSnapshot</span></strong><span class="koboSpan" id="kobo.687.1"> is a hook to understand how a state is used in a render function and will trigger re-renders when the used part in the state is changed.</span></p>
			<p><span class="koboSpan" id="kobo.688.1">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">App</span></strong><span class="koboSpan" id="kobo.690.1"> component is the same as MobX:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.691.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.692.1">  &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.693.1">    &lt;TimerView timer={myTimer} /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.694.1">  &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.695.1">);</span></p>
			<p><span class="koboSpan" id="kobo.696.1">In the end, we should have the same behavior as MobX. </span><span class="koboSpan" id="kobo.696.2">It shows a button with a label. </span><span class="koboSpan" id="kobo.696.3">The label shows the number of seconds that have passed, and clicking the button will reset the value.</span></p>
			<p><span class="koboSpan" id="kobo.697.1">Now, let's discuss some differences. </span></p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.698.1">Comparing examples of MobX and Valtio</span></h2>
			<p><span class="koboSpan" id="kobo.699.1">The two </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.700.1">examples in MobX and Valtio look similar, but </span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.701.1">there are two major differences:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.702.1">The first difference is the updating method. </span><span class="koboSpan" id="kobo.702.2">Although both use mutations, the MobX example is class-based, whereas the Valtio example is object-based. </span><span class="koboSpan" id="kobo.702.3">It's mostly stylistic, and Valtio is not very opinionated regarding the styles.</span><p><span class="koboSpan" id="kobo.703.1">One of the styles Valtio allows is the separation of functions from the state object. </span><span class="koboSpan" id="kobo.703.2">The same example can be implemented in the following approach:</span></p><p class="source-code"><span class="koboSpan" id="kobo.704.1">// timer.js</span></p><p class="source-code"><span class="koboSpan" id="kobo.705.1">const timer = proxy({ secondsPassed: 0 })</span></p><p class="source-code"><span class="koboSpan" id="kobo.706.1">export const increase = () =&gt; {</span></p><p class="source-code"><span class="koboSpan" id="kobo.707.1">  timer.secondsPassed += 1;</span></p><p class="source-code"><span class="koboSpan" id="kobo.708.1">};</span></p><p class="source-code"><span class="koboSpan" id="kobo.709.1">export const reset = () =&gt; {</span></p><p class="source-code"><span class="koboSpan" id="kobo.710.1">  timer.secondsPassed = 0;</span></p><p class="source-code"><span class="koboSpan" id="kobo.711.1">};</span></p><p class="source-code"><span class="koboSpan" id="kobo.712.1">export const useSecondsPasses = () =&gt;</span></p><p class="source-code"><span class="koboSpan" id="kobo.713.1">  useSnapshot(timer).secondsPassed;</span></p><p><span class="koboSpan" id="kobo.714.1">We define updating functions outside the state object defined by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">proxy</span></strong><span class="koboSpan" id="kobo.716.1"> function. </span><span class="koboSpan" id="kobo.716.2">The benefit of this approach is that it allows code-splitting, minification, and dead code elimination. </span><span class="koboSpan" id="kobo.716.3">In the end, we can expect an optimized bundle size.</span></p></li>
				<li><span class="koboSpan" id="kobo.717.1">The second difference is the render optimization method. </span><span class="koboSpan" id="kobo.717.2">While MobX takes the observer approach, Valtio takes the hook approach. </span><span class="koboSpan" id="kobo.717.3">There are pros and cons to each. </span><span class="koboSpan" id="kobo.717.4">The </span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.718.1">observer approach is more </span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.719.1">predictable. </span><span class="koboSpan" id="kobo.719.2">The hook approach is more "concurrent rendering" friendly. </span><span class="koboSpan" id="kobo.719.3">Implementing this approach is likely very different. </span><span class="koboSpan" id="kobo.719.4">There's also a stylistic difference; some developers prefer the HoC style, while other developers prefer the hook style.</span><p class="callout-heading"><span class="koboSpan" id="kobo.720.1">Important Note</span></p><p class="callout"><span class="koboSpan" id="kobo.721.1">As of the time of writing, we only have limited information about concurrent rendering. </span><span class="koboSpan" id="kobo.721.2">It's our best observation at this point, but it's not guaranteed whether the statement will hold in the future.</span></p></li>
			</ul>
			<p><span class="koboSpan" id="kobo.722.1">In this section, we saw a comparison between MobX and Valtio. </span><span class="koboSpan" id="kobo.722.2">Next up, we will discuss a comparison between Zustand, Jotai, and Valtio.</span></p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.723.1">Comparing Zustand, Jotai, and Valtio</span></h1>
			<p><span class="koboSpan" id="kobo.724.1">In this </span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.725.1">chapter so </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.726.1">far, we have compared the following pairs:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.727.1">Zustand </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.728.1">and Redux </span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.729.1">in the </span><em class="italic"><span class="koboSpan" id="kobo.730.1">Differences between Zustand and Redux</span></em><span class="koboSpan" id="kobo.731.1"> section</span></li>
				<li><span class="koboSpan" id="kobo.732.1">Jotai </span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.733.1">and Recoil </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.734.1">in the </span><em class="italic"><span class="koboSpan" id="kobo.735.1">Understanding when to use Jotai and Recoil</span></em><span class="koboSpan" id="kobo.736.1"> section</span></li>
				<li><span class="koboSpan" id="kobo.737.1">Valtio and MobX in the </span><em class="italic"><span class="koboSpan" id="kobo.738.1">Using Valtio and MobX</span></em><span class="koboSpan" id="kobo.739.1"> section</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.740.1">We compared these pairs because there are some similarities. </span><span class="koboSpan" id="kobo.740.2">In this section, we will compare Zustand, Jotai, and Valtio.</span></p>
			<p><span class="koboSpan" id="kobo.741.1">First of all, all three libraries are provided by the Poimandres GitHub organization (</span><a href="https://github.com/pmndrs"><span class="koboSpan" id="kobo.742.1">https://github.com/pmndrs</span></a><span class="koboSpan" id="kobo.743.1">). </span><span class="koboSpan" id="kobo.743.2">It's a developer collective providing many libraries. </span><span class="koboSpan" id="kobo.743.3">Three micro-state </span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.744.1">management libraries from a single GitHub organization </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.745.1">may sound counter-intuitive, but they are in different styles. </span><span class="koboSpan" id="kobo.745.2">There is also a philosophy that is common in the three libraries: their small API surfaces. </span><span class="koboSpan" id="kobo.745.3">All three </span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.746.1">libraries try their best to provide small API </span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.747.1">surfaces and let developers compose the APIs as they want.</span></p>
			<p><span class="koboSpan" id="kobo.748.1">But then, what </span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.749.1">are the </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.750.1">differences between the three libraries? </span></p>
			<p><span class="koboSpan" id="kobo.751.1">There are two aspects: </span></p>
			<ul>
				<li><strong class="bold"><span class="koboSpan" id="kobo.752.1">Where does the state reside?</span></strong><span class="koboSpan" id="kobo.753.1"> In React, there are two approaches. </span><span class="koboSpan" id="kobo.753.2">One is the module state, and the other is the component state. </span><span class="koboSpan" id="kobo.753.3">A module state is a state that is created at the module level and doesn't belong to React. </span><span class="koboSpan" id="kobo.753.4">A component state is a state that is created in React component life cycles and controlled by React. </span><span class="koboSpan" id="kobo.753.5">Zustand and Valtio are designed for module states. </span><span class="koboSpan" id="kobo.753.6">On the other hand, Jotai is designed for component states. </span><span class="koboSpan" id="kobo.753.7">For example, consider Jotai atoms. </span><span class="koboSpan" id="kobo.753.8">The following is a definition of </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">countAtom</span></strong><span class="koboSpan" id="kobo.755.1">:</span><p class="source-code"><span class="koboSpan" id="kobo.756.1">const countAtom = atom(0);</span></p><p><span class="koboSpan" id="kobo.757.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">countAtom</span></strong><span class="koboSpan" id="kobo.759.1"> variable holds a config object, and it doesn't hold a value. </span><span class="koboSpan" id="kobo.759.2">The atom values are stored in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">Provider</span></strong><span class="koboSpan" id="kobo.761.1"> component. </span><span class="koboSpan" id="kobo.761.2">Hence, </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">countAtom</span></strong><span class="koboSpan" id="kobo.763.1"> can be reused for multiple components. </span><span class="koboSpan" id="kobo.763.2">Implementing the same behavior is tricky with module states. </span><span class="koboSpan" id="kobo.763.3">With Zustand and Valtio, we would end up using React Context. </span><span class="koboSpan" id="kobo.763.4">On the other hand, accessing component states from outside React is technically not possible. </span><span class="koboSpan" id="kobo.763.5">We'll likely need some sort of module state to connect to the component states.</span></p><p><span class="koboSpan" id="kobo.764.1">Whether we use module states or component states depends on the app requirements. </span><span class="koboSpan" id="kobo.764.2">Usually, using either module states or component states for global states fulfills the app requirements, but in some rare cases, using both types of states may make sense.</span></p></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.765.1">What is the state updating style?</span></strong><span class="koboSpan" id="kobo.766.1"> There is a major difference between Zustand and Valtio. </span><span class="koboSpan" id="kobo.766.2">Zustand is based on the immutable state model, while Valtio is based on the mutable state model. </span><span class="koboSpan" id="kobo.766.3">The contract in the immutable state model is that </span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.767.1">objects cannot be changed once created. </span><span class="koboSpan" id="kobo.767.2">Suppose </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.768.1">you have a state variable such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">state = { count: 0 }</span></strong><span class="koboSpan" id="kobo.770.1">. </span><span class="koboSpan" id="kobo.770.2">If you want to update the count in the immutable state model, you need to </span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.771.1">create a new object. </span><span class="koboSpan" id="kobo.771.2">Hence, incrementing the count by </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">1</span></strong><span class="koboSpan" id="kobo.773.1"> should be </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">state = { count: state.count + 1 }</span></strong><span class="koboSpan" id="kobo.775.1">. </span><span class="koboSpan" id="kobo.775.2">In the mutable state mode, it </span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.776.1">could be </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">++state.count</span></strong><span class="koboSpan" id="kobo.778.1">. </span><span class="koboSpan" id="kobo.778.2">This is because JavaScript objects are mutable by nature. </span><span class="koboSpan" id="kobo.778.3">The benefit of the immutable model is that you </span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.779.1">can compare the object references to know </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.780.1">whether anything has changed. </span><span class="koboSpan" id="kobo.780.2">It helps improve performance for large, nested objects. </span><span class="koboSpan" id="kobo.780.3">Because React is mostly based on the immutable model, Zustand with the same model has compatibility. </span><span class="koboSpan" id="kobo.780.4">Thus, Zustand is a very thin library. </span><span class="koboSpan" id="kobo.780.5">On the other hand, Valtio, with the mutable state model, requires filling the gap between the two models. </span><span class="koboSpan" id="kobo.780.6">In the end, Zustand and Valtio take different state updating styles. </span><span class="koboSpan" id="kobo.780.7">The mutable updating style is very handy, especially when an object is deeply nested. </span><span class="koboSpan" id="kobo.780.8">Revisit the example in </span><em class="italic"><span class="koboSpan" id="kobo.781.1">The pros and cons of this approach</span></em><span class="koboSpan" id="kobo.782.1"> section of </span><a href="B17780_09_Final_VK_ePub.xhtml#_idTextAnchor116"><em class="italic"><span class="koboSpan" id="kobo.783.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.784.1">, </span><em class="italic"><span class="koboSpan" id="kobo.785.1">Use Case Scenario 3 – Valtio</span></em><span class="koboSpan" id="kobo.786.1">.</span><p class="callout-heading"><span class="koboSpan" id="kobo.787.1">Note Regarding the Use of Immer</span></p><p class="callout"><span class="koboSpan" id="kobo.788.1">It's possible to use </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.789.1">Immer to allow mutations to update states in Zustand and Jotai. </span><span class="koboSpan" id="kobo.789.2">Compared to the combination of Zustand and Immer, Valtio is more optimized for the mutable state model. </span><span class="koboSpan" id="kobo.789.3">It has smaller API surfaces and it also optimizes re-renders. </span><span class="koboSpan" id="kobo.789.4">The combination of Jotai and Immer is useful for big objects, and the Jotai library provides a specific feature to integrate Immer. </span><span class="koboSpan" id="kobo.789.5">However, Jotai atoms are usually small, and in such a case, the immutable updating style is not a big issue.</span></p></li>
			</ul>
			<p><span class="koboSpan" id="kobo.790.1">There are some minor differences among the three libraries, but what's important is the fact that they are based on different principles. </span><span class="koboSpan" id="kobo.790.2">If we were to choose one of them, we would need to see which principle fits well with our app requirements and our mental model.</span></p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.791.1">Summary</span></h1>
			<p><span class="koboSpan" id="kobo.792.1">In this chapter, we summarized the differences between the three libraries for a global state we explained in this book. </span><span class="koboSpan" id="kobo.792.2">They are different because they are based on different models.</span></p>
			<p><span class="koboSpan" id="kobo.793.1">Essentially, micro-state management involves choosing the right solution and the right library for a specific problem. </span><span class="koboSpan" id="kobo.793.2">Micro state management requires you to understand what your problem is and what solutions are available for your problem. </span><span class="koboSpan" id="kobo.793.3">We hope that this book has covered some topics that will help developers find the right solution.</span></p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.794.1">Hi!</span></h1>
			<p><span class="koboSpan" id="kobo.795.1">I am Daishi Kato, author of Micro State Management with React Hooks. </span><span class="koboSpan" id="kobo.795.2">I really hope you enjoyed reading this book and found it useful for increasing your productivity and efficiency in React Hooks. </span></p>
			<p><span class="koboSpan" id="kobo.796.1">It would really help me (and other potential readers!) if you could leave a review on Amazon sharing your thoughts on Micro State Management with React Hooks here. </span></p>
			<p><span class="koboSpan" id="kobo.797.1">Go to the link below or scan the QR code to leave your review:</span></p>
			<p><a href="https://packt.link/r/1801812373"><span class="koboSpan" id="kobo.798.1">https://packt.link/r/1801812373</span></a></p>
			<p><span class="koboSpan" id="kobo.799.1"><img src="image/QR_code_B17780.png" alt="Qr code  Description automatically generated"/></span></p>
			<p><span class="koboSpan" id="kobo.800.1">Your review will help me to understand what's worked well in this book, and what could be improved upon for future editions, so it really is appreciated.</span></p>
			<p><span class="koboSpan" id="kobo.801.1">Best wishes,</span></p>
			<p><span class="koboSpan" id="kobo.802.1"><img src="image/Author_photo.png" alt=""/></span></p>
			<p><span class="koboSpan" id="kobo.803.1">Daishi Kato</span></p>
		</div>
	</body></html>