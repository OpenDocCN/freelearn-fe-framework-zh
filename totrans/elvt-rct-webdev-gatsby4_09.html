<html><head></head><body>
		<div id="_idContainer037">
			<h1 id="_idParaDest-104"><em class="italic"><a id="_idTextAnchor105"/>Chapter 7</em>: Testing and Auditing Your Site</h1>
			<p>In this chapter, we will learn about what unit testing is, why it's useful, and how to start unit testing your Gatsby site. We will then learn how we can use Git hooks to trigger your unit tests and other commands when running common Git commands. Following this, we will investigate how we can measure core web vitals to understand how well our Gatsby site's page experience is performing, both in lab and field environments. By the end of this chapter, you should feel comfortable that you can analyze how well a Gatsby site is working locally by using unit tests and looking at web vitals when it is out there on the web. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Exploring unit testing</li>
				<li>Adding Git hooks for tests</li>
				<li>Auditing core web vitals</li>
			</ul>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor106"/>Technical requirements</h1>
			<p>To complete this chapter, you will need to have completed <a href="B15983_06_ePub_RK.xhtml#_idTextAnchor092"><em class="italic">Chapter 6</em></a>, <em class="italic">Improving Your Site's Search Engine Optimization</em>. You will also need Google Chrome installed.</p>
			<p>The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter07">https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter07</a>.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor107"/>Exploring unit testing</h1>
			<p>Unit testing is a <a id="_idIndexMarker385"/>way of testing the smallest piece of code that you have logically defined within your application. During unit testing, we isolate a small part of the code and verify that it is behaving as intended independently from the rest of the code base. We instantiate this piece of code, invoke it, and then observe its behavior. If the observed behavior matches what we expected, then we know that our code is doing what it should be. By setting up a multitude of these tests, we can have a better understanding of where something has broken when we edit large parts of the code base.</p>
			<p>Within React and Gatsby, there <a id="_idIndexMarker386"/>are multiple different ways in which you can set up unit tests. Here, we will focus on one of the most popular combinations – <strong class="bold">Jest</strong> and <strong class="bold">React Testing Library</strong>. Let's create a structure within our repository <a id="_idIndexMarker387"/>that will <a id="_idIndexMarker388"/>allow us to test our site using these tools:</p>
			<ol>
				<li>Install the necessary dependencies:<p class="source-code">npm install -D jest babel-jest @testing-library/jest-</p><p class="source-code">dom @testing-library/react babel-preset-gatsby</p><p class="source-code">identity-obj-proxy</p></li>
				<li>Create a <strong class="source-inline">jest.config.js</strong> file:<p class="source-code">module.exports = {</p><p class="source-code">  transform: {</p><p class="source-code">    "^.+\\.jsx?$": '&lt;rootDir&gt;/jest-preprocess.js',</p><p class="source-code">  },</p><p class="source-code">  moduleNameMapper: {</p><p class="source-code">    ".+\\.(css|styl|less|sass|scss)$": 'identity-obj-</p><p class="source-code">      proxy',</p><p class="source-code">    ".+\\.(jpg|jpeg|png|gif|eot|otf|webp</p><p class="source-code">      |svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac</p><p class="source-code">      |oga)$": '&lt;rootDir&gt;/__mocks__/file-mock.js',</p><p class="source-code">  },</p><p class="source-code">  testPathIgnorePatterns: ['node_modules', '.cache'],</p><p class="source-code">  transformIgnorePatterns:</p><p class="source-code">    ['node_modules/(?!(gatsby)/)'],</p><p class="source-code">    testEnvironment: "jsdom",</p><p class="source-code">    globals: {__PATH_PREFIX__: '',</p><p class="source-code">  },</p><p class="source-code">  setupFiles: ['&lt;rootDir&gt;/loadershim.js'],</p><p class="source-code">  setupFilesAfterEnv: ['&lt;rootDir&gt;/jest.setup.js']</p><p class="source-code">};</p><p>Both Gatsby and Jest use Babel under the hood. However, unlike Gatsby, Jest does not handle its own Babel configuration. We use the <strong class="source-inline">jest.config.js</strong> file to manually set up Jest with Babel, as well as configure our tests.</p><p>Let's break down <a id="_idIndexMarker389"/>the contents of this file so that we understand what each part is doing:</p><p>a. <strong class="source-inline">transform</strong>: This tells Jest that all the files that end in <strong class="source-inline">.js</strong> or <strong class="source-inline">.jsx</strong> need to be handled with a <strong class="source-inline">jest-preprocess.js</strong> file, which we will create in the next step.</p><p>b. <strong class="source-inline">moduleNameMapper</strong>: When testing, it is uncommon to test static assets such as images. As such, Jest does not care for them. But it is still important that it knows how to handle them as they may be embedded in your code. Here, we are giving Jest a mock for handling stylesheets that uses the <strong class="source-inline">identity-obj-proxy</strong> package, which we installed in the first step, and another mock that handles common image, video, and sound files. We will create this second mock later in this section.</p><p>c. <strong class="source-inline">testPathIgnorePatterns</strong>: This tells Jest to ignore any tests found within <strong class="source-inline">node_modules</strong> as we do not want to bring in tests that have been found within our packages and the <strong class="source-inline">.cache</strong> directory.</p><p>d. <strong class="source-inline">transformIgnorePatterns</strong>: Here, we tell Jest to ignore Gatsby when it is transforming code, as Gatsby includes untranspiled ES6 code.</p><p>e. <strong class="source-inline">globals</strong>: This is where we define a global variable called <strong class="source-inline">__PATH_PREFIX__</strong> that Gatsby uses behind the scenes. We need to define it here too as some Gatsby components will break without it being present.</p><p>f. <strong class="source-inline">setupFiles</strong>: Here, we list the configuration files that we would like to use to configure the testing environment. It is run once per test. Here, we tell it to run <strong class="source-inline">loadershim.js</strong>, which we will create later in this section. </p><p>g. <strong class="source-inline">setupFilesAfterEnv</strong>: Here, we specify the configuration files we would like to use to set up our tests. Crucially, these files run after the testing environment has been set up.</p></li>
				<li>Create a <strong class="source-inline">jest-preprocess.js</strong> file within your root directory:<p class="source-code">const babelOptions = {</p><p class="source-code">  presets: ["babel-preset-gatsby"],</p><p class="source-code">};</p><p class="source-code">module.exports = require("babel-</p><p class="source-code">  jest").default.createTransformer(babelOptions);</p><p>This is where we <a id="_idIndexMarker390"/>define our Babel configuration. As we are working with Gatsby, we are using the <strong class="source-inline">babel-preset-gatsby</strong> preset. You can expand this preset list as necessary. </p></li>
				<li>Create a <strong class="source-inline">loadershim.js</strong> file within your root directory:<p class="source-code">global.___loader = {</p><p class="source-code">    enqueue: jest.fn(),</p><p class="source-code"> }</p><p>We use this file to mock a global <strong class="source-inline">loader.enqueue</strong> function using a Jest mock function. </p></li>
				<li>Create a new folder in your root directory called <strong class="source-inline">__mocks__</strong>. </li>
				<li>Create a <strong class="source-inline">file-mock.js</strong> file within the <strong class="source-inline">__mocks__</strong> folder: <p class="source-code">module.exports = "test-file-mock"</p><p>As we <a id="_idIndexMarker391"/>mentioned in <em class="italic">Step 2</em>, this file mocks out static asset file types.</p></li>
				<li>Create a <strong class="source-inline">gatsby.js</strong> file within the <strong class="source-inline">__mocks__</strong> folder: <p class="source-code">const React = require("react")</p><p class="source-code">const gatsby = jest.requireActual("gatsby")</p><p class="source-code">module.exports = {</p><p class="source-code">  ...gatsby,</p><p class="source-code">  graphql: jest.fn(),</p><p class="source-code">  Link: jest.fn().mockImplementation(</p><p class="source-code">    ({</p><p class="source-code">      activeClassName,</p><p class="source-code">      activeStyle,</p><p class="source-code">      getProps,</p><p class="source-code">      innerRef,</p><p class="source-code">      partiallyActive,</p><p class="source-code">      ref,</p><p class="source-code">      replace,</p><p class="source-code">      to,</p><p class="source-code">      ...rest</p><p class="source-code">    }) =&gt;</p><p class="source-code">      React.createElement("a", {</p><p class="source-code">        ...rest,</p><p class="source-code">        href: to,</p><p class="source-code">      })</p><p class="source-code">  ),</p><p class="source-code">  StaticQuery: () =&gt; React.createElement("div", {</p><p class="source-code">    id: "StaticQuery",</p><p class="source-code">  }),</p><p class="source-code">  useStaticQuery: jest.fn(),</p><p class="source-code">}</p><p>Here, we are <a id="_idIndexMarker392"/>mocking out any components or functions that we are using from the <strong class="source-inline">gatsby</strong> package. We strip the props from the <strong class="source-inline">Link</strong> component and return an <strong class="source-inline">&lt;a/&gt;</strong> tag instead. We return a <strong class="source-inline">div</strong> in place of the <strong class="source-inline">StaticQuery</strong> component. Finally, we also mock out the <strong class="source-inline">useStaticQuery</strong> function with a Jest mock function.</p></li>
				<li>Create a <strong class="source-inline">gatsby-plugin-image.js</strong> file within the <strong class="source-inline">__mocks__</strong> folder: <p class="source-code">const React = require("react")</p><p class="source-code">const gatsbyPluginImage = jest.requireActual("gatsby-</p><p class="source-code">  plugin-image")</p><p class="source-code">module.exports = {</p><p class="source-code">  ...gatsbyPluginImage,</p><p class="source-code">  StaticImage: () =&gt; React.createElement("div", {</p><p class="source-code">    id: "StaticImage",</p><p class="source-code">  }),</p><p class="source-code">}</p><p>Here, we are mocking out any components or functions that we are using from the <strong class="source-inline">gatsby-plugin-image</strong> package. We return a <strong class="source-inline">div</strong> in place of the <strong class="source-inline">StaticImage</strong> component.</p></li>
				<li>Create a <strong class="source-inline">jest.setup.js</strong> file within your root directory:<p class="source-code">require('@testing-library/jest-dom/extend-expect');</p><p class="source-code">const { useStaticQuery } = require("gatsby");</p><p class="source-code">beforeAll(() =&gt; {</p><p class="source-code">  useStaticQuery.mockReturnValue({</p><p class="source-code">    site: {</p><p class="source-code">      siteMetadata: {</p><p class="source-code">        siteUrl: "test.url.com",</p><p class="source-code">        social: { twitter: "@slarsendisney" },</p><p class="source-code">      },</p><p class="source-code">    },</p><p class="source-code">  });</p><p class="source-code">});</p><p>Before <a id="_idIndexMarker393"/>each test, we need to mock a return value for <strong class="source-inline">useStaticQuery</strong>. Any page components that make use of the SEO component will fail unless they can retrieve this data from the function.</p></li>
				<li>Create a <strong class="source-inline">test-utils.js</strong> file within your <strong class="source-inline">src</strong> directory:<p class="source-code">import React from 'react'</p><p class="source-code">import {render} from '@testing-library/react'</p><p class="source-code">import { HelmetProvider } from "react-helmet-async";</p><p class="source-code">const Wrapper = ({children}) =&gt; {</p><p class="source-code">  return (</p><p class="source-code">    &lt;HelmetProvider&gt;</p><p class="source-code">        {children}</p><p class="source-code">    &lt;/HelmetProvider&gt;</p><p class="source-code">  )</p><p class="source-code">}</p><p class="source-code">const customRender = (ui, options) =&gt;</p><p class="source-code">  render(ui, {wrapper: Wrapper, ...options})</p><p class="source-code">export {customRender as render}</p><p>This file is <a id="_idIndexMarker394"/>not required but is helpful. Much of your application might make use of a provider, which we would normally wrap our root element in, within <strong class="source-inline">gatsby-browser.js</strong>. We can't do that in Jest. So, instead of defining <strong class="source-inline">wrapper</strong> in every test, it is preferable to create a custom <strong class="source-inline">render</strong> function that wraps any content in the required providers. We then call this <strong class="source-inline">render</strong> instead of the one that's exported from <strong class="source-inline">@testing-library/react</strong> when required.</p></li>
				<li>Create a test script within your <strong class="source-inline">package.json</strong> file:<p class="source-code">"scripts": {</p><p class="source-code">    "build": "gatsby build",</p><p class="source-code">    "develop": "gatsby develop",</p><p class="source-code">    "start": "npm run develop",</p><p class="source-code">    "serve": "gatsby serve",</p><p class="source-code">    "clean": "gatsby clean",</p><p class="source-code">    <strong class="bold">"test": "jest"</strong></p><p class="source-code">  },</p><p>Now, when using the <strong class="source-inline">npm run test</strong> command, it will start Jest and begin testing.</p></li>
			</ol>
			<p>We now have everything in place to start testing! This book does not have space for a full guide on unit testing. However, let's create a few example tests for a few different component <a id="_idIndexMarker395"/>types, such as simple components, SEO components, and our Gatsby page components. </p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor108"/>Testing simple components</h2>
			<p>Testing simple <a id="_idIndexMarker396"/>components can be done in the same <a id="_idIndexMarker397"/>way you would do so in any standard react project. Let's take a look at how we would test our header component, as an example. </p>
			<p>Create a <strong class="source-inline">Header.test.js</strong> file next to your header component using the following code:</p>
			<p class="source-code">import React from "react";</p>
			<p class="source-code">import {render, screen} from '@testing-library/react'</p>
			<p class="source-code">import '@testing-library/jest-dom'</p>
			<p class="source-code">import Header from "./Header";</p>
			<p class="source-code">test("Renders header", async () =&gt; {</p>
			<p class="source-code">  render(&lt;Header /&gt;);</p>
			<p class="source-code">  expect(screen.getByText('Site Header'))</p>
			<p class="source-code">});</p>
			<p>Here, we are rendering our <strong class="source-inline">Header</strong> component to the screen. We are then testing that the screen contains some text stating <strong class="source-inline">Site Header</strong> to ensure that the <strong class="source-inline">Header</strong> component is rendered. We do this by using the <strong class="source-inline">screen.getByText</strong> function. </p>
			<p>Now that we understand how to test simple components, let's look at a more complex example – your site's SEO component.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor109"/>Testing the SEO component</h2>
			<p>A common component among Gatsby pages that is important to test is the SEO component. It is <a id="_idIndexMarker398"/>important to ensure that the meta tags we are <a id="_idIndexMarker399"/>adding using the component are being correctly applied to the document's head so that we know that when that page is shared, it will have the rich previews that we set up in <a href="B15983_06_ePub_RK.xhtml#_idTextAnchor092"><em class="italic">Chapter 6</em></a>, <em class="italic">Improving Your Site's Search Engine Optimization</em>. Let's look at how we could test this. </p>
			<p>Create a <strong class="source-inline">SEO.test.js</strong> file next to your SEO component using the following code:</p>
			<p class="source-code">import React from "react";</p>
			<p class="source-code">import { render } from "@testing-library/react";</p>
			<p class="source-code">import "@testing-library/jest-dom";</p>
			<p class="source-code">import { HelmetProvider } from "react-helmet-async";</p>
			<p class="source-code">import SEO from "../SEO";</p>
			<p class="source-code">HelmetProvider.canUseDOM = false;</p>
			<p class="source-code">test("Correctly Adds Meta Tags to Header", async () =&gt; {</p>
			<p class="source-code">  const mockTitle = "Elevating React with Gatsby";</p>
			<p class="source-code">  const mockDescription = "A starter blog demonstrating</p>
			<p class="source-code">    what Gatsby can do.";</p>
			<p class="source-code">  const context = {};</p>
			<p class="source-code">  render(</p>
			<p class="source-code">   &lt;HelmetProvider context={context}&gt;</p>
			<p class="source-code">    &lt;SEO title={mockTitle} description={mockDescription} /&gt;</p>
			<p class="source-code">   &lt;/HelmetProvider&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">  const head = context.helmet;</p>
			<p class="source-code">  expect(head.meta.toString()).toMatchSnapshot();</p>
			<p class="source-code">});</p>
			<p>First, we inform <strong class="source-inline">react-helmet-async</strong> from <strong class="source-inline">HelmetProvider</strong> that it cannot use the <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) as this is only available in the browser. This allows it to emulate <a id="_idIndexMarker400"/>how it behaves when your site is being built. Within <a id="_idIndexMarker401"/>the test itself, we first create a mock title and <a id="_idIndexMarker402"/>description. Then, we pass this to the <strong class="source-inline">SEO</strong> component. After rendering, we check that the context's helmet object contains meta, and if it does, we make sure it matches the snapshot.</p>
			<p>Now, let's understand how we would test whole site pages.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor110"/>Testing Gatsby page components</h2>
			<p>If you ever want to test pages, you can make use of the custom <strong class="source-inline">render</strong> function we set up in <em class="italic">Step 10</em> of the <em class="italic">Exploring unit testing</em> section. Let's take a look at how we would test our site's index page as an example. </p>
			<p>Unlike our <a id="_idIndexMarker403"/>component tests, it is best to avoid placing <a id="_idIndexMarker404"/>your page tests in the same directory as the page files. This is because Gatsby will automatically try and create pages for every exported React component in the <strong class="source-inline">pages</strong> directory. Instead, create a folder alongside the <strong class="source-inline">pages</strong> directory called <strong class="source-inline">pages-lib</strong> that's specifically for Gatsby page tests.</p>
			<p>Create an <strong class="source-inline">index.test.js</strong> file in the <strong class="source-inline">pages-lib</strong> directory using the following code:</p>
			<p class="source-code">import React from "react";</p>
			<p class="source-code">import { screen } from "@testing-library/react";</p>
			<p class="source-code"><strong class="bold">import {render} from "../../test-utils"</strong></p>
			<p class="source-code">import "@testing-library/jest-dom";</p>
			<p class="source-code">import Index from "../pages/index";</p>
			<p class="source-code">test("Renders Index Page with correct name", async () =&gt; {</p>
			<p class="source-code"><strong class="bold">  const data = {</strong></p>
			<p class="source-code"><strong class="bold">    site: {</strong></p>
			<p class="source-code"><strong class="bold">      siteMetadata: { name: "My Name", role: "My Role" },</strong></p>
			<p class="source-code"><strong class="bold">    },</strong></p>
			<p class="source-code"><strong class="bold">  };</strong></p>
			<p class="source-code">  render(&lt;Index <strong class="bold">data={data}</strong> /&gt;);</p>
			<p class="source-code">  expect(screen.getByText(data.site.siteMetadata.name));</p>
			<p class="source-code">});</p>
			<p>In this <a id="_idIndexMarker405"/>instance, we are making use of the custom render <a id="_idIndexMarker406"/>function that we set up in the <strong class="source-inline">test-utils.js</strong> file. This is because page components typically also contain an <strong class="source-inline">SEO</strong> component, which uses the <strong class="source-inline">Helmet</strong> component, and, as such, needs to be wrapped in <strong class="source-inline">HelmetProvider</strong>. It's also important to pass any data to the <strong class="source-inline">data</strong> prop that the page would normally retrieve via GraphQL, as GraphQL queries on the page will not run. </p>
			<p>Now that we understand how to write tests, let's understand how we can trigger them with Git hooks.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor111"/>Adding Git hooks for tests</h1>
			<p>A <strong class="bold">Git hook</strong> is a method <a id="_idIndexMarker407"/>that fires on common Git commands. We can use <a id="_idIndexMarker408"/>this method to invoke custom scripts when we commit or push our code. It is common practice to use these hooks to run checks against your repository to ensure that the code that is being added does not break application functionality. One valuable check we could add is to run our applications unit tests before we <strong class="source-inline">push</strong> our code, and if they fail, we can stop the push. By implementing this feature, it's unlikely that the code being pushed will break any functionality we test for. </p>
			<p>Let's implement this functionality now by creating a Git hook that is triggered by a <strong class="source-inline">git push</strong>. This will ensure our unit tests pass before allowing the <strong class="source-inline">push</strong> command to run. We will be using the <strong class="source-inline">husky</strong> package to do this as it is easy to set up and maintain:</p>
			<ol>
				<li value="1">Install the necessary dependencies:<p class="source-code">npm install husky --save-dev</p></li>
				<li>Create a <strong class="source-inline">postinstall</strong> script in your <strong class="source-inline">package.json</strong> file with the following command:<p class="source-code">npm set-script postinstall "husky install"</p><p>This command will add a new script to our <strong class="source-inline">package.json</strong> file called <strong class="source-inline">postinstall</strong> that causes <strong class="source-inline">husky</strong> to be installed. </p></li>
				<li>Run <a id="_idIndexMarker409"/>this new script:<p class="source-code">npm run postinstall</p><p>As we are setting this up for the first time, we will need to trigger the <strong class="source-inline">husky</strong> install manually by running the <strong class="source-inline">postinstall</strong> script via the command line. Every subsequent developer will never need to run this manually.</p></li>
				<li>Add a hook:<p class="source-code">npx husky add .husky/pre-push "npm run test"</p><p>This adds a <strong class="source-inline">pre-push</strong> hook that runs our npm <strong class="source-inline">test</strong> script. After running this command, every subsequent push will run the <strong class="source-inline">test</strong> script and only push on success. </p><p class="callout-heading">Important Note</p><p class="callout">Running tests on push is not always the best test. We may have uncommitted code locally that is causing the tests to pass, which are not included in the push. This can cause <a id="_idIndexMarker410"/>the same tests to fail in <strong class="bold">continuous integration/continuous deployment </strong>(<strong class="bold">CI/CD</strong>) environments.</p></li>
			</ol>
			<p>Now that we understand how to trigger unit tests with Git hooks, let's turn our attention to a different kind of test – auditing core web vitals.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor112"/>Auditing core web vitals</h1>
			<p>Web vitals (<a href="https://web.dev/vitals">https://web.dev/vitals</a>) are an initiative by Google to provide unified guidance for <a id="_idIndexMarker411"/>quality signals that are essential to delivering a great user experience on the web. These directly tie into the signals discussed in <a href="B15983_06_ePub_RK.xhtml#_idTextAnchor092"><em class="italic">Chapter 6</em></a>, <em class="italic">Improving Your Site's Search Engine Optimization</em>.</p>
			<p>The core <a id="_idIndexMarker412"/>web vitals are a small group of Google's web vitals that focus on three pillars – how fast the page loads, how soon you can interact with the page, and how stable the page is while it is loading and while the user is interacting with it. These <a id="_idIndexMarker413"/>three pillars are encompassed in the following three metrics:</p>
			<ul>
				<li><strong class="bold">Largest Contentful Paint</strong>: A representation of load time. It is the measure of the time the browser takes to make the majority of a page's content visible from the moment you start navigating to it. This is the moment at which a user perceives the site to have finished loading. </li>
				<li><strong class="bold">First Input Delay</strong>: Measures the response time to interact. First input delay is the time the browser takes from navigation to a point where you can interact with any element on the page, such as a form or button. </li>
				<li><strong class="bold">Cumulative Layout Shift</strong>: A measurement of how stable the page is while it loads. The less your elements shift around the page while the page loads, the higher your score will be. </li>
			</ul>
			<p>Now that we understand these core web vitals, how do we measure them? There are two different <a id="_idIndexMarker414"/>methods we can use to retrieve these metrics. They are as follows:</p>
			<ul>
				<li><strong class="bold">Lab Test Data</strong>: Data generated <a id="_idIndexMarker415"/>on demand by you for testing. This is less accurate as it is based on approximations of user data. But while developing, it is often incredibly useful as we can use it to develop our site iteratively, without ever having to deploy it.</li>
				<li><strong class="bold">Field Data</strong>: Data collected <a id="_idIndexMarker416"/>from users when viewing your site. This is the most accurate source of data as it directly corresponds to how your users are perceiving your site. </li>
			</ul>
			<p>Let's look at how we can retrieve lab test data using the lighthouse tool and field data using the <strong class="source-inline">web-vitals</strong> package.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor113"/>Using Chrome's lighthouse tool</h2>
			<p>The lighthouse tool will analyze your website for performance, accessibility, search engine <a id="_idIndexMarker417"/>optimization, and progressive <a id="_idIndexMarker418"/>web app features. Not only does it give you a score in each of these categories, but it will also tell you how to improve your site to increase these scores. The best part? It's built into Google Chrome – no other downloads or tooling installation is required. </p>
			<p>Now, let's generate a lighthouse report for our site using the tool:</p>
			<ol>
				<li value="1">Build your site using the <strong class="source-inline">gatsby build</strong> command. As we saw in <a href="B15983_01_ePub_RK.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">An Overview of Gatsby.js for the Uninitiated</em>, this creates a production build of your website. It is <em class="italic">vitally</em> important that we audit a production build of the site instead of a development build, since the development tools that Gatsby adds into the build drastically increase your site's bundle. </li>
				<li>Serve your build using the <strong class="source-inline">gatsby serve</strong> command. With the default settings, your site should be live on http://localhost:9000/. </li>
				<li>Open Google Chrome in incognito mode and navigate to http://localhost:9000/. You should see the index page of your site. By loading this page in incognito mode, we ensure that no Chrome extensions you have installed interfere with the test.</li>
				<li>Right-click anywhere on the page and click <strong class="bold">Inspect</strong>. This will bring up <strong class="bold">Developer Tools</strong> on the right-hand side of the window.</li>
				<li>Click the chevron in the center of the top bar and select <strong class="bold">Lighthouse</strong>:<div id="_idContainer033" class="IMG---Figure"><img src="image/Figure_7.1_B15983.jpg" alt="Figure 7.1 – Lighthouse location Within Developer Tools&#13;&#10;"/></div><p class="figure-caption">Figure 7.1 – Lighthouse location Within Developer Tools</p></li>
				<li>This will <a id="_idIndexMarker419"/>present you with the <a id="_idIndexMarker420"/>lighthouse report generator window, which looks like this:<div id="_idContainer034" class="IMG---Figure"><img src="image/Figure_7.2_B15983.jpg" alt="Figure 7.2 – Lighthouse report generator&#13;&#10;"/></div><p class="figure-caption">Figure 7.2 – Lighthouse report generator</p><p>Select the categories you would like to audit, all of which will be switched on by default. All of these categories are important, and it is advised to keep them all on unless you are specifically trying to improve a single metric and want the report to be generated more quickly.</p><p>You must also select a <strong class="bold">Device</strong> type. By default, this setting is set to <strong class="bold">Mobile</strong>. Lighthouse will try to emulate a mobile device attempting to access the page, which includes using a smaller viewport and throttling the network connection. Running multiple reports – one for each device type – is a great idea as it ensures that your site has a great experience on every device. Note that for SEO purposes, Google uses mobile metrics in their site rankings.</p></li>
				<li>Clicking <strong class="bold">Generate report</strong> will start lighthouse. You may see the page flash a few times during this process. This is nothing to worry about. Congratulations – you've just run your first lighthouse report!</li>
			</ol>
			<p>Once lighthouse <a id="_idIndexMarker421"/>has finished running, you <a id="_idIndexMarker422"/>will see that the report generator window has been replaced with a report that contains a section for each category. Let's take a look at the <strong class="bold">Performance</strong> category: </p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/Figure_7.3_B15983.jpg" alt="Figure 7.3 – Lighthouse Performance report&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – Lighthouse Performance report</p>
			<p>You may notice some familiar items within these metrics. Lighthouse has audited each of the three core web vitals as part of its audit. Each metric will be color-coded to give you an indication of where you need to focus your efforts. Green means good, orange means that <a id="_idIndexMarker423"/>it needs improvement, while red <a id="_idIndexMarker424"/>means that the score for this metric is considered poor. In cases where your scores are not optimal, lighthouse will propose changes that you can make to your site to improve the score. Let's look at an example:</p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/Figure_7.4_B15983.jpg" alt="Figure 7.4 – Lighthouse Accessibility report with suggested improvements&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – Lighthouse Accessibility report with suggested improvements</p>
			<p>In the preceding screenshot, we can see that our buttons are not currently accessible as they do not have accessible names. Hovering over the failing element will highlight it within the site so that we can rectify it quickly.</p>
			<p>Now that we understand how to retrieve lab test data, let's investigate how we can retrieve field data using the <strong class="source-inline">web-vitals</strong> JavaScript package.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor114"/>Using the web-vitals JavaScript package</h2>
			<p>The <strong class="source-inline">web-vitals</strong> package is a 1 KB package that's developed by the Google Chrome team. This <a id="_idIndexMarker425"/>package monitors web vitals, including <a id="_idIndexMarker426"/>core web vitals on real users as they visit your site. It aims to measure them in a way that is incredibly similar to other Google reporting tools.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The <strong class="source-inline">web-vitals</strong> package <a id="_idIndexMarker427"/>makes use of browser APIs that are not supported in all browsers. The package only guarantees complete support in Google Chrome. If you are gathering metrics using this tool, please consider that the results will only be retrievable on supported browsers. If you are collating these metrics, it is important to remember that they do not necessarily represent all your site visitors.</p>
			<p>To understand how to use <strong class="source-inline">web-vitals</strong> within our application, let's create a rudimentary example where we simply log the vitals when the user navigates to our site:</p>
			<ol>
				<li value="1">Install the <strong class="source-inline">web-vitals</strong> package:<p class="source-code">npm install web-vitals</p></li>
				<li>Create a function that utilizes the <strong class="source-inline">web-vitals</strong> package:<p class="source-code">import { getCLS, getFID, getLCP } from "web-vitals";</p><p class="source-code">export default async function webVitals() {</p><p class="source-code">  try {</p><p class="source-code">    getFID((metric) =&gt; console.log(metric));</p><p class="source-code">    getLCP((metric) =&gt; console.log(metric));</p><p class="source-code">    getCLS((metric) =&gt; console.log(metric));</p><p class="source-code">  } catch (err) {</p><p class="source-code">    console.log(err);</p><p class="source-code">  }</p><p class="source-code">}</p><p>In this example, we retrieve the metrics and then simply log them to the console. It is important to wrap them in a <strong class="source-inline">try catch</strong> block to avoid crashing the page when the APIs are not supported. This also allows you to handle the error accordingly.</p></li>
				<li>Use the following code within your <strong class="source-inline">gatsby-browser.js</strong> file: <p class="source-code">import "./src/styles/global.css"</p><p class="source-code"><strong class="bold">import webVitals from "./src/utils/web-vitals"</strong></p><p class="source-code"><strong class="bold">webVitals()</strong></p><p>By calling the function within this file, it will run once when the user initially navigates to our site from an external source, but not on every page navigation within the site.</p></li>
			</ol>
			<p>Starting <a id="_idIndexMarker428"/>your development server and <a id="_idIndexMarker429"/>navigating to your site via Google Chrome, you should see the metrics logged in the console. In this example, we are simply displaying them, but we could be sending these to our analytics platform. We will look at this in more detail in <a href="B15983_08_ePub_RK.xhtml#_idTextAnchor116"><em class="italic">Chapter 8</em></a>, <em class="italic">Web Analytics and Performance Monitoring</em>.</p>
			<p>We now have a good understanding of how to measure web vitals both in the field and during development.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor115"/>Summary</h1>
			<p>In this chapter, we learned about unit testing – what it is and why it is important. Then, we integrated unit testing into our Gatsby site. We also looked at a few different recipes for unit tests that we can use to test different types of react components. We then learned about Git hooks and implemented a Git hook that runs unit tests using <strong class="source-inline">husky</strong>. Finally, we investigated core web vitals. We used web vitals to test our page experience both locally using lighthouse, and in the field using the <strong class="source-inline">web-vitals</strong> package. Using what you've learned, you should now feel that you can test a site locally, as well as audit its performance, accessibility, and SEO once it is out on the web.</p>
			<p>In the next chapter, we will discover how we can add analytics to our site, including how we can track <strong class="source-inline">web-vitals</strong> field data.</p>
		</div>
	</body></html>