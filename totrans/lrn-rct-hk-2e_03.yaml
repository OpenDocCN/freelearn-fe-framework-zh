- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the State Hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After learning about the principles of React and giving an introduction to Hooks,
    we are now going to learn about the State Hook in depth. We will start by learning
    how the State Hook works internally by reimplementing it ourselves. Doing so will
    teach us about the limitations of Hooks and why they exist. Then, we will learn
    about possible alternative Hook APIs and their associated problems. Finally, we
    will learn how to solve the common problems that result from the limitations of
    Hooks. By the end of this chapter, you will know how to use the State Hook to
    implement stateful function components in React.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reimplementing the State Hook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Potential alternative Hook APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving common problems with Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A fairly recent version of Node.js should already be installed. The **Node
    Package Manager** (`npm`) also needs to be installed (it should come with Node.js).
    For more information on how to install Node.js, please check out the official
    website: [https://nodejs.org/](https://nodejs.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use **Visual Studio Code** (**VS Code**) for the guides in
    this book, but everything should work similarly in any other editor. For more
    information on how to install VS Code, please refer to the official website: [https://code.visualstudio.com](https://code.visualstudio.com).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we use the following versions:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js v22.14.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm` v10.9.2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VS Code v1.97.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While installing a newer version should not be an issue, please note that certain
    steps might work differently on a newer version. If you are having an issue with
    the code and steps provided in this book, please try using the mentioned versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter02).'
  prefs: []
  type: TYPE_NORMAL
- en: It is highly recommended that you write the code on your own. Do not simply
    run the code examples that are provided with the book. It is important to write
    the code yourself to be able to learn and understand it properly. However, if
    you run into any issues, you can always refer to the code example.
  prefs: []
  type: TYPE_NORMAL
- en: Reimplementing the State Hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to get a better understanding of how Hooks work internally in React,
    we are going to reimplement the `useState` function from scratch. However, we
    are not going to implement it as an actual React Hook but as a simple JavaScript
    function—just to get an idea of what Hooks are actually doing.
  prefs: []
  type: TYPE_NORMAL
- en: This reimplementation is not exactly how React Hooks work internally. The actual
    implementation is similar, and thus, has similar constraints. However, the real
    implementation is more extensive than what we will be implementing here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to start reimplementing the State Hook:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the `Chapter01_3` folder to a new `Chapter02_1` folder by executing the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the new `Chapter02_1` folder in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we need to define a function to (re)render the app, which we can use
    to simulate React rerendering when the Hook state changes. If we used actual React
    Hooks, this would be dealt with internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `src/main.jsx` and *remove* the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Replace* it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the `src/App.jsx` file and *remove* the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Replace* it with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we define our own `useState` function. As we already know, the `useState`
    function takes `initialState` as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define a value, where we will store our state. At first, this value
    will be set to `initialState`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we define the `setState` function, where we will set the new value, and
    force the rerendering of our app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we return the `value` and the `setState` function as an array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the `dev` server (keep it running) and then open the link in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you try to enter text into the input field now, you will notice that when
    the component rerenders, the state gets reset, so it is not possible to enter
    any text in the field. We are going to solve this problem in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason that we use an array and not an object is that we usually want to
    rename the `value` and `setState` variables. Using an array makes it easy to rename
    the variables through destructuring. For example, if we want to have state for
    `username`, we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'While renaming in destructuring is possible with objects too, it would be more
    verbose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, Hooks are simple JavaScript functions that deal with side effects,
    such as setting a stateful value.
  prefs: []
  type: TYPE_NORMAL
- en: Our Hook function uses a **closure** to store the current value. The closure
    is an environment where variables exist and are stored. In our case, the function
    provides the closure, and the `value` variable is stored within that closure.
    The `setState` function is also defined within the same closure, which is why
    we can access the `value` variable within that function. Outside of the `useState`
    function, we cannot directly access the `value` variable unless we return it from
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving issues with our simple Hook implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The issue of not being able to enter any text into the input field is due to
    the reinitialization of the `value` variable every time the component gets rendered
    because we call `useState` each time we render the component.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we are going to solve this problem by using a global
    variable and then turning the simple value into an array, allowing us to define
    multiple Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Using a global variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have learned, the `value` is stored within the closure that is defined
    by the `useState` function. Every time the component rerenders, the closure gets
    reinitialized, which means that the `value` variable will be set to the `initialState`
    again. To solve this, we need to store the `value` in a global variable, outside
    of the function. That way, the `value` variable will be in the closure outside
    of the function, which means that when the function gets called again, the `value`
    will not be reinitialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define the global variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, edit `src/App.jsx` and add the following line above the `useState` function
    definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, *remove* the following first line in the function definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Replace* it with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Try entering some text into the input field again; you will see that our Hook
    function works now!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, our `useState` function uses the global `value` variable instead of defining
    the `value` variable within its closure, so it will not get reinitialized when
    the function gets called again. While our Hook function currently works fine,
    if we wanted to add another Hook, we would run into another problem: all Hooks
    write to the same global `value` variable! Let’s take a closer look at this problem
    by adding a second Hook to our component.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining multiple Hooks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s say we want to create a second field for the last name of the user. We
    can achieve it by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `src/App.jsx` and start by defining a new Hook at the beginning of the
    `App` component, after the current Hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, define a function to handle changing the last name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, show the `lastName` value after the first name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add another `input` field for the last name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Try entering the first name and last name now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will notice that our reimplemented Hook function uses the same value for
    both states, so we are always changing both fields at once. Let’s attempt to fix
    that now.
  prefs: []
  type: TYPE_NORMAL
- en: Adding support for multiple Hooks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add support for multiple Hooks, we need to store an array of Hook values
    instead of a single global variable. We are now going to refactor the `value`
    variable to a `values` array with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `src/App.jsx` and *remove* the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Replace* it with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, edit the first line of the `useState` function, where we now initialize
    the value at the `currentHook` index of the `values` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to update the setter function so that only the corresponding state
    value is updated. Here, we need to first store the `currentHook` value in a separate
    `hookIndex` variable, because the `currentHook` value will change later. This
    ensures that a copy of the `currentHook` variable is created within the closure
    of the `useState` function. Otherwise, the `useState` function would access the
    `currentHook` variable from the outer closure, which gets modified with each call
    to `useState`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit the `return` statement of the `useState` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using `values[currentHook++]`, we pass the current value of `currentHook` as
    an index to the `values` array and then increase the `currentHook` value by one.
    This means that `currentHook` will be increased after returning from the function.
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to first increment a value and then use it, we could use the `arr[++indexToBeIncremented]`
    syntax, which first increments and then passes the result to the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'We still need to reset the `currentHook` counter when we start rendering our
    component. Add the following line right after the component definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Try entering the first name and last name again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, our simple reimplementation of the `useState` Hook works! The following
    screenshot highlights this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Our custom Hook reimplementation works!](img/B31327_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Our custom Hook reimplementation works!
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, using a global array to store our Hook values solved the problems
    that we had when defining multiple Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example code**'
  prefs: []
  type: TYPE_NORMAL
- en: The example code for this section can be found in the `Chapter02/Chapter02_1`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  prefs: []
  type: TYPE_NORMAL
- en: After resolving the problems we had with our custom Hook implementation, let’s
    find out more about the limitations of Hooks in general.
  prefs: []
  type: TYPE_NORMAL
- en: Can we define conditional Hooks?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What if we wanted to add a checkbox that toggles the use of the first name
    field? Let’s find out by implementing such a checkbox:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the `Chapter02_1` folder to a new `Chapter02_2` folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the new `Chapter02_2` folder in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit `src/App.jsx` and add a new Hook to the `App` component, which will store
    the state of the checkbox:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, adjust the Hook for the `name` state to only be used when the first name
    is enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need to disable ESLint for this line; otherwise, it will yell at us, telling
    us that Hooks cannot be used conditionally. For the purposes of this demonstration,
    I want to show what happens when you ignore this warning, though.
  prefs: []
  type: TYPE_NORMAL
- en: We also define a fallback to an empty string (`''`) and a function that does
    nothing (`() => {}`) when the Hook is not defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, define a handler function for changing the checkbox state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, render the checkbox:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the `dev` server and then open the link in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we either use the Hook or, if the first name is disabled, we return the
    initial state and an empty setter function, so that editing the input field will
    not work.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now try out this code, we are going to notice that editing the last name
    still works, but editing the first name does not work, which is what we wanted.
    As we can see in the following screenshot, only editing the last name works now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – State of the app before checking the checkbox](img/B31327_02_02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – State of the app before checking the checkbox
  prefs: []
  type: TYPE_NORMAL
- en: 'When we click the checkbox, something strange happens:'
  prefs: []
  type: TYPE_NORMAL
- en: The checkbox gets checked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first name input field gets enabled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of the last name field is now the value of the first name field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see the result of clicking the checkbox in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – State of the app after clicking the checkbox](img/B31327_02_03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – State of the app after clicking the checkbox
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the last name state is now in the first name field. The value
    gets swapped because the order of Hooks matters. As we know from our implementation,
    we use the `currentHook` index to find out where the state of each Hook is stored.
    However, when we insert an additional Hook in between two existing Hooks, the
    order gets messed up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before checking the checkbox, the `values` array was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[false, '''']`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hook order: `enableFirstName`, `lastName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we entered some text in the `lastName` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[false, ''Hook'']`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hook order: `enableFirstName`, `lastName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we clicked the checkbox, which activated another Hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[true, ''Hook'', '''']`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hook order: `enableFirstName`, `name`, `lastName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see, inserting a new Hook in between two existing Hooks makes the
    `name` Hook *steal* the state from the next Hook (`lastName`) because it now has
    the same index that the `lastName` Hook previously had. Now, the `lastName` Hook
    does not have a value, which causes it to set the initial value (an empty string).
  prefs: []
  type: TYPE_NORMAL
- en: As a result, toggling the checkbox puts the value of the `lastName` field into
    the `name` field and leaves the `lastName` field empty.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example code**'
  prefs: []
  type: TYPE_NORMAL
- en: The example code for this section can be found in the `Chapter02/Chapter02_2`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  prefs: []
  type: TYPE_NORMAL
- en: After learning that Hooks always need to be called in the same order, let’s
    compare our custom Hook implementation to real React Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing our reimplementation to real Hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our simple Hook implementation already gives us an idea of how Hooks work internally.
    However, in reality, Hooks do not use global variables. Instead, they store state
    within the React component. They also deal with the Hook counter internally, so
    we do not need to manually reset the count in function components. Additionally,
    real Hooks automatically trigger rerenders of components when the state changes.
    To be able to do this, however, Hooks need to be called from a React function
    component. React Hooks cannot be called outside of React or inside React class
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'By reimplementing the `useState` Hook, we have learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Hooks are functions that access React features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hooks deal with side effects that persist across rerenders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of Hook definitions matters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final point is especially important because it means that we cannot conditionally
    define Hooks. We should always have all Hook definitions at the beginning of a
    function component and never nest them within `if` statements, ternaries, or similar
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have also learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: React Hooks need to be called inside React function components or other Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Hooks cannot be defined conditionally or in loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are some additional limitations of React Hooks, resulting from the limitations
    we have learned about:'
  prefs: []
  type: TYPE_NORMAL
- en: React Hooks cannot be defined after a conditional `return` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Hooks cannot be defined in event handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Hooks cannot be defined inside `try`/`catch`/`finally` blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Hooks cannot be defined in the functions passed to `useMemo`, `useReducer`,
    and `useEffect` (we will learn more about these three Hooks throughout the book,
    but just keep this limitation in mind for now)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are now going to look at alternative Hook APIs that would allow conditional
    Hooks, but they come with their own downsides.
  prefs: []
  type: TYPE_NORMAL
- en: Potential alternative Hook APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it would be nice to define Hooks conditionally or in loops, but why
    did the React team decide to implement Hooks like this? What are the alternatives?
    Let’s go through some of them to get a feeling for the trade-offs involved in
    making this decision.
  prefs: []
  type: TYPE_NORMAL
- en: Named Hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We could give each Hook a name, and then store the Hooks in an object instead
    of an array. However, this would not make such a nice API, and we would also always
    have to think of unique names for Hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, there are unresolved questions: What would happen when a conditional
    is set to `false` or an item is removed from a loop? Would we clear the Hook state?
    If we do not clear the Hook state, we might be causing memory leaks. If we do
    clear it, we might be unintentionally discarding user input.'
  prefs: []
  type: TYPE_NORMAL
- en: Even if we solved these problems, there would still be the problem of name collisions.
    If we, for example, create a Hook and call it `nameHook`, then we cannot call
    any other Hook `nameHook` in our component anymore, or we will cause a name collision.
    This is even the case for Hook names from libraries, so we need to make sure to
    avoid name collisions with Hooks defined by libraries as well!
  prefs: []
  type: TYPE_NORMAL
- en: Hook factories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alternatively, we could create a Hook factory function, which uses `Symbol`
    internally to give each Hook a unique key name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we could use the factory function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this means that we will need to instantiate each Hook twice: once
    outside of the component, and once inside the function component. This creates
    more room for error. For example, if we create two Hooks and copy and paste the
    boilerplate code, then we might make a mistake in the name of our Hook resulting
    from the factory function, or we might make a mistake when using the Hook inside
    the component.'
  prefs: []
  type: TYPE_NORMAL
- en: This approach also makes it much harder to create custom Hooks, forcing us to
    write wrapper functions. Additionally, it is harder to debug these wrapped functions
    than it is to debug a simple function.
  prefs: []
  type: TYPE_NORMAL
- en: Other alternatives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There were many proposed alternative APIs for React Hooks, but each of them
    suffered from similar problems: either making the API harder to use, less flexible,
    harder to debug, or introducing the possibility of name collisions.'
  prefs: []
  type: TYPE_NORMAL
- en: In the end, the React team decided that the simplest API was to keep track of
    Hooks by counting the order in which they were called. This approach comes with
    its own downsides, such as not being able to call Hooks conditionally or in loops.
    However, this approach makes it very easy to create custom Hooks, and it is simple
    to use and debug. We also do not need to worry about naming Hooks, name collisions,
    or writing wrapper functions. The final approach for Hooks lets us use Hooks just
    like any other function!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about the various proposals and the final Hook implementation,
    let’s learn how to solve common problems resulting from the limitations of the
    chosen official API.
  prefs: []
  type: TYPE_NORMAL
- en: Solving common problems with Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we found out, implementing Hooks with the official API also has its own trade-offs
    and limitations. We are now going to learn how to overcome these common problems,
    which stem from the limitations of React Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will take a look at solutions that can be used to overcome these two problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Solving conditional Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving Hooks in loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving conditional Hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, how do we implement conditional Hooks? Instead of making the Hook conditional,
    we can just always define the Hook and use it whenever we need it. If this is
    not an option, we need to split up our components, which is usually better anyway!
  prefs: []
  type: TYPE_NORMAL
- en: Always defining the Hook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For simple cases, such as the first and last name example that we had previously,
    we can just always keep the Hook defined, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the `Chapter02_2` folder to a new `Chapter02_3` folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the new `Chapter02_3` folder in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit `src/App.jsx` and *remove* the following two lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Replace* them with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to move the conditional down to where the first name gets rendered
    instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you want to re-add the feature that the first name field cannot even be
    edited when it is not enabled, just add the following attribute to the `<input>`
    field: `disabled={!enableFirstName}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `dev` server and then open the link in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, our example works fine! Always defining the Hook is usually a good solution
    for simple cases. In more complex cases, it might not be feasible to always define
    the Hook. In that case, we would need to create a new component, define the Hook
    there, and then conditionally render the component.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example code**'
  prefs: []
  type: TYPE_NORMAL
- en: The example code for this section can be found in the `Chapter02/Chapter02_3`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting up components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way to solve conditional Hooks is to split up one component into multiple
    components and then conditionally render the components. For example, let’s say
    we want to fetch user information from a database after the user logs in.
  prefs: []
  type: TYPE_NORMAL
- en: 'We cannot do the following, as using an `if` conditional could change the order
    of the Hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we have to create a separate component for when the user is logged
    in, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Using two separate components for the non-logged-in and logged-in state makes
    sense anyway because we want to stick to the principle of having one functionality
    per component. Usually, not being able to have conditional Hooks is not much of
    a limitation if we stick to best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Solving Hooks in loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you may have a case where you would want to define Hooks in loops
    – for example, if you have a way to dynamically add new input fields and you need
    a State Hook for each of them.
  prefs: []
  type: TYPE_NORMAL
- en: To solve problems where we would want to have Hooks in loops, we can either
    use a single State Hook containing an array or we can again split up our components.
    For example, let’s say we want to display all the users that are online.
  prefs: []
  type: TYPE_NORMAL
- en: Using an array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We could simply use an array that contains all users, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: However, this might not always make sense. For example, we might not want to
    update the user state through the `OnlineUsers` component because we would have
    to select the correct user state from the array and then modify the array. This
    might work but it is quite tedious.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting up components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A better solution would be to use the Hook in the `UserInfo` component instead.
    That way, we can keep the state for each user up to date, without having to deal
    with array logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, using one component for each functionality keeps our code simple
    and concise, and also avoids the limitations of React Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started out by reimplementing the `useState` function, making
    use of global state and closures. We then learned that in order to support multiple
    Hooks, we need to keep track of them using an array. By using a state array, however,
    we were forced to keep the order of Hooks consistent across function calls. This
    limitation made conditional Hooks and Hooks in loops impossible. We then learned
    about potential alternatives to the Hook API, their trade-offs, and why the final
    API was chosen. Finally, we learned how to solve the common problems that stem
    from the limitations of Hooks. We now have a solid understanding of the inner
    workings and limitations of Hooks. Along the way, we also learned about the State
    Hook in depth.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to create a blog application using the State
    Hook and learn how to combine multiple Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To recap what we have learned in this chapter, try to answer the following
    questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Which problems did we run into while developing our own reimplementation of
    the `useState` Hook? How did we solve these problems?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are conditional Hooks not possible in the React implementation of Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do we need to watch out for when using Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the common problems of alternative API ideas for Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we implement conditional Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we implement Hooks in loops?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are interested in more information about the concepts that we have learned
    in this chapter, take a look at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'More information on the flaws of alternative Hook APIs: [https://overreacted.io/why-do-hooks-rely-on-call-order/](https://overreacted.io/why-do-hooks-rely-on-call-order/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Official comment on alternative Hook APIs: [https://github.com/reactjs/rfcs/pull/68#issuecomment-439314884](https://github.com/reactjs/rfcs/pull/68#issuecomment-439314884)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Official documentation on the limitations and rules of Hooks: [https://react.dev/reference/rules/rules-of-hooks](https://react.dev/reference/rules/rules-of-hooks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information on how `Symbol` works: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/wnXT0](Chapter_02.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_%283%29.png)'
  prefs: []
  type: TYPE_IMG
