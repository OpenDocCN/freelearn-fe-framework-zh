<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Styling and Animating Components"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Styling and Animating Components</h1></div></div></div><p>In the last chapter, you learned how persist pages even after reloading the page or restarting the browser. We're at the point now where this could start to be a useful system for us. Unfortunately, it still looks rough and unstyled.</p><p>That's because, up until now, we've almost completely ignored styles in our components. In this chapter, we will change all that!</p><p>You will learn how to add custom styles and class names to component elements. We'll add animations to new and old components. We'll even learn how to combine the two to create highly reusable styles and animation.</p><div class="section" title="Adding new pages"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Adding new pages</h1></div></div></div><p>So far, we are able to change and remove pages from our content management system. We ended the last chapter by<a id="id59" class="indexterm"/> seeding our local storage with a serialized array, so we could see it in action. Let's take a step back and make a way to create new pages through the interface.</p><p>First, we'll add an <code class="literal">insert</code> method and update the <code class="literal">constructor</code> method of <code class="literal">Backend</code>:</p><div class="informalexample"><pre class="programlisting">constructor() {
    super();

    var pages = LocalStore.get("pages", []);

    this.id = 1;

    this.pages = pages.map((page) =&gt; {
        page.id = this.id++;
        return page;
    });
}

insert() {
    this.pages.push({
        "id": this.id,
        "title": "New page " + this.id,
        "body": ""
    });

    this.id++;

    LocalStore.set("pages", this.pages);

    this.emit("update", this.pages);
}</pre></div><p>The page <code class="literal">id</code> values aren't really important to us outside the context of our React components. So, it's fine to regenerate them as the pages are loaded from local storage. We keep track of the<a id="id60" class="indexterm"/> internal <code class="literal">id</code> value, so new pages can be assigned a new <code class="literal">id</code> value when they are created.</p><p>The <code class="literal">insert</code> method pushes a new page object onto the list of pages. We then update the <code class="literal">pages</code> data in local storage so it's available the next time we need the pages. And, as with the <code class="literal">update</code> and <code class="literal">delete</code> methods, we emit an <code class="literal">update</code> event, so all concerned components will update their state.</p><p>We can use this <code class="literal">insert</code> method in <code class="literal">PageAdmin</code>:</p><div class="informalexample"><pre class="programlisting">onInsert() {
    <span class="strong"><strong>this.props.backend.insert();</strong></span>
}</pre></div><p>In the <code class="literal">render</code> method, add the following code:</p><div class="informalexample"><pre class="programlisting">render() {
    return &lt;div&gt;
        <span class="strong"><strong>&lt;div&gt;</strong></span>
<span class="strong"><strong>            &lt;button onClick={this.onInsert}&gt;</strong></span>
<span class="strong"><strong>                create new page</strong></span>
<span class="strong"><strong>            &lt;/button&gt;</strong></span>
<span class="strong"><strong>        &lt;/div&gt;</strong></span>
        &lt;ol&gt;
            ...
        &lt;/ol&gt;
    &lt;/div&gt;;
}</pre></div><p>Along with the rest of the code we wrote, the interface looks like this:</p><p> </p><div class="mediaobject"><img src="graphics/5268_04_01.jpg" alt="Adding new pages"/></div></div></div>
<div class="section" title="Adding styles to components"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Adding styles to components</h1></div></div></div><p>There are a number of ways <a id="id61" class="indexterm"/>we could improve the appearance of our <a id="id62" class="indexterm"/>components. Let's take the <code class="literal">PageView</code> component, for example. What would make it better? Perhaps if we increased the font size and used a sans serif font, the titles would be clearer to read. Perhaps we could increase the margin around each page.</p><p>There are a few different ways to style our components. The first is by adding styles inline to the <code class="literal">render</code> method in <code class="literal">PageView</code>:</p><div class="informalexample"><pre class="programlisting">render() {
    <span class="strong"><strong>var rowStyle = this.props.rowStyle || {</strong></span>
<span class="strong"><strong>        "fontSize": "18px",</strong></span>
<span class="strong"><strong>        "fontFamily": "Helvetica"</strong></span>
<span class="strong"><strong>    };</strong></span>

<span class="strong"><strong>    var labelStyle = this.props.labelStyle || {</strong></span>
<span class="strong"><strong>        "whiteSpace": "nowrap"</strong></span>
<span class="strong"><strong>    };</strong></span>

<span class="strong"><strong>    var buttonStyle = this.props.buttonStyle || {</strong></span>
<span class="strong"><strong>        "margin": "0 0 0 10px",</strong></span>
<span class="strong"><strong>        "verticalAlign": "middle",</strong></span>
<span class="strong"><strong>    };</strong></span>

    return &lt;div <span class="strong"><strong>style={rowStyle}</strong></span>&gt;
        &lt;label <span class="strong"><strong>style={labelStyle}</strong></span>&gt;
            {this.props.title}
        &lt;/label&gt;
        &lt;button
            <span class="strong"><strong>style={buttonStyle}</strong></span>
            onClick={this.props.onEdit}&gt;
            edit
        &lt;/button&gt;
        &lt;button
            <span class="strong"><strong>style={buttonStyle}</strong></span>
            onClick={this.props.onDelete}&gt;
            delete
        &lt;/button&gt;
    &lt;/div&gt;;
}</pre></div><p>We can define a set of styles for each element we want our component to render. For the outer <code class="literal">div</code> element, we<a id="id63" class="indexterm"/> define a font size and family. For the <code class="literal">label</code> title, we tell the browser not to wrap text. For each button, we add margins. Each style <a id="id64" class="indexterm"/>object may be overwritten through properties, owing to the <code class="literal">var value = value1 || value2</code> notation. That's shorthand for saying if <code class="literal">value1</code> is undefined, use <code class="literal">value2</code>.</p><p>We should also apply those styles to the list items, so the numbers appear in the same manner as the titles:</p><div class="informalexample"><pre class="programlisting">render() {
    var itemStyle = this.props.itemStyle || {
        <span class="strong"><strong>"</strong></span>minHeight<span class="strong"><strong>"</strong></span>: <span class="strong"><strong>"</strong></span>40px<span class="strong"><strong>"</strong></span>,
        <span class="strong"><strong>"</strong></span>lineHeight<span class="strong"><strong>"</strong></span>: <span class="strong"><strong>"</strong></span>40px<span class="strong"><strong>",</strong></span>
<span class="strong"><strong>        "fontSize": "18px",</strong></span>
<span class="strong"><strong>        "fontFamily": "Helvetica"</strong></span>

    };

    return &lt;div&gt;
        &lt;div&gt;
            &lt;button
                onClick={this.onInsert}&gt;
                create new page
            &lt;/button&gt;
        &lt;/div&gt;
        &lt;ol&gt;
            {this.state.pages.map((page, i) =&gt; {
                return &lt;li key={i} <span class="strong"><strong>style={itemStyle}</strong></span>&gt;
                    &lt;Page
                        {...page}
                        onUpdate={this.onUpdate}
                        onDelete={this.onDelete}
                        /&gt;);
                &lt;/li&gt;;
            })}
        &lt;/ol&gt;
    &lt;/div&gt;;
}</pre></div><p>Note how there are two<a id="id65" class="indexterm"/> sets of braces for the <code class="literal">style</code> object? That's how we define objects as properties. In this case, it's an object of styles we want applied to <a id="id66" class="indexterm"/>each list item.</p></div>
<div class="section" title="Changing and reverting"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Changing and reverting</h1></div></div></div><p>Now <a id="id67" class="indexterm"/>we can style our<a id="id68" class="indexterm"/> edit form. Let's replace the modification indicator (asterisk) with a <a id="id69" class="indexterm"/>button that will simulate the save action:</p><div class="informalexample"><pre class="programlisting">constructor(props) {
    super(props);

    this.state = {
        <span class="strong"><strong>"</strong></span>changed<span class="strong"><strong>"</strong></span>: false
    };

    this.bind(
        <span class="strong"><strong>"</strong></span>onCancel<span class="strong"><strong>"</strong></span>,
        <span class="strong"><strong>"onSave",</strong></span>
        <span class="strong"><strong>"</strong></span>onUpdate<span class="strong"><strong>"</strong></span>,
    );
}

render() {
    <span class="strong"><strong>var cancelButtonStyle = null;</strong></span>
<span class="strong"><strong>    var saveButton = null;</strong></span>

<span class="strong"><strong>    if (this.state.changed) {</strong></span>
<span class="strong"><strong>        cancelButtonStyle = this.props.cancelButtonStyle || {</strong></span>
<span class="strong"><strong>           "margin": "0 0 0 10px"</strong></span>
<span class="strong"><strong>        };</strong></span>

<span class="strong"><strong>        saveButton = &lt;button</strong></span>
<span class="strong"><strong>            onClick={this.onCancel}&gt;</strong></span>
<span class="strong"><strong>            save</strong></span>
<span class="strong"><strong>        &lt;/button&gt;</strong></span>
<span class="strong"><strong>    }</strong></span>

    return &lt;form&gt;
        &lt;div&gt;
            &lt;input
                type="text"
                onChange={this.onUpdate}
                name="title"
                value={this.props.title}
                /&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;input
                type="text"
                onChange={this.onUpdate}
                name="body"
                value={this.props.body}
                /&gt;
        &lt;/div&gt;
        <span class="strong"><strong>{saveButton}</strong></span>
<span class="strong"><strong>        &lt;button</strong></span>
<span class="strong"><strong>            onClick={this.onCancel}</strong></span>
<span class="strong"><strong>            style={cancelButtonStyle}&gt;</strong></span>
<span class="strong"><strong>            cancel</strong></span>
<span class="strong"><strong>        &lt;/button&gt;</strong></span>
    &lt;/form&gt;;
}

onSave(event) {
    event.perventDefault();
    this.props.onSave();
}</pre></div><p>This gives the illusion that clicking on the <span class="strong"><strong>Save</strong></span> button will save something, when the save happens regardless. This poses an interesting question—should we make the <span class="strong"><strong>Cancel</strong></span> button cancel the edit? Because right now it's just a back button masquerading as a cancel button. We should<a id="id70" class="indexterm"/> also define an <code class="literal">onSave</code> function to pass to this component.</p><p>To do that, we'd have to track its initial state. But where would we get this initial state? The <code class="literal">PageEditor</code> component receives<a id="id71" class="indexterm"/> the page details through properties, so the current state is the same in <code class="literal">PageEditor</code> as it is in <code class="literal">Backend</code>.</p><p>Perhaps we should store the state when <code class="literal">PageView</code> is hidden and <code class="literal">PageEditor</code> is shown:</p><div class="informalexample"><pre class="programlisting">onEdit() {
    this.setState({
        "isEditing": true,
        <span class="strong"><strong>"title": this.props.title</strong></span>
    });
}</pre></div><p>When the page enters edit mode, we store the unedited title. We should change the <code class="literal">onCancel</code> method to actually cancel a change:</p><div class="informalexample"><pre class="programlisting">onCancel() {
    <span class="strong"><strong>this.props.onUpdate(</strong></span>
<span class="strong"><strong>        this.props.id,</strong></span>
<span class="strong"><strong>        "title",</strong></span>
<span class="strong"><strong>        this.state.title</strong></span>
<span class="strong"><strong>    );</strong></span>

    this.setState({
        "isEditing": false
    });
}

onSave() {
    this.setState({
        "isEditing": false
    });
}</pre></div><p>When the <code class="literal">onCancel</code> property is called, we set the page title to the unedited title we stored earlier. We need to bind this new <code class="literal">onSave</code> method in the constructor:</p><div class="informalexample"><pre class="programlisting">constructor(props) {
    super(props);

    this.state = {
        "isEditing": false
    };

    this.bind(
        "onEdit",
        "onDelete",
        <span class="strong"><strong>"onCancel",</strong></span>
        <span class="strong"><strong>"onSave"</strong></span>
    );
}</pre></div><p>This assures that <code class="literal">this</code><a id="id72" class="indexterm"/> refers to the page component when the <code class="literal">onSave</code> property is later <a id="id73" class="indexterm"/>called. We'll need to pass this new method to the <code class="literal">PageEditor</code> component in the form of a property:</p><div class="informalexample"><pre class="programlisting">render() {
    if (this.state.isEditing) {
        return &lt;PageEditor
            {...this.props}
            <span class="strong"><strong>onCancel={this.onCancel}</strong></span>
            <span class="strong"><strong>onSave={this.onSave}</strong></span>
            /&gt;;
    }

    return &lt;PageView
        {...this.props}
        onEdit={this.onEdit}
        onDelete={this.onDelete}
        /&gt;;
}</pre></div><p>Now, instead of both the <code class="literal">PageEditor</code> buttons calling <code class="literal">this.props.onCancel</code>, they can call their applicable methods:</p><div class="informalexample"><pre class="programlisting">if (this.state.changed) {
    cancelButtonStyle = this.props.cancelButtonStyle || {
       "margin": "0 0 0 10px"
    };

    saveButton = &lt;button
        <span class="strong"><strong>onClick={this. onSave}</strong></span>&gt;
        save
    &lt;/button&gt;
}</pre></div></div>
<div class="section" title="Animating new components"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Animating new components</h1></div></div></div><p>At the moment, new<a id="id74" class="indexterm"/> pages are just appearing. There's no subtle animation to ease them in. Let's change that!</p><p>We will use a new React component for this, and we can find it in the add-ons build of React. Go back to the React scripts you downloaded in the first chapter and replace all references to <code class="literal">react.js</code> with <code class="literal">react-with-addons.js</code>.</p><p>This gives us access to a new component called <code class="literal">CSSTransitionGroup</code>:</p><div class="informalexample"><pre class="programlisting">render() {
    var itemStyle = this.props.itemStyle || {
        <span class="strong"><strong>"</strong></span>minHeight<span class="strong"><strong>"</strong></span>: <span class="strong"><strong>"</strong></span>40px<span class="strong"><strong>"</strong></span>,
        <span class="strong"><strong>"</strong></span>lineHeight<span class="strong"><strong>"</strong></span>: <span class="strong"><strong>"</strong></span>40px<span class="strong"><strong>",</strong></span>
<span class="strong"><strong>        "fontSize": "18px",</strong></span>
<span class="strong"><strong>        "fontFamily": "Helvetica"</strong></span>
    };

    return &lt;div&gt;
        &lt;div&gt;
            &lt;button
                onClick={this.onInsert}&gt;
                create new page
            &lt;/button&gt;
        &lt;/div&gt;
        &lt;ol&gt;
            <span class="strong"><strong>&lt;React.addons.CSSTransitionGroup</strong></span>
                <span class="strong"><strong>transitionName="page"</strong></span>
                <span class="strong"><strong>transitionEnterTimeout={150}</strong></span>
                <span class="strong"><strong>transitionLeaveTimeout={150}&gt;</strong></span>
                {this.state.pages.map((page, i) =&gt; {
                    return &lt;li key={i} style={itemStyle}&gt;
                        &lt;Page
                            {...page}
                            onUpdate={this.onUpdate}
                            onDelete={this.onDelete}
                            /&gt;
                    &lt;/li&gt;;
                })}
            <span class="strong"><strong>&lt;/React.addons.CSSTransitionGroup&gt;</strong></span>
        &lt;/ol&gt;
    &lt;/div&gt;;
}</pre></div><p>This new container component watches for changes in its children. When new child components are added, they are given a couple of CSS class names, which can apply CSS animation. We<a id="id75" class="indexterm"/> need to add this animation to the corresponding CSS styles:</p><div class="informalexample"><pre class="programlisting">.page-enter {
    opacity: 0.01;
    margin-left: -50%;
}

.page-enter.page-enter-active {
    opacity: 1;
    margin-left: 0;
    transition: all 150ms linear;
}

.page-leave {
    opacity: 1;
    margin-left: 0;
}

.page-leave.page-leave-active {
    opacity: 0.01;
    margin-left: 50%;
    transition: all 150ms linear;
}</pre></div><p>Since we specified <code class="literal">transitionName="page"</code>, React adds <code class="literal">page-enter</code> and <code class="literal">page-leave</code> to the <code class="literal">Page</code> components, as they enter and leave <code class="literal">PageAdmin</code>. Note how <code class="literal">150ms</code> in our styles matches <code class="literal">transitionEnterTimeout={150}</code>? They need to be the same. React adds classes such as <code class="literal">page-enter-active</code> for those <code class="literal">150ms</code>, and then removes them. This ensures that transitions only happen once.</p></div>
<div class="section" title="Working with CSS transitions"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Working with CSS transitions</h1></div></div></div><p>It's a great time to<a id="id76" class="indexterm"/> talk about CSS transitions. We have used them to fade and slide new <code class="literal">Page</code> components in from the left. If you're unfamiliar with how they generally work, the code might be confusing and difficult to change.</p><p>There are a few things you should know. The first is that you can transition individual CSS properties or all of them at once:</p><div class="informalexample"><pre class="programlisting">.background-transition {
    background-color: red;
    font-size: 16px;
    <span class="strong"><strong>transition-property: background-color;</strong></span>
}

.background-transition:hover {
    background: blue;
    font-size: 18px;
}</pre></div><p>In this example, we only want to transition the background color. The font size will immediately jump from <code class="literal">16px</code> to <code class="literal">18px</code>. Alternatively, we can transition all CSS properties:</p><div class="informalexample"><pre class="programlisting">.all-transition {
    <span class="strong"><strong>transition-property: all;</strong></span>
}</pre></div><p>We've already seen transition duration, albeit briefly. We can use <code class="literal">ms</code> or <code class="literal">s</code> as units for these:</p><div class="informalexample"><pre class="programlisting">.background-transition {
    <span class="strong"><strong>transition-duration: 1s;</strong></span>
}</pre></div><p>Then there are timing functions. These control how the animation gets from 0% to 100%. They're sometimes called curves because of how they're often demonstrated:</p><div class="mediaobject"><img src="graphics/5268_04_02.jpg" alt="Working with CSS transitions"/></div><p>Linear is the most<a id="id77" class="indexterm"/> basic of these timing functions, moving evenly from 0% to 100%. It's also the default <code class="literal">timing</code> function.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>You can <a id="id78" class="indexterm"/>see these demonstrated at <a class="ulink" href="http://easings.net">http://easings.net</a>.</p></div></div><p>You can also define your own curve, in the <code class="literal">cubic-bezier(x1, y1, x2, y2)</code> form. That's a bit advanced for now, but it's good to know in any case.</p><p>Transitions can also be delayed, so they only happen after the desired amount of time:</p><div class="informalexample"><pre class="programlisting">.background-transition {
    <span class="strong"><strong>transition-delay: 1s;</strong></span>
}</pre></div><p>Altogether, these styles look like this:</p><div class="informalexample"><pre class="programlisting">.background-transition {
    transition-property: background;
    transition-duration: 1s;
    transition-timing-function: linear;
    transition-delay: 0.5s;
}</pre></div><p>As in the previous section, you can bundle all of these properties together into a smaller set:</p><div class="informalexample"><pre class="programlisting">.background-transition {
<span class="strong"><strong>    transition: background 1s linear 0.5s;</strong></span>
}</pre></div><p>Not all properties can be transitioned. Properties need to have some form of granularity. Some common <a id="id79" class="indexterm"/>properties are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">background</code> (applies to color and position)</li><li class="listitem" style="list-style-type: disc"><code class="literal">border</code> (applies to color, width, and spacing)</li><li class="listitem" style="list-style-type: disc"><code class="literal">bottom</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">clip</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">color</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">crop</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">font</code> (applies to size and weight)</li><li class="listitem" style="list-style-type: disc"><code class="literal">height</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">left</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">letter-spacing</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">line-height</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">margin</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">max-height</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">max-width</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">min-height</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">min-width</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">opacity</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">outline</code> (applies to color, offset, and width)</li><li class="listitem" style="list-style-type: disc"><code class="literal">padding</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">right</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">text-indent</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">text-shadow</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">top</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">vertical-align</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">visibility</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">width</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">word-spacing</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">z-index</code></li></ul></div></div>
<div class="section" title="Organizing styles with Sass"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Organizing styles with Sass</h1></div></div></div><p>Style sheets are a great <a id="id80" class="indexterm"/>alternative to inline component styles. CSS is wonderfully expressive as a language for finding and applying visual characteristics to elements.</p><p>Unfortunately, it <a id="id81" class="indexterm"/>also has drawbacks. The biggest drawback to CSS is that all styles are in global scope. Some styles are inherited, and styles applied to elements often collide (and cancel each other out).</p><p>In small doses, the collisions are avoidable or manageable. In large doses, these collisions can cripple productivity. As a stop-gap, CSS supports the <code class="literal">!important</code> keyword. This often leads to ugly hacks, as everyone wants their styles to be the most important.</p><p>In addition to this, common values need to be repeated. Until recently, CSS didn't even support calculated values. If we wanted an element to have an absolute width (for example) in relation to other elements, we had to use JavaScript.</p><p>These are some of the problems Sass aims to solve. It's a CSS superset language (CSS + other features), so it's easy to learn, that is, once you know CSS.</p><p>Sass style sheets need to be compiled to CSS style sheets before they can be used in the browser. Installing a Sass compiler is easy; execute the following command to install it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save node-sass</strong></span>
</pre></div><p>After that's done, we're able to compile Sass style sheets (files ending in <code class="literal">.scss</code>) with the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ node_modules/.bin/node-sass index.scss &gt; index.css</strong></span>
</pre></div><p>Consider the following code:</p><div class="informalexample"><pre class="programlisting">$duration: 150ms;
$timing-function: linear;

.page-enter {
    opacity: 0.01;
    margin-left: -50%;

    &amp;.page-enter-active {
        opacity: 1;
        margin-left: 0;
        transition: all $duration $timing-function;
    }
}

.page-leave {
    opacity: 1;
    margin-left: 0;

    &amp;.page-leave-active {
        opacity: 0.01;
        margin-left: 50%;
        transition: all $duration $timing-function;
    }
}</pre></div><p>The<a id="id82" class="indexterm"/> preceding <a id="id83" class="indexterm"/>code will be turned into CSS, as follows:</p><div class="informalexample"><pre class="programlisting">.page-enter {
    opacity: 0.01;
    margin-left: -50%;
}

.page-enter.page-enter-active {
    opacity: 1;
    margin-left: 0;
    transition: all 150ms linear;
}

.page-leave {
    opacity: 1;
    margin-left: 0;
}

.page-leave.page-leave-active {
    opacity: 0.01;
    margin-left: 50%;
    transition: all 150ms linear;
}</pre></div><p>If you prefer to<a id="id84" class="indexterm"/> compile React components in the browser and want to do the<a id="id85" class="indexterm"/> same with Sass, then you can install the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save sass.js</strong></span>
</pre></div><p>Then, you need to add the following elements to the head of your page:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&lt;script src="/node_modules/sass.js/dist/sass.sync.js"&gt;&lt;/script&gt;</strong></span>
&lt;style <span class="strong"><strong>type="text/sass"</strong></span>&gt;
    $duration: 150ms;
    $timing-function: linear;

    .page-enter {
        opacity: 0.01;
        margin-left: -50%;

        &amp;.page-enter-active {
            opacity: 1;
            margin-left: 0;
            transition: all $duration $timing-function;
        }
    }

    .page-leave {
        opacity: 1;
        margin-left: 0;

        &amp;.page-leave-active {
            opacity: 0.01;
            margin-left: 50%;
            transition: all $duration $timing-function;
        }
    }
&lt;/style&gt;
&lt;script&gt;
    <span class="strong"><strong>var stylesheets = Array.prototype.slice.call(</strong></span>
<span class="strong"><strong>        document.querySelectorAll("[type='text/sass']")</strong></span>
<span class="strong"><strong>    );</strong></span>

<span class="strong"><strong>    stylesheets.forEach(function(stylesheet) {</strong></span>
<span class="strong"><strong>        Sass.compile(stylesheet.innerHTML, function(result) {</strong></span>
<span class="strong"><strong>            stylesheet.type = "text/css";</strong></span>
<span class="strong"><strong>            stylesheet.innerHTML = result.text;</strong></span>
<span class="strong"><strong>        });</strong></span>
<span class="strong"><strong>    });</strong></span>
&lt;/script&gt;</pre></div><p>This is a bit of<a id="id86" class="indexterm"/> JavaScript to look for the <code class="literal">style</code> elements with <code class="literal">type="text/sass"</code>. The contents of each of these style elements is passed through <code class="literal">sass.js</code> and saved back into the style elements. Their type is changed back to <code class="literal">text/css</code>, so the browser<a id="id87" class="indexterm"/> will recognize the styles as CSS.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>You should only use this method in development. It creates a lot of work for the browser, which can be avoided by pre-compiling Sass for a production environment (using tools such as Grunt, Gulp, and webpack).</p></div></div></div>
<div class="section" title="Alternatives"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Alternatives</h1></div></div></div><p>There are a few other<a id="id88" class="indexterm"/> ways in which we can style and <a id="id89" class="indexterm"/>animate React components, and they all deal with the issue in subtly different ways.</p><div class="section" title="CSS modules"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec06"/>CSS modules</h2></div></div></div><p><span class="strong"><strong>CSS modules</strong></span> allow you to<a id="id90" class="indexterm"/> define styles that only <a id="id91" class="indexterm"/>apply in a local context to individual elements. They look<a id="id92" class="indexterm"/> like regular CSS styles, but when they're applied to components, they are altered so that the class names given to components are unique. You can read more about CSS modules at <a class="ulink" href="http://glenmaddern.com/articles/css-modules">http://glenmaddern.com/articles/css-modules</a>.</p></div><div class="section" title="React style"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec07"/>React style</h2></div></div></div><p><span class="strong"><strong>React style</strong></span> is a way of creating inline <a id="id93" class="indexterm"/>styles as slightly enhanced objects. It lacks support for a few common CSS <a id="id94" class="indexterm"/>selectors, but does a<a id="id95" class="indexterm"/> good job otherwise. You can read more about it at <a class="ulink" href="https://github.com/js-next/react-style">https://github.com/js-next/react-style</a>.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Summary</h1></div></div></div><p>In this chapter, you learned how to style React components great and small. We used inline styles, CSS style sheets, and even Sass style sheets. You also learned how to animate child components in and out of view using CSS transitions.</p><p>Finally, we looked briefly at a couple of alternative technologies, which do the same things we did in this chapter but in slightly different ways. You may prefer one of these methods over all the others, but what is important is to recognize that there are many methods we can use to style and animate components.</p><p>In the next chapter, we will put all these skills to use as we dive into material design. There's lots of styling and animation to come!</p></div></body></html>