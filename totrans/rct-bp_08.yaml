- en: Chapter 8. Deploying Your App to the Cloud
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。将你的应用部署到云上
- en: In this chapter, we're going to create a production pipeline for our apps. This
    involves splitting your configuration files for development and production as
    well as making a production-ready instance of your Node.js server. First we'll
    look at how to set up a production-ready deployment of the Browserify scaffold
    from [Chapter 1](ch01.html "Chapter 1. Diving Headfirst into ReactJS"), *Diving
    Headfirst Into React*, and then we'll look at how to do the same with Webpack.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为我们的应用创建一个生产级管道。这包括将你的配置文件分为开发和生产版本，以及创建一个为Node.js服务器准备好的实例。首先，我们将查看如何设置来自[第1章](ch01.html
    "第1章。深入ReactJS")的Browserify脚手架的生产级部署，即*深入React*，然后我们将查看如何使用Webpack进行相同的操作。
- en: Using a cloud server is the most cost-efficient way to deploy your code. Before
    the cloud became a viable option, you would often have to deploy your code to
    your physical server, situated in a single data center. If you want to deploy
    your code to several data centers, you'd need to purchase or rent more physical
    servers, often at a significant cost.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用云服务器是部署代码最经济的方式。在云服务成为可行的选择之前，你通常会不得不将代码部署到位于单个数据中心中的物理服务器。如果你要将代码部署到多个数据中心，你需要购买或租赁更多的物理服务器，这通常需要相当大的成本。
- en: The cloud changes this because now you can deploy your code to a cloud provider
    who has data centers all over the world. The cost of deploying your app in the
    U.S. as well as in Europe and Asia is usually the same and relatively inexpensive
    as well.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务改变了这一点，因为现在你可以将你的代码部署到全球拥有数据中心的所有云服务提供商。在美国、欧洲和亚洲部署你的应用的成本通常相同，而且相对便宜。
- en: 'These are the topics we''ll cover in detail:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将详细讨论的主题：
- en: Choosing a cloud provider
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择云服务提供商
- en: Preparing a Browserify app for the cloud
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为云服务准备Browserify应用
- en: Preparing a Webpack app for the cloud
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为云服务准备Webpack应用
- en: Choosing a cloud provider
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择云服务提供商
- en: There are a vast number of decent cloud providers available to choose from.
    Among the most popular and mature providers are **Heroku**, **Microsoft Azure**,
    **Amazon**, **Google App Engine**, and **Digital Ocean**. All of them come with
    their own set of advantages and disadvantages, so it's well worth investigating
    each one of them before you decide to choose which one to go for.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 可供选择的大量云服务提供商中，最受欢迎和成熟的提供商包括**Heroku**、**Microsoft Azure**、**Amazon**、**Google
    App Engine**和**Digital Ocean**。它们各自都有其优点和缺点，因此在决定选择哪一个之前，调查每一个都是值得的。
- en: In this book, we've used Heroku throughout to deploy our apps, and we'll set
    up our deployments to target this platform. Let's take a brief look at the advantages
    and disadvantages of using Heroku.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们一直使用Heroku来部署我们的应用，我们将设置我们的部署以针对这个平台。让我们简要地看看使用Heroku的优点和缺点。
- en: 'The advantages are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 优点如下：
- en: Easy to use. After the initial sign-up, you usually only need to issue a single
    Git push to deploy your code.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于使用。在初始注册后，你通常只需要发出一个单一的Git push来部署你的代码。
- en: Easy to scale when traffic to your app increases.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你的应用流量增加时，易于扩展。
- en: Provides great plugin support for third-party apps and cloud services.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为第三方应用和云服务提供出色的插件支持。
- en: Free basic tier.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供免费的基本层。
- en: No infrastructure management.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有基础设施管理。
- en: 'Now, the disadvantages:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，缺点如下：
- en: Can get pricey. Heroku offers a generous free tier, but the first rung of the
    price ladder is pretty steep.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会变得昂贵。Heroku提供了慷慨的免费层，但价格阶梯的第一步相当陡峭。
- en: The vendor lock-in issue; it's a lot of work moving from Heroku to another cloud
    provider.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 供应商锁定问题；从Heroku迁移到另一个云服务提供商需要大量工作。
- en: The basic tier was sufficient for a while, but recently, Heroku has added a
    policy that the free instance must be inactive for 6 hours every 24 hours.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本层曾满足了一段时间，但最近，Heroku增加了一项政策，即免费实例每24小时必须保持6小时不活跃。
- en: The environment gets wiped irregularly. You can't log in to the instance and
    make local changes to the environment because they will be gone the next time
    the instance is refreshed.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境会不定期被清除。你无法登录实例并对环境进行本地更改，因为下一次实例刷新时它们将消失。
- en: Because it's relatively easy to get going with Heroku, we'll be using Heroku
    for deployment.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Heroku相对容易上手，我们将使用Heroku进行部署。
- en: Start with signing up for a free account at [https://signup.heroku.com/](https://signup.heroku.com/).
    After you've done this, download the Heroku toolbelt from [https://toolbelt.heroku.com/](https://toolbelt.heroku.com/).
    You also need to upload your SSH key. If you need help in generating an SSH key,
    visit [https://devcenter.heroku.com/articles/keys](https://devcenter.heroku.com/articles/keys).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在 [https://signup.heroku.com/](https://signup.heroku.com/) 注册一个免费账户。完成此操作后，从
    [https://toolbelt.heroku.com/](https://toolbelt.heroku.com/) 下载 Heroku 工具包。你还需要上传你的
    SSH 密钥。如果你需要生成 SSH 密钥的帮助，请访问 [https://devcenter.heroku.com/articles/keys](https://devcenter.heroku.com/articles/keys)。
- en: 'When the setup is done, you can create a Heroku app by issuing this command
    in your terminal:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，你可以在终端中输入以下命令来创建 Heroku 应用程序：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can omit the name, in which case Heroku will provide you with a random
    one. Note that Heroku requires Git. If you have a Git repository already, Heroku
    will automatically add the configuration parameters to your `.git/config` file.
    If not, you will have to do it manually later. The parameters look like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以省略名称，在这种情况下，Heroku 将为你提供一个随机的名称。请注意，Heroku 需要 Git。如果你已经有了 Git 仓库，Heroku 将自动将配置参数添加到你的
    `.git/config` 文件中。如果没有，你稍后必须手动完成。参数看起来像这样：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can find the configuration file inside the `.git` folder (note the dot).
    The file is called `config`, so the full path is `.git/config`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `.git` 文件夹（注意点号）内找到配置文件。文件名为 `config`，所以完整路径是 `.git/config`。
- en: 'To deploy your app, add the files to your repository and commit your changes.
    Then, issue the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署你的应用程序，将文件添加到你的仓库并提交你的更改。然后，执行以下命令：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Your app will then be deployed, based on the master branch. You can deploy other
    branches by typing in `git push heroku yourbranch:master` instead.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你的应用程序将基于主分支进行部署。你可以通过输入 `git push heroku yourbranch:master` 来部署其他分支。
- en: Setting up cloud deployment with npm
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 npm 设置云部署
- en: If we try to publish our scaffold right off the bat, we'll probably end up with
    an error because we haven't told Heroku how to serve our app. Heroku will simply
    try running the app with `npm start`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们立即尝试发布我们的脚手架，我们可能会遇到错误，因为我们没有告诉 Heroku 如何为我们提供应用程序。Heroku 将简单地尝试使用 `npm
    start` 运行应用程序。
- en: The `npm` package is the backbone of Node.js. We've covered it briefly in previous
    chapters, but as we're going to depend heavily on it now, it's time to take a
    closer look at what it can do for you.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm` 包是 Node.js 的基础。我们在前面的章节中简要介绍了它，但鉴于我们现在将严重依赖它，现在是时候更仔细地看看它能为你们做什么了。'
- en: You may have heard of or even used task runners such as **Grunt**, **Gulp**,
    or **Broccoli**. They are great at automating tasks so that you can focus on writing
    code rather than performing repetitive tasks, such as minifying and bundling your
    code, copying and concatenating stylesheets, and so on.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过或甚至使用过像 **Grunt**、**Gulp** 或 **Broccoli** 这样的任务运行器。它们擅长自动化任务，这样你就可以专注于编写代码，而不是执行重复性任务，例如压缩和打包你的代码、复制和连接样式表等。
- en: Yet, for most tasks, you're better off letting `npm` do the job for you. With
    `npm` scripts, you have all the power you need to automate common tasks, with
    less overhead and maintenance to boot.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于大多数任务，你最好让 `npm` 为你完成工作。使用 `npm` 脚本，你将拥有自动化常见任务所需的所有功能，而且开销和维护成本更低。
- en: The `npm` package comes with a few built-in commands, one of which is `npm run-script`
    (`npm run` for short). This command extracts the scripts object from `package.json`.
    The first argument passed to `npm run` refers to a property in the scripts object.
    For any property you create yourself, you need to run them with `npm run`. A few
    property names have been reserved, such as `start`, `stop`, `restart`, `install`,
    `publish`, `test`, and so on. They can be invoked by simply executing `npm start`
    and so on.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm` 包包含一些内置命令，其中之一是 `npm run-script`（简称 `npm run`）。此命令从 `package.json` 中提取脚本对象。传递给
    `npm run` 的第一个参数指的是脚本对象中的一个属性。对于你自己创建的任何属性，你需要使用 `npm run` 来运行它们。一些属性名称已被保留，例如
    `start`、`stop`、`restart`、`install`、`publish`、`test` 等。它们可以通过简单地执行 `npm start`
    等命令来调用。'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An important thing to note is that `npm run foo` will also run `prefoo` and
    `postfoo` if defined. You can run each stage separately by executing `npm run
    prefoo` or `postfoo`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点需要注意，如果定义了 `prefoo` 和 `postfoo`，则 `npm run foo` 也会运行它们。你可以通过执行 `npm run prefoo`
    或 `postfoo` 来单独运行每个阶段。
- en: 'Execute `npm run` to see the available scripts; you''ll see the following output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `npm run` 命令以查看可用的脚本；你将看到以下输出：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is interesting. We haven't made a start script, yet `npm` `run` tells us
    that `npm start` will run `node server.js`. This is another default of node. If
    you haven't specified a start script and there is a `server.js` file in your root,
    then this will be executed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣。我们还没有创建一个启动脚本，但 `npm run` 告诉我们 `npm start` 将运行 `node server.js`。这是 node
    的另一个默认设置。如果你没有指定启动脚本，并且根目录中有一个 `server.js` 文件，那么它将被执行。
- en: Heroku still won't run the scaffold because the express server is configured
    to start a develop session with Webpack and hot reloading. You need to create
    a production server in addition to your develop server.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku 仍然不会运行脚手架，因为 express 服务器配置为使用 Webpack 和热重载启动开发会话。你需要创建一个生产服务器，除了你的开发服务器之外。
- en: 'You can approach this in one of two ways:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式之一来处理这个问题：
- en: 'One option is to introduce `environment` flags in your server code, such as
    this:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个选择是在你的服务器代码中引入 `environment` 标志，例如这样：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The other option is to create an independent production `server` file
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个选择是创建一个独立的 `server` 生产文件
- en: Either way is good, but it's arguably cleaner to use a separate file, so we'll
    go with that approach.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都很好，但使用单独的文件可能更干净，所以我们选择这种方法。
- en: Preparing your Browserify app for cloud deployment
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备你的 Browserify 应用以进行云部署
- en: In this section, we'll use the shop application we developed in [Chapter 2](ch02.html
    "Chapter 2. Creating a Web Shop"), *Creating a Web Shop*. The app uses Browserify
    to bundle the code and node to run the development server. We'll keep on using
    the node in production, but we'll need to set up a specific `server` file in order
    to make a production-ready app.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用我们在 [第 2 章](ch02.html "第 2 章。创建一个网络商店") 中开发的商店应用，*创建一个网络商店*。该应用使用
    Browserify 打包代码并使用 node 运行开发服务器。我们将继续在生产中使用 node，但我们需要设置一个特定的 `server` 文件，以便制作一个生产就绪的应用。
- en: 'As a reminder, this is how our shop app looks like before we start:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，这是我们开始之前商店应用的样子：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We''ll take these steps to make it cloud-ready:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取以下步骤使其准备好云部署：
- en: Create a production server file
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建生产服务器文件
- en: Install production dependencies
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装生产依赖项
- en: Modify `package.json`
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 `package.json`
- en: Transpile our code base to EcmaScript 5
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的代码库转换为 EcmaScript 5
- en: The actual process
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际的过程
- en: 'Create a new file called `server.prod.js` and put it in the root of your project.
    Add this code to it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `server.prod.js` 的新文件，并将其放在项目的根目录下。将以下代码添加到其中：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We''re defining an express server and setting up a host and a `port` variable.
    The defaults are port `8080` on `0.0.0.0`. This host address is functionally identical
    to localhost when running on your local machine, but it can make a difference
    when running on your server. If the server host has several IP addresses, specifying
    `0.0.0.0` as the host will match any request. Using a parameter such as localhost
    can result in a situation where the server will be unable to bind your app and
    fail to start:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在定义一个 express 服务器并设置主机和 `port` 变量。默认情况下，在 `0.0.0.0` 上为端口 `8080`。当在本地机器上运行时，这个主机地址在功能上与
    localhost 相同，但在服务器上运行时可能会有所不同。如果服务器主机有多个 IP 地址，将 `0.0.0.0` 作为主机将匹配任何请求。使用如 localhost
    这样的参数可能会导致服务器无法绑定你的应用并失败启动：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since we''re going to be serving files to the public, it''s worth compressing
    them with **GZIP** before serving them. For text and script files, the savings
    can be dramatic, up to 80-90 percent in many cases. For a low-traffic site, this
    implementation is good enough. For a high-traffic site, the best way to put compression
    in place is to implement it at a reverse proxy level, for instance, by using **nginx**.
    We''ll route all requests to our `public` folder and the desired filename:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将向公众提供文件，因此在提供服务之前用 **GZIP** 压缩它们是值得的。对于文本和脚本文件，节省的量可能非常显著，在许多情况下可达 80-90%。对于流量较低的网站，这种实现已经足够好。对于流量较高的网站，在反向代理级别实现压缩是最佳方式，例如，通过使用
    **nginx**。我们将路由所有请求到我们的 `public` 文件夹和所需的文件名：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, the server will start with a debug message telling us the address
    of the deployed app:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，服务器将以调试信息启动，告诉我们已部署应用的地址：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The next thing we need to do is create a `build` script to bundle our JavaScript
    code. When running the development server, the code is bundled automatically.
    This bundle is usually rather large. For instance, the development bundle for
    the shop app is 1.4 MB. Even with compression enabled, this file is arguably too
    large to present to your users. When deploying to production, we need to create
    a smaller bundle so that your app will download and be ready to use faster. Fortunately,
    this is rather easy.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步我们需要做的是创建一个`build`脚本来打包我们的JavaScript代码。在运行开发服务器时，代码会自动打包。这个包通常相当大。例如，商店应用的开发包是1.4
    MB。即使启用了压缩，这个文件也可能太大，不适合向用户展示。当部署到生产环境时，我们需要创建一个更小的包，以便您的应用可以更快地下载并准备好使用。幸运的是，这相当简单。
- en: We're going to use a combination of the CLI version of Browserify and UglifyJS.
    The latter is a compression tool that strips out newlines, shortens variable names,
    and strips out unused code from our bundle. We'll run it by first bundling our
    source files with Browserify, then we'll use the pipe operator (`|`) to send the
    output to UglifyJS. The result of this operation is then sent to a `bundle` file
    with the greater-than operator (`>`).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Browserify和UglifyJS的CLI版本组合。后者是一个压缩工具，它会删除换行符、缩短变量名，并从我们的包中删除未使用的代码。我们将首先使用Browserify打包源文件，然后使用管道运算符（`|`）将输出发送到UglifyJS。此操作的输出结果然后通过大于运算符（`>`）发送到一个`bundle`文件。
- en: 'The first part of the sequence looks like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 序列的第一部分如下：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When you run this, the entire bundle will be returned as a string output. You
    can optionally specify `-o bundle.js` in order to save the result to a bundle
    file. We don't want to do this because we have no use for a temporary bundle.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此命令时，整个包将以字符串形式输出。您可以可选地指定`-o bundle.js`以将结果保存到包文件中。我们不希望这样做，因为我们不需要临时包。
- en: 'The second part of the sequence looks like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 序列的第二部分如下：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have specified a few arguments, so let's look at what they do.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经指定了一些参数，让我们看看它们的作用。
- en: The `-p` argument skips the prefix for the original filenames that appear in
    the source name. The saving here is very small, but it's worth keeping in there
    nonetheless. The number after the argument is the number of relative paths dropped.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p`参数跳过源文件名中出现的原始文件名前缀。这里的节省非常小，但仍然值得保留。参数后面的数字是删除的相对路径数。'
- en: The `-c` option is short for compressor. By not specifying any compressor option,
    the default compress option will be used. This saves quite a few bytes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`-c`选项代表压缩器。如果不指定任何压缩器选项，将使用默认的压缩选项。这可以节省很多字节。'
- en: The next is `drop_console=true`. This tells UglifyJS to remove any console logs.
    This is useful if you've used this method for debugging your app and have forgotten
    to remove it from your code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`drop_console=true`。这告诉UglifyJS删除任何控制台日志。如果您在调试应用时使用了这种方法，并且忘记从代码中删除它，这将很有用。
- en: The next one is `-m`, which is short for mangle. This option changes and shortens
    your variable and function names and is a serious byte-saving factor.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个是`-m`，代表混淆。此选项更改并缩短了您的变量和函数名，并且是一个重要的字节节省因素。
- en: The final two arguments won't save any bytes, but they're still useful. The
    `--max-line-len` argument will break up the uglified code if the line length is
    above a given value (defaults to 32,000 characters). This is useful when supporting
    older browsers that can't cope with very long lines. The `––inline-script` argument
    escapes the slash in the occurrences of `</script` in strings.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个参数不会节省任何字节，但它们仍然很有用。`--max-line-len`参数会在行长度超过给定值时（默认为32,000个字符）拆分丑化后的代码。当支持无法处理非常长行的旧浏览器时，这很有用。`--inline-script`参数会转义字符串中`</script`出现的斜杠。
- en: 'Running this command on its own won''t result in a compressed bundle because
    we haven''t specified an input. If you store the bundle in a temporary file, you
    could send the content to the preceding command by using the less-than operator
    and the filename like this: `< bundle.js`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 仅运行此命令本身不会生成压缩包，因为我们没有指定输入。如果您将包存储在临时文件中，可以使用小于运算符和文件名（如：`< bundle.js`）将内容发送到前面的命令。
- en: Finally, we'll send the result to the output location we desire by using the
    greater-than operator.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用大于运算符将结果发送到我们想要的输出位置。
- en: 'The full command sequence looks like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的命令序列如下：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Running the first part results in a bundle size that's approximately 1.4 MB.
    Passing it through UglifyJS results in a bundle size of about 548 KB. If you drop
    the options and go with vanilla UglifyJS, you'll end up with a bundle size that's
    about 871 KB.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 运行第一部分的结果是一个大约 1.4 MB 的包大小。通过 UglifyJS 处理后，包大小约为 548 KB。如果你去掉选项并使用纯 UglifyJS，最终的包大小大约为
    871 KB。
- en: After bundling and minifying, we're now ready to deploy our app to the cloud.
    Since we're using compression, the final bundle size will be approximately 130
    KB. That's a huge win when compared to the original file size of 1.4 MB.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在打包和压缩之后，我们现在可以准备好将我们的应用到云端部署。由于我们使用了压缩，最终的包大小大约为 130 KB。与原始文件大小 1.4 MB 相比，这是一个巨大的胜利。
- en: Before we deploy our code, we need to tell Heroku how to start our app. We'll
    do this by adding a single file called `Procfile`. This is a special file that
    Heroku will read and execute if it exists. If it doesn't exist, Heroku will try
    to execute `npm start` instead; if this fails, try to run `node server.js`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们部署代码之前，我们需要告诉 Heroku 如何启动我们的应用。我们将通过添加一个名为 `Procfile` 的单个文件来完成这项工作。这是一个特殊的文件，如果存在，Heroku
    将会读取并执行它。如果不存在，Heroku 将尝试执行 `npm start`；如果失败，则尝试运行 `node server.js`。
- en: 'Add the `Procfile` file with this content:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 添加包含以下内容的 `Procfile` 文件：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When you''ve done this, commit your code and push to Heroku by executing this
    command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，提交你的代码并通过执行此命令将代码推送到 Heroku：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The end result should look identical to the local app, except that now you''re
    running it on the cloud. The example app is available on [https://reactjsblueprints-webshop.herokuapp.com/](https://reactjsblueprints-webshop.herokuapp.com/).
    The following screenshot displays the web page of the preceding link:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果应该与本地应用看起来完全相同，但现在你是在云端运行它。示例应用可在 [https://reactjsblueprints-webshop.herokuapp.com/](https://reactjsblueprints-webshop.herokuapp.com/)
    找到。以下截图显示了上述链接的网页：
- en: '![The actual process](img/B04943_08_01.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![实际过程](img/B04943_08_01.jpg)'
- en: It's very tough to remember the entire command sequence for generating a minified
    Browserify bundle. We'll add it to `package.json` so we can execute it with ease.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 记住生成压缩后的 Browserify 包的整个命令序列非常困难。我们将将其添加到 `package.json` 中，以便我们可以轻松执行。
- en: 'Open `package.json` and replace the contents in the `scripts` section with
    this code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `package.json` 并将 `scripts` 部分的内文替换为以下代码：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now you can run the bundle operation with `npm run bundle`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用 `npm run bundle` 来运行打包操作。
- en: Deploying a Webpack app to the cloud
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Webpack 应用部署到云端
- en: In this section, we'll use the Webpack scaffold we developed in [Chapter 6](ch06.html
    "Chapter 6. Advanced React"), *Advanced React*. We'll need to add a few packages
    and make some modifications.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用我们在 [第 6 章](ch06.html "第 6 章。高级 React") 中开发的 Webpack 框架，*高级 React*。我们需要添加一些包并做一些修改。
- en: 'As a reminder, this is the file structure of our scaffold before we start:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，这是我们开始之前的项目文件结构：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s start by renaming our `server.js` file to `server-development.js`. Then,
    create a new file called `server-production.js` in the root of the scaffold and
    add this code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先把我们名为 `server.js` 的文件重命名为 `server-development.js`。然后，在项目根目录中创建一个名为 `server-production.js`
    的新文件，并添加以下代码：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we instruct the server to use the preconfigured variables for `PORT`
    and `HOST` or the default variables if these aren''t provided, just as we did
    with the Browserify server. Then, we add an error handler so that we are able
    to respond to errors gracefully. This could also be added to the Browserify server:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指示服务器使用预配置的 `PORT` 和 `HOST` 变量或默认变量，就像我们在 Browserify 服务器中所做的那样。然后，我们添加了一个错误处理器，以便我们能够优雅地响应错误。这也可以添加到
    Browserify 服务器中：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We add compression as well:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了压缩：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we move on to the `assets` file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向 `assets` 文件：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We''ll copy the `asset` files we need manually. We only have two, so it''s
    okay to do this manually. If we had many files to copy, another approach might
    be more beneficial. An option that is cross-compatible across different environments
    is **ShellJS**. With this extension, you can set up ordinary `shell` commands
    and have them executed in a JavaScript environment. We won''t do this in this
    project but it''s worth looking into. Now refer to the following lines of code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将手动复制所需的 `asset` 文件。我们只有两个文件，所以手动操作是可以接受的。如果我们有很多文件要复制，另一种方法可能更有效。一个在不同环境中都兼容的选项是
    **ShellJS**。使用这个扩展，你可以在 JavaScript 环境中设置普通 `shell` 命令并执行它们。我们在这个项目中不会这样做，但值得一看。现在参考以下代码行：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, we set the `environment` to `production`, and we let Express know that
    our static files are placed in the `./public/assets` folder using the `serve-static`
    middleware. This means we can refer to `/app.css` in our file, and Express will
    know to look for it in the correct `assets` folder. For low-traffic apps, this
    is a good implementation, but for a high-traffic app, it''s better to use a reverse
    proxy to serve static files. The main benefit of using a reverse proxy is to remove
    load from your dynamic server to other servers specially designed to handle assets.
    We route all requests to `index.html`. This will not apply to files that exist
    in the `static` folder:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `environment` 设置为 `production`，并让 Express 知道我们的静态文件放置在 `./public/assets`
    文件夹中，使用 `serve-static` 中间件。这意味着我们可以在文件中引用 `/app.css`，Express 将知道在正确的 `assets`
    文件夹中查找它。对于低流量应用，这是一个好的实现，但对于高流量应用，最好使用反向代理来提供静态文件。使用反向代理的主要好处是减轻动态服务器上的负载，将其转移到专门设计来处理资产的其它服务器。我们路由所有请求到
    `index.html`。这不会应用于存在于 `static` 文件夹中的文件：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We create the `server` object so that we can pass it to the error handler:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建 `server` 对象以便将其传递给错误处理器：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we respond to errors and conditionally shut down the server. The `server`
    object is passed as an argument so that the error handler can shut it down gracefully:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们响应错误并条件性地关闭服务器。`server` 对象作为参数传递，以便错误处理器可以优雅地关闭它：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we start the app:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们启动应用：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you''ve noticed, we''ve added a few new packages. Install these with this
    command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所注意到的，我们添加了一些新的包。使用以下命令安装这些包：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'All modules that are required in `server.prod.js` need to be moved to the `dependencies`
    section in `package.json`. Your dependencies section should now look like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所有在 `server.prod.js` 中需要的模块都需要移动到 `package.json` 的 `dependencies` 部分中。您的依赖部分现在应该看起来像这样：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: All dependencies that Heroku needs must be put in the normal dependencies section
    because Heroku will omit all packages in `devDependencies`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku 需要的所有依赖项都必须放在正常的 `dependencies` 部分中，因为 Heroku 会省略 `devDependencies` 中的所有包。
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Dependency strategy for cloud deployment**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**云部署的依赖策略**'
- en: Since downloading and installing packages from `npm` is rather slow, it's a
    good practice to put packages you only need when developing in `devDependencies`
    and vice-versa. We've been doing this throughout the entire book, so hopefully
    you're already following this pattern.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从 `npm` 下载和安装包相当慢，将仅在开发时需要的包放在 `devDependencies` 中，反之亦然，是一种良好的实践。我们在整本书中都这样做，所以希望您已经遵循了这种模式。
- en: We're almost done, but we need to create a production version of `webpack.config.js`,
    `index.html` and add the build scripts before we're ready.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了，但在我们准备好之前，我们需要创建 `webpack.config.js`、`index.html` 的生产版本，并添加构建脚本。
- en: Rename your existing `webpack.config.js` file to `Webpack-development.config.js`,
    and then create a file called `Webpack-production.config.js`. Note that this means
    you need to change the Webpack import in `server-development.js` to reflect this
    change.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将现有的 `webpack.config.js` 文件重命名为 `Webpack-development.config.js`，然后创建一个名为 `Webpack-production.config.js`
    的文件。注意，这意味着您需要将 `server-development.js` 中的 Webpack 导入更改为反映这一更改。
- en: 'Add the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This plugin reorders the packages so that the most used one is put at the top.
    This should reduce the file size and make the bundle more efficient. We specify
    that this is a production build so that Webpack utilizes the most byte-saving
    algorithm it has:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件重新排序包，以便最常用的包放在顶部。这应该会减小文件大小并使包更高效。我们指定这是一个生产构建，以便 Webpack 利用它拥有的最节省字节的算法：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We''ll also tell it to use UglifyJS to compress our code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将告诉它使用 UglifyJS 压缩我们的代码：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'From the `production` configuration of Webpack, we remove the hot loader plugin
    since it only makes sense to have it included when developing:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Webpack 的 `production` 配置中，我们移除了热加载插件，因为它仅在开发时才有意义：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, add a file called `index-production.html` to `assets` and add this code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将一个名为 `index-production.html` 的文件添加到 `assets` 目录中，并添加以下代码：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, add these scripts to `package.json`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将这些脚本添加到 `package.json` 中：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: These scripts let you build and deploy your app. We've stopped short from actually
    committing the changes to let you know that the deploy process is ready to commence.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些脚本让您可以构建和部署您的应用。我们暂时没有提交更改，以便让您知道部署过程已准备就绪。
- en: Note that in the build argument, we add `NODE_ENV=production` in order to prevent
    Babel from trying to use the `hot` module replacement when building the code.
    The configuration that controls this is in `.babelrc`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在构建参数中，我们添加了 `NODE_ENV=production` 以防止 Babel 在构建代码时尝试使用 `hot` 模块替换。控制此功能的配置在
    `.babelrc` 文件中。
- en: Your Webpack scaffold is now production-ready!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Webpack 框架现在已准备好用于生产！
- en: When developing, execute `npm run dev` and enjoy a slick development environment
    with hot reloading.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发时，执行 `npm run dev` 并享受一个具有热重载的流畅开发环境。
- en: On `npm deploy`, the build script is executed and it lets you know when it's
    ready to publish your changes. You need to add the changes yourself via `git add`
    and `git commit` and then run `git push heroku master`. You can, of course, automate
    this in the deploy script.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `npm deploy` 上，构建脚本将被执行，并会通知你何时准备好发布更改。你需要通过 `git add` 和 `git commit` 手动添加更改，然后运行
    `git push heroku master`。当然，你可以在部署脚本中自动化这一过程。
- en: The build script can also be triggered by issuing `npm run build`. Before building
    the script, we will first execute `rimraf public`. **Rimraf** is an environment-safe
    command that deletes the `public` folder and all its contents. It's the same as
    running `rm -rf public` on Mac/Linux. This command doesn't exist on Windows, so
    running `rm` on that platform won't work, but running `rimraf` will work on either
    platform. Finally, the script executes `webpack` and builds a production bundle
    that is put in `public/assets/bundle.js`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 构建脚本也可以通过执行 `npm run build` 来触发。在构建脚本之前，我们将首先执行 `rimraf public`。**Rimraf** 是一个环境安全的命令，用于删除
    `public` 文件夹及其所有内容。它在 Mac/Linux 上等同于运行 `rm -rf public`。此命令在 Windows 上不存在，因此在那个平台上运行
    `rm` 不会起作用，但运行 `rimraf` 将在任一平台上起作用。最后，脚本执行 `webpack` 并构建一个生产包，该包放在 `public/assets/bundle.js`
    中。
- en: In general, Webpack is slightly more efficient at removing unused code, so the
    final bundle sizes will be smaller than the ones generated by Browserify. The
    bundle generated in this example is about 132 KB.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，Webpack 在移除未使用代码方面略有效率，因此最终生成的包大小将小于 Browserify 生成的包。本例中生成的包大约为 132 KB。
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this is not an apples-to-apples comparison because the app we bundled
    in the Browserify section was much larger.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这并不是一个完全公平的比较，因为我们捆绑在 Browserify 部分的应用程序要大得多。
- en: The final result is available at [https://reactjsblueprints-wpdeploy.herokuapp.com/](https://reactjsblueprints-wpdeploy.herokuapp.com/).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果可在[https://reactjsblueprints-wpdeploy.herokuapp.com/](https://reactjsblueprints-wpdeploy.herokuapp.com/)找到。
- en: '![Deploying a Webpack app to the cloud](img/B04943_08_02.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![将 Webpack 应用程序部署到云端](img/B04943_08_02.jpg)'
- en: 'For reference, our file structure now looks like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了参考，我们的文件结构现在看起来是这样的：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It's still quite manageable. Admittedly, separating the files in `prod` and
    `dev` requires a bit more handholding, but it's arguably better than switching
    the code with `if…else` loops inside different files. However, code organization
    is admittedly a thorny issue, and there is no general setup that will please everyone.
    For small modifications spanning just a few files, `if…else` statements are probably
    preferable to break up the files in production and development versions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然相当易于管理。诚然，在 `prod` 和 `dev` 中分离文件需要更多的人工干预，但与在文件内部使用 `if…else` 循环切换代码相比，这可能是更好的选择。然而，代码组织确实是一个棘手的问题，没有一种通用的设置能令每个人都满意。对于仅涉及几个文件的少量修改，`if…else`
    语句可能更适合在生产版本和开发版本中分割文件。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we added cloud deployment to the two scaffolds we developed
    throughout this book. A preview of both examples are available online.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将云部署添加到了本书中开发的所有两个框架中。两个示例的预览现在可在网上找到。
- en: Generating cloud-deployable apps generally means bundling our code as tight
    as possible. With the era of HTTP/2 upon us, this strategy may have to be revisited
    as it may be more beneficial to generate a set of files that can be downloaded
    in parallel instead of a single bundle, however small it may be. It's worth noting
    that very small files won't benefit much from *gzipping*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 生成可云部署的应用程序通常意味着尽可能紧密地捆绑我们的代码。随着 HTTP/2 时代的到来，这种策略可能需要重新审视，因为生成一组可以并行下载的文件可能更有益，而不是单个捆绑包，无论它有多小。值得注意的是，非常小的文件从
    *gzip* 中获益不大。
- en: It's also possible to split your code bundles with Webpack. For more on code
    splitting with Webpack, take a look at [https://webpack.github.io/docs/code-splitting.html](https://webpack.github.io/docs/code-splitting.html).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Webpack 也可以分割你的代码包。有关 Webpack 代码分割的更多信息，请参阅[https://webpack.github.io/docs/code-splitting.html](https://webpack.github.io/docs/code-splitting.html)。
- en: In the next chapter, we'll develop a streaming server-rendered app based on
    the production Webpack setup we just made in this chapter.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将基于本章中刚刚制作的生成式Webpack配置，开发一个流式服务器渲染的应用程序。
