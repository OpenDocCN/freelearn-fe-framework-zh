- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Utilizing Vue’s Built-In Directives for Effortless Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how Vue.js features, such as dynamic classes,
    props, and private state, help us simplify our development. In this chapter, we
    will continue to build on top of our previous topic by introducing you to the
    world of Vue.js built-in directives. These directives are the first real taste
    of Vue.js and will provide you with the tools necessary to make your code more
    dynamic. The main goal of these directives is to simplify your workflow and make
    your development easier. Throughout the chapter, we will introduce two new components
    called `TheHeader.vue` and `SocialPostComments.vue`, alongside continuing to work
    on existing components such as `SocialPost.vue` to make them more dynamic and
    ready for future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to break up the chapter into three different sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying text with `v-text` and `v-html`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling element visibility with `v-if` and `v-show`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying your template with `v-for`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have a basic understanding of some of the
    Vue.js built-in directives and be able to toggle component visibility with `v-if`
    and `v-show`, and will learn how to simplify your HTML templates by using `v-for`
    and render text or HTML with `v-text` and `v-html`.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code required for you to complete the chapter can be found on GitHub within
    a branch called `CH04`. To pull this branch, run the following command or use
    your GUI of choice to support you in this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Do not forget that the repository can be found at [https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners).
  prefs: []
  type: TYPE_NORMAL
- en: There are some small changes to the branch compared to the end of the previous
    chapter. These changes were added to simplify the book and allow us to focus on
    the learning material instead of spending too much time on setting things up.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying text with v-text and v-html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**HTML** is a very powerful tool, but it does have its limitations that forces
    us to have very verbose and hard-to-maintain code. If you have ever worked on
    a fully static site without a framework, you may have encountered long HTML pages
    with many duplicated code blocks. This is where Vue directives come in handy.'
  prefs: []
  type: TYPE_NORMAL
- en: Vue’s directives are described on Vue School website as “special HTML attributes
    that allow us to manipulate the **Document Object** **Model** (**DOM**).”
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters, we have seen how Vue uses existing attribute syntax to
    add functionality such as component properties. Vue directives follow a similar
    approach that creates new functionality by using syntax that resembles existing
    HTML.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding description says that Vue.js directives allow us to manipulate
    the **DOM**, but are there any native HTML attributes that do something similar?
    The answer is yes.
  prefs: []
  type: TYPE_NORMAL
- en: HTML provides us with attributes such as “value” in a `<input>` element that
    assigns the visible value. We also have “rows” and “column” in a `<textarea>`
    that define the size of our element. The list could go on for a long time, but
    I think it is good to illustrate what directives can help us achieve.
  prefs: []
  type: TYPE_NORMAL
- en: Vue’s built-in directives, allow us to modify the DOM and enhance the flexibility
    of a component with the use of the element attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the 15 built-in directives of Vue:'
  prefs: []
  type: TYPE_NORMAL
- en: '`v-text`: Sets the `innerText` of a given element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v-html`: Sets the `innetHtml` of a given element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v-show`: Toggles the element visibility (`display:hidden`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v-if`: Renders the element if a condition is met'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v-else`: Displays the element if the previous condition (`v-if` or `v-else-if`)
    was not met'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v-else-if`: Displays the element if the previous condition (`v-if`) was not
    met, and the current one is fulfilled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v-for`: Renders the element or template block multiple times based on the
    source data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v-on`: Triggers a callback when an event is triggered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v-bind`: Dynamically binds one or more attributes or a component prop to an
    expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v-model`: Creates a two-way binding on a form input element or a component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v-slot`: Defines a placeholder used by the parent component to be replaced
    with arbitrary markup'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v-pre`: Skips compilation for this element and all its children (usually used
    to display code blocks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v-once`: Renders the element and component once only and skips future updates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v-memo`: Memoizes a sub-tree of the template'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v-cloak`: Used to hide an uncompiled template until it is ready'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the preceding directives, including `v-memo`, `v-once`, and `v-cloak`,
    are for more advanced users and will not be covered during the course of the book,
    but if you are interested, you can find more information about these in the Vue.js
    official documentation ([https://vuejs.org/api/built-in-directives.html#v-once](https://vuejs.org/api/built-in-directives.html#v-once)).
    The rest of the directives will be explained and accompanied by coding examples.
  prefs: []
  type: TYPE_NORMAL
- en: Good to know
  prefs: []
  type: TYPE_NORMAL
- en: All built-in directives start with a prefix of `v-`. This is done to be able
    to separate the framework attributes from native attributes available in the HTML.
    This standard is also used to create custom directives that should always start
    with the same prefix.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with our first directive, `v-text`.
  prefs: []
  type: TYPE_NORMAL
- en: Applying dynamic text to our component using v-text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vue.js directives are a very strong addition to Vue.js feature. Not only because
    they provide extra functionality, but also because they help to write cleaner
    and more readable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'When asked about how important code readability is, I always steer people into
    reading the book *Clean Code* by *Robert Martin* in which he states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: “Indeed, the ratio of time spent reading versus writing is well over 10 to 1\.
    …[Therefore,] making it easy to read makes it easier to write.”
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start to work with some of these directives and see how they can be plugged
    in our Companion App.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to work on a new component that will be used as
    the header of our companion app. This component has already been created in the
    repository and you can find it within the `components/organisms/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: As you can deduce from the folder in which the component is saved, this component
    is going to be an “organism” within our atomic design structure that we discussed
    in [*Chapter 1*](B21130_01.xhtml#_idTextAnchor015).
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, let’s explain why our component is going to be called `TheHeader.vue`.
    The file name of Vue components needs to always be unique and different from native
    HTML elements, and this prevented us from simply calling it `header` as it would
    have clashed with the HTML `header` native element. To avoid these issues, Vue.js
    component names should always be made up of two words written using Pascal case,
    where the first word and any additional words start with an uppercase letter.
    There are some cases in which finding two words to make up a component name can
    be hard. When this case arises, we can prefix the component with the word `the`.
    Using this approach for our header component will then produce a component name
    of `TheHeader`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This component is going to show a logo, a title, and a link to our user profile.
    If we run our application using the `npm run dev` command, we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: Companion app landing page displaying the new header](img/B21130_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Companion app landing page displaying the new header'
  prefs: []
  type: TYPE_NORMAL
- en: The code of our component is currently plain HTML with hardcoded data, and it
    is up to us to update it to make it dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: If you have ever used the internet, you will probably know that a username like
    the one displayed in the preceding screenshot should not be hardcoded, but rather
    should be dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: So, our first step is to remove this hardcoded value from the HTML and turn
    it into a Ref instance, just like we learned in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to create a `Ref` variable with the username in our script
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we are going to use our first built-in directives to assign this variable
    to the HTML element, as shown in the snippets below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using the `v-text` built-in directive will automatically change the `innerText`
    of the element with the value of our JavaScript variable `username`.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in our example, the name is still hardcoded as the Ref is predefined
    in our script, but this will later be changed to dynamically be fetched from an
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember from our previous chapter, we already managed to assign dynamic
    text to replace the post, name, and username in our `SocialPost.vue` file. We
    achieved that using the mustache interpolation syntax `{{ }}`, just as we did
    to display our post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So, at this point, you may be asking yourself, what is the actual difference
    between these two methods?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is not going to be exciting—in fact, both of these methods will compile
    into the same code at render time. The two methods, even if they achieve the same
    goal, have different syntax, one defined as an attribute using `v-text` and the
    other directly written as part of element content using `{{ }}`, and will appeal
    to different developers to align with their coding style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another small difference is that `v-text` will replace the full content of
    `innerHTML`while using the mustache interpolation will allow you to replace just
    part of the text. Let’s see an example that illustrates these differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the first example that uses `v-text`, we had to add a `<span>` element to
    be able to use the directives. In fact, if we had assigned the `v-text` directives
    directly to the `<a>` tag, the “Welcome” text would have been overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example that uses the double curly braces, we can see that we
    are able to change just part of the string without the need for extra markup,
    making it more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, the use of `v-text` or mustache interpolation can be interchanged
    and there is no right or wrong, it is totally a personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the inner HTML of an element with v-html
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous subsection, we used our first Vue.js directive, `v-text`. We
    learned that this directive replaces the `innerText` of a given component, but
    what if we would like to replace the text with a dynamic string that includes
    HTML? This is where `v-html` comes in handy. Let’s dig deeper into how this can
    be used and apply it in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering HTML can be dangerous
  prefs: []
  type: TYPE_NORMAL
- en: Rendering HTML dynamically needs to be done carefully as it can be very dangerous
    aand can lead to XSS vulnerabilities. Only use it for trusted content and never
    on user-provided content.
  prefs: []
  type: TYPE_NORMAL
- en: Before we explain *how* `v-html` is used, we should first try to understand
    *why* you would use this technique in your code. In fact, why would you add HTML
    within a variable when you can write it directly in the `<template>` section of
    your component?
  prefs: []
  type: TYPE_NORMAL
- en: 'I asked myself this question at the start of my career, but I then realized
    that there are a couple of cases in which `v-html` can be useful, including the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`v-html` can be useful when developing an application that receives its content
    (such as blog posts) from a CMS. In some cases, this is received as HTML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Third-party plugin output**: There are some third-party plugins such as code
    visualization and canvas visualization plugins that may require the use of HTML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hardcoded SVGs or icons**: It is very common for small projects to create
    a library of hardcoded assets such as icons and SVGs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the real uses of `v-html` are restricted to some very specific
    scenarios and it is not recommended for all string interpolation usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our header component, `TheHeader.vue`, currently includes a hardcoded SVG to
    display our logo. We can use `v-html` to make the image dynamic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a variable called `logo` to hold our SVG code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the `v-html` directives in our template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: All done! Our application will now display a star as the logo, instead of our
    previous image, as shown in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: Companion app header](img/B21130_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Companion app header'
  prefs: []
  type: TYPE_NORMAL
- en: This was a simple example that did not really make full use of the dynamic use
    of `v-html`. In fact, in a case like this, it may be more suitable to just place
    the SVG directly within the HTML as there is no need to create a dynamic property
    for something that is static.
  prefs: []
  type: TYPE_NORMAL
- en: It is time to move forward and cover how to toggle the visibility of our component.
    In the next section, we will learn all about `v-show` and `v-if` and start to
    see how using a framework such as Vue.js can really simplify our code.
  prefs: []
  type: TYPE_NORMAL
- en: Handling element visibility with v-if and v-show
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is all about element visibility. We are going to learn about two
    directives that can actually achieve the same result—toggling the element’s visibility—but
    with two underlying differences.
  prefs: []
  type: TYPE_NORMAL
- en: Toggling an element’s visibility means the ability to show or hide an element
    in our rendered HTML. This is a very common feature on the web today. This may
    be as simple as a dropdown appearing, a modal showing when a button is clicked,
    or more data being shown when a “show more” link is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Toggling visibility is the first of many features that support the increased
    adoption of many frontend frameworks by making the user experience flawless and
    reactive. First, we are going to add a button in our `SocialPost.vue` file that
    will show only if the article has comments, then we are going to display a new
    component called `SocialPostsComments.vue` that will be toggled by the new button
    and will be used in later sections to display a list of posts.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding elements from the DOM with v-show
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having the ability to show or hide an element can be useful for extremely complex
    situations, but also for very simple cases such as the one that we are about to
    cover.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the structure of our posts in `TheWelcome.vue`, you will notice
    that the `posts` object now includes extra information such as comments and tags
    that are not displayed yet.
  prefs: []
  type: TYPE_NORMAL
- en: Our first step is to display a button in `SocialPost.vue` that the user will
    be able to click to show or hide post comments. Because not all posts have comments,
    we would like to show this button just for articles that include comments. To
    achieve this, we are going to use `v-show`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with all other directives, `v-show` is just an element attribute that accepts
    a value. In this case, the value that is accepted is a `true` or `false`. When
    `v-show` receives a Boolean, it will *show* the element if its value is truthy,
    as in `<button v-show="true" />`, or *hide* the value if the value is false, as
    in `<button` `v-show="false" />`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have accessed our `SocialPost.vue` file and added
    a new button element. Then since we just want to display this new element only
    for posts that have comments, we have used our newly introduced `v-show` directive
    and used the comments properties to define when to toggle the element visibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in our case, if our post has no comment, the value of `comments.length
    > 0` will be equal to `false`, and when `v-show` receives a `false` value, it
    will hide the element. On the other hand, if the post has comments, the value
    of `comments.length > 0` will be truthy and the button will be shown. The preceding
    code will display the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: Companion app displaying the result of the preceding code snippet
    with one of the posts showing the “Show comments” button](img/B21130_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Companion app displaying the result of the preceding code snippet
    with one of the posts showing the “Show comments” button'
  prefs: []
  type: TYPE_NORMAL
- en: Please note that when using `v-show` we do not actually remove the item from
    the DOM, but just hide it. In fact, if we analyze the DOM using the browser debugger,
    we can see that the button is available in the second post, but just hidden.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: Chrome DevTools Elements tab showing the button in the DOM and
    its style defined as “display:none”](img/B21130_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Chrome DevTools Elements tab showing the button in the DOM and
    its style defined as “display:none”'
  prefs: []
  type: TYPE_NORMAL
- en: Even if this seems to be of very little importance for now, it will make more
    sense after the next section where we will learn about `v-if`.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the DOM clean and performant with v-if
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous subsection, we added a button to show comments, but these comments
    are still not displayed on the screen. In this section, we are going to add these
    comments to our UI by working on a new component and then enhance the **Show comments**
    button to toggle the visibility of these components on and off.
  prefs: []
  type: TYPE_NORMAL
- en: The `v-if` directive works in the same way as `v-show` did. It accepts an argument
    that will either show or hide the given element depending on it being *truthy*
    or *falsy*.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we are going to create a new Ref called `showComments` and this
    is going to be used to toggle our element visibility. Let’s see how to achieve
    this step by step in our `SocialPost.vue` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to define our new Ref in the <script> block of the **SFC** (**Single**
    **File Components**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the new component at the top of the script tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add that component to our HTML. We do so by passing it a property containing
    the comments like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `v-if` directives to make sure that the component is shown only when
    our showComments private data is true:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we checked the application now, we would notice that the new component is
    not displayed yet. This is because the value of showComments is set to `false`
    and there is no way to change it. Let’s fix the problem by allowing our “Show
    Comments” button to change the value of our Ref:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As shown in the preceding code, we used the native `click` event that triggers
    some basic JavaScript to change the value of our Ref. Thanks to Vue reactivity,
    our UI will automatically re-render when the value of `showComments` changes.
    If you would like to be able to toggle the component on and off, you could write
    `showComment = !showComment` to make sure that the value of `showComment` will
    be the equal to the *opposite* of the current value of `showComment.`
  prefs: []
  type: TYPE_NORMAL
- en: 'The component without its style should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Before we move on to the next section, in which we are going to learn how to
    render a list of items, we need to clarify the difference between `v-if` and `v-show`.
    In fact, until now we have not defined what really makes them different and there
    seems to be no reason why we could not use `v-show` in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we emphasized the fact that when using `v-show`, the
    HTML element is rendered in the DOM but hidden. However, if we look at the same
    aspect of `v-if`, we would notice that the element is missing altogether and is
    replaced by an HTML comment of `<!--v-if-->`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: DOM extract of the SocialPosts.vue component](img/B21130_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: DOM extract of the SocialPosts.vue component'
  prefs: []
  type: TYPE_NORMAL
- en: 'As small as this difference may seem to a new set of eyes, this is actually
    very important for three main reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Without the ability to omit elements from HTML, we will encounter errors if
    we try to render a component (even if hidden) that requires a specific value.
    For example, in our case, if we had used `v-show` the Vue compiler would have
    tried to render the component, but this would have failed as in some cases the
    comments variable would not have been available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering lots of unused elements in the DOM can really affect your performance.
    Let’s say for example that we had 150 comments on each post, and we used `v-show`.
    Now the DOM would have hundreds and hundreds of hidden nodes that may never be
    used. Using `v-if` allows us to make sure that these nodes are only rendered when
    needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is time to move forward to our next section where we will be learning a new
    directive called `v-for`. This directive allows us to render a list of items,
    such as our comments, by automatically duplicating our HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying your template with v-for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The directive covered in this section is called `v-for` and will be used to
    render a list of elements. If you have learned any programming language, you have
    probably been exposed to the concept of a `for` loops are used in programming
    languages to iterate through a list one entry at a time, and the `v-for` directive
    is no different.
  prefs: []
  type: TYPE_NORMAL
- en: Using `v-for` allows us to render a specific list by re-rendering the same element
    (or set of elements) multiple times. Using `v-for` not only simplifies our **HTML**,
    but also allows us to render dynamic lists that would be impossible to render
    ahead of time unless we knew the actual number of entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how the native HTML implementation and a Vue.js implementation of
    a simple list compare:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: Comparison of native HTML and Vue.js implementations of a list](img/B21130_04_06_BW.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Comparison of native HTML and Vue.js implementations of a list'
  prefs: []
  type: TYPE_NORMAL
- en: As shown, the implementation of a `v-for` directive is very similar to other
    `for` loops that you may have seen before. The directive accepts a parameter in
    the format of “item in array” just as in major programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Even if the preceding example does not seem very impressive, this will change
    over time as `v-for` is going to become the go-to directive and will help you
    achieve complex requirements with elegant code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue the development of `SocialPostComments.vue` file and utilize
    `v-for` directive to display the different comments for a specific post.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps required for us to use a `v-for` directive are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Get access to a variable or property that is an object or array. In our case,
    it is available as a property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the HTML for the first element. This helps to speed up the HTML development.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the list to use `v-for` and automatically create duplicate entries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first step is already set for us in the `SocialPostComments.vue` file as
    an array property using `defineProps()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to create the HTML that we want to display. As mentioned
    previously, we are going to hardcode the first entry of the array by accessing
    it using the array syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code in which we hardcoded the first comment, may seem irrelevant,
    but in more complex development, creating `v-for` this way will save you lots
    of time. I use this process of rendering just one entry of the `v-for` list to
    focus on the design and development of the HTML. When the list element if fully
    designed I then move to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, it is time to implement our `v-for` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will render our `<div>` element as many times as the length
    of our array.
  prefs: []
  type: TYPE_NORMAL
- en: Did you know?
  prefs: []
  type: TYPE_NORMAL
- en: The body of a `v-for` directive can also be used to load other Vue components.
    This allows you to abstract complex code into its own components and make your
    application cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move to our next chapter, we should point out that `v-for` can accept
    multiple elements and not just a single element as shown previously. To show this
    in real life, we are going to add a heading to each of the comments by using the
    `index` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows two more additions.
  prefs: []
  type: TYPE_NORMAL
- en: First, we exposed the index of the array by using the `(comment, index)` syntax.
    Then we improved the HTML contained in our `v-for` loop by replacing a simple
    string with a multi-element structure.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter exposed you to the first Vue directives and started to add some
    magic to your HTML.
  prefs: []
  type: TYPE_NORMAL
- en: In total, you learned how to accomplish three different use cases. First, we
    showed you how to apply HTML and text with `v-text` and `v-html`. This is very
    useful to bind dynamic variables to our component template. Then, we found out
    how to handle element visibility with `v-if` and `v-show`. We discovered that
    even if they both achieve the same result visually, they are actually different
    behind the scenes. `v-show` hides the element using CSS while `v-if` removes it
    from the DOM altogether. Finally, we finished the chapter with a look at `v-for`
    and how it can be used to iterate within a list and simplify our HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Your turn
  prefs: []
  type: TYPE_NORMAL
- en: It is your turn to do some practice for this section. There are multiple places
    to practice directives, but these are some specific suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Refactor `SocialPost.vue` to use `v-show` to display a post’s tags. (You
    need to add a new property for this.)
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Refactor TheWelcome.vue to use v-for to load our posts instead of the hardcoded
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Go back to your footer implementation and replace the hardcoded links using
    v-text and v-for.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we return to the logical part of our component and enhance
    our Refs and props by introducing **computed properties**. The second part of
    the chapter will introduce **methods** that will hold our component logic and
    help clean up the HTML of our components further.
  prefs: []
  type: TYPE_NORMAL
