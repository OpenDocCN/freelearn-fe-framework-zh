<html><head></head><body>
<div id="_idContainer013">
<h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor014"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/><span class="koboSpan" id="kobo.2.1">Scalable Front-End Architecture for Angular Applications</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Angular is a powerful and extensive framework for building web applications. </span><span class="koboSpan" id="kobo.3.2">According to the 2023 Stack Overflow developer survey, it is the fourth most used web technology after ReactJS, NodeJS, and jQuery among professional developers. </span><span class="koboSpan" id="kobo.3.3">Due to the structure and tools it provides, Angular is often chosen when building large web applications or enterprise solutions comprised of several applications </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">and libraries.</span></span></p>
<p><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.5.1">This book will guide you through the process of effectively using the Angular framework to develop and test applications of any size. </span><span class="koboSpan" id="kobo.5.2">You’ll start by learning about front-end architecture and setting up a scalable workspace with Nx that’s ready for hundreds of Angular applications. </span><span class="koboSpan" id="kobo.5.3">Next, you’ll explore the most powerful and newest features within the Angular framework. </span><span class="koboSpan" id="kobo.5.4">You’ll learn about reactive programming and state management using RxJS, Signals, and NgRx, and will be able to test Angular applications with Jest and Cypress. </span><span class="koboSpan" id="kobo.5.5">Upon completing this book, you’ll be able to effectively use the Angular framework and develop scalable, enterprise-ready Angular applications, utilizing all the tools Angular has to offer while implementing best practices and sound </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">design patterns.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, you will create your Angular workspace using Nx. </span><span class="koboSpan" id="kobo.7.2">You’ll start by learning what we mean by scalable front-end architecture and why it is essential to think about your architecture before you start writing code. </span><span class="koboSpan" id="kobo.7.3">You will also learn about different patterns in front-end architecture and what to consider when building enterprise-ready solutions </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">from scratch.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">Lastly, you will explore and use Nx, the build tool that allows you to create scalable Angular monorepos. </span><span class="koboSpan" id="kobo.9.2">By the end of this chapter, you will understand crucial aspects of front-end architecture and have your own Nx monorepo for Angular, ready to handle hundreds of </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">applications easily.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">This chapter will cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Understanding scalable </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">front-end applications</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Different approaches to scalable </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">front-end architecture</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">What is Nx and why should you </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">use it?</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Setting up a scalable </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">Angular workspace</span></span></li>
</ul>
<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">By the end of this chapter, we will create an Nx monorepo with an Angular application and library in it. </span><span class="koboSpan" id="kobo.22.2">To follow along, you’ll need to install some tools. </span><span class="koboSpan" id="kobo.22.3">Note that we will only use freely </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">available tools.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">You will require </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.26.1">Visual Studio Code</span></strong><span class="koboSpan" id="kobo.27.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.28.1">VS Code</span></strong><span class="koboSpan" id="kobo.29.1">) as your </span><strong class="bold"><span class="koboSpan" id="kobo.30.1">integrated development </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.31.1">environment</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.32.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.33.1">IDE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.35.1">Chrome </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">web browser</span></span></li>
<li><span class="koboSpan" id="kobo.37.1">Angular 17.1 </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">or higher</span></span></li>
<li><span class="koboSpan" id="kobo.39.1">NodeJS version v20.11.0 </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">or higher</span></span></li>
<li><span class="koboSpan" id="kobo.41.1">TypeScript version 5.3.3 </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">or higher</span></span></li>
<li><span class="koboSpan" id="kobo.43.1">Nx version v18.0.7 </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">or higher</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.45.1">Throughout this book, we will use Angular 17.1, NodeJS 20.11.0, TypeScript 5.3.3, and </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">Nx 18.0.7.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">The GitHub repository for this book is available </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">at </span></span><a href="https://github.com/PacktPublishing/Effective-Angular"><span class="No-Break"><span class="koboSpan" id="kobo.49.1">https://github.com/PacktPublishing/Effective-Angular</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.50.1">.</span></span></p>
<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.51.1">Understanding scalable front-end applications</span></h1>
<p><span class="koboSpan" id="kobo.52.1">Modern web</span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.53.1"> applications are constantly getting bigger and more complex. </span><span class="koboSpan" id="kobo.53.2">Because of this, developing scalable front-end applications is more critical than ever. </span><span class="koboSpan" id="kobo.53.3">To create scalable front-end applications, we need to understand what scalability means in the context of a </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">front-end application.</span></span></p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.55.1">What is scalability?</span></h2>
<p><span class="koboSpan" id="kobo.56.1">The first thing that </span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.57.1">might come to mind when you hear the term </span><strong class="bold"><span class="koboSpan" id="kobo.58.1">scalability</span></strong><span class="koboSpan" id="kobo.59.1"> is handling more traffic. </span><span class="koboSpan" id="kobo.59.2">However, in the context of front-end applications, when talking about scalability, we mostly mean the scalability of the code base. </span><span class="koboSpan" id="kobo.59.3">Or, more concisely, the code is easy to extend, and modules or micro front-ends can be added to the software without much work. </span><span class="koboSpan" id="kobo.59.4">Components and libraries are reusable; the code is easy to maintain, test, and debug, even when the application grows. </span><span class="koboSpan" id="kobo.59.5">You can work with different teams on separate parts of the application, and onboarding new teams that write similar code is easy to achieve and enforce. </span><span class="koboSpan" id="kobo.59.6">The application has good performance and small bundle sizes. </span><span class="koboSpan" id="kobo.59.7">Compile and build times remain low, and deployment can be done swiftly to different staging environments </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">if needed.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">To achieve these feats within your front-end applications, you must create a good architecture, a set of tools, and rules everyone can adhere to. </span><span class="koboSpan" id="kobo.61.2">Your architecture will include elements such as your repository type, folder structure, architectural patterns, design patterns, a programming language, framework, and tools for building, testing, linting, and deploying your application. </span><span class="koboSpan" id="kobo.61.3">Making the right decisions for each part of your architecture helps with creating scalable applications that are easy to maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">and extend.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">When making architectural decisions, you should aim to create a fast, loosely coupled, testable system. </span><span class="koboSpan" id="kobo.63.2">You want to avoid direct dependencies between different parts of your system so that you don’t get stuck and need to refactor the entire application when the business </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">introduces changes.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">With this brief introduction to what a scalable front-end application is, let’s understand the importance of a good </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">front-end architecture.</span></span></p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.67.1">Why is front-end architecture important?</span></h2>
<p><span class="koboSpan" id="kobo.68.1">Good architecture is</span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.69.1"> essential to maintain a good workflow for the developers working on the software and makes it easy for new teams and team members to join. </span><span class="koboSpan" id="kobo.69.2">If developers spend much time refactoring or waiting for builds or tests to complete, they wander off and do less </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">productive things.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">With good architecture in place, the code base remains manageable, even when your applications grow. </span><span class="koboSpan" id="kobo.71.2">Without good architecture, the code becomes messy and hard to debug or extend. </span><span class="koboSpan" id="kobo.71.3">As time progresses, such problems will pile up, and developers will be wasting more time on bugs and refactoring than creating new features, especially in large enterprise solutions where business needs are constantly changing. </span><span class="koboSpan" id="kobo.71.4">Before you know it, you will have a web of dependencies, and adding simple things will become </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">very time-consuming.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">Suppose you’re building an application for employee scheduling that includes a calendar component. </span><span class="koboSpan" id="kobo.73.2">You want to avoid tight coupling between the calendar and scheduling applications. </span><span class="koboSpan" id="kobo.73.3">When management lets you know the company is adding another application – let’s say a project management tool that also includes a calendar – you don’t want to redo the entire calendar component and scheduling application because the two are </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">tightly coupled.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">The following figure shows </span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.76.1">the development process with and without architecture. </span><span class="koboSpan" id="kobo.76.2">Without architecture, you start fast, but in the end, you are crawling. </span><span class="koboSpan" id="kobo.76.3">With architecture, you will have a consistent and predictable </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">work pace:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer008">
<span class="koboSpan" id="kobo.78.1"><img alt="Figure 1.1: Development speed" src="image/B21625_01_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.79.1">Figure 1.1: Development speed</span></p>
<p><span class="koboSpan" id="kobo.80.1">Now that you understand what we mean by scalable front-end applications and why having good architecture is essential to achieve them, we will dive into some approaches to scaling front-end applications and learn about their advantages </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">and trade-offs.</span></span></p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.82.1">Different approaches to scaling front-end applications</span></h1>
<p><span class="koboSpan" id="kobo.83.1">When it comes to </span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.84.1">architecting software, it’s essential to think of what you are building, what it can grow into, what the context is, and who will work on it. </span><span class="koboSpan" id="kobo.84.2">Depending on these parameters, you’ll want to create an architecture that’s flexible enough to grow and adapt without overengineering it, making things more complex and time-consuming </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">than needed.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">For example, if you’re building a simple website for a small family-owned business, you don’t need elaborate architecture and complex design patterns; this will make things more complex and time-consuming than they need to be. </span><span class="koboSpan" id="kobo.86.2">The needs for the website will probably stay mostly the same, and the code base will remain small and manageable. </span><span class="koboSpan" id="kobo.86.3">But when you’re building enterprise software comprised of multiple applications, the needs and utility of those applications will change quite a bit, and you’ll want to ensure that the software is set up </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">for that.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">In this section, you will learn about different architectural choices so that you can ensure you don’t over or under-engineer your front-end applications. </span><span class="koboSpan" id="kobo.88.2">You will learn about different repository structures and architectural patterns that are commonly used within Angular applications. </span><span class="koboSpan" id="kobo.88.3">Without further ado, let’s learn about the differences between mono and </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">poly repositories.</span></span></p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.90.1">Monorepo or polyrepo</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.91.1">Monorepo</span></strong><span class="koboSpan" id="kobo.92.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.93.1">polyrepo</span></strong><span class="koboSpan" id="kobo.94.1"> are </span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.95.1">two options for storing code within a source control</span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.96.1"> application such as GitHub. </span><span class="koboSpan" id="kobo.96.2">If you create a new repository for each project or application, it’s called a polyrepo or multi-repos structure. </span><span class="koboSpan" id="kobo.96.3">Meanwhile, when all applications are in one large repository, it’s called a monorepo structure. </span><span class="koboSpan" id="kobo.96.4">For large companies, a monorepo can easily contain hundreds </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">of applications.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">What option should you pick when developing a large front-end environment? </span><span class="koboSpan" id="kobo.98.2">Let’s start exploring the advantages and disadvantages of </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">both solutions.</span></span></p>
<h3><span class="koboSpan" id="kobo.100.1">Advantages of monorepos</span></h3>
<p><span class="koboSpan" id="kobo.101.1">Some of the key advantages</span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.102.1"> of monorepos are </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.104.1">Easy code sharing</span></strong><span class="koboSpan" id="kobo.105.1">: Monorepos</span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.106.1"> make it easy to share code among different projects and teams. </span><span class="koboSpan" id="kobo.106.2">You have the code of all projects in one directory, so inspecting or reusing code from another project and sharing things in libraries is simple. </span><span class="koboSpan" id="kobo.106.3">This helps prevent duplicate code, gives you inspiration and guidance on solving similar issues, and allows you to quickly check if a bug originates in your code or the implementation of </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">a library.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.108.1">Uniformity among different applications</span></strong><span class="koboSpan" id="kobo.109.1">: Because all code resides in one repository, enforcing uniformity among different applications is easier. </span><span class="koboSpan" id="kobo.109.2">You can ensure that the same tooling is used, code conventions and best practices are applied, and all applications are tested similarly. </span><span class="koboSpan" id="kobo.109.3">Also, testing the entire system is easier with </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">a monorepo.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.111.1">No versioning conflicts</span></strong><span class="koboSpan" id="kobo.112.1">: In a monorepo, dependencies commonly share the same version among all applications. </span><span class="koboSpan" id="kobo.112.2">This ensures that no versioning conflicts occur and implementations are equal in all applications. </span><span class="koboSpan" id="kobo.112.3">Furthermore, it ensures that applications that are not actively developed still get regular updates for </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">their dependencies.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.114.1">Cross-project refactoring</span></strong><span class="koboSpan" id="kobo.115.1">: If you want to refactor something that occurs in many applications, you can do it in one go for all applications or efficiently run scripts to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">these actions.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.117.1">Quick code movement and debugging</span></strong><span class="koboSpan" id="kobo.118.1">: Code can quickly be moved from one project to another, and when you encounter a bug within a library, you can fix the bug without holdups and continue </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">your work.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.120.1">Shared commit timeline</span></strong><span class="koboSpan" id="kobo.121.1">: Lastly, a monorepo </span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.122.1">has one shared commit timeline. </span><span class="koboSpan" id="kobo.122.2">This makes it safe to create atomic commits with changes in multiple applications. </span><span class="koboSpan" id="kobo.122.3">This happens because if anything goes wrong, you can always revert to a common state of all applications through the </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">commit timeline.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.124.1">Regardless of these advantages, monorepos have some shortcomings too. </span><span class="koboSpan" id="kobo.124.2">We’ll look at them in detail in the </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">following section.</span></span></p>
<h3><span class="koboSpan" id="kobo.126.1">Disadvantages of monorepos</span></h3>
<p><span class="koboSpan" id="kobo.127.1">Some of the disadvantages</span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.128.1"> of monorepos are </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.130.1">Large folder structure</span></strong><span class="koboSpan" id="kobo.131.1">: A monorepo can be daunting because all code and libraries live in one large solution. </span><span class="koboSpan" id="kobo.131.2">If you have yet to work with a monorepo, this might take some time to get used to. </span><span class="koboSpan" id="kobo.131.3">Because it’s so easy to use code from other projects, you need to be extra careful not to create unwanted dependencies </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">between applications.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.133.1">Complex package updates</span></strong><span class="koboSpan" id="kobo.134.1">: Updating packages and dependencies in a monorepo can be complicated because, often, all projects need to update </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">at once.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.136.1">Breaking changes</span></strong><span class="koboSpan" id="kobo.137.1">: Because there are no different versions, when you make changes in libraries, you can break other applications without </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">noticing it.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.139.1">Slow build times</span></strong><span class="koboSpan" id="kobo.140.1">: In a monorepo, building and testing can become time-consuming if not </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">managed correctly.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.142.1">Challenges in deployment</span></strong><span class="koboSpan" id="kobo.143.1">: Deploying applications modularly can be more challenging compared to polyrepos, where everything is separated and modular </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">by nature.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.145.1">Most disadvantages can be mitigated with the right tools. </span><span class="koboSpan" id="kobo.145.2">For monorepos comprised of Angular applications, you can use Nx, giving you everything to handle a monorepo without these disadvantages. </span><span class="koboSpan" id="kobo.145.3">In this book, we will work with a monorepo </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">and Nx.</span></span></p>
<p><span class="koboSpan" id="kobo.147.1">Now, let’s move on to the advantages and disadvantages </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">of polyrepos.</span></span></p>
<h3><span class="koboSpan" id="kobo.149.1">Advantages of polyrepos</span></h3>
<p><span class="koboSpan" id="kobo.150.1">The key advantages of </span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.151.1">polyrepos are </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.153.1">A higher level of isolation between applications</span></strong><span class="koboSpan" id="kobo.154.1">: The most apparent advantage of a polyrepo is higher levels of isolation between your applications. </span><span class="koboSpan" id="kobo.154.2">Each project has a repository and developers can do whatever they want within that repository without affecting other projects </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">too much.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.156.1">Flexibility with dependency management</span></strong><span class="koboSpan" id="kobo.157.1">: When using a polyrepo, each project can manage versions of its dependencies on its own. </span><span class="koboSpan" id="kobo.157.2">This gives the teams working on the projects more freedom when updating dependencies and offers </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">more stability.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.159.1">Individual tooling</span></strong><span class="koboSpan" id="kobo.160.1">: With a polyrepo, there is more flexibility for using different tools and </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">programming languages.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.162.1">Easy to manage</span></strong><span class="koboSpan" id="kobo.163.1">: A polyrepo is generally easier to manage, especially for smaller teams. </span><span class="koboSpan" id="kobo.163.2">There is little code in each repository compared to a monorepo, so there are fewer things you can affect with </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">your changes.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.165.1">Straightforward modular deployment</span></strong><span class="koboSpan" id="kobo.166.1">: Deploying your applications modularly is more </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">straightforward.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.168.1">In-line with a micro front-end architecture</span></strong><span class="koboSpan" id="kobo.169.1">: Lastly, if you’re developing with a micro front-end architecture, using a polyrepo might feel more in tune with the rest of your architecture. </span><span class="koboSpan" id="kobo.169.2">However, micro front-ends can be achieved with both a </span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.170.1">monorepo and </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">polyrepo structure.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.172.1">Before you pick between a monorepo or polyrepo structure, you must also consider the drawbacks of polyrepos. </span><span class="koboSpan" id="kobo.172.2">These are described in the </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">next section.</span></span></p>
<h3><span class="koboSpan" id="kobo.174.1">Disadvantages of polyrepos</span></h3>
<p><span class="koboSpan" id="kobo.175.1">Some common</span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.176.1"> disadvantages of polyrepos are </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.178.1">Difficulties in code sharing</span></strong><span class="koboSpan" id="kobo.179.1">: First, because code resides in isolation, it is harder to share code between applications. </span><span class="koboSpan" id="kobo.179.2">This can result in different implementations for the same problem or duplicate code in various projects. </span><span class="koboSpan" id="kobo.179.3">Teams will often create their own solution instead of contributing to a library that solves </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">shared problems.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.181.1">Boundaries between projects and libraries</span></strong><span class="koboSpan" id="kobo.182.1">: When you depend on a library that resides in another repository, and you run into a bug, it will be more time-consuming to fix the issue. </span><span class="koboSpan" id="kobo.182.2">Often, you need to wait for other teams to fix the bug in the library and deploy a new version before you </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">can continue.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.184.1">Challenges when testing multiple repositories</span></strong><span class="koboSpan" id="kobo.185.1">: Testing applications can become more challenging. </span><span class="koboSpan" id="kobo.185.2">Predominantly when applications consist of different modules that reside in different repositories, testing the entire system can </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">be difficult.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.187.1">Difficulties in creating CI/CD pipelines and deployments</span></strong><span class="koboSpan" id="kobo.188.1">: Creating CI/CD pipelines and deployments of the whole system might become more challenging as you need multiple repositories to complete </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">the tasks.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.190.1">Dependency conflicts</span></strong><span class="koboSpan" id="kobo.191.1">: Lastly, you can run into dependency conflicts. </span><span class="koboSpan" id="kobo.191.2">Different applications need to work together in production and can depend on similar dependencies. </span><span class="koboSpan" id="kobo.191.3">You can encounter compatibility issues when these applications use</span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.192.1"> different versions of the </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">set dependency.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.194.1">In this section, you learned about the advantages and disadvantages of storing your code in a monorepo or polyrepo. </span><span class="koboSpan" id="kobo.194.2">Next, you will learn about different architectural patterns that are commonly used with </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">Angular applications.</span></span></p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.196.1">Architectural patterns for Angular applications</span></h2>
<p><span class="koboSpan" id="kobo.197.1">Architectural patterns</span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.198.1"> focus on how you structure your code and </span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.199.1">provide rules for abstracting business logic away from specific implementations. </span><span class="koboSpan" id="kobo.199.2">Architectural patterns are an extensive topic and there are entire books dedicated to it; so, it will be impossible to cover everything in this section. </span><span class="koboSpan" id="kobo.199.3">Still, we will briefly cover some of the most common architectural patterns that are used with Angular and Nx. </span><span class="koboSpan" id="kobo.199.4">In </span><a href="B21625_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.200.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.201.1">, we will dive into design patterns while focusing on code implementations instead of providing a high-level view of </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">Now, let’s dive into some architectural patterns and learn what they try to achieve, how they try to achieve it, and what their advantages and </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">disadvantages are.</span></span></p>
<h3><span class="koboSpan" id="kobo.205.1">Common architectural patterns in Angular applications</span></h3>
<p><span class="koboSpan" id="kobo.206.1">Most </span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.207.1">architectural patterns try to accomplish the same at their core, only with little nuances and different terminologies. </span><span class="koboSpan" id="kobo.207.2">Regarding architectural patterns for Angular applications, they try to separate domain and business logic from implementations and the view. </span><span class="koboSpan" id="kobo.207.3">Doing so gives you a loosely coupled system that is easy to test, change, and expand without creating </span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.208.1">dependencies in the wrong places. </span><span class="koboSpan" id="kobo.208.2">In this section, we will cover the </span><strong class="bold"><span class="koboSpan" id="kobo.209.1">Model-View-Controller</span></strong><span class="koboSpan" id="kobo.210.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.211.1">MVC</span></strong><span class="koboSpan" id="kobo.212.1">), hexagonal architecture, and layered architecture. </span><span class="koboSpan" id="kobo.212.2">These three patterns are some of the most commonly used architectural patterns for Angular applications. </span><span class="koboSpan" id="kobo.212.3">Other noteworthy patterns are </span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.213.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.214.1">Model-View View-Model</span></strong><span class="koboSpan" id="kobo.215.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.216.1">MVVM</span></strong><span class="koboSpan" id="kobo.217.1">), union architecture, and </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">clean architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">Without further ado, let’s learn about the MVC pattern and how it can be used within </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">Angular applications.</span></span></p>
<h4><span class="koboSpan" id="kobo.221.1">MVC in Angular applications</span></h4>
<p><strong class="bold"><span class="koboSpan" id="kobo.222.1">MVC</span></strong><span class="koboSpan" id="kobo.223.1"> is one of</span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.224.1"> the most commonly used architectural patterns in the world of software development. </span><span class="koboSpan" id="kobo.224.2">The pattern was </span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.225.1">first used in the back-end but is now also used for front-end applications, or at least something resembling the MVC pattern. </span><span class="koboSpan" id="kobo.225.2">The MVC pattern is often used for Angular applications because it fits well </span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.226.1">with the tools provided by the framework. </span><span class="koboSpan" id="kobo.226.2">As the name implies, MVC</span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.227.1"> consists of three</span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.228.1"> parts – the </span><strong class="bold"><span class="koboSpan" id="kobo.229.1">model</span></strong><span class="koboSpan" id="kobo.230.1">, the </span><strong class="bold"><span class="koboSpan" id="kobo.231.1">view</span></strong><span class="koboSpan" id="kobo.232.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">the </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.234.1">controller</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.236.1">The model declares the data models and handles business and </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">data-related logic.</span></span></li>
<li><span class="koboSpan" id="kobo.238.1">The view displays the current state of the model to </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">the user.</span></span></li>
<li><span class="koboSpan" id="kobo.240.1">The controller acts as a bridge between the view and the model. </span><span class="koboSpan" id="kobo.240.2">The controller passes the user input to the model so that the model can perform actions and update accordingly, after which the controller returns the updated values to </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">the view.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.242.1">If we translate this pattern into an Angular application, the model would be a service handling the data and data models. </span><span class="koboSpan" id="kobo.242.2">The view would be the HTML template. </span><span class="koboSpan" id="kobo.242.3">Finally, the controller would be the TypeScript file behind the HTML file, commonly named the component class. </span><span class="koboSpan" id="kobo.242.4">A better implementation is considering the component class as part of the view and having an extra facade service (an additional abstraction layer creating a simple interface and communication layer between the view and business or state-related logic of your application; we will discuss the facade pattern in more detail in </span><a href="B21625_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.243.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.244.1">) between the model service and the view acting as </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">the controller.</span></span></p>
<p><span class="koboSpan" id="kobo.246.1">If you keep true to the</span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.247.1"> MVC architecture’s original implementation, the model directly gives the updated values to the view. </span><span class="koboSpan" id="kobo.247.2">To achieve this, in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.248.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.249.1">.2</span></em><span class="koboSpan" id="kobo.250.1">, we would eliminate </span><em class="italic"><span class="koboSpan" id="kobo.251.1">steps 4</span></em><span class="koboSpan" id="kobo.252.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.253.1">5</span></em><span class="koboSpan" id="kobo.254.1"> and would then go to the view instead of the controller. </span><span class="koboSpan" id="kobo.254.2">In Angular, this is sort of the case when using the component class as a controller, and it results in a tight coupling between the business logic and the component classes. </span><span class="koboSpan" id="kobo.254.3">Because of that, I prefer to add a separate facade service that acts as a controller to fully separate the component classes from the business and state layers of my application. </span><span class="koboSpan" id="kobo.254.4">By separating the components from the state </span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.255.1">and business logic, you end up with a loose coupling, making it easier to change implementations throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">your application:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer009">
<span class="koboSpan" id="kobo.257.1"><img alt="Figure 1.2: MVC pattern" src="image/B21625_01_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.258.1">Figure 1.2: MVC pattern</span></p>
<p><span class="koboSpan" id="kobo.259.1">Now that </span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.260.1">you know what the</span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.261.1"> MVC pattern entails and how you can implement it within your Angular applications, let’s learn about the next common architectural pattern: the </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">Hexagonal architecture.</span></span></p>
<h4><span class="koboSpan" id="kobo.263.1">The hexagonal architecture pattern in Angular applications</span></h4>
<p><span class="koboSpan" id="kobo.264.1">Hexagonal architecture</span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.265.1"> is relatively new </span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.266.1">compared to MVC and some other architectural patterns, such as layered architecture, MVVC, and MVP. </span><span class="koboSpan" id="kobo.266.2">The hexagonal architecture was introduced in 2005, and people have only started implementing it in Angular applications in the last couple of years. </span><span class="koboSpan" id="kobo.266.3">It gained popularity because </span><strong class="bold"><span class="koboSpan" id="kobo.267.1">domain-driven development</span></strong><span class="koboSpan" id="kobo.268.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.269.1">DDD</span></strong><span class="koboSpan" id="kobo.270.1">) became </span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.271.1">a hot topic, and hexagonal architecture is very well suited to combine with DDD. </span><span class="koboSpan" id="kobo.271.2">The main principle of hexagonal architecture is to separate the core application logic away from the UI and data implementation through ports and adapters. </span><span class="koboSpan" id="kobo.271.3">Because of that, the architecture is also commonly referred to as the </span><em class="italic"><span class="koboSpan" id="kobo.272.1">ports and adapter architecture</span></em><span class="koboSpan" id="kobo.273.1">. </span><span class="koboSpan" id="kobo.273.2">But I hear you thinking, what are ports </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">and adapters?</span></span></p>
<p><span class="koboSpan" id="kobo.275.1">In simple terms, </span><strong class="bold"><span class="koboSpan" id="kobo.276.1">ports</span></strong><span class="koboSpan" id="kobo.277.1"> are</span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.278.1"> interfaces (or abstract classes) that separate your core logic from the UI and code implementations. </span><span class="koboSpan" id="kobo.278.2">These interfaces dictate how the UI and code implementations can communicate with your application core. </span><span class="koboSpan" id="kobo.278.3">The </span><strong class="bold"><span class="koboSpan" id="kobo.279.1">adapters</span></strong><span class="koboSpan" id="kobo.280.1"> are the </span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.281.1">UI and code implementations that connect with your application core through the ports. </span><span class="koboSpan" id="kobo.281.2">In hexagonal architecture, ports and adaptors come in two types, UI and data-related ports and adapters – in other terms, primary and secondary adapters and</span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.282.1"> ports. </span><span class="koboSpan" id="kobo.282.2">This concept is</span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.283.1"> illustrated in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.284.1">Figure 1</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.285.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<span class="koboSpan" id="kobo.287.1"><img alt="Figure 1.3: Hexagonal architecture pattern" src="image/B21625_01_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.288.1">Figure 1.3: Hexagonal architecture pattern</span></p>
<p><span class="koboSpan" id="kobo.289.1">When implementing </span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.290.1">hexagonal architecture, you will have a set of ports and adapters for each domain within your application. </span><span class="koboSpan" id="kobo.290.2">I like to use a facade service between the port interfaces and adapters for more</span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.291.1"> abstraction between the UI, implementations, and application core. </span><span class="koboSpan" id="kobo.291.2">When using a facade service, the facade can be considered as the port itself. </span><span class="koboSpan" id="kobo.291.3">Just make sure the facade implements an interface so that there is a fixed set of rules for communication with the core </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">and adapters.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">Because ports define a fixed set of rules for communicating with your application core, you can easily change implementations when business requirements change. </span><span class="koboSpan" id="kobo.293.2">You can swap UI components without touching your business logic or data implementations, and you can change how you persist or fetch your data without touching your views or application core. </span><span class="koboSpan" id="kobo.293.3">The only thing you need to do is ensure your new implementation can connect to the same interface your ports are using to connect everything. </span><span class="koboSpan" id="kobo.293.4">This approach offers excellent flexibility and a loosely </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">coupled system.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">To clarify things, I want to go over </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.296.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.297.1">.3</span></em><span class="koboSpan" id="kobo.298.1"> and translate it into an Angular application. </span><span class="koboSpan" id="kobo.298.2">We will go from left to right. </span><span class="koboSpan" id="kobo.298.3">On the far left, we have the primary adapters. </span><span class="koboSpan" id="kobo.298.4">Everything the user faces, or triggers, is considered a primary adapter: components, directives, resolvers, guards, and event listeners. </span><span class="koboSpan" id="kobo.298.5">One step to the right, we will find the primary ports. </span><span class="koboSpan" id="kobo.298.6">These regular TypeScript interfaces (or facade services) dictate how the UI layer communicates with the application core. </span><span class="koboSpan" id="kobo.298.7">Our application core is in the middle, where we access state management and define business and application logic in Angular services. </span><span class="koboSpan" id="kobo.298.8">On the right of the application core, we have our secondary ports. </span><span class="koboSpan" id="kobo.298.9">These ports dictate how the application code communicates with HTTP services, state management, in-memory persistence, event dispatchers, and other data or API-related logic. </span><span class="koboSpan" id="kobo.298.10">Like the primary ports, the secondary ports are regular TypeScript interfaces (or facade services). </span><span class="koboSpan" id="kobo.298.11">On the far right, we have our secondary adapters. </span><span class="koboSpan" id="kobo.298.12">The secondary adapters implement our HTTP services, local </span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.299.1">storage </span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.300.1">persistence, state management, and </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">event dispatchers.</span></span></p>
<p><span class="koboSpan" id="kobo.302.1">Now that you know what hexagonal architecture is and how you can implement it within your Angular applications, let’s take a look at the third and final architectural pattern we will discuss: </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">layered architecture.</span></span></p>
<h4><span class="koboSpan" id="kobo.304.1">The layered architecture pattern in Angular applications</span></h4>
<p><span class="koboSpan" id="kobo.305.1">As the name implies, the </span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.306.1">layered architecture</span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.307.1"> pattern uses different layers to separate concerns. </span><span class="koboSpan" id="kobo.307.2">For each application section, you create a layer in the architecture that sits on top of another layer. </span><span class="koboSpan" id="kobo.307.3">When you implement the layered architecture pattern in your Angular applications, you should have at least three (main) layers: the core layer, the abstraction layer, and the presentation layer. </span><span class="koboSpan" id="kobo.307.4">Within these top-level layers, you can have additional sub-layers or sibling elements. </span><span class="koboSpan" id="kobo.307.5">If your application architecture needs more layers, you can add them </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">as needed.</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">The most important thing with layered architecture is that each layer can only communicate with the layer above and below itself; the rest of the layers in the chain are off limits. </span><span class="koboSpan" id="kobo.309.2">Another essential feat is that events and actions flow upwards, and data flows downwards. </span><span class="koboSpan" id="kobo.309.3">The user triggers an event or performs an action in the presentation layer. </span><span class="koboSpan" id="kobo.309.4">This layer notifies the abstraction layer of the action and the corresponding changes. </span><span class="koboSpan" id="kobo.309.5">The abstraction layer sends these actions and changes to the core layer, where the business logic is performed and the data changes persist. </span><span class="koboSpan" id="kobo.309.6">When the core layer has performed the application logic and persisted the changes, the data will flow back from the core layer through the abstraction layer in the presentation layer, where the view is updated for </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">the user:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<span class="koboSpan" id="kobo.311.1"><img alt="Figure 1.4: Layered architecture pattern" src="image/B21625_01_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.312.1">Figure 1.4: Layered architecture pattern</span></p>
<p><span class="koboSpan" id="kobo.313.1">Throughout this book, we </span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.314.1">will use a layered architecture resembling what’s shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.315.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.316.1">.4</span></em><span class="koboSpan" id="kobo.317.1">, with the presentation layer containing dumb, wrapper, and smart components. </span><span class="koboSpan" id="kobo.317.2">Dumb components only have component inputs to receive data and outputs to alert the parent components something has changed. </span><span class="koboSpan" id="kobo.317.3">Wrapper components are also dumb, but they are used to group multiple components and provide a reusable layout or animation. </span><span class="koboSpan" id="kobo.317.4">Even though a wrapper container can wrap around dumb components, they are the same for the flow of data and separation of dependencies, which is why they are placed next to each other in the architecture design. </span><span class="koboSpan" id="kobo.317.5">On top of the dumb components, we have smart components. </span><span class="koboSpan" id="kobo.317.6">These components are, generally </span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.318.1">speaking, specific business use cases or pages, and they inject facade services and implement component logic </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">and state.</span></span></p>
<p><span class="koboSpan" id="kobo.320.1">The next main layer in our architecture is the abstraction layer, where we have facade services. </span><span class="koboSpan" id="kobo.320.2">These facade services are regular Angular services that implement the facade design pattern. </span><span class="koboSpan" id="kobo.320.3">These facade services provide additional abstraction and are used as a bridge between our smart components and the core layer of </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">Our last </span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.323.1">major layer is the core </span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.324.1">layer, where the global state management, business and application logic, and HTTP services reside. </span><span class="koboSpan" id="kobo.324.2">Our HTTP services layer lies on top of the state management and business logic layers. </span><span class="koboSpan" id="kobo.324.3">We have separate services that do nothing but fetch data and pass it to our other core layers; the lower core layers never fetch data directly, so we have an additional abstraction layer and have better separation </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">of concerns.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">Now that you know about the layered, hexagonal, and MVC architectural patterns, let’s move on and briefly learn about the advantages and disadvantages </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">of each</span></span></p>
<h3><span class="koboSpan" id="kobo.328.1">Comparing the architectural patterns</span></h3>
<p><span class="koboSpan" id="kobo.329.1">All three patterns we </span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.330.1">discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.331.1">Common architectural patterns in Angular applications</span></em><span class="koboSpan" id="kobo.332.1"> section separate the business logic from the implementations and presentation code. </span><span class="koboSpan" id="kobo.332.2">They all provide abstraction layers but have different approaches to creating these layers. </span><span class="koboSpan" id="kobo.332.3">First, the MVC pattern might seem the simplest to implement, but you can have too many dependencies and implementations in your component classes if you don’t add facade services, especially if you let the model part of MVC directly communicate with the view. </span><span class="koboSpan" id="kobo.332.4">Not only will this tightly couple your view with your business logic, but it can also trigger extensive DOM updates. </span><span class="koboSpan" id="kobo.332.5">Changing implementations can become hard, and unit testing needs a lot </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">of mocking.</span></span></p>
<p><span class="koboSpan" id="kobo.334.1">Next, we have hexagonal architecture. </span><span class="koboSpan" id="kobo.334.2">I like this architecture, but it introduces a lot of boilerplate code and can feel complex to implement, making it not the right fit if you have a lot of junior developers on your team. </span><span class="koboSpan" id="kobo.334.3">Nonetheless, the significant advantage of hexagonal architecture is that you can easily change implementations once everything has been set up. </span><span class="koboSpan" id="kobo.334.4">Unit testing the code also becomes straightforward because everything is separated into ports </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">and adapters.</span></span></p>
<p><span class="koboSpan" id="kobo.336.1">Lastly, we have the layered architecture. </span><span class="koboSpan" id="kobo.336.2">This one offers the best of both the MVC and hexagonal architectures: we have clear divisions and good abstraction for our core, implementations, and view. </span><span class="koboSpan" id="kobo.336.3">Adding more layers to your architecture is simple, and the rules are easy to understand, making it a good solution for teams with developers of different experience levels. </span><span class="koboSpan" id="kobo.336.4">Because of good separation and abstractions, you can simply change implementations, and unit testing </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">remains easy.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">You now know</span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.339.1"> what the MVC, hexagonal, and layered architectures are, and you learned about the advantages and disadvantages of each implementation. </span><span class="koboSpan" id="kobo.339.2">In the next section, you’ll briefly learn what design patterns are and how they differ from </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">architectural patterns.</span></span></p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.341.1">Design patterns used within Angular applications</span></h2>
<p><span class="koboSpan" id="kobo.342.1">While architectural </span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.343.1">patterns focus on a high-level overview of how </span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.344.1">we segment and abstract our code, design patterns focus on how we implement things within our code. </span><span class="koboSpan" id="kobo.344.2">When developing Angular applications, we are already working with some design patterns out of the box. </span><span class="koboSpan" id="kobo.344.3">This is because Angular is a strongly opinionated framework with strong </span><strong class="bold"><span class="koboSpan" id="kobo.345.1">object-orientated programming</span></strong><span class="koboSpan" id="kobo.346.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.347.1">OOP</span></strong><span class="koboSpan" id="kobo.348.1">) principles at its core. </span><span class="koboSpan" id="kobo.348.2">Some design patterns</span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.349.1"> we use by default within Angular applications are the observable, dependency injection, decorator, component, and singleton patterns. </span><span class="koboSpan" id="kobo.349.2">These and other design patterns, such as the factory and inheritance patterns, are embedded in how the Angular framework works and should be used throughout your application when you use the framework correctly. </span><span class="koboSpan" id="kobo.349.3">Because these patterns are somewhat concealed within the tools and ways of working of the Angular framework, you might be using them without actually understanding how they work at their core. </span><span class="koboSpan" id="kobo.349.4">Besides these design patterns embedded within the Angular framework, you can improve your code by introducing even more design patterns. </span><span class="koboSpan" id="kobo.349.5">Some work very well in combination with Angular, such as the </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">facade pattern.</span></span></p>
<p><span class="koboSpan" id="kobo.351.1">As with architectural patterns, design patterns ensure that you adhere to specific rules when implementing your code, resulting in code that is easy to adjust and extend. </span><span class="koboSpan" id="kobo.351.2">They prevent you from making the wrong dependencies throughout your code and provide a structured and battle-tested way to approach common problems with software engineering. </span><span class="koboSpan" id="kobo.351.3">For now, I wanted to briefly explain design patterns and list some design patterns the Angular framework uses by default. </span><span class="koboSpan" id="kobo.351.4">In </span><a href="B21625_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.352.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.353.1">, you will learn about design patterns in more detail. </span><span class="koboSpan" id="kobo.353.2">You will learn about different patterns, when to use them, and how to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">them correctly.</span></span></p>
<p><span class="koboSpan" id="kobo.355.1">You now know what design patterns are and how they differ from architectural patterns. </span><span class="koboSpan" id="kobo.355.2">You’ve learned about some patterns that are used within Angular by design and that you can add more patterns to improve your code implementations throughout your code base. </span><span class="koboSpan" id="kobo.355.3">The next topic we will discuss is Nx, which makes structuring, creating, maintaining, and testing large Angular </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">monorepos easy.</span></span></p>
<h1 id="_idParaDest-25"><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.357.1">What is Nx and why should you use it?</span></h1>
<p><span class="koboSpan" id="kobo.358.1">In this section, you will learn what Nx is and why it’s such a fantastic tool for developing Angular applications at scale. </span><strong class="bold"><span class="koboSpan" id="kobo.359.1">Nx</span></strong><span class="koboSpan" id="kobo.360.1"> is</span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.361.1"> rapidly becoming the go-to tool for developing large monorepo front-end applications. </span><span class="koboSpan" id="kobo.361.2">So, what exactly is Nx and why should you </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">use it?</span></span></p>
<p><span class="koboSpan" id="kobo.363.1">Nx is a tool that helps you to speed up, streamline, and standardize your development, testing, build, and deployment process. </span><span class="koboSpan" id="kobo.363.2">The Nx tooling offers various features and integrations you can utilize during every stage of development. </span><span class="koboSpan" id="kobo.363.3">Nx was created so that you can adopt it incrementally by picking and choosing what you want to use or add to your current environment. </span><span class="koboSpan" id="kobo.363.4">At its core, Nx helps you with </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.365.1">Speeding up the build</span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.366.1"> and test times of </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">your applications.</span></span></li>
<li><span class="koboSpan" id="kobo.368.1">Managing dependencies and running tasks within </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">monorepo projects.</span></span></li>
<li><span class="koboSpan" id="kobo.370.1">Swiftly scaffolding new code snippets, applications, and libraries without needing to worry about configuring </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">build tools.</span></span></li>
<li><span class="koboSpan" id="kobo.372.1">Integrating new tools into the projects of your </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">monorepo workspace.</span></span></li>
<li><span class="koboSpan" id="kobo.374.1">Ensuring uniformity and consistency within the code of </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">different projects.</span></span></li>
<li><span class="koboSpan" id="kobo.376.1">Updating applications and tools through automated </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">code migration.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.378.1">In the preceding tasks, multiple tools, features, and options, such as a CLI, generators, and plugins, help you achieve your goals and streamline processes. </span><span class="koboSpan" id="kobo.378.2">The tools and features Nx has to offer are divided into different modules in </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">their ecosystem.</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">To start, you have</span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.381.1"> the Nx </span><strong class="bold"><span class="koboSpan" id="kobo.382.1">command-line interface</span></strong><span class="koboSpan" id="kobo.383.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.384.1">CLI</span></strong><span class="koboSpan" id="kobo.385.1">). </span><span class="koboSpan" id="kobo.385.2">Similar to the Angular CLI, it lets you run commands for tasks such as creating workspaces, scaffolding projects, testing projects, or serving and building. </span><span class="koboSpan" id="kobo.385.3">Next, the </span><strong class="bold"><span class="koboSpan" id="kobo.386.1">Nx package</span></strong><span class="koboSpan" id="kobo.387.1"> contains all </span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.388.1">the fundamental technologies Nx offers: task running, workspace analysis, build caching, scaffolding, and automated code migrations. </span><span class="koboSpan" id="kobo.388.2">Then, there are plugins, which are NPM packages that extend the fundamentals of Nx and can be created by the Nx community for various purposes, such as generating projects, integrating tools, and adding or updating libraries. </span><span class="koboSpan" id="kobo.388.3">Another element of Nx is its </span><strong class="bold"><span class="koboSpan" id="kobo.389.1">Devkit</span></strong><span class="koboSpan" id="kobo.390.1">, which </span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.391.1">can be used to build plugins to extend the Nx tooling to your specific needs. </span><span class="koboSpan" id="kobo.391.2">Nx also has something </span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.392.1">called </span><strong class="bold"><span class="koboSpan" id="kobo.393.1">Nx cloud</span></strong><span class="koboSpan" id="kobo.394.1">, which speeds up your CI with remote caching and distributed task executions, but this is outside the scope of this book. </span><span class="koboSpan" id="kobo.394.2">Lastly, we have </span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.395.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.396.1">Nx console</span></strong><span class="koboSpan" id="kobo.397.1">, an extension for VS Code, IntelliJ, and VIM, making it much easier to manage your Nx workspace and run </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">Nx commands.</span></span></p>
<p><span class="koboSpan" id="kobo.399.1">Now that you know what Nx does at its core, let’s examine it in more detail and see how it can help you build scalable monorepos for your </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">Angular applications.</span></span></p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.401.1">How Nx helps you build Angular monorepos that scale</span></h2>
<p><span class="koboSpan" id="kobo.402.1">Now that you understand </span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.403.1">what Nx is at its core, let’s dive deeper and explore how it helps you build, test, and standardize your Angular applications. </span><span class="koboSpan" id="kobo.403.2">We will begin with one of the main features Nx offers: speeding up tasks such as building, serving, </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">and testing.</span></span></p>
<h3><span class="koboSpan" id="kobo.405.1">Improving build times with computational caching and incremental builds</span></h3>
<p><span class="koboSpan" id="kobo.406.1">Typically, when </span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.407.1">we run tasks with the Angular CLI, such </span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.408.1">as </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">ng build</span></strong><span class="koboSpan" id="kobo.410.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">ng serve</span></strong><span class="koboSpan" id="kobo.412.1">, our entire application and all the libraries it depends on need to be </span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.413.1">compiled to complete the build or serve your application. </span><span class="koboSpan" id="kobo.413.2">This can become time-consuming as the application grows. </span><span class="koboSpan" id="kobo.413.3">The result is slow CI builds and developers waiting for the application to compile each time they want to start or test it. </span><span class="koboSpan" id="kobo.413.4">Nx helps to resolve these issues with incremental builds and </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">computational caching.</span></span></p>
<p><span class="koboSpan" id="kobo.415.1">With computational caching, Nx will check if anything has changed since the last time you ran a command. </span><span class="koboSpan" id="kobo.415.2">If nothing has changed or the build computation is equal to a previous cached run, Nx won’t rerun the command and instead take the results from its caching system. </span><span class="koboSpan" id="kobo.415.3">First, it will look at the local caching, and if you set up remote caching with Nx cloud, it will also check if it can find the same computational hash in the remote cache. </span><span class="koboSpan" id="kobo.415.4">If Nx cannot find the same computational hash, it will run the command and store the hash of the result in the </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">Nx cache.</span></span></p>
<p><span class="koboSpan" id="kobo.417.1">Besides computational caching, Nx helps speed up our build and compile times with incremental builds. </span><span class="koboSpan" id="kobo.417.2">When using incremental builds, we only build projects that have been changed since your last build. </span><span class="koboSpan" id="kobo.417.3">In a regular scenario, we build the application and all the libraries the application uses. </span><span class="koboSpan" id="kobo.417.4">As the application grows and depends on many libraries, it can become time-consuming and costly to rebuild everything each time you build the application. </span><span class="koboSpan" id="kobo.417.5">To use incremental builds, your libraries must be buildable so that Nx can cache the libraries and only build them if they changed since your last build. </span><span class="koboSpan" id="kobo.417.6">When you’re building smaller applications, you might not want buildable libraries with computational caching because making a library buildable has some overhead as well. </span><span class="koboSpan" id="kobo.417.7">When you create a</span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.418.1"> library in your Nx workspace, you can choose if you want it to be standard, buildable, or publishable. </span><span class="koboSpan" id="kobo.418.2">We will dive deeper into this topic in the </span><em class="italic"><span class="koboSpan" id="kobo.419.1">Structuring Angular applications and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.420.1">libraries</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.421.1"> section.</span></span></p>
<h3><span class="koboSpan" id="kobo.422.1">Running tasks effectively in a monorepo with Nx</span></h3>
<p><span class="koboSpan" id="kobo.423.1">Running</span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.424.1"> tasks, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">ng build</span></strong><span class="koboSpan" id="kobo.426.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">ng test</span></strong><span class="koboSpan" id="kobo.428.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">ng lint</span></strong><span class="koboSpan" id="kobo.430.1">, with the Angular CLI in a single </span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.431.1">Angular </span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.432.1">project is </span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.433.1">straightforward. </span><span class="koboSpan" id="kobo.433.2">But things become more complicated when you have a monorepo with tens, hundreds, or even thousands of applications and libraries. </span><span class="koboSpan" id="kobo.433.3">In many scenarios, you want to run tasks simultaneously for multiple (or all) projects. </span><span class="koboSpan" id="kobo.433.4">Sometimes, you want to run specific tasks when something changes in a project, or you need to know if changes in a library have affected other projects and break them. </span><span class="koboSpan" id="kobo.433.5">If you perform these tasks by running commands one by one, this becomes unmanageable quickly, and building tools to watch and check for the affected projects becomes complicated. </span><span class="koboSpan" id="kobo.433.6">Luckily, Nx has everything we need to run tasks for multiple or affected projects, watch for changes, and react to them </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">with commands.</span></span></p>
<p><span class="koboSpan" id="kobo.435.1">When you use the Nx CLI, it is advised not to use the Angular CLI within the monorepo. </span><span class="koboSpan" id="kobo.435.2">We want Nx to do all its magic, and this is not possible if we start to generate things with the Angular CLI. </span><span class="koboSpan" id="kobo.435.3">Luckily, Nx has </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">you covered!</span></span></p>
<p><span class="koboSpan" id="kobo.437.1">Let’s start with the basics – running commands for a single project using the Nx CLI. </span><span class="koboSpan" id="kobo.437.2">Running tasks for a single project is similar to running tasks with the Angular CLI. </span><span class="koboSpan" id="kobo.437.3">For example, if we want to run the tests for an application named </span><strong class="bold"><span class="koboSpan" id="kobo.438.1">testApp</span></strong><span class="koboSpan" id="kobo.439.1">, we can run the </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.441.1">
nx test testApp</span></pre> <p><span class="koboSpan" id="kobo.442.1">If we want to run</span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.443.1"> tasks for multiple projects, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">run-many</span></strong><span class="koboSpan" id="kobo.445.1"> keyword combined with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">-p</span></strong><span class="koboSpan" id="kobo.447.1"> flag to define the projects for which we want to run the tasks. </span><span class="koboSpan" id="kobo.447.2">If you omit the </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">-p</span></strong><span class="koboSpan" id="kobo.449.1"> flag and only use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">run-many</span></strong><span class="koboSpan" id="kobo.451.1"> keyword, the task will run for all projects. </span><span class="koboSpan" id="kobo.451.2">We can also add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">-t</span></strong><span class="koboSpan" id="kobo.453.1"> flag to run multiple tasks at once. </span><span class="koboSpan" id="kobo.453.2">For example, if we want to build, lint, and test all projects, we can run the </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.455.1">
nx run-many -t build lint test</span></pre> <p><span class="koboSpan" id="kobo.456.1">Now, let’s say we only want to build, lint, and test </span><em class="italic"><span class="koboSpan" id="kobo.457.1">testApp</span></em><span class="koboSpan" id="kobo.458.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.459.1">testApp2</span></em><span class="koboSpan" id="kobo.460.1">. </span><span class="koboSpan" id="kobo.460.2">For this, we can run the </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.462.1">
run-many -t build lint test -p testApp testApp2</span></pre> <p><span class="koboSpan" id="kobo.463.1">As you can see, running commands with the Nx CLI is simple, even if you need to do it for multiple or all projects within your monorepo. </span><span class="koboSpan" id="kobo.463.2">Even if you want to run several tasks simultaneously for a subset or all projects, you can do it quickly and with a </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">single command.</span></span></p>
<p><span class="koboSpan" id="kobo.465.1">Another helpful option is to watch for changes in specific projects and run scripts whenever changes occur in a watched project. </span><span class="koboSpan" id="kobo.465.2">For example, you can watch for changes in an application and echo the project name and the changed filename. </span><span class="koboSpan" id="kobo.465.3">This can be done for single projects, a subset of projects, or all projects, like running regular commands. </span><span class="koboSpan" id="kobo.465.4">Here’s an example of what this command will </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">look like:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.467.1">
nx watch --projects=testApp,testApp2 --includeDependentProjects -- echo \$NX_PROJECT_NAME \$NX_FILE_CHANGES</span></pre> <p><span class="koboSpan" id="kobo.468.1">Lastly, we need something to detect the affected projects and run commands for them. </span><span class="koboSpan" id="kobo.468.2">When a monorepo grows, it becomes too time-consuming to run tests for all projects every time you change a library. </span><span class="koboSpan" id="kobo.468.3">Consider the following scenario. </span><span class="koboSpan" id="kobo.468.4">We have five applications and three libraries being used by those applications. </span><span class="koboSpan" id="kobo.468.5">Now, if we change the code of a library and all five projects use this library, our changes can affect and break the four other projects we aren’t working on ourselves. </span><span class="koboSpan" id="kobo.468.6">This can be a massive problem if we release an application or library to production without noticing we broke another application with our changes. </span><span class="koboSpan" id="kobo.468.7">When we make changes in a library, we need to know what projects in the monorepo are affected by those changes and run the appropriate tests to see if everything still works. </span><span class="koboSpan" id="kobo.468.8">For this scenario, Nx has </span><em class="italic"><span class="koboSpan" id="kobo.469.1">affected commands</span></em><span class="koboSpan" id="kobo.470.1">. </span><span class="koboSpan" id="kobo.470.2">By running these commands, you can run tasks such as linting and testing for all projects affected by your </span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.471.1">changes. </span><span class="koboSpan" id="kobo.471.2">The following is an example of such </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">a command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.473.1">
nx affected -t test</span></pre> <p><span class="koboSpan" id="kobo.474.1">With that, you have basic knowledge of running tasks in an Nx monorepo. </span><span class="koboSpan" id="kobo.474.2">Next, let’s explore how Nx helps us keep the code and setup in our monorepo projects standardized </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">and uniform.</span></span></p>
<h3><span class="koboSpan" id="kobo.476.1">Ensuring uniformity and consistency within your Nx monorepo</span></h3>
<p><span class="koboSpan" id="kobo.477.1">Another critical aspect of</span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.478.1"> a scalable Angular monorepo is uniformity and consistency in the code of the different applications within the monorepo. </span><span class="koboSpan" id="kobo.478.2">When you have hundreds of projects in your monorepo, you don’t want different code conventions and implementations in each project. </span><span class="koboSpan" id="kobo.478.3">This would make it much harder for developers to start working on other projects within the monorepo, and it also makes it harder to find similar code or refactor code in bulk. </span><span class="koboSpan" id="kobo.478.4">When everyone uses the same conventions and code patterns, each developer can work on every project within the monorepo and make changes </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">when needed.</span></span></p>
<p><span class="koboSpan" id="kobo.480.1">Nx helps us maintain uniformity with global linting rules that apply to all projects within the monorepo. </span><span class="koboSpan" id="kobo.480.2">You can set up these linting rules however you see fit and can even create custom linting rules. </span><span class="koboSpan" id="kobo.480.3">Besides global linting rules, you can also apply specific lint rules for </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">individual projects.</span></span></p>
<p><span class="koboSpan" id="kobo.482.1">Nx generators are another great way to enforce uniformity within your Nx monorepo. </span><span class="koboSpan" id="kobo.482.2">Generators are used to generate applications, libraries, components, and other code snippets. </span><span class="koboSpan" id="kobo.482.3">You can even use Nx generators to modify your code throughout the monorepo or set up and change configuration files. </span><span class="koboSpan" id="kobo.482.4">This can be very useful when you need to apply refactoring to multiple files of </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">your monorepo.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">Using generators ensures that things are created in the same manner by all developers working within the monorepo. </span><span class="koboSpan" id="kobo.484.2">Executing generators can be done with the terminal, though when using the Nx console, you get a nice user interface for executing them. </span><span class="koboSpan" id="kobo.484.3">You can also overwrite the built-in generators so that fewer options are revealed, and the default values are set. </span><span class="koboSpan" id="kobo.484.4">This reduces variation and makes the generators easier to use for less experienced developers. </span><span class="koboSpan" id="kobo.484.5">We will dive deeper into this topic when we create an Nx monorepo in the </span><em class="italic"><span class="koboSpan" id="kobo.485.1">Setting up a scalable Angular workspace</span></em><span class="koboSpan" id="kobo.486.1"> section. </span><span class="koboSpan" id="kobo.486.2">For now, it’s important to know that you must use generators </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">whenever possible.</span></span></p>
<p><span class="koboSpan" id="kobo.488.1">The last thing I </span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.489.1">want to mention on uniformity</span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.490.1"> is </span><strong class="bold"><span class="koboSpan" id="kobo.491.1">Prettier</span></strong><span class="koboSpan" id="kobo.492.1">. </span><span class="koboSpan" id="kobo.492.2">Nx has built-in support for the code formatter Prettier. </span><span class="koboSpan" id="kobo.492.3">As with linting rules, formatting rules can be configured for the entire monorepo and individual projects within the monorepo. </span><span class="koboSpan" id="kobo.492.4">You can also run a command with the Nx CLI to detect unformatted lines of code. </span><span class="koboSpan" id="kobo.492.5">When you configure VS Code to auto-format on </span><strong class="bold"><span class="koboSpan" id="kobo.493.1">Save</span></strong><span class="koboSpan" id="kobo.494.1">, Prettier will format your code whenever you save </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">a file.</span></span></p>
<p><span class="koboSpan" id="kobo.496.1">Now that you’ve learned how to manage monorepos with Nx, we will explore how you can update and manage dependencies in an </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">Nx monorepo.</span></span></p>
<h3><span class="koboSpan" id="kobo.498.1">Nx dependency management and code migrations</span></h3>
<p><span class="koboSpan" id="kobo.499.1">Managing</span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.500.1"> dependencies in an Nx monorepo is easy since there is one </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">package.json</span></strong><span class="koboSpan" id="kobo.502.1"> file for the entire monorepo (this is only the case for integrated monorepos, but we’ll cover this in more detail when we create our monorepo in the </span><em class="italic"><span class="koboSpan" id="kobo.503.1">Setting up a scalable Angular workspace</span></em><span class="koboSpan" id="kobo.504.1"> section) and most packages can be updated automatically, including configuration and code changes needed for that update. </span><span class="koboSpan" id="kobo.504.2">Running automated updates can be done by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">nx migrate</span></strong><span class="koboSpan" id="kobo.506.1"> command, </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">like so:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.508.1">
nx migrate [packageAndVersion]</span></pre> <p><span class="koboSpan" id="kobo.509.1">In general, you will update to the latest version of the Nx package and dependencies; in that case, you can use the </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.511.1">
nx migrate latest</span></pre> <p><span class="koboSpan" id="kobo.512.1">Running the preceding command will update your </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">package.json</span></strong><span class="koboSpan" id="kobo.514.1"> file and generate a </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">migrations.json</span></strong><span class="koboSpan" id="kobo.516.1"> file containing all the migrations that Nx and its plugins need to run to update all packages successfully. </span><span class="koboSpan" id="kobo.516.2">To execute these migrations, you need to run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">migrate</span></strong><span class="koboSpan" id="kobo.518.1"> command with an additional flag, </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">like so:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.520.1">
nx migrate --run-migrations</span></pre> <p><span class="koboSpan" id="kobo.521.1">After running this command, your packages, configuration files, and code will be updated to use the latest versions of Nx and the plugins configured within the workspace. </span><span class="koboSpan" id="kobo.521.2">For packages that don’t have a plugin, you need to do the updates manually as you do with NPM packages. </span><span class="koboSpan" id="kobo.521.3">Packages with a plugin will do everything for you with Nx migrations. </span><span class="koboSpan" id="kobo.521.4">There are plugins for Angular, Jest, Cypress, and most other things you will use within the </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">Nx monorepo.</span></span></p>
<p><span class="koboSpan" id="kobo.523.1">Another cool</span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.524.1"> feature for managing dependencies is that Nx lets you visualize dependencies on a graph. </span><span class="koboSpan" id="kobo.524.2">With this, you can see what projects depend on one another and zoom in on these nodes to better view the dependencies. </span><span class="koboSpan" id="kobo.524.3">This works for projects as well as tasks. </span><span class="koboSpan" id="kobo.524.4">If you have tasks that run multiple tasks in a chain, you can also visualize this task chain on a nice graph. </span><span class="koboSpan" id="kobo.524.5">The </span><strong class="bold"><span class="koboSpan" id="kobo.525.1">Nx graph</span></strong><span class="koboSpan" id="kobo.526.1"> is a valuable tool as visualization helps you better understand your </span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.527.1">monorepo’s structure. </span><span class="koboSpan" id="kobo.527.2">If you can no longer make sense of the dependencies in the graph, chances are that they won’t make sense in your code either. </span><span class="koboSpan" id="kobo.527.3">You can open the graph by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.529.1">
nx graph</span></pre> <p><span class="koboSpan" id="kobo.530.1">If you want a graph of the affected projects, you can run the </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.532.1">
nx affected:graph</span></pre> <p><span class="koboSpan" id="kobo.533.1">Lastly, you can use tags to set up boundaries throughout your monorepo so that projects can only import what they’re supposed to import. </span><span class="koboSpan" id="kobo.533.2">If you try to import a library you aren’t supposed to, the code won’t compile, and an error will inform you that you aren’t allowed to use the library within your project. </span><span class="koboSpan" id="kobo.533.3">When we create our monorepo in the </span><em class="italic"><span class="koboSpan" id="kobo.534.1">Setting up a scalable Angular workspace </span></em><span class="koboSpan" id="kobo.535.1">section, we’ll set up these boundaries </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.537.1">As mentioned previously, Nx is a vast topic that offers us many tools for managing monorepos. </span><span class="koboSpan" id="kobo.537.2">As we progress through this book, we will learn more about Nx, but for now, you have a good idea of what Nx is and how it can help you manage Angular monorepos of any size. </span><span class="koboSpan" id="kobo.537.3">Now, we will move on to creating an Nx monorepo, including some Angular projects </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">and libraries.</span></span></p>
<h1 id="_idParaDest-27"><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.539.1">Setting up a scalable Angular workspace</span></h1>
<p><span class="koboSpan" id="kobo.540.1">In this</span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.541.1"> final section, we will create an Nx monorepo, along with some placeholder Angular applications and libraries for demonstration purposes. </span><span class="koboSpan" id="kobo.541.2">We’ll start by adding some extensions in VS Code to make our developer experience </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">more pleasant.</span></span></p>
<p><span class="koboSpan" id="kobo.543.1">Add the </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">following extensions:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.545.1">Angular Essentials (version 16): Angular Essentials is comprised of eight different extensions that are useful for </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">Angular development</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.547.1">Angular support</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.548.1">Nx console</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.549.1">Once you’ve installed these extensions, you will probably need to reload VS Code for all of them to be applied, so restart your VS Code application. </span><span class="koboSpan" id="kobo.549.2">After this, you should see an Nx icon on the left-hand side of VS Code; this is the Nx console. </span><span class="koboSpan" id="kobo.549.3">When you have successfully installed the various VS Code extensions, you must globally install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">Nx</span></strong><span class="koboSpan" id="kobo.551.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">Cypress NPM</span></strong><span class="koboSpan" id="kobo.553.1"> packages. </span><span class="koboSpan" id="kobo.553.2">To do so, you can run the following command in the terminal of your choice. </span><span class="koboSpan" id="kobo.553.3">I like to use the integrated VS </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">Code terminal:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.555.1">
npm i -g nx cypress</span></pre> <p><span class="koboSpan" id="kobo.556.1">Once these NPM packages have been installed, we can create our Nx workspace. </span><span class="koboSpan" id="kobo.556.2">Find a folder where you want to create the Nx monorepo and open a terminal at this location. </span><span class="koboSpan" id="kobo.556.3">To create the Nx workspace, run the </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.558.1">
npx create-nx-workspace</span></pre> <p><span class="koboSpan" id="kobo.559.1">When you run this</span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.560.1"> command, you will be prompted with </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">several questions:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.562.1">Where would you like to create your </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">workspace? </span><span class="koboSpan" id="kobo.563.2">(</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">business-tools-monorepo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">.)</span></span></li>
<li><span class="koboSpan" id="kobo.566.1">Which stack do you want to use? </span><span class="koboSpan" id="kobo.566.2">(Angular: Configures an Angular app with </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">modern tooling.)</span></span></li>
<li><span class="koboSpan" id="kobo.568.1">Standalone project or integrated monorepo? </span><span class="koboSpan" id="kobo.568.2">(Integrated monorepo: Nx creates a monorepo that contains </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">multiple projects.)</span></span></li>
<li><span class="koboSpan" id="kobo.570.1">Application </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">name (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">Invoicing</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.574.1">Which bundler would you like to </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">use? </span><span class="koboSpan" id="kobo.575.2">(</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">esbuild</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">.)</span></span></li>
<li><span class="koboSpan" id="kobo.578.1">Default stylesheet </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">format (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">SASS(.scss)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.582.1">Do you want</span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.583.1"> to </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.584.1">enable </span><strong class="bold"><span class="koboSpan" id="kobo.585.1">server-side rendering</span></strong><span class="koboSpan" id="kobo.586.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.587.1">SSR</span></strong><span class="koboSpan" id="kobo.588.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.589.1">static site generation</span></strong><span class="koboSpan" id="kobo.590.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.591.1">SSG</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">)? </span><span class="koboSpan" id="kobo.592.2">(No.)</span></span></li>
<li><span class="koboSpan" id="kobo.593.1">Test runner to use </span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.594.1">for </span><strong class="bold"><span class="koboSpan" id="kobo.595.1">end-to-end</span></strong><span class="koboSpan" id="kobo.596.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.597.1">e2e</span></strong><span class="koboSpan" id="kobo.598.1">) </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">tests (Cypress).</span></span></li>
<li><span class="koboSpan" id="kobo.600.1">Set up CI with caching, distribution, and test </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">deflaking (Skip).</span></span></li>
<li><span class="koboSpan" id="kobo.602.1">Would you like remote caching to make your build </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">faster? </span><span class="koboSpan" id="kobo.603.2">(Yes.)</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.604.1">Once you’ve</span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.605.1"> answered these questions, the Nx monorepo will be created in a folder called </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">business-tools-monorepo</span></strong><span class="koboSpan" id="kobo.607.1">. </span><span class="koboSpan" id="kobo.607.2">We will dive into what Nx created for us in the </span><em class="italic"><span class="koboSpan" id="kobo.608.1">What did Nx create in our new workspace?</span></em><span class="koboSpan" id="kobo.609.1"> section, but first, I want to explain the different types of workspaces you can create </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">with Nx.</span></span></p>
<p><span class="koboSpan" id="kobo.611.1">Nx workspaces come as standalone projects, package-based monorepos, and </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">integrated monorepos:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.613.1">Standalone projects are well suited for when you want to start with a single project but keep the door open for growing into a large monorepo. </span><span class="koboSpan" id="kobo.613.2">Nx is also useful for single projects as you can utilize their generators and automated updates through Nx migrations </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">and executors.</span></span></li>
<li><span class="koboSpan" id="kobo.615.1">Next, we have package-based monorepos. </span><span class="koboSpan" id="kobo.615.2">This solution is beneficial when you need to add a lot of exciting projects to an Nx workspace. </span><span class="koboSpan" id="kobo.615.3">With package-based repos, each project in the Nx workspace has its own dependencies. </span><span class="koboSpan" id="kobo.615.4">You will get the improved speed and task running from Nx, but Nx will stay out of your way for </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">the rest.</span></span></li>
<li><span class="koboSpan" id="kobo.617.1">Lastly, there are integrated Nx monorepos. </span><span class="koboSpan" id="kobo.617.2">This is what we’ll be using and is the setup where you leverage all the tools Nx has </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">to offer.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.619.1">Now, let’s see what Nx created f when it generated </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">the monorepo.</span></span></p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.621.1">What did Nx create in our new workspace?</span></h2>
<p><span class="koboSpan" id="kobo.622.1">When you open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">business-tools-monorepo</span></strong><span class="koboSpan" id="kobo.624.1"> folder in V SCode, you will see five folders and a couple of files in the root of the monorepo. </span><span class="koboSpan" id="kobo.624.2">We will review the essential files and explain the folders, but first, let’s briefly lay out what Nx did for us when it generated </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">the monorepo.</span></span></p>
<p><span class="koboSpan" id="kobo.626.1">Nx created our monorepo and configured it for building Angular applications. </span><span class="koboSpan" id="kobo.626.2">It installed the Nx Angular plugin and all the essential NPM packages needed to develop Angular applications. </span><span class="koboSpan" id="kobo.626.3">Besides that, Nx configured everything for computational caching, ESlint, Cypress e2e testing, and unit testing with Jest, and Prettier for code formatting. </span><span class="koboSpan" id="kobo.626.4">Nx also made our first Angular application, </span><strong class="bold"><span class="koboSpan" id="kobo.627.1">invoicing</span></strong><span class="koboSpan" id="kobo.628.1">, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">apps</span></strong><span class="koboSpan" id="kobo.630.1"> folder. </span><span class="koboSpan" id="kobo.630.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">apps</span></strong><span class="koboSpan" id="kobo.632.1"> folder will contain all the applications we create in our Nx monorepo. </span><span class="koboSpan" id="kobo.632.2">If you open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">apps</span></strong><span class="koboSpan" id="kobo.634.1"> folder, you will notice that Nx also created an </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">invoicing-e2e</span></strong><span class="koboSpan" id="kobo.636.1"> project. </span><span class="koboSpan" id="kobo.636.2">This is a Cypress project for e2e testing our Angular invoicing application. </span><span class="koboSpan" id="kobo.636.3">All of these things will work out of the box. </span><span class="koboSpan" id="kobo.636.4">Nx did all the configuration for us. </span><span class="koboSpan" id="kobo.636.5">In the folder structure, we’ll see a folder </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">apps</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.640.1">Now, let’s look at some important files that Nx</span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.641.1"> created in </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">our workspace:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">nx.json</span></strong><span class="koboSpan" id="kobo.644.1">: This is used to configure the Nx CLI and its </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">default configurations</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">.eslintrc.json</span></strong><span class="koboSpan" id="kobo.647.1">: This file can be found at the root of your monorepo and inside each project in the repo. </span><span class="koboSpan" id="kobo.647.2">The file in the root contains the global ESlint rules that are applied to all projects within our monorepo. </span><span class="koboSpan" id="kobo.647.3">The files within the specific projects contain project-specific </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">ESlint rules.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">project.json</span></strong><span class="koboSpan" id="kobo.650.1">: This can be found at the root of our Angular application (</span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">apps\invoicing\project.json</span></strong><span class="koboSpan" id="kobo.652.1">). </span><span class="koboSpan" id="kobo.652.2">In a regular Angular application, this would be our </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">angular.json</span></strong><span class="koboSpan" id="kobo.654.1"> file. </span><span class="koboSpan" id="kobo.654.2">It has the same content and usage. </span><span class="koboSpan" id="kobo.654.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">project.json</span></strong><span class="koboSpan" id="kobo.656.1"> file will be created for each project in our </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">Nx monorepo.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">tsconfig.base.json</span></strong><span class="koboSpan" id="kobo.659.1">: This is </span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.660.1">used for global TypeScript settings and setting up aliases for </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">library imports.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.662.1">We will learn more about these files and how to edit them throughout this book and when we start to add projects, libraries, and plugins to our </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">Nx monorepo.</span></span></p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.664.1">Improving our Nx workspace for better Angular development</span></h2>
<p><span class="koboSpan" id="kobo.665.1">We </span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.666.1">already have a nice workspace from Nx that will scale pretty well out of the box. </span><span class="koboSpan" id="kobo.666.2">You can uniformly create Angular applications, libraries, and other classes throughout the workspace. </span><span class="koboSpan" id="kobo.666.3">For each application or library you create, Jest unit testing is configured, and for each application, you get a Cypress project with everything you need to run e2e tests. </span><span class="koboSpan" id="kobo.666.4">ESlint and Prettier are configured for the entire monorepo to keep your code uniform among the different projects. </span><span class="koboSpan" id="kobo.666.5">The monorepo has automated updates with Nx migrations; you can visualize your dependencies and tasks with the Nx graph and effectively run commands against your monorepo with the Nx task runner. </span><span class="koboSpan" id="kobo.666.6">The first step I like to take is creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">libs</span></strong><span class="koboSpan" id="kobo.668.1"> folder next to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">apps</span></strong><span class="koboSpan" id="kobo.670.1"> folder. </span><span class="koboSpan" id="kobo.670.2">Inside this </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">libs</span></strong><span class="koboSpan" id="kobo.672.1"> folder, we will store all our libraries. </span><span class="koboSpan" id="kobo.672.2">To improve this further, we need to add some extra ESlint rules, create custom generators tailored to our needs, and set up project boundaries </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">with tags.</span></span></p>
<h3><span class="koboSpan" id="kobo.674.1">Adding ESlint rules to improve our Angular code</span></h3>
<p><span class="koboSpan" id="kobo.675.1">We can use </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.676.1">lint rules to keep our code uniform and ensure that developers don’t implement code in unintended ways. </span><span class="koboSpan" id="kobo.676.2">Linting can catch bugs preemptively and enforce best practices. </span><span class="koboSpan" id="kobo.676.3">Nx has already added Angular-specific lint rules for our monorepo with two </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">@angular-eslint</span></strong><span class="koboSpan" id="kobo.678.1"> packages. </span><span class="koboSpan" id="kobo.678.2">To make our monorepo more robust, we’ll want to add some extra ESlint rules tailored for Angular and RxJS. </span><span class="koboSpan" id="kobo.678.3">The lint rules we will add are not required, but I suggest using them or adding rules according to your preferences when setting up a monorepo. </span><span class="koboSpan" id="kobo.678.4">This is important so that everyone working on your code will follow the same implementation and style guide rules for writing code. </span><span class="koboSpan" id="kobo.678.5">Each company and code base uses its own conventions, so make sure you have lint rules in place to enforce them. </span><span class="koboSpan" id="kobo.678.6">If you can’t find lint rules that enforce your code conventions, Nx also allows you to add custom </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">lint rules.</span></span></p>
<p><span class="koboSpan" id="kobo.680.1">First, we will add some NPM packages as </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">dev dependencies:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.682.1">
npm i --save-dev eslint-plugin-deprecation eslint-plugin-rxjs eslint-plugin-rxjs-angular</span></pre> <p><span class="koboSpan" id="kobo.683.1">When the command has finished running, the packages will be added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">package.json</span></strong><span class="koboSpan" id="kobo.685.1"> file in the root of your Nx monorepo, and the lint rules belonging to these packages can be added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">.eslintrc.json</span></strong><span class="koboSpan" id="kobo.687.1"> files. </span><span class="koboSpan" id="kobo.687.2">We will only add rules to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">.eslintrc.json</span></strong><span class="koboSpan" id="kobo.689.1"> file at the root of the monorepo. </span><span class="koboSpan" id="kobo.689.2">These lint rules will be applied to all the projects within the monorepo. </span><span class="koboSpan" id="kobo.689.3">We also need to add </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">parserOptions</span></strong><span class="koboSpan" id="kobo.691.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">.eslintrc.json</span></strong><span class="koboSpan" id="kobo.693.1"> file because we’re working with TypeScript and type-based lint rules. </span><span class="koboSpan" id="kobo.693.2">You can find the updated </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">.eslintrc.json</span></strong><span class="koboSpan" id="kobo.695.1"> file in this book’s GitHub repository (link in the </span><em class="italic"><span class="koboSpan" id="kobo.696.1">Technical </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.697.1">requirements</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.698.1"> section).</span></span></p>
<p><span class="koboSpan" id="kobo.699.1">Once you’ve </span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.700.1">added the extra lint rules and </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">parserOptions</span></strong><span class="koboSpan" id="kobo.702.1">, we can move on and start creating some custom </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">Nx generators.</span></span></p>
<h3><span class="koboSpan" id="kobo.704.1">Creating custom Nx generators for our Angular monorepo</span></h3>
<p><span class="koboSpan" id="kobo.705.1">Generators</span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.706.1"> are excellent tools to do things </span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.707.1">uniformly because everyone who uses the generator will have the same result. </span><span class="koboSpan" id="kobo.707.2">First, we’ll focus on overwriting built-in Angular generators. </span><span class="koboSpan" id="kobo.707.3">Throughout this book, we will create and use generators to refactor code in our monorepo and to create custom </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">code snippets.</span></span></p>
<p><span class="koboSpan" id="kobo.709.1">In this section, we will overwrite the generator for creating Angular libraries. </span><span class="koboSpan" id="kobo.709.2">We will significantly reduce the options you can enter when using the generator, add custom options to enforce a directory structure, and add tags for project boundaries. </span><span class="koboSpan" id="kobo.709.3">Fewer options means less deviation from the conventions your organization is using, resulting in more uniformity and fewer questions from less </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">experienced developers.</span></span></p>
<p><span class="koboSpan" id="kobo.711.1">Let’s start by creating an Nx plugin using an </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">Nx generator:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.713.1">To use the plugin generator, install the NPM package by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.715.1">npm i @nx/plugin</span></strong></pre></li> <li><span class="koboSpan" id="kobo.716.1">Now, on the left-hand side of VS Code, click on the Nx icon to open the </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">Nx console.</span></span></li>
<li><span class="koboSpan" id="kobo.718.1">Go to the </span><strong class="bold"><span class="koboSpan" id="kobo.719.1">GENERATE &amp; RUN TARGET</span></strong><span class="koboSpan" id="kobo.720.1"> tab and click </span><strong class="bold"><span class="koboSpan" id="kobo.721.1">generate</span></strong><span class="koboSpan" id="kobo.722.1">. </span><span class="koboSpan" id="kobo.722.2">This will open a dropdown with a search bar at the top of </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">VS Code.</span></span></li>
<li><span class="koboSpan" id="kobo.724.1">In this search bar, enter </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">plugin</span></strong><span class="koboSpan" id="kobo.726.1"> and select the </span><strong class="bold"><span class="koboSpan" id="kobo.727.1">@nx/plugin - plugin Create a Nx plugin</span></strong><span class="koboSpan" id="kobo.728.1"> option. </span><span class="koboSpan" id="kobo.728.2">This will open a new window in VS Code where you can generate </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">your plugin.</span></span></li>
<li><span class="koboSpan" id="kobo.730.1">By default, the generator will ask you to fill out two fields, a </span><em class="italic"><span class="koboSpan" id="kobo.731.1">name</span></em><span class="koboSpan" id="kobo.732.1"> and an </span><em class="italic"><span class="koboSpan" id="kobo.733.1">import path</span></em><span class="koboSpan" id="kobo.734.1">, and a directory, of which the name </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">is required.</span></span></li>
<li><span class="koboSpan" id="kobo.736.1">Name your plugin </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">workspace-generators-plugin</span></strong><span class="koboSpan" id="kobo.738.1">. </span><span class="koboSpan" id="kobo.738.2">For the import path, enter </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">@business-tools/workspace-generators-plugin</span></strong><span class="koboSpan" id="kobo.740.1">, and for the directory, </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">enter </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">libs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.744.1">Click </span><strong class="bold"><span class="koboSpan" id="kobo.745.1">Show </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.746.1">all options</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.748.1">Under </span><strong class="bold"><span class="koboSpan" id="kobo.749.1">projectNameAndRootFormat</span></strong><span class="koboSpan" id="kobo.750.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">select </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.752.1">derived</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.754.1">Then, click on the </span><strong class="bold"><span class="koboSpan" id="kobo.755.1">generate</span></strong><span class="koboSpan" id="kobo.756.1"> button at the </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">top right.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.758.1">This will generate your plugin under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">libs</span></strong><span class="koboSpan" id="kobo.760.1"> folder at the root of </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">your monorepo.</span></span></p>
<p><span class="koboSpan" id="kobo.762.1">Next, we will</span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.763.1"> create our </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">custom</span></span><span class="No-Break"><a id="_idIndexMarker089"/></span><span class="No-Break"><span class="koboSpan" id="kobo.765.1"> generator:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.766.1">First, click on </span><strong class="bold"><span class="koboSpan" id="kobo.767.1">generate</span></strong><span class="koboSpan" id="kobo.768.1"> again in the </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">Nx console.</span></span></li>
<li><span class="koboSpan" id="kobo.770.1">In the search bar, type </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">generator</span></strong><span class="koboSpan" id="kobo.772.1"> and select </span><strong class="bold"><span class="koboSpan" id="kobo.773.1">@nx/plugin - </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.774.1">generator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.776.1">Now, in the newly opened window, give the generator a name, such </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">generate-angular-library</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.780.1">For </span><strong class="bold"><span class="koboSpan" id="kobo.781.1">directory</span></strong><span class="koboSpan" id="kobo.782.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.783.1">enter </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">libs\workspace-generators-plugin</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.786.1">Click </span><strong class="bold"><span class="koboSpan" id="kobo.787.1">Show </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.788.1">all options</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.790.1">Under </span><strong class="bold"><span class="koboSpan" id="kobo.791.1">projectNameAndRootFormat</span></strong><span class="koboSpan" id="kobo.792.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">select </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.794.1">derived</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.796.1">Then, click on the </span><strong class="bold"><span class="koboSpan" id="kobo.797.1">generate</span></strong><span class="koboSpan" id="kobo.798.1"> button at the </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">top right.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.800.1">When this process completes, you will find a </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">generators</span></strong><span class="koboSpan" id="kobo.802.1"> folder inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">src</span></strong><span class="koboSpan" id="kobo.804.1"> folder of </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">workspace-generators-plugin</span></strong><span class="koboSpan" id="kobo.806.1">. </span><span class="koboSpan" id="kobo.806.2">Inside this </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">generators</span></strong><span class="koboSpan" id="kobo.808.1"> folder, you will find your custom generator, which is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">generate-angular-library</span></strong><span class="koboSpan" id="kobo.810.1">. </span><span class="koboSpan" id="kobo.810.2">Inside your custom generator are a bunch of files, but before we start exploring them, let’s look at what we will overwrite with this </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">custom generator:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.812.1">Go back to your Nx console and click </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.813.1">generate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.814.1"> again.</span></span></li>
<li><span class="koboSpan" id="kobo.815.1"> This time, search for </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">library</span></strong><span class="koboSpan" id="kobo.817.1"> and choose </span><strong class="bold"><span class="koboSpan" id="kobo.818.1">option @nx/angular - </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.819.1">library</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.821.1">When you inspect the new generator window for this library, you will find seven options to fill out; if you click on </span><strong class="bold"><span class="koboSpan" id="kobo.822.1">Show all options</span></strong><span class="koboSpan" id="kobo.823.1">, you will have 30 possibilities to fill out. </span><span class="koboSpan" id="kobo.823.2">Not all developers will know what to select here, and if we leave it up to developers, we will get too much variation when we create libraries within our monorepo. </span><span class="koboSpan" id="kobo.823.3">For now, let’s close the window for generating an Angular library and start to overwrite it with our </span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">custom generator.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.825.1">When we overwrite an existing generator, we are interested in three different files: </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">generator.ts</span></strong><span class="koboSpan" id="kobo.827.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">schema.json</span></strong><span class="koboSpan" id="kobo.829.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">schema.d.ts</span></strong><span class="koboSpan" id="kobo.831.1">. </span><span class="koboSpan" id="kobo.831.2">We will write our logic inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">generator.ts</span></strong><span class="koboSpan" id="kobo.833.1"> file; the </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">schema.json</span></strong><span class="koboSpan" id="kobo.835.1"> file will contain the information for the Nx console window, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">schema.d.ts</span></strong><span class="koboSpan" id="kobo.837.1"> will contain the interface for our options inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">generator.ts</span></strong><span class="koboSpan" id="kobo.839.1"> file. </span><span class="koboSpan" id="kobo.839.2">Let’s inspect these three files individually, starting with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">generator.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.841.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.842.1">Nx has already</span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.843.1"> generated a bunch of code </span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.844.1">for us in this </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">generator.ts</span></strong><span class="koboSpan" id="kobo.846.1"> file, but we won’t worry about all that and instead replace it with the following small piece </span><span class="No-Break"><span class="koboSpan" id="kobo.847.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.848.1">
import { Tree } from '@nx/devkit';
import { libraryGenerator } from '@nx/angular/generators';
import { GenerateAngularLibraryGeneratorSchema } from './schema';
export async function generateAngularLibraryGenerator(
  tree: Tree,
  options: GenerateAngularLibraryGeneratorSchema
) {
  await libraryGenerator(tree, options);
}
export default generateAngularLibraryGenerator;</span></pre> <p><span class="koboSpan" id="kobo.849.1">We cleared everything inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">generateAngularLibraryGenerator</span></strong><span class="koboSpan" id="kobo.851.1"> function and replaced it with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">libraryGenerator</span></strong><span class="koboSpan" id="kobo.853.1"> method from </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">@nx/angular/generators</span></strong><span class="koboSpan" id="kobo.855.1">. </span><span class="koboSpan" id="kobo.855.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">libraryGenerator</span></strong><span class="koboSpan" id="kobo.857.1"> method is the built-in Angular library generator we inspected a moment ago. </span><span class="koboSpan" id="kobo.857.2">When you want to overwrite built-in generators, you can find them in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">node_modules</span></strong><span class="koboSpan" id="kobo.859.1"> folder or the GitHub repository of the corresponding package. </span><span class="koboSpan" id="kobo.859.2">Now, if we build and run our custom generator, we </span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.860.1">can only enter a name because</span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.861.1"> that is the only thing we have in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">schema.json</span></strong><span class="koboSpan" id="kobo.863.1"> file, so our custom generator generates an Angular library for us with the default settings. </span><span class="koboSpan" id="kobo.863.2">So, we went from 30 options to fill out to only a name. </span><span class="koboSpan" id="kobo.863.3">However, we want to add additional options and choose specific values for some of the built-in options. </span><span class="koboSpan" id="kobo.863.4">We can do this by editing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">libraryGenerator</span></strong><span class="koboSpan" id="kobo.865.1"> method, </span><span class="No-Break"><span class="koboSpan" id="kobo.866.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.867.1">
await libraryGenerator(tree, {
  name: options.name,
  simpleName: true,
  standalone: true,
  buildable: true,
  prefix: `bt-libs-${options.type}`,
  style: ‹scss›,
  changeDetection: ‹OnPush›,
  directory: `libs/${options.domain}/${options.type}`,
  tags: `domain:${options.domain}, type:${options.type}`,
  importPath: `@bt-libs/${options.domain}/${options.type}/${options.name}`,
});</span></pre> <p><span class="koboSpan" id="kobo.868.1">Our generated libraries will now be buildable, use standalone components, have on-push change detection, use SCSS style, have tags, have an import path, and have a directory structure configured. </span><span class="koboSpan" id="kobo.868.2">We use a name, domain, and type property in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">options</span></strong><span class="koboSpan" id="kobo.870.1"> object. </span><span class="koboSpan" id="kobo.870.2">The name is configured by default, so let’s add the options we want to expose inside our </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">schema.json</span></strong><span class="koboSpan" id="kobo.872.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">schema.d.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.874.1"> files.</span></span></p>
<p><span class="koboSpan" id="kobo.875.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">schema.d.ts</span></strong><span class="koboSpan" id="kobo.877.1"> file, we’ll find an interface for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">options</span></strong><span class="koboSpan" id="kobo.879.1"> object we used in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">generator.ts</span></strong><span class="koboSpan" id="kobo.881.1"> file. </span><span class="koboSpan" id="kobo.881.2">This interface declares a </span><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">name</span></strong><span class="koboSpan" id="kobo.883.1"> property by default. </span><span class="koboSpan" id="kobo.883.2">We want to add a domain and type to the interface and only allow preset string values for these properties. </span><span class="koboSpan" id="kobo.883.3">We</span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.884.1"> can do this by editing the</span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.885.1"> interface </span><span class="No-Break"><span class="koboSpan" id="kobo.886.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.887.1">
export interface GenerateAngularLibraryGeneratorSchema {
  name: string;
  domain: 'finance' | 'hr' | 'marketing' | 'inventory' | 'shared' ;
  type: 'ui' | 'data-access' | 'feature' | 'util' | 'all' ;
}</span></pre> <p><span class="koboSpan" id="kobo.888.1">Lastly, we want to update our </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">schema.json</span></strong><span class="koboSpan" id="kobo.890.1"> file. </span><span class="koboSpan" id="kobo.890.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">schema.json</span></strong><span class="koboSpan" id="kobo.892.1"> file defines the values we can fill out in the Nx console or terminal when using the generator. </span><span class="koboSpan" id="kobo.892.2">When we generated our custom generator, Nx added a name property for us, so we must add the domain and type. </span><span class="koboSpan" id="kobo.892.3">We can do this by adding extra objects in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">properties</span></strong><span class="koboSpan" id="kobo.894.1"> object inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">schema.json</span></strong><span class="koboSpan" id="kobo.896.1"> file. </span><span class="koboSpan" id="kobo.896.2">To include the domain, you can add the </span><span class="No-Break"><span class="koboSpan" id="kobo.897.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.898.1">
"domain": {
  "type": "string",
  "description": "Domain of the library",
  "$default": {
    "$source": "argv",
    "index": 1
  },
  "x-prompt": {
    "message": "What domain would you like to use?",
    "type": "list",
    "items": ["finance", "hr", "marketing", "inventory", "shared"]
  }
}</span></pre> <p><span class="koboSpan" id="kobo.899.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">type</span></strong><span class="koboSpan" id="kobo.901.1"> field, you</span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.902.1"> can add a similar object </span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.903.1">under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">domain</span></strong><span class="koboSpan" id="kobo.905.1"> object. </span><span class="koboSpan" id="kobo.905.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">index</span></strong><span class="koboSpan" id="kobo.907.1"> property needs to be one unit higher for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">type</span></strong><span class="koboSpan" id="kobo.909.1"> object because this index indicates at what position the field will be shown in the Nx console when we use </span><span class="No-Break"><span class="koboSpan" id="kobo.910.1">the generator.</span></span></p>
<p><span class="koboSpan" id="kobo.911.1">Now, if we build and run the generator, we’ll have three fields to fill out. </span><span class="koboSpan" id="kobo.911.2">When we fill those fields, a library will be generated for us with all the configurations </span><span class="No-Break"><span class="koboSpan" id="kobo.912.1">we added.</span></span></p>
<p><span class="koboSpan" id="kobo.913.1">But we can improve the generator even more. </span><span class="koboSpan" id="kobo.913.2">We can do this by adding an </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">'all'</span></strong><span class="koboSpan" id="kobo.915.1"> option to the type. </span><span class="koboSpan" id="kobo.915.2">When selecting </span><strong class="source-inline"><span class="koboSpan" id="kobo.916.1">'all'</span></strong><span class="koboSpan" id="kobo.917.1">, we generate a library for each type at once, and we can add cleanup logic to remove the initial component that comes with the generator – in most cases, we don’t want a component named after the library. </span><span class="koboSpan" id="kobo.917.2">To achieve these improvements, we’ll need to extract the </span><strong class="source-inline"><span class="koboSpan" id="kobo.918.1">libraryGenerator</span></strong><span class="koboSpan" id="kobo.919.1"> method into a separate function underneath the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">generateAngularLibraryGenerator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.921.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.922.1">
async function generateLibrary(
  tree: Tree,
  options: GenerateAngularLibraryGeneratorSchema,
  type: string
) {
  await libraryGenerator(tree, {
    name: options.name,
    simpleName: true,
    standalone: true,
    buildable: true,
    prefix: `bt-libs-${type}`,
    style: ‹scss›,
    changeDetection: ‹OnPush›,
    directory: `${options.domain}/${type}`,
    tags: `domain:${options.domain}, type:${type}`,
    importPath: `@bt-libs/${options.domain}/${type}/${options.name}`,
  });
}</span></pre> <p><span class="koboSpan" id="kobo.923.1">Next, we need to add an array with our types above the </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">generateAngularLibraryGenerator</span></strong><span class="koboSpan" id="kobo.925.1"> function, </span><span class="No-Break"><span class="koboSpan" id="kobo.926.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.927.1">
const TYPES = ['ui', 'data-access', 'feature', 'util'];
export async function generateAngularLibraryGenerator(
  tree: Tree,
  options: GenerateAngularLibraryGeneratorSchema
) {
  ………
}</span></pre> <p><span class="koboSpan" id="kobo.928.1">Now, inside </span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.929.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">generateAngularLibraryGenerator</span></strong><span class="koboSpan" id="kobo.931.1"> function, we’ll replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">libraryGenerator</span></strong><span class="koboSpan" id="kobo.933.1"> with</span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.934.1"> a </span><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">for</span></strong><span class="koboSpan" id="kobo.936.1"> loop. </span><span class="koboSpan" id="kobo.936.2">This will add a library for each of the available types when </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">options.type</span></strong><span class="koboSpan" id="kobo.938.1"> is equal </span><span class="No-Break"><span class="koboSpan" id="kobo.939.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">'all'</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.941.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.942.1">
  if (options.type === ‹all›) {
    for (const type of TYPES) {
      await generateLibrary(tree, options, type);
    }
  } else {
    await generateLibrary(tree, options, options.type);
  }</span></pre> <p><span class="koboSpan" id="kobo.943.1">The only thing</span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.944.1"> that is left to do now is to </span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.945.1">add some logic to clean up the initial component files and update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">index.ts</span></strong><span class="koboSpan" id="kobo.947.1"> file to remove the export of this initial component. </span><span class="koboSpan" id="kobo.947.2">Otherwise, if we create a library named </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">common-components</span></strong><span class="koboSpan" id="kobo.949.1">, for example, it will create a component named </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">common-components-component</span></strong><span class="koboSpan" id="kobo.951.1">, and that is not something </span><span class="No-Break"><span class="koboSpan" id="kobo.952.1">we want.</span></span></p>
<p><span class="koboSpan" id="kobo.953.1">To clean up our library, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">tree</span></strong><span class="koboSpan" id="kobo.955.1"> parameter that’s exposed to us by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">generateAngularLibraryGenerator</span></strong><span class="koboSpan" id="kobo.957.1"> function. </span><span class="koboSpan" id="kobo.957.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.958.1">tree</span></strong><span class="koboSpan" id="kobo.959.1"> object contains our monorepo tree and, in it, all our folders and files. </span><span class="koboSpan" id="kobo.959.2">To remove the initial component files and update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.960.1">index.ts</span></strong><span class="koboSpan" id="kobo.961.1"> file when we generate a library, we can add the following code at the bottom of our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">generateAngularLibraryGenerator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.963.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.964.1">
  const path = `libs/${options.domain}/${options.type}/${options.name}/src`;
  tree.delete(`${path}/lib/${options.name}`);
  tree.write(`${path}/index.ts`, ‹›);</span></pre> <p><span class="koboSpan" id="kobo.965.1">Once you’ve updated and saved everything, you can test </span><span class="No-Break"><span class="koboSpan" id="kobo.966.1">the generator.</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.967.1">Open the Nx console in VS Code. </span><span class="koboSpan" id="kobo.967.2">At the top, you will find a section </span><span class="No-Break"><span class="koboSpan" id="kobo.968.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.969.1">projects</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.970.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.971.1">Underneath this section, you will find your </span><strong class="bold"><span class="koboSpan" id="kobo.972.1">workspace-generators-plugin</span></strong><span class="koboSpan" id="kobo.973.1"> project. </span><span class="koboSpan" id="kobo.973.2">If you expand this, you will see three options: </span><strong class="bold"><span class="koboSpan" id="kobo.974.1">build</span></strong><span class="koboSpan" id="kobo.975.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.976.1">lint</span></strong><span class="koboSpan" id="kobo.977.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.978.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.979.1">test</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.980.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.981.1">When you hover over the </span><strong class="bold"><span class="koboSpan" id="kobo.982.1">build</span></strong><span class="koboSpan" id="kobo.983.1"> option, you’ll see a </span><strong class="bold"><span class="koboSpan" id="kobo.984.1">play</span></strong><span class="koboSpan" id="kobo.985.1"> button. </span><span class="koboSpan" id="kobo.985.2">Go ahead and click on this button to build the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.986.1">workspace-generators-plugin</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.987.1"> project.</span></span></li>
<li><span class="koboSpan" id="kobo.988.1">When the plugin is built successfully, restart VS Code and click on </span><strong class="bold"><span class="koboSpan" id="kobo.989.1">generate</span></strong><span class="koboSpan" id="kobo.990.1"> in your Nx console. </span><span class="koboSpan" id="kobo.990.2">You should see </span><strong class="bold"><span class="koboSpan" id="kobo.991.1">@business-tools/workspace-generators-plugin - </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.992.1">generate-angular-library generator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.993.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.994.1">You only need to </span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.995.1">restart VS Code when you </span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.996.1">add a new generator or adjust </span><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">schema.json</span></strong><span class="koboSpan" id="kobo.998.1"> because Nx schematics are loaded when you open </span><span class="No-Break"><span class="koboSpan" id="kobo.999.1">VS Code.</span></span></p>
<p><span class="koboSpan" id="kobo.1000.1">When we use the generator, there are three fields where we can enter the name, domain, and type. </span><span class="koboSpan" id="kobo.1000.2">Let’s create a library called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">common-components</span></strong><span class="koboSpan" id="kobo.1002.1"> and then select </span><strong class="bold"><span class="koboSpan" id="kobo.1003.1">shared</span></strong><span class="koboSpan" id="kobo.1004.1"> for the domain and </span><strong class="bold"><span class="koboSpan" id="kobo.1005.1">UI</span></strong><span class="koboSpan" id="kobo.1006.1"> for the type. </span><span class="koboSpan" id="kobo.1006.2">This will generate a library for us at the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">libs\shared\ui\common-components</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1008.1"> path.</span></span></p>
<p><span class="koboSpan" id="kobo.1009.1">We will also overwrite the component generator. </span><span class="koboSpan" id="kobo.1009.2">You can go ahead and try to do this yourself. </span><span class="koboSpan" id="kobo.1009.3">If it still feels challenging, you can go to this book’s GitHub repository and take the code from there (link in the </span><em class="italic"><span class="koboSpan" id="kobo.1010.1">Technical requirements</span></em><span class="koboSpan" id="kobo.1011.1"> section). </span><span class="koboSpan" id="kobo.1011.2">If you did the overwrite on your own, please check if you implemented it the same as we did so that you can continue using the same generators throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.1012.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.1013.1">With that, you know how to overwrite generators and have created your first custom generator to build Angular libraries. </span><span class="koboSpan" id="kobo.1013.2">Next, we will create project boundaries for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1014.1">Nx monorepo.</span></span></p>
<h3><span class="koboSpan" id="kobo.1015.1">Setting up project boundaries for the Angular monorepo</span></h3>
<p><span class="koboSpan" id="kobo.1016.1">When you </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.1017.1">work in a large monorepo where</span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.1018.1"> different teams work on separate projects, it is essential to have some boundaries. </span><span class="koboSpan" id="kobo.1018.2">If you have a library only intended for one domain of the monorepo, you don’t want someone to create unintended dependencies by importing that library into </span><span class="No-Break"><span class="koboSpan" id="kobo.1019.1">another domain.</span></span></p>
<p><span class="koboSpan" id="kobo.1020.1">For example, if you have a library intended for finance-related applications, you don’t want it to be imported into a marketing application and create a dependency between our finance and marketing domains. </span><span class="koboSpan" id="kobo.1020.2">What’s even worse is if someone made a direct dependency between the two applications. </span><span class="koboSpan" id="kobo.1020.3">If we do this, we have to build and deploy both applications when we only want to update and deploy one </span><span class="No-Break"><span class="koboSpan" id="kobo.1021.1">of them.</span></span></p>
<p><span class="koboSpan" id="kobo.1022.1">With Nx, we can set up boundaries with </span><strong class="bold"><span class="koboSpan" id="kobo.1023.1">tags</span></strong><span class="koboSpan" id="kobo.1024.1">. </span><span class="koboSpan" id="kobo.1024.2">The tags</span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.1025.1"> that belong to a project can be found inside its </span><strong class="source-inline"><span class="koboSpan" id="kobo.1026.1">project.json</span></strong><span class="koboSpan" id="kobo.1027.1"> file. </span><span class="koboSpan" id="kobo.1027.2">The boundaries are defined inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1028.1">.eslintrc.json</span></strong><span class="koboSpan" id="kobo.1029.1"> files. </span><span class="koboSpan" id="kobo.1029.2">We will only create global boundaries in the root </span><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">.eslintrc.json</span></strong><span class="koboSpan" id="kobo.1031.1"> file. </span><span class="koboSpan" id="kobo.1031.2">Inside this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1032.1">.eslintrc.json</span></strong><span class="koboSpan" id="kobo.1033.1"> file, you will find the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1034.1">lint rule:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1035.1">
        "@nx/enforce-module-boundaries"
          "error",
          {
            "enforceBuildableLibDependency": true,
            "depConstraints": [
              {
                "sourceTag": "*",
                "onlyDependOnLibsWithTags": ["*"]
              }
            ]
          }</span></pre> <p><span class="koboSpan" id="kobo.1036.1">You can update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1037.1">depConstraints</span></strong><span class="koboSpan" id="kobo.1038.1"> array to update the boundaries for your Nx monorepo. </span><span class="koboSpan" id="kobo.1038.2">By default, the object inside this array uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.1039.1">*</span></strong><span class="koboSpan" id="kobo.1040.1"> as a wildcard, allowing any project to import every other project. </span><span class="koboSpan" id="kobo.1040.2">I advise removing this object and setting strict project boundaries. </span><span class="koboSpan" id="kobo.1040.3">For </span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.1041.1">example, if you only want</span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.1042.1"> projects with domain finance to import other projects with the same domain, you can add this object to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1043.1">depConstraints</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1044.1"> array:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1045.1">
{
 "sourceTag": "domain:finance",
 "onlyDependOnLibsWithTags": ["domain:finance"]
}</span></pre> <p><span class="koboSpan" id="kobo.1046.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">sourceTag</span></strong><span class="koboSpan" id="kobo.1048.1"> component defines the tag we are targeting, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.1049.1">onlyDependOnLibsWithTags</span></strong><span class="koboSpan" id="kobo.1050.1"> defines the tag it is allowed to import. </span><span class="koboSpan" id="kobo.1050.2">If you want to see the constraints I configured for the monorepo, you can take them from this book’s GitHub repository, but you are free to set up the constraints however </span><span class="No-Break"><span class="koboSpan" id="kobo.1051.1">you like.</span></span></p>
<p><span class="koboSpan" id="kobo.1052.1">After you’ve </span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.1053.1">configured the boundaries, you</span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.1054.1"> will get a lint error in VS Code if you try to import something you’re not allowed to. </span><span class="koboSpan" id="kobo.1054.2">After the initial setup, you might need to restart VS Code for the boundaries to take effect without running </span><span class="No-Break"><span class="koboSpan" id="kobo.1055.1">the linter.</span></span></p>
<p><span class="koboSpan" id="kobo.1056.1">Now that we’ve improved our Nx monorepo and it is ready to host many Angular applications and libraries, let’s wrap things up by discussing a good structure for our Angular applications and libraries within </span><span class="No-Break"><span class="koboSpan" id="kobo.1057.1">our monorepo.</span></span></p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.1058.1">Structuring Angular applications and libraries</span></h2>
<p><span class="koboSpan" id="kobo.1059.1">The last thing we must cover is how </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.1060.1">to structure our Angular applications and libraries </span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.1061.1">within the Nx monorepo. </span><span class="koboSpan" id="kobo.1061.2">Seeing your applications as containers that build up their pages with the components and logic from libraries is a good practice. </span><span class="koboSpan" id="kobo.1061.3">This incentivizes a modular approach and makes it easier for you to have a good separation of concerns as a dedicated library project is a much greater boundary than separating code with folders in your application. </span><span class="koboSpan" id="kobo.1061.4">Generally speaking, you can use the 80/20 rule, where 80% of your code lives within dedicated library projects and 20% within your </span><span class="No-Break"><span class="koboSpan" id="kobo.1062.1">application projects.</span></span></p>
<p><span class="koboSpan" id="kobo.1063.1">These libraries don’t have to be built separately from the projects that consume them. </span><span class="koboSpan" id="kobo.1063.2">If that is the case, everything stays the same regarding your deployment process, but you won’t utilize Nx incremental builds and computational caching. </span><span class="koboSpan" id="kobo.1063.3">If you want to use incremental builds or publish your libraries to an external registry such as NPM, you can mark them as buildable or publishable when you generate them. </span><span class="koboSpan" id="kobo.1063.4">In our custom generator, we made the libraries buildable by default. </span><span class="koboSpan" id="kobo.1063.5">For small applications, you can consider using regular libraries that aren’t buildable unless you want to </span><span class="No-Break"><span class="koboSpan" id="kobo.1064.1">publish them.</span></span></p>
<p><span class="koboSpan" id="kobo.1065.1">Placing code in a library doesn’t necessarily mean the code has to be general purpose and must be consumed by multiple parties; putting code in an Nx library can be purely for organizational goals. </span><span class="koboSpan" id="kobo.1065.2">It stimulates you to think in a more API-driven way about your code, often resulting in cleaner implementations with fewer dependencies, which, in turn, might result in code that can be reused, but it doesn’t have to be. </span><span class="koboSpan" id="kobo.1065.3">When organizing libraries and applications, you should consider the different business domains. </span><span class="koboSpan" id="kobo.1065.4">Generally speaking, the teams of an organization are aligned with these business domains; thus, it makes sense to have a similar organization for your </span><span class="No-Break"><span class="koboSpan" id="kobo.1066.1">monorepo projects.</span></span></p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.1067.1">Do you create a new library or reuse an existing one?</span></h2>
<p><span class="koboSpan" id="kobo.1068.1">The decision of when to create a new application is pretty straightforward. </span><span class="koboSpan" id="kobo.1068.2">It should probably be an application if it’s a product with a UI that can be used or sold independently. </span><span class="koboSpan" id="kobo.1068.3">For libraries, it can sometimes be harder to define when to create a new library and when to add code to an existing library. </span><span class="koboSpan" id="kobo.1068.4">As with most programming decisions, whether to start or reuse a library is </span><span class="No-Break"><span class="koboSpan" id="kobo.1069.1">about trade-offs.</span></span></p>
<p><span class="koboSpan" id="kobo.1070.1">The main benefits</span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.1071.1"> of creating a new library and splitting up your code are that tasks such as building and testing will be completed faster, you have better visualization of your architecture with the Nx graph, and you have more control over project boundaries by using tags. </span><span class="koboSpan" id="kobo.1071.2">The advantages of reusing a library are that you can better group related code together without any constraints, so it’s easier to experiment and less prone to mistakes. </span><span class="koboSpan" id="kobo.1071.3">Especially when your code base is rapidly evolving, keeping things in one library might be easier for the time being. </span><span class="koboSpan" id="kobo.1071.4">A good practice is splitting things into multiple libraries when the development </span><span class="No-Break"><span class="koboSpan" id="kobo.1072.1">pace slows.</span></span></p>
<p><span class="koboSpan" id="kobo.1073.1">Libraries are generally divided into UI, feature, utility, and data-access libraries. </span><span class="koboSpan" id="kobo.1073.2">Your UI libraries should only contain dumb presentational components. </span><span class="koboSpan" id="kobo.1073.3">Feature libraries contain smart components with access to your facade services and are created for business cases or pages within the applications. </span><span class="koboSpan" id="kobo.1073.4">The data-access libraries house state management logic and provide everything to communicate with the back-end APIs. </span><span class="koboSpan" id="kobo.1073.5">Lastly, we have the utility libraries, which host helper functions and other useful </span><span class="No-Break"><span class="koboSpan" id="kobo.1074.1">low-level utilities.</span></span></p>
<p><span class="koboSpan" id="kobo.1075.1">All your libraries should be grouped by their respective application or a business domain containing multiple applications. </span><span class="koboSpan" id="kobo.1075.2">For large companies, the libraries can be grouped by sections of a specific business domain, depending on how the scope of each domain is defined. </span><span class="koboSpan" id="kobo.1075.3">When you want to move an application or library into a new folder within your Nx monorepo, you need to use the Nx </span><strong class="source-inline"><span class="koboSpan" id="kobo.1076.1">move</span></strong><span class="koboSpan" id="kobo.1077.1"> generator by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.1078.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1079.1">
nx g move --project some-library target/folder/path</span></pre> <p><span class="koboSpan" id="kobo.1080.1">If you want to remove an application or library, you should use the Nx </span><strong class="source-inline"><span class="koboSpan" id="kobo.1081.1">remove</span></strong><span class="koboSpan" id="kobo.1082.1"> generator, </span><span class="No-Break"><span class="koboSpan" id="kobo.1083.1">like so:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1084.1">
nx g remove some-project-name</span></pre> <p><span class="koboSpan" id="kobo.1085.1">For both moving and removing projects, you can use the Nx console for a more visual approach. </span><span class="koboSpan" id="kobo.1085.2">It is important to use the Nx console or run the respective Nx command in the terminal to perform these actions because they will automatically update all configuration files within your </span><span class="No-Break"><span class="koboSpan" id="kobo.1086.1">Nx monorepo.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1087.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1088.1">.5</span></em><span class="koboSpan" id="kobo.1089.1"> shows a proposed folder structure, although this is entirely up to you and the structure and needs of what </span><span class="No-Break"><span class="koboSpan" id="kobo.1090.1">you’re building:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<span class="koboSpan" id="kobo.1091.1"><img alt="Figure 1.5: Folder structure" src="image/B21625_01_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1092.1">Figure 1.5: Folder structure</span></p>
<p><span class="koboSpan" id="kobo.1093.1">Before moving on to the next chapter, let’s clean up our monorepo and add some placeholder projects. </span><span class="koboSpan" id="kobo.1093.2">First, remove the invoicing application we made earlier and its corresponding e2e project. </span><span class="koboSpan" id="kobo.1093.3">You can do this by right-clicking on the project and selecting </span><strong class="bold"><span class="koboSpan" id="kobo.1094.1">Remove Nx project</span></strong><span class="koboSpan" id="kobo.1095.1">. </span><span class="koboSpan" id="kobo.1095.2">This will open an Nx console window for removing projects. </span><span class="koboSpan" id="kobo.1095.3">In the dropdown, you can choose the project you want to remove. </span><span class="koboSpan" id="kobo.1095.4">First, remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1096.1">invoicing-e2e</span></strong><span class="koboSpan" id="kobo.1097.1"> project; then, remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">invoicing</span></strong><span class="koboSpan" id="kobo.1099.1"> project. </span><span class="koboSpan" id="kobo.1099.2">Once you’ve removed both projects, we can create some placeholder applications with the custom application generator we took from this book’s </span><span class="No-Break"><span class="koboSpan" id="kobo.1100.1">GitHub repository.</span></span></p>
<p><span class="koboSpan" id="kobo.1101.1">Create the </span><span class="No-Break"><span class="koboSpan" id="kobo.1102.1">following projects:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1103.1">expenses-registration</span></strong><span class="koboSpan" id="kobo.1104.1"> (under the </span><span class="No-Break"><span class="koboSpan" id="kobo.1105.1">domain finance)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1106.1">social-media-dashboard</span></strong><span class="koboSpan" id="kobo.1107.1"> (under the </span><span class="No-Break"><span class="koboSpan" id="kobo.1108.1">domain marketing)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1109.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1110.1">placeholder</span></strong><span class="koboSpan" id="kobo.1111.1"> library we created can stay because it is already equipped with tags and a domain and was created with a custom generator. </span><span class="koboSpan" id="kobo.1111.2">We will create extra libraries as we continue and start to add </span><span class="No-Break"><span class="koboSpan" id="kobo.1112.1">some code.</span></span></p>
<h1 id="_idParaDest-32"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.1113.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1114.1">In this chapter, you created an Nx monorepo with some placeholder projects and are now ready to scale to hundreds of applications. </span><span class="koboSpan" id="kobo.1114.2">You learned how to structure your Angular applications and libraries within the monorepo, and now know how to utilize the essential features </span><span class="No-Break"><span class="koboSpan" id="kobo.1115.1">of Nx.</span></span></p>
<p><span class="koboSpan" id="kobo.1116.1">In the next chapter, we will explore some of the newest and most powerful features in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1117.1">Angular framework.</span></span></p>
</div>
</body></html>