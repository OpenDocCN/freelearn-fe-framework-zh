- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Going Beyond
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越
- en: Our application is finally in production. It might be getting some users as
    we speak. However, as with every piece of software, our application may never
    be fully completed. There is always room for improvement, and since the application
    we built is just an MVP, there are a lot of potential improvements worth mentioning.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序最终投入生产。可能在我们说话的时候，它已经有了用户。然而，就像每一件软件一样，我们的应用程序可能永远不会完全完成。总有改进的空间，而且由于我们构建的应用程序只是一个MVP，有很多潜在的改进值得提及。
- en: In this chapter, we will be covering some of the most important improvements
    from both feature and technical perspectives. These topics might give us some
    ideas on extending and improving the existing application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖从功能和技术角度的一些最重要的改进。这些主题可能会给我们一些关于扩展和改进现有应用程序的想法。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Feature improvements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能改进
- en: Technical improvements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术改进
- en: Appendix
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附录
- en: By the end of this chapter, we will have covered some features we can add to
    the existing application to make it more complete. We will also mention some topics
    that were not covered in this book but are worth exploring on your own.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将介绍一些可以添加到现有应用程序中的功能，使其更加完整。我们还将提及一些本书未涉及但值得自己探索的主题。
- en: Feature improvements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能改进
- en: Since our application is at the MVP stage at the moment, there are many potential
    improvements from the user’s perspective that would make the application more
    usable.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序目前处于MVP阶段，从用户的角度来看，有许多潜在的改进可以使应用程序更加易用。
- en: Jobs feature improvements
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作功能改进
- en: 'The jobs feature is the most important feature of this app. There are several
    improvements we can implement to make the application better:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 工作功能是本应用最重要的功能。我们可以实施一些改进来使应用程序变得更好：
- en: Updating jobs
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新工作
- en: Adding jobs in a draft state
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以草稿状态添加工作
- en: Deleting jobs
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除工作
- en: Adding/updating jobs information with markdown/the *WYSIWYG* editor
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用markdown/ *WYSIWYG* 编辑器添加/更新工作信息
- en: Updating jobs
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新工作
- en: Right now, our application only supports job creation. What happens when we
    want to change some information about the given job posting? It would be great
    if we could edit job data after it’s been created.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序仅支持工作创建。当我们想要更改给定职位发布的信息时会发生什么？如果在创建后能够编辑工作数据，那将非常棒。
- en: 'Here is how we can do that:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们如何做到这一点的说明：
- en: Create the *update* endpoint handler at `PATCH /jobs/:jobId`, which will update
    the data in the database
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `PATCH /jobs/:jobId` 创建 *更新* 端点处理程序，该处理程序将更新数据库中的数据
- en: Create the *update job* page at `/dashboard/jobs/:jobId/update`, which is where
    the update form should be
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `/dashboard/jobs/:jobId/update` 创建 *更新工作* 页面，这是更新表单应该放置的地方
- en: Create the *update* form with all the fields that we want to be able to update
    for a job
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 *更新* 表单，包含我们想要能够更新工作所需的所有字段
- en: Upon successful submission, we should invalidate the job query so that its data
    gets refetched
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在成功提交后，我们应该使工作查询无效，以便重新获取其数据
- en: Adding jobs in a draft state
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以草稿状态添加工作
- en: Currently, when we create a job for our organization, it will become immediately
    available to the public. However, it would be great if we could extend its functionality
    so that we can choose when we want to publish job postings to the public.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，当我们为我们的组织创建一个工作，它将立即对公众可用。然而，如果我们能扩展其功能，以便我们可以选择何时将职位发布给公众，那将非常棒。
- en: 'This can be done by doing the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下方式完成：
- en: Extending the job model with the `status` property.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `status` 属性扩展工作模型。
- en: Setting the `status` value to `draft` or `published`.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `status` 值设置为 `draft` 或 `published`。
- en: When submitting the job creation form, the newly created job will initially
    have a `status` of `draft`.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在提交工作创建表单时，新创建的工作将最初具有 `draft` 状态。
- en: Then, we could update the status of the job via the *update* form, where we
    send the desired status as a value. Another way we could do this would be to expose
    a separate endpoint that would only update the status of the job.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们可以通过 *更新* 表单更新工作的状态，在那里我们发送期望的状态作为值。另一种我们可以做到的方法是公开一个单独的端点，该端点只会更新工作的状态。
- en: Deleting jobs
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除工作
- en: Most of the time, job positions get closed. In that case, no one wants a job
    posting that is no longer relevant, so it might be a good idea to allow organization
    admins to delete jobs they don’t find relevant anymore.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，职位空缺会被关闭。在这种情况下，没有人想要一个不再相关的职位发布，因此允许组织管理员删除不再相关的职位可能是个好主意。
- en: 'This can be done in two ways:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过两种方式实现：
- en: Having a *Delete* endpoint that will handle deleting the job from the database.
    Clicking on a button would send the request and, on a successful request, redirect
    the user to the jobs list.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个*删除*端点，将处理从数据库中删除职位。点击按钮会发送请求，在请求成功的情况下，将用户重定向到职位列表。
- en: Extending the `status` property, which could now have an additional `archived`
    or `deleted` value. This method is called **soft delete** because we are not deleting
    the entry from the database, but from the application’s perspective, it looks
    as if it was deleted. Archiving job postings might be useful for tracking different
    stats from previous hires.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展`status`属性，现在它可能具有额外的`archived`或`deleted`值。这种方法被称为**软删除**，因为我们并没有从数据库中删除条目，但从应用程序的角度来看，它看起来就像被删除了。存档职位发布可能有助于跟踪以前招聘的不同统计数据。
- en: Adding/updating jobs information with markdown/the WYSIWYG editor
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Markdown/WYSIWYG编辑器添加/更新职位信息
- en: Currently, the job information is filled with a `textarea` input field, which
    is convenient for plain text values. However, the admin’s ability to add as much
    information as possible is limited to text only.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，职位信息是通过`textarea`输入字段填充的，这对于纯文本值来说很方便。然而，管理员添加尽可能多的信息的能力仅限于文本。
- en: It would be great if we could allow admins to add things, such as different
    headers, lists, links, and so on, to the job information so that the job posting
    provides as much information as possible.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够允许管理员添加诸如不同的标题、列表、链接等内容到职位信息中，那么职位发布将提供尽可能多的信息。
- en: The solution would be to replace the `textarea` input field with a rich text
    editor, which would allow us to add more than just text. Just make sure that you
    sanitize the inputs before submitting them to keep the application as safe as
    possible.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将`textarea`输入字段替换为富文本编辑器，这将使我们能够添加不仅仅是文本的内容。只需确保在提交之前对输入进行清理，以使申请尽可能安全。
- en: Organization improvements
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织改进
- en: Currently, there is no way for the organization admin to update the organization’s
    information. The organization should be able to change any of the information
    at any time.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，组织管理员无法更新组织信息。组织应该能够随时更改任何信息。
- en: 'To make this possible, we can do the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们可以做以下事情：
- en: Create the endpoint for updating the organization at `PATCH /organizations/:organizationId`
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`PATCH /organizations/:organizationId`创建更新组织的端点
- en: Create a page at `/dashboard/organization/update` where we can have the update
    form
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`/dashboard/organization/update`创建一个页面，我们可以在这里填写更新表单
- en: Adding job applications
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加职位申请
- en: One more thing we can improve is the ability to add job applications.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以改进的一点是添加职位申请的能力。
- en: Currently, there is no mechanism to apply to jobs directly in the application.
    When the user clicks the **Apply** button, the email client is opened with the
    correctly set subject. Then, the user would send an email to the organization’s
    email address, and that would be the entire flow.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，没有直接在应用程序中申请职位的机制。当用户点击**申请**按钮时，电子邮件客户端会打开，并设置正确的主题。然后，用户会向组织的电子邮件地址发送电子邮件，这就是整个流程。
- en: To take it to the next level, we can create another entity called *Application*
    that will be submitted when the user applies for a job. This approach will allow
    admins to track job applications for their organizations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其提升到下一个层次，我们可以创建另一个名为*Application*的实体，当用户申请工作时将提交此实体。这种方法将允许管理员跟踪其组织的职位申请。
- en: 'Let’s rethink what the data model of the application will look like with this
    new feature:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新思考一下，使用这个新功能，应用程序的数据模型将看起来是什么样子：
- en: '![Figure 10.1 – Applications in the data model ](img/B17297_10_01.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 数据模型中的应用](img/B17297_10_01.jpg)'
- en: Figure 10.1 – Applications in the data model
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 数据模型中的应用
- en: As we can see, an application should contain some basic information about the
    candidate, a message, a report from the interviewer, and so on.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，申请应包含有关候选人的基本信息、一条消息、面试官的报告等等。
- en: 'Once the data model has been updated, we can build the applications feature,
    which will handle all things related. This would include things such as the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据模型被更新，我们可以构建应用程序功能，这将处理所有相关事务。这包括以下内容：
- en: Endpoints for creating and browsing applications.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和浏览应用的端点。
- en: Pages on the dashboard where the admins can browse through all the applications.
    They can be defined at `/dashboard/applications` and `/dashboard/applications/:applicationId`
    for the listing and details pages, respectively.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪表板上的页面，管理员可以浏览所有应用。它们可以定义为 `/dashboard/applications` 和 `/dashboard/applications/:applicationId`，分别对应列表和详情页面。
- en: Filtering and paginating lists of data
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤和分页数据列表
- en: Displaying lists of data in tables is fine, but what happens when the number
    of entries starts to grow significantly? It is not very optimal to load all the
    entries in one go because not all entries might be needed in the first place.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在表格中显示数据列表是好的，但当条目数量开始显著增长时会发生什么？一次性加载所有条目并不是很优化，因为一开始可能并不需要所有条目。
- en: To optimize data lists, we can add support for filtering and paginating data.
    This will help users narrow down the search results to what they need. Both filtering
    and paginating should happen on the server.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化数据列表，我们可以添加对过滤和分页数据的支持。这将帮助用户缩小搜索结果，以满足他们的需求。过滤和分页都应该在服务器上发生。
- en: Tracking current filter and pagination values should be handled by URL parameters.
    This will make it easy for the application to deep link the search results for
    any further usage.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 应该通过URL参数处理当前筛选和分页值。这将使应用程序能够轻松地深度链接搜索结果以供进一步使用。
- en: Adding user registration
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加用户注册
- en: 'This one is pretty straightforward. Until now, we have relied on test data,
    which had one test user that we used to sign in to the dashboard. However, there
    is no way to register new users. If we want to make this application usable by
    more than one organization, we should add this functionality. This can be implemented
    by doing the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点相当直接。到目前为止，我们一直依赖于测试数据，其中有一个测试用户，我们用它来登录仪表板。然而，没有方法可以注册新用户。如果我们想使这个应用程序被多个组织使用，我们应该添加这个功能。这可以通过以下方式实现：
- en: Creating the registration endpoint at POST `/auth/register`, which would take
    the required data from a form and create a user and its corresponding organization
    in the database
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 POST `/auth/register` 上创建注册端点，它将从表单中获取所需数据并创建用户及其对应组织在数据库中的记录
- en: Create the registration page at `/auth/register`, where there is the registration
    form which, when submitted, calls the registration endpoint
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `/auth/register` 创建注册页面，其中包含注册表单，提交后调用注册端点
- en: Technical improvements
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术改进
- en: Our application is in good shape, but several things should be kept in mind
    in case the application starts growing. Let’s take a look.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用状态良好，但在应用开始增长时，有几件事情应该牢记在心。让我们看看。
- en: Server-side rendering and caching
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端渲染和缓存
- en: There are several improvements we can make to further optimize how the public
    pages are rendered on the server.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步优化如何在服务器上渲染公共页面，我们可以做出以下改进。
- en: Currently, we are rendering the pages on each request, which is good if the
    data changes frequently; otherwise, it might increase the loading time and server
    costs because rendering on the server is a compute-intensive operation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在每个请求上渲染页面，如果数据频繁更改，这是好的；否则，它可能会增加加载时间和服务器成本，因为服务器上的渲染是一个计算密集型操作。
- en: Fortunately, Next.js supports another rendering strategy called **Incremental**
    **Static Regeneration**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Next.js 支持另一种名为 **增量** **静态重新生成** 的渲染策略。
- en: 'It works as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式如下：
- en: '*User1* requests a page.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*用户1* 请求一个页面。'
- en: The server returns the cached version of the page and returns it.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器返回缓存的页面版本并将其返回。
- en: During that request, Next.js is triggered to regenerate the same page with the
    latest data.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那次请求期间，Next.js 被触发以使用最新数据重新生成相同的页面。
- en: '*User2* requests a page.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*用户2* 请求一个页面。'
- en: The server returns the new version of the page.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器返回页面的新版本。
- en: If we take our public job details page as an example, it will work as follows.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的公共工作详情页面为例，它的工作方式如下。
- en: 'First, we would need to use `getStaticPaths` to generate all the paths for
    all the jobs:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用 `getStaticPaths` 来生成所有工作的所有路径：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will generate a list of paths for all the jobs that exist in the database.
    The key thing here is the `fallback` property, which will make Next.js not return
    the 404 page but try to generate a new one.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为数据库中存在的所有作业生成路径列表。这里的关键是`fallback`属性，它将使Next.js不返回404页面，而是尝试生成一个新的页面。
- en: 'We must also replace `getServerSideProps` with `getStaticProps`, which would
    look something like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须将`getServerSideProps`替换为`getStaticProps`，其外观可能如下所示：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice how we can add the `revalidate` property to the `return` value. This
    will force the page to revalidate after 60 seconds.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何可以将`revalidate`属性添加到`return`值中。这将强制页面在60秒后重新验证。
- en: Since jobs and organizations’ data don’t change very frequently, this rendering
    strategy sounds more optimal in the long run, especially once the number of requests
    starts to grow.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于作业和组织的数据变化不是很频繁，这种渲染策略从长远来看听起来更优，尤其是在请求数量开始增加之后。
- en: It makes for a good compromise between the performance and freshness of the
    data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这在性能和数据新鲜度之间提供了一个良好的折衷方案。
- en: React Query hydration for SSR
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React Query的SSR解冻
- en: Currently, we are using React Query for handling data fetching on the client,
    but data fetching on the server is being handled without it. We are just fetching
    the data and passing and rendering it on the page. This is fine if we don’t have
    many levels of components, but there is a better way to do this.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在使用React Query来处理客户端的数据获取，但服务器端的数据获取则没有使用它。我们只是在页面上获取数据并传递和渲染它。如果我们没有很多层级的组件，这没问题，但还有更好的方法来做这件事。
- en: 'React Query supports two ways of fetching data on the server and passing it
    to the client:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: React Query支持两种在服务器上获取数据并将其传递到客户端的方式：
- en: Fetching the data on the server and then passing it as `initialData` to the
    query
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上获取数据，然后将其作为`initialData`传递给查询
- en: Prefetching on the server, dehydrating the cache, and rehydrating it on the
    client
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上预取，解冻缓存，并在客户端重新解冻
- en: The first option is good for smaller apps where there is not a very large hierarchy
    between the component, so there is no need to pass the server data down multiple
    levels to the desired query.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方案适用于较小型的应用，其中组件之间没有非常复杂的层次结构，因此没有必要将服务器数据向下传递多个层级到所需的查询。
- en: The second option might take more initial setup, but in the end, it makes the
    code base much simpler.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方案可能需要更多的初始设置，但最终会使代码库变得更加简单。
- en: 'In the `pages/_app.tsx` file, we should wrap anything that is inside `QueryClientProvider`
    with `Hydrate`, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pages/_app.tsx`文件中，我们应该将`QueryClientProvider`内部的任何内容都包裹在`Hydrate`中，如下所示：
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will prepare the application to process any dehydrated state. But how do
    we provide a dehydrated state to the page?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使应用程序准备好处理任何解冻状态。但我们如何向页面提供解冻状态呢？
- en: 'On a specific page, we can modify `getStaticProps` or `getServerSideProps`
    as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定页面上，我们可以修改`getStaticProps`或`getServerSideProps`，如下所示：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we can consume the jobs as we would if we were fetching them on the client:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以像在客户端获取它们一样消费作业：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will make it much easier to handle all the server states with React Query.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使使用React Query处理所有服务器状态变得更加容易。
- en: Using query key factories
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用查询键工厂
- en: Having many queries all over the app might get pretty difficult to manage once
    the number of queries starts to grow. It is hard to track all the variations of
    the queries and where they are being used. Preventing duplicate query keys might
    be one of the problems as well.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当查询的数量开始增加时，整个应用中遍布许多查询可能会变得难以管理。跟踪所有查询的变体及其使用位置可能很困难。防止重复查询键可能也是一个问题。
- en: That’s why we should think about using query key factories instead of just deliberately
    adding the query keys all over the place.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们应该考虑使用查询键工厂而不是故意在各个地方添加查询键。
- en: 'We can define all potential keys in `src/lib/react-query.ts`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`src/lib/react-query.ts`中定义所有潜在键：
- en: 'First, we can define a simplified version of the factory:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以定义工厂的简化版本：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we can create the keys for the queries:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以为查询创建键：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, not all the features have the same key structure, but we can
    combine different factories to create what we need.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，并非所有功能都具有相同的键结构，但我们可以结合不同的工厂来创建所需的内容。
- en: 'Then, if we wanted to use a key in a query, we could do so as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们想在查询中使用一个键，可以这样做：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What is good with this approach is that we have a centralized overview of all
    the keys, which reduces the possibility of making mistakes by mistyping a key
    or something similar.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是我们对所有密钥有一个集中的概览，这减少了因误输入密钥或类似情况而犯错的概率。
- en: This was an example of a simplified query key factory. If you need a more robust
    solution, there is a great library for this that can be found at [https://www.npmjs.com/package/@lukemorales/query-key-factory](https://www.npmjs.com/package/@lukemorales/query-key-factory).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简化查询密钥工厂的例子。如果您需要一个更健壮的解决方案，有一个非常好的库可以在[https://www.npmjs.com/package/@lukemorales/query-key-factory](https://www.npmjs.com/package/@lukemorales/query-key-factory)找到。
- en: Code scaffolding
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码脚手架
- en: 'When looking at our application, we might notice that there is some level of
    boilerplate. Creating components, for example, requires a folder that looks like
    this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看我们的应用程序时，我们可能会注意到存在一定程度的样板代码。例如，创建组件需要这样一个文件夹：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We must remember to re-export the component from `index.ts` to make it available.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住从`index.ts`重新导出组件，使其可用。
- en: The same thing can be said for API requests. We need to create the request function
    and then the hook that consumes it. These things can be automated with tools that
    can help us generate these kinds of files easier via their CLI.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于API请求也可以这么说。我们需要创建请求函数，然后是消费它的钩子。这些事情可以通过帮助我们通过CLI更容易生成这些类型文件的工具来自动化。
- en: Having some scaffolding tools such as Plop.js and Hygen.io also brings better
    consistency to the code base.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一些脚手架工具，如Plop.js和Hygen.io，也给代码库带来了更好的一致性。
- en: Validating form inputs and API responses with Zod
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Zod验证表单输入和API响应
- en: Let’s talk briefly about validation. With validation, we want to make sure the
    data is in the expected form. For our application, we can validate form inputs
    and API responses.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地谈谈验证。通过验证，我们想确保数据处于预期的形式。对于我们的应用程序，我们可以验证表单输入和API响应。
- en: For validation, we can use Zod, which is a great validation library that is
    TypeScript-first. This means that we can define a schema out of which we can infer
    types we can use.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于验证，我们可以使用Zod，这是一个以TypeScript为先的出色验证库。这意味着我们可以定义一个模式，从中我们可以推断出我们可以使用的类型。
- en: Form input validation
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表单输入验证
- en: 'The `react-hooks-form` library comes with great support for Zod, which we could
    utilize for this. Taking the current login form, we could modify it so that it
    looks like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-hooks-form`库为Zod提供了很好的支持，我们可以利用它来做这件事。以当前的登录表单为例，我们可以修改它使其看起来像这样：'
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we are creating an object schema and providing that to `useForm` with
    the help of `yupResolver`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们正在创建一个对象模式，并借助`yupResolver`将其提供给`useForm`。
- en: This will make sure the form will never be submitted unless all the fields have
    valid values.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保表单只有在所有字段都有有效值的情况下才会提交。
- en: API requests validation
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API请求验证
- en: 'We do have TypeScript types in place, but they don’t protect us from runtime
    errors. That’s why we should consider validating API responses in some cases.
    Let’s take a look at the following example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实有TypeScript类型，但它们不能保护我们免受运行时错误的影响。这就是为什么在某些情况下我们应该考虑验证API响应。让我们看看以下例子：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since Zod is a TypeScript-first library, we can use it to infer the types of
    the given object’s shape:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Zod是一个以TypeScript为先的库，我们可以用它来推断给定对象的形状类型：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This might help with reducing duplicate type definitions. Finally, we can validate
    our requests, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有助于减少重复的类型定义。最后，我们可以按照以下方式验证我们的请求：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If any of the job properties do not match the schema, Zod will throw a runtime
    error, which we can then handle properly.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何作业属性与模式不匹配，Zod将抛出一个运行时错误，然后我们可以妥善处理。
- en: Next.js 13
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Next.js 13
- en: 'Next.js 13 is around the corner! It was released recently with some big changes,
    including the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 13即将到来！它最近发布，带来了一些重大变化，包括以下内容：
- en: A new routing system with the app folder
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有应用文件夹的新路由系统
- en: Server components
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器组件
- en: A new data fetching approach
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的数据获取方法
- en: It’s worth noting that it is backward compatible with older versions, so it
    allows incremental upgrades. It might take some time for everything to get polished
    out, but it is worth keeping an eye on it and upgrading to the new approach at
    some point.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，它与旧版本向后兼容，因此它允许增量升级。可能需要一些时间来完善所有内容，但值得关注，并在某个时候升级到新方法。
- en: Appendix
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: There are a couple of topics that are not directly related to the application
    we built, but they are worth mentioning.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个主题与我们所构建的应用程序没有直接关系，但它们值得提及。
- en: GraphQL
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL
- en: Having a GraphQL API is a very common thing nowadays, especially in a microservices
    architecture. We worked with a REST API in our application, but how would we structure
    our API layer if it were a GraphQL API?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今，拥有GraphQL API是非常普遍的，尤其是在微服务架构中。我们在我们的应用程序中使用了REST API，但如果它是GraphQL API，我们将如何构建我们的API层？
- en: Well, the implementation would be very similar. We could choose to use a different
    library, such as Apollo, but we will stick with React Query.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，实现将非常相似。我们可以选择使用不同的库，例如Apollo，但我们将坚持使用React Query。
- en: 'Look at the following request:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 看以下请求：
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, first, we are defining the GraphQL query, which we then use
    to define the request function. Finally, we use the request function to create
    the `useJobs` hook.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，首先，我们定义了GraphQL查询，然后我们使用它来定义请求函数。最后，我们使用请求函数来创建`useJobs`钩子。
- en: Monorepos
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单仓库
- en: 'A **monorepo** is a Git repository that contains more than one project with
    a clearly defined relationship between those projects. This means that a good
    monorepo setup should provide the following features:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**单仓库**是一个包含多个项目且这些项目之间有明确关系的Git仓库。这意味着一个好的单仓库设置应该提供以下功能：'
- en: Easy code sharing between projects
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目间易于代码共享
- en: Project constraints and visibility
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目约束和可见性
- en: Computation caching
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算缓存
- en: Clear boundaries of the projects
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目清晰的边界
- en: It is worth exploring monorepos because they are being used in some of the largest
    software projects and make such large projects easier to manage.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 值得探索单仓库，因为它们被用于一些最大的软件项目中，并使这些大型项目更容易管理。
- en: 'Some of the most popular monorepo tools are as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最受欢迎的单仓库工具有以下：
- en: Lerna
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lerna
- en: Nx
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nx
- en: Turborepo
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Turborepo
- en: Yarn workspaces
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yarn工作空间
- en: Micro frontend architecture
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微前端架构
- en: '**Micro frontend** architecture is a very interesting concept. It means that
    we can build and deploy components of the application as separate applications,
    and they would look and feel as if they were part of the same application.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**微前端**架构是一个非常有趣的概念。这意味着我们可以将应用程序的组件作为独立的应用程序构建和部署，它们看起来和感觉就像它们是同一应用程序的一部分。'
- en: 'Some of the benefits of using this kind of architecture are as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种架构的一些好处如下：
- en: Useful when working on a platform that has many different teams.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在一个拥有许多不同团队的平台工作时很有用。
- en: Does not constrain the apps to a specific technology. Each micro frontend application
    can have a different stack, and they would work together really well.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不限制应用程序使用特定的技术。每个微前端应用程序都可以有不同的堆栈，并且它们可以真正地很好地协同工作。
- en: 'However, there are also some drawbacks:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也有一些缺点：
- en: Building micro frontend architectures with different technologies, even though
    it’s possible, should be discouraged. It is best to choose one framework and create
    standards for how the applications are built.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管使用不同的技术构建微前端架构是可能的，但应该予以劝阻。最好选择一个框架，并制定应用程序构建的标准。
- en: Micro frontend architecture requires much more complex tooling, which for most
    of the use cases might not be worth it.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微前端架构需要更复杂的工具，对于大多数用例来说可能并不值得。
- en: 'A couple of tools to explore are as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一些值得探索的工具如下：
- en: Module Federation
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块联邦
- en: Single SPA
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单SPA
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through the rest of the topics that are worth exploring
    after finishing this book. Things such as feature improvements and technical improvements
    can take your application to the next level. Hopefully, you can take what you
    have learned here and apply it to a similar real-world scenario.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们探讨了在完成这本书之后值得探索的其他主题。比如功能改进和技术改进可以将您的应用程序提升到下一个层次。希望您能将在这里学到的知识应用到类似的真实世界场景中。
