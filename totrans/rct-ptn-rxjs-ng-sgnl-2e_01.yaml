- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Diving into the Reactive Paradigm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive patterns are reusable solutions to a commonly occurring problem using
    reactive programming. Behind all these patterns is a new way of thinking, a new
    architecture, new coding styles, and new tools. That’s what this entire book is
    based on – useful reactive patterns in Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Now, I know you are impatient to write your first reactive pattern in Angular,
    but before doing so, and in order to help you take full advantage of all the RxJS
    patterns and leverage the reactive paradigm, we will start by explaining in detail
    all the fundamentals and preparing the groundwork for the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a basic understanding of the reactive paradigm, its advantages,
    and the problems it solves. Best of all, let’s put a reactive mindset on and start
    thinking reactively. We will begin by highlighting the pillars and the advantages
    of the reactive paradigm. Then, we will explain the marble diagram and why it
    is useful. Finally, we will highlight the use of RxJS in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Giving an insight into the fundamentals of the reactive paradigm is incredibly
    important. This will ensure you get the basics right, help you understand the
    usefulness of the reactive approach, and consequently help you determine which
    situation is best to use it in.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the pillars of reactive programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the marble diagram (our secret weapon)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highlighting the use of RxJS in Angular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter does not require any environment setup or installation steps.
  prefs: []
  type: TYPE_NORMAL
- en: All the code snippets in this chapter are just examples to illustrate the concept,
    so you will not need the code repository to follow along. However, if you’re interested,
    the code for the book can be found at [https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: This book assumes that you have a basic understanding of Angular and RxJS.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This book uses the new Angular documentation site, [angular.dev](http://angular.dev).
    The previous documentation site, [angular.io](http://angular.io), will soon be
    deprecated. Stay connected with the latest updates and resources by accessing
    the documentation through this link.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the pillars of reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Reactive programming** is among the major programming paradigms used by developers
    worldwide. Every programming paradigm solves some problems and has its own advantages.
    By definition, reactive programming is programming with asynchronous data streams
    and is based on observer patterns. So, let’s talk about these pillars of reactive
    programming!'
  prefs: []
  type: TYPE_NORMAL
- en: Data streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Data streams** are the spine of reactive programming. Everything that may
    change or happen over time (you don’t know when exactly) is represented as asynchronous
    streams such as events, notifications, and messages. Reactive programming is about
    reacting to changes as soon as they are emitted!'
  prefs: []
  type: TYPE_NORMAL
- en: 'An excellent example of data streams is UI events. Let’s suppose that we have
    an HTML button and we want to execute an action whenever a user clicks on it.
    Here, we can think of the click event as a stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As implemented in the preceding code snippet, in order to react to the click
    event, we register an `EventListener` event. Then, every time a click occurs,
    the `processClick` method is called to execute a side effect. In our case, we
    are just logging `Hi` in the console.
  prefs: []
  type: TYPE_NORMAL
- en: As you might have gathered, to be able to react when something happens and execute
    a side effect, you should listen to the streams to become notified. To get closer
    to reactive terminology, instead of *listen*, we can say *observe*. This leads
    us to the *observer* design pattern, which is at the heart of reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: Observer patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **observer pattern** is based on two main roles – a publisher and a subscriber:'
  prefs: []
  type: TYPE_NORMAL
- en: A **publisher** maintains a list of subscribers and notifies them or propagates
    a change every time there is an update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, a **subscriber** performs an update or executes a side effect
    every time they receive a notification from the publisher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The observer pattern is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – The observer pattern](img/B21180_01_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – The observer pattern
  prefs: []
  type: TYPE_NORMAL
- en: To get notified about the updates, you need to subscribe to the publisher. A
    real-world analogy would be a newsletter; you don’t get any emails from a specific
    newsletter if you don’t subscribe to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads us to the building blocks of RxJS, which include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Observables**: These are a representation of the asynchronous data streams
    that notify the observers of any change'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observers**: These are consumers of the data streams emitted by Observables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RxJS combines the observer pattern with the iterator pattern and functional
    programming to process and handle asynchronous events. This was a reminder of
    reactive programming fundamentals, and it is crucial to know when to put a reactive
    implementation in place and when to avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, whenever you have to handle asynchronous tasks in your Angular
    application, always think of RxJS. The main advantages of RxJS over other asynchronous
    APIs are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: RxJS makes dealing with event-based programs, asynchronous data calls, and callbacks
    an easy task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observables guarantee consistency. They emit multiple values over time so that
    you can consume continuous data streams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observables are lazy; they are not executed until you subscribe to them. This
    helps with writing declarative code that is clean, efficient, and easy to understand
    and maintain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observables can be canceled, completed, and retrieved at any moment. This makes
    a lot of sense in many real-world scenarios.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RxJS provides many operators with a functional style to manipulate collections
    and optimize side effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observables push errors to the subscribers and provide a clean way to handle
    errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RxJS allows you to write clean and efficient code to handle asynchronous data
    in your application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have given some insight into the reactive programming pillars and
    detailed the major advantages of RxJS, let’s explore the marble diagram, which
    is very handy for understanding and visualizing the Observable execution.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the marble diagram (our secret weapon)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RxJS ships with more than one hundred **operators** – these are among the building
    blocks of RxJS, useful for manipulating streams. All the reactive patterns that
    will be detailed later in this book are based on operators, and when it comes
    to explaining operators, it is better to refer to a visual representation – that’s
    where marble diagrams come in!
  prefs: []
  type: TYPE_NORMAL
- en: '**Marble diagrams** are visual representations of the operator’s execution,
    which will be used in all chapters to understand the behavior of RxJS operators.
    At first, it might seem daunting, but it is delightfully simple. You only have
    to understand the anatomy of the diagram and then you’ll be good at reading and
    translating it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Marble diagrams represent the execution of an operator, so every diagram will
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Input Observable(s)**: Represents one or many Observables given as input
    to the operator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operator**: Represents the operator to be executed with its parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output Observable**: Represents the Observable produced after the operator’s
    execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see the execution illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – The operator execution](img/B21180_01_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – The operator execution
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s zoom in on the representation of the input/output Observables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – The marble diagram elements](img/B21180_01_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – The marble diagram elements
  prefs: []
  type: TYPE_NORMAL
- en: 'The elements of these diagrams include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The timeline**: Observables are asynchronous streams that produce data over
    time. Therefore, the representation of time is crucial in the marble diagram,
    and it is represented as an arrow flowing from left to right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The marble values**: These are the values emitted by the Observables over
    time. They are represented by colored circles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The completion status**: The vertical line (|) represents the successful
    completion of the Observables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The error status**: The **X** represents an error emitted by the Observable.
    Neither the values nor the vertical line representing completion will be emitted
    thereafter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That’s all the elements you need to know about. Now, let’s put all the pieces
    together in a real marble diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – An example of a marble diagram for a custom operator](img/B21180_01_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – An example of a marble diagram for a custom operator
  prefs: []
  type: TYPE_NORMAL
- en: As you may have guessed, we have a custom operator called `divideByTwo` that
    will emit half of every received number. When the input Observable emits the values
    `4` and `8`, the output Observable produces `2` and `4` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: However, when the `R` value, which is non-numeric, is emitted, then an error
    is thrown, indicating abnormal termination. This case is not handled in the operator
    code. The input Observable continues the emission and then completes successfully.
    However, the value will never be processed because, after the error, the stream
    is closed.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we’ve gone through all the elements composing the marble diagram.
    You will be able to understand the operators used in the chapters to come. Now,
    let’s shed some light on the use of RxJS in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting the use of RxJS in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'RxJS is practically a first-class citizen in Angular. It is part of the Angular
    ecosystem and is used in many features to handle asynchronous tasks. The following
    are some examples of these features:'
  prefs: []
  type: TYPE_NORMAL
- en: The HttpClient module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Router module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Event emitter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss each of the following concepts in the subsequent subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We recommend taking a quick look at [https://angular.dev/overview](https://angular.dev/overview),
    where you can find further details about the aforementioned features.
  prefs: []
  type: TYPE_NORMAL
- en: The HttpClient module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might be familiar with the HttpClient API provided by Angular that is used
    to communicate with a server over the HTTP protocol. The `HttpClient` service
    is based on Observables that manage all transactions, which means that the result
    of calling API methods such as `GET`, `PATCH`, `POST`, and `PUT` will be an Observable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, we have an example of an Angular service that
    injects the `HttpClient` service and fetches data from the server using the `HttpClient.get()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `getRecipes()` method – or, to be more accurate, the call to ``this.http.get<Recipe>(`api/recipes/`)``
    – returns an Observable that you should subscribe to in order to send the `GET`
    request to the server. Please note that this is an example of an HTTP transaction,
    and it is the same for all the other HTTP methods available in the API (`POST`,
    `PUT`, `PATCH`, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The code contains references to `recipe.model` and `getRecipes()` – in [*Chapter
    2*](B21180_02.xhtml#_idTextAnchor031)*, Walking through Our Application*, you
    will be introduced to the Recipe app that we will be working on throughout the
    rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'For those familiar with Promise-based HTTP APIs, you may be wondering about
    the advantages of using Observables in this context. For those who are not acquainted
    with Promises, **Promises** are JavaScript objects that represent the eventual
    completion (or failure) of an asynchronous operation and its resulting value.
    They provide a cleaner and more structured way to work with asynchronous code
    compared to traditional callback-based approaches. However, there are a lot of
    advantages of using Observables over Promises, and the most important ones are
    listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Observables are cancellable, so you can cancel the HTTP request whenever you
    want by calling the unsubscribe method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also retry HTTP requests when an error occurs or an exception is thrown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server’s response cannot be mutated by Observables, although this can be
    the case for chaining `then()` on Promises.
  prefs: []
  type: TYPE_NORMAL
- en: The Router module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Router module available in the `@angular/router` package uses Observables
    in router events and activated routes. We will look at both here.
  prefs: []
  type: TYPE_NORMAL
- en: Router events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Router events allow you to intercept the navigation life cycle. They are defined
    in the Router as Observables.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We recommend taking a quick look at [https://angular.dev/api/router/Event](https://angular.dev/api/router/Event),
    where you can find further details about router events.
  prefs: []
  type: TYPE_NORMAL
- en: The majority of Angular applications have a routing mechanism. Router events
    change frequently over time, and it makes sense to listen to changes to execute
    side effects. That’s why Observables are a flexible way in which to handle those
    streams.
  prefs: []
  type: TYPE_NORMAL
- en: To intercept all the events the router goes through, first, you should inject
    the `Router` service, which provides URL manipulation capabilities. Then, subscribe
    to the events Observable available in the `Router` object and filter the events
    of type `RouterEvent` using the RxJS filter operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of an Angular service that injects the Router in
    the constructor, subscribes to the router events, and traces the event ID and
    path in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is a very basic example, and you could introduce pretty much any specific
    behavior to it.
  prefs: []
  type: TYPE_NORMAL
- en: The activated route
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ActivatedRoute` is a router service that you can inject into your components
    to retrieve information about a route’s path and parameters. Many properties are
    based on Observables. Here, you will find the implementation of the `ActivatedRoute`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you may have figured out, `url`, `params`, `queryParams`, `fragment`, `data`,
    `paramMap`, and `queryParamMap` are represented as Observables. All these parameters
    might change over time, so it makes sense to listen to these changes to register
    side effects or update the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of an Angular component that injects the `ActivatedRoute`
    class in the constructor and then in `ngOnInit()` method, subscribes to the following
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: The `url` property of `ActivatedRoute`, in order to log the current URL in the
    console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `queryParams` property of `ActivatedRoute`, in order to retrieve the `criteria`
    parameter and store it in a local property named `criteria`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This example showcases the usage of the `url` and `queryParams` properties.
    For a comprehensive overview of all `ActivatedRoute` properties and their functionalities,
    I encourage you to visit the Angular documentation page at [https://angular.dev/api/router/ActivatedRoute#properties](https://angular.dev/api/router/ActivatedRoute#properties).
  prefs: []
  type: TYPE_NORMAL
- en: Reactive forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Reactive forms available under the `@angular/forms` package are based on Observables
    to track form control changes. Here’s the overview of the `FormControl` class
    in Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The properties `valueChanges` and `statusChanges` of `FormControl` are represented
    as Observables that trigger change events. Subscribing to a `FormControl` value
    change is a way of triggering application logic within the `component` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example that subscribes to the `valueChanges` Observable of a `FormControl`
    property called `rating` and simply traces the value through `console.log(value)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This way, you will get the changed value as an output.
  prefs: []
  type: TYPE_NORMAL
- en: The Event emitter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The event emitter, which is part of the `@angular/core` package, is used to
    emit data from a child component to a parent component through the `@Output()`
    decorator. The `EventEmitter` class extends the RxJS subject and registers handlers
    for events emitted by this instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is what happens under the hood when you create an event emitter and emit
    a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is an example of emitting the updated value of a recipe
    rating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So, the `EventEmitter` smooths communication between components by allowing
    one component to emit custom events and another component to listen for and respond
    to those events. This mechanism plays a crucial role in enabling parent-child
    communication, sibling communication, and even communication between unrelated
    components in Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In the previous code snippets, the subscription to the Observables was done
    explicitly for demonstration purposes. In a real-world example, we should include
    the unsubscription logic if we want to subscribe explicitly. We will shed light
    on this in [*Chapter 3*](B21180_03.xhtml#_idTextAnchor047), *Fetching Data* *as
    Streams*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we walked you through the fundamentals of reactive programming
    and in which use cases it shines. Then, we explained the marble diagram that will
    be our reference for explaining RxJS operators in all the following chapters.
    Finally, we highlighted the use of reactive programming in Angular by illustrating
    concrete examples, implementations, and advantages.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have got the basics right, it is time to start preparing and explaining,
    in the next chapter, the application that we are going to build throughout this
    book, where we are going to implement all of the reactive patterns we will learn
    progressively.
  prefs: []
  type: TYPE_NORMAL
