- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Enhancing the User Experience
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升用户体验
- en: Remix enables us to build applications with progressive enhancement in mind.
    In Remix, enhancing the user experience can be achieved by making additive changes.
    This allows us to follow a simple step-by-step process to build our applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Remix使我们能够以渐进增强为前提构建应用程序。在Remix中，通过进行增量更改来提升用户体验。这允许我们遵循一个简单的步骤过程来构建我们的应用程序。
- en: In [*Chapter 5*](B17399_05.xhtml#_idTextAnchor078), *Fetching and Mutating Data*,
    we added data loading and mutations to our BeeRich application. When building
    out the create expense form, we first implemented the UI to work without JavaScript
    and then enhanced the browser’s default behavior with JavaScript. By doing so,
    we progressively enhanced the experience.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B17399_05.xhtml#_idTextAnchor078)“获取和变更数据”中，我们向BeeRich应用程序添加了数据加载和变更。在构建创建费用表单时，我们首先实现了无需JavaScript的UI，然后使用JavaScript增强了浏览器的默认行为。通过这样做，我们逐步提升了体验。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding progressive enhancement
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解渐进增强
- en: Prefetching data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预取数据
- en: Working with action data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与动作数据一起工作
- en: Handling concurrent mutations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理并发变更
- en: First, we will formalize how progressive enhancement works in Remix. After that,
    we will focus on advanced data loading and mutation topics, including how to prefetch
    loader data and assets. Next, we will learn how to access action data to display
    mutation feedback. Finally, we will learn how to support concurrent mutations
    in Remix.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将正式说明渐进增强在Remix中的工作方式。之后，我们将关注高级数据加载和变更主题，包括如何预取加载器数据和资源。接下来，我们将学习如何访问动作数据以显示变更反馈。最后，我们将学习如何在Remix中支持并发变更。
- en: After reading this chapter, you will understand the benefits of working with
    progressive enhancement in mind. You will also learn how to prefetch data, work
    with action data, and handle multiple form submissions simultaneously.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '阅读本章后，您将了解以渐进增强为前提工作的好处。您还将学习如何预取数据、处理动作数据以及同时处理多个表单提交。 '
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before you start this chapter, follow the instructions in the `README.md` file
    in this chapter’s folder on GitHub. You can find the code for this chapter here:
    [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/06-enhancing-the-user-experience](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/06-enhancing-the-user-experience).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本章之前，请遵循GitHub上本章文件夹中的`README.md`文件中的说明。您可以在以下位置找到本章的代码：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/06-enhancing-the-user-experience](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/06-enhancing-the-user-experience)。
- en: Understanding progressive enhancement
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解渐进增强
- en: In this section, we will learn more about the motivation behind progressive
    enhancement and introduce best practices for working with progressive enhancement
    in mind.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入了解渐进增强背后的动机，并介绍以渐进增强为前提的最佳实践。
- en: Progressive enhancement is a design philosophy that aims to create a baseline
    user experience for users on older devices and browsers. Building with progressive
    enhancement in mind is like designing mobile first; you start with a minimal UI
    for small screens and progress from there.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 渐进增强是一种设计理念，旨在为旧设备和浏览器上的用户提供一个基本用户体验。以渐进增强为前提构建就像设计移动端优先；你从一个适用于小屏幕的最小UI开始，然后逐步发展。
- en: 'A less frequently used term is **graceful degradation**. Graceful degradation
    describes a similar idea: striving for the best experience possible while supporting
    older browsers and devices. Progressive enhancement works upward, while graceful
    degradation works downward.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个较少使用的术语是**优雅降级**。优雅降级描述了一个类似的概念：在支持旧版浏览器和设备的同时，努力提供最佳的用户体验。渐进增强是从下往上工作，而优雅降级则是从上往下工作。
- en: Progressive enhancement in Remix
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Remix中的渐进增强
- en: Remix allows us to build highly dynamic user experiences by utilizing web standards.
    Remix, by default, works without JavaScript. When working with progressive enhancement
    in mind, we can enhance the experience upward but still keep it accessible and
    usable when JavaScript is still loading, fails to load, or is disabled.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Remix通过利用网络标准使我们能够构建高度动态的用户体验。默认情况下，Remix无需JavaScript即可工作。当考虑到渐进增强时，我们可以向上提升体验，但仍然在JavaScript仍在加载、加载失败或被禁用时保持其可访问性和可用性。
- en: In [*Chapter 4*](B17399_04.xhtml#_idTextAnchor057), *Routing in Remix*, we learned
    about Remix’s `Link` and `NavLink` components. These components enhance the browser’s
    default behavior with JavaScript. Without JavaScript, Remix’s `Link` and `NavLink`
    components still render an anchor tag that the browser can work with.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B17399_04.xhtml#_idTextAnchor057) *Remix中的路由*中，我们学习了Remix的`Link`和`NavLink`组件。这些组件在JavaScript的帮助下增强了浏览器的默认行为。如果没有JavaScript，Remix的`Link`和`NavLink`组件仍然会渲染一个浏览器可以与之交互的锚点标签。
- en: If JavaScript is available, `Link` and `NavLink` perform client-side navigations
    and fetch loader data and assets from the server without re-requesting the full
    HTML document. Client-side navigations aim to reduce response times by avoiding
    downloading the entire HTML document repeatedly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果JavaScript可用，`Link`和`NavLink`将执行客户端导航并从服务器获取fetch加载器和资源数据，而无需重新请求完整的HTML文档。客户端导航旨在通过避免重复下载整个HTML文档来减少响应时间。
- en: Remix also supports progressive enhancement for data mutations. When using Remix’s
    `Form` component, we again let Remix enhance the experience. If JavaScript is
    available, Remix prevents the browser’s default behavior and initiates a fetch
    request to the specified action. However, without JavaScript, we still render
    a form element that the browser can work with. Remix is capable of falling back
    to native form submissions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Remix还支持数据变更的渐进增强。当使用Remix的`Form`组件时，我们再次让Remix增强体验。如果JavaScript可用，Remix将阻止浏览器默认行为并启动对指定操作的fetch请求。然而，如果没有JavaScript，我们仍然渲染一个浏览器可以与之交互的表单元素。Remix能够回退到原生表单提交。
- en: Remix provides the tools to create highly dynamic but progressively enhanced
    experiences. When working with progressive enhancement in mind, the first step
    is to make it work without JavaScript.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Remix提供了创建高度动态但渐进增强体验的工具。当考虑到渐进增强时，第一步是使其在没有JavaScript的情况下工作。
- en: Making it work without JavaScript
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使其在没有JavaScript的情况下工作
- en: Making it work without JavaScript lets us keep things simple and take advantage
    of the browser’s default behavior.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有JavaScript的情况下使其工作使我们能够保持简单并利用浏览器的默认行为。
- en: 'There are several reasons why JavaScript might not be available on the client:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因可能导致客户端上没有JavaScript可用：
- en: JavaScript is still loading, or React is still hydrating when the user interacts
    with the page. This frequently happens on slower network connections.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户与页面交互时，JavaScript仍在加载，或React仍在激活。这通常发生在较慢的网络连接上。
- en: JavaScript failed to load due to a network error.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于网络错误，JavaScript加载失败。
- en: JavaScript failed to be interpreted, executed, or hydrated due to an error in
    the bundle.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于包中的错误，JavaScript未能被解释、执行或激活。
- en: JavaScript is disabled on the browser by the user.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户已在浏览器中禁用了JavaScript。
- en: JavaScript is not supported in the user’s environment.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的环境不支持JavaScript。
- en: When our application works without JavaScript, we may be able to reach more
    people on slower networks or further away from our server locations. We may also
    be able to better serve assistive technologies that rely on the browser’s default
    behavior.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序在没有JavaScript的情况下工作时，我们可能能够触及更慢的网络或远离我们的服务器位置的用户。我们还可以更好地服务依赖于浏览器默认行为的辅助技术。
- en: Starting without JavaScript also ensures that our application logic lives on
    the server whenever possible, reducing our client bundle size and keeping our
    client application simple.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有JavaScript的情况下启动也确保了我们的应用程序逻辑尽可能在服务器上运行，从而减少了我们的客户端包大小并使我们的客户端应用程序保持简单。
- en: 'There are several ways to disable JavaScript in a Remix app to emulate such
    an environment. For one, we can disable JavaScript in the browser’s developer
    tools. Alternatively, we can open the `app/root.tsx` file in an editor and remove
    the `Scripts` component:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以在Remix应用程序中禁用JavaScript以模拟此类环境。一方面，我们可以在浏览器开发者工具中禁用JavaScript。或者，我们可以在编辑器中打开`app/root.tsx`文件并移除`Scripts`组件：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Removing the `Scripts` component removes all script tags from the server-side
    rendered HTML document. By disabling JavaScript or not loading any JavaScript,
    we are forced to move logic from the client to our server-side `actions` and `loader`
    functions. Working with progressive enhancement in mind is a great way to reduce
    client-side code complexity for the baseline user experience. Once the baseline
    experience is implemented, we can add client-side JavaScript.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 移除`Scripts`组件将从服务器端渲染的HTML文档中移除所有脚本标签。通过禁用JavaScript或未加载任何JavaScript，我们被迫将逻辑从客户端移动到我们的服务器端`actions`和`loader`函数。考虑到渐进增强，以减少基准用户体验的客户端代码复杂性是一种很好的方法。一旦实现了基准体验，我们就可以添加客户端JavaScript。
- en: Making it worse before making it better
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在改进之前先使其变得更糟
- en: Once we make it work without JavaScript, we can think about further enhancing
    the experience with JavaScript. One thing to note is that enabling JavaScript
    will make the experience worse, not better. By default, the browser indicates
    page loads by showing a loading spinner in the browser window’s title tab. Full
    page reloads also reset client-side states such as form inputs and revalidate
    the UI with the latest server data. By preventing the browser’s default behavior,
    we get rid of these features.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在没有JavaScript的情况下使其工作，我们就可以考虑使用JavaScript进一步增强体验。需要注意的是，启用JavaScript将使体验变得更差，而不是更好。默认情况下，浏览器通过在浏览器窗口的标题标签中显示加载旋转器来指示页面加载。完整页面刷新也会重置客户端状态，如表单输入，并使用最新的服务器数据重新验证UI。通过防止浏览器默认行为，我们摆脱了这些功能。
- en: If we skip refreshing client-side states, resetting forms, and showing loading
    indicators during transitions or submissions, the user experience suffers. Therefore,
    we need to add these features back using JavaScript when we stop the browser from
    doing its default actions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们跳过在转换或提交期间刷新客户端状态、重置表单和显示加载指示，用户体验将受到影响。因此，我们需要使用JavaScript将这些功能重新添加回来，当我们阻止浏览器执行其默认操作时。
- en: We already added custom loading indications in [*Chapter 4*](B17399_04.xhtml#_idTextAnchor057),
    *Routing in Remix*. However, whenever we add a new form to our application, we
    should investigate the experience and see whether additional pending indications
    are necessary.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第4章*](B17399_04.xhtml#_idTextAnchor057)，*Remix中的路由*中添加了自定义加载指示。然而，无论何时我们向应用程序添加新的表单，我们都应该调查体验并查看是否需要额外的挂起指示。
- en: Testing on slow networks
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在慢速网络上进行测试
- en: Testing on slow networks is a great way to check an application’s user experience.
    It is especially helpful when testing pending states. Take the expense creation
    form as an example; you might not have noticed the missing loading indication
    with the application running on your local machine.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在慢速网络上进行测试是检查应用程序用户体验的好方法。特别是在测试挂起状态时特别有帮助。以创建费用表单为例；你可能没有注意到当应用程序在你的本地机器上运行时，缺少加载指示。
- en: Your browser’s developer tools offer a toggle to throttle your connection to
    a preset or custom bandwidth. Setting throttling to **Slow 3G** allows you to
    test your application in a way not possible when developing on fast Wi-Fi.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器的开发者工具提供了一个切换选项，可以限制你的连接到预设或自定义带宽。将限制设置为**慢速3G**允许你在开发快速Wi-Fi时无法实现的方式测试你的应用程序。
- en: 'Let’s test BeeRich on a slow 3G connection:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在慢速3G连接上测试BeeRich：
- en: Run BeeRich by executing `npm run dev` in the project’s root folder.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在项目的根目录中执行`npm run dev`来运行BeeRich。
- en: Make sure JavaScript is enabled in case it was previously disabled.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保JavaScript已启用，以防之前已禁用。
- en: Open the application in your browser.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开应用程序。
- en: Open the developer tools and navigate to the **Network** tab.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开开发者工具并导航到**网络**标签页。
- en: Look for the throttling functionality and select **Slow 3G**.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找限制功能并选择**慢速3G**。
- en: Open the expense form in your browser window (`http://localhost:3000/dashboard/expense/`).
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器窗口中打开费用表单（`http://localhost:3000/dashboard/expense/`）。
- en: Fill out the form and click **Submit**.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写表单并点击**提交**。
- en: Note that the **Submit** button remains active and can be clicked again. It
    is not perfectly clear to the user that the form is currently being submitted.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，**提交**按钮保持活动状态，可以再次点击。用户并不完全清楚表单目前正在提交。
- en: Open the `dashboard.expenses._index.tsx` route module in your editor.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器中打开`dashboard.expenses._index.tsx`路由模块。
- en: 'Update the route component so that it uses the `useNavigation` hook to derive
    the current transition state of our application:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新路由组件，使其使用`useNavigation`钩子来推导我们应用程序的当前转换状态：
- en: '[PRE1]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Test the new pending UI with the throttled network connection.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用限制的网络连接测试新的挂起UI。
- en: Notice how our changes to the **Submit** button enhance the experience. Submitting
    the expense creation form on a slow connection may take a few moments. Now, we
    have a clear loading indication.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何通过修改**提交**按钮来增强用户体验。在慢速连接上提交创建费用表单可能需要几秒钟时间。现在，我们有一个清晰的加载指示。
- en: Progressive enhancement is about making an application accessible to as many
    users as possible. Working with progressive enhancement in mind ensures that the
    baseline user experience stays simple enough to be used on older browsers and
    devices.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 渐进增强是关于使应用程序尽可能多地对用户可访问。考虑到渐进增强，确保基本用户体验足够简单，可以在较旧的浏览器和设备上使用。
- en: It turns out that building with progressive enhancement in mind creates a simpler
    mental model for building great user interfaces. First, we create the baseline
    implementation without JavaScript. Once the baseline implementation works, we
    focus on enhancing the experience with JavaScript. We test the application by
    throttling the network. This forces us to build a resilient user experience that
    scales up and down. Remix supports us by providing primitives and conventions
    that let us make additive changes to enhance the experience until we are satisfied.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，以渐进增强为前提构建可以创建一个更简单的心理模型来构建出色的用户界面。首先，我们创建没有 JavaScript 的基本实现。一旦基本实现工作正常，我们就专注于使用
    JavaScript 增强体验。我们通过限制网络来测试应用程序。这迫使我们构建一个具有弹性的用户体验，可以上下扩展。Remix 通过提供原语和约定来支持我们，使我们能够进行增量更改以增强体验，直到我们满意。
- en: We’re just getting started! Remix can scale up to highly dynamic experiences.
    Next, we’ll learn how to prefetch data with Remix to reduce page transition times.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们才刚刚开始！Remix 可以扩展到高度动态的体验。接下来，我们将学习如何使用 Remix 预取数据以减少页面转换时间。
- en: Prefetching data
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预取数据
- en: In this section, we will learn how to prefetch assets and loader data in Remix
    and how to utilize prefetching to speed up transition times.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在 Remix 中预取资产和 loader 数据，以及如何利用预取来加快转换时间。
- en: Remix compiles the `routes` folder into a routing hierarchy at build time. The
    hierarchy information is stored in an asset manifest in the `public` folder. This
    asset manifest is used by both Remix’s frontend and backend applications.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 在构建时将`routes`文件夹编译成一个路由层次结构。层次结构信息存储在`public`文件夹中的一个资产清单中。这个资产清单由 Remix
    的前端和后端应用程序共同使用。
- en: Since Remix has access to the asset manifest on the client, Remix knows in advance
    which `loader` functions to call to transition to a route. This allows Remix to
    prefetch loader data (and route assets) before the transition.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Remix 可以访问客户端的资产清单，Remix 预先知道在转换到路由时需要调用哪些`loader`函数。这允许 Remix 在转换之前预取 loader
    数据（和路由资产）。
- en: 'Enabling prefetching in Remix is as easy as setting a prop on the link we want
    to prefetch data for:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Remix 中启用预取与设置我们想要预取数据的链接上的属性一样简单：
- en: Open the `/app/routes/dashboard.tsx` file in your editor.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的编辑器中打开`/app/routes/dashboard.tsx`文件。
- en: 'Add the `prefetch` property to the **Income** and **Expenses** navigation links:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`prefetch`属性添加到**收入**和**费用**导航链接中：
- en: '[PRE2]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Visit the income overview page ([http://localhost:3000/dashboard/income](http://localhost:3000/dashboard/income))
    in your browser window.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器窗口中访问收入概览页面([http://localhost:3000/dashboard/income](http://localhost:3000/dashboard/income))。
- en: Open the **Network** tab of your developer tools.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的开发者工具的**网络**标签页。
- en: Clear the list of requests and filter for **All** requests.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除请求列表并筛选**所有**请求。
- en: Now, hover over the **Expenses** link in the navigation.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将鼠标悬停在导航中的**费用**链接上。
- en: 'Inspect the **Network** tab. It should now list four prefetch requests, as
    visible in *Figure 6**.1*:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查**网络**标签页。现在，它应该列出四个预取请求，如图 *图 6**.1* 所示：
- en: '![Figure 6.1 – Inspecting prefetch requests](img/Figure_6.01_B17399.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 检查预取请求](img/Figure_6.01_B17399.jpg)'
- en: Figure 6.1 – Inspecting prefetch requests
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 检查预取请求
- en: 'A transition to `/dashboard/expenses/$id` from the income route matches the
    following route modules:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从收入路由跳转到 `/dashboard/expenses/$id` 的转换与以下路由模块匹配：
- en: '`dashboard.tsx`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dashboard.tsx`'
- en: '`dashboard.expenses.tsx`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dashboard.expenses.tsx`'
- en: '`dashboard.expenses.$id.tsx`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dashboard.expenses.$id.tsx`'
- en: The `dashboard.tsx` route module is already active on the page, and there is
    no need to reload it. Remix only loads assets and loader data for the other two
    route modules. We can see four prefetch requests in *Figure 6**.1*. There are
    two requests of the JSON content type to fetch the required loader data and two
    requests to fetch the code-split JavaScript bundles of the two new route modules.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`dashboard.tsx` 路由模块已经在页面上激活，无需重新加载。Remix 只为其他两个路由模块加载资产和加载器数据。我们可以在 **图 6**.1
    中看到四个预取请求。有两个是 JSON 内容类型的请求，用于获取所需的加载器数据，还有两个请求用于获取两个新路由模块的代码分割 JavaScript 包。'
- en: Inspect the requests by clicking on them in the **Network** tab. This should
    open a request detail view. Inspect the nested **Preview** and **Response** tabs.
    The JSON responses contain the loader data of the two route modules.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 **网络** 选项卡中点击它们来检查请求。这应该会打开一个请求详情视图。检查嵌套的 **预览** 和 **响应** 选项卡。JSON 响应包含两个路由模块的加载器数据。
- en: Prefetching data is optional. With prefetching, we pull a lever to reduce request
    times but introduce a risk of fetching unnecessary data if the user does not visit
    the link.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 预取数据是可选的。使用预取，我们可以拉一个杠杆来减少请求时间，但如果用户不访问链接，则可能会引入获取不必要数据的风险。
- en: Prefetching on render is the most aggressive strategy while prefetching on intent
    is based on the user’s actions on the page.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染时预取是最激进的策略，而在意图上预取则是基于用户在页面上的操作。
- en: Remix provides levers
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 提供了杠杆
- en: Prefetching is a lever we can pull. Using prefetching reduces response times
    by increasing the risk of downloading unnecessary data over the network. Remix
    allows us to optimize our application for our use cases and requirements by providing
    levers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 预取是我们可以拉的杠杆。使用预取通过增加在网络中下载不必要数据的风险来减少响应时间。Remix 通过提供杠杆允许我们根据我们的用例和需求优化我们的应用程序。
- en: Now that we’ve learned about prefetching, let’s dive deeper into mutations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了预取，让我们更深入地了解突变。
- en: Working with action data
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理操作数据
- en: 'The `loader` and `action` functions contain most of the business logic of our
    Remix application. This is where we fetch, filter, and update data. Both functions
    must return a `Response` object. You know about the `redirect` and `json` helper
    functions, which let us create specific `Response` objects, and you have already
    practiced working with loader data. In this section, we will learn how to work
    with action data. For that, we will update the expense details view and implement
    an edit expense form:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`loader` 和 `action` 函数包含我们 Remix 应用程序的大部分业务逻辑。这是我们获取、过滤和更新数据的地方。这两个函数都必须返回一个
    `Response` 对象。您已经了解了 `redirect` 和 `json` 辅助函数，它们让我们可以创建特定的 `Response` 对象，并且您已经练习了处理加载器数据。在本节中，我们将学习如何处理操作数据。为此，我们将更新费用详情视图并实现编辑费用表单：'
- en: Open the `dashboard.expenses.$id.tsx` route module in your editor.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的编辑器中打开 `dashboard.expenses.$id.tsx` 路由模块。
- en: Take the current code from `dashboard.expenses._index.tsx`. Can you modify the
    code to edit an existing expense? Give it a try!
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `dashboard.expenses._index.tsx` 中获取当前代码。您能修改代码以编辑现有的费用吗？试试看！
- en: The final code for this chapter is available in the `/bee-rich/solution` folder
    on GitHub for this chapter. As we move forward, we'll help you align your work
    with this final solution.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本章的最终代码可在 GitHub 的 `/bee-rich/solution` 文件夹中找到。随着我们继续前进，我们将帮助您将您的工作与这个最终解决方案对齐。
- en: 'Make sure to update the form''s `action` property using the `expense` object
    from the loader data:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保使用加载器数据中的 `expense` 对象更新表单的 `action` 属性：
- en: '[PRE3]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you haven''t already, update the `isSubmitting` constant''s `formAction`
    check:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有，更新 `isSubmitting` 常量的 `formAction` 检查：
- en: '[PRE4]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We again use the `useNavigation` hook to compute whether we should add pending
    indications to the form. Note that, again, we ensure that the submitted form action
    matches this form’s `action` property.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们再次使用 `useNavigation` 钩子来计算是否应该将挂起的指示添加到表单中。请注意，同样地，我们确保提交的表单操作与该表单的 `action`
    属性匹配。
- en: 'Next, update the route component’s form fields:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新路由组件的表单字段：
- en: '[PRE5]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, add React’s `key` property to the `Form` component to ensure that React
    reconstructs the content of the form every time we transition between different
    expense details pages:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向 `Form` 组件添加 React 的 `key` 属性，以确保 React 在我们切换到不同的费用详情页面时每次都重建表单的内容：
- en: '[PRE6]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following `action` function to the route module:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `action` 函数添加到路由模块中：
- en: '[PRE7]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the missing `updateExpense` function to the route module file:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将缺少的 `updateExpense` 函数添加到路由模块文件中：
- en: '[PRE8]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Import the `useActionData` hook:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `useActionData` 钩子：
- en: '[PRE9]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: typeof operator. Note that action data – unlike loader data – can be undefined.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: typeof 操作符。请注意，与加载器数据不同，操作数据可以是未定义的。
- en: '[PRE10]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use the action data to display a success message below the **Submit** button:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用操作数据在 **提交** 按钮下方显示成功消息：
- en: '[PRE11]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the app and test out the updated expense form!
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序并测试更新的支出表单！
- en: Awesome! Just like that, we can leverage `action` data to communicate successful
    mutations. Make sure you implement the same functionality on the `income` routes.
    Try to adapt the income route modules without looking at the instructions. This
    will help you better understand the lessons of this chapter. If you get stuck,
    review the instructions of this chapter. You can also find the solution code for
    this chapter on GitHub.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！就这样，我们可以利用 `action` 数据来传达成功的突变。确保您在 `income` 路由上实现相同的功能。尝试在不看说明的情况下适应收入路由模块。这将帮助您更好地理解本章的要点。如果您遇到困难，请回顾本章的说明。您还可以在GitHub上找到本章的解决方案代码。
- en: Use useActionData only within the same route module
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在相同的路由模块中使用 `useActionData`
- en: Note that a form submission creates a navigation to the location of the `action`
    function. `useLoaderData` can only access loader data of the same route’s loader.
    Similarly, `useActionData` must be used in the route module of the `action` function
    that the form submits to.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，表单提交会导航到 `action` 函数的位置。`useLoaderData` 只能访问同一路由加载器的加载数据。同样，`useActionData`
    必须在提交表单的 `action` 函数的路由模块中使用。
- en: Remix also provides advanced data mutation utilities. Next, we’ll add the ability
    to delete expenses and learn how to handle concurrent mutations in Remix.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Remix还提供了高级数据突变工具。接下来，我们将添加删除支出的功能，并学习如何在Remix中处理并发突变。
- en: Handling concurrent mutations
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理并发突变
- en: So far, we have created expense creation and edit forms. Both forms are standalone
    on their respective pages. This section will teach you how to manage multiple
    form submissions simultaneously. Let’s start by adding a deletion form to every
    item in the expense overview list.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了支出创建和编辑表单。这两个表单都在各自的页面上独立存在。本节将教您如何同时管理多个表单提交。让我们首先为支出概览列表中的每个项添加删除表单。
- en: Adding a form to a list
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将表单添加到列表中
- en: 'The goal of this section is to add a deletion form to every list item in the
    expense overview list. Clicking the item should delete the associated expense.
    Let’s get started:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是为支出概览列表中的每个列表项添加删除表单。点击项应删除相关的支出。让我们开始：
- en: 'If you haven''t already, follow the instructions in the `README.md` file of
    this chapter on GitHub: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/06-enhancing-the-user-experience/bee-rich/README.md](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/06-enhancing-the-user-experience/bee-rich/README.md).'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果还没有，请遵循GitHub上本章 `README.md` 文件中的说明：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/06-enhancing-the-user-experience/bee-rich/README.md](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/06-enhancing-the-user-experience/bee-rich/README.md)。
- en: The `README.md` file includes instructions for how to update the `ListLinkItem`
    component for this chapter.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`README.md` 文件包括如何更新本章 `ListLinkItem` 组件的说明。'
- en: Next, open the `dashboard.expenses.$id.tsx` route module.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开 `dashboard.expenses.$id.tsx` 路由模块。
- en: 'Add a `deleteExpense` function to the route module:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在路由模块中添加一个 `deleteExpense` 函数：
- en: '[PRE12]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Call the newly created `deleteExpense` function in the `action` function:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `action` 函数中调用新创建的 `deleteExpense` 函数：
- en: '[PRE13]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, open the `dashboard.expenses.tsx` file in your editor and pass the `deleteProps`
    property to the `ListLinkItem` component:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在您的编辑器中打开 `dashboard.expenses.tsx` 文件，并将 `deleteProps` 属性传递给 `ListLinkItem`
    组件：
- en: '[PRE14]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: import { Outlet, useLoaderData, useNavigation, useParams } from '@remix-run/react';
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导入 `{ Outlet, useLoaderData, useNavigation, useParams }` 从 `@remix-run/react`；
- en: '[PRE15]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Use the `useParams` hook in the route module component to access the `id` route
    parameter of the expense details page:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在路由模块组件中使用 `useParams` 钩子访问支出详情页的 `id` 路由参数：
- en: '[PRE16]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the `isActive` property to the `ListLinkItem` component:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `isActive` 属性添加到 `ListLinkItem` 组件：
- en: '[PRE17]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let’s try out our implementation. Run the app locally, visit the expense overview
    page, and delete an expense object by clicking the `action` function handles the
    submission and redirects the user back to the current page or the expense overview
    page. After the mutation, Remix refetches the loader data, which triggers a re-render.
    The expense object disappears from the expenses list.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试一下我们的实现。在本地运行应用程序，访问费用概览页面，并通过点击`action`函数来删除费用对象。该函数处理提交并将用户重定向回当前页面或费用概览页面。在突变之后，Remix重新获取加载器数据，这触发了重新渲染。费用对象从费用列表中消失。
- en: Great! Each list item in the expenses list now contains a form to delete an
    expense. Next, let’s indicate pending states on deletion.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！费用列表中的每个列表项现在都包含一个用于删除费用的表单。接下来，让我们在删除时指示待处理状态。
- en: Supporting multiple pending states
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持多个待处理状态
- en: 'We already know that we can use the `useNavigation` hook to access the global
    navigation object. The navigation object’s state property indicates the current
    transition state of our app. Let’s use the `useNavigation` hook to indicate pending
    deletion for the deletion forms:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道我们可以使用`useNavigation`钩子来访问全局导航对象。导航对象的状态属性指示我们应用程序的当前转换状态。让我们使用`useNavigation`钩子来指示删除表单的待处理删除：
- en: 'Import `useNavigation` in `/app/components/links.tsx`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/app/components/links.tsx`中导入`useNavigation`：
- en: '[PRE18]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: const navigation = useNavigation();
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const navigation = useNavigation();
- en: '[PRE19]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Derive whether the form is currently submitting or loading:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推断表单当前是否正在提交或加载：
- en: '[PRE20]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that we are playing extra safe here. We check whether there is currently
    a page navigation happening and whether `formAction` matches this form’s `action`
    function. Finally, we also make sure that the form’s `intent` value matches this
    form’s submit button’s `intent` value. This ensures that we only show the pending
    state if this delete button is clicked.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们在这里采取了额外的安全措施。我们检查当前是否有页面导航正在进行，以及`formAction`是否与该表单的`action`函数匹配。最后，我们还要确保表单的`intent`值与该表单提交按钮的`intent`值匹配。这确保了只有当此删除按钮被点击时，我们才显示待处理状态。
- en: 'Finally, use `isSubmitting` to disable the **Submit** button and indicate the
    pending submission conditionally:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`isSubmitting`禁用**提交**按钮，并条件性地指示待处理提交状态：
- en: '[PRE21]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Run the application in development mode and open [http://localhost:3000/dashboard/expenses](http://localhost:3000/dashboard/expenses)
    in a browser window.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开发模式下运行应用程序，并在浏览器窗口中打开[http://localhost:3000/dashboard/expenses](http://localhost:3000/dashboard/expenses)。
- en: Open the **Network** tab of the browser developer tools and set throttling to
    **Slow 3G**. This helps us experience the pending UI for longer. Also, make sure
    to filter by **Fetch/XHR** requests.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器开发者工具的**网络**标签页，并将限速设置为**慢3G**。这有助于我们更长时间地体验待处理的UI。同时，确保通过**Fetch/XHR**请求进行筛选。
- en: Try deleting several expenses at once to see whether you spot any issues.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试一次性删除多个费用，看看你是否发现了任何问题。
- en: 'You may notice a flaw in the current implementation: deleting an expense seems
    to cancel all other ongoing deletions.'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会注意到当前实现中存在一个缺陷：删除费用似乎会取消所有其他正在进行的删除操作。
- en: 'Can you reason why this is the case? Remix’s navigation object captures the
    global navigation state of our application. There can only be one page navigation
    at a time. If the user submits a second form, then Remix cancels the first navigation,
    as visible in *Figure 6**.2*. The navigation object is updated, reflecting the
    second form submission:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你能解释为什么是这样吗？Remix的导航对象捕获了我们应用程序的全局导航状态。一次只能有一个页面导航。如果用户提交第二个表单，那么Remix将取消第一个导航，如*图6**.2*所示。导航对象被更新，反映了第二个表单的提交：
- en: '![Figure 6.2 – Canceling fetch requests](img/Figure_6.02_B17399.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 取消fetch请求](img/Figure_6.02_B17399.jpg)'
- en: Figure 6.2 – Canceling fetch requests
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 取消fetch请求
- en: Note that the deletions are not aborted; we only lose the pending indications.
    On the client, Remix cancels the current submission and updates the navigation
    object accordingly. However, the fetch request to delete the expense still reaches
    the server, and the action is performed. Remix also ensures that the loader data
    is only revalidated after every submission has been executed to avoid stale data
    in case the latest submission finishes faster than previous submissions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，删除操作并未被取消；我们只是失去了待处理指示。在客户端，Remix取消当前提交并相应地更新导航对象。然而，删除费用的fetch请求仍然到达服务器，并且操作被执行。Remix还确保只有在每个提交都已执行之后，才重新验证加载器数据，以避免在最新提交比之前的提交更快完成时出现过时数据。
- en: Remix tracks all ongoing submissions but only handles the last navigation
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 跟踪所有正在进行的提交，但只处理最后的导航
- en: Remember that Remix aims to emulate the browser’s default behavior. There can
    only ever be one page navigation. On concurrent form submissions, the last user
    action determines the final page navigation. In the background, Remix keeps track
    of all ongoing submissions to manage loader data revalidation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Remix 旨在模拟浏览器的默认行为。只能有一个页面导航。在并发表单提交中，最后一个用户操作决定最终的页面导航。在后台，Remix 会跟踪所有正在进行的提交以管理加载器数据重新验证。
- en: 'Let’s fix the lost pending indications. We want to show the pending UI for
    every currently pending deletion. Luckily, Remix provides us with another way
    to declare a form. Remix’s `useFetcher` hook can declare a `Form` component with
    an isolated submission state:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修复丢失的挂起指示。我们希望为每个当前挂起的删除显示挂起 UI。幸运的是，Remix 为我们提供了另一种声明表单的方法。Remix 的 `useFetcher`
    钩子可以声明具有独立提交状态的 `Form` 组件：
- en: 'Import `useFetcher`, replacing the `useNavigation` and `Form` imports, in in
    `/app/components/links.tsx`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/app/components/links.tsx` 中导入 `useFetcher`，替换 `useNavigation` 和 `Form` 的导入：
- en: '[PRE22]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: const fetcher = useFetcher();
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const fetcher = useFetcher();
- en: '[PRE23]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, update the assignment of the `isSubmitting` constant:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新 `isSubmitting` 常量的分配：
- en: '[PRE24]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The fetcher object that’s returned from `useFetcher` has an isolated submission
    lifecycle and navigation state. The state is unaffected by other submissions or
    loading activities in the app.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从 `useFetcher` 返回的 fetcher 对象具有独立的提交生命周期和导航状态。状态不受应用程序中其他提交或加载活动的影响。
- en: Note that a `useFetcher` form submission still triggers all active `loader`
    functions to reload after mutation. This sets the global navigation state to `loading`.
    However, a `useFetcher` form submission does not set the global navigation object’s
    state to `submitting`.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`useFetcher` 表单提交仍然会在修改后触发所有活动的 `loader` 函数重新加载。这会将全局导航状态设置为 `loading`。然而，`useFetcher`
    表单提交不会将全局导航对象的状态设置为 `submitting`。
- en: 'Replace `Form` with `fetcher.Form`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将 `Form` 替换为 `fetcher.Form`:'
- en: '[PRE25]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, create a few expenses using the expense creation form.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用费用创建表单创建一些费用。
- en: Open the developer tools and navigate to the **Network** tab.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开开发者工具并导航到 **网络** 选项卡。
- en: Throttle to **Slow 3G**.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整到 **慢速 3G**。
- en: Filter for **Fetch/XHR** requests.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤 **Fetch/XHR** 请求。
- en: Now, click the delete (`useFetcher`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击删除 (`useFetcher`。
- en: Loading and mutating data without page navigations with `useFetcher`
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `useFetcher` 无需页面导航即可加载数据和修改数据
- en: Data mutations through the `Form` component navigate the user to the `action`
    function’s location. This is the browser’s default behavior for form submissions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `Form` 组件进行数据修改会将用户导航到 `action` 函数的位置。这是浏览器表单提交的默认行为。
- en: The `useFetcher` hook allows us to load and mutate data without triggering page
    navigations; `useFetcher` has an isolated navigation state and does not trigger
    page navigations if JavaScript is loaded.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`useFetcher` 钩子允许我们在不触发页面导航的情况下加载数据和修改数据；如果 JavaScript 已加载，`useFetcher` 具有独立的导航状态，不会触发页面导航。'
- en: One thing to note is that `useFetcher` still honors redirect responses from
    `action` functions. Also, in case JavaScript is not available, `useFetcher.Form`
    falls back to the native form element’s behavior.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的事项是，`useFetcher` 仍然尊重来自 `action` 函数的重定向响应。此外，如果 JavaScript 不可用，`useFetcher.Form`
    将回退到原生表单元素的默认行为。
- en: 'There are plenty of use cases for `useFetcher`. You can read more about `useFetcher`
    in the Remix documentation: [https://remix.run/docs/en/2/hooks/use-fetcher](https://remix.run/docs/en/2/hooks/use-fetcher).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`useFetcher` 有许多用例。你可以在 Remix 文档中了解更多关于 `useFetcher` 的信息：[https://remix.run/docs/en/2/hooks/use-fetcher](https://remix.run/docs/en/2/hooks/use-fetcher)。'
- en: Next, practice what you’ve learned and use the updated `ListLinkItem` component
    for the `income` routes. This will help you study this section’s newly introduced
    concepts.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，练习你所学的知识，并使用更新的 `ListLinkItem` 组件处理 `income` 路由。这将帮助你学习本节新引入的概念。
- en: Amazing! We’ve covered much ground in this chapter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们在本章中覆盖了很多内容。
- en: Please note that we are currently facing an issue with our user experience.
    If you are on an expense details page (`dashboard/expenses/$id`) and quickly delete
    all expenses in one go, you may end up on a not found page. We will address this
    issue together in the next chapter, [*Chapter 7*](B17399_07.xhtml#_idTextAnchor105),
    *Error Handling* *in Remix*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们目前正面临用户体验问题。如果你在一个费用详情页面（`dashboard/expenses/$id`）上，并且一次性快速删除所有费用，你可能会结束在一个找不到页面上。我们将在下一章中一起解决这个问题，[*第
    7 章*](B17399_07.xhtml#_idTextAnchor105)，*Remix 中的错误处理*。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about progressive enhancement. Progressive enhancement
    is a design philosophy that aims to create a baseline user experience for users
    on older devices and browsers.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了渐进式增强。渐进式增强是一种设计理念，旨在为较旧设备和浏览器上的用户提供基本用户体验。
- en: You learned that Remix’s primitives work with and without JavaScript. This allows
    us to progressively enhance the experience and make our application accessible
    to more users. By building with progressive enhancement in mind, we ensure a simple
    but resilient experience for as many devices and browsers as possible. Once we
    ensure a baseline experience, we can enhance the experience with JavaScript.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解到Remix的原语在有和没有JavaScript的情况下都能工作。这使我们能够渐进式地增强体验，并使我们的应用程序对更多用户可访问。通过考虑渐进式增强来构建，我们确保尽可能多的设备和浏览器都能获得简单但健壮的体验。一旦我们确保了基本体验，我们就可以使用JavaScript来增强体验。
- en: Next, you learned that Remix can scale both up and down. We can start simple
    and even disable JavaScript, but by making additive changes, we can create highly
    dynamic experiences with concurrent mutations, data revalidation, and prefetching.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你了解到Remix可以向上和向下扩展。我们可以从简单开始，甚至禁用JavaScript，但通过进行增量更改，我们可以创建具有并发突变、数据重新验证和预取的高度动态体验。
- en: Remix provides levers to optimize the experience for what is important to us.
    We can decide how aggressively we want to prefetch data by setting the `prefetch`
    property to `render`, `viewport`, `intent`, or `none`. You further learned about
    action data, which can be used to communicate error or success states after a
    mutation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Remix提供了优化我们所需重要体验的杠杆。我们可以通过将`prefetch`属性设置为`render`、`viewport`、`intent`或`none`来决定我们希望多积极地预取数据。你进一步了解了动作数据，这些数据可以在突变后用来传达错误或成功状态。
- en: Finally, you learned how Remix manages concurrent form submissions. You know
    that there can only ever be one active page navigation. Remix cancels all pending
    navigations and updates the global navigation object accordingly.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你学习了Remix如何管理并发表单提交。你知道只能有一个活动的页面导航。Remix取消所有挂起的导航，并相应地更新全局导航对象。
- en: If we want to manage concurrent pending indications and isolated action data,
    then we can use Remix’s `useFetcher` hook. This can be used to programmatically
    submit forms, but also offers a `useFetcher.Form` component that does not trigger
    a page navigation if JavaScript is available.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要管理并发挂起的指示和隔离的动作数据，那么我们可以使用Remix的`useFetcher`钩子。这可以用来程序化地提交表单，同时也提供了一个`useFetcher.Form`组件，如果JavaScript可用，则不会触发页面导航。
- en: The `useFetcher` hook is especially useful to allow the submission of several
    forms concurrently while communicating the pending state of each of them in parallel.
    This is usually the case when rendering a list of forms, as we saw with the expense
    overview list in BeeRich.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`useFetcher`钩子特别有用，允许同时提交多个表单，同时并行传达每个表单的挂起状态。这通常发生在渲染表单列表时，正如我们在BeeRich中的费用概览列表中看到的那样。'
- en: In the next chapter, we will focus on handling errors and see how we can use
    Remix to provide a great user experience, even when something goes wrong.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于处理错误，并了解我们如何使用Remix在出现问题时提供良好的用户体验。
- en: Further reading
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The Remix team has created an amazing video series called Remix Singles that
    goes in depth into how to work with data in Remix. I recommend that you watch
    the entire series. Most notably for this chapter, the series has a video about
    concurrent mutations with `useFetcher` that you can find here: [https://www.youtube.com/watch?v=vTzNpiOk668&list=PLXoynULbYuEDG2wBFSZ66b85EIspy3fy6](https://www.youtube.com/watch?v=vTzNpiOk668&list=PLXoynULbYuEDG2wBFSZ66b85EIspy3fy6).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Remix团队创建了一个名为Remix Singles的精彩视频系列，深入探讨了如何在Remix中处理数据。我建议你观看整个系列。特别是对于本章，该系列有一个关于使用`useFetcher`进行并发突变的视频，你可以在这里找到：[https://www.youtube.com/watch?v=vTzNpiOk668&list=PLXoynULbYuEDG2wBFSZ66b85EIspy3fy6](https://www.youtube.com/watch?v=vTzNpiOk668&list=PLXoynULbYuEDG2wBFSZ66b85EIspy3fy6)。
- en: 'The Remix documentation includes a page about progressive enhancement: [https://remix.run/docs/en/2/discussion/progressive-enhancement](https://remix.run/docs/en/2/discussion/progressive-enhancement)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Remix文档包括一个关于渐进式增强的页面：[https://remix.run/docs/en/2/discussion/progressive-enhancement](https://remix.run/docs/en/2/discussion/progressive-enhancement)。
- en: 'You can also read more about progressive enhancement in the MDN Web Docs: [https://developer.mozilla.org/en-US/docs/Glossary/Progressive_Enhancement](https://developer.mozilla.org/en-US/docs/Glossary/Progressive_Enhancement).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 MDN Web 文档中了解更多关于渐进增强的内容：[https://developer.mozilla.org/en-US/docs/Glossary/Progressive_Enhancement](https://developer.mozilla.org/en-US/docs/Glossary/Progressive_Enhancement)。
- en: 'You can find more information about the `useFetcher` hook in the Remix documentation:
    [https://remix.run/docs/en/2/hooks/use-fetcher](https://remix.run/docs/en/2/hooks/use-fetcher).'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Remix 文档中找到更多关于 `useFetcher` 钩子的信息：[https://remix.run/docs/en/2/hooks/use-fetcher](https://remix.run/docs/en/2/hooks/use-fetcher)。
