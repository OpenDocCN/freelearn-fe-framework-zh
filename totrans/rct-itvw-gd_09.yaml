- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rapid Development with Next.js, Gatsby, and Remix Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developers are continuously searching for tools and frameworks that can speed
    up the development process without compromising the flexibility and resilience
    of their apps in the rapid digital environment of today. Full stack React frameworks
    such as **Next.js**, **Gatsby**, and **Remix** have become crucial participants
    in the contemporary web development environment as the need for seamless user
    experiences and dynamic, data-driven apps keeps rising. This chapter thoroughly
    examines these three formidable frameworks, focusing on their distinctive features,
    advantages, and application use cases.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at how each framework approaches different technologies such as **server-side
    rendering** (**SSR**), SEO, and creating static sites. These frameworks can be
    used to create blazing-fast, scalable, and highly performant apps, so we will
    see how they do it. Knowing the difference between popular React build tools will
    help us justify our choices for using them when asked at an interview. So, let’s
    continue our learning and see how Next.js, Gatsby, and Remix can revolutionize
    our approach to web development and help us realize our digital goals. By the
    end of the chapter, we should have much better knowledge in this area to help
    us give great answers to interview questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the topics that we will be going through in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using React as a full stack framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static site generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server-side rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding page metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SEO best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using React as a full stack framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s begin our journey by learning about Next.js, Gatsby, and Remix. If you
    are a modern developer then you should be using one of these three build tools
    to develop your React applications. They are recommended in the official React
    documentation, and understanding how they work and when to choose one over the
    other is paramount to putting together excellent interview answers. First, we
    will see what Next.js has to offer us.
  prefs: []
  type: TYPE_NORMAL
- en: What is Next.js?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next.js is an open source framework for creating contemporary, scalable, and
    high-performance online apps with the help of React. Next.js, developed and maintained
    by **Vercel**, provides a complete collection of capabilities and optimizations
    that make it an excellent choice for both **static site generation** (**SSG**)
    and SSR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers who choose to use Next.js for their React projects are blessed with
    a diverse tool that is rich in features. This has made Next.js the best framework
    for building React projects and replaces **Create React App** as the default choice.
    Some of its standout features are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Features** | **Explanation** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Code splitting** | It can automatically break the JavaScript code into
    smaller bits, ensuring that users only load the code required for a given page.
    This enhances the web application’s overall speed and loading times. |'
  prefs: []
  type: TYPE_TB
- en: '| **Dynamic importing** | Next.js enables developers to leverage dynamic imports
    to load JavaScript modules and components as needed, reducing the initial bundle
    size and improving speed. |'
  prefs: []
  type: TYPE_TB
- en: '| **API routing** | Support for building serverless API endpoints is included,
    so it’s simple to build **RESTful** or **GraphQL** APIs within your online application.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **File routing** | It uses a file-based routing method that makes it simple
    to add new routes and pages by just adding new files to the `pages` folder. |'
  prefs: []
  type: TYPE_TB
- en: '| **Built-in TypeScript** | There is TypeScript support, allowing developers
    to create type-safe code while also benefiting from improved tools and refactoring.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Hybrid renders** | With Next.js, we can enable static site creation as
    well as SSR, permitting developers to select the optimal solution for their particular
    situation or even combine both ways inside a single application. |'
  prefs: []
  type: TYPE_TB
- en: '| **Hot reload** | Hot reloading adds dynamic capabilities to a React application’s
    frontend UI. This implies that any changes we make to the application’s code are
    immediately reflected on the web application frontend that the user sees in real
    time. |'
  prefs: []
  type: TYPE_TB
- en: '| **Built-in support** **for CSS** | Next.js works out of the box with many
    CSS libraries and has the option to configure it with **Tailwind CSS** on setup.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.1: Next.js features'
  prefs: []
  type: TYPE_NORMAL
- en: As a whole, Next.js is a strong and adaptable framework that can handle a variety
    of web development requirements, from SSG to the construction of static websites,
    making it an attractive choice for programmers creating efficient online applications.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s have a look at Gatsby, which is another popular choice.
  prefs: []
  type: TYPE_NORMAL
- en: What is Gatsby?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gatsby is a free and open source static site generator based on React for creating
    contemporary, high-performance web apps and static websites. Gatsby uses GraphQL,
    an API query language, to retrieve data from many sources and integrate it with
    your React components throughout the build process to produce static HTML, CSS,
    and JavaScript files. The end result is a website that is lightning-fast, SEO-friendly,
    and well optimized.
  prefs: []
  type: TYPE_NORMAL
- en: It shares a few similarities with Next.js. However, it does differ in a few
    key areas. For starters, it is powered by GraphQL and it can also be used as a
    headless **content management system** (**CMS**). A CMS with a headless CMS separates
    the presentation layer, where the content is displayed, from the backend, where
    content is maintained. It distinguishes between knowledge and display. This allows
    for the reusing and rearranging of material across different digital media platforms.
    Basically, it is the equivalent of developing a WordPress website, but in this
    case, it is built for JavaScript developers, so we get access to the full suite
    of features.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can have a look at some of the unique features that make Gatsby a great
    React build tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Features** | **Explanation** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **GraphQL integration** | Gatsby leverages GraphQL to build a uniform and
    flexible data layer, allowing developers to retrieve data from a variety of sources,
    including Markdown files, CMSs, APIs, and databases, and utilize it through their
    React components. |'
  prefs: []
  type: TYPE_TB
- en: '| **Plugin library** | It features an extensive library of plugins that let
    programmers customize its capabilities, integrate it with multiple services, and
    tailor the development process to their own requirements. |'
  prefs: []
  type: TYPE_TB
- en: '| **Progressive web** **app (PWA)** | PWAs can be simply created by Gatsby-generated
    websites, enabling capabilities such as offline access, quick launching, and app-like
    performance on phones and tablets. |'
  prefs: []
  type: TYPE_TB
- en: '| **Performance enhancements** | To guarantee rapid loading times and an effortless
    user experience, Gatsby automatically performs several speed optimizations such
    as code splitting, inlining crucial CSS, and lazy-loading of pictures. |'
  prefs: []
  type: TYPE_TB
- en: '| **Versatile** **hosting choices** | The framework works nicely with a variety
    of hosting systems and provides continuous deployment, ensuring that it’s simple
    to set up and maintain your website. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.2: Gatsby features'
  prefs: []
  type: TYPE_NORMAL
- en: Gatsby is a strong and adaptable framework for creating rapid, SEO-friendly,
    and thoroughly optimized React and GraphQL web apps and static web pages. Because
    of its emphasis on speed, developer satisfaction, and flexibility, it is a favored
    option for programmers and enterprises.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s see what our final option, the Remix framework, is capable of
    doing and how its capabilities and features match up with the previous two options.
  prefs: []
  type: TYPE_NORMAL
- en: What is Remix?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remix is a cutting-edge web framework that uses React. Remix, which was built
    by the creators of **React Router**, seeks to deliver a fantastic user experience
    for developers while emphasizing the significance of web basics and best practices.
    Just like Next.js and Gatsby, the Remix framework also has a wide array of qualities
    that make it a great option when considering a starting point for your React projects.
    Remix has quite a lot of features, including the ones highlighted in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Features** | **Explanation** |'
  prefs: []
  type: TYPE_TB
- en: '| **Flexibility** | Remix is built to interact with a variety of backend technologies,
    server systems, and data sources of information, which makes it an ideal choice
    for programmers who work on a variety of applications. |'
  prefs: []
  type: TYPE_TB
- en: '| **Nested routes** | It is an easy-to-use and robust nested routing framework
    that allows you to design complicated and multilevel structures while maintaining
    the state and scroll location throughout browsing. |'
  prefs: []
  type: TYPE_TB
- en: '| **Rendering outputs** | The framework features SSR, SSG, and **client-side
    rendering (CSR)**, allowing programmers to select the best rendering technique
    for a particular use case or even blend multiple ways inside one application.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Web standards** | Because of its reliance on internet standards and its
    emphasis on the significance of exploiting browser-native technologies, it has
    enhanced speed and ease of use when using features such as the **Fetch** API,
    other HTML methods, and browser navigation. |'
  prefs: []
  type: TYPE_TB
- en: '| **Data-fetching improvements** | Users can access the Remix “loader” methods,
    which provide a distinctive information-fetching strategy, enabling programmers
    to retrieve information from the server or client side, ensuring fast processing
    of data and rapid page transitions. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.3: Remix features'
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, Remix is a strong and adaptable web framework for creating high-performance,
    feature-rich React apps. It distinguishes itself from other frameworks by focusing
    on web principles, best practices, and developer experience, making it an enticing
    alternative for developers wanting to build modern online apps. These features
    make it developer friendly, and the documentation is easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Now, moving on to the next section, we will learn about SSG, which is a popular
    tool for web developers to swiftly and effectively design websites. All of the
    frameworks we are discussing use it for builds.
  prefs: []
  type: TYPE_NORMAL
- en: Static site generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s now time for us to learn about SSG and why it’s so important. We will present
    an overview of static site creation, the way it works, and the reason why it has
    become so popular among millions of developers worldwide. With this technology,
    you will be able to rapidly develop stunning sites without having to be concerned
    about installing complicated server settings or handling obtrusive backend operations.
    Let’s do it.
  prefs: []
  type: TYPE_NORMAL
- en: Why should you care about SSG?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s a popular approach to developing websites, and for good reason. Instead
    of depending on a server to produce site content on the fly each time a user demands
    a page, static site creation pre-builds all required files and sends them through
    a user’s computer as soon as a page is requested. This leads to speedier load
    times and overall better performance. Static sites are also easier and less expensive
    to host because there is no dynamic material to handle. So, whether you’re a developer
    trying to streamline your workflow or a company owner looking to increase the
    performance and accessibility of your site, static site creation is absolutely
    something to think about.
  prefs: []
  type: TYPE_NORMAL
- en: What are the advantages of using a static site generator?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For developers aiming to simplify and improve their processes, static site generators
    are game changers. Static site generators, which do not rely on a database or
    server-side scripting, tend to be dependable even under tremendous traffic, making
    them an excellent choice for both corporations and individuals. Additionally,
    with the flexibility of a large choice of themes, developers can keep total control
    over the aesthetic of their website while benefiting from the performance of a
    static site. With advantages such as performance, security, and personalization,
    it’s no surprise that static site generators are gaining favor.
  prefs: []
  type: TYPE_NORMAL
- en: Using a static site generator leads to further advantages and better maintenance.
    Let’s now understand how these can make our applications safer and more robust.
  prefs: []
  type: TYPE_NORMAL
- en: Why are speed and performance so good in static websites?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Static site generators are tools that assist with the creation of static websites
    through the transformation of source files (such as Markdown or templates) into
    static HTML, CSS, and JavaScript files. They are well known for outperforming
    dynamic websites in terms of speed and performance for many different reasons
    that we are going to learn about now:'
  prefs: []
  type: TYPE_NORMAL
- en: '**On-demand page content**: In contrast to dynamic websites, which construct
    pages on the spot according to every request, static site generators pre-build
    all pages throughout the build process. When a user requests a page, the website’s
    server can just send the already created HTML file, making it quicker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caches static files**: **Content delivery networks** (**CDNs**) and websites
    can readily cache static files. CDNs can keep replicas of static files on hosts
    all around the globe, enabling users to view material from a location near them.
    This decreases latency and speeds up loading times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data compression**: Static site generators frequently contain tools for minimizing
    and compressing assets such as HTML, CSS, and JavaScript. This decreases file
    sizes, resulting in quicker transmission and loading times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decreased web page loading times**: Because the web pages are pre-built,
    the computer running them does not have to spend time performing server-side code
    or searching databases. This minimizes system strain and enables the computer
    to process additional requests at the same time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Robust security settings**: Given that static internet pages do not have
    databases or server-side programming, they are less susceptible to attacks such
    as **SQL injection** and **cross-site scripting** (**XSS**). This can boost performance
    immediately by lowering the chances of the website being hacked and dragged down
    by criminal activity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, basically, static site generators provide various advantages to website
    developers, including faster performance, improved security, and simpler maintenance
    and upgrading. It is critical to be aware of the most common static site generators
    on the market, as well as the step-by-step instructions for installing a static
    site generator.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the best practices for configuring a static site generator is also useful
    in ensuring that your brand’s website functions properly from the start. Finally,
    as with all computer users, it is critical to track your static website on a regular
    basis to maintain constant peak performance and to detect any possible dangers.
    Using a static site generator is a good option for people who want to take their
    website-building skills to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: With our knowledge in this area boosted, let’s move on to SSR so that we are
    also able to talk about this topic in depth when asked about it.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we’ll look at one of the most efficient and successful methods
    for creating fast-loading web pages: SSR. Using SSR techniques ensures that the
    website loads swiftly and looks good on all devices. We will discuss what it implies,
    how it works, why it is essential, and the benefits of employing this strategy
    over other ones.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, with the aforementioned information, we will learn how it becomes much
    easier to improve our site’s user experience and have greater control over loading
    times so our users can access material more quickly and without interruption.
    When we are done with this chapter, we will have all the knowledge we need to
    explain what SSR is. Now, let’s answer some of the biggest questions about SSR.
  prefs: []
  type: TYPE_NORMAL
- en: What is SSR and why is it important?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Websites must load as quickly as possible. This is where SSR enters the picture.
    The process of producing a web page on the server side before delivering it to
    the client’s browser is known as SSR. This significantly speeds up the process
    because the server could provide a pre-populated HTML file to the browser, instead
    of waiting for the browser to request the necessary assets and construct the HTML
    file itself.
  prefs: []
  type: TYPE_NORMAL
- en: This not only enhances the user experience but also provides major SEO benefits,
    because search engines can crawl server-side-rendered material more readily than
    client-side-generated content. In brief, SSR is an important strategy for assuring
    faster load times and improved search engine exposure.
  prefs: []
  type: TYPE_NORMAL
- en: How does SSR work? The fundamentals of SSR page loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSR is a method that can significantly enhance a website’s speed and user experience.
    SSR is a means of rendering a web page on the server before transmitting it to
    the client (browser). When a user requests a page, the server creates the HTML,
    populates it with basic data, and returns it to the client as a pre-rendered page.
    This strategy greatly decreases the amount of time it requires to load a website
    and enables quicker CSR. SSR, in basic terms, gives a quicker, more efficient,
    and more intuitive experience by generating a page with preliminary material on
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: What are the advantages of SSR?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most crucial elements for websites right now is their loading speed.
    Nobody likes waiting for a website to load, which is where SSR comes in. SSR enables
    the server to build a website’s HTML code before it is transmitted to the browser,
    resulting in quicker loading times, enhanced SEO, and greater user accessibility.
    Additionally, SSR can aid in the prevention of frequent difficulties, such as
    content loading before it’s ready (which may lead to broken designs) and content
    moving around the screen. This results in a smoother user experience. Overall,
    the benefits of SSR make it an essential component in the development of successful
    and efficient websites.
  prefs: []
  type: TYPE_NORMAL
- en: 'When utilized in web applications, SSR offers various benefits. Among these
    many advantages, we can find many reasons why it is seeing such high usage these
    days. Let’s learn more:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Strong SEO**: Because the final programming files are created on the server
    before being transmitted to the client’s web browser, search engines can simply
    scan and index server-rendered content. This helps search engines comprehend and
    rate your website, increasing its prominence in the search results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic data**: SSR is appropriate for apps that demand regular updates or
    that require clients to see personalized content. Because the content is created
    on the server, it is able to be readily changed or customized depending on input
    from users, cookies, or additional factors without requiring the whole website
    to be rebuilt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fast loading times**: When compared to CSR, SSR can give quicker initial
    page load times because the browser obtains completely rendered HTML content from
    the server, removing the requirement to wait on JavaScript to load and run before
    showing the content on the screen. This can lead to improved user perception of
    website performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web browser legacy support**: With SSR, we can improve support for outdated
    browsers and devices with restricted JavaScript capabilities. As the data is displayed
    on the server, regardless of whether certain JavaScript capabilities are available
    or not, these browsers can view them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With SSR, we gain a lot of advantages, but we also need to take into account
    how SSR can have a detrimental effect on our applications. Next, we will see what
    the disadvantages are and learn whether they are dealbreakers.
  prefs: []
  type: TYPE_NORMAL
- en: What are the disadvantages of SSR?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although SSR has advantages such as increased SEO and faster beginning load
    times, it also has some drawbacks. Let’s take a look at some of these drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application server requirements**: To display and transmit the content, SSR
    depends on the server. If the server is experiencing latency or is down, this
    can lead to problems because the whole website could become unreachable or load
    slowly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**More complex architecture**: The application architecture becomes more complicated
    when SSR is implemented because server-side programming and administration are
    needed. Debugging and upkeep could become more difficult as a result, while development
    time might go up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching issues**: Compared to static files, dynamic material produced by
    SSR is frequently harder to adequately cache. As a result, caching’s performance
    advantages might be diminished, and the workload of servers can escalate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decreased server efficiency**: SSR will raise server load and CPU use, particularly
    on sites with heavy traffic, because it necessitates the server rendering the
    pages for each request. As a result, there may be a demand for more robust and
    pricey infrastructure for servers and longer turnaround times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regardless of these drawbacks, SSR can still be a useful option in some circumstances,
    such as if SEO is a necessity or if dynamic material has to be displayed rapidly.
    Before selecting a rendering strategy, it is crucial to analyze the benefits and
    drawbacks and consider the specific needs of your project.
  prefs: []
  type: TYPE_NORMAL
- en: Remaining on topic, let’s now segue into the subject of SEO, which is related
    to page metadata. This will give us answers to the interview question on how we
    can improve the SEO for our applications and websites.
  prefs: []
  type: TYPE_NORMAL
- en: Adding page metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding page information to enhance SEO does not have to be challenging. Once
    we have gone through this section, we should be able to grasp and talk about the
    fundamentals of increasing a website’s visibility via the use of SSG and other
    techniques. As soon as we grasp the principles, it becomes so much easier to develop
    pages, giving us the real-world experience needed for coming up with answers to
    questions on creating better SEO.
  prefs: []
  type: TYPE_NORMAL
- en: What is page metadata and why is it important for SEO?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to increase traffic to your website, SEO is essential. Page metadata
    is possibly one of the most crucial components of a good SEO strategy, but there
    are many more. Title tags, meta descriptions, and keywords are examples of metadata,
    which is information that characterizes the content of a web page. The material
    on your website might be better understood by search engines and made more interesting
    to potential visitors by optimizing your metadata. In simple terms, page metadata
    functions as a roadmap for both visitors and search engines, making it a crucial
    part of any SEO plan.
  prefs: []
  type: TYPE_NORMAL
- en: What types of page metadata can be used for SSG?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Understanding the significance of page information is essential for creating
    static sites. In principle, metadata is information about information, and it
    aids search engines in understanding the purpose of your website. Title tags,
    meta descriptions, and alt text are just a few examples of the several kinds of
    information that are regularly used on a website. The words that show in your
    web browser’s tab are called title tags, and meta descriptions give a one-sentence
    overview of the contents of the page. Images are frequently accurately classified
    by search engines when they include descriptive alt text. You can boost the search
    engine ranking of your website and make a guarantee that what you publish is correctly
    indexed by including these various sorts of metadata.
  prefs: []
  type: TYPE_NORMAL
- en: To make it clear how much of an impact metadata can have, we are going to learn
    about some popular types. We will now learn about meta titles, meta descriptions,
    meta viewports, meta robots, meta authors, meta language, and open graph tags.
  prefs: []
  type: TYPE_NORMAL
- en: What is a meta title?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any website’s SEO plan has to include title tags. Make sure they appropriately
    represent the content on each page, because they are the first thing that search
    engines such as Google notice when they crawl your website. In addition to essential
    keywords, title tags should be clear, comprehensible, and interesting. Your search
    engine rankings can be enhanced, and the number of clicks can be increased with
    a well-written title tag. So, whether you’re developing a new website or optimizing
    an existing one, pay special attention to your title tags and make sure they’re
    successful in drawing attention to your website.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see what that looks like in an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The title tag basically describes a website page.
  prefs: []
  type: TYPE_NORMAL
- en: What are meta descriptions?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Meta descriptions are now a crucial component of website optimization in the
    ever-changing world of SEO. These text excerpts offer an ideal chance to persuade
    potential customers to visit your website. Standing out from the crowd is accomplished
    by creating an engaging meta description that uses your chosen keywords. Meta
    descriptions can help your website’s overall search engine rankings, so it’s not
    only about gaining clicks. Spend some time creating a clear, direct meta description
    that appropriately summarizes your content and draws visitors who are looking
    for the things you are able to provide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The content of this tag gives a summary of the web page’s content.
  prefs: []
  type: TYPE_NORMAL
- en: What is a meta viewport?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A meta viewport is a form of metadata element that is used in a web page’s HTML
    code to manage the layout and scaling of the website’s content on multiple devices,
    particularly mobile devices with various screen sizes and resolutions. The meta
    viewport tag is critical to rendering a website responsive and easy to use on
    phones, tablets, and other mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a meta viewport:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code tells the browser how to control the width of the page and to give
    it a scale of 1, which is useful when viewed on mobile devices. It helps the page
    to display better on mobile and these options enable a website to adjust and be
    responsive.
  prefs: []
  type: TYPE_NORMAL
- en: What are meta robots?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Meta robots are a form of metadata element that is used in a web page’s HTML
    code to guide search engine crawlers (also known as robots, spiders, or bots)
    on how to index or follow links on a website. Website administrators can regulate
    the behavior of search engine crawlers when they view their website’s pages with
    the use of meta robot tags, which helps to optimize indexing and avoid potential
    SEO concerns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `noindex` value instructs the crawler not to index this
    page, meaning it won’t show up in search results, while the `nofollow` value instructs
    the crawler not to follow any links from this page.
  prefs: []
  type: TYPE_NORMAL
- en: What are meta authors?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The meta author tag is a form of metadata element that is used in a web page’s
    HTML code to denote the writer or creator of the material on the website. This
    tag is not directly connected to SEO, but it can give useful details about the
    individual or organization that manages the written material on a website’s page
    to users or search engines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This tells everyone looking at the HTML that Sarah Thomas created the web page.
  prefs: []
  type: TYPE_NORMAL
- en: What is a meta language?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The meta language tag, commonly referred to as the *Content-Language* meta tag,
    is a form of metadata element that specifies the principal language of a home
    page’s information in the HTML code. This tag assists search engines, web browsers,
    and other online services in understanding the content’s language, which might
    be important for searching, interpreting, and accessibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see what that looks like in this code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The HTML element in this example uses the `lang="en"` property to specify that
    the entire HTML page is written in English. The `<meta http-equiv="Content-Language"
    content="en-us">` tag further states that the content is written in American English.
  prefs: []
  type: TYPE_NORMAL
- en: What are open graph tags?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open graph tags are responsible for making links on social media platforms look
    more visually appealing than others. You can decide how links to your website
    appear on social networking sites such as Facebook, Twitter/X, and LinkedIn, among
    others, by using open graph tags, which are HTML code snippets. You can customize
    the picture, title, and description that appears when someone shares the link
    by using open graph tags on your website. As a result, you have the ability to
    provide your audience with a more interesting and aesthetically appealing link
    preview, which can eventually result in increased interaction and clickthrough
    rates. So, think about using it if you want your website to stand out on social
    networking sites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see an open graph tag example in the code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code demonstrates the use of open graph tags using examples from Twitter/X
    and Facebook.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a better understanding of the usage of these tags, another
    important area that we should be aware of is website auditing. This is where we
    essentially run tests on our web page to test its SEO capability with those meta
    tags that we learned about, which are going to give us a much higher website score.
    The **Lighthouse** Chrome extension is a very popular choice for website auditing.
    Let’s learn about it now.
  prefs: []
  type: TYPE_NORMAL
- en: How can we use the Lighthouse extension to audit our website?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lighthouse is an open source, automated tool for enhancing web app performance,
    quality, and accuracy. Lighthouse audits a page by running a series of tests against
    it and then generating a report on how effectively the page performed. Based on
    the results, you can take advantage of the failed tests to determine what you
    need to do to enhance your app.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be learning about SEO best practices, where we
    will get even more valuable knowledge that will be useful when it comes to deploying
    a real-world application online.
  prefs: []
  type: TYPE_NORMAL
- en: SEO best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SEO is the process of improving a website’s ranking in search engine results
    by optimizing its content, structure, and other aspects. So, we should be implementing
    SEO best practices that can assist our website in ranking better in search engine
    results. By doing this, it increases our chances of being able to attract more
    organic visitors and improve its overall online visibility. There are many ways
    we can accomplish this and some of them are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Strategy** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| **Meta tags** | Create distinct and captivating meta titles and descriptions
    for each page. Because these are the snippets that appear in search engine results,
    they should be accurate representations of the material. |'
  prefs: []
  type: TYPE_TB
- en: '| **Page** **load speed** | Optimize the loading speed of your website to create
    a better user experience and improve search engine results. Compress pictures,
    reduce code, and make use of browser caching. |'
  prefs: []
  type: TYPE_TB
- en: '| **URL structure** | Use descriptive, easy-to-read URLs that indicate the
    theme of the item. Avoid using long, complicated URLs with extraneous arguments.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Good content** | Create relevant, insightful, and entertaining content
    that speaks to your target audience’s requirements. The writing should be correctly
    written, understandable, and related to the subject or keywords. |'
  prefs: []
  type: TYPE_TB
- en: '| **Mobile optimization** | Websites tend to get high traffic from mobile users,
    even higher than that from desktop users. As mobile compatibility is a ranking
    criterion for search engines, make sure that the site is responsive and mobile-friendly.
    An excellent mobile experience increases user interest and their subsequent return.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Great UI** **and UX** | Focus on giving an enjoyable user experience by
    making navigation simple, calls to action obvious, and material organized properly.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Security certificate** | Install an SSL certificate on your website to
    ensure data encryption and to improve your search engine ranking. HTTPS is a ranking
    indication for Google. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.4: SEO best practices'
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully reached the end of this chapter and learned a great deal
    about the differences between the different metadata types. We will now be able
    to apply what we have learned when working on our React projects and when under
    interview conditions, as this knowledge will always be useful.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has offered a thorough examination of Next.js, Gatsby, and Remix,
    three potent, full stack React frameworks. We have gotten a greater grasp of how
    these technologies can be used to expedite the web development process and easily
    construct dynamic, data-driven apps by exploring their special features and use
    cases. We have covered key topics in contemporary web development along the way,
    including the creation of static sites, SSR, and the addition of page information
    for SEO. We have paved the way for wise decision-making when picking the best
    tool for a certain project by analyzing the benefits and drawbacks of each framework.
  prefs: []
  type: TYPE_NORMAL
- en: Next.js, Gatsby, and Remix provide us with different choices for developing
    React applications. We have looked at the differences between all three of them,
    which gives us good interview answers because we can compare these differences
    and give a valid reason for why we would choose one over the other in our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we have covered useful information that has encouraged
    us to learn more about these frameworks and their strengths to ace interviews
    and stand out in an increasingly crowded market. The road to mastering Next.js,
    Gatsby, and Remix is only getting started, and there are countless opportunities
    for development and creativity. The ultimate potential of these technologies resides
    in your imagination, inventiveness, and resolve to push the limits of what is
    feasible in the field of web development as you continue to study and explore.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to crack real-world programming tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 4: Hands-On with Programming Tasks'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will learn about how to crack the coding tasks given in the
    interview process at a high level in a stipulated time. We will also get useful
    tips and recommendations before deep-diving into the projects. Then, we will build
    two React applications to showcase your programming skills – one app is based
    on Redux and styled-components along with the Firebase backend, and another app
    is based on the Next.js toolkit, GraphQL, and SWR using the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18603_10.xhtml#_idTextAnchor297), *Cracking Any Real-World
    Programming Task*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B18603_11.xhtml#_idTextAnchor316), *Building an App Based on
    React, Redux, Styled Components, and the Firebase Backend*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B18603_12.xhtml#_idTextAnchor339), *Building an App Based on
    the Next.js Toolkit, Authentication, SWR, GraphQL, and Deployment*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
