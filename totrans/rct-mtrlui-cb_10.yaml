- en: Buttons - Initiating Actions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll learn about the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Button variants
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Button emphasis
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Link buttons
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Floating actions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Icon buttons
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Button sizes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Buttons in Material-UI applications are used to initiate actions. The user clicks
    on a button and something happens. What happens when a button is activated is
    entirely up to you. Material-UI buttons range in complexity from simple text buttons
    to floating action buttons.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Button variants
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Material-UI `Button` component exists as one of three variants. These are
    as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '`Text`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Outlined`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Contained`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s some code that renders three `Button` components, each explicitly setting
    their `variant` property:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When you load the screen, here''s what you''ll see:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1989266-5989-42d6-be32-e7503cebf345.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `variant` property controls the type of button that's rendered. The three
    variants can be used in different scenarios or contexts as you see fit. For example,
    TEXT buttons draw less attention if this is what you need. Conversely, CONTAINED
    buttons try to stand out as an obvious interaction point for the user.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The default variant is `text`. I find `Button` markup easier to read when you
    explicitly include the variant. This way, you or anyone else reading the code
    don't have to remember what the default `variant` is.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Button` demos: [https://material-ui.com/demos/buttons/](https://material-ui.com/demos/buttons/)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Button` API documentation: [https://material-ui.com/api/button/](https://material-ui.com/api/button/)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Button emphasis
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `color` and `disabled` properties of `Button` let you control the emphasis
    of a button relative to its surroundings. For example, you can specify that a
    button should use the `primary` color value. The emphasis of a button is the cumulative
    result of the `variant` and `color` properties. You can adjust both until the
    button has the appropriate emphasis.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: There is no *right* level of emphasis. Use what makes sense in the context of
    your application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s some code that shows the different color values that you can apply
    to `Button` components:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here''s what you''ll see when the screen first loads:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66673a02-2bac-4bb2-a7a8-fee8db117207.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: 'And if the `disabled` property is `true`, here''s what you''ll see:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/025f7332-1043-4118-a333-f8a14852fa8b.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This example serves to illustrate the combinatorial result of the `variant`
    and `color` properties. Alternatively, you can completely disable buttons and
    yet still control the `variant` aspect of their emphasis (the `color` property
    has no effect on disabled buttons).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'The order of most to least emphatic `variant` values is as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '`contained`'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`outlined`'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`text`'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The order of most to least emphatic `color` values is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '`primary`'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`secondary`'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`default`'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By combining these two property values, you can control the emphasis of your
    buttons. Sometimes, you really need a button to stand out, so you can combine
    `contained` and `primary`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7de4ec33-441f-407b-96eb-a0350e70dd2e.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: 'If you want your button to not stand out at all, you can combine the `text`
    variant with `default` color:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95673d2f-8e54-48d5-b42a-056a095a514c.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: There's more...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If your button is placed in another Material-UI component, it can be difficult
    to ensure the correct color choice. For example, let''s say that you have some
    buttons in an `AppBar` component, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If the `AppBar` color value is `default`, here''s what you''ll see:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d78c451f-9ef4-408b-ba80-a1a31e41bbb0.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: 'This doesn''t actually look too bad because the buttons themselves are using
    the default color. But what happens if you change the `AppBar` color to `primary`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53b934f2-30b9-40f4-8efd-3966b2b26e89.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: 'The `contained` variant is the only button that even comes close to looking
    like it belongs in the App Bar. Let''s modify the buttons so that they all use
    the `inherit` color property value, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, your App Bar and buttons look like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f58c6039-6817-4cc1-9457-4143d966bba8.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: The TEXT and OUTLINE buttons look much better now. They've inherited the theme
    font color from their parent component. The CONTAINED button actually looks worse,
    now that it's using `inherited` as its font color. This is because the background
    color of CONTAINED buttons doesn't change when inheriting colors. So instead,
    you have to change the color of CONTAINED buttons yourself.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see whether we can automatically set the color of a CONTAINED button
    based on the color of its parent by implementing a function that returns the color
    to use:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, you can use this `function` when you''re setting the `color` of your `contained`
    buttons. Just make sure that you pass it the `color` of the parent as an argument,
    as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, if you change your App Bar color to `primary`, here''s what your buttons
    look like:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7512c5fa-73b2-433c-98b3-34364772c8cb.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: 'Here''s what your buttons look like if you change the App Bar color to `secondary`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d27de2e-683b-4231-a1ac-cc1c59d0d5ae.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: 'To quickly recap: TEXT and OUTLINED buttons can safely use `inherit` as a color.
    If you''re working with CONTAINED buttons, you need to take extra steps to use
    the correct color, like you did with the `buttonColor()` function.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Button` demos: [https://material-ui.com/demos/buttons/](https://material-ui.com/demos/buttons/)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Button` API documentation: [https://material-ui.com/api/button/](https://material-ui.com/api/button/)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AppBar` API documentation: [https://material-ui.com/api/app-bar/](https://material-ui.com/api/app-bar/)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Toolbar` API documentation: [https://material-ui.com/api/toolbar/](https://material-ui.com/api/toolbar/)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Link buttons
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Material-UI `Button` components can also be used as links to other locations
    in your app. The most common example is using a button as a link to a route declared
    using `react-router`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Material-UI 的 `Button` 组件也可以用作链接，指向应用中的其他位置。最常见的例子是将按钮用作通过 `react-router` 声明的路由的链接。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s say that your application has three pages, and you need three buttons
    that link to each of them. You''ll probably need buttons to link to them from
    arbitrary places too, as the application grows. Here''s the code to do it:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的应用有三个页面，你需要三个按钮将它们链接到每个页面。随着应用的扩展，你可能还需要从任意位置链接到它们。以下是实现这一点的代码：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Storybook code that sets up this example to run includes a `BrowserRouter`
    component. In your code, you'll need to include this component as a parent of
    any of your `Route` components.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 设置此示例以运行的 Storybook 代码包括一个 `BrowserRouter` 组件。在你的代码中，你需要将此组件包含为任何 `Route` 组件的父组件。
- en: 'When the screen first loads, you''ll see the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当屏幕首次加载时，你会看到以下内容：
- en: '![](img/9e5a9913-ccc1-419a-9eb8-6531161cacb4.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e5a9913-ccc1-419a-9eb8-6531161cacb4.png)'
- en: 'If you click on the Page 2 button, you''ll be taken to `/page2`, and the content
    will update accordingly:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击“页面 2”按钮，你将被带到 `/page2`，内容将相应更新：
- en: '![](img/4f58395b-38bb-4f95-aecf-0bdf01e32aa2.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f58395b-38bb-4f95-aecf-0bdf01e32aa2.png)'
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When you use `react-router` as the router for your application, you can render
    links using the `Link` component from `react-router-dom`. Since you want to render
    Material-UI buttons in order to get the consistent Material-UI theme and user
    interaction behavior, you can''t render `Link` components directly. Instead, you
    can make the underlying `Button` component a `Link` component, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `react-router` 作为应用的路由器时，你可以使用来自 `react-router-dom` 的 `Link` 组件来渲染链接。由于你想要渲染
    Material-UI 按钮以获得一致的 Material-UI 主题和用户交互行为，你不能直接渲染 `Link` 组件。相反，你可以将底层的 `Button`
    组件变成一个 `Link` 组件，如下所示：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By using the `component` property, you can tell the `Button` component to apply
    styles and event handling logic to this component instead of the default. Then,
    any additional properties that you would normally pass to `Link` are set on the
    `Button` component—which forwards them to `Link`. For example, the `to` property
    isn't a `Button` property, so it gets passed to `Link`, which requires it in order
    to work.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `component` 属性，你可以告诉 `Button` 组件将样式和事件处理逻辑应用到该组件而不是默认样式。然后，任何你通常传递给 `Link`
    的附加属性都设置在 `Button` 组件上——并将它们转发给 `Link`。例如，`to` 属性不是 `Button` 的属性，所以它被传递给 `Link`，这是它工作所必需的。
- en: There's more...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: One problem with this example is that there's no visual indication that a button
    links to the current URL. For example, when the app first loads the `/` URL, the
    Home button should stand out from the other buttons. One way to do this would
    be to change the `color` property to `primary` if the button is considered active.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的一个问题是，没有视觉指示按钮链接到当前 URL。例如，当应用首次加载 `/` URL 时，主页按钮应该从其他按钮中突出出来。一种方法是将 `color`
    属性更改为 `primary`，如果按钮被认为是活动的。
- en: You could use the `NavLink` component from `react-router-dom`. This component
    lets you set styles or class names that are only applied when the link is active.
    The challenge with doing this is that you only need to change a simple `Button`
    property when it is active. Having to maintain styles for active buttons seems
    like a bit much, especially if you want to make your UI easy to theme.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用来自 `react-router-dom` 的 `NavLink` 组件。这个组件允许你设置仅在链接活动时应用的样式或类名。挑战在于，你只需要在活动时更改一个简单的
    `Button` 属性。维护活动按钮的样式似乎有点多，尤其是如果你想使你的 UI 容易主题化。
- en: 'Instead, you can create a button abstraction that uses `react-router` tools
    to `render` the appropriate `Button` property when it''s active, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以创建一个按钮抽象，使用 `react-router` 工具在活动时渲染适当的 `Button` 属性，如下所示：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `NavButton` component uses `Switch` and `Route` components to determine
    the active route. It does this by comparing the `to` property passed to `NavButton`
    against the current URL. If a match is found, the `Button` component is rendered
    with the `color` property set to `primary`. Otherwise, no color is specified (if
    the first `Route` in `Switch` doesn''t match, the second `Route` matches everything).
    Here''s what the new component looks like in action:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavButton`组件使用`Switch`和`Route`组件来确定活动路由。它是通过比较传递给`NavButton`的`to`属性与当前URL来做到这一点的。如果找到匹配项，则渲染带有`color`属性设置为`primary`的`Button`组件。否则，不指定颜色（如果`Switch`中的第一个`Route`不匹配，则第二个`Route`匹配一切）。以下是新组件在操作中的样子：'
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here''s what the screen looks like when it first loads:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是屏幕首次加载时的样子：
- en: '![](img/c51b0917-d769-46e3-90f2-a7d89b2debdf.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c51b0917-d769-46e3-90f2-a7d89b2debdf.png)'
- en: Because the initial URL is `/`, and the first `NavButton` component has a `to`
    property of `/`, the Home button color is marked as `primary`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因为初始URL是`/`，并且第一个`NavButton`组件有一个`to`属性为`/`，所以主页按钮颜色被标记为`primary`。
- en: See also
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`Button` demos: [https://material-ui.com/demos/buttons/](https://material-ui.com/demos/buttons/)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Button`演示：[https://material-ui.com/demos/buttons/](https://material-ui.com/demos/buttons/)'
- en: '`Button` API documentation: [https://material-ui.com/api/button/](https://material-ui.com/api/button/)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Button` API 文档：[https://material-ui.com/api/button/](https://material-ui.com/api/button/)'
- en: React Router Guide: [https://reacttraining.com/react-router/web/guides/quick-start](https://reacttraining.com/react-router/web/guides/quick-start)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Router 指南：[https://reacttraining.com/react-router/web/guides/quick-start](https://reacttraining.com/react-router/web/guides/quick-start)
- en: Floating actions
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮动操作
- en: Some screens in your application will have one primary action. For example,
    if you're on a screen that lists items, the primary action might be to add a new
    item. If you're on an item details page, the primary action might be to edit the
    item. Material-UI provides a `Fab` component (floating action button) to show
    primary screen actions in a prominent way.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序中的某些屏幕将有一个主要操作。例如，如果你在一个列出项目的屏幕上，主要操作可能是添加新项目。如果你在一个项目详情页面上，主要操作可能是编辑项目。Material-UI
    提供了一个`Fab`组件（浮动操作按钮），以突出显示主要屏幕操作。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: The common case for floating action buttons is to show the user a round button
    with an icon representing the action to perform, positioned in the bottom right
    of the screen. Also, the position of floating action buttons is `fixed`, meaning
    that as the user scrolls down the page, the primary action is always visible.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 浮动操作按钮的常见情况是向用户展示一个带有表示要执行的操作的图标、位于屏幕右下角的圆形按钮。此外，浮动操作按钮的位置是`固定`的，这意味着当用户滚动页面时，主要操作始终可见。
- en: 'Let''s write some code to `position` a floating action button at the bottom
    right of the screen that indicates an add action, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码来`定位`一个位于屏幕右下角的浮动操作按钮，以指示添加操作，如下所示：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When you load the screen, you''ll see the following in the bottom right-hand
    corner:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你加载屏幕时，你会在屏幕右下角看到以下内容：
- en: '![](img/8eed2d83-68f2-4224-b463-781c8bd0399f.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8eed2d83-68f2-4224-b463-781c8bd0399f.png)'
- en: 'The component for this screen has a `fabColor` property that is used to set
    the color of the `Fab` component. Here''s what the `primary` color looks like:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 该屏幕组件有一个`fabColor`属性，用于设置`Fab`组件的颜色。以下是`primary`颜色的样子：
- en: '![](img/915e8698-f21d-4f49-8f5e-b104389dffed.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/915e8698-f21d-4f49-8f5e-b104389dffed.png)'
- en: 'Lastly, here''s what the floating action button looks like with `secondary`
    as the color:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是以`secondary`颜色为背景的浮动操作按钮的样子：
- en: '![](img/3c430b6f-6209-45a9-8f57-c10f5716c3d0.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3c430b6f-6209-45a9-8f57-c10f5716c3d0.png)'
- en: How it works...
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Fab` component is very similar to a `Button` component. In fact, you used
    to use `Button` to render floating action buttons, using the `fab` variant. The
    rounded styling of the button is handled by `Fab`. You just need to support the
    icon and any other button properties, such as `onClick` handlers. Additionally,
    you can include text in your floating action buttons. If you do, you should use
    the `extended` variant so that the shape of the button is styled correctly (flat
    top and bottom instead of rounded).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fab`组件与`Button`组件非常相似。实际上，你过去使用`Button`来渲染浮动操作按钮，使用`fab`变体。按钮的圆角样式由`Fab`处理。你只需要支持图标和任何其他按钮属性，例如`onClick`处理程序。此外，你可以在浮动操作按钮中包含文本。如果你这样做，你应该使用`extended`变体，以便正确地样式化按钮的形状（顶部和底部是平的而不是圆角）。'
- en: There's more...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's create a small abstraction for `Fab` components that applies the `fab`
    style and uses the correct variant. Since the `extended` variant is only useful
    when there's text in the button, you shouldn't have to remember to set it every
    time you want to use it. This can be especially confusing if your application
    has both icon and icon plus text floating action buttons.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`Fab`组件创建一个小型的抽象，它应用`fab`样式并使用正确的变体。由于`extended`变体仅在按钮中有文本时才有用，因此你不需要每次使用时都记住设置它。如果你的应用程序既有图标又有图标加文本的浮动操作按钮，这可能会特别令人困惑。
- en: 'Here''s the code to implement the new `Fab` component:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现新`Fab`组件的代码：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `className` property is set in the same way as before. The `variant` property
    is set to extended when `isExtended` is `true`. To figure this out, it uses the
    `React.Children.toArray()` function to convert the `children` property into a
    plain array. Then, the `find()` method looks for any text elements. If one is
    found, `isExtended` will be `true` and the `extended` variant is used.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`className`属性设置方式与之前相同。当`isExtended`为`true`时，`variant`属性设置为`extended`。为了找出这一点，它使用`React.Children.toArray()`函数将`children`属性转换为普通数组。然后，`find()`方法查找任何文本元素。如果找到了一个，`isExtended`将为`true`，并使用`extended`变体。'
- en: 'Here''s how the new `ExtendedFab` button can be used:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用新的`ExtendedFab`按钮的：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Add`  text is placed before the `AddIcon` component. This `ExtendedFab` component
    has two children, and one of them is text, which means that the `extended` variant
    will be used. Here''s what it looks like:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`添加`文本放置在`AddIcon`组件之前。这个`ExtendedFab`组件有两个子组件，其中一个是有文本的，这意味着将使用`extended`变体。以下是它的样子：'
- en: '![](img/52f74cee-f4cd-4d90-95ad-63d8a2cfde77.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52f74cee-f4cd-4d90-95ad-63d8a2cfde77.png)'
- en: See also
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`Button` demos: [https://material-ui.com/demos/buttons/](https://material-ui.com/demos/buttons/)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`按钮`演示：[https://material-ui.com/demos/buttons/](https://material-ui.com/demos/buttons/)'
- en: '`Fab` API documentation: [https://material-ui.com/api/fab/](https://material-ui.com/api/fab/)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fab` API 文档：[https://material-ui.com/api/fab/](https://material-ui.com/api/fab/)'
- en: Icon buttons
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图标按钮
- en: Sometimes, you need a button that's just an icon. This is where the `IconButton`
    component comes in handy. You can pass it any icon component as a child, and then
    you have an icon button.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要一个仅是图标的按钮。这就是`IconButton`组件派上用场的地方。你可以传递任何图标组件作为子组件，然后你就有了一个图标按钮。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Icon buttons are especially useful when you're working with restricted screen
    real estate or when you want to visually show the toggled state of something.
    For example, it might be easier for a user to toggle the state of a microphone
    if the enabled/disabled state indicates the actual microphone.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图标按钮在你处理受限的屏幕空间或想要直观地显示某物的切换状态时特别有用。例如，如果启用/禁用状态表示实际的麦克风，用户切换麦克风的开关可能更容易。
- en: 'Let''s build on this idea and implement toggle controls for the microphone
    and volume in an app, using icon buttons. Here''s the code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在此基础上构建，并在应用程序中使用图标按钮实现麦克风和音量的切换控制。以下是代码：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When you first load the screen, here''s what you''ll see:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当你首次加载屏幕时，你会看到以下内容：
- en: '![](img/38a82707-4b3d-4300-b0e4-756e234025b5.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38a82707-4b3d-4300-b0e4-756e234025b5.png)'
- en: 'If you click on both icon buttons, here''s what you''ll see:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击两个图标按钮，你会看到以下内容：
- en: '![](img/4c5eec29-3c62-4483-aa40-4632a88523e0.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c5eec29-3c62-4483-aa40-4632a88523e0.png)'
- en: No matter the state of the microphone or volume, the user can still have a visual
    indication of the item and its state.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 无论麦克风或音量的状态如何，用户仍然可以有一个对项目及其状态的视觉指示。
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The component for this screen maintains two pieces of state: `mic` and `volume`.
    Both of these are Booleans that control the icon that''s displayed in the `IconButton`
    component:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此屏幕的组件维护两个状态：`mic`和`volume`。这两个都是布尔值，用于控制`IconButton`组件中显示的图标：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, based on these states, the icon is swapped as the `state` changes, giving
    useful visual feedback to the user:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，基于这些状态，当`状态`改变时，图标会相应交换，为用户提供有用的视觉反馈：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Additionally, the component for this screen takes an `iconColor` property,
    which can be either `default`, `primary`, or `secondary`. Here''s what the `primary`
    color looks like:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，此屏幕的组件接受一个`iconColor`属性，它可以是`default`、`primary`或`secondary`。以下是`primary`颜色的样子：
- en: '![](img/874be03e-b127-4d30-a750-52ca0048f937.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/874be03e-b127-4d30-a750-52ca0048f937.png)'
- en: See also
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`Button` demos: [https://material-ui.com/demos/buttons/](https://material-ui.com/demos/buttons/)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`按钮`演示：[https://material-ui.com/demos/buttons/](https://material-ui.com/demos/buttons/)'
- en: '`IconButton` API documentation: [https://material-ui.com/api/icon-button/](https://material-ui.com/api/icon-button/)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IconButton` API 文档：[https://material-ui.com/api/icon-button/](https://material-ui.com/api/icon-button/)'
- en: Button sizes
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按钮尺寸
- en: Material-UI buttons support tee shirt-style sizing. Rather than try to find
    the perfect size for your buttons, you can use one of the predefined sizes that
    comes closest to what you need.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Material-UI按钮支持T恤式尺寸。与其试图为您的按钮找到完美的尺寸，您可以使用最接近您需求的预定义尺寸之一。
- en: How to do it...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'If you need to adjust the size of your buttons, you can use `small`, `medium`
    (the default), or `large`. Here''s an example of how to set the `size` of a `Button`
    component:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要调整按钮的大小，可以使用`small`、`medium`（默认值）或`large`。以下是如何设置`Button`组件的`size`的示例：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here''s what the various sizes look like:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是各种尺寸的外观：
- en: '![](img/188f56ea-4786-456c-915f-b35471092868.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/188f56ea-4786-456c-915f-b35471092868.png)'
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The distinction between sizes is greatest between medium and large. Using a
    large button, in conjunction with other `Button` properties, such as `color` and `Icons`,
    can really make a button stand out.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 中等尺寸和大型尺寸之间的区别最大。使用大型按钮，结合其他`Button`属性，如`color`和`Icons`，可以使按钮真正脱颖而出。
- en: There's more...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The one downside to using tee shirt sizes with buttons is when you combine text
    and icon images. The icon doesn't scale the same as the text, so the button never
    looks quite right, unless the medium default size is used.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带按钮的T恤尺寸的一个缺点是，当结合文本和图标图像时。图标不会像文本一样缩放，所以按钮看起来永远不太对劲，除非使用中等默认尺寸。
- en: 'Let''s implement a button abstraction that makes it easier to use text buttons
    or icon buttons that can be resized consistently. Here''s the code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个按钮抽象，使其更容易使用可一致调整大小的文本按钮或图标按钮。以下是代码：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here''s what the three buttons on the screen look like when the `size` property
    is set to `small`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当`size`属性设置为`small`时，屏幕上三个按钮的外观如下：
- en: '![](img/1261dea1-0dd8-475a-984b-caf142057f2b.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1261dea1-0dd8-475a-984b-caf142057f2b.png)'
- en: 'And here''s the `large` size:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`large`尺寸的外观：
- en: '![](img/c1a496e8-71c5-4662-a012-5ae98aba6d0a.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1a496e8-71c5-4662-a012-5ae98aba6d0a.png)'
- en: 'Let''s break down what''s going on in the `MyButton` component. It expects
    a single `child` node, which it gets by turning the `children` property into an
    array and assigning the first element to the `child` constant:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析`MyButton`组件中正在发生的事情。它期望一个单一的`child`节点，它通过将`children`属性转换为数组并将第一个元素分配给`child`常量来获取：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The idea is to render the appropriate `Button` element, depending on the `child`
    element and the `fab` property. Here''s how the correct component is assigned
    to `ButtonComponent`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是根据`child`元素和`fab`属性渲染适当的`Button`元素。以下是正确组件分配给`ButtonComponent`的方式：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the `child` is an element and the `fab` property is true, then the `Fab`
    component is used. If the child is an element and `fab` is false, `IconButton`
    is used. Otherwise, `Button` is used. This means that you can pass either a valid
    icon element or text as a child to `MyButton`. Setting the size on any buttons
    rendered with this component will be consistent.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`child`是一个元素且`fab`属性为真，则使用`Fab`组件。如果`child`是一个元素且`fab`为假，则使用`IconButton`。否则，使用`Button`。这意味着您可以将有效的图标元素或文本作为子元素传递给`MyButton`。使用此组件渲染的任何按钮的大小设置都将保持一致。
- en: See also
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`Button` demos: [https://material-ui.com/demos/buttons/](https://material-ui.com/demos/buttons/)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Button`演示：[https://material-ui.com/demos/buttons/](https://material-ui.com/demos/buttons/)'
- en: '`Button` API documentation: [https://material-ui.com/api/button/](https://material-ui.com/api/button/)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Button` API 文档：[https://material-ui.com/api/button/](https://material-ui.com/api/button/)'
- en: '`IconButton` API documentation: [https://material-ui.com/api/icon-button/](https://material-ui.com/api/icon-button/)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IconButton` API 文档：[https://material-ui.com/api/icon-button/](https://material-ui.com/api/icon-button/)'
- en: '`Fab` API documentation: [https://material-ui.com/api/fab/](https://material-ui.com/api/fab/)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fab` API 文档：[https://material-ui.com/api/fab/](https://material-ui.com/api/fab/)'
