- en: Chapter 7. Components for User Experience
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。用户体验组件
- en: User experience is a core concern for developers building today's applications.
    We are no longer living in a world where users are contented with an application
    that just works. The expectations are much higher. Now, an application needs to
    be highly usable and should provide an efficient workflow; users also expect it
    to bring them pleasure while performing tasks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 用户体验是当今应用程序开发者的核心关注点。我们不再生活在一个用户对仅仅能工作的应用程序感到满意的世界。期望值要高得多。现在，一个应用程序需要高度可用，并且应该提供高效的工作流程；用户还期望它在执行任务时能带来愉悦。
- en: In this chapter, we're going to look at building some components that will increase
    the overall usability of our task management system. These features will enrich
    the current functionality and provide more efficient workflows.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨构建一些组件，这些组件将提高我们任务管理系统的整体可用性。这些功能将丰富当前的功能，并提供更高效的工作流程。
- en: 'We will develop the following three technical features and embed them into
    our current application, wherever applicable:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发以下三个技术特性，并将它们嵌入到我们当前的应用程序中，适用于任何地方：
- en: '**Tag management**: We''ll enable the use of tags within generated content,
    such as comments, activities, and other areas where they can be of any use. Tags
    will help users build links between content and navigation shortcuts.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签管理**：我们将启用在生成内容中使用标签，例如评论、活动和其他任何可以使用标签的地方。标签将帮助用户在内容和导航快捷方式之间建立链接。'
- en: '**Drag and drop**: We''ll build generic components that will make use of drag
    and drop features a breeze. By enabling drag and drop features, we''ll allow users
    to fulfill certain tasks with much higher efficiency.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拖放**：我们将构建通用的组件，使拖放功能变得简单易用。通过启用拖放功能，我们将允许用户以更高的效率完成某些任务。'
- en: '**Infinite scrolling**: We''ll build a component that will reveal the content
    of lists while scrolling. This feature is not going to directly increase the workflow
    performance, but it will help us increase the overall application performance.
    It will also narrow down the user''s context by only showing relevant information.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无限滚动**：我们将构建一个组件，在滚动时揭示列表的内容。这个功能不会直接提高工作流程性能，但它将帮助我们提高整体应用程序性能。它还将通过仅显示相关信息来缩小用户的上下文。'
- en: 'We''ll cover the following topics in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Creating a tag management system to enter and display tags
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个标签管理系统以输入和显示标签
- en: Creating a stateful pipe to render tags using a service
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个有状态的管道，使用服务渲染标签
- en: Using the `sanitize-html` module to sanitize potentially unsafe content
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `sanitize-html` 模块对可能不安全的内容进行清理
- en: Creating a component to autocomplete tags during user input
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个组件，在用户输入时自动完成标签
- en: Going through the basics of the HTML5 drag and drop API
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 HTML5 拖放 API 的基础知识
- en: Creating directives for draggable elements and drop targets
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为可拖动元素和放置目标创建指令
- en: Using `dataTransfer` objects and a custom attribute to enable selective drop
    targets
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `dataTransfer` 对象和自定义属性来启用选择性的放置目标
- en: Creating a custom `ForOf` repeater using the asterisk template syntax to enable
    infinite scrolling
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用星号模板语法创建一个自定义的 `ForOf` 重复器，以实现无限滚动
- en: Implementing custom change detection using the `DoCheck` lifecycle hook, and
    using `IterableDiffer` to apply DOM changes
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `DoCheck` 生命周期钩子实现自定义更改检测，并使用 `IterableDiffer` 应用 DOM 变更
- en: Performing dynamic view instantiation using `ViewContainer`
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ViewContainer` 执行动态视图实例化
- en: Tag management
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签管理
- en: The classical form of tagging enables you to associate a taxonomy with elements
    within a system and helps you organize your project. It allows you to have a many-to-many
    association that can be quickly managed, and you can use it later to filter relevant
    information.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的标签形式允许你将分类法与系统内的元素相关联，并帮助你组织项目。它允许你有一个可以快速管理的多对多关联，你可以在以后用它来过滤相关信息。
- en: In our task management system, we're going to use a slightly different version
    of tags. Our goal is to provide a way to have semantic shortcuts within the application.
    With the help of tags, a user should be able to cross-reference information between
    different parts of the data, providing a summary of the referenced entity as well
    as a navigation shortcut for the entity.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的任务管理系统中，我们将使用一个略有不同的标签版本。我们的目标是提供一种在应用程序内实现语义快捷方式的方法。借助标签，用户应该能够在不同部分的数据之间交叉引用信息，提供所引用实体的摘要以及实体的导航快捷方式。
- en: For example, we can include a `project` tag within a user comment. A user can
    enter the tag by simply typing in the project ID. When a comment is displayed,
    we see the title of the project and the number of open tasks within the project.
    But when we click on the tag, we directly reach the project detail page where
    the task is located.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在用户评论中包含一个`project`标签。用户可以通过简单地输入项目ID来输入标签。当显示评论时，我们看到项目的标题和项目中的打开任务数量。但是，当我们点击标签时，我们会直接到达任务所在的项目详情页面。
- en: In this section, we'll develop the required elements to provide a way to use
    `project` tags that will enable the user to cross-reference other projects within
    comments. We'll also use tag management in our activities, which we created in
    the previous chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发所需元素，以提供使用`project`标签的方法，这将使用户能够在评论中交叉引用其他项目。我们还将使用我们在上一章中创建的活动中的标签管理。
- en: Tag data entity
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签数据实体
- en: 'Let''s start with the tag entity that shows how we can represent tags within
    our system. We''ll create a new `Tag` class in a file under `tags/tag.js`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从表示我们如何在系统中表示标签的标签实体开始。我们将在`tags/tag.js`文件下创建一个新的`Tag`类：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This class represents tags; whenever we store tag information, we''ll use this
    entity as a data vehicle. Let''s look at the individual fields and elaborate on
    their use:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类代表标签；每次我们存储标签信息时，我们都会使用这个实体作为数据载体。让我们看看单个字段并详细说明它们的使用：
- en: '`textTag`: This is the text representation of a tag. All our tags need to be
    identified uniquely using this text representation. We can define the text representation
    of tags as follows:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`textTag`：这是标签的文本表示。我们所有的标签都需要使用这种文本表示来唯一标识。我们可以如下定义标签的文本表示：'
- en: Text tags always start with a hash symbol (`#`)
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本标签始终以井号符号（`#`）开头
- en: Text tags only contain word characters or the minus symbol (`-`)
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本标签只包含单词字符或减号符号（`-`）
- en: All the innards of a tag, defined by other properties (`title`, `link`, and
    `type`), can be extrapolated from the `textTag` property. It can therefore be
    considered an ID.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有由其他属性（`title`、`link`和`type`）定义的标签内部结构都可以从`textTag`属性中推断出来。因此，它可以被视为一个ID。
- en: '`title`: This is a comparatively longer text representation of a tag. It should
    contain as much detail about the subject as possible. In the case of project tags,
    this could mean the project title, open tags count, assignee, and other important
    information. Since this is the field that will be rendered if a tag is parsed,
    it''ll be beneficial if the content stays relatively condensed.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：这是标签的一个相对较长的文本表示。它应尽可能包含有关主题的详细信息。在项目标签的情况下，这可能意味着项目标题、打开的标签数量、负责人和其他重要信息。由于这是在解析标签时将渲染的字段，因此保持内容相对紧凑将是有益的。'
- en: '`link`: A valid URL, which will be used when the tag is rendered. This URL
    will make links clickable and enable the shortcut navigation. In the case of the
    projects tags we''re going to create, this will be a URL fragment identifier that
    will link to the given project page.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`link`：一个有效的URL，当渲染标签时将使用它。这个URL将使链接可点击，并启用快捷导航。在我们将要创建的项目标签的情况下，这将是一个URL片段标识符，它将链接到指定的项目页面。'
- en: '`type`: This is used to distinguish between different tags and provide us a
    way to organize tags at a higher granularity level.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：用于区分不同的标签，并为我们提供一种在更高粒度级别组织标签的方法。'
- en: So far, so good. We now have a data vehicle we can easily construct to transfer
    information about tags.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。我们现在有一个可以轻松构建的数据载体，用于传输有关标签的信息。
- en: Generating tags
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成标签
- en: 'Our next step is to create a factory that will generate tags for us. All we''d
    like to pass to the factory is a subject, which can be basically anything. The
    factory will then determine the type of the subject and execute the necessary
    logic to generate a tag from it. This might sound a bit abstract at first, but
    let''s look at the code of the `generateTag` function we''ll create in a module
    under `tags/generate-tag.js`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是创建一个工厂，为我们生成标签。我们希望传递给工厂的只是一个主题，这可以是基本上任何东西。然后，工厂将确定主题的类型并执行必要的逻辑来从它生成标签。这听起来可能一开始有点抽象，但让我们看看我们将在`tags/generate-tag.js`模块中创建的`generateTag`函数的代码：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's examine the `generateTag` function and what we're trying to achieve here.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`generateTag`函数以及我们在这里试图实现的目标。
- en: 'First, we determined the subject type by checking the type attribute of the
    `subject` object. In the case of project data objects, we know that the type will
    be set to `"project"`. The following three points succinctly explain what we''ve
    done:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过检查`subject`对象的类型属性来确定主题类型。在项目数据对象的情况下，我们知道类型将被设置为`"project"`。以下三个要点简要说明了我们所做的工作：
- en: Since we were sure that we were dealing with a project here, we generated a
    new tag. In the future, we'll deal with other subject types as well, so this check
    will be required.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们确信我们正在处理一个项目，所以我们生成了一个新的标签。在未来，我们还将处理其他主题类型，因此这个检查将是必需的。
- en: We wanted to use an indicator for all the open tasks in the tag title. For this
    reason, we did a quick filtering of open tasks within the project and stored the
    length of the filtered array in the `openTaskCount` constant.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望在标签标题中使用一个指标来表示所有未完成的任务。因此，我们在项目中快速筛选了未完成的任务，并将筛选数组的长度存储在`openTaskCount`常量中。
- en: Now we can instantiate a new `Tag` object using the project ID as `textTag`.
    For the `title` field, we used a helper function, `limitWithElipsis`, which truncates
    project titles that are longer than 20 characters. We also appended the open tasks
    count to the tag title. For the `link` field of the `Tag` instance, we specify
    a URL that will navigate to the project details view. Finally, we used the `TAG_TYPE_PROJECT`
    constant to define the tag `type` field.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用项目ID作为`textTag`实例化一个新的`Tag`对象。对于`title`字段，我们使用了一个辅助函数`limitWithElipsis`，该函数截断超过20个字符的项目标题。我们还把未完成的任务计数追加到标签标题中。对于`Tag`实例的`link`字段，我们指定一个将导航到项目详情视图的URL。最后，我们使用`TAG_TYPE_PROJECT`常量来定义标签的`type`字段。
- en: Creating a tags service
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建标签服务
- en: 'Okay, we''re done with setting up all the supporting structures we need; we
    can now move forward to create a tags service. A tags service will have the following
    responsibilities:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经设置好了所有需要的辅助结构；现在我们可以继续创建标签服务。标签服务将承担以下职责：
- en: '**Generating and caching tags**: We won''t create tags in our system ad hoc
    if we only want to render them. The mechanics of a tags service is more like generated
    cache. Initially, a tags service gathers all the required information to generate
    all the possible tags within the system. It also reacts to changes and updates
    the list of tags if required. With this, we''ll not only save on some processing
    needs, but we''ll also have a readily available list to search for existing tags.
    This will be particularly useful if we like to present the available tags to the
    user so they can choose from them.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成和缓存标签**：如果我们只想渲染标签，我们不会在我们的系统中随意创建标签。标签服务的机制更像是一个生成缓存。最初，标签服务收集生成系统内所有可能标签所需的所有信息。它还会对变化做出反应，并在需要时更新标签列表。这样，我们不仅可以节省一些处理需求，而且我们还将有一个现成的列表来搜索现有标签。如果我们想向用户展示可用的标签以便他们从中选择，这将特别有用。'
- en: '**Rendering tags**: A tags service is also responsible for turning tags into
    HTML. It uses the `title` and `link` fields of the `Tag` instances to generate
    their HTML representation.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染标签**：标签服务还负责将标签转换为HTML。它使用`Tag`实例的`title`和`link`字段来生成它们的HTML表示。'
- en: '**Parsing text content**: The parsing functionality of the tags service is
    responsible for finding text representations of tags within a string. It then
    uses the rendering function to render these tags into HTML.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解析文本内容**：标签服务的解析功能负责在字符串中找到标签的文本表示。然后它使用渲染函数将这些标签渲染成HTML。'
- en: Let's create a module for our tags service in a new file under `tags/tags-service.js`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`tags/tags-service.js`下的新文件中为我们的标签服务创建一个模块。
- en: First, we need to create two utility functions that will help us process tags
    and strings containing the textual representations of tags.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建两个实用函数，这些函数将帮助我们处理标签以及包含标签文本表示的字符串。
- en: 'The `replaceAll` function is a simple substitute for a missing JavaScript function
    to replace multiple text occurrences within a string without using regular expressions:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`replaceAll`函数是一个简单的替代方案，用于在没有使用正则表达式的情况下替换字符串中的多个文本出现：'
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `findTags` function will extract any possible tag from a text string. It
    does this by applying a regular expression that will find matches for tags in
    the format discussed at the beginning of the topic. This format assumes that our
    tags always start with a hash symbol, followed by any word character or dash symbols.
    This function returns a list of all the possible text tags:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`findTags` 函数将从文本字符串中提取任何可能的标签。它是通过应用一个正则表达式来完成的，该正则表达式将找到与话题开头讨论的格式匹配的标签。这个格式假设我们的标签总是以一个井号符号开始，后面跟着任何单词字符或破折号符号。这个函数返回所有可能的文本标签列表：'
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For our tags service, we will now define a new class that will be annotated
    with `@Injectable` so we can use it as a provider in our components:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的标签服务，我们现在将定义一个新的类，该类将使用 `@Injectable` 进行注解，这样我们就可以将其用作组件中的提供者：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s look at the constructor of our `TagsService` class:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的 `TagsService` 类的构造函数：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In order to generate and cache project tags, we obviously need `ProjectService`,
    which provides us with a list of all the projects. Instead of grabbing the list
    data from `ProjectService` once, we're observing the list for changes. This brings
    us the advantage that we'll not only get the initial list of projects, but we'll
    also be made aware of any changes made in the project list.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成和缓存项目标签，我们显然需要 `ProjectService`，它为我们提供所有项目的列表。我们不是一次性从 `ProjectService`
    中获取列表数据，而是在观察列表的变化。这带来了优势，我们不仅会得到初始的项目列表，还会意识到项目列表中的任何更改。
- en: 'We subscribed to `ProjectService` using the `change` field. This exposes `ReplaySubject`,
    which emits the project list. After storing the current project list as a member
    field, we need to call the `initializeTags` method:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `change` 字段订阅了 `ProjectService`。这暴露了 `ReplaySubject`，它发出项目列表。在将当前项目列表存储为成员字段后，我们需要调用
    `initializeTags` 方法：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we only support project tags currently, the only thing we need to consider
    while generating tags is the projects we have stored in our service. We can simply
    map the project list we have stored in the `projects` member field using our `generateTag`
    function. The `Array.prototype.map` function will return a new array that is already
    a list of generated tasks for the projects.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们目前只支持项目标签，因此在生成标签时，我们唯一需要考虑的是我们存储在服务中的项目。我们可以简单地使用我们的 `generateTag` 函数将存储在
    `projects` 成员字段中的项目列表进行映射。`Array.prototype.map` 函数将返回一个新的数组，该数组已经是为项目生成的任务列表。
- en: Rendering tags
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签渲染
- en: Okay, we now have a service that uses a reactive approach to generate tags from
    the available projects. This is already addressing the first concern of our service.
    Let's look at its other responsibilities, which are parsing text content for tags
    and rendering HTML.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在有一个使用反应式方法从可用项目中生成标签的服务。这已经解决了我们服务的第一个问题。让我们看看它的其他职责，即解析文本内容以查找标签和渲染
    HTML。
- en: Rendering tags is not a big deal since we have already abstracted the data model
    of tags in a clean way. We need to write a method for rendering tags that will
    act as a pass-through function if the argument is not a valid `Tag` instance.
    This way, we can pass unrecognized text representations of tags as strings, and
    it will just return us the string.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经以一种干净的方式抽象了标签的数据模型，标签渲染并不是什么大问题。我们需要编写一个方法来渲染标签，如果参数不是一个有效的 `Tag` 实例，它将作为一个透传函数。这样，我们可以将未识别的标签文本表示作为字符串传递，它将只返回字符串。
- en: 'Since tags have URLs that point to a location, we''re going to use anchor HTML
    elements to represent our tags. These elements also have classes that will help
    us style tags differently than regular content. Let''s create another method within
    the tags service that can be used to render tag objects into HTML:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于标签有指向位置的 URL，我们将使用锚点 HTML 元素来表示我们的标签。这些元素也有类，可以帮助我们以不同于常规内容的方式对标签进行样式化。让我们在标签服务中创建另一个方法，该方法可以用来将标签对象渲染成
    HTML：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following method can be used to find a tag by its textual representation.
    This function will try to find the tag within our generated cache, and if unsuccessful,
    will return the `textTag` argument. This is also a pass-through mechanism that
    simplifies the handling when we parse a whole piece of text for tags:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法可以用来通过其文本表示形式查找标签。这个函数将尝试在我们的生成缓存中找到标签，如果失败，将返回 `textTag` 参数。这也是一种透传机制，它简化了当我们解析整个文本以查找标签时的处理：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Last but not least, let''s implement the main method of the service. The parse
    function scans the whole text for tags and replaces them with their HTML representation:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，让我们实现服务的主方法。`parse` 函数会扫描整个文本以查找标签，并将它们替换为它们的 HTML 表示形式：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First, we need to use the `findTags` utility function; this will return a list
    of all the text tags that it would find in the string content passed to the `parse`
    function. Using this text tag list, we can then iterate through the list and successively
    replace all the text tags in the content with the generated HTML using the `renderTag`
    method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用`findTags`实用函数；这将返回一个列表，其中包含它会在传递给`parse`函数的字符串内容中找到的所有文本标签。使用这个文本标签列表，我们可以然后遍历列表，并使用`renderTag`方法连续替换内容中的所有文本标签，以生成相应的HTML。
- en: Integrating the task service
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成任务服务
- en: All the concerns of our task service have now been taken care of, and it is
    already storing tags for the available projects. We can now go ahead and integrate
    our service into the application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务服务的所有问题现在都已得到解决，并且它已经为可用的项目存储了标签。我们现在可以继续将我们的服务集成到应用程序中。
- en: Since our tags service turns text with simple hash tags into HTML with links,
    a pipe would be a perfect helper to integrate the functionality within our components.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的标签服务将文本中的简单哈希标签转换为带有链接的HTML，因此管道将是一个完美的助手，以在我们的组件中集成该功能。
- en: 'Let''s create a `tags.js` file in our `pipes` folder and create a new pipe
    class, namely, `Tags`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`pipes`文件夹中创建一个`tags.js`文件，并创建一个新的管道类，即`Tags`：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have already created a few pipes so far. However, this pipe is a bit different
    in that it isn't a pure pipe. Pipes are considered pure if their transform function
    always returns the same output for a given input. This implies that the transform
    function should not be dependent on any other external source that can influence
    the outcome of the transform, and the only dependencies are the input values.
    This is not true for our `Tags` pipe though. It depends on `TagsService` to transform
    the input, and new tags can be stored in the tags service at any time. Successive
    transformations can successfully render tags that were not existent just a moment
    ago.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一些管道。然而，这个管道有点不同，因为它不是一个纯管道。如果管道的转换函数总是为给定的输入返回相同的输出，则认为管道是纯的。这意味着转换函数不应依赖于任何其他可能影响转换结果的外部来源，唯一的依赖是输入值。然而，我们的`Tags`管道并非如此。它依赖于`TagsService`来转换输入，并且可以在任何时间将新标签存储在标签服务中。连续的转换可以成功渲染刚刚不存在的标签。
- en: By telling Angular that our pipe is not pure, we can disable the optimization
    it performs on pure pipes. This also means that Angular will need to revalidate
    the output of the pipe on every change detection. This can lead to performance
    issues; therefore, the pure flag should be used with caution.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过告诉Angular我们的管道不是纯的，我们可以禁用它在纯管道上执行的优化。这也意味着Angular需要在每次变更检测时重新验证管道的输出。这可能会导致性能问题；因此，应谨慎使用纯标志。
- en: All right, as far as rendering tags is concerned, we are all set. Let's integrate
    our tags functionality into our `Editor` component so we can make use of them
    within the commenting system.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，就渲染标签而言，我们已经准备好了。让我们将我们的标签功能集成到`Editor`组件中，这样我们就可以在评论系统中使用它们。
- en: 'Let''s start by editing the `Editor` module located under `ui/editor/editor.js`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编辑位于`ui/editor/editor.js`下的`Editor`模块开始：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, we imported the `TagsPipe` class and referenced it to the `pipes` configuration
    of the `@Component` annotation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入了`TagsPipe`类，并将其引用到`@Component`注解的`pipes`配置中。
- en: We've also added a new input to the `enableTags` component, which will allow
    us to control whether we should handle tags within the content of the editor or
    ignore them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还向`enableTags`组件添加了一个新的输入，这将允许我们控制是否应该处理编辑器内容中的标签或忽略它们。
- en: 'That''s it, as far as changes to the component file is concerned. Let''s apply
    some changes to the template of the component by editing the `ui/editor/editor.html`
    file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 就组件文件的变化而言，到此为止。让我们通过编辑`ui/editor/editor.html`文件来对组件的模板应用一些更改：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The only change we've made in the template is where we display the editor content.
    We've used two template elements by employing the `NgIf` asterisk template syntax.
    The latter one, if tags are disabled, renders the content as before. If tags are
    enabled, we'll be using a property binding to the `innerHTML` property of our
    editor's output HTML element. This allows us to render the HTML content. In the
    binding, we've used our `Tags` pipe that will parse the content for tags using
    `TagService`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模板中做的唯一改变是显示编辑器内容的位置。我们通过使用`NgIf`星号模板语法使用了两个模板元素。后者，如果标签被禁用，将渲染之前的内容。如果标签被启用，我们将使用属性绑定到编辑器输出HTML元素的`innerHTML`属性。这允许我们渲染HTML内容。在绑定中，我们使用了我们的`Tags`管道，该管道将使用`TagService`解析内容以查找标签。
- en: Completion of the tags service
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签服务的完成
- en: Let's digress for a moment at this point. We've already created a tagging system,
    and we just integrated it into our `Editor` component by using the `Tags` pipe.
    If a user writes project tags in any comment now, they will be rendered by `TagsService`.
    This is fantastic! Users can now establish cross-links to other projects within
    comments, which will be automatically rendered as links showing the project title
    and open tasks. All a user needs to do is add the text representations of project
    tags to a comment. In the default data set of the book, this could be the `#project-1`
    string.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，让我们暂时偏离一下。我们已经创建了一个标签系统，并且我们刚刚通过使用`Tags`管道将其集成到我们的`Editor`组件中。如果用户现在在任意评论中编写项目标签，它们将通过`TagsService`进行渲染。这太棒了！用户现在可以在评论中建立与其他项目的交叉链接，这些链接将自动渲染为显示项目标题和开放任务的链接。用户需要做的只是将项目标签的文本表示添加到评论中。在书籍的默认数据集中，这可能是`#project-1`字符串。
- en: 'The following two images show you an example of the commenting system. The
    first image is an example of an editor in edit mode, under the commenting system,
    where a text tag is entered:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两张图片展示了评论系统的示例。第一张图片是编辑模式下编辑器的示例，在评论系统中输入了一个文本标签：
- en: '![Completion of the tags service](img/image00329.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![标签服务完成](img/image00329.jpeg)'
- en: An example where a text tag is entered
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文本标签的示例
- en: 'The second image is an example of a rendered tag enabled in the commenting
    system through our editor integration:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 第二张图片是评论系统中通过我们的编辑器集成启用的渲染标签的示例：
- en: '![Completion of the tags service](img/image00330.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![标签服务完成](img/image00330.jpeg)'
- en: An example of rendered tag through editor integration
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编辑器集成渲染的标签示例
- en: 'We''re not done yet when it comes to entering tags. We cannot expect our users
    to know all the available tags within the system and then enter them manually
    within comments. Let''s look at how we can improve this in the next section:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在标签输入方面，我们还没有完成。我们不能期望我们的用户知道系统中的所有可用标签，然后在评论中手动输入它们。让我们看看在下一节中我们如何改进这一点：
- en: 'In this section, we looked at the following concepts:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了以下概念：
- en: We built a tags service that generates, caches, and renders tags.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们构建了一个生成、缓存和渲染标签的标签服务。
- en: We built a stateful pipe using the `pure` flag.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`pure`标志构建了一个有状态的管道。
- en: We used the `[innerHTML]` property binding to render HTML content into an element.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用了`[innerHTML]`属性绑定将HTML内容渲染到元素中。
- en: Supporting tag input
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持标签输入
- en: Here, we're going to build a component and its supporting structures to make
    the process of entering tags a smooth experience for our users. So far, they can
    write project tags, but it requires them to know the project IDs, which makes
    our tag management quite useless. What we'd like to do is provide the user with
    some choices when they are about to write a tag. Ideally, we show them the available
    tags, as soon as they start writing a tag by typing the hash (*#*) symbol.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将构建一个组件及其支持结构，以便为用户提供一个顺畅的标签输入体验。到目前为止，他们可以编写项目标签，但需要他们知道项目ID，这使得我们的标签管理变得毫无用处。我们希望做的是，当用户准备编写标签时，为他们提供一些选择。理想情况下，当他们开始通过输入哈希符号（*#*）编写标签时，我们立即显示可用的标签。
- en: 'What sounds simple in the first place is actually quite a tricky thing to implement.
    Our tag input needs to deal with the following challenges:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 起初听起来很简单的事情实际上实现起来相当棘手。我们的标签输入需要处理以下挑战：
- en: Handling input events to monitor tag creation. Somehow, we need to know when
    a user starts writing a tag, and we need to know when the typed tag name is updated
    or canceled by using an invalid tag character.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理输入事件以监控标签创建。我们需要知道用户何时开始编写标签，以及当输入的标签名称被无效的标签字符更新或取消时，我们需要知道何时更新。
- en: Calculating the position of the input caret of the user. Yeah, I know this sounds
    pretty simple, but it actually isn't. Calculating the viewport offset position
    of a user's input caret requires the use of the browser's Selection API, which
    is quite low-level and needs some abstraction.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算用户输入光标的位置。是的，我知道这听起来很简单，但实际上并不简单。计算用户输入光标的视口偏移位置需要使用浏览器的Selection API，这是一个相当低级的API，需要一些抽象。
- en: In order to tackle these challenges, we are going to introduce a utility class
    we can delegate the user input to. It will help us figure out the details we're
    interested in and deal with low-level APIs.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这些挑战，我们将引入一个实用类，我们可以将用户输入委托给它。它将帮助我们了解我们感兴趣的细节，并处理低级API。
- en: Creating a tag input manager
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建标签输入管理器
- en: 'Create a module in a new file under `tags/tag-input-manager.js`. The first
    bit of code is a function that will help us figure out the position of the user
    input caret when the user starts typing a tag:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tags/tag-input-manager.js`的新文件中创建一个模块。代码的第一部分是一个函数，它将帮助我们确定当用户开始输入标签时用户输入光标的位置：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let's not go into too much detail here. What this code basically does is that
    it tries to find the bounding box `DOMRect` object, which describes the `top`,
    `right`, `bottom`, and `left` offsets of the caret position relative to the viewport.
    The problem is that the Selection API does not allow us to get the position of
    the caret directly; it only allows us to get the position of the current selection.
    In case the caret is not placed correctly, we will need to insert a dummy element
    at the location of the caret and return the bounding box `DOMRect` object of the
    dummy element. Of course, we'd need to remove the dummy element again before we
    return the `DOMRect` object.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里就不详细说明了。这段代码的基本功能是尝试找到描述光标位置相对于视口的`top`、`right`、`bottom`和`left`偏移量的`DOMRect`对象。问题是Selection
    API不允许我们直接获取光标的位置；它只允许我们获取当前选择的位置。如果光标放置不正确，我们需要在光标位置插入一个占位元素，并返回占位元素的`DOMRect`对象。当然，在返回`DOMRect`对象之前，我们需要再次移除占位元素。
- en: 'Now let''s create a new class, `TagInputManager`, under `lib/tags/tag-input-manager.js`,
    which will deal with the user input handling for tag creation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`lib/tags/tag-input-manager.js`下创建一个新的类`TagInputManager`，它将处理标签创建的用户输入处理：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the constructor, we need to call an internal `reset` method. This `reset`
    method will reset the two member fields that `TagInputManager` will expose. The
    `position` member will store the position of the latest caret, where the user
    had started writing a tag. The `textTag` member will store the current tag, which
    is recognized by `TagInputManager`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们需要调用一个内部`reset`方法。这个`reset`方法将重置`TagInputManager`将公开的两个成员字段。`position`成员将存储最新光标的位置，即用户开始编写标签的地方。`textTag`成员将存储当前标签，该标签由`TagInputManager`识别：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now let''s create a method to determine if a user is in the progress of entering
    a tag. If the `textTag` member contains a hash symbol at the beginning, we can
    assume that there is a tag entering in progress:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个方法来确定用户是否正在输入标签的过程中。如果`textTag`成员以哈希符号开头，我们可以假设有一个标签正在输入中：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We also need a method that will allow us to update both the current text tag,
    which is entered, as well as the updated caret position:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个方法，允许我们更新当前输入的文本标签以及更新的光标位置：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Within the `onKeyDown` method, we expect to receive delegated `keydown` events.
    We are concerned about the backspace, which should also remove the last character
    of the tag that is currently entered.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onKeyDown`方法中，我们期望接收委托的`keydown`事件。我们关注的是退格键，它应该也会移除当前输入的标签的最后一个字符。
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the `onKeyPress` method, we expect to receive delegated key press events.
    This is where the main logic of this supporting class lies. Here, we handle two
    different cases:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onKeyPress`方法中，我们期望接收委托的按键事件。这是这个辅助类的主要逻辑所在。在这里，我们处理两种不同的情况：
- en: If the pressed key is a hash symbol, we will start over with a new tag.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果按下的键是哈希符号，我们将重新开始一个新的标签。
- en: If the pressed key is not a valid word character or a hash symbol, we will reset
    it to its initial state, which will cancel the tag entry. Otherwise, it'd mean
    that we are dealing with a valid tag character, and we'll add it to the current
    text tag string.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果按下的键不是有效的单词字符或哈希符号，我们将将其重置为其初始状态，这将取消标签输入。否则，这意味着我们正在处理一个有效的标签字符，我们将将其添加到当前文本标签字符串中。
- en: 'The code for this is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是相应的代码：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Okay, so now we have all the support we need to handle tag input. However, we
    still need a way to show the available tags from `TagsService` to the user. For
    this purpose, we'll create a new `TagsSelect` component.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们有了处理标签输入所需的所有支持。然而，我们仍然需要一个方法来向用户显示`TagsService`中的可用标签。为此，我们将创建一个新的`TagsSelect`组件。
- en: Creating a tags select component
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建标签选择组件
- en: 'To support the user in finding the right tag, we''ll provide them with a dropdown
    with the available tags. To do this, we need to use our `TagInputManager` class
    to recognize tags within user input as well as filter the available tags with
    user input. Let''s briefly look at the requirements of this component:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助用户找到正确的标签，我们将提供一个包含可用标签的下拉菜单。为此，我们需要使用我们的`TagInputManager`类来识别用户输入中的标签以及使用用户输入过滤可用标签。让我们简要看看该组件的要求：
- en: Display the available tags gathered from `TagsService` in a tooltip/callout
    box
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工具提示/调用框中显示从`TagsService`收集的可用的标签
- en: It should support a limitation of displayed tags
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该支持显示标签的限制
- en: It should support an input to filter the available tags
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该支持一个输入来过滤可用的标签
- en: The component should accept an input parameter to position the callout box
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件应该接受一个输入参数来定位调用框
- en: It should emit an event once the user clicks on a tag in the listed tags
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户在列表标签中点击标签时，组件应该发出一个事件
- en: The component should hide itself if the filter is invalid or if there are no
    elements matching the filter:![Creating a tags select component](img/image00331.jpeg)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果过滤器无效或没有元素匹配过滤器，组件应该隐藏自己：![创建标签选择组件](img/image00331.jpeg)
- en: Finished tags select component filtered with user input
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成带有用户输入过滤的标签选择组件
- en: 'Let''s start with the component class and see how we fulfill these requirements.
    First, create a new file called `tags-select.js` under `tags/tags-select`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从组件类开始，看看我们如何满足这些要求。首先，在`tags/tags-select`下创建一个名为`tags-select.js`的新文件：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have no specialties to deal with in our `@Component` annotation. Let''s
    start with implementing the innards of our component. First, we''ll define the
    following input in the component:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`@Component`注解中，我们没有特殊之处要处理。让我们从实现组件的内部开始。首先，我们将在组件中定义以下输入：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using the `filter` input, we can pass a filter tag to the `TagsSelect` component.
    This means that we'll use the `filter` input to filter the available tags by `title`
    and `text` tags.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`filter`输入，我们可以将过滤标签传递给`TagsSelect`组件。这意味着我们将使用`filter`输入通过`title`和`text`标签过滤可用的标签。
- en: 'The `limit` input can be set to any number. This input is used to limit the
    number of filtered tags that could be displayed within the component:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`limit`输入可以设置为任何数字。此输入用于限制在组件内显示的过滤标签数量：'
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `position` input should be set to a valid `DOMRect` object that contains
    the top and left properties. They will be used to position our component:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`position`输入应设置为包含`top`和`left`属性的合法`DOMRect`对象。它们将用于定位我们的组件：'
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `tagSelected` output property is used to emit an event once the user has
    clicked on a tag within the list of tags:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`tagSelected`输出属性用于在用户在标签列表中点击标签时发出事件：'
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following accessor property is bound to the host element''s display style
    property. It will control whether the component is displayed or hidden. We only
    display the component if the filter is valid and the filtered tags contain at
    least one tag:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下访问器属性绑定到宿主元素的显示样式属性。它将控制组件是显示还是隐藏。我们仅在过滤器有效且过滤后的标签至少包含一个标签时显示组件：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following two accessor properties use host bindings to set the `top` and
    `left` styles of our host element based on the `position` input of the component:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个访问器属性使用宿主绑定来设置宿主元素的`top`和`left`样式，这些样式基于组件的`position`输入：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s inject `TagsService` into our component so we can access the list of
    available tags:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`TagsService`注入到我们的组件中，这样我们就可以访问可用的标签列表：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We need to use the `OnInit` life cycle hook to set up a subscription to the
    `TagService` change observable. This way, we''ll get access to the initial list
    of tags as well as any changes in the list. After we receive a new list of tags,
    we will need to reapply the filtering:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用`OnInit`生命周期钩子来设置对`TagService`更改观察器的订阅。这样，我们将能够访问初始标签列表以及列表中的任何更改。在收到新的标签列表后，我们需要重新应用过滤：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following is the method that will be called from the template if a tag
    is clicked. We''ll just re-emit that tag using the `tagSelected` output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在点击标签时从模板中调用的方法。我们将仅使用`tagSelected`输出重新发射该标签：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `filterTags` method is responsible for filtering and limiting our tag list
    based on the filter and limit input properties and the available tags from `TagsService`.
    As a result, it will store the filtered and limited list in the `filteredTags`
    member field:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`filterTags`方法负责根据过滤和限制输入属性以及从`TagsService`提供的可用标签来过滤和限制我们的标签列表。因此，它将在`filteredTags`成员字段中存储过滤和限制后的列表：'
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If the input properties filter or limit changes, we will need to reapply our
    filtering method. By implementing the `ngOnChanges` life cycle hook, we can easily
    manage this requirement:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入属性过滤或限制发生变化，我们需要重新应用我们的过滤方法。通过实现`ngOnChanges`生命周期钩子，我们可以轻松地管理这一需求：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we should unsubscribe from the `TagsService` change observable if
    the `TagsSelect` component is destroyed:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果`TagsSelect`组件被销毁，我们应该从`TagsService`的变化可观察对象中取消订阅：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The template for our component is rather simple. Let''s look at the view template
    that is stored under `tags/tags-select/tags-select.html`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件模板相当简单。让我们看看存储在`tags/tags-select/tags-select.html`下的视图模板：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We used the `NgFor` directive to iterate over all the tags within the `filteredTags`
    member. If a tag is clicked, we will need to execute the `onTagClicked` method
    and pass the tag of the current iteration. In the listing, we'll only display
    the tag title that should help the user identify the tag they would like to use.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`NgFor`指令来遍历`filteredTags`成员中的所有标签。如果点击了一个标签，我们需要执行`onTagClicked`方法并传递当前迭代的标签。在列表中，我们只显示有助于用户识别他们想要使用的标签的标签标题：
- en: Now we have built all the pieces that we need to enable smooth tag entering
    for our users. Let's patch our `Editor` component again to include our changes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了我们需要的所有部分，以实现用户平滑地输入标签。让我们再次修补我们的`Editor`组件以包含我们的更改：
- en: Integrating tag input within the editor component
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在编辑器组件中集成标签输入
- en: As the first step, we should amend our `Editor` component to utilize the `TagInputManager`
    class. We need to delegate the user input inside the content-editable element
    to the tag input manager so it can detect any tag entering. Then, we'll use the
    information from `TagInputManager` to control a `TagsSelector` component.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们应该修改我们的`Editor`组件以利用`TagInputManager`类。我们需要将内容可编辑元素内的用户输入委派给标签输入管理器，以便它可以检测任何标签输入。然后，我们将使用`TagInputManager`的信息来控制`TagsSelector`组件：
- en: 'First, let''s look at the required changes to be made inside the `Component`
    class located under `ui/editor/editor.js`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看需要在位于`ui/editor/editor.js`下的`Component`类内部进行的必要更改：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In our `@Component` annotation, we added the `TagsSelect` component to the directives
    property so we could use the component within the template.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`@Component`注解中，我们将`TagsSelect`组件添加到指令属性中，这样我们就可以在模板中使用该组件：
- en: To help us do all the low-level processing for tag entry, we used `TagInputManager`
    and created a new instance of it within the component constructor.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们完成标签输入的所有底层处理，我们使用了`TagInputManager`并在组件构造函数中创建了一个新的实例：
- en: We have now created two methods for handling `keypress` and `keydown` events
    coming from our content-editable element. These methods delegate the events to
    `TagInputManager`, which will handle all of the processing to extract a text tag
    and the position of the caret.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在创建了两个方法来处理来自我们可编辑内容元素的`keypress`和`keydown`事件。这些方法将事件委派给`TagInputManager`，它将处理所有提取文本标签和光标位置的加工：
- en: Finally, we added a method that will be called once a tag is clicked within
    the `TagsSelect` component. Here, we simply replaced the text tag that is currently
    entered with the text representation of the tag that was clicked. This provides
    a naive implementation of some sort of autocomplete. After we added the text representation
    of the clicked tag to the content-editable element, we reset `TagInputManager`
    to clear its state.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了一个方法，当在`TagsSelect`组件中点击标签时将被调用。在这里，我们简单地替换了当前输入的文本标签，用被点击的标签的文本表示形式替换。这提供了一种简单的自动完成实现。在我们将点击的标签的文本表示形式添加到内容可编辑元素后，我们将重置`TagInputManager`以清除其状态：
- en: The only bit left now is to to edit the template of the `Editor` component in
    order to include the `TagsSelect` component.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在唯一剩下的是编辑`Editor`组件的模板，以便包含`TagsSelect`组件：
- en: 'In the `ui/editor/editor.html` file, we need to make the following changes:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ui/editor/editor.html`文件中，我们需要进行以下更改：
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `NgIf` directive helps us avoid the component from being created if tags
    are not enabled within the editor.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgIf`指令帮助我们避免在编辑器中未启用标签时创建组件：'
- en: We set the `filter` and `position` input of the `TagsSelect` component from
    the data we have in our `TagInputManager` instance.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从我们的`TagInputManager`实例中的数据设置了`TagsSelect`组件的`filter`和`position`输入。
- en: On the emitted `tagSelected` event of the `TagsSelect` component, we called
    the `onTagSelected` method on the `Editor` component we created a moment ago.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TagsSelect`组件的`tagSelected`事件中，我们调用了我们刚才创建的`Editor`组件上的`onTagSelected`方法。
- en: That's all we need to do with the template of the `Editor` component.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对`Editor`组件模板需要做的所有事情。
- en: Finishing up our tagging system
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成我们的标签系统
- en: Congratulations! You've now successfully implemented the first of the three
    usability components.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经成功实现了三个可用性组件中的第一个。
- en: With the help of a `TagInputManager` class, we offloaded heavy low-level handling
    of user input and the processing of the user caret position. Then, we created
    a component to display the available tags to the user and provided a way for them
    to select a tag by clicking on it. In our `Editor` component, we used the `TagInputManager`
    class together with the `TagsSelect` component to enable the smooth entering of
    tags while editing comments and other areas where we've enabled tagging.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TagInputManager`类的帮助下，我们将用户输入的低级处理和用户光标位置的处理工作外包出去。然后，我们创建了一个组件来向用户显示可用的标签，并提供了他们通过点击来选择标签的方法。在我们的`Editor`组件中，我们使用了`TagInputManager`类和`TagsSelect`组件，以实现编辑评论和其他我们启用了标签功能的地方的标签的顺畅输入。
- en: 'We''ve covered the following concepts in this section:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们涵盖了以下概念：
- en: We processed complex user input within a designated manager class to offload
    logic from our components.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在指定的管理类中处理了复杂的用户输入，以从我们的组件中卸载逻辑。
- en: We used host bindings to set positional style attributes.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用了宿主绑定来设置位置样式属性。
- en: We implemented fully reactive components that rely on observables and don't
    create side effects during change detection.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现了完全响应式的组件，这些组件依赖于可观察的，并在变化检测期间不创建副作用。
- en: Drag and drop
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拖放
- en: We have learned to use our computer mouse and keyboard with great efficiency.
    Using keyboard shortcuts, different click actions and contextual mouse menus support
    us nicely when performing tasks. However, there is one pattern that has gained
    more attention again in applications lately, given the current mobile and touch
    devices hype. Drag and drop actions are a very intuitive and logical way to express
    actions such as moving or copying items. One task performed on user interfaces
    benefits from drag and drop particularly, which is ordering items within a list.
    If we need to order items via action menus, it gets very confusing. Moving items
    step by step using the up and down buttons works great, but it takes a lot of
    time. If you can drag items around and drop them in a place where you'd like them
    to be reordered, you can sort a list of items extremely fast.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了高效地使用我们的计算机鼠标和键盘。使用快捷键、不同的点击动作和上下文鼠标菜单在执行任务时为我们提供了很好的支持。然而，鉴于当前移动和触摸设备的炒作，最近有一个模式再次引起了更多关注。拖放动作是表达移动或复制项目等动作的一种非常直观和逻辑的方式。在用户界面中执行的一项任务特别受益于拖放，例如在列表中排列项目。如果我们需要通过动作菜单来排列项目，这会变得非常混乱。使用上下按钮逐步移动项目效果很好，但需要花费很多时间。如果您可以将项目拖动到您希望它们重新排列的位置，您就可以非常快速地对项目列表进行排序。
- en: In this topic, we will build the required elements to enable drag and drop selectively.
    We will use the drag and drop feature to enable users to reorder their task lists.
    By developing reusable directives to provide this functionality, we can enable
    the feature at any other spot within our application later on.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们将构建所需的元素以实现选择性的拖放。我们将使用拖放功能来使用户能够重新排列他们的任务列表。通过开发可重用的指令来提供此功能，我们可以在稍后应用程序的任何其他位置启用此功能。
- en: To implement our directives, we will make use of the HTML5 drag and drop API,
    which is supported in all the major browsers at the time of writing this book.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的指令，我们将利用HTML5拖放API，该API在撰写本书时得到了所有主流浏览器的支持。
- en: 'Since we would like to reuse our drag and drop behavior on multiple components,
    we will use directives for the implementation. We are going to create two directives
    in this section:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在多个组件上重用我们的拖放行为，我们将使用指令来实现。在本节中，我们将创建两个指令：
- en: '**Draggable directive**: This directive should be attached to components, which
    should be enabled for dragging'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可拖动指令**：这个指令应该附加到组件上，这些组件应该被启用以进行拖动'
- en: '**Draggable drop zone directive**: This directive should be attached to components
    that will act as a drop target'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可拖动目标区域指令**：这个指令应该附加到将作为目标区域的组件'
- en: We'll also implement a feature where we can be selective about what can be dragged
    where. For this, we will use a type attribute on our draggable directives as well
    an accepted type attribute on our drop zones.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将实现一个功能，允许我们选择哪些元素可以拖动到哪些位置。为此，我们将在我们的可拖动指令中使用类型属性，同时在我们的目标区域中使用接受类型属性。
- en: Implementing the draggable directive
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现可拖动指令
- en: 'The `draggable` directive will be attached to the element that can be dragged
    onto other elements. Let''s get started with creating a new directive class under
    `draggable/draggable.js`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`draggable` 指令将被附加到可以拖动到其他元素上的元素。让我们在 `draggable/draggable.js` 下创建一个新的指令类：'
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Instead of using the `@Component` annotation, we've now used the `@Directive`
    annotation to let Angular know that the following class is a directive class.
    By setting the HTML attribute `draggable` to `true`, we tell the browser that
    we're considering this element a draggable element.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用 `@Directive` 注解而不是 `@Component` 注解，让 Angular 知道以下类是一个指令类。通过将 HTML 属性
    `draggable` 设置为 `true`，我们告诉浏览器我们正在考虑这个元素为可拖动元素。
- en: Tip
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The big difference of using directives in comparison to components is that they
    don't embrace a view but only behavior. Therefore, it's also possible to use many
    directives on the same element, which is not possible with components.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与组件相比，使用指令的一个重大区别是它们不包含视图，只包含行为。因此，也可以在同一个元素上使用多个指令，这是组件所不可能的。
- en: 'Let''s look at the input for our newly created component class:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们新创建的组件类的输入：
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `draggableData` input is used to specify the data that represents the element
    which can be dragged. This data will be serialized to JSON and transferred to
    our drop zones once a drag action is completed.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`draggableData` 输入用于指定表示可拖动元素的的数据。一旦拖动操作完成，这些数据将被序列化为 JSON 并传输到我们的目标区域。'
- en: By specifying a draggable type, we can be more selective when the element is
    dragged over a drop zone. Within the drop zone, we can have a counterpart that
    controls what types are acceptable to be dropped.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定可拖动类型，当元素拖动到目标区域上时，我们可以更加选择性地操作。在目标区域内，我们可以有一个对应的部分来控制哪些类型是被接受的。
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Additionally to our input, we also want to use a host binding to set a special
    class if the element is currently dragged:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们的输入之外，我们还想使用主机绑定来设置一个特殊类，如果元素当前正在被拖动：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This binding will set a `draggable--dragging` class, which will apply some special
    styles that will make it easy to recognize that an element is dragged.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个绑定将设置一个 `draggable--dragging` 类，这将应用一些特殊样式，使得识别出被拖动的元素变得容易。
- en: 'Now we need to handle two events within our directive to implement the behavior
    of a draggable element. The following DOM events are triggered by the drag and
    drop DOM API:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在我们的指令中处理两个事件来实现可拖动元素的行为。以下 DOM 事件由拖放 DOM API 触发：
- en: '`dragstart`: This event is emitted on elements that are grabbed and moved across
    the screen'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dragstart`：这个事件在元素被抓住并在屏幕上移动时发出'
- en: '`dragend`: If the previously initiated dragging of the element is ended, because
    of a successful drop or a release outside of a valid drop target, this DOM event
    will be triggered.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dragend`：如果之前启动的元素拖动因为成功放置或释放到有效的目标区域外而结束，这个 DOM 事件将被触发。'
- en: 'Let''s look at the implementation of `HostListener` for the `dragstart` event:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `dragstart` 事件的 `HostListener` 的实现：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now let''s discuss the different actions we will perform in the implementation
    of our host listener:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来讨论在实现我们的主机监听器时将执行的不同操作：
- en: 'We will need to access the DOM event object in our host listener. If we were
    to create this binding within the template, we would probably need to write something
    similar to this: `(dragstart)="onDragStart($event)"`. Within event bindings, we
    can make use of the synthetic variable `$event`, which is a reference to the event
    that would have triggered the event binding. If we were to create an event binding
    on our host element using the `@HostListener` annotation, we would need to construct
    the parameter list for the binding using the second argument of the decorator.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在我们的宿主监听器中访问DOM事件对象。如果我们要在模板中创建这个绑定，我们可能需要写一些类似这样的代码：`(dragstart)="onDragStart($event)"`。在事件绑定中，我们可以使用合成变量`$event`，它是触发事件绑定的事件的引用。如果我们使用`@HostListener`注解在我们的宿主元素上创建事件绑定，我们需要使用装饰器的第二个参数来构造绑定的参数列表。
- en: The first action in our event listener is to set the desired `effectAllowed`
    property on the `dataTransfer` object. Currently, we only support the `move` effect
    as our main concern is to reorder tasks within the task list using drag and drop.
    The drag and drop API is very system-specific, but usually there are different
    drag effects if a user holds a modifier key (such as *Ctrl* or *Shift*) while
    initiating the dragging. Within our `draggable` directive, we can force the `move`
    effect for all drag actions.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的事件监听器的第一个动作是设置`dataTransfer`对象上的期望`effectAllowed`属性。目前，我们只支持`move`效果，因为我们的主要关注点是使用拖放重新排序任务列表中的任务。拖放API非常特定于系统，但通常，如果用户在开始拖动时按住修饰键（如*Ctrl*或*Shift*），会有不同的拖放效果。在我们的`draggable`指令中，我们可以强制所有拖动动作都使用`move`效果。
- en: In the next code snippet, we will set the data that should be transferred by
    dragging. It's important to understand the core purpose of the drag and drop API.
    It does not only provide a way to implement drag and drop for elements solely
    in your DOM, but it also supports the dragging of files and other objects into
    your browser. Because of this, the API undergoes some constraints, where one of
    them is making it impossible to transfer data other than simple string values.
    In order for us to transfer complex objects, we will serialize the data from the
    `draggableData` input using `JSON.stringify`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个代码片段中，我们将设置通过拖动应该传输的数据。理解拖放API的核心目的是很重要的。它不仅提供了一种在您的DOM中仅对元素实现拖放的方法，而且还支持将文件和其他对象拖放到浏览器中。正因为如此，API经历了一些限制，其中之一是使得除了简单的字符串值之外的数据传输变得不可能。为了使我们能够传输复杂对象，我们将使用`JSON.stringify`序列化`draggableData`输入的数据。
- en: Another limitation caused by some security constraints within the API is that
    data can only be read after a successful drop. This means that we cannot inspect
    the data if the user is just hovering over an element. However, we need to know
    some facts about the data when hovering drop zones. We need to know the type of
    the draggable element when entering a drop zone so we can make the drop zone signal
    if the type is accepted. We're using a small workaround for this issue. The drag
    and drop API hides the data when we drag data over a drop target. However, it
    tells us what type of data it is. Knowing this fact, we can use the `setData`
    function to encode our draggable type. Accessing the data keys only is considered
    secure and therefore can be done in all drop zone events.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于API中的一些安全限制造成的另一个限制是，数据只能在成功放置后读取。这意味着如果用户只是悬停在元素上，我们无法检查数据。然而，当悬停在放置区域时，我们需要了解一些关于数据的事实。当进入放置区域时，我们需要知道可拖动元素的类型，这样我们就可以让放置区域发出是否接受该类型的信号。我们为此问题使用了一个小的解决方案。拖放API在我们将数据拖动到放置目标上时隐藏数据。然而，它告诉我们数据的类型。了解这个事实后，我们可以使用`setData`函数来编码我们的可拖动类型。仅访问数据键被认为是安全的，因此可以在所有放置区域事件中完成。
- en: Finally, we'll set the dragging flag to `true`, which will cause the class binding
    to revalidate and add the `draggable--dragging` class to the element.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将拖动标志设置为`true`，这将导致类绑定重新验证并向元素添加`draggable--dragging`类。
- en: 'After dealing with the `dragstart` event, we only need to handle the `dragend`
    event to complete our `Draggable` directive. The only thing we do within the `onDragEnd`
    method that is bound to the `dragend` event is set the dragging member to false.
    This will cause the `draggable--dragging` class to be removed from the host element:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完`dragstart`事件后，我们只需要处理`dragend`事件来完成我们的`Draggable`指令。在绑定到`dragend`事件的`onDragEnd`方法中，我们唯一做的事情是将拖动成员设置为`false`。这将导致从宿主元素中移除`draggable--dragging`类：
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: That's it for the behavior of our `Draggable` directive. Now we need to create
    its counterpart directive to provide the behavior of a drop zone.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的`Draggable`指令的行为。现在我们需要创建它的对应指令来提供拖放区域的行为。
- en: Implementing a drop target directive
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现拖放目标指令
- en: 'Drop zones will act as containers where draggable elements can be dropped.
    For this, we''ll create a new directive called `DraggableDropZone` under `draggable/draggable-drop-zone.js`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 拖放区域将作为容器，其中可拖动元素可以被放置。为此，我们将在`draggable/draggable-drop-zone.js`下创建一个新的指令，称为`DraggableDropZone`：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'There''s nothing special about this `@Directive` annotation. We used an attribute
    selector so it can be attached using a `draggableDropZone` attribute on any HTML
    element. Using the following input, we can specify what types of draggable elements
    we accept in this drop zone. This will help the user identify whether they are
    able to drop off the draggable elements when approaching the drop zone:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`@Directive`注解没有什么特别之处。我们使用了一个属性选择器，因此它可以通过在HTML元素上使用`draggableDropZone`属性来附加。使用以下输入，我们可以指定在这个拖放区域中接受哪些类型的可拖动元素。这将帮助用户确定他们是否能够在接近拖放区域时放下可拖动元素：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Upon successful drops into the drop zone, we will need to emit an event so
    that the components using our drag and drop functionality can react accordingly.
    For this purpose, let''s create a `dropDraggable` output property:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功将元素拖放到拖放区域后，我们需要发出一个事件，以便使用我们拖放功能的组件能够相应地做出反应。为此，让我们创建一个名为`dropDraggable`的输出属性：
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `over` member field will store the state if an accepted element is in the
    process of being dragged over the drop zone:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`over`成员字段将存储一个已接受元素正在拖动过拖放区域的状态：'
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following method will be used to check whether our drop zone should accept
    any given drag and drop event by checking against our `dropAcceptType` member.
    If you remember the security problems we needed to work around with when creating
    the `Draggable` directive, you will understand why this determination is rather
    simple:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法将用于检查我们的拖放区域是否应该接受任何给定的拖放事件，通过检查我们的`dropAcceptType`成员。如果您还记得我们在创建`Draggable`指令时需要解决的安全问题，您将理解为什么这个判断相当简单：
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We can only read the types of the data within `dataTransfer` objects for certain
    events, where the data itself is hidden until a successful `drop` event is occurred.
    To bypass this security limitation, we've encoded the draggable type information
    into a data key itself. Since we can list all the data types safely, it's not
    too hard to extract the encoded draggable type information. We will search for
    a data type key that starts with `"draggable-type"` and then split it by the column
    character. The value after the column character is our type information, which
    we will then compare against the `dropAcceptType` directive input property.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能读取某些事件中`dataTransfer`对象的数据类型，而数据本身在成功发生`drop`事件之前是隐藏的。为了绕过这个安全限制，我们将可拖动类型信息编码到数据键本身中。由于我们可以安全地列出所有数据类型，因此提取编码的可拖动类型信息并不太难。我们将搜索一个以`"draggable-type"`开头的数据类型键，然后通过列字符进行分割。列字符之后的值就是我们的类型信息，然后我们将它与`dropAcceptType`指令输入属性进行比较。
- en: 'We will use two events to determine whether a draggable element is moved to
    our drop zone:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个事件来确定一个可拖动元素是否被移动到我们的拖放区域：
- en: '`dragenter`: This is fired by an element if another element is dragged over
    it'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dragenter`：如果另一个元素被拖动到它上面，则由元素触发'
- en: '`dragleave`: This is fired by an element if the previously entered element
    has left again'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dragleave`：如果之前进入的元素再次离开，则由元素触发'
- en: 'There''s one problem with the preceding events, which is that they actually
    bubble, and we will receive a `dragleave` event if the dragged element is moved
    to a child element within our drop zone. Because of the bubbling, we then also
    receive `dragenter` and `dragleave` events from the child elements. This is not
    desired in our case, and we need to build some functionality to improve this behavior.
    We will make use of a counter member field `dragEnterCount`, which will count
    up to all the `dragenter` events and count down to `dragleave` events. This way,
    we can now say that only on `dragleave` events, where the counter becomes zero,
    we will actually leave the inside of our drop zone. Let''s look at the following
    diagram that illustrates the problem:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的事件有一个问题，就是它们实际上会冒泡，如果拖动的元素被移动到我们的拖放区域内的子元素中，我们将会收到一个`dragleave`事件。由于冒泡，我们还会从子元素那里收到`dragenter`和`dragleave`事件。在我们的情况下，这并不是我们想要的，我们需要构建一些功能来改进这种行为。我们将利用一个计数成员字段`dragEnterCount`，它将计数到所有的`dragenter`事件，并递减到`dragleave`事件。这样，我们现在可以说，只有在`dragleave`事件中，当计数器变为零时，我们实际上才会离开我们的拖放区域。让我们看看以下说明问题的图示：
- en: '![Implementing a drop target directive](img/image00332.jpeg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![实现拖放目标指令](img/image00332.jpeg)'
- en: Visualization of important variables and functions for our calculations
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化我们计算中重要的变量和函数
- en: 'Let''s implement this logic to build a proper enter and leave behavior of our
    drop zone within the `draggable/draggable-drop-zone.js` file:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`draggable/draggable-drop-zone.js`文件中实现这个逻辑，以构建我们拖放区域的适当进入和离开行为：
- en: '[PRE47]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Within both the events, we first check whether the event is carrying a `dataTransfer`
    object of which we accept the type. After validating the type using our `typeIsAccepter`
    method, we deal with the counter and set the `over` member field if required.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个事件中，我们首先检查事件是否携带一个我们接受的`dataTransfer`对象。在用我们的`typeIsAccepter`方法验证类型之后，我们处理计数器，并在必要时设置`over`成员字段。
- en: 'We need to handle another event that is important for drag and drop functionality,
    which is the `dragover` event. Within the `dragover` event, we can set the accepted
    `dropEffect` of the current dragging action. This will tell our browser that the
    initiated dragging action from our draggable is suitable for this drop zone. It''s
    also important that we prevent the default browser behavior so there''s nothing
    in the way of our custom drag and drop behavior. Let''s add an other function
    to cover those concerns:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要处理另一个对拖放功能很重要的事件，即`dragover`事件。在`dragover`事件中，我们可以设置当前拖动操作的接受`dropEffect`。这将告诉我们的浏览器，从我们的可拖动元素发起的拖动操作适合这个拖放区域。同样重要的是，我们需要防止默认的浏览器行为，以便我们的自定义拖放行为不受干扰。让我们添加另一个函数来处理这些关注点：
- en: '[PRE48]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, we need to handle the most important event in the drop zone, which
    is the `drop` event that is triggered if a user drops a draggable into our drop
    zone:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要处理拖放区域中最重要的事件，即当用户将可拖动元素拖放到我们的拖放区域时触发的`drop`事件：
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: After checking whether the dropped element is of an accepted type, we can now
    go ahead and read the `dataTransfer` object data from the event. This data was
    previously set by the `Draggable` directive and needs to be deserialized using
    `JSON.parse`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查掉落元素是否为接受的类型之后，我们现在可以继续从事件中读取`dataTransfer`对象数据。这些数据之前由`Draggable`指令设置，需要使用`JSON.parse`进行反序列化。
- en: Since the drop was successful, we can reset our `dragEnterCount` member and
    set the `over` flag to `false`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于拖放成功，我们可以重置我们的`dragEnterCount`成员，并将`over`标志设置为`false`。
- en: Finally, we will emit the deserialized data from the draggable element using
    our `dropDraggable` output property.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用我们的`dropDraggable`输出属性发出可拖动元素的反序列化数据。
- en: That's all we need to have a highly reusable drag and drop behavior that we
    can now attach to any components within our application where we feel the need.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的所有内容，以拥有一个高度可重用的拖放行为，我们现在可以将其附加到我们应用程序中任何需要的地方。
- en: Integrating drag and drop in task list component
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在任务列表组件中集成拖放
- en: We can now use the `Draggable` and `DraggableDropZone` directives in our `TaskList`
    component so we can enable the reordering of tasks using drag and drop.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在我们的`TaskList`组件中使用`Draggable`和`DraggableDropZone`指令，这样我们就可以通过拖放来启用任务的重新排序。
- en: The way we're going to do this is by attaching both the directives to the task
    elements within the `TaskList` component template, where we'll render them. Yeah,
    that's right! We want to make our `Task` component a draggable but also a drop
    zone at the same time. This way, we can drop tasks into other tasks, and this
    gives us the foundation for reordering. What we will do is reorder the list in
    a drop so that the dropped task will be squeezed into the position right before
    the task where it was dropped.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这样做是通过将指令附加到`TaskList`组件模板中的任务元素上，我们将在这里渲染它们。是的，没错！我们希望使我们的`Task`组件既可以拖动也可以作为拖放区。这样，我们就可以将任务拖放到其他任务中，这为我们提供了重新排序的基础。我们将执行的操作是在拖放中重新排序列表，以便被拖放的任务将被挤压到它被放置的任务的正前方位置。
- en: 'First, let''s apply the directives to the `<ngc-task>` element in the `TaskList`
    component template, namely `task-list/task-list.html`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将指令应用到`TaskList`组件模板中的`<ngc-task>`元素上，即`task-list/task-list.html`：
- en: '[PRE50]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Alright, using the preceding attributes, we have made our tasks not only a draggable,
    but also a drop zone. By specifying both `draggableType` and `dropAcceptType`
    to the `"task"` string, we are telling our drag and drop behavior that these task
    elements can be dropped into other task elements. Our `DraggableDropZone` directive
    is set to emit a `dropDraggable` event whenever a valid draggable is dropped off.
    To handle dropped tasks, we can simply use this event and create a binding to
    a method in our `TaskList` component.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，使用前面的属性，我们已经使我们的任务不仅可拖动，还可以作为拖放区。通过将`draggableType`和`dropAcceptType`指定为字符串`"task"`，我们告诉我们的拖放行为这些任务元素可以被拖放到其他任务元素中。我们的`DraggableDropZone`指令被设置为在有效可拖动元素被放下时发出`dropDraggable`事件。为了处理被放置的任务，我们可以简单地使用此事件并在我们的`TaskList`组件中创建一个绑定到方法的事件。
- en: 'Let''s see what we need to change within our `Component` class, located under
    `task-list/task-list.js`, to make this work:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在`Component`类中，位于`task-list/task-list.js`下的哪些内容需要更改，以便使这个功能正常工作：
- en: '[PRE51]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s elaborate on the behavior we''ll see within the `onTaskDrop` method
    that is bound to the `DropZone`''s `dropDraggable` event in our template:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细说明在模板中绑定到`DropZone`的`dropDraggable`事件上的`onTaskDrop`方法中的行为：
- en: 'If you check the template again, you would see that we bound to the `onTaskDrop`
    method with the following expression: `(dropDraggable)="onTaskDrop($event, task)"`.
    Since the drop zone emitted an event with de-serialized data that was bound using
    the draggable input property `draggableData`, we can safely assume that we will
    receive a copy of the task that was dropped into the drop zone. As a second parameter
    to our binding, we added the local view variable `task`, which is actually the
    task that acts as the drop zone. Therefore, we can say that the first parameter
    of our `onTaskDrop` method represents the source, while the second represents
    the target task.'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你再次检查模板，你会看到我们使用以下表达式绑定到`onTaskDrop`方法：`(dropDraggable)="onTaskDrop($event,
    task)"`。由于拖放区发出的事件包含使用可拖动输入属性`draggableData`绑定的反序列化数据，我们可以安全地假设我们将收到一个被拖放到拖放区的任务的副本。作为绑定的第二个参数，我们添加了本地视图变量`task`，它实际上是作为拖放区的任务。因此，我们可以这样说，我们的`onTaskDrop`方法的第一参数代表源，而第二个参数代表目标任务。
- en: As a first check in our method, we compare the source position with the target
    position, and if they match, we can assume that the task was dropped by itself
    and we don't need to perform any further actions.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的方法中的第一次检查，我们比较源位置和目标位置，如果它们匹配，我们可以假设任务是自己被放置的，我们不需要执行任何进一步的操作。
- en: Now we can get the source and target task indices within our tasks array and
    execute a nested splice so that we can remove the source from its old position
    within the array and add it right before the position of the target.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在任务数组中获取源任务和目标任务的索引，并执行嵌套的`splice`操作，以便我们可以从数组中的旧位置移除源任务，并将其添加到目标位置的正前方。
- en: All that's left to do now is recalculate the position fields of the tasks so
    that they reflect the reordered array. We can do this easily by using `Array.prototype.map`.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在剩下的工作就是重新计算任务的坐标字段，以便它们反映重新排序的数组。我们可以通过使用`Array.prototype.map`轻松完成此操作。
- en: As the last step, we need to notify our parent component that we've updated
    the task list. We can simply use the `taskUpdated` event to do so. We have used
    that same event when tasks were added or removed.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，我们需要通知我们的父组件我们已经更新了任务列表。我们可以简单地使用`taskUpdated`事件来完成此操作。我们在添加或删除任务时使用了相同的事件。
- en: How great is that? We have successfully implemented drag and drop on our task
    list to provide a very usable feature to reorder tasks.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这有多棒？我们已经成功地在任务列表上实现了拖放，提供了一个非常实用的功能来重新排列任务。
- en: Recapitulate on drag and drop
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拖放回顾
- en: With the use of the low-level drag and drop API, using events and `dataTransfer`
    objects, we have implemented two directives that can now be used to execute smooth
    drag and drop functionality within our application wherever we desire.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用低级拖放API，使用事件和`dataTransfer`对象，我们已经实现了两个指令，现在可以在我们需要的任何地方执行平滑的拖放功能。
- en: With almost no effort, we have implemented our drag and drop behavior on the
    task list to provide a nice feature to reorder the tasks within the list. The
    only thing we needed to do, besides hooking up the directives, was to implement
    a method where we could reorder the tasks based on the information from the `DraggableDropZone`
    event.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎不需要任何努力，我们就已经在任务列表上实现了拖放行为，为用户提供了一个重新排列列表中任务的不错功能。我们除了连接指令外，还需要实现一个方法，根据`DraggableDropZone`事件的信息来重新排列任务。
- en: 'We have worked with the following concepts in this section:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们处理了以下概念：
- en: We learned the basics of HTML5 drag and drop API.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们学习了HTML5拖放API的基础知识。
- en: We used the `dataTransfer` object to securely transfer data within drag and
    drop events.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`dataTransfer`对象在拖放事件中安全地传输数据。
- en: Built reusable behavior patterns using directives.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用指令构建可重用的行为模式。
- en: Enriched the standard drag and drop API by providing our own custom selection
    mechanisms using a custom data type that encodes draggable-type information.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过提供我们自己的自定义选择机制，使用自定义数据类型来编码可拖动类型信息，丰富了标准的拖放API。
- en: To infinity and beyond!
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无限与更远！
- en: Displaying a simple list with an average size does not come with a lot of challenges.
    As soon as the lists starts to grow, challenges start to appear. We can easily
    overwhelm a user with a very long list. Long lists can also have a performance
    impact on our application, especially when it displays dynamic content.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 显示一个平均大小的简单列表并不具有太多挑战性。一旦列表开始增长，挑战就开始出现。我们很容易用一个非常长的列表让用户感到不知所措。长列表也可能对我们的应用程序产生性能影响，尤其是在显示动态内容时。
- en: One way to address the challenge faced when displaying long lists is to provide
    pagination. However, pages do not always translate very well. While using pagination
    on a desktop device with a mouse seems very intuitive, it becomes cumbersome on
    mobile devices with touch support.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 解决显示长列表时面临的挑战的一种方法是通过提供分页。然而，分页并不总是翻译得很好。虽然在使用鼠标的桌面设备上进行分页看起来非常直观，但在具有触摸支持的移动设备上则变得繁琐。
- en: In this chapter, we'll look at a different approach that can help us mitigate
    the performance implications of long lists while providing a smooth experience
    on mobile devices. We are using a pattern sometimes referred to as infinite scrolling.
    The goal is to display only enough items within the list to fill the screen, and
    load more items on demand if the user scrolls down.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一种不同的方法，可以帮助我们减轻长列表的性能影响，同时在移动设备上提供流畅的体验。我们使用了一种有时被称为无限滚动的模式。目标是只显示足够多的项目以填满屏幕，并在用户向下滚动时按需加载更多项目。
- en: To implement such a behavior, we could write a wrapper component that will provide
    an infinite scroll pane and use content insertion to embrace our list. However,
    we will use a different approach to implement our infinite scroll behavior and
    build a custom template directive such as `NgFor`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种行为，我们可以编写一个包装组件，该组件将提供一个无限滚动面板，并使用内容插入来包含我们的列表。然而，我们将使用不同的方法来实现我们的无限滚动行为，并构建一个自定义模板指令，例如`NgFor`。
- en: The asterisk syntax and templates
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 星号语法和模板
- en: We have used the `NgFor` and `NgIf` directives quite a lot so far using the
    asterisk (`*`) symbol to indicate we're dealing with a directive that creates
    a template. However, we haven't looked at the anatomy of the asterisk template
    syntax. Imagine that it will create some sort of syntactic sugar for our template.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经大量使用了`NgFor`和`NgIf`指令，使用星号（`*`）符号来表示我们正在处理一个创建模板的指令。然而，我们还没有查看星号模板语法的结构。想象一下，它将为我们的模板创建某种语法糖。
- en: 'Check out this example of using the `NgFor` directive with the asterisk template
    syntax:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下使用星号模板语法的`NgFor`指令示例：
- en: '[PRE52]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The template parser of Angular will handle all the attributes that start with
    an asterisk in a special way. The preceding example is an easier and more concise
    writing style of the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的模板解析器将以特殊方式处理以星号开头的所有属性。前面的例子是以下更简单、更简洁的编写风格：
- en: '[PRE53]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Both the preceding examples are absolutely identical. Template directives, such
    as `NgFor` or `NgIf`, make use of HTML template elements, which we've briefly
    discussed in [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Component-Based
    User Interfaces"), *Component-Based User Interfaces*. The reason that the Angular
    common directives `NgFor`, `NgIf`, and `NgSwitch` use HTML template elements is
    actually quite obvious if you think about their nature. All three directives need
    to insert and remove large regions of our DOM dynamically. `NgIf`, for example,
    inserts or removes the element it's attached to, based on a condition. By leveraging
    template elements, this can be supported by the browser's native functionality.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的两个例子绝对相同。模板指令，如 `NgFor` 或 `NgIf`，利用 HTML 模板元素，我们已在 [第 1 章](part0014.xhtml#aid-DB7S1
    "第 1 章。组件化用户界面") 中简要讨论过，*组件化用户界面*。如果你考虑它们的本质，Angular 通用指令 `NgFor`、`NgIf` 和 `NgSwitch`
    使用 HTML 模板元素的原因实际上是非常明显的。所有三个指令都需要动态地插入和删除我们的 DOM 中的大区域。例如，`NgIf` 会根据条件插入或删除它附加到的元素。通过利用模板元素，这可以通过浏览器的原生功能得到支持。
- en: Note
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you compare the examples discussed here, it's obvious that the first writing
    style is much simpler to deal with. Asking you to write a separate template element
    every time you'd want to use `NgFor` or `NgIf` would be quite a pain. This is
    the only reason why the asterisk syntax exists, its raison d'être if you like.
    Instead of writing a template element directly, we can use an asterisk on an attribute
    and Angular will transform the HTML portion into a template element for us.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你比较这里讨论的例子，很明显，第一种编写风格处理起来要简单得多。每次你想使用 `NgFor` 或 `NgIf` 时都要求你编写一个单独的模板元素，那将相当痛苦。这就是存在星号语法的原因，如果你喜欢的话，这就是它的存在理由。我们不需要直接编写模板元素，而可以在属性上使用星号，Angular
    会将 HTML 部分转换为我们所需的模板元素。
- en: The `NgFor` directive uses a `TemplateRef` dependency, which can be injected
    into the constructor of the directive, to instantiate the template or multiple
    instances of it, as desired. The `[ngForOf]` property binding is generated during
    de-sugaring by appending the word `Of` within the `NgFor` expression to the directive
    name, `ngFor`. The binding is created by the `NgFor` directive, which accepts
    an input, `ngForOf`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgFor` 指令使用 `TemplateRef` 依赖项，这可以被注入到指令的构造函数中，以实例化模板或多个实例，根据需要。在去糖化过程中，`[ngForOf]`
    属性绑定是通过在 `NgFor` 表达式中的 `NgFor` 指令名称后添加单词 `Of` 生成的。绑定是由 `NgFor` 指令创建的，它接受一个输入，`ngForOf`。'
- en: 'Consider the following example:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下例子：
- en: '[PRE54]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Angular would de-sugar this into the following code:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 会将此简化为以下代码：
- en: '[PRE55]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: That's just the way Angular de-sugars the asterisk template syntax. It's a shortcut
    to attach directives as well as one input bindings to template elements.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是 Angular 去糖化星号模板语法的做法。这是一个将指令附加到模板元素以及一个输入绑定到模板元素的快捷方式。
- en: 'There''s still one thing that might look confusing, which is the variable attribute
    in the template. Let''s look at another example of using the `NgFor` directive
    by aliasing the exposed local variables of a directive like the current index:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有一件事可能看起来有些令人困惑，那就是模板中的变量属性。让我们通过使用 `NgFor` 指令并别名指令公开的局部变量（如当前索引）来查看另一个例子：
- en: '[PRE56]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This example will be de-sugared to the following template:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将被简化为以下模板：
- en: '[PRE57]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: So we can now tell from de-sugaring that additional aliases or mappings will
    get created as variable mappings in our template element. The index that is exposed
    within the code of the `NgFor` directive class as a local view variable is mapped
    to a local view variable within the instantiated content of the template.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在可以从去糖化中得知，将创建额外的别名或映射作为模板元素中的变量映射。在 `NgFor` 指令类的代码中公开的索引作为局部视图变量映射到模板实例化内容中的局部视图变量。
- en: So what's going on with the local view variable `n` within our instantiated
    templates? Why can we access `n`, when there's just one variable attribute without
    any value that would tell us where it's mapped to?
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在我们的实例化模板中，局部视图变量 `n` 发生了什么？为什么我们能够访问 `n`，当只有一个没有任何值来告诉我们它映射到哪里的变量属性时？
- en: We have learned that when we use hash symbol attributes on regular elements,
    we create a local view reference. We can use this reference as an identifier in
    the view directly, or by querying using `@ViewChild`. However, when the view compiler
    of Angular discovers what looks like a local view reference on a template, the
    behavior is a bit different.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，当我们对常规元素使用哈希符号属性时，我们创建了一个局部视图引用。我们可以直接在视图中使用这个引用作为标识符，或者通过使用 `@ViewChild`
    进行查询。然而，当 Angular 的视图编译器发现模板上看起来像局部视图引用的内容时，其行为略有不同。
- en: What is invisible to us is that Angular actually implies a default value for
    variable attributes on template elements that don't have an attribute value. It
    will create a mapping for a local view variable called `$implicit`. You can think
    of `$implicit` as a default value that can be exposed in directives as local view
    variables and will provide some ease of use when dealing with template elements.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前看不到的是，Angular 实际上为模板元素上的变量属性隐含了一个默认值。它将为名为 `$implicit` 的局部视图变量创建一个映射。你可以将
    `$implicit` 视为一个默认值，可以在指令中作为局部视图变量暴露，并在处理模板元素时提供一些便利。
- en: 'It would also be totally valid to write the preceding example as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，前面的示例也可以写成如下形式：
- en: '[PRE58]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, the `NgFor` directive is exposing a local view variable `$implicit`, which
    is a reference to the current value associated with the instance during the iteration
    over the array it receives within the `ngForOf` input. Using a plain variable
    attribute without a value, Angular will default a mapping to `$implicit`. Because
    we don't want to write this mapping all the time ourselves, we can just specify
    an empty variable attribute and Angular will assume it for us.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`NgFor` 指令正在暴露一个局部视图变量 `$implicit`，它是对在 `ngForOf` 输入中接收到的数组迭代期间与实例关联的当前值的引用。使用不带值的普通变量属性，Angular
    将默认将其映射到 `$implicit`。因为我们不想每次都自己编写这个映射，所以我们可以只指定一个空的变量属性，Angular 会为我们处理。
- en: Creating an infinite scroll directive
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建无限滚动指令
- en: Since we now know a bit more about template elements and how Angular deals with
    the asterisk syntax, we can actually create our own copy of `NgFor`, which is
    additionally dealing with the behavior of infinite scrolling.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在对模板元素和 Angular 如何处理星号语法有了一些了解，我们实际上可以创建自己的 `NgFor` 复制，它还处理无限滚动的行为。
- en: 'Let''s create a new file for our directive under `infinite-scroll/infinite-scroll.js`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `infinite-scroll/infinite-scroll.js` 下为我们的指令创建一个新文件：
- en: '[PRE59]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We start off by declaring a regular directive that is sensitive to the attribute
    selector `ngcInfiniteScroll`. The preceding code excerpt only shows the relevant
    code for the template element handling we discussed in the previous topic. There
    are some code parts that we will cover later on in this topic. You can see that
    we used an input property `ngcInfiniteScrollOf`, which is used to pass in the
    list of times used within the infinite scrolling. For inserted template instances,
    we set the local view variable `$implicit` to the actual item within the list
    we were iterating over.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明一个对属性选择器 `ngcInfiniteScroll` 敏感的常规指令。前面的代码摘录仅显示了我们在前一个主题中讨论的模板元素处理的相关代码。有一些代码部分我们将在本主题的后面部分进行介绍。你可以看到我们使用了一个输入属性
    `ngcInfiniteScrollOf`，它用于传递无限滚动中使用的项目列表。对于插入的模板实例，我们将局部视图变量 `$implicit` 设置为我们正在迭代的列表中的实际项目。
- en: 'We will discuss how we get to all of the surrounding code shortly, but first
    let''s take a look at how we could use this directive within a template:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后讨论如何获取所有相关代码，但首先让我们看看我们如何在模板中使用这个指令：
- en: '[PRE60]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The preceding code, as per the mechanisms described in the previous topic,
    will de-sugar into the following template element:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前一个主题中描述的机制，前面的代码将简化为以下模板元素：
- en: '[PRE61]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: So what we can tell now is that the items array will be placed as a property
    binding onto our template element. The same element also contains the `InfiniteScroll`
    directive.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在可以告诉的是，项目数组将被放置为属性绑定到我们的模板元素上。相同的元素还包含 `InfiniteScroll` 指令。
- en: After discussing how the directive will be used and how we can get the required
    input into the directive, let's look at the implementation details that enable
    the infinite scroll behavior.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了指令的用法以及如何将所需输入传递到指令之后，让我们看看实现无限滚动行为的详细实现。
- en: 'Our directive needs to deal with quite a lot of concerns. Let''s check out
    a high-level requirement list:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的需求列表需要处理很多问题。让我们来看看一个高级需求列表：
- en: It needs to dynamically create new child views based on the template element
    and also remove child views that are no longer required.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要根据模板元素动态创建新的子视图，并删除不再需要的子视图。
- en: It needs to detect changes on the input property `ngcInfiniteScrollOf`, which
    is bound to an array within the template. It's not sufficient to use a simple
    identity check, because we'd like to create a comparison of the previous array
    to the new array and only perform view changes based on the differences. For this
    purpose, we will need to implement the `DoCheck` life cycle callback.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要检测输入属性 `ngcInfiniteScrollOf` 的变化，该属性绑定到模板内的数组。仅使用简单的身份检查是不够的，因为我们希望创建前一个数组与新数组的比较，并且仅基于差异执行视图更改。为此，我们需要实现
    `DoCheck` 生命周期回调。
- en: It needs to store a count of items that should be displayed initially, and by
    detecting scroll events, the displayed item count should increase so more items
    could be made visible. At the same time, scrolling should trigger the change detection
    so that we can create new instances of the template within the view.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要存储应最初显示的项目数，并通过检测滚动事件，显示的项目数应增加，以便更多项目可见。同时，滚动应触发变更检测，以便我们可以在视图中创建模板的新实例。
- en: 'Let''s start with the constructor of our directive:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从指令的构造函数开始：
- en: '[PRE62]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We needed to use quite a lot of injected dependencies in order to perform all
    the operations required to fulfill the outlined requirements of our directive:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行所有满足指令概述要求所需的操作，我们需要使用相当多的注入依赖项：
- en: The `ViewContainerRef` dependency helps us create new embedded views based on
    our template element as well as detach or completely remove existing views.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewContainerRef` 依赖项帮助我们根据模板元素创建新的嵌入式视图，以及分离或完全删除现有视图。'
- en: The `TemplateRef` dependency is a reference to the template element, and we
    can use it in conjunction with the `ViewContainerRef` dependency in order to create
    new instances.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TemplateRef` 依赖项是对模板元素的引用，我们可以将其与 `ViewContainerRef` 依赖项结合使用，以创建新实例。'
- en: The `IterableDiffers` dependency is used to create a diff of our input property,
    which is the array of items we're concerned about in our infinite scroll repeater.
    It supports us in finding the created, removed, and deleted items.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IterableDiffers` 依赖项用于创建我们输入属性的差异，这是我们无限滚动重复器中关心的项目数组。它支持我们找到创建、删除和删除的项目。'
- en: The `ChangeDetectorRef` dependency is used to trigger change detection manually
    when we actually need it.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChangeDetectorRef` 依赖项用于在我们实际需要时手动触发变更检测。'
- en: As the first step, we used `Object.assign` to store all our function parameters
    in the instance of the directive. Then, we set two-member variables that will
    store information related to the number of items that should be displayed and
    also the number of displayed items we should increase upon scrolling.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们使用 `Object.assign` 将所有函数参数存储在指令的实例中。然后，我们设置两个成员变量，将存储与应显示的项目数量以及滚动时应增加的显示项目数量相关的信息。
- en: 'That''s it for the constructor. We also need to perform some actions after
    the view within our directive has been initialized. We''ll use the `ngOnInit`
    life cycle hook for this purpose:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的内容到此为止。我们还需要在指令中的视图初始化后执行一些操作。我们将使用 `ngOnInit` 生命周期钩子来完成此目的：
- en: '[PRE63]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s look at these two lines of code in more detail:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这两行代码：
- en: The way our infinite scrolling works is that it detects whether the scrollable
    parent element has already scrolled to the bottom. If that's the case, we'd need
    to render more items from the list. In order to check whether our parent element
    has already scrolled to the bottom, we will need a reference to it. As scroll
    events don't bubble, we need to be very precise where to monitor them. That's
    the reason why we use a utility function to scan the DOM tree to find the next
    scrollable parent element. The `findScrollableParent` function looks for the first
    parent element that has scrollbars or the window object. You can check the source
    code of this chapter if you'd like to see the internals of the function.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的无限滚动工作方式是检测可滚动父元素是否已经滚动到底部。如果是这种情况，我们需要从列表中渲染更多项目。为了检查我们的父元素是否已经滚动到底部，我们需要对其有一个引用。由于滚动事件不会冒泡，我们需要非常精确地监控它们的位置。这就是为什么我们使用一个实用函数来扫描DOM树以找到下一个可滚动的父元素。`findScrollableParent`
    函数寻找第一个具有滚动条或窗口对象的父元素。如果您想查看该函数的内部结构，可以检查本章的源代码。
- en: Now we've added an event handler to the found scrollable parent element and
    registered our internal `onScroll` method as a callback.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们已经为找到的可滚动父元素添加了一个事件处理器，并将我们的内部`onScroll`方法注册为回调。
- en: Detecting change within our template directive
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的模板指令中检测变更
- en: 'Now let''s look at the complete code of the `ngcInfiniteScrollOf` property
    setter, which we have briefly looked at already:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下`ngcInfiniteScrollOf`属性设置器的完整代码，我们之前已经简要地看过：
- en: '[PRE64]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Our property setter will be called by Angular every time the `ngcInfiniteScrollOf`
    input property changes. Since this property is bound by the de-sugaring of the
    asterisk template syntax to the list we refer to within our template, we can assume
    that the value will always be an array or a similar iterable structure.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当Angular每次`ngcInfiniteScrollOf`输入属性变化时，我们的属性设置器将被调用。由于这个属性通过模板语法的解糖绑定到我们在模板中引用的列表，我们可以假设这个值始终是一个数组或类似的可迭代结构。
- en: Besides storing the new value from the input property onto our directive instance,
    we also lazy initialize a member field called `differ`. Using the `find` method
    on the `IterableDiffers` object, we can obtain a factory that matches the type
    of iterable you're dealing with (in our case, this will be plain arrays). On the
    obtained factory, we can then call the `create` method to create a new differ.
    The `create` method expects a `ChangeDetectorRef` object to be passed. Luckily,
    we have that readily available through an injection within the constructor.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将输入属性的新值存储到我们的指令实例上，我们还懒加载一个名为`differ`的成员字段。通过在`IterableDiffers`对象上调用`find`方法，我们可以获得一个与您正在处理的可迭代类型匹配的工厂（在我们的情况下，这将是一个普通的数组）。在获得的工厂上，我们可以调用`create`方法来创建一个新的差异。`create`方法期望传递一个`ChangeDetectorRef`对象。幸运的是，我们通过构造函数中的注入已经准备好了。
- en: The differ will help us in a later step to detect changes between the existing
    value of our array and an updated one. We can then perform additions, removals,
    and movements in a very performant way.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 差异将帮助我们稍后检测数组现有值和更新值之间的变更。然后我们可以以非常高效的方式执行添加、移除和移动操作。
- en: 'If we call the `diff` method on `IterableDiffer`, it will return a new `IterableDiffer`
    object that contains all the changes relative to the previous `IterableDiffer`
    object. In a differ, we can then call one of the following methods to iterate
    over the relevant `CollectionChangeRecord`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`IterableDiffer`上调用`diff`方法，它将返回一个新的`IterableDiffer`对象，该对象包含相对于先前`IterableDiffer`对象的所有变更。在一个差异中，我们可以调用以下方法之一来遍历相关的`CollectionChangeRecord`：
- en: '`forEachItem`: This iterates over each `CollectionChangeRecord` within the
    differ by providing a callback function. The first argument to the callback will
    be a change record.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEachItem`: 这通过提供一个回调函数来遍历差异中的每个`CollectionChangeRecord`。回调函数的第一个参数将是一个变更记录。'
- en: '`forEachPreviousItem`: This only iterates over each `CollectionChangeRecord`
    within the differ that already existed in the previous differ.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEachPreviousItem`: 这只遍历在先前的差异中已经存在于差异中的每个`CollectionChangeRecord`。'
- en: '`forEachAddedItem`: This only iterates over each change record that was added
    from the previous diff to the current one.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEachAddedItem`: 这只遍历从先前的差异到当前差异中添加的每个变更记录。'
- en: '`forEachMovedItem`: This only iterates over each change record that was moved.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEachMovedItem`: 这只遍历被移动的每个变更记录。'
- en: '`forEachRemovedItem`: This only iterates over change records that were removed'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEachRemovedItem`: 这只遍历被移除的变更记录'
- en: 'The `CollectionChangeRecord` objects contain the following three main properties:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollectionChangeRecord`对象包含以下三个主要属性：'
- en: '`item`: A reference to the item within the list which we''re observing for
    changes using the differ'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`item`: 对列表中我们正在使用`differ`观察变更的项目的一个引用'
- en: '`previousIndex`: The index of the item within the list before the `differ`
    iterable happened'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`previousIndex`: 在`differ`可迭代之前列表中项目的索引'
- en: '`currentIndex`: The index of the item within the list after the `differ` iterable'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentIndex`: 在`differ`可迭代之后列表中项目的索引'
- en: 'We can also solely tell from the constellation of `previousIndex` and `currentIndex`
    what happened to the item. The following methods are present on an `IterableDiffer`
    object:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以仅从`previousIndex`和`currentIndex`的星座中判断出项目发生了什么。以下方法存在于一个`IterableDiffer`对象上：
- en: '**Added items**: This can be identified if `previousIndex` is null and `currentIndex`
    is set to a valid number'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**新增的项目**：如果`previousIndex`为null且`currentIndex`设置为有效数字，则可以识别出来'
- en: '**Moved items**: This can be identified if `previousIndex` and `currentIndex`
    are both set to a valid number'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已移动的项目**：如果`previousIndex`和`currentIndex`都设置为有效的数字，则可以识别出来'
- en: '**Removed items**: This can be identified if `previousIndex` is set to a valid
    number but `currentIndex` is set to `null`'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已删除的项目**：如果`previousIndex`设置为有效的数字但`currentIndex`设置为`null`，则可以识别出来'
- en: 'Now let''s look at the `onScroll` method, which will be invoked by the scroll
    event callback of the scrollable container element. In this method, we need to
    handle the logic of our behavior that should be executed when a user scrolls down:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`onScroll`方法，它将由可滚动容器元素的滚动事件回调调用。在这个方法中，我们需要处理当用户向下滚动时应执行的行为逻辑：
- en: '[PRE65]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In the `onScroll` method, we first checked whether the scrollbar of the scrollable
    parent element has already scrolled to the bottom. If that's the case, we can
    assume that we should display more items from our list.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onScroll`方法中，我们首先检查可滚动父元素的滚动条是否已经滚动到底部。如果是这样，我们可以假设我们应该从我们的列表中显示更多项目。
- en: We incremented the `showItemCount` member by the default `increment` value,
    which we have set to `3`, and after modifying the number of displayed items, we
    used the change detector to mark our subtree structure to be checked.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`showItemCount`成员增加了默认的`increment`值，我们将其设置为`3`，在修改了显示项目的数量后，我们使用了变更检测器来标记我们的子树结构以进行检查。
- en: 'Since we would like to use the differ that we have lazy initialized within
    our input setter to detect changes and perform any actions manually, we will need
    to implement the `DoCheck` life cycle callback on our directive. By implementing
    this, we will disable the default change detection of Angular and implement our
    own way to deal with changes:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在输入设置器中懒初始化的检测器中检测更改并手动执行任何操作，我们需要在我们的指令上实现`DoCheck`生命周期回调。通过实现这一点，我们将禁用Angular的默认变更检测并实现我们自己的处理更改的方式：
- en: '[PRE66]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: First, we used the differ to obtain a change record set from the current `infiniteScrollOf`
    array to the previous one. The differ will actually always store the previous
    value, so we only need to pass it the current value. The change records will then
    help us to perform different actions for added, removed, and moved items. It's
    also important to note that we did not use the whole list here to create a diff,
    but a slice of the list where our `showItemCount` member comes into play. This
    will only make the list that we're concerned about available in our infinite scroll
    behavior.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用检测器从当前的`infiniteScrollOf`数组到前一个数组获取一个更改记录集。实际上，检测器总是会存储前一个值，所以我们只需要传递当前值给它。更改记录将帮助我们为添加、删除和移动的项目执行不同的操作。同样重要的是要注意，我们在这里没有使用整个列表来创建差异，而是使用列表的一部分，其中我们的`showItemCount`成员发挥作用。这将只使我们在无限滚动行为中关心的列表可用。
- en: Adding and removing embedded views
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加和删除嵌入式视图
- en: 'If there are any changes detected by the differ, we can call the `applyChanges`
    method, which deals with the details of how to perform view updates with changed
    items:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果检测到任何变化，我们可以调用`applyChanges`方法，该方法处理如何使用更改的项目执行视图更新的细节：
- en: '[PRE67]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Let's look at the innards of the `applyChanges` method. It needs to be called
    from the `OnChange` life cycle hook with a parameter that reflects the record
    changes within the observed input array called `infiniteScrollOf`. In the constant
    `recordViewTuples`, we stored all the change records that were either moved or
    removed completely. Now you can call the `bulkRemove` method by passing the `recordViewTuples`
    array. The `bulkRemove` method will either detach the view, in case there is movement,
    or completely remove the view. The returned value is a list that will contain
    only the tuples that were moved. We stored these within a constant called `insertTuples`.
    Because they were detached from the view container, we will need to reattach them
    at a different position within the view container.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`applyChanges`方法的内部结构。它需要从观察到的输入数组`infiniteScrollOf`中的记录更改调用。在常量`recordViewTuples`中，我们存储了所有已移动或完全删除的更改记录。现在你可以通过传递`recordViewTuples`数组来调用`bulkRemove`方法。`bulkRemove`方法将根据是否有移动来断开视图，或者完全删除视图。返回的值是一个列表，它将只包含移动的元组。我们将这些存储在一个名为`insertTuples`的常量中。因为它们已经从视图容器中分离出来，所以我们需要在视图容器中的不同位置重新附加它们。
- en: Now we can go ahead and add all the records to the `insertTuples` array that
    were added according to the latest diff. The `insertTuples` array now contains
    all the moved as well as added records.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续将根据最新差异添加的所有记录添加到`insertTuples`数组中。`insertTuples`数组现在包含所有移动的以及添加的记录。
- en: Using this list, we call the `bulkInsert` method, which will reinsert moved
    views and create new embedded views for added records. As a result, we get a list
    of all the inserted records (moved and added), where each record also contains
    a view property that points to the inserted view.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此列表，我们调用`bulkInsert`方法，该方法将重新插入移动的视图并为添加的记录创建新的嵌入视图。结果，我们得到一个包含所有插入记录（移动的和添加的）的列表，其中每个记录还包含一个指向插入视图的视图属性。
- en: The last step within our `applyChanges` method should now ring a bell. We iterated
    through the list of newly inserted views and set the local view variable `$implicit`
    on the view context. This way, we can set the required variable that is used to
    create the default variable mappings on our template elements, as discussed in
    the previous topic.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`applyChanges`方法的最后一步应该现在响起警钟。我们遍历了新插入的视图列表，并在视图上下文中设置了局部视图变量`$implicit`。这样，我们可以设置所需的变量，该变量用于在模板元素上创建默认变量映射，如前一个主题中讨论的那样。
- en: In order to understand how we can instantiate new views from our template element,
    move views around, and remove existing views, we need to understand the view container.
    The `ViewContainerRef` dependency is provided to our directive or component using
    injection in the constructor. It stores a list of views and provides some methods
    to add new and remove existing views. Each component within Angular contains one
    view container. We can then access the methods on the view container in order
    to programmatically modify the view.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解我们如何从模板元素实例化新视图，移动视图，以及删除现有视图，我们需要了解视图容器。`ViewContainerRef`依赖项通过构造函数中的注入提供给我们的指令或组件。它存储了一个视图列表，并提供了一些添加新视图和删除现有视图的方法。Angular中的每个组件都包含一个视图容器。然后我们可以访问视图容器上的方法来以编程方式修改视图。
- en: 'There are four main methods in `ViewContainerRef` that we''re interested in:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ViewContainerRef`中有四种主要方法是我们感兴趣的：
- en: '| Method | Description |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `createEmbeddedView` | This method will create a new embedded view using
    a template reference and insert the newly created view at a given index within
    the view container. Embedded views are views instantiated from template elements.The
    following are its parameters:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '| `createEmbeddedView` | 此方法将使用模板引用创建一个新的嵌入视图，并在视图容器中给定索引处插入新创建的视图。嵌入视图是从模板元素实例化的视图。以下是其参数：'
- en: '`templateRef`: The first parameter should be the template reference, which
    should be instantiated into an embedded view.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templateRef`：第一个参数应该是模板引用，它应该被实例化为嵌入视图。'
- en: '`context`: This is an optional context object, which will be available for
    the instantiated template view. All properties within the context can be used
    within the view template as local view variables.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context`：这是一个可选的上下文对象，它将为实例化的模板视图可用。上下文中的所有属性都可以在视图模板中作为局部视图变量使用。'
- en: '`index`: The optional index parameter can be used to place the instantiated
    view at a given position within the view container.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`：可选的索引参数可以用来在视图容器中指定位置放置实例化的视图。'
- en: This method returns the created embedded view. |
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回创建的嵌入视图。 |
- en: '| `detach` | The `detach` method will remove an embedded view from the view
    container at a given index without destroying the view so it can be reattached
    later using the `insert` method.The following is its parameter:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '| `detach` | `detach`方法将从视图容器中移除给定索引的嵌入视图，而不销毁视图，以便稍后可以使用`insert`方法重新附加。以下是其参数：'
- en: '`index`: This is the index of the embedded view, which should be detached'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`：这是嵌入视图的索引，应该被分离'
- en: This method returns the detached embedded view. |
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回分离的嵌入视图。 |
- en: '| `remove` | The `remove` method will completely remove an embedded view from
    the view container and also destroy the view. A view that has been destroyed can''t
    simply be reattached using the `insert` method.The following is its parameter:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '| `remove` | `remove`方法将完全从视图容器中删除嵌入视图并销毁视图。已销毁的视图不能简单地使用`insert`方法重新附加。以下是其参数：'
- en: '`index`: This is the index of the embedded view, which should be removed'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`：这是嵌入视图的索引，应该被移除'
- en: This method returns the removed embedded view. |
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回被删除的嵌入视图。 |
- en: '| `insert` | This method will insert an existing view into the view container.The
    following are its parameters:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '| `insert` | 此方法将现有视图插入到视图容器中。以下是其参数：'
- en: '`viewRef`: The embedded view that should be inserted into the view container.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`viewRef`：应插入到视图容器中的嵌入式视图。'
- en: '`index`: The optional index parameter that can be used to place the embedded
    view at a given position within the view container.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`：可选的索引参数，可用于在视图容器中指定位置放置嵌入式视图。'
- en: This method returns the inserted embedded view. |
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回插入的嵌入式视图。|
- en: 'Let''s quickly look at the `bulkRemove` and `bulkInsert` methods to see how
    we can use the view container to modify the containing view upon changes:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看 `bulkRemove` 和 `bulkInsert` 方法，看看我们如何使用视图容器在更改时修改包含的视图：
- en: '[PRE68]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We use `ViewContainerRef` to detach views in case the record contains a valid
    `currentIndex` field. If that's the case, we know that we are dealing with a view
    that will be moved. We use the `detach` method to exclude the view from its position
    within the view container, but this will not destroy the view. It's important
    to note here that we stored the returned view from the `detach` method onto the
    tuple before we added it to the `movedTuples` list. This way, we were able to
    identify it later as a moved item, and we could use the view to reattach it using
    the `insert` method on the view container.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `ViewContainerRef` 来断开视图，以防记录包含有效的 `currentIndex` 字段。如果是这种情况，我们知道我们正在处理一个将要移动的视图。我们使用
    `detach` 方法将视图从视图容器中的位置排除，但这不会销毁视图。在此需要注意的是，我们在将视图添加到 `movedTuples` 列表之前，将 `detach`
    方法返回的视图存储到元组中。这样，我们就能在以后将其识别为移动项，并可以使用视图容器上的 `insert` 方法重新附加它。
- en: In the case where there's no valid `currentIndex`, we are dealing with an element
    that was removed from the list. In such cases, we'd need to use the `remove` method
    to completely destroy the view and remove it from the view container.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有有效 `currentIndex` 的情况下，我们正在处理从列表中删除的元素。在这种情况下，我们需要使用 `remove` 方法完全销毁视图并将其从视图容器中删除。
- en: 'Now we''ll call the `bulkInsert` method with any moved or inserted views. Let''s
    also look at the code of this method briefly to see how we can handle view updates
    there:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用任何移动或插入的视图调用 `bulkInsert` 方法。让我们也简要看看这个方法的代码，看看我们如何在其中处理视图更新：
- en: '[PRE69]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: If the tuple contains a `view` property, we know we have previously detached
    it from a different position. We are using the insert method of the view container
    to reattach it at the new position using the information from `CollectionChangeRecord`.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元组包含 `view` 属性，我们知道我们之前已经从不同的位置将其断开。我们正在使用视图容器的插入方法，使用 `CollectionChangeRecord`
    中的信息在新的位置重新附加它。
- en: If there's no `view` property, we are dealing with a newly added record. In
    that case, we simply use the `createEmbeddedView` method to create a new template
    instance. For the context parameter, we need to pass a new empty object. However,
    we've updated the context object already within our `applyChanges` method. There,
    we added the `$implicit` local view variable for every created view.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 `view` 属性，我们正在处理一个新添加的记录。在这种情况下，我们只需使用 `createEmbeddedView` 方法创建一个新的模板实例。对于上下文参数，我们需要传递一个新的空对象。然而，我们已经在
    `applyChanges` 方法中更新了上下文对象。在那里，我们为每个创建的视图添加了 `$implicit` 本地视图变量。
- en: 'That''s all we need for our `InfiniteScroll` directive, and we can now add
    it to the templates where we''re planning to use this functionality. Let''s use
    it within the task list by adding the directive to the directive list of the `TaskList`
    component within the `task-list/task-list.js` file:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们 `InfiniteScroll` 指令所需的所有内容，我们现在可以将其添加到我们计划使用此功能的模板中。让我们在 `task-list/task-list.js`
    文件中的 `TaskList` 组件的指令列表中添加这个指令：
- en: '[PRE70]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now we can simply edit the task list template in `task-list/task-list.html`
    and replace the `NgFor` directive with our `InfiniteScroll` directive:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `task-list/task-list.html` 中简单地编辑任务列表模板，并用我们的 `InfiniteScroll` 指令替换
    `NgFor` 指令：
- en: '[PRE71]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: That's all we need to use our infinite scroll functionality. This is highly
    reusable, and we can place it wherever we'd like to use it instead of the regular
    `NgFor` repeater.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们使用无限滚动功能所需的所有内容。这是高度可重用的，我们可以将其放置在我们希望使用它的任何位置，而不是常规的 `NgFor` 重复器。
- en: Finishing our infinite scroll directive
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成我们的无限滚动指令
- en: In this topic, we created an infinite scrolling behavior by implementing a template
    directive similar to `NgFor`. We replaced the `NgFor` directive in our task list
    to use the `InfiniteScroll` directive instead. Now we don't display all the tasks
    right at the beginning, but as soon as the user starts to scroll, new tasks appear.
    In scenarios where we rely on a list that is partially loaded from the server,
    our directive could even be extended so it could request for more items from the
    server on demand.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们通过实现一个类似于 `NgFor` 的模板指令来创建无限滚动行为。我们将任务列表中的 `NgFor` 指令替换为 `InfiniteScroll`
    指令。现在我们不会一开始就显示所有任务，而是在用户开始滚动时，新任务就会出现。在依赖于从服务器部分加载的列表的场景中，我们的指令甚至可以扩展，以便在需要时从服务器请求更多项目。
- en: 'We''ve covered the following subtopics here:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们涵盖了以下子主题：
- en: The asterisk syntax and de-sugaring to template elements
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 星号语法和将模板元素去糖化
- en: The local view variable, `$implicit`
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地视图变量，`$implicit`
- en: Implementing the `OnChange` life cycle hook to provide custom change detection
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现用于提供自定义更改检测的 `OnChange` 生命周期钩子
- en: Using `IterableDiffer` to analyze the difference of changes within our array
    input property and handling `CollectionChangeRecord` objects to react on changes
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `IterableDiffer` 分析数组输入属性中的更改差异，并处理 `CollectionChangeRecord` 对象以对更改做出反应
- en: Using `ViewContainerRef` to update the view of a component programmatically
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ViewContainerRef` 以编程方式更新组件的视图
- en: Using `TemplateRef` as a reference to the template element within template directives
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板指令中使用 `TemplateRef` 作为模板元素内的引用
- en: Summary
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built three components to enhance the usability of our application.
    Users can now make use of tags to easily annotate comments with navigable items
    that provide summaries to the subject. They can use drag and drop to reorder tasks
    and benefit from an infinite scroll behavior on the task list.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了三个组件来增强我们应用程序的可用性。现在用户可以使用标签轻松地对注释进行标记，并使用可导航的项目提供主题摘要。他们可以使用拖放来重新排序任务，并从任务列表的无限滚动行为中受益。
- en: Usability is a key asset in today's applications, and by providing highly encapsulated
    and reusable components to address usability concerns, we can make our lives a
    lot easier when building those applications. Thinking in terms of components when
    dealing with usability is a very good thing, which not only eases development,
    but also establishes consistency. The consistency itself then plays a major role
    in making an application usable.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性是当今应用程序的关键资产，通过提供高度封装和可重用的组件来解决可用性问题，我们可以在构建这些应用程序时使生活变得更加容易。在处理可用性时以组件为思考方式是非常好的，这不仅简化了开发，还建立了一致性。一致性本身在使应用程序可用方面发挥着重要作用。
- en: In the next chapter, we're going to create some nifty components to manage time
    within our task management system. This will also include some new user input
    components to enable simple work time-entry fields.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建一些巧妙的功能组件来管理任务管理系统中的时间。这还将包括一些新的用户输入组件，以启用简单的工时输入字段。
