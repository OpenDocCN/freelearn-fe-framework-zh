- en: Chapter 2. JSX in Depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first chapter, we built our first component using React. We saw how using
    JSX makes the development easy. In this chapter, we will dive deep into JSX.
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript XML** (**JSX**) is an XML syntax that constructs the markup in
    React components. React works without JSX, but using JSX makes it easy to read
    and write the React components as well as structure them just like any other HTML
    element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Why JSX?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming JSX into JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying HTML tags and React components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different types of JSX tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JavaScript expressions inside JSX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaced components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spread attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS styles and JSX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSX Gotchas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of the chapter, we will get familiar with the JSX syntax, how it
    should be used with React, and best practices of using it. We will also study
    some of the corner cases that one can run into while using JSX.
  prefs: []
  type: TYPE_NORMAL
- en: Why JSX?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shawn had a great first day and he was just getting started with the next one
    at Adequate Consulting. With a mug of coffee, he startled Mike.
  prefs: []
  type: TYPE_NORMAL
- en: '"Hey Mike, I saw that we used JSX for building our first component. Why should
    we use JSX when React has `React.createElement`?"'
  prefs: []
  type: TYPE_NORMAL
- en: '"You can use React without using JSX. But JSX makes it easy to build React
    components. It reduces the amount of code required to write. It looks like HTML
    markup. Its syntax is simple and concise and it''s very easy to visualize the
    components that are getting built."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Take an example of the render function of a component without using JSX."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '"With JSX, it looks much better."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '"Compared to the previous non-JSX example, the JSX code is much more readable,
    easy to understand, and close to the actual HTML markup."'
  prefs: []
  type: TYPE_NORMAL
- en: '"The similarity between JSX and HTML markup means that non-developers such
    as UI and UX designers in the team can contribute to a project using JSX. Having
    XML-like tag syntax also makes reading large component trees easier compared to
    the function calls or object literals in JavaScript." explained Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Yeah. The syntax does look familiar. We will be using JSX all the way in our
    projects right?"'
  prefs: []
  type: TYPE_NORMAL
- en: '"Yes, we will", remarked Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: Transforming JSX into JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Shawn, as I mentioned, the JSX is transformed to the native JavaScript syntax."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '"This will eventually get transformed to"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for this book from your account at [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code files by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in or register to our website using your e-mail address and password.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hover the mouse pointer on the **SUPPORT** tab at the top.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on **Code Downloads & Errata**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter the name of the book in the **Search** box.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the book for which you're looking to download the code files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose from the drop-down menu where you purchased this book from.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on **Code Download**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the file is downloaded, please make sure that you unzip or extract the
    folder using the latest version of:'
  prefs: []
  type: TYPE_NORMAL
- en: WinRAR / 7-Zip for Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zipeg / iZip / UnRarX for Mac
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7-Zip / PeaZip for Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"If you would like to see this live in action, try this example at [https://babeljs.io/repl/](https://babeljs.io/repl/).
    It''s a live REPL that can transform a JSX code to the native JavaScript code."'
  prefs: []
  type: TYPE_NORMAL
- en: '"There is another editor available for converting HTML to JSX. You can check
    it out at [http://facebook.github.io/react/html-jsx.html](http://facebook.github.io/react/html-jsx.html).
    This allows you to paste an arbitrary HTML code that gets converted to JSX with
    extraction of styles, classes, and other information and then create a component
    on top of it." said Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Pretty handy. However, this is just for ease of development, right? What happens
    when we deploy our code?" asked Shawn.'
  prefs: []
  type: TYPE_NORMAL
- en: '"JSX is not meant to be compiled at runtime. Though there is a JSX transformer
    that converts JSX to JavaScript in a browser. Using it to compile JSX at runtime
    in the browser would slow down our application. We will use tools such as Babel,
    which is a JavaScript transpiler to convert our JSX code to the native JavaScript
    code before deploying the application."'
  prefs: []
  type: TYPE_NORMAL
- en: HTML tags vs React components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Mike, I am intrigued by one more thing. In JSX, we are mixing the React components
    as if they are simple HTML tags. We did this in our first component."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '"The `App` tag is not a valid HTML tag here. But this still works."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Yes. That''s because we can specify both HTML tags and React components in
    JSX. There is a subtle difference though. HTML tags start with a lowercase letter
    and React components start with an uppercase letter." Mike explained.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '"That''s the primary difference. JSX uses this convention to differentiate
    between the local component classes and HTML tags."'
  prefs: []
  type: TYPE_NORMAL
- en: Self closing tag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Another thing that you must have noticed is how the component tag is closed
    in `ReactDOM.render`" added Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '"As JSX is based on XML, it allows adding a self-closing tag. All the component
    tags must be closed either with self-closing format or with a closing tag."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Thanks Mike! Things make much more sense now."'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Shawn, let''s get back to our application. We are using almost the same code
    from last time but you can set up a new JSBin. We have included the latest React
    library and bootstrap library in the HTML tab. We have also added a container
    element, which we will render our React app."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '"Right now, we are only using a single component to display the data from the
    recent changes API."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '"Let''s split this single component into small composable components. These
    simple modular components will use other modular components with well-defined
    self-contained interfaces."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Got it" said Shawn.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Ok. The first step is trying to identify the different components that are
    present in our single component."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Currently, our render method lists `tableHeadings` and `tableRows` as the
    children of table element."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '"I guess we will make the components for the headings and rows?" Shawn asked.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Yes. But we can go one step further. Both headings and rows are lists of still
    smaller units, a `Heading` and a `Row` tag, respectively. It can be visualized
    as follows:"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '"Makes sense, Mike. Let me try to create `Heading` now."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Sure, go ahead."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '"Mike, I think this will work, except the heading. I am not sure how to render
    the actual heading in the `<th>` tag."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Don''t worry about it. Let''s just assume that it will be passed as props
    to the `Heading` component."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Sure. Here is the `Heading` component then:"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '"Perfect! The `Row` component will also be similar to `Heading`. It will get
    the `changeSet` object in its props"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '"Shawn, we are done with lowest-level components. Now, it''s time to move up
    a level. Let''s build `Headings` first."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Similar to how a `Heading` component will get its title in props, `Headings`
    will get a list of titles passed to it."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '"We are iterating over the list of titles and converting them into a list of
    the `Heading` components. The `Headings` component is controlling how the props
    are passed to the individual `Heading` components. In a sense, individual `Heading`
    components are owned by `Headings`." explained Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"In React, an owner is the component that sets props of other components. We
    can also say that if the X component is present in the `render()` method of the
    Y component, then Y owns X." Mike further added.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Shawn, go ahead and build the Rows component similar to `Headings`."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Here you go:"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '"There is just one issue. You can''t render the rows as it''s a collection
    of components. Remember that the `render()` function can only render one tag"
    Mike said.'
  prefs: []
  type: TYPE_NORMAL
- en: '"I guess I should wrap the rows in a `<tbody>` tag.", Shawn."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '"Perfect. We have almost everything now. Let''s finish it by adding the top-level
    `App` component."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '"Here''s how our complete code looks now:"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '"Shawn, I think you have understood the power of composability of components
    now. It makes our UI easy to reason with and easy to reuse and compose. We will
    be using this philosophy throughout with React."'
  prefs: []
  type: TYPE_NORMAL
- en: '"I agree. Every component does one thing right and in the end, all of them
    get composed together so that the whole application is built. Different parts
    of the code get separated in such a way that they don''t interfere with each other."'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Shawn, let''s discuss a bit about how we have rendered the `Rows` and `Headings`
    tag."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '"We are rendering `{headings}`, which is a list of React components, directly
    by adding them in curly braces as children of the `<tr>` tag. These expressions
    that are used to specify the child components are called child expressions."'
  prefs: []
  type: TYPE_NORMAL
- en: '"There is another category of expressions called as JavaScript expressions.
    These are simple expressions used for passing props or evaluating some JavaScript
    code that can be used as an attribute value."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '"Anything that is present in curly braces is evaluated by JSX. It works for
    both children expressions as well as JavaScript expressions," added Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Thanks for the detailed explanation. I have a query though. Is there any way
    to write comments in the JSX code? I mean, we may not need it all the time, but
    knowing how to add comments might be handy," Shawn asked.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Remember the curly braces rule. Comments are simply just JavaScript expressions.
    When we are in a child element, just wrap the comments in the curly braces."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '"You can also add comments in a JSX tag. There is no need to wrap them in curly
    braces in this case," Mike added.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Namespaced components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Shawn, you must have used modules and packages in languages such as Ruby and
    Java. The idea behind these concepts is to create a namespace hierarchy of code
    such that the code from one module or package doesn''t interfere with another."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Yes. Is something like this available with React?" Shawn asked.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Yes. React allows creating components that are namespaced under a parent component
    so that they don''t interfere with other components or global functions."'
  prefs: []
  type: TYPE_NORMAL
- en: '"We are using very generic names such as Rows and Headings that can be used
    later in other parts of the app too. So it makes sense to namespace them now,
    rather than later." explained Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Agreed. Let''s do it right away," Shawn.'
  prefs: []
  type: TYPE_NORMAL
- en: '"We need to represent the top-level component as custom component rather than
    using the `<table>` element."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '"Now, we can replace the `App` component to use `RecentChangesTable` instead
    of `<table>.`"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '"Hang on, Mike. We just replaced `<table>` with a custom component. All it
    does is just render `this.props.children`. How does it get all the headings and
    rows?" Shawn asked.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Ah! Nice observation. React, by default, captures all the child nodes between
    open and close tags of a component in an array and adds it to the props of that
    component as `this.props.children`. So we can render it using `{this.props.children}`.
    We will get all Headings and Rows as `this.props.children` in the `RecentChangesTable`
    component. The output is the same as before, when we used the `<table>` tag directly."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Awesome!" exclaimed Shawn.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Cool. Let''s move on next step by namespacing all other components under `RecentChangesTable`."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '"We will also need to update the `App` component to use namespaced components
    now."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '"We are now done. Everything is namespaced under `RecentChangesTable` now",
    said Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: Spread attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shawn learned a lot of things about JSX but when he was reflecting on the previous
    steps, he came up with another question.
  prefs: []
  type: TYPE_NORMAL
- en: '"Mike, as of now we are just passing two props to the `App` component: `headings`
    and `changesets`. However, tomorrow these props can increase to any number. Passing
    them one by one would be cumbersome. Especially, when we have to pass some data
    from the recent changes API directly. It will be hard to a keep track of the structure
    of the incoming data and pass it accordingly in the props. Is there a better way?"'
  prefs: []
  type: TYPE_NORMAL
- en: '"Another excellent question, Shawn. True, it might be cumbersome passing a
    large number of attributes to the component one by one. But we can solve this
    using the `spread` attributes."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '"In this case, all the properties of object are passed as props to the `App`
    component. We can pass any object that can contain any number of key value pairs
    and all of them will be passed as props to the component" explained Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Very cool. Is the `(…)` operator present only in JSX?"'
  prefs: []
  type: TYPE_NORMAL
- en: '"Nope. It is actually based on the spread attribute feature in ES2015, which
    is the next JavaScript standard. ES2015, or ES6 as it is called, introduces some
    new features in JavaScript language and React is taking advantage of these developing
    standards in order to provide a cleaner syntax in JSX" added Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ES2015 already supports spread operator for arrays at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
    There is also a proposal for objects at [https://github.com/sebmarkbage/ecmascript-rest-spread](https://github.com/sebmarkbage/ecmascript-rest-spread).
  prefs: []
  type: TYPE_NORMAL
- en: '"Not only this, spread attributes can be used multiple times or it can be combined
    with other attributes. The order of the attributes is important though. Newer
    attributes override previous ones."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '"Instead of showing **When**, **Who**, and **Description**, **Updated at**,
    **Author**, and **Change** will be shown as the headings in this case" Mike explained.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Spread attributes](img/4730_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ES2015 or ES6 is the latest version JavaScript standard. It has a lot of features,
    which are used by React, similar to the spread attributes. We will be using lot
    more ES2015 or ES6 code in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Styles in JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Mike, all of the things that we did today are very cool. When do we start
    adding styles? How can I make this page look pretty? Right now it''s a bit dull."
    Shawn asked.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Ah, right. Let''s do that. React allows us to pass styles to the components
    the same way props can be passed. For example, we want our headings to be of the
    floral white color and maybe we want to change the font size. We will represent
    it in a typical CSS way as follows:"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '"We can represent this as a JavaScript object in the CamelCase fashion."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Then, we can use it in each Heading component as a JavaScript object."
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '"Similarly, let''s change the rows to have their own styles."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '"We now have some shiny new headings and rows sprinkled by CSS styling" Mike
    added.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styles in JSX](img/4730_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '"Nice. The name of the attribute to pass these styles must be ''style'', right?"
    Shawn asked.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Yes. Also the keys of this style object need to be CamelCased, for example,
    `backgroundColor`, `backgroundImage`, `fontSize`, and so on."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Mike, I understood the inline styling, however, how to add the CSS classes?"'
  prefs: []
  type: TYPE_NORMAL
- en: '"Ah right. We can pass the class name as an attribute to the DOM tags. Let''s
    extract the styling to a new `recentChangesTable` CSS class."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '"Now, to apply this class to our component, all we need to do is pass it to
    the component using the expalined `className` prop."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '"As we have seen previously, React makes use of the CamelCase attributes. Here,
    the `className` prop will be converted to a normal class attribute when React
    renders the actual HTML."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '"We can also pass multiple classes to the `className` prop."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '"That''s it! We can simply start using the styles freely in our components.
    This makes it trivial to integrate React with existing CSS styles."'
  prefs: []
  type: TYPE_NORMAL
- en: JSX Gotchas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The day was heading to an end. Mike and Shawn were still discussing about this
    shiny new thing—JSX. Mike decided that it was time to tell Shawn about the issues
    with using JSX.
  prefs: []
  type: TYPE_NORMAL
- en: '"Shawn, so how do you feel about using JSX?"'
  prefs: []
  type: TYPE_NORMAL
- en: '"I liked it so far. It''s very similar to the HTML markup. I can pass attributes,
    styles, and even classes. I can also use all the DOM elements" explained Shawn.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Yes. But JSX is not HTML. We have to always remember this. Otherwise, we will
    run into trouble."'
  prefs: []
  type: TYPE_NORMAL
- en: '"For example, if you want to pass some custom attribute that does not exist
    in the HTML specification, then React will simply ignore it."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '"It must be passed as a data attribute so that React will render it."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '"We may also run into some issues while rendering the HTML content dynamically.
    In the JSX tags, we can add a valid HTML entity directly."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '"But if we render it in a dynamic expression, it will then escape the ampersand."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '"It happens as React escapes all the strings in order to prevent XSS attacks
    by default. To overcome it, we can directly pass the Unicode character of `&amp;`
    or we can use arrays of strings and JSX elements." Mike explained.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '"Wow. It can get pretty messed up" expressed Shawn.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Well, yes, but if we remember the rules, then it''s pretty simple. Also, as
    a last resort, React also allows to render raw HTML using a special `dangerouslySetInnerHTML`
    prop."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '"Although this option should be used after consideration about what is getting
    rendered to prevent XSS attacks" Mike explained.'
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals in JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"React embraces the idea of tying markup and logic that generates the markup
    together. This means that we can use the power of JavaScript for loops and conditionals."'
  prefs: []
  type: TYPE_NORMAL
- en: '"But if/else logic is a bit hard to express in markup. Therefore, in JSX, we
    can''t use conditional statements such as if/else."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '"Instead, we can use a ternary operator for specifying the if/else logic."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '"But ternary operator gets cumbersome with large expressions when we want to
    use the React component as a child. In this case, it''s better to offload the
    logic to a block or maybe a function" Mike added.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Non-DOM attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Alright Shawn, it''s time to take a detailed look at our application again.
    If you closely see the console output, you will see a few warnings related to
    Keys."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '"In the `render()` method of `Rows`, we are rendering collection of the `Row`
    components."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '"During the rendering of list items, a component may move up or down in the
    DOM tree based on the user interaction. For example, in case of search or sorting,
    the items in the list can change their position. New items can also get added
    to the front of the list in case new data gets fetched. In such cases, React may
    remove and recreate components based on the diff algorithm. But if we provide
    a unique identifier for each element in the list, then React will intelligently
    decide whether to destroy it or not. This will improve the rendering performance.
    This can be achieved by passing a unique `key` prop to every item in the list."'
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the number of rows is currently fixed. But later on, we want to
    show the updates page as the new data is being fetched from the API. The situation
    gets complicated when children are added or removed dynamically as the state and
    identity of each component must be maintained in every render pass. The `key`
    prop will help React to uniquely identify the component in such cases. Go ahead
    and use the index of the `Row` component for this purpose as it will be unique
    as of now" Mike further explained.
  prefs: []
  type: TYPE_NORMAL
- en: '"Cool. So let me try adding the `key` prop to `Rows`. I noticed same issue
    with the `Headings` component too, therefore, I will add a key for `Headings`
    as well." said Shawn.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '"Perfect. Note that the value of keys for a given list should be unique. We
    will get to know more about the keys when we start updating the DOM based on dynamic
    data. But this is good enough for now" said Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Makes sense. Are there any more such keywords/identifiers available for us?"'
  prefs: []
  type: TYPE_NORMAL
- en: '"Yes. Along with key, there is also refs or references. It allows the parent
    component to keep a reference of a child component. Right now, we can''t access
    the child components outside the `render()` method of the component. But having
    `ref` allows us to use the child component anywhere in the component, not just
    the `render()` method."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '"Now, we can access these references outside the render method too."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '"It''s pretty useful when we want to inform a component to change something
    at runtime. We will discuss and use `refs` in more detail later when we deal with
    event handlers" Mike added.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dived deep into JSX. We discussed why using JSX makes development
    with React easy and how JSX gets transformed into the plain native JavaScript.
    We split big the single React component into small, focused components and understood
    the advantages of reusable, modular components. We saw different JSX tags, JavaScript
    expressions, and how React is taking advantages of ES6 features such as spread
    attributes. In the end, we discussed advanced topics such as namespaced components
    and some gotchas that we should keep in mind while using JSX.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on data flow and models to access data and
    component life cycle and their use.
  prefs: []
  type: TYPE_NORMAL
