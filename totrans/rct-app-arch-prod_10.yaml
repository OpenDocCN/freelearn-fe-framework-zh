- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Going Beyond
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application is finally in production. It might be getting some users as
    we speak. However, as with every piece of software, our application may never
    be fully completed. There is always room for improvement, and since the application
    we built is just an MVP, there are a lot of potential improvements worth mentioning.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be covering some of the most important improvements
    from both feature and technical perspectives. These topics might give us some
    ideas on extending and improving the existing application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Feature improvements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical improvements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Appendix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have covered some features we can add to
    the existing application to make it more complete. We will also mention some topics
    that were not covered in this book but are worth exploring on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Feature improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since our application is at the MVP stage at the moment, there are many potential
    improvements from the user’s perspective that would make the application more
    usable.
  prefs: []
  type: TYPE_NORMAL
- en: Jobs feature improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The jobs feature is the most important feature of this app. There are several
    improvements we can implement to make the application better:'
  prefs: []
  type: TYPE_NORMAL
- en: Updating jobs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding jobs in a draft state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting jobs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding/updating jobs information with markdown/the *WYSIWYG* editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating jobs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now, our application only supports job creation. What happens when we
    want to change some information about the given job posting? It would be great
    if we could edit job data after it’s been created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we can do that:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the *update* endpoint handler at `PATCH /jobs/:jobId`, which will update
    the data in the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the *update job* page at `/dashboard/jobs/:jobId/update`, which is where
    the update form should be
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the *update* form with all the fields that we want to be able to update
    for a job
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upon successful submission, we should invalidate the job query so that its data
    gets refetched
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding jobs in a draft state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, when we create a job for our organization, it will become immediately
    available to the public. However, it would be great if we could extend its functionality
    so that we can choose when we want to publish job postings to the public.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Extending the job model with the `status` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the `status` value to `draft` or `published`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When submitting the job creation form, the newly created job will initially
    have a `status` of `draft`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we could update the status of the job via the *update* form, where we
    send the desired status as a value. Another way we could do this would be to expose
    a separate endpoint that would only update the status of the job.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting jobs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the time, job positions get closed. In that case, no one wants a job
    posting that is no longer relevant, so it might be a good idea to allow organization
    admins to delete jobs they don’t find relevant anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Having a *Delete* endpoint that will handle deleting the job from the database.
    Clicking on a button would send the request and, on a successful request, redirect
    the user to the jobs list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the `status` property, which could now have an additional `archived`
    or `deleted` value. This method is called **soft delete** because we are not deleting
    the entry from the database, but from the application’s perspective, it looks
    as if it was deleted. Archiving job postings might be useful for tracking different
    stats from previous hires.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding/updating jobs information with markdown/the WYSIWYG editor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, the job information is filled with a `textarea` input field, which
    is convenient for plain text values. However, the admin’s ability to add as much
    information as possible is limited to text only.
  prefs: []
  type: TYPE_NORMAL
- en: It would be great if we could allow admins to add things, such as different
    headers, lists, links, and so on, to the job information so that the job posting
    provides as much information as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The solution would be to replace the `textarea` input field with a rich text
    editor, which would allow us to add more than just text. Just make sure that you
    sanitize the inputs before submitting them to keep the application as safe as
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: Organization improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, there is no way for the organization admin to update the organization’s
    information. The organization should be able to change any of the information
    at any time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this possible, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the endpoint for updating the organization at `PATCH /organizations/:organizationId`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a page at `/dashboard/organization/update` where we can have the update
    form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding job applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One more thing we can improve is the ability to add job applications.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, there is no mechanism to apply to jobs directly in the application.
    When the user clicks the **Apply** button, the email client is opened with the
    correctly set subject. Then, the user would send an email to the organization’s
    email address, and that would be the entire flow.
  prefs: []
  type: TYPE_NORMAL
- en: To take it to the next level, we can create another entity called *Application*
    that will be submitted when the user applies for a job. This approach will allow
    admins to track job applications for their organizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s rethink what the data model of the application will look like with this
    new feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Applications in the data model ](img/B17297_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Applications in the data model
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, an application should contain some basic information about the
    candidate, a message, a report from the interviewer, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the data model has been updated, we can build the applications feature,
    which will handle all things related. This would include things such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Endpoints for creating and browsing applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pages on the dashboard where the admins can browse through all the applications.
    They can be defined at `/dashboard/applications` and `/dashboard/applications/:applicationId`
    for the listing and details pages, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering and paginating lists of data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Displaying lists of data in tables is fine, but what happens when the number
    of entries starts to grow significantly? It is not very optimal to load all the
    entries in one go because not all entries might be needed in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: To optimize data lists, we can add support for filtering and paginating data.
    This will help users narrow down the search results to what they need. Both filtering
    and paginating should happen on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking current filter and pagination values should be handled by URL parameters.
    This will make it easy for the application to deep link the search results for
    any further usage.
  prefs: []
  type: TYPE_NORMAL
- en: Adding user registration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This one is pretty straightforward. Until now, we have relied on test data,
    which had one test user that we used to sign in to the dashboard. However, there
    is no way to register new users. If we want to make this application usable by
    more than one organization, we should add this functionality. This can be implemented
    by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the registration endpoint at POST `/auth/register`, which would take
    the required data from a form and create a user and its corresponding organization
    in the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the registration page at `/auth/register`, where there is the registration
    form which, when submitted, calls the registration endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application is in good shape, but several things should be kept in mind
    in case the application starts growing. Let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side rendering and caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several improvements we can make to further optimize how the public
    pages are rendered on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, we are rendering the pages on each request, which is good if the
    data changes frequently; otherwise, it might increase the loading time and server
    costs because rendering on the server is a compute-intensive operation.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Next.js supports another rendering strategy called **Incremental**
    **Static Regeneration**.
  prefs: []
  type: TYPE_NORMAL
- en: 'It works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*User1* requests a page.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server returns the cached version of the page and returns it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: During that request, Next.js is triggered to regenerate the same page with the
    latest data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*User2* requests a page.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server returns the new version of the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we take our public job details page as an example, it will work as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we would need to use `getStaticPaths` to generate all the paths for
    all the jobs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will generate a list of paths for all the jobs that exist in the database.
    The key thing here is the `fallback` property, which will make Next.js not return
    the 404 page but try to generate a new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must also replace `getServerSideProps` with `getStaticProps`, which would
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we can add the `revalidate` property to the `return` value. This
    will force the page to revalidate after 60 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Since jobs and organizations’ data don’t change very frequently, this rendering
    strategy sounds more optimal in the long run, especially once the number of requests
    starts to grow.
  prefs: []
  type: TYPE_NORMAL
- en: It makes for a good compromise between the performance and freshness of the
    data.
  prefs: []
  type: TYPE_NORMAL
- en: React Query hydration for SSR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, we are using React Query for handling data fetching on the client,
    but data fetching on the server is being handled without it. We are just fetching
    the data and passing and rendering it on the page. This is fine if we don’t have
    many levels of components, but there is a better way to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'React Query supports two ways of fetching data on the server and passing it
    to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetching the data on the server and then passing it as `initialData` to the
    query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefetching on the server, dehydrating the cache, and rehydrating it on the
    client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first option is good for smaller apps where there is not a very large hierarchy
    between the component, so there is no need to pass the server data down multiple
    levels to the desired query.
  prefs: []
  type: TYPE_NORMAL
- en: The second option might take more initial setup, but in the end, it makes the
    code base much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `pages/_app.tsx` file, we should wrap anything that is inside `QueryClientProvider`
    with `Hydrate`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will prepare the application to process any dehydrated state. But how do
    we provide a dehydrated state to the page?
  prefs: []
  type: TYPE_NORMAL
- en: 'On a specific page, we can modify `getStaticProps` or `getServerSideProps`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can consume the jobs as we would if we were fetching them on the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will make it much easier to handle all the server states with React Query.
  prefs: []
  type: TYPE_NORMAL
- en: Using query key factories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having many queries all over the app might get pretty difficult to manage once
    the number of queries starts to grow. It is hard to track all the variations of
    the queries and where they are being used. Preventing duplicate query keys might
    be one of the problems as well.
  prefs: []
  type: TYPE_NORMAL
- en: That’s why we should think about using query key factories instead of just deliberately
    adding the query keys all over the place.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define all potential keys in `src/lib/react-query.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can define a simplified version of the factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can create the keys for the queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, not all the features have the same key structure, but we can
    combine different factories to create what we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, if we wanted to use a key in a query, we could do so as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: What is good with this approach is that we have a centralized overview of all
    the keys, which reduces the possibility of making mistakes by mistyping a key
    or something similar.
  prefs: []
  type: TYPE_NORMAL
- en: This was an example of a simplified query key factory. If you need a more robust
    solution, there is a great library for this that can be found at [https://www.npmjs.com/package/@lukemorales/query-key-factory](https://www.npmjs.com/package/@lukemorales/query-key-factory).
  prefs: []
  type: TYPE_NORMAL
- en: Code scaffolding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When looking at our application, we might notice that there is some level of
    boilerplate. Creating components, for example, requires a folder that looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We must remember to re-export the component from `index.ts` to make it available.
  prefs: []
  type: TYPE_NORMAL
- en: The same thing can be said for API requests. We need to create the request function
    and then the hook that consumes it. These things can be automated with tools that
    can help us generate these kinds of files easier via their CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Having some scaffolding tools such as Plop.js and Hygen.io also brings better
    consistency to the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Validating form inputs and API responses with Zod
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s talk briefly about validation. With validation, we want to make sure the
    data is in the expected form. For our application, we can validate form inputs
    and API responses.
  prefs: []
  type: TYPE_NORMAL
- en: For validation, we can use Zod, which is a great validation library that is
    TypeScript-first. This means that we can define a schema out of which we can infer
    types we can use.
  prefs: []
  type: TYPE_NORMAL
- en: Form input validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `react-hooks-form` library comes with great support for Zod, which we could
    utilize for this. Taking the current login form, we could modify it so that it
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are creating an object schema and providing that to `useForm` with
    the help of `yupResolver`.
  prefs: []
  type: TYPE_NORMAL
- en: This will make sure the form will never be submitted unless all the fields have
    valid values.
  prefs: []
  type: TYPE_NORMAL
- en: API requests validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We do have TypeScript types in place, but they don’t protect us from runtime
    errors. That’s why we should consider validating API responses in some cases.
    Let’s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Zod is a TypeScript-first library, we can use it to infer the types of
    the given object’s shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This might help with reducing duplicate type definitions. Finally, we can validate
    our requests, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If any of the job properties do not match the schema, Zod will throw a runtime
    error, which we can then handle properly.
  prefs: []
  type: TYPE_NORMAL
- en: Next.js 13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next.js 13 is around the corner! It was released recently with some big changes,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A new routing system with the app folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new data fetching approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s worth noting that it is backward compatible with older versions, so it
    allows incremental upgrades. It might take some time for everything to get polished
    out, but it is worth keeping an eye on it and upgrading to the new approach at
    some point.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a couple of topics that are not directly related to the application
    we built, but they are worth mentioning.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having a GraphQL API is a very common thing nowadays, especially in a microservices
    architecture. We worked with a REST API in our application, but how would we structure
    our API layer if it were a GraphQL API?
  prefs: []
  type: TYPE_NORMAL
- en: Well, the implementation would be very similar. We could choose to use a different
    library, such as Apollo, but we will stick with React Query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, first, we are defining the GraphQL query, which we then use
    to define the request function. Finally, we use the request function to create
    the `useJobs` hook.
  prefs: []
  type: TYPE_NORMAL
- en: Monorepos
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **monorepo** is a Git repository that contains more than one project with
    a clearly defined relationship between those projects. This means that a good
    monorepo setup should provide the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy code sharing between projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project constraints and visibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computation caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear boundaries of the projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is worth exploring monorepos because they are being used in some of the largest
    software projects and make such large projects easier to manage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most popular monorepo tools are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Lerna
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turborepo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yarn workspaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Micro frontend architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Micro frontend** architecture is a very interesting concept. It means that
    we can build and deploy components of the application as separate applications,
    and they would look and feel as if they were part of the same application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the benefits of using this kind of architecture are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Useful when working on a platform that has many different teams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not constrain the apps to a specific technology. Each micro frontend application
    can have a different stack, and they would work together really well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, there are also some drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Building micro frontend architectures with different technologies, even though
    it’s possible, should be discouraged. It is best to choose one framework and create
    standards for how the applications are built.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Micro frontend architecture requires much more complex tooling, which for most
    of the use cases might not be worth it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A couple of tools to explore are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Module Federation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single SPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through the rest of the topics that are worth exploring
    after finishing this book. Things such as feature improvements and technical improvements
    can take your application to the next level. Hopefully, you can take what you
    have learned here and apply it to a similar real-world scenario.
  prefs: []
  type: TYPE_NORMAL
