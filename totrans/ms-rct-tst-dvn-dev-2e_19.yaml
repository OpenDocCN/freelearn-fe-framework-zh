- en: '19'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding TDD in the Wider Testing Landscape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides the mechanics of test-driven development, this book has touched on
    a few ideas about the mindset of the TDD practitioner: how and when to “cheat,”
    systematic refactoring, *strict* TDD, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some dev teams like to adopt the mantra of *move fast and break things*. TDD
    is the opposite: go slow and think about things. To understand what this means
    in practice, we can compare TDD with various other popular testing techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven development as a testing technique
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manual testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not testing at all
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have a good idea of why and how we practice
    TDD compared to other programming practices.
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven development as a testing technique
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TDD practitioners sometimes like to say that TDD is not about testing; rather,
    it’s about design, behavior, or specification, and the automated tests we have
    at the end are simply a bonus.
  prefs: []
  type: TYPE_NORMAL
- en: Yes, TDD is about design, but TDD is certainly about testing, too. TDD practitioners
    care that their software has a high level of *quality*, and this is the same thing
    that testers care about.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, people question the naming of TDD because they feel that the notion
    of a “test” confuses the actual process. The reason for this is that developers
    misunderstand what it means to build a “test.” A typical unit testing tool offers
    you practically no guidance on how to write *good* tests. And it turns out that
    reframing tests as specifications and examples is a good way to introduce testing
    to developers.
  prefs: []
  type: TYPE_NORMAL
- en: All automated tests are hard to write. Sometimes, we forget to write important
    tests, or we build brittle tests, write loose expectations, over-complicate solutions,
    forget to refactor, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not just novices who struggle with this – everyone does it, experts included.
    People make a mess all the time. That’s also part of the fun. Discovering the
    joy of TDD requires a certain degree of humility and accepting that you aren’t
    going to be writing pristine test suites most of the time. Pristine test suites
    are very rare indeed.
  prefs: []
  type: TYPE_NORMAL
- en: If you are lucky enough to have a tester on your team, you may think that TDD
    encroaches on their work, or may even put them out of a job. However, if you ask
    them their opinion, you’ll undoubtedly find they are only too keen for developers
    to take an interest in the quality of their work. With TDD, you can catch all
    those trivial logic errors yourself without needing to rely on someone else’s
    manual testing. The testers can then better use their time by focusing on testing
    complex use cases and hunting down missed requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for your unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some great unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Independent**: Each test should test just one thing, and invoke only one
    unit. There are many techniques that we can employ to achieve this goal. To take
    just two examples, collaborators are often (but not always) mocked, and example
    data should be the minimum set of data required to correctly describe the test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classicist versus mockist TDD
  prefs: []
  type: TYPE_NORMAL
- en: You may have heard of the great TDD debate of *classicist* versus *mockist*
    TDD. The idea is that the classicist will not use mocks and stubs, while the mockist
    will mock all collaborators. In reality, both techniques are important. You have
    seen both in use in this book. I encourage you to not limit yourself to a single
    approach, but instead experiment and learn to be comfortable with both.
  prefs: []
  type: TYPE_NORMAL
- en: '**Short, with a high level of abstraction**: The test description should be
    concise. The test code should highlight all the pieces of code that are important
    to the test, and hide any apparatus that’s required but not relevant.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quick to run**: Use test doubles instead of interacting with system resources
    (files, network connections, and so on) or other processes. Do not use timeouts
    in your code, or rely on the passing of time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Focused on observable behavior**: The system is interesting for what it does
    to the outside world, not for how it does it. In the case of React, we care about
    DOM interaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In three parts**: These parts are **Arrange**, **Act**, and **Assert**, also
    known as the **AAA** pattern. Each test should follow this structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Don’t Repeat Yourself** (**DRY**): Always take the time to refactor and clean
    up your tests, aiming for readability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A design tool**: Great tests help you figure out how to design your system.
    That’s not to say that up-front design isn’t important. In almost every chapter
    in this book, we started with a little design before we embarked on our tests.
    It’s important to do some thinking so that you have an idea of the general direction
    you’re headed. Just don’t try to plan too far ahead, and be prepared to throw
    out your design entirely as you proceed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD is not a replacement for great design. To be a great TDD practitioner, you
    should also learn about and practice software design. There are many books about
    software design. Do not limit yourself to books about JavaScript or TypeScript;
    good design transcends language.
  prefs: []
  type: TYPE_NORMAL
- en: Improving your technique
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some general tips for improving:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Work with others**: Beyond reading this book, the best way to level up in
    TDD is to work with experts. Since TDD lends itself so well to pair and mob programming,
    it can give structure to teams of mixed experience. More experienced developers
    can use the granularity of small tests to help improve the work of less experienced
    developers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Experiment with design**: TDD gives you a safety net that allows you to experiment
    with the style and shape of your programs. Make use of that safety net to learn
    more about design. Your tests will keep you safe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Learn to slow down**: TDD requires a great deal of personal discipline. Unfortunately,
    there is no room for sloppiness. You must not cut corners; instead, take every
    opportunity to refactor. Once your test passes, sit with your code. Before moving
    on to the next test, stare at your current solution and think carefully about
    whether it is the best it can be.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Don’t be afraid to defer design decisions**: Sometimes, we’re faced with
    several design options, and it can be tricky to know which option to choose. Even
    a simple act such as naming variables can be difficult. Part of having a sense
    of design is knowing when to defer your thinking. If you’re in the refactor stage
    and feel yourself weighing up two or more options, move on and add another test,
    and then revisit your design. You’ll often find that you have more design knowledge
    and will be closer to the right answer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solve a kata each day**: A kata is a short exercise designed to be practiced
    repeatedly to teach you a certain technique. Two basic katas are *Coin Changer*
    and *Roman Numerals*. More complex katas include the bowling game kata, the bank
    kata, and Conway’s *Game of Life*. The diamond kata is a favorite of mine, as
    are sorting algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attend a Coderetreat**: **Coderetreats** involve a day of pairing and TDD
    that revolves around the *Game of Life* kata. The *Global Day of Coderetreat*
    is held in November. Groups from all around the world get together to solve this
    problem. It’s not only fun but a great way to expand your TDD horizons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That covers the general advice on TDD. Next, let’s look at manual testing techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Manual testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Manual testing, as you may have guessed, means starting your application and
    actually using it.
  prefs: []
  type: TYPE_NORMAL
- en: Since your software is your creative work, naturally, you are interested to
    find out how it performs. You should certainly take the time to do this but think
    of it as downtime and a chance to relax, rather than a formal part of your development
    process.
  prefs: []
  type: TYPE_NORMAL
- en: The downside to *using* your software as opposed to *developing* your software
    is that using it takes up a lot of time. It sounds silly but pointing, clicking,
    and typing all take up valuable time. Plus, it takes time to get test environments
    set up and primed with the relevant test data.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, it’s important to avoid manual testing where possible. There
    are, however, times when it’s necessary, as we’ll discover in this section.
  prefs: []
  type: TYPE_NORMAL
- en: There is always a temptation to manually test the software after each feature
    is complete, just to verify that it works. If you find yourself doing this a lot,
    consider how much confidence you have in your unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: If you can claim, “I have 100% confidence in my unit tests,” why would you ever
    need to *use* your software to prove it?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at some specific types of manual testing, starting with demonstrating
    software.
  prefs: []
  type: TYPE_NORMAL
- en: Demonstrating software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are at least two important occasions where you should *always* manually
    test: when you are demonstrating your software to your customers and users, and
    when you are preparing to demonstrate your software.'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing means writing down a demo script that lists every action you want
    to perform. Rehearse your script at least a couple of times before you perform
    it live. Very often, rehearsals will bring about changes to the script, which
    is why rehearsals are so important. Always make sure you’ve done at least one
    full run-through that didn’t require changes before you perform a live demo.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the whole product
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Frontend development includes a lot of moving parts, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple browser environments that require support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed components, such as proxies and caches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually testing is necessary because of the interaction of all these moving
    parts. We need to check that everything sits together nicely.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can use end-to-end tests for the same coverage; however,
    these are costly to develop and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Exploratory testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exploratory testing is what you want your QA team to do. If you don’t work with
    a QA team, you should allocate time to do this yourself. Exploratory testing involves
    exploring software and hunting for missing requirements or complex use cases that
    your team has not thought about yet.
  prefs: []
  type: TYPE_NORMAL
- en: Because TDD works at a very low level, it can be easy to miss or even misunderstand
    requirements. Your unit tests may cover 95% of cases, but you can accidentally
    forget about the remaining 5%. This happens a lot when a team is new to TDD, or
    is made up of novice programmers. It happens all the time with experienced TDDers,
    too – even those of us who write books on TDD! We all make errors from time to
    time.
  prefs: []
  type: TYPE_NORMAL
- en: A very common error scenario involves mocks. When a class or function signature
    is changed, any mocks of that class or function must also be updated. This step
    is often forgotten; the unit tests still pass, and the error is only discovered
    when you run the application for real.
  prefs: []
  type: TYPE_NORMAL
- en: Bug-free software
  prefs: []
  type: TYPE_NORMAL
- en: TDD can give you more confidence, but there is absolutely no way that TDD guarantees
    bug-free software.
  prefs: []
  type: TYPE_NORMAL
- en: With time and experience, you’ll get better at spotting all those pesky edge
    cases before they make it to the QA team.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to exploratory testing is automated acceptance tests, but as
    with end-to-end tests, these are costly to develop and maintain, and they also
    require a high level of expertise and team discipline.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging in the browser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Debugging is always an epic time sink. It can be an incredibly frustrating
    experience, with a lot of hair-pulling. That’s a big reason we test-drive: so
    that we never have to debug. Our tests do the debugging for us.'
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, a downside of TDD is that your debugging skills will languish.
  prefs: []
  type: TYPE_NORMAL
- en: For the TDD practitioner, debugging should, in theory, be a very rare experience,
    or at least something that is actively avoided. But there are always occasions
    when debugging is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Print-line debugging is the name given to the debugging technique where a code
    base is littered with `console.log` statements in the hope that they can provide
    runtime clues about what’s going wrong. I’ve worked with many programmers who
    began their careers with TDD; for many of them, print-line debugging is the only
    form of debugging they know. Although it’s a simple technique, it’s also time-consuming,
    involves a lot of trial and error, and you have to remember to clean up after
    yourself when you’re done. There’s a risk of accidentally forgetting about a stray
    `console.log` and it then going live in production.
  prefs: []
  type: TYPE_NORMAL
- en: Modern browsers have very sophisticated debugging tools that, until just recently,
    would have been imaginable only in a “full-fat” IDE such as Visual Studio or IntelliJ.
    You should make time to learn about all of the standard debugging techniques,
    including setting breakpoints (including conditional breakpoints), stepping in,
    out, and over, watching variables, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: A common anti-pattern is to use debugging techniques to track down a bug, and
    once it’s discovered, fix it and move on to the next task. What you should be
    doing instead is writing a failing test to prove the existence of a bug. As if
    by magic, the test has done the debugging for you. Then, you can fix the bug,
    and immediately, the test will tell you whether the issue has been fixed, without
    you needing to manually re-test. Think of all the time you’ll save!
  prefs: []
  type: TYPE_NORMAL
- en: Check out the *Further reading* section for resources on the Chrome debugger.
  prefs: []
  type: TYPE_NORMAL
- en: That covers the main types of manual testing that you’ll perform. Next, let’s
    take a look at automated testing techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Automated testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TDD is a form of automated testing. This section lists some other popular types
    of automated testing and how they compare to TDD.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These tests check how two or more independent processes interact. Those processes
    could either be on the same machine or distributed across a network. However,
    your system should exercise the same communication mechanisms as it would in production,
    so if it makes HTTP calls out to a web service, then it should do so in your integration
    tests, regardless of where the web service is running.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests should be written in the same unit test framework that you
    use for unit tests, and all of the same rules about writing good unit tests apply
    to integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: The trickiest part of integration testing is the orchestration code, which involves
    starting and stopping processes, and waiting for processes to complete their work.
    Doing that reliably can be difficult.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re choosing to mock objects in your unit tests, you will need at least
    *some* coverage of those interactions when they *aren’t* mocked, and integration
    tests are one way to do that. Another way is system testing, as discussed below.
  prefs: []
  type: TYPE_NORMAL
- en: System tests and end-to-end tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These are automated tests that exercise the entire system, usually (but not
    necessarily) by driving a UI.
  prefs: []
  type: TYPE_NORMAL
- en: They are useful when manual exploratory testing starts taking an inordinate
    amount of time. This happens with codebases as they grow in size and age.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end tests are costly to build and maintain. Fortunately, they can be
    introduced gradually, so you can start small and prove their value before increasing
    their scope.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Acceptance tests are written by the customer, or a proxy to the customer such
    as a product owner, where *acceptance* refers to a quality gate that must be passed
    for the released software to be accepted as complete. They may or may not be automated,
    and they specify behavior at a system level.
  prefs: []
  type: TYPE_NORMAL
- en: How should the customer write these tests? For automated tests, you can often
    use system testing tools such as Cucumber and Cypress. The Gherkin syntax that
    we saw in [*Chapter 17*](B18423_17.xhtml#_idTextAnchor344)*, Writing Your First
    Cucumber Test*, and [*Chapter 18*](B18423_18.xhtml#_idTextAnchor355)*, Adding
    Features Guided by Cucumber Tests*, is one way to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance tests can be used to build trust between developers and product stakeholders.
    If the customer is endlessly testing your software looking for bugs, that points
    to a low level of trust between the development team and the outside world. Acceptance
    tests could help improve that trust if they start catching bugs that would otherwise
    be found by your customer. At the same time, however, you should be asking yourself
    why TDD isn’t catching all those bugs in the first place and consider how you
    can improve your overall testing process.
  prefs: []
  type: TYPE_NORMAL
- en: Property-based and generative testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In traditional TDD, we find a small set of specifications or examples to test
    our functions against. Property-based testing is different: it generates a large
    set of tests based on a definition of what the inputs to those functions should
    be. The test framework is responsible for generating the input data and the tests.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, if I had a function that converted Fahrenheit to Celsius, I could
    use a generative test framework to generate tests for a large, random sample of
    integer-valued Fahrenheit measurements and ensure that each of them converts into
    the correct Celsius value.
  prefs: []
  type: TYPE_NORMAL
- en: Property-based testing is just as hard as TDD. It is no magic bullet. Finding
    the right properties to assert is challenging, particularly if you aim to build
    them up in a test-driven style.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of testing does not replace TDD, but it is another tool in any TDD
    practitioner’s toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Snapshot testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a popular testing technique for React applications. React component
    trees are serialized to disk as a JSON string and then compared between test runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'React component trees are useful in a couple of important scenarios, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: When your team has a low level of experience with TDD and general program design
    and could become more confident with a safety net of snapshot testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you have zero test coverage of software that is already being used in production,
    and you would like to quickly gain some level of confidence before making any
    changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: QA teams are sometimes interested in how software changes visually between releases,
    but they will probably not want to write tests in your unit test suites; they’ll
    have their own specialized tool for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Snapshot testing is certainly a useful tool to know about, but be aware of
    the following issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Snapshots are not descriptive. They do not go beyond saying, “this component
    tree looks the same as it did before.” This means that if they break, it will
    not be immediately clear why they broke.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If snapshots are rendered at a high level in your component tree, they are brittle.
    Brittle tests break frequently and therefore take a lot of time to correct. Since
    the tests are at a high level, they do not pinpoint where the error is, so you’ll
    spend a lot of time hunting down failures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Snapshot tests can pass in two scenarios: first, when the component tree is
    the same as the previous version that was tested, and second, when no snapshot
    artifacts from the previous test run are found. This means that a green test does
    not give you full confidence – it could simply be green because previous artifacts
    are missing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When writing good tests (of any kind), you want the following to be true of
    any test failure that occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: It is very quick to ascertain whether the failure is due to an error or a change
    in specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of errors, it is very quick to pinpoint the problem and the location
    of the error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD is an established technique that the community has learned enough about
    to know how to write good tests. We aren’t quite there with snapshot testing.
    If you absolutely must employ snapshot testing in your code base, make sure that
    you measure how much value it is providing you and your team.
  prefs: []
  type: TYPE_NORMAL
- en: Canary testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Canary testing is when you release your software to a small proportion of your
    users and see what happens. It can be useful for web applications with a large
    user base. One version of canary testing involves sending each request to two
    systems: the live system and the system under test. Users only sense the live
    system but the test system results are recorded and analyzed by you. Differences
    in functionality and performance can then be observed, while your users are never
    subjected to test software.'
  prefs: []
  type: TYPE_NORMAL
- en: Canary testing is attractive because, on the surface, it seems very cost-effective,
    and also requires next to no *thinking* from the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike TDD, canary testing cannot help you with the design of your software,
    and it may take a while for you to get any feedback.
  prefs: []
  type: TYPE_NORMAL
- en: 'That completes our look at the automated testing landscape. We started this
    chapter by looking at manual testing techniques. Now, let’s round this chapter
    off with a final technique: not testing at all!'
  prefs: []
  type: TYPE_NORMAL
- en: Not testing at all
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a belief that TDD doesn’t apply to some scenarios in which it does
    – for example, if your code is throwaway or if it’s presumed to never need modification
    once it’s deployed. Believing this is almost ensuring the opposite is true. Code,
    particularly code without tests, has a habit of living on beyond its intended
    lifespan.
  prefs: []
  type: TYPE_NORMAL
- en: Fear of deleting code
  prefs: []
  type: TYPE_NORMAL
- en: In addition to reducing the fear of changing code, tests also reduce the fear
    of *removing* code. Without tests, you’ll read some code and think “maybe something
    uses this code for some purpose I don’t quite remember.” With tests in place,
    this won’t be a concern. You’ll read the test, see that the test no longer applies
    due to a changed requirement, and then delete the test and its corresponding production
    code.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are several scenarios in which not writing tests is acceptable.
    The two most important ones are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: When quality doesn’t matter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately, in many environments, quality doesn’t matter. Many of us can
    relate to this. We’ve worked for employers who actively disregard quality. These
    people make enough profit that they don’t *need* or *want* to care. Caring about
    quality is, unfortunately, a personal choice. If you are in a team that does not
    value quality, it will be hard to convince them that TDD is worthwhile.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re in this situation and you have a burning desire to use TDD, then you
    have a few options. First, you can spend time convincing your colleagues that
    it is a good idea. This is never an easy task. You could also play the TDD-by-stealth
    game, in which you don’t ask permission before you start. Failing these options,
    some programmers will be fortunate enough that they can take the risk of finding
    an alternative employer that *does* value quality.
  prefs: []
  type: TYPE_NORMAL
- en: Spiking and deleting code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spiking means coding without tests. We spike when we’re in uncharted territory.
    We need to find a workable approach to a problem we’ve never solved before, and
    there is likely to be a great deal of trial and error, along with a lot of backtracking.
    There is a high chance of finding *unworkable* approaches before a workable one.
    Writing tests doesn’t make much sense in this situation because many of the tests
    written along the way will ultimately end up being scrapped.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say, for example, that I’m building a web socket server and client, but
    it’s the first time I’ve used WebSockets. This would be a good candidate for spiking
    – I can safely explore the WebSocket API until I’m comfortable baking it into
    my application.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to stop spiking when you feel that you’ve hit on a workable approach.
    You don’t need a complete solution, just one that teaches you enough to set you
    off on the right path.
  prefs: []
  type: TYPE_NORMAL
- en: In the purist vision of TDD, spiking must be followed by deleting. If you’re
    going to spike, you must be comfortable with deleting your work. Unfortunately,
    that’s easier said than done; it’s hard to scrub out creative output. You must
    shake off the belief that your code is sacred. Be happy to chuck it away.
  prefs: []
  type: TYPE_NORMAL
- en: In the pragmatic vision of TDD, spiking can often be followed by writing tests
    around the spiked code. I use this technique all the time. If you’re new to TDD,
    it may be wise to avoid this particular cheat until you’re confident that you
    can think out a test sequence of required tests that will cover all the required
    functionality within spike code.
  prefs: []
  type: TYPE_NORMAL
- en: A purist may say that your spike code can include redundant code, and it may
    not be the simplest solution because tests will not have driven the implementation.
    There is some merit to this argument.
  prefs: []
  type: TYPE_NORMAL
- en: Spiking and test-last development
  prefs: []
  type: TYPE_NORMAL
- en: Spiking is related to the practice of **test last**, but there’s a subtle difference.
    Writing code around a spike is a TDD cheat in that you want your finished tests
    to look as if you used TDD in the first place. Anyone else coming along after
    you should never know that you cheated.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test last**, however, is a more loosely defined way of testing where you
    write all the production code and then write some unit tests that prove *some*
    of the more important use cases. Writing tests like this gives you some level
    of regression coverage but none of the other benefits of TDD.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Becoming a great practitioner of TDD takes great effort. It requires practice,
    experience, determination, and discipline.
  prefs: []
  type: TYPE_NORMAL
- en: Many people have tried TDD and failed. Some of them will conclude that TDD is
    broken. But I don’t believe it’s broken. It just takes effort and patience to
    get right.
  prefs: []
  type: TYPE_NORMAL
- en: But what is getting it right, anyway?
  prefs: []
  type: TYPE_NORMAL
- en: All software development techniques are subjective. Everything in this book
    is subjective; it is not the *right way*. It is a collection of techniques that
    I like to use, and that I have found success with. Other people have found success
    with other techniques.
  prefs: []
  type: TYPE_NORMAL
- en: The exciting part of TDD is not the black-and-white, strict form of the process;
    it is the grays in which we can define (and refine) a development process that
    works for us and our colleagues. The TDD cycle gives us *just enough* structure
    that we can find joy in fleshing it out with our rules and our own dogma.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you have found this book valuable and enjoyable. There are many, many
    ways to test-drive React applications and I hope that this is the launchpad for
    you to evolve your testing practice.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Useful Kata resources:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://codingdojo.org/kata/](http://codingdojo.org/kata/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://codekata.com](http://codekata.com)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://kata-log.rocks](http://kata-log.rocks)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/sandromancuso/Bank-kata](https://github.com/sandromancuso/Bank-kata)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.natpryce.com/articles/000807.xhtml](http://www.natpryce.com/articles/000807.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Global Day of Coderetreat: [https://www.coderetreat.org](https://www.coderetreat.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Getting Started with Debugging JavaScript in Chrome DevTools: [https://developers.google.com/web/tools/chrome-devtools/javascript/](https://developers.google.com/web/tools/chrome-devtools/javascript/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Property-based testing for JavaScript: [https://github.com/leebyron/testcheck-js](https://github.com/leebyron/testcheck-js)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
