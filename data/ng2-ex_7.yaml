- en: Chapter 7.  Testing Personal Trainer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。测试个人教练
- en: Unless you are a superhero who codes perfectly, you need to test what you build.
    Also, unless you have loads of free time to test your application again and again,
    you need some test automation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您是一个完美编码的超级英雄，否则您需要测试您构建的内容。此外，除非您有大量的空闲时间来一遍又一遍地测试您的应用程序，否则您需要一些测试自动化。
- en: When we say Angular was built with testability in mind, we really mean it. It
    has a strong **Dependency Injection** (**DI**) framework, some good mock constructs,
    and awesome tools that make testing in an Angular app a fruitful endeavor.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说Angular是考虑到可测试性而构建的，我们是真的。它有一个强大的**依赖注入**（**DI**）框架，一些很好的模拟构造，以及使在Angular应用程序中进行测试成为一项富有成效的工作的出色工具。
- en: This chapter is all about testing and is dedicated to testing what we have built
    over the course of this book. We test everything from components to pipes, services,
    and our app directives.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要讨论测试，并致力于测试我们在本书中构建的内容。我们测试从组件到管道、服务和应用程序指令的所有内容。
- en: 'The topics we cover in this chapter include:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括：
- en: '**Understanding the big picture**: We will try to understand how testing fits
    into the overall context of Angular app development. We will also discuss the
    types of testing Angular supports, including unit and **end-to-end** (**E2E**)
    testing.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解全局视角**：我们将尝试理解测试如何适应Angular应用程序开发的整体背景。我们还将讨论Angular支持的测试类型，包括单元测试和**端到端**（**E2E**）测试。'
- en: '**Overview of tools and frameworks**: We cover the tools and frameworks that
    help in both unit and end-to-end testing with Angular. These include **Karma**
    and **Protractor**.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具和框架概述**：我们涵盖了帮助在Angular中进行单元测试和端到端测试的工具和框架。这些包括**Karma**和**Protractor**。'
- en: '**Writing unit tests**: You will learn how to do unit testing with Angular
    using Jasmine and Karma inside a browser. We will unit-test what we have built
    in the last few chapters. This section also teaches us how to unit-test various
    Angular constructs, including pipes, components, services, and directives.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编写单元测试**：您将学习如何使用Jasmine和Karma在浏览器中进行单元测试。我们将对前几章中构建的内容进行单元测试。本节还教会我们如何对各种Angular构造进行单元测试，包括管道、组件、服务和指令。'
- en: '**Creating end-to-end tests**: Automated end-to-end tests work by mimicking
    the behavior of the actual user through browser automation. You will learn how
    to use Protractor combined with WebDriver to perform end-to-end testing.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建端到端测试**：自动化的端到端测试通过模拟浏览器自动化来模仿实际用户的行为。您将学习如何使用Protractor结合WebDriver执行端到端测试。'
- en: Let the testing begin!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让测试开始吧！
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The code for this chapter can be found at `checkpoint7.1`. It is available on
    GitHub ([https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample))
    for everyone to download. Checkpoints are implemented as branches in GitHub.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在`checkpoint7.1`找到。它可以在GitHub上（[https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample)）下载。检查点在GitHub中作为分支实现。
- en: 'If you are not using Git, download the snapshot of `checkpoint7.1` (a ZIP file)
    from this GitHub location: [https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不使用Git，请从此GitHub位置下载`checkpoint7.1`的快照（ZIP文件）：[https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip)。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: The need for automation
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化的需求
- en: The size and complexity of apps being built for the Web are growing with each
    passing day. The plethora of options that we now have to build web apps is just
    mind-boggling. Add to this the fact that the release cycles for products/apps
    have shrunk drastically from months to days, or even multiple releases per day!
    This puts a lot of burden on software testing. There is too much to be tested.
    Multiple browsers, multiple clients and screen sizes (desktop and mobile), multiple
    resolution, and so on.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着每一天过去，为Web构建的应用程序的规模和复杂性正在增长。我们现在有太多的选项来构建Web应用程序，这简直令人难以置信。再加上产品/应用程序的发布周期已经从几个月缩短到几天，甚至一天内发布多个版本！这给软件测试带来了很大的负担。有太多需要测试的内容。多个浏览器，多个客户端和屏幕尺寸（桌面和移动），多种分辨率等等。
- en: To be effective in such a diverse landscape, automation is the key. *Automate
    everything that can be automated* should be our mantra.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要在如此多样化的环境中发挥作用，自动化是关键。*应该自动化一切可以自动化*应该成为我们的口头禅。
- en: Testing in Angular
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Angular中的测试
- en: The Angular team realized the importance of testability and hence created a
    framework that allowed easy testing (automated) for apps built on it. The design
    choice of using DI constructs to inject dependencies everywhere helped. This will
    become clear as the chapter progresses and we build a number of tests for our
    apps. However, before that, let's understand the types of testing that we target
    when building apps on this platform.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Angular团队意识到了可测试性的重要性，因此创建了一个框架，允许在其上构建的应用程序进行轻松的（自动化）测试。使用DI构造进行依赖注入的设计选择有助于这一点。随着本章的进展，当我们为我们的应用程序构建大量测试时，这一点将变得清晰。然而，在此之前，让我们了解在构建此平台上的应用程序时，我们所针对的测试类型。
- en: Types of testing
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试类型
- en: 'There are broadly two forms of testing that we do for a typical Angular app:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于典型的Angular应用程序，我们进行了两种广义上的测试：
- en: '**Unit testing**: Unit testing is all about testing a component in isolation
    to verify the correctness of its behavior. Most of the dependencies of the component
    under test need to be replaced with mock implementations to make sure that the
    unit tests do not fail due to failure in a dependent component.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：单元测试完全是关于在孤立环境中测试组件，以验证其行为的正确性。需要用模拟实现替换被测试组件的大多数依赖项，以确保单元测试不会因为依赖组件的失败而失败。'
- en: '**End-to-end testing**: This type of testing is all about executing the application
    like a real end user and verifying the behavior of the application. Unlike unit
    testing, components are not tested in isolation. Tests are done against a running
    system in real browsers, and assertions are done based on the state of the user
    interface and the content displayed.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试**：这种类型的测试完全是关于像真正的最终用户一样执行应用程序，并验证应用程序的行为。与单元测试不同，组件不是孤立测试的。测试是针对在真实浏览器中运行的系统进行的，并且基于用户界面的状态和显示的内容进行断言。'
- en: Unit testing is the first line of defense against bugs, and we should be able
    to iron out most issues with code during unit testing. But unless E2E is done,
    we cannot confirm that the software is working correctly. Only when all the components
    within a system interact in the desired manner can we confirm that the software
    works; hence, E2E testing becomes a necessity.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是防止错误的第一道防线，我们应该能够在单元测试期间解决大部分问题。但除非进行了E2E测试，否则我们无法确认软件是否正常工作。只有当系统中的所有组件以期望的方式进行交互时，我们才能确认软件正常工作；因此，E2E测试成为必要。
- en: Who writes unit and E2E tests and when are they written are important questions
    to answer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 谁编写单元测试和E2E测试，以及它们何时编写，这些都是重要的问题需要回答。
- en: Testing - who does it and when?
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 - 谁进行测试以及何时进行测试？
- en: Traditionally, E2E testing was done by the **Quality Assurance** (**QA**) team
    and developers were responsible for unit-testing their code before submitting.
    Developers too did some amount of E2E testing but the overall the E2E testing
    process was manual.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，E2E测试是由质量保证（QA）团队进行的，开发人员负责在提交代码之前对其进行单元测试。开发人员也会进行一定量的E2E测试，但整个E2E测试过程是手动的。
- en: With the changing landscape, modern testing tools, especially on the web front,
    have allowed developers to write automated E2E tests themselves and execute them
    against any deployment setup (such as development/stage/production). Tools such
    as Selenium, together with WebDrivers, allow easy browser automation, thus making
    it easy to write and execute E2E tests against real web browsers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 随着技术环境的变化，现代测试工具，特别是在Web前端，已经允许开发人员自己编写自动化的E2E测试，并针对任何部署设置（如开发/阶段/生产）执行这些测试。像Selenium这样的工具，连同WebDrivers，可以轻松进行浏览器自动化，从而便于编写和执行针对真实网络浏览器的E2E测试。
- en: A good time to write E2E scenario tests is when the development is complete
    and ready to be deployed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 写E2E场景测试的好时机是在开发完成并准备部署时。
- en: When it comes to unit testing, there are different schools of thought around
    when a test should be written. A *TDDer* writes tests before the functionality
    is implemented. Others write tests when the implementation is complete to confirm
    the behavior. Some write while developing the component itself. Choose a style
    that suits you, keeping in mind that the earlier you write your tests, the better.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试方面，有不同的观点认为测试应该在何时编写。TDDer在功能实现之前编写测试。其他人在实现完成后编写测试以确认行为。有些人在开发组件本身时编写测试。选择适合自己的风格，记住你写测试的越早，越好。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are not going to give any recommendations, nor are we going to get into an
    argument over which one is better. Any amount of unit tests is better than nothing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算提出任何建议，也不打算就哪种更好进行争论。任何数量的单元测试都比没有好。
- en: Our personal preference is to use the *middle approach*. With TDD, we feel that
    the test creation effort at times is lost as the specifications/requirements change.
    Tests written at the start are prone to constant fixes as the requirement changes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们个人偏好使用“中间方法”。在TDD中，我们觉得测试创建的努力有时会因为规格/需求的变化而丧失。在开始时编写的测试容易因需求的变化而不断修复。
- en: The problem with writing unit tests at the end is that our target is to create
    tests that pass according to the current implementation. The tests that are written
    are retrofitted to test the implementation whereas they should test the specifications.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后编写单元测试的问题在于我们的目标是创建根据当前实现通过的测试。编写的测试是为了测试实现而不是规格。
- en: Adding tests somewhere in the middle works best for us.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间某个地方添加测试对我们来说效果最好。
- en: Let's now try to understand the tooling and technology landscape available for
    Angular testing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们试着了解可用于Angular测试的工具和技术环境。
- en: The Angular testing ecosystem
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular测试生态系统
- en: 'Look at the following diagram to understand the tools and frameworks that support
    Angular testing:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 看下面的图表以了解支持Angular测试的工具和框架：
- en: '![The Angular testing ecosystem](../Images/image00401.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![Angular测试生态系统](../Images/image00401.jpeg)'
- en: As we can see, we write our tests using unit testing libraries such as Jasmine
    or Mocha.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们使用Jasmine或Mocha等单元测试库编写我们的测试。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the moment, the Angular testing library works by default with Jasmine. However,
    the Angular team has indicated that they have made the framework more generic
    so that you can use other testing libraries such as Mocha with it. The Angular
    documentation has not yet been updated to include how to do this.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Angular 测试库默认使用 Jasmine。然而，Angular 团队表示他们已经将框架更加通用化，以便您可以使用其他测试库，比如 Mocha。Angular
    文档尚未更新以包括如何做到这一点。
- en: These tests are executed by either Karma or Protractor depending on whether
    we are writing unit or integration tests. These test runners in turn run our tests
    in a browser such as Chrome, Firefox, or IE, or headless browsers such as PhantomJS.
    It is important to highlight that not only E2E but also unit tests are executed
    in a real browser.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试由 Karma 或 Protractor 执行，具体取决于我们是在编写单元测试还是集成测试。这些测试运行器又会在浏览器中运行我们的测试，比如 Chrome、Firefox
    或 IE，或者无头浏览器，比如 PhantomJS。重要的是要强调的是，不仅 E2E 测试，单元测试也是在真实浏览器中执行的。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Except for browsers, the complete Angular testing setup is supported by the
    awesome libraries and framework made available through the **Node.js** ecosystem.
    Some libraries such as Jasmine have standalone versions too, but we will stick
    to Node.js packages.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了浏览器，完整的 Angular 测试设置是由 **Node.js** 生态系统提供的出色库和框架支持的。一些库，比如 Jasmine，也有独立版本，但我们将坚持使用
    Node.js 包。
- en: All the tests in this chapter are written using Jasmine (both unit and integration
    tests). Karma will be our test runner for unit tests and Protractor for E2E tests.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有测试都是使用 Jasmine 编写的（包括单元测试和集成测试）。Karma 将是我们的单元测试运行器，Protractor 将是我们的 E2E
    测试运行器。
- en: Getting started with unit testing
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始进行单元测试
- en: 'The ultimate aim of unit testing is to test a specific piece of code/component
    in isolation to make sure that the components work according to the specification.
    This reduces the chances of failures/bugs in the component when integrated with
    other parts of the software. Before we start writing tests, there are some guidelines
    that can help us write good and maintainable tests:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的最终目的是测试特定的代码/组件，以确保组件按照规范工作。这减少了与软件其他部分集成时组件出现故障/错误的机会。在我们开始编写测试之前，有一些指导方针可以帮助我们编写良好且易于维护的测试：
- en: One unit should test one behavior. For obvious reasons, testing one behavior
    per unit test makes sense. A failing unit test should clearly highlight the problem
    area. If multiple behaviors are tested together, a failed test requires more probing
    to assert what behavior was violated.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单元应该测试一个行为。出于显而易见的原因，每个单元测试一个行为是有意义的。失败的单元测试应该清楚地突出问题区域。如果多个行为一起测试，失败的测试需要更多的探究来确定违反了哪个行为。
- en: Dependencies in a unit test should be mocked away. Unit testing, as the name
    suggests, should test the unit and not its dependencies.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试中的依赖项应该被模拟掉。单元测试应该测试单元本身，而不是它的依赖项。
- en: Unit tests should not change the state of the component being tested permanently.
    If it does happen, other tests may get affected.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试不应该永久改变被测试组件的状态。如果发生这种情况，其他测试可能会受到影响。
- en: The order of execution of unit tests should be immaterial. One unit test should
    not be dependent on another unit test to execute before it. This is a sign of
    a brittle unit test. It may also mean that the dependencies are not mocked.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试的执行顺序应该是无关紧要的。一个单元测试不应该依赖于另一个单元测试在它之前执行。这是脆弱单元测试的迹象。这也可能意味着依赖项没有被模拟。
- en: Unit tests should be fast. If they are not fast enough, developers will not
    run them. This is a good reason to mock all dependencies such as database access,
    remote web service call, and others in a unit test.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试应该快速。如果它们不够快，开发人员就不会运行它们。这是模拟所有依赖项的一个很好的理由，比如数据库访问、远程网络服务调用等。
- en: 'Unit tests should try to cover all code paths. Code coverage is a metric that
    can help us assess the effectiveness of unit tests. If we have covered all positive
    and negative scenarios during testing, the coverage will indeed be higher. A word
    of caution here: high code coverage does not imply that the code is bug-free,
    but low coverage clearly highlights a lack of areas covered in unit tests.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试应该尝试覆盖所有代码路径。代码覆盖率是一个可以帮助我们评估单元测试效果的度量标准。如果在测试过程中覆盖了所有正面和负面情况，覆盖率确实会更高。这里需要注意：高代码覆盖率并不意味着代码是无错的，但低覆盖率明显突出了单元测试中未覆盖的区域。
- en: Unit tests should test both positive and negative scenarios. Just don't concentrate
    on positive test cases; all software can fail, and hence unit testing failure
    scenarios are as important to test as success scenarios.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试应该测试正面和负面情况。不要只集中在正面测试用例上；所有软件都可能出现故障，因此单元测试失败场景与成功场景一样重要。
- en: These guidelines are not framework-specific but give us enough ammunition for
    writing good tests. Let's begin the process of unit testing by setting up the
    components required for it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些准则并不特定于框架，但为我们提供了撰写良好测试所需的足够支持。让我们通过设置所需的组件开始单元测试的过程。
- en: Setting up Karma for unit testing
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为单元测试设置Karma
- en: Since the complete test automation infrastructure is supported using Node, this
    needs to be installed first. Follow the instructions on the Node website ([https://nodejs.org](https://nodejs.org))
    and get Node installed locally.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于完整的测试自动化基础设施是使用Node支持的，因此首先需要安装Node。请按照Node网站（[https://nodejs.org](https://nodejs.org)）上的说明进行安装。
- en: Node comes with a package manager called **Node Package Manager** (**NPM**)
    that is used to install all other components (**packages** in the Node world)
    required for testing.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Node自带一个名为**Node Package Manager**（**NPM**）的包管理器，用于安装测试所需的所有其他组件（Node世界中的**包**）。
- en: 'Start by installing Karma from the command line. Navigate to the root of your
    application code base (in the `trainer` folder) and install Karma using this command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行开始安装Karma。导航到应用程序代码库的根目录（在`trainer`文件夹中），并使用以下命令安装Karma：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To use Karma from the command line, we need to install its command-line interface:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要从命令行使用Karma，我们需要安装其命令行界面：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Karma version against which the code was tested is 0.13.22\. The **karma-cli**
    version was 1.0.1 .
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 代码被测试的Karma版本是0.13.22。**karma-cli**版本是1.0.1。
- en: To install a specific version of a package, suffix the package name with `@version`,
    for example, `npm install karma@0.13.22 --save-dev`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装特定版本的包，需要在包名后面加上`@version`，例如，`npm install karma@0.13.22 --save-dev`。
- en: 'This completes the Karma installation and it''s now time to configure the test
    runner. Configuring Karma is all about setting up its configuration file so that
    it contains enough details for it to run our scripts and test them. Create a `tests`
    folder in the root (in the `trainer` folder), navigate to it, and start the Karma
    configuration setup with the following command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了Karma的安装，现在是时候配置测试运行器了。配置Karma就是设置其配置文件，以便其中包含足够的细节来运行我们的脚本并对其进行测试。在根目录（在`trainer`文件夹中）创建一个`tests`文件夹，导航到该文件夹，并使用以下命令开始Karma配置设置：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This starts a command-line wizard that guides us through the options available,
    including the test framework, folders to watch, and other such settings. Once
    the wizard is complete, it generates a `karma.conf.js` file. Instead of using
    the generated configuration file, copy the `karma.conf.js` file from the companion
    code base at `checkpoint7.1/tests` to your local `tests` folder.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个命令行向导，指导我们选择可用的选项，包括测试框架、要监视的文件夹和其他设置。向导完成后，它会生成一个`karma.conf.js`文件。不要使用生成的配置文件，而是将伴随代码库中`checkpoint7.1/tests`的`karma.conf.js`文件复制到本地的`tests`文件夹中。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `karma init` wizard installs some packages based on our selection. If we
    skip the wizard, the `karma-chromelauncher` and `karma-jasmine` packages need
    to be installed manually for unit testing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`karma init`向导根据我们的选择安装了一些包。如果我们跳过向导，那么`karma-chromelauncher`和`karma-jasmine`包需要手动安装以进行单元测试。'
- en: 'Next, we will install Jasmine. So execute the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将安装Jasmine。因此执行以下命令：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Karma configuration files
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Karma配置文件
- en: Open `karma.conf.js` in the `tests` directory. It contains settings that affect
    the tests we run. We will not be covering each and every configuration supported
    by Karma here, but will focus on configurations that are unique and/or required
    for our test setup. Refer to the Karma documentation ([http://karma-runner.github.io/1.0/config/configuration-file.html](http://karma-runner.github.io/1.0/config/configuration-file.html))
    to understand more about the various Karma configuration options.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tests`目录中打开`karma.conf.js`。它包含影响我们运行的测试的设置。我们不会在这里涵盖Karma支持的每个配置，但会专注于对我们的测试设置是独特和/或必需的配置。请参考Karma文档（[http://karma-runner.github.io/1.0/config/configuration-file.html](http://karma-runner.github.io/1.0/config/configuration-file.html)）了解更多关于各种Karma配置选项的信息。
- en: 'First, we''ll need to set the base path for resolving file locations. In our
    case, because we have put Karma in a `tests` folder just below the root of the
    application, we will use a relative URL that will point to that location:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置解析文件位置的基本路径。在我们的情况下，因为我们将Karma放在了应用程序根目录下方的`tests`文件夹中，我们将使用一个相对URL来指向该位置：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We then set our framework to Jasmine:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将框架设置为Jasmine：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The next Karma configuration is the `files` array. Files can be referenced either
    by their file path or by using patterns. In our case, we are referencing the first
    ten files using file paths. These are the files for the polyfills, SystemJS and
    zone.js. When Karma first starts it will load all these files in the browser using
    a `<script>` tag.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个Karma配置是`files`数组。文件可以通过文件路径或使用模式引用。在我们的情况下，我们使用文件路径引用前十个文件。这些是用于polyfills、SystemJS和zone.js的文件。当Karma首次启动时，它将使用`<script>`标签在浏览器中加载所有这些文件。
- en: For the rest, we are using patterns because this approach allows us to set the
    `included` and `watched` properties. The `included` property determines whether
    Karma will initially load the file. If set to `true`, Karma will load these files
    in a `<script>` tag. If not, Karma will not load the file, so that some other
    mechanism must be found to do that. The `watched` property indicates whether a
    file will be watched for changes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其余部分，我们使用模式，因为这种方法允许我们设置`included`和`watched`属性。`included`属性确定Karma是否最初加载文件。如果设置为`true`，Karma将在`<script>`标签中加载这些文件。如果不是，Karma将不加载文件，因此必须找到其他机制来完成。`watched`属性指示文件是否将被监视以进行更改。
- en: As you look through the file patterns in our configuration, you will notice
    files you have seen before that are used for building our application such as
    RxJS, and Angular itself. We have set the `included` property for all but one
    of these files to `false`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当您查看我们配置中的文件模式时，您会注意到一些您以前见过的用于构建我们的应用程序的文件，例如RxJS和Angular本身。我们已将`included`属性设置为`false`，除了其中一个文件。
- en: 'The one file pattern where the `included` property has been set to `true` is
    one we have not seen before: `karma-test-shim.js`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`included`属性被设置为`true`的一个文件模式是我们以前没有见过的：`karma-test-shim.js`：'
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This pattern references an additional file that we have added to the testing
    folder to handle the special requirements for running Angular tests in Karma and
    it will be loaded by Karma when it first starts. We will discuss that file shortly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式引用了一个我们添加到测试文件夹中的额外文件，用于处理在Karma中运行Angular测试的特殊要求，并且在Karma首次启动时将被加载。我们将很快讨论该文件。
- en: The `watched` property in all our files (except for RxJS and the files that
    support debugging) is set to true, which means that Karma will watch these files
    and rerun our tests if any of them are changed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有文件中（除了RxJS和支持调试的文件）的`watched`属性都设置为true，这意味着Karma将监视这些文件，如果它们中的任何一个发生变化，将重新运行我们的测试。
- en: 'The next file pattern in the array after `karma-test-shim.js` is a little different
    from the rest:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在`karma-test-shim.js`之后数组中的下一个文件模式与其他文件有些不同：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This pattern contains a path to our application files (the code that we have
    been building throughout the earlier chapters), as well as a path to the test
    files we will create.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式包含了我们应用程序文件的路径（我们在前几章中一直在构建的代码），以及我们将创建的测试文件的路径。
- en: But note that it is pointing to the `dist` directory that holds the JavaScript
    files that have been generated by the TypeScript transpiler and not the TypeScript
    files themselves. This stands to reason because Karma, of course, is a JavaScript
    test runner (and will not itself transpile our TypeScript files). This in turn
    means we will need an initial transpilation step in order to get our tests running.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，它指向的是`dist`目录，该目录包含TypeScript转译器生成的JavaScript文件，而不是TypeScript文件本身。这是有道理的，因为Karma当然是一个JavaScript测试运行器（不会自己转译我们的TypeScript文件）。这反过来意味着我们需要一个初始的转译步骤来运行我们的测试。
- en: Getting back to the files where we have set the `included` property to false,
    how do we load them if we do not use Karma? As you know, we are using SystemJS
    to load our modules and Karma does not know anything about SystemJS. If Karma
    were to run our test files before the related modules are loaded, our tests would
    fail. This means that for these files, we need to run SystemJS and load our modules
    before Karma runs. Setting the `included` property to false means that Karma will
    not run these files automatically.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们将“included”属性设置为false的文件，如果我们不使用Karma，我们如何加载它们？正如你所知，我们正在使用SystemJS来加载我们的模块，而Karma对SystemJS一无所知。如果Karma在相关模块加载之前运行我们的测试文件，我们的测试将失败。这意味着对于这些文件，我们需要在Karma运行之前运行SystemJS并加载我们的模块。将“included”属性设置为false意味着Karma不会自动运行这些文件。
- en: But if the config file sets the `included` property for these files to `false`,
    how and when will we run the tests in these files? The answer to that question
    brings us to the Karma test shim file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果配置文件将这些文件的`included`属性设置为`false`，我们将如何运行这些文件中的测试？这个问题的答案将我们带到了Karma测试shim文件。
- en: The Karma test shim file
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Karma测试shim文件
- en: Open `karma-test-shim.js` in the `tests` directory. This file addresses the
    challenges of using Karma with Angular and SystemJS.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tests`目录中打开`karma-test-shim.js`。这个文件解决了使用Karma与Angular和SystemJS的挑战。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Karma test shim file currently uses the SystemJS loader but according to
    the Angular team it could be adapted for something else such as Web Pack.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Karma测试shim文件目前使用SystemJS加载器，但根据Angular团队的说法，它可以适应其他东西，比如Web Pack。
- en: The Karma test shim file does three things, which we'll discuss now.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Karma测试shim文件做了三件事，我们现在来讨论。
- en: 'First, it cancels Karma''s synchronous start:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它取消了Karma的同步启动。
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then it adds the configuration for SystemJS:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它添加了SystemJS的配置：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This should already be familiar. After all, we are already doing this kind of
    configuration for SystemJS in the `system.js.config` file in the root of our application.
    What this configuration does is set up the path mapping for the modules that will
    be used by Karma including the Angular testing modules. We have modified the file
    so that it points to the right locations in our application for this mapping.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该已经很熟悉了。毕竟，我们已经在应用程序根目录的`system.js.config`文件中为SystemJS进行了这种配置。这个配置的作用是设置Karma将使用的模块的路径映射，包括Angular测试模块。我们已经修改了文件，使其指向我们应用程序中这个映射的正确位置。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's important to understand that this configuration is for using SystemJS with
    our test runner and not for use with our underlying application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，这个配置是用于在测试运行器中使用SystemJS，而不是用于我们的基础应用程序。
- en: 'Finally, it uses SystemJS with a promise to import our modules. If the promise
    resolves successfully, it starts up Karma, and if not, throws an error:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它使用SystemJS来导入我们的模块。如果承诺成功解析，它将启动Karma，否则会抛出错误：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that we are importing `@angular/platform-browser-dynamic/testing` and passing
    parameters that are specific to testing browser-based applications to the `initTestEnvironment` method
    of `TestBed`. We will be discussing `TestBed` in detail later in this chapter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在导入`@angular/platform-browser-dynamic/testing`并将特定于测试基于浏览器的应用程序的参数传递给`TestBed`的`initTestEnvironment`方法。我们将在本章后面详细讨论`TestBed`。
- en: With this file in place, we are now ready to begin using Karma for Angular testing.
    While this configuration has been somewhat tedious, the good news is that once
    we have completed configuring Karma, Angular makes it easy to create and run unit
    tests, as we will see soon.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个文件，我们现在准备开始使用Karma进行Angular测试。虽然这个配置有点繁琐，但好消息是一旦我们完成了Karma的配置，Angular会很容易地创建和运行单元测试，我们很快就会看到。
- en: Organization and naming of our test files
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们测试文件的组织和命名
- en: To unit-test our app, the plan is to create one test (such as `workout-runner.spec.ts`)
    file for each TypeScript file that we have in our project.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对我们的应用进行单元测试，计划为项目中的每个TypeScript文件创建一个测试文件（例如`workout-runner.spec.ts`）。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Naming the test files with the name of the file under test plus `.spec` is a
    convention that is used by developers who test with Jasmine. It is also used to
    facilitate the mapping of files to tests in the configuration steps we outlined
    previously.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jasmine进行测试的开发人员通常将测试文件命名为被测试文件的名称加上`.spec`，这是一种惯例。这也用于在我们之前概述的配置步骤中方便地将文件映射到测试中。
- en: 'This test file will contain the unit test specification for the corresponding
    component, as shown in the following screenshot (taken in the Karma debugger when
    running our unit tests):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试文件将包含相应组件的单元测试规范，如下面的截图所示（在运行我们的单元测试时在Karma调试器中拍摄）：
- en: '![Organization and naming of our test files](../Images/image00402.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![我们测试文件的组织和命名](../Images/image00402.jpeg)'
- en: Unit-testing Angular applications
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试Angular应用程序
- en: Over the course of this book, we have built components that cover every construct
    available in Angular. We have built components, pipes, a few services, and finally
    some directives too. All of these are testable in unit tests.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的过程中，我们已经构建了覆盖Angular中的每个构造的组件。我们已经构建了组件、管道、一些服务，最后还有一些指令。所有这些都可以在单元测试中进行测试。
- en: 'Just to get the hang of unit testing with Jasmine, let''s test the smallest
    and easiest component first: the pipe.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了熟悉使用Jasmine进行单元测试，让我们先测试最小和最简单的组件：管道。
- en: Unit-testing pipes
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试管道
- en: Pipes are the easiest to test as they have minimum or zero dependencies on other
    constructs. The `SecondsToTimePipe` that we created for *Workout Runner* (the
    *7 Minute Workout* app) has no dependencies and can be easily unit-tested.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是最容易测试的，因为它们对其他构造的依赖最少或者没有依赖。我们为*Workout Runner*（*7 Minute Workout*应用程序）创建的`SecondsToTimePipe`没有依赖，可以很容易地进行单元测试。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Look at the Jasmine framework documentation to understand how to write unit
    tests using Jasmine. We are using Jasmine 2.0 for our unit tests ([http://jasmine.github.io/2.0/introduction.html](http://jasmine.github.io/2.0/introduction.html)).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Jasmine框架文档，了解如何使用Jasmine编写单元测试。我们在单元测试中使用Jasmine 2.0（[http://jasmine.github.io/2.0/introduction.html](http://jasmine.github.io/2.0/introduction.html)）。
- en: Jasmine has some of the best documentations available and the overall framework
    is very intuitive to use. We strongly recommend that you head over to the Jasmine
    site and get yourself familiar with the framework before you proceed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine有一些最好的文档，并且整体框架非常直观易用。我们强烈建议您前往Jasmine网站，并在继续之前熟悉该框架。
- en: 'Add a `seconds-to-time.pipe.spec.ts` file to the `trainer`/`src/components/shared`
    folder and add this unit test to it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`trainer`/`src/components/shared`文件夹中添加一个`seconds-to-time.pipe.spec.ts`文件，并将这个单元测试添加到其中：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's take a look at what we are doing here in our test file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们在测试文件中正在做什么。
- en: 'Not surprisingly, we import the `SecondsToTimePipe`, which we are going to
    test. This is just like the imports we have used elsewhere in our TypeScript classes.
    Notice that we use a relative path to the file in which it is located `''./seconds-to-time.pipe''`.
    In Angular, this means to look for the component to test in the same directory
    as the test itself. As you recall, this is the way we set up our file structure:
    putting our tests in the same directory as the file under test.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，我们导入了`SecondsToTimePipe`，这是我们将要测试的内容。这与我们在其他地方使用的TypeScript类中的导入方式一样。请注意，我们在文件中使用了相对路径来定位它的位置`'./seconds-to-time.pipe'`。在Angular中，这意味着在与测试本身相同的目录中查找要测试的组件。正如你记得的那样，这是我们设置文件结构的方式：将测试放在与要测试的文件相同的目录中。
- en: In the next line, we start using Jasmine syntax. First, we wrap the test in
    a `describe` function that identifies the test. The first parameter of this function
    is a user-friendly description of the test; in this case, it is the `SecondsToTime
    pipe`. For the second parameter, we pass a lambda (fat arrow) function that will
    contain our test. After setting up a local variable to hold the pipe, we call
    Jasmine's `beforeEach` function and use this to inject an instance of our pipe.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们开始使用Jasmine语法。首先，我们在`describe`函数中包装测试，以标识测试。这个函数的第一个参数是测试的用户友好描述；在这种情况下，它是`SecondsToTime
    pipe`。对于第二个参数，我们传递一个lambda（fat arrow）函数，它将包含我们的测试。在设置一个本地变量来保存管道之后，我们调用Jasmine的`beforeEach`函数，并使用它来注入我们的管道的一个实例。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since the `beforeEach` function runs before every test that is in our `describe` function,
    we can use it for common code that will run in each of our tests. In this case,
    it is not strictly necessary since there is only one test in our `describe` function.
    But it is a good idea to get into the habit of using it for common setup scenarios,
    as we will see going forward.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`beforeEach`函数在我们的`describe`函数中的每个测试之前运行，我们可以将其用于每个测试中运行的通用代码。在这种情况下，这并不是严格必要的，因为我们的`describe`函数中只有一个测试。但是，养成使用它进行常见设置场景的习惯是一个好主意，因为我们将会看到它在未来的使用中的好处。
- en: Next, we call Jasmine's `it` function and pass it a title, along with three
    calls to Jasmine's `expect` function (Jasmine's name for assertions). These are
    all self-explanatory.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用Jasmine的`it`函数，并传递一个标题，以及对Jasmine的`expect`函数的三次调用（Jasmine对断言的称呼）。这些都是不言自明的。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is not necessary to explicitly import these Jasmine functions in our test.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中，不需要显式导入这些Jasmine函数。
- en: Running our test files
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行我们的测试文件
- en: 'Now it''s time to run our tests using Karma. As you recall, in order to do
    that, we first have to transpile our files from TypeScript to JavaScript. To do
    this, we will simply start up our application itself in a terminal window by calling:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候使用Karma运行我们的测试了。正如你记得的那样，为了做到这一点，我们首先必须将我们的文件从TypeScript转译成JavaScript。为了做到这一点，我们将简单地在终端窗口中启动我们的应用程序本身，方法是调用：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The gulp file for the application will transpile our TypeScript files to JavaScript
    and then watch for changes in these files.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的gulp文件将把我们的TypeScript文件转译成JavaScript，然后监视这些文件的更改。
- en: 'Next, we need to run Karma and we do that by executing the following command
    in a separate terminal window in the `trainer` folder:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要运行Karma，我们通过在`trainer`文件夹中的一个单独的终端窗口中执行以下命令来实现：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We should then see this output in the terminal window:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们应该在终端窗口中看到这个输出：
- en: '![Running our test files](../Images/image00403.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![运行我们的测试文件](../Images/image00403.jpeg)'
- en: 'The last line shows that our test passed successfully. To make sure that it
    is reporting the correct pass/fail results, let''s make a change in the test to
    cause one of the expectations to fail. Change the time in the first expectation
    to 6 seconds rather than 5, like so:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行显示我们的测试成功通过了。为了确保它报告了正确的通过/失败结果，让我们在测试中做出改变，导致其中一个期望失败。将第一个期望中的时间更改为6秒，而不是5秒，如下所示：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We get the following error message:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下错误消息：
- en: '![Running our test files](../Images/image00404.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![运行我们的测试文件](../Images/image00404.jpeg)'
- en: What's nice about this error message is that it combines the `describe` and
    `it` descriptions into a complete sentence that provides a clear summary of the
    error. This shows how Jasmine allows us to write readable tests so that someone
    who is new to our code can quickly understand any problems that may arise in it.
    The next line shows us which expectation was not met, what was expected, and what
    the actual results were that did not meet this expectation.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误消息的好处在于它将`describe`和`it`的描述结合成一个完整的句子，提供了对错误的清晰摘要。这显示了Jasmine如何允许我们编写可读的测试，以便对我们的代码不熟悉的人可以快速理解可能出现的任何问题。下一行显示了哪个期望没有被满足，期望是什么，以及未满足这个期望的实际结果是什么。
- en: 'We also get a lengthy stack trace below this message and a final line that
    shows the overall results of our tests:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此消息下面还有一个冗长的堆栈跟踪，以及一个显示我们测试整体结果的最后一行：
- en: '![Running our test files](../Images/image00405.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![运行我们的测试文件](../Images/image00405.jpeg)'
- en: One thing you'll notice is that when we make the change to our test, we do not
    have to rerun Karma. Instead, it watches for any changes in our files and related
    tests and immediately reports success or failure whenever we make a change.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到的一件事是，当我们对测试进行更改时，我们不需要重新运行Karma。相反，它会监视我们文件和相关测试的任何更改，并在我们进行更改时立即报告成功或失败。
- en: Pretty cool! Let's undo the last change that we made and put the test back into
    a passing state.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 非常酷！让我们撤消我们所做的最后一次更改，并将测试恢复到通过状态。
- en: 'To sum up, we''ll be taking the following multi-step approach to executing
    all our tests. First, we use our gulp script to convert the TypeScript files to
    JavaScript. Then we call Karma to run our tests against those JavaScript files.
    The following diagram sets forth these steps:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们将采取以下多步骤方法来执行所有我们的测试。首先，我们使用我们的gulp脚本将TypeScript文件转换为JavaScript。然后我们调用Karma来针对这些JavaScript文件运行我们的测试。以下图表阐明了这些步骤：
- en: '![Running our test files](../Images/image00406.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![运行我们的测试文件](../Images/image00406.jpeg)'
- en: We will not be repeating the description of these steps in the tests we cover
    moving forward. So, be sure to follow them with every test we are exploring in
    this section. Now let's move on to unit-testing components.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会在我们覆盖的测试中重复这些步骤的描述。因此，请确保在我们在本节中探索的每个测试中都遵循这些步骤。现在让我们继续进行单元测试组件。
- en: Unit-testing components
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试组件
- en: Testing Angular components is more complicated than testing simple pipes or
    services. That is because Angular components are associated with views and also
    usually have more dependencies than services, filters, or directives.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 测试Angular组件比测试简单的管道或服务更复杂。这是因为Angular组件与视图相关联，通常比服务、过滤器或指令具有更多的依赖关系。
- en: Angular testing utilities
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Angular测试工具
- en: Because of their complexity, Angular has introduced utilities that enable us
    to test our components more easily. These testing utilities include the `TestBed`
    class (which we previously used to initialize our tests) and several helper functions
    in `@angular/core/testing`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其复杂性，Angular引入了一些工具，使我们能够更轻松地测试我们的组件。这些测试工具包括`TestBed`类（我们之前用来初始化测试）和`@angular/core/testing`中的几个辅助函数。
- en: '`TestBed` has a `createComponent` method that returns a `ComponentFixture`
    containing several members and methods, including:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestBed`有一个`createComponent`方法，返回一个包含多个成员和方法的`ComponentFixture`。'
- en: '`debugElement`: For debugging a component'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debugElement`：用于调试组件'
- en: '`componentInstance`: For accessing the component properties and methods'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentInstance`：用于访问组件的属性和方法'
- en: '`nativeElement`: For accessing the view''s markup and other DOM elements'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nativeElement`：用于访问视图的标记和其他DOM元素'
- en: '`detectChanges`: For triggering the component''s change detection cycle'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detectChanges`：用于触发组件的变化检测周期'
- en: '`ComnponentFixture` also contains methods for overriding the view, directives,
    bindings, and providers of a component. Going forward, we will be using `TestBed`
    throughout the rest of our tests.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComnponentFixture`还包含用于覆盖组件的视图、指令、绑定和提供者的方法。在接下来的测试中，我们将在整个测试过程中使用`TestBed`。'
- en: '`TestBed` has a method called `configureTestingModule` that we can use to set
    up our testing as its own module. This means we can bypass the initial bootstrap
    process and compile our components under test within out test files. We can also
    use `TestBed` to specify additional dependencies and identify the providers that
    we will need.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestBed`有一个名为`configureTestingModule`的方法，我们可以使用它来设置我们的测试作为自己的模块。这意味着我们可以绕过初始的引导过程，并在我们的测试文件中编译我们要测试的组件。我们还可以使用`TestBed`来指定额外的依赖关系，并确定我们将需要的提供者。'
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: According to the Angular documentation, `TestBed` has a base state that is reset
    before each spec file runs. This base state includes *the declarables (components,
    directives, and pipes) and providers (some of them mocked)* that almost every
    component needs to run. See [https://angular.io/docs/ts/latest/guide/testing.html#!#atu-intro](http://bit.ly/2eufBGN).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Angular文档，`TestBed`在每个规范文件运行之前都会重置基本状态。这个基本状态包括*可声明的内容（组件、指令和管道）和提供者（其中一些是模拟的）*，几乎每个组件都需要运行。参见[https://angular.io/docs/ts/latest/guide/testing.html#!#atu-intro](http://bit.ly/2eufBGN)。
- en: Managing dependencies in our tests
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在我们的测试中管理依赖关系
- en: Components in Angular integrate the view with everything else. Due to this,
    components normally have more dependencies compared to any of the services, filters,
    or directives.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Angular中的组件将视图与其他所有内容集成在一起。因此，与任何服务、过滤器或指令相比，组件通常具有更多的依赖关系。
- en: Notwithstanding the fact that our unit tests focus on the code within the component
    itself, we still need to account for these dependencies in our tests or else the
    tests will fail (we skipped the dependency setup for pipe testing as it did not
    have external dependencies).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的单元测试侧重于组件本身的代码，但我们仍需要在测试中考虑这些依赖关系，否则测试将失败（我们跳过了管道测试的依赖设置，因为它没有外部依赖）。
- en: 'Two approaches exist for handling these dependencies: inject them into our
    component or create a mock or fake for them that we can use in our tests. If a
    dependency is simple enough, we can just inject an instance of it into our test
    class. However, if the dependency is significantly complicated, especially if
    it has dependencies of its own and/or makes remote server calls, then we should
    be mocking it. The Angular testing library provides the tools for us to do that.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这些依赖项存在两种方法：将它们注入到我们的组件中，或者为它们创建一个我们可以在测试中使用的模拟或伪造品。如果一个依赖项足够简单，我们可以将其实例直接注入到我们的测试类中。然而，如果依赖项非常复杂，特别是如果它有自己的依赖项和/或进行远程服务器调用，那么我们应该对其进行模拟。Angular测试库为我们提供了这样做的工具。
- en: The component that we plan to test in this section is the `WorkoutRunner` component.
    Located inside `trainer/src/components/workout-runner/`, this is the component
    that runs a specific workout.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划在本节中测试的组件是`WorkoutRunner`组件。位于`trainer/src/components/workout-runner/`内，这是运行特定锻炼的组件。
- en: Unit-testing WorkoutRunnerComponent
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试WorkoutRunnerComponent
- en: With this background, let's get started unit testing `WorkoutRunnerComponent`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个背景，让我们开始单元测试`WorkoutRunnerComponent`。
- en: 'First, add a new file, `workout-runner-component.spec.ts`, with the following
    imports:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加一个新文件`workout-runner-component.spec.ts`，其中包含以下导入：
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These imports identify the test utilities (and things such as `Router` and `Observable`
    from `RxJS)` that we will be using in our tests along with the types and dependencies
    our component requires. We'll discuss these dependencies in a moment. One import
    that looks different from the others is the one that imports `NO_ERRORS_SCHEMA`
    from `@angular/core`. We will use this import to ignore elements in the component
    that we will not be testing. Again, we will discuss that further in a moment.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这些导入标识了我们在测试中将使用的测试工具（以及来自`RxJS`的`Router`和`Observable`等内容），以及我们组件所需的类型和依赖项。我们将在一会儿讨论这些依赖关系。一个与其他不同的导入是从`@angular/core`导入`NO_ERRORS_SCHEMA`的导入。我们将使用这个导入来忽略我们不会测试的组件中的元素。同样，我们将在一会儿进一步讨论这一点。
- en: One more thing to note with the imports is that `@angular/core/testing` is a
    part of the core module and not in a separate testing module. This is a common
    pattern with imports for Angular testing. For example, when we get to testing
    HTTP, you will see that we are importing from `@angular/http/testing`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的是，导入中的`@angular/core/testing`是核心模块的一部分，而不是单独的测试模块。这是Angular测试导入的常见模式。例如，当我们开始测试HTTP时，您将看到我们从`@angular/http/testing`导入。
- en: Setting up component dependencies
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置组件依赖项
- en: 'Next, we need to establish our component''s dependencies and determine whether
    we need to inject or mock them. If we look at the code for the `WorkoutRunner`
    component, we see that there are three dependencies being injected into our component:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要建立组件的依赖关系，并确定我们是否需要注入或模拟它们。如果我们查看`WorkoutRunner`组件的代码，我们会发现有三个依赖项被注入到我们的组件中：
- en: '`WorkoutHistoryTracker`: This is a component that has some behavior attached
    to it. So we definitely want to mock it.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WorkoutHistoryTracker`：这是一个附有一些行为的组件。因此，我们肯定希望对其进行模拟。'
- en: '`Router`: We''ll have to mock this too in order to isolate `WorkoutRunner`
    from the rest of the application and prevent our test from trying to navigate
    away from the `WorkoutRunner` view.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Router`：我们也必须模拟这个，以便将`WorkoutRunner`与应用程序的其余部分隔离开，并防止我们的测试尝试从`WorkoutRunner`视图中导航离开。'
- en: '`WorkoutService:` This is a service that we will use to make an HTTP call to
    retrieve our workouts. We will mock this service as well since we don''t want
    to be making a call to an external system within our test.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WorkoutService：`这是一个我们将使用来进行HTTP调用以检索我们的锻炼的服务。我们也将模拟这个服务，因为我们不希望在我们的测试中对外部系统进行调用。'
- en: Mocking dependencies - workout history tracker
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟依赖 - workout history tracker
- en: 'Angular allows us to mock our dependencies in a straightforward manner using
    simple classes. Let''s start with mocking `WorkoutHistoryTracker`. To do that,
    add the following class just after the imports:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Angular允许我们使用简单的类以直接的方式模拟我们的依赖关系。让我们从模拟`WorkoutHistoryTracker`开始。为此，请在导入之后添加以下类：
- en: '[PRE16]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We do not need to mock the entire `WorkoutHistoryTracker` class but only the
    methods that `WorkoutRunner` will be calling. In this case, those methods are
    `startTracking()`, `endTracking()`, and `exerciseComplete()`. We have made these
    methods empty because we do not need anything returned from them in order to test
    `WorkoutRunner`. Now we can inject this dummy implementation into `WorkoutRunner` wherever
    it is looking for `WorkoutHistoryTracker`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要模拟整个`WorkoutHistoryTracker`类，而只需要模拟`WorkoutRunner`将要调用的方法。在这种情况下，这些方法是`startTracking()`，`endTracking()`和`exerciseComplete()`。我们将这些方法设置为空，因为我们不需要从中返回任何东西来测试`WorkoutRunner`。现在我们可以将这个虚拟实现注入到`WorkoutRunner`中，无论它在哪里寻找`WorkoutHistoryTracker`。
- en: Mocking dependencies - workout service
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟依赖 - workout service
- en: 'In [Chapter 5](part0056.xhtml#aid-1LCVG2 "Chapter 5.  Supporting Server Data
    Persistence"), *Supporting Server Data Persistence*, we extended the workout service
    to make a remote call to retrieve the data that populates a workout. For unit-testing
    the workout runner, we will want to replace that call with a mock implementation
    that returns some static data that we can use to run the test. So we will add
    a third mock class, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](part0056.xhtml#aid-1LCVG2 "Chapter 5.  Supporting Server Data Persistence")中，*支持服务器数据持久性*，我们扩展了workout
    service以进行远程调用以检索填充workout的数据。对于单元测试workout runner，我们将希望用返回一些静态数据的模拟实现来替换该调用，以便我们可以用来运行测试。因此，我们将添加第三个模拟类，如下所示：
- en: '[PRE17]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that the `getWorkout` method is returning an `Observable`. Otherwise
    the class is self-explanatory.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`getWorkout`方法返回一个`Observable`。否则，该类是不言自明的。
- en: Mocking dependencies - router
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟依赖 - router
- en: As with `WorkoutHistoryTracker` and `WorkoutService,` we also will be using
    mocking to handle the dependency that we have on the Angular router. But here
    we will be taking a slightly different approach. We will assign a jasmine spy
    to a navigate method on our mock. This will be sufficient for our purposes because
    we only want to make sure that the router's navigate method is being called with
    the appropriate route (`finished`) as a parameter. The jasmine spy will allow
    us to do that as we will see later.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与`WorkoutHistoryTracker`和`WorkoutService`一样，我们也将使用模拟来处理我们对Angular路由器的依赖。但是在这里，我们将采取稍微不同的方法。我们将在我们的模拟上分配一个jasmine
    spy给一个navigate方法。这对我们来说已经足够了，因为我们只想确保路由器的navigate方法被调用时带有适当的路由（`finished`）作为参数。后面我们将看到，jasmine
    spy将允许我们做到这一点。
- en: Configuring our test using TestBed
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用TestBed配置我们的测试
- en: 'Now that we have our imports and dependencies out of the way, let''s get started
    with the tests themselves. We begin by adding a Jasmine `Describe` function that
    will wrap our tests, followed by setting two local variable using `let`: one for
    `fixture` and the other for `runner`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了导入和依赖关系，让我们开始测试本身。我们首先添加一个Jasmine `Describe`函数来包装我们的测试，然后使用`let`设置两个本地变量：一个用于`fixture`，另一个用于`runner`：
- en: '[PRE18]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next we''ll add a `beforeEach` function that sets up our test configuration:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个`beforeEach`函数来设置我们的测试配置：
- en: '[PRE19]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `beforeEach` method executes before each test, which means that we will
    only have to set this up once in our test file. Inside `beforeEach`, we add an
    `async` call. This is required because of the asynchronous `compileComponents`
    method we are calling.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforeEach`方法在每个测试之前执行，这意味着我们只需要在测试文件中设置一次。在`beforeEach`中，我们添加一个`async`调用。这是必需的，因为我们正在调用异步的`compileComponents`方法。'
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Angular documentation indicates that the `async` function *arranges for
    the tester's code to run in a special `async` test zone that hides the mechanics
    of asynchronous execution, just as it does when passed to an `it` test*. For more
    information refer to [https://angular.io/docs/ts/latest/guide/testing.html#!#async-in-before-each](http://bit.ly/2etY1me).
    We'll discuss this in more detail shortly.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Angular文档指出，`async`函数*安排测试者的代码在一个特殊的`async`测试区域中运行，隐藏了异步执行的机制，就像在传递给`it`测试时一样*。有关更多信息，请参阅[https://angular.io/docs/ts/latest/guide/testing.html#!#async-in-before-each](http://bit.ly/2etY1me)。我们很快会更详细地讨论这个问题。
- en: Let's go through each method call in the order they are executed. The first
    method, `configureTestingModule`, allows us to build on the base configuration
    of the testing module and add things such as imports, declarations (of the components,
    directives, and pipes we will be using in our test), and providers. In the case
    of our test, we are first adding declarations for the workout runner, our component
    under test, and the `SecondsToTimePipe:`
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照它们执行的顺序逐个讨论每个方法调用。第一个方法`configureTestingModule`允许我们在测试模块的基本配置上构建，并添加诸如导入、声明（我们将在测试中使用的组件、指令和管道）和提供者等内容。在我们的测试中，我们首先添加了workout
    runner，我们的组件，和`SecondsToTimePipe`的声明。
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Then we add three providers for our `Router`, `WorkoutHistoryTracker,` and `WorkoutService:`
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们为我们的`Router`、`WorkoutHistoryTracker`和`WorkoutService`添加了三个提供者：
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For each of these providers, we set the `useClass` property to our mocks instead
    of the actual components. Now, anywhere in our test, when the `WorkoutRunner`
    requires any of these components, the mock will be used instead.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些提供者中的每一个，我们将`useClass`属性设置为我们的模拟，而不是实际的组件。现在，在我们的测试中的任何地方，当`WorkoutRunner`需要这些组件中的任何一个时，将使用模拟。
- en: 'The next configuration may seem a bit mysterious:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个配置可能看起来有点神秘：
- en: '[PRE22]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This setting allows us to bypass the errors we would otherwise get regarding
    the custom elements associated with two components that we are using in the component's
    template: `ExerciseDescriptionComponent` and `VideoPlayerComponent`. At this point,
    we don't want to be testing these components within the test for the `WorkoutRunnerComponent`.
    Instead, we should be testing them separately. One thing to be aware of, however,
    when you use this setting is that it will suppress all schema errors related to
    elements and attributes in the template of the component under test; so it may
    hide other errors that you do want to see.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置允许我们绕过我们在组件模板中使用的两个组件`ExerciseDescriptionComponent`和`VideoPlayerComponent`相关的自定义元素的错误。在这一点上，我们不想在`WorkoutRunnerComponent`的测试中测试这些组件。相反，我们应该分开测试它们。然而，当您使用这个设置时，需要注意的一点是，它将抑制与被测试组件模板中的元素和属性相关的所有模式错误；因此它可能会隐藏您想要看到的其他错误。
- en: When you set up a test using `NO_ERRORS_SCHEMA`, you are creating what is called
    a shallow test, one that does not go deeper than the component you are testing.
    Shallow tests allow you to reduce complexities in the templates within the component
    you are testing and reduce the need for mocking dependencies.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`NO_ERRORS_SCHEMA`设置测试时，您创建了所谓的浅层测试，即不深入到您正在测试的组件之外。浅层测试允许您减少在您正在测试的组件中的模板中的复杂性，并减少对模拟依赖的需求。
- en: 'The final steps in the configuration of our test are to compile and instantiate
    our components:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试配置的最后一步是编译和实例化我们的组件：
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As mentioned previously, we are using an `async` function in our `beforeEach`
    method because this is required when we call the `compileComponents` method. This
    method call is asynchronous and we need to use it here because our component has
    an external template that is specified in a `templateUrl`. This method compiles
    that external template and then inlines it so that it can be used by the `createComponent`
    method (which is synchronous) to create our component fixture. This component
    fixture in turn contains a `componentInstance`-`WorkoutRunner`. We then assign
    both the `fixture` and the `componentInstance` to local variables.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们在`beforeEach`方法中使用了`async`函数，因为当我们调用`compileComponents`方法时，这是必需的。这个方法调用是异步的，我们需要在这里使用它，因为我们的组件有一个在`templateUrl`中指定的外部模板。这个方法编译了外部模板，然后内联它，以便它可以被`createComponent`方法（同步的）使用来创建我们的组件fixture。这个组件fixture反过来包含了一个`componentInstance`-`WorkoutRunner`。然后我们将`fixture`和`componentInstance`都分配给本地变量。
- en: As mentioned previously, the `async` function we are using creates a special
    `async` test zone in which our tests will run. You'll notice that this function
    is simplified from normal `async` programming and lets us do things such as using
    the `.then` operator without returning a promise.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们正在使用的`async`函数创建了一个特殊的`async`测试区域，在这个区域中我们的测试将运行。您会注意到，这个函数与普通的`async`编程相比更简化，让我们可以做一些事情，比如使用`.then`操作符而不返回一个promise。
- en: Note
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can also compile and instantiate test components inside individual test
    methods. But the `beforeEach` method allows us to do it once for all our tests.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在单独的测试方法中编译和实例化测试组件。但是`beforeEach`方法允许我们为所有测试只做一次。
- en: Now that we have configured our test, let's move on to unit-testing `WorkoutRunner`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了我们的测试，让我们继续对`WorkoutRunner`进行单元测试。
- en: Starting unit testing
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始单元测试
- en: Starting from the loading of workout data to transitioning of exercises, pausing
    workouts, and running exercise videos, there are number of aspects of the `WorkoutRunner`
    that we can test. The `workout.spec.ts` file (available in the `components/workout-runner`
    folder under `trainer/src`) contains a number of unit tests that cover the preceding
    scenarios. We will pick up some of those tests and work through them.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 从加载锻炼数据到转换锻炼，暂停锻炼，运行锻炼视频，`WorkoutRunner`有许多方面可以测试。`workout.spec.ts`文件（位于`trainer/src`下的`components/workout-runner`文件夹中）包含了许多单元测试，涵盖了前述情景。我们将挑选其中一些测试并逐个进行。
- en: 'To start with, let''s add a test case that verifies that the workout starts
    running once the component is loaded:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加一个测试用例，验证一旦组件加载，锻炼就开始运行。
- en: '[PRE24]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This test asserts that the total duration of the workout is correct and the
    workout is in the running state (that is, not paused).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试断言了锻炼的总持续时间是正确的，并且锻炼处于运行状态（即未暂停）。
- en: Assuming that the `autoWatch` property of `karma.conf.js` is true, saving this
    test automatically triggers the test execution. But this test fails (check the
    Karma console). Strange! All the dependencies have been set up correctly but still
    the second expect function of the `it` block fails as it is undefined.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`karma.conf.js`文件中的`autoWatch`属性为true，保存这个测试会自动触发测试执行。但是这个测试失败了（查看Karma控制台）。奇怪！所有依赖项都已正确设置，但`it`块的第二个expect函数失败了，因为它是未定义的。
- en: We need to debug this test.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要调试这个测试。
- en: Debugging unit tests in Karma
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Karma中调试单元测试
- en: Debugging unit tests in Karma is easy as the tests are run in the browser. We
    debug tests as we debug the standard JavaScript code. And since our Karma configuration
    has added mappings from our TypeScript files to our JavaScript files, we can debug
    directly in TypeScript.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在Karma中调试单元测试很容易，因为测试是在浏览器中运行的。我们调试测试就像调试标准的JavaScript代码一样。而且由于我们的Karma配置已经将TypeScript文件映射到JavaScript文件，我们可以直接在TypeScript中调试。
- en: When Karma starts, it opens a specific browser window to run the tests. To debug
    any test in Karma, we just need to click on the **Debug** button available at
    the top of the browser window.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Karma启动时，它会打开一个特定的浏览器窗口来运行测试。要在Karma中调试任何测试，我们只需要点击浏览器窗口顶部的**调试**按钮。
- en: Note
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is one window opened by Karma and one when we click on **Debug**; we can
    use the original window too for testing, but the original window is connected
    to Karma and does a live reload. Also, the script files in the original window
    are timestamped, which changes whenever we update the test and hence requires
    us to put in a breakpoint again to test.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Karma打开了一个窗口，当我们点击**调试**时会打开另一个窗口；我们也可以使用原始窗口进行测试，但原始窗口连接到Karma并进行实时重新加载。此外，原始窗口中的脚本文件是有时间戳的，每当我们更新测试时时间戳都会改变，因此需要再次设置断点进行测试。
- en: Once we click on **Debug**, a new tab/window opens with all the tests and other
    app scripts loaded for testing. These are scripts that were defined during the
    Karma configuration setup in the `karma.conf.js` files section.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们点击**调试**，一个新的标签/窗口将打开，加载了所有测试和其他应用程序脚本进行测试。这些脚本是在`karma.conf.js`文件部分的Karma配置设置期间定义的。
- en: To debug the preceding failure, we need to add breakpoints at two locations.
    One should be added inside the test itself and the second one inside `Workoutcomponent`,
    where it loads the workout and assigns the data to the appropriate local variables.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试前面的失败，我们需要在两个位置添加断点。一个应该在测试本身内部添加，另一个应该在`Workoutcomponent`内部添加，在那里它加载了锻炼并将数据分配给适当的本地变量。
- en: 'Perform the following steps to add a breakpoint in Google Chrome:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤在Google Chrome中添加断点：
- en: Open the Karma debug window/tab by clicking on the **Debug** button on the window
    loaded by Karma when it started.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击Karma启动时加载的窗口上的**调试**按钮打开Karma调试窗口/标签。
- en: Press the **F12** key to open the developer console.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下**F12**键打开开发者控制台。
- en: Go to the **Sources** tab and the TypeScript files for your application will
    be located in the `source` folder.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**Sources**标签，您的应用程序的TypeScript文件将位于`source`文件夹中。
- en: We can now put breakpoints at the required locations just by clicking on the
    line number. This is the standard mechanism to debug any script. Add breakpoints
    at the locations highlighted here:![Debugging unit tests in Karma](../Images/image00407.jpeg)
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以通过点击行号在需要的位置设置断点。这是调试任何脚本的标准机制。在这里突出显示的位置添加断点：![在Karma中调试单元测试](../Images/image00407.jpeg)
- en: We refresh the **Debug** page (the one we opened when we clicked on the **Debug**
    button). The breakpoint in `workout-runner.ts` is never hit, causing the test
    to fail.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新**调试**页面（我们点击**调试**按钮时打开的页面）。`workout-runner.ts`中的断点从未被触发，导致测试失败。
- en: 'What we overlooked is that the code that we were trying to reach is within
    the `start` method of `workout-runner`, and the `start` method is not being called
    in the constructor. Instead it is called in `ngDoCheck` after the data for the
    workout has been loaded through a call to the `getWorkout` method in `ngOnInit`.
    Add calls to `ngOnInit` and `ngDoCheck` in your test, like so:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忽视的是，我们试图到达的代码位于`workout-runner`的`start`方法中，并且`start`方法不是在构造函数中被调用的。相反，它是在`ngOnInit`中通过对`getWorkout`方法的调用加载锻炼数据后在`ngDoCheck`中被调用的。在测试中添加对`ngOnInit`和`ngDoCheck`的调用，如下所示：
- en: '[PRE25]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Save the change and Karma will run the test again. This time it will pass.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更改，Karma将再次运行测试。这次测试将通过。
- en: Note
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As the number of tests grows, unit testing may require us to concentrate on
    a specific test or a specific suite of tests. Karma allows us to target one or
    more tests by prepending `f` to the existing `it` block; that is, `it` becomes
    `fit`. If Karma finds tests with `fit`, it only executes those tests. Similarly,
    a specific test suite can be targeted by prepending `f` to the existing `describe`
    block: `fdescribe`. Also, if you prepend `x` to an `it` block, making it `xit`,
    then that block will be skipped.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 随着测试数量的增加，单元测试可能需要我们集中精力进行特定的测试或一组特定的测试。Karma允许我们通过在现有的`it`块前加上`f`来针对一个或多个测试；也就是说，`it`变成了`fit`。如果Karma找到带有`fit`的测试，它只会执行这些测试。同样，可以通过在现有的`describe`块前加上`f`来针对特定的测试套件：`fdescribe`。此外，如果你在`it`块前加上`x`，使其成为`xit`，那么该块将被跳过。
- en: Let's continue unit-testing the component!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续对组件进行单元测试！
- en: Unit-testing WorkoutRunner continued...
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试WorkoutRunner继续...
- en: 'What other interesting things can we test? We can test whether the first exercise
    has started. We add this test to `workout.spec.ts` after the one we just added:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以测试什么其他有趣的事情？我们可以测试第一个练习是否已经开始。我们将这个测试添加到`workout.spec.ts`中，放在我们刚刚添加的测试之后：
- en: '[PRE26]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The second `expect` function in this test is interesting. It uses a Jasmine
    feature: spies. Spies can be used to verify method invocations and dependencies.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试中的第二个`expect`函数很有趣。它使用了Jasmine的一个特性：间谍。间谍可以用来验证方法的调用和依赖关系。
- en: Using Jasmine spies to verify method invocations
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Jasmine间谍来验证方法调用
- en: A spy is an object that intercepts every call to the function it is spying on.
    Once the call is intercepted, it can either return fixed data or pass the call
    to the actual function being invoked. It also records the call invocation details
    that can be used later in `expect` as we did in the preceding test.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍是一个拦截对其进行监听的函数的每次调用的对象。一旦调用被拦截，它可以返回固定的数据，或者将调用传递给实际被调用的函数。它还记录了调用的细节，可以在后面的`expect`中使用，就像我们在前面的测试中所做的那样。
- en: Note
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Spies are very powerful and can be used in a number of ways during unit testing.
    Look at the documentation on spies at [http://jasmine.github.io/2.0/introduction.html#section-Spies](http://jasmine.github.io/2.0/introduction.html#section-Spies)
    to learn more about them.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍非常强大，在单元测试期间可以以多种方式使用。查看关于间谍的文档以了解更多信息：[http://jasmine.github.io/2.0/introduction.html#section-Spies](http://jasmine.github.io/2.0/introduction.html#section-Spies)。
- en: The second `expect` function verifies that the `startExercise` method was called
    when the workout started (`toHaveBeenCalledWith`). It is also asserting the correctness
    of the parameters passed to the function. The second `expect` statement asserts
    the behavior using a spy, but we first need to set up the spy to make this assert
    work.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`expect`函数验证了在锻炼开始时是否调用了`startExercise`方法（`toHaveBeenCalledWith`）。它还断言了传递给函数的参数的正确性。第二个`expect`语句使用了间谍来断言行为，但我们首先需要设置间谍才能使这个断言生效。
- en: In this case, we are using the spy to mock a call to the `startExercise` method.
    We can use the spy to determine whether the method has been called and with what
    parameters, using Jasmine's `toHaveBeenCalledWith` function.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用间谍来模拟对`startExercise`方法的调用。我们可以使用间谍来确定方法是否已被调用，以及使用Jasmine的`toHaveBeenCalledWith`函数来确定使用了哪些参数。
- en: Note
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Look at the Jasmine documentation for the `toHaveBeenCalled` and `toHaveBeenCalledWith`
    functions to learn more about these assert functions.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Jasmine文档中的`toHaveBeenCalled`和`toHaveBeenCalledWith`函数，以了解更多关于这些断言函数的信息。
- en: Here, the method is being called with the current `Exercise` as a parameter.
    Since the previous `expect` confirms that this is the first exercise, this `expect`
    confirms that a call to start that first exercise was executed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，该方法被调用时带有当前的`Exercise`作为参数。由于前面的`expect`确认了这是第一个练习，这个`expect`确认了对第一个练习的调用已经执行。
- en: There are a couple of things to note here. First, you have to be careful to
    put the setup for `spyOn` prior to calling `ngOnInit`. Otherwise, the spy will
    not be *spying* when the `startExercise` method is called and the method invocation
    will not be captured.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几点需要注意。首先，您必须小心在调用`ngOnInit`之前设置`spyOn`的设置。否则，当调用`startExercise`方法时，间谍将不会*监听*，并且方法调用将不会被捕获。
- en: Second, since the spy is a mock, we will normally not be able to verify anything
    within the `startExercise` method. This is because the method itself is being
    mocked. This means that we cannot actually verify that the `currentExercise` property
    has been set, since that is being done inside the mocked method. However, Jasmine
    allows us to chain the spy with .`and.callThrough`, which will mean that in addition
    to tracking the calls to the method, it will delegate to the actual implementation.
    This then allows us to test that the `currentExercise` has also been set correctly
    inside the `startExercise` method.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，由于间谍是一个模拟，我们通常无法验证`startExercise`方法内部的任何内容。这是因为方法本身被模拟了。这意味着我们实际上无法验证`currentExercise`属性是否已经设置，因为这是在模拟方法内部完成的。然而，Jasmine允许我们将间谍与`.and.callThrough`链接，这意味着除了跟踪方法的调用之外，它还将委托给实际的实现。这样我们就可以测试`startExercise`方法内部`currentExercise`是否也已经被正确设置。
- en: Using Jasmine spies to verify dependencies
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Jasmine间谍来验证依赖项
- en: While we just used a spy to verify the call to a method within our class, Jasmine
    spies are also useful in mocking calls to external dependencies. But why test
    calls to our external dependencies at all? After all, we are trying to limit our
    testing to the component itself!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们刚刚使用了一个间谍来验证类内部方法的调用，但Jasmine间谍在模拟对外部依赖项的调用时也很有用。但为什么要测试对外部依赖项的调用呢？毕竟，我们试图将我们的测试限制在组件本身！
- en: The answer is that we mock a dependency to make sure that the dependency does
    not adversely affect the component under test. From a unit testing perspective,
    we still need to make sure that these dependencies are called by the component
    being tested at the right time with the correct input. In the Jasmine world, spies
    help us assert whether dependencies were invoked correctly.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，我们模拟一个依赖项，以确保该依赖项不会对正在测试的组件产生不利影响。从单元测试的角度来看，我们仍然需要确保这些依赖项在正确的时间以及正确的输入下被被测试的组件调用。在Jasmine世界中，间谍帮助我们断言依赖项是否被正确调用。
- en: If we look at the `WorkoutRunner` implementation, we emit a message with the
    details of the workout whenever the workout starts. An external dependency, `WorkoutHistoryTracker`,
    subscribes to this message/event. So let's create a spy and confirm that `WorkoutHistoryTracker`
    started when the workout started.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下`WorkoutRunner`的实现，我们会在锻炼开始时发出包含锻炼详情的消息。一个外部依赖项`WorkoutHistoryTracker`订阅了这个消息/事件。所以让我们创建一个间谍并确认`WorkoutHistoryTracker`在锻炼开始时启动了。
- en: 'Add this `it` block after the preceding one:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`it`块之后添加这个`it`块：
- en: '[PRE27]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Within the `it` block, we add a spy on the `tracker`, a local instance of the
    `WorkoutHistoryTracker`. Then we use the spy to verify that the `startTracking`
    method of that dependency has been called. Simple and expressive!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在`it`块内，我们在`tracker`上添加了一个`WorkoutHistoryTracker`的本地实例的间谍。然后我们使用这个间谍来验证该依赖项的`startTracking`方法是否被调用。简单而富有表现力！
- en: You may recall that we are using `MockHistoryWorkoutTracker` here; it contains
    a mock, a `startTracking` method that is empty and returns nothing. That is fine
    because we are not testing the `WorkoutHistoryTracker` itself but just the method
    invocation on it being made by the `WorkoutRunner`. This test shows how useful
    it is to be able to combine mocks with spies to fully test the inner workings
    of the `WorkoutRunner`, separately and apart from its dependencies.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得我们在这里使用`MockHistoryWorkoutTracker`；它包含一个空的`startTracking`方法，不返回任何内容。这没关系，因为我们不是在测试`WorkoutHistoryTracker`本身，而只是测试`WorkoutRunner`对其进行的方法调用。这个测试展示了能够将模拟与间谍结合起来，以完全测试`WorkoutRunner`内部工作的有用性，与其依赖项分开测试。
- en: Testing event emitters
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试事件发射器
- en: 'Examining the code for the `WorkoutRunner`, we see that it sets up several
    event emitters that look like the following one for `workoutStarted`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`WorkoutRunner`的代码，我们看到它设置了几个事件发射器，看起来像`workoutStarted`的以下一个：
- en: '[PRE28]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The Angular documentation describes an event emitter as *an output property
    that fires events to which we can subscribe with an event binding*. In [Chapter
    2](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3 "Chapter 2.  Building
    Our First App - 7 Minute Workout"), *Building Our First App - 7 Minute Workout*,
    we described in detail how event emitters are used in WorkoutRunner. So we have
    a good understanding of what they do. But how do we unit-test our event emitters
    and determine that they are firing events in the way we expect?
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Angular文档将事件发射器描述为*一个输出属性，触发我们可以使用事件绑定订阅的事件*。在[第2章](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3
    "第2章。构建我们的第一个应用程序-7分钟锻炼")*构建我们的第一个应用程序-7分钟锻炼*中，我们详细描述了事件发射器在WorkoutRunner中的使用。因此，我们对它们的作用有很好的理解。但是我们如何对我们的事件发射器进行单元测试，并确定它们是否按我们的预期触发事件呢？
- en: 'It''s actually pretty easy to do. If we remember that an event emitter is an
    `Observable Subject` to which we can subscribe, we realize that we can simply
    subscribe to it in our unit test. Let''s revisit our test that verifies that a
    workout is starting and add the highlighted code to it:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上做起来相当容易。如果我们记得事件发射器是一个`Observable Subject`，我们可以订阅它，我们意识到我们可以在我们的单元测试中简单地订阅它。让我们重新审视一下我们的测试，验证锻炼是否开始，并向其中添加突出显示的代码：
- en: '[PRE29]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We injected the `WorkoutService` and added a subscription to the `WorkoutStarted`
    event emitter and an expectation that checks to see whether the property is emitting
    a `WorkoutPlan` when the event is triggered. The subscription is placed before
    `ngOnInit` because that is the method that results in the `workoutStarted` event
    being triggered, and we need to have our subscription in place before that happens.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注入了`WorkoutService`并向`WorkoutStarted`事件发射器添加了一个订阅，并添加了一个期望，检查在触发事件时该属性是否发出`WorkoutPlan`。订阅放在`ngOnInit`之前，因为那是导致`workoutStarted`事件被触发的方法，我们需要在那之前放置我们的订阅。
- en: Testing interval and timeout implementations
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试间隔和超时的实现
- en: One of the interesting challenges for us is to verify that the workout progresses
    as time elapses. The `Workout` component uses `setInterval` to move things forward
    with time. How can we simulate time without actually waiting?
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，一个有趣的挑战是验证锻炼随着时间的流逝而进行。`Workout`组件使用`setInterval`来随着时间推移推进事物。我们如何在不实际等待的情况下模拟时间呢？
- en: The answer is the Angular testing library's `fakeAsync` function, which allows
    us to run otherwise asynchronous code synchronously. It does this by wrapping
    the function to be executed in a `fakeAsync` zone. It then supports using synchronous
    timers within that zone and also allows us to simulate the asynchronous passage
    of time with `tick()`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是Angular测试库的`fakeAsync`函数，它允许我们将本来是异步的代码以同步的方式运行。它通过将要执行的函数包装在`fakeAsync`区域中来实现这一点。然后支持在该区域内使用同步定时器，并且还允许我们使用`tick()`来模拟时间的异步流逝。
- en: Note
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about `fakeAsync`, see the Angular documentation at [https://angular.io/docs/ts/latest/guide/testing.html#!#async](http://bit.ly/2eFYf7g),
    under the heading *The fakeAsync function*.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`fakeAsync`的更多信息，请参阅Angular文档[https://angular.io/docs/ts/latest/guide/testing.html#!#async](http://bit.ly/2eFYf7g)，标题为*fakeAsync函数*。
- en: 'Let''s see how we can use the `fakeAsync` function to test the timeout and
    interval implementations in our code. Add the following test to `workout-runner.spec.ts`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`fakeAsync`函数来测试代码中的超时和间隔实现。将以下测试添加到`workout-runner.spec.ts`中：
- en: '[PRE30]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In addition to injecting `WorkoutRunner`, we first wrap the test in `fakeAsync`.
    Then we add a call to the `WorkoutRunner`'s `ngOnit()` method. This kicks off
    the timers for the exercises within `WorkoutRunner`. Then within the test, we
    use the `tick()` function set at various durations to test the operation of the
    timer for an exercise, and make sure that it continues running for the duration
    that we expected it to run. Using `tick()` allows us to *fast forward* through
    the code and avoid having to wait for the exercise to complete over several seconds
    as it would if we ran the code asynchronously.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 除了注入`WorkoutRunner`之外，我们首先在`fakeAsync`中包装测试。然后我们调用`WorkoutRunner`的`ngOnit()`方法。这会启动`WorkoutRunner`中的练习计时器。然后在测试中，我们使用`tick()`函数在不同的持续时间内测试计时器的运行情况，并确保它在我们预期的持续时间内继续运行。使用`tick()`允许我们*快进*代码，避免异步运行代码时需要等待几秒钟才能完成练习。
- en: Note
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You'll notice that there is a helper method, `advanceWorkout`, being used here.
    This takes care of an anomaly that seemed to exist if the parameter passed to
    tick was anything other than `1000`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这里使用了一个辅助方法`advanceWorkout`。这个方法处理了一个异常，即如果传递给tick的参数不是`1000`，似乎会出现异常。
- en: At the end, we call the `WorkoutRunner`'s `ngOnDestroy()` method to clear any
    pending timers.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`WorkoutRunner`的`ngOnDestroy()`方法来清除任何未决的计时器。
- en: 'Let''s try another similar test. We want to make sure that the WorkoutRunner
    is correctly transitioning from one exercise to the next. Add the following test
    to `workout-runner.ts`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试另一个类似的测试。我们要确保`WorkoutRunner`能够正确地从一个练习过渡到下一个。将以下测试添加到`workout-runner.ts`中：
- en: '[PRE31]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Again we wrap the test in `fakeAsync` and call `runner.ngOnInit` to start the
    timer. Then we grab the duration of the first exercise and use the `tick()` function
    to advance the timer 1 second beyond the duration of that exercise. Next, we test
    the expectation that we are now in the rest exercise and thus have transitioned
    from the first exercise.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 再次在`fakeAsync`中包装测试，并调用`runner.ngOnInit`来启动计时器。然后我们获取第一个练习的持续时间，并使用`tick()`函数将计时器提前1秒超过该练习的持续时间。接下来，我们测试我们现在处于休息练习中的期望，因此已经从第一个练习过渡过来。
- en: Testing workout pause and resume
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试练习暂停和恢复
- en: 'When we pause a workout, it should stop and the time counter should not lapse.
    To check this, add the following time test:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们暂停练习时，它应该停止，时间计数器不应该流逝。为了检查这一点，添加以下时间测试：
- en: '[PRE32]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The test starts with verifying the state of the workout as not paused, advances
    the time for 1 second, pauses it, and then verifies that the time of `workoutTimeRemaining`
    does not change after the pause.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 测试从验证工作状态不是暂停开始，时间提前1秒，暂停，然后验证暂停后`workoutTimeRemaining`的时间没有改变。
- en: Unit-testing services
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试服务
- en: Unit testing of services is not much different from unit-testing components.
    Once we get the hang of how to set up a component and its dependencies (mostly
    using mocks), it becomes a routine affair to apply that learning to testing services.
    More often than not, the challenge is to set up the dependencies for the services
    so that testing can be done effectively.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的单元测试与组件的单元测试并没有太大的不同。一旦我们掌握了如何设置组件及其依赖项（主要是使用模拟对象），将这种学习应用到测试服务就成了例行公事。往往，挑战在于设置服务的依赖项，以便有效地进行测试。
- en: Things are a little different for services that make remote requests (using
    either `http` or `jsonp`). There is some setup required before we can test such
    services in isolation.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对于进行远程请求的服务（使用`http`或`jsonp`），情况有些不同。在我们可以单独测试这些服务之前，需要进行一些设置。
- en: We will target `WorkoutService` and write some unit tests for it. Since this
    service makes remote requests to load workout data, we will explore how to test
    such a service with a mock HTTP backend. Angular provides us with a `MockBackend`
    and `MockConnection` for doing that.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将针对`WorkoutService`编写一些单元测试。由于这个服务会进行远程请求来加载锻炼数据，我们将探讨如何使用模拟HTTP后端来测试这样的服务。Angular为我们提供了`MockBackend`和`MockConnection`来实现这一点。
- en: Mocking HTTP request/response with MockBackend
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用MockBackend模拟HTTP请求/响应
- en: 'When testing services (or, as a matter of fact, any other Angular construct)
    that make remote requests, we obviously do not want to make actual requests to
    a backend to check the behavior. That does not even qualify for a unit test. The
    backend interaction just needs to be mocked away. Angular provides a service for
    precisely that: `MockBackend`! Using `MockBackend`, we intercept HTTP requests,
    mock actual responses from the server, and assert endpoints invocation too.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试服务（或者实际上是任何其他Angular构造）进行远程请求时，显然我们不希望实际向后端发出请求来检查行为。那甚至都不符合单元测试的资格。后端交互只需要被模拟掉。Angular提供了一个专门用于此目的的服务：`MockBackend`！使用`MockBackend`，我们拦截HTTP请求，模拟来自服务器的实际响应，并断言端点的调用。
- en: 'Create a new file named `workout-service.spec.ts` and add the following import
    statements at the top of the file:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`workout-service.spec.ts`的新文件，并在文件顶部添加以下导入语句：
- en: '[PRE33]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In addition to the imports from the `testing` module, we are importing both
    the `http` module and the `MockBackend` and `MockConnection` from the `http/testing` module.
    We are also importing the `WorkoutService` and `WorkoutPlan` that we will be testing.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从`testing`模块导入的内容，我们还从`http`模块和`http/testing`模块中导入了`MockBackend`和`MockConnection`。我们还导入了将要进行测试的`WorkoutService`和`WorkoutPlan`。
- en: 'Once we have the imports in place, we will begin creating the test with the
    Jasmine `describe` statement that wraps our tests, and will set several local
    variables:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们导入就位，我们将开始使用Jasmine的`describe`语句创建测试，同时设置几个本地变量：
- en: '[PRE34]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In addition to creating local variables for `WorkoutService` and `MockBackend`,
    you'll also notice that we are setting local variables for our Mongo connection.
    To be clear, we are not setting these variables in order to make a remote call
    to Mongo but instead to test that the connection properties are being set properly.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为`WorkoutService`和`MockBackend`创建本地变量之外，您还会注意到我们为Mongo连接设置了本地变量。需要明确的是，我们设置这些变量不是为了对Mongo进行远程调用，而是为了测试连接属性是否被正确设置。
- en: 'The next step is set up the providers and dependency injection for our tests.
    To handle the providers, add the following to the test file:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为我们的测试设置提供者和依赖注入。要处理提供者，请在测试文件中添加以下内容：
- en: '[PRE35]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Not surprisingly, we are adding `MockBackEnd` and `WorkoutService` as providers.
    At the same time, we are also adding `BaseRequestOptions` from the http module.
    And then we are adding a provider for HTTP that uses a factory with the `MockEnd`
    and `BaseRequestOptions`. This factory will then return an `Http` service that
    is using the `MockBackend`. So now we can make an HTTP call from our tests that
    will not be a remote call, but instead will use the `MockBackEnd` to fake that
    call.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，我们正在添加`MockBackEnd`和`WorkoutService`作为提供者。与此同时，我们还从http模块中添加了`BaseRequestOptions`。然后我们添加了一个使用`MockEnd`和`BaseRequestOptions`的工厂的HTTP提供者。这个工厂将返回一个使用`MockBackend`的`Http`服务。因此，现在我们可以从我们的测试中发出一个HTTP调用，而不是远程调用，而是使用`MockBackEnd`来模拟这个调用。
- en: 'To complete the setup for our tests, we add the following to inject dependencies
    into each of our tests:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们测试的设置，我们添加以下内容来为每个测试注入依赖项：
- en: '[PRE36]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With this setup in place, we are now in a position to create tests for the
    workout-service that avoid our making a remote call. We''ll start with a simple
    test that makes sure that the `workoutService` loads:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们现在可以为workout-service创建测试，避免进行远程调用。我们将从一个简单的测试开始，确保`workoutService`加载：
- en: '[PRE37]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: While this test may seem trivial, it is important to place it here because it
    acts as a check to make sure that we have set up our configuration correctly.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个测试看起来可能微不足道，但将其放在这里很重要，因为它作为一个检查，确保我们已经正确设置了配置。
- en: 'Next, we''ll move to testing several of the methods in the workout-service.
    First, we will make sure that it returns all workouts when the get Workouts method
    is called. To do that, add the following test:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将测试workout-service中的几种方法。首先，我们将确保在调用get Workouts方法时返回所有的锻炼。为此，添加以下测试：
- en: '[PRE38]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice that we are using `fakeAsync` to synchronously run what would otherwise
    be an asynchronous HTTP call.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在使用`fakeAsync`来同步运行本来应该是异步HTTP调用的代码。
- en: Note
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that there would be a problem with this approach if we were making a true
    HTTP call using XHR. See [https://github.com/angular/angular/issues/8280](https://github.com/angular/angular/issues/8280).
    But here, we are not making a real XHR call in our mock.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们使用XHR进行真正的HTTP调用，这种方法可能会有问题。请参阅[https://github.com/angular/angular/issues/8280](https://github.com/angular/angular/issues/8280)。但在这里，我们并没有在我们的模拟中进行真正的XHR调用。
- en: Because the `Http` module returns `RxJS` observables, we are also using the
    pattern of subscribing to those observables. You should be used to seeing this
    pattern from our coverage of observables in [Chapter 5](part0056.xhtml#aid-1LCVG2
    "Chapter 5.  Supporting Server Data Persistence"), *Supporting Server Data Persistence*.
    Specifically, we are subscribing to the `connections` property of the `mockBackEnd` and
    passing in a `MockConnection` as our connection. After confirming that our connection
    has been set properly, we construct a `response` containing two `workouts`. Then
    we call the `mockRespond` method on our `connection` and return the `response`
    that we have constructed. The net result is that we have been able to construct
    a testable response for our service that avoids making a remote call.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Http`模块返回`RxJS`可观察对象，我们还使用了订阅这些可观察对象的模式。你应该已经习惯从我们对可观察对象的覆盖中看到这种模式了[第5章](part0056.xhtml#aid-1LCVG2
    "第5章。支持服务器数据持久性")，*支持服务器数据持久性*。具体来说，我们正在订阅`mockBackEnd`的`connections`属性，并将`MockConnection`作为我们的连接传入。在确认我们的连接已经正确设置之后，我们构造一个包含两个`workouts`的`response`。然后我们在我们的`connection`上调用`mockRespond`方法，并返回我们构造的`response`。最终结果是，我们已经能够为我们的服务构造一个可测试的响应，避免进行远程调用。
- en: The final step in the process is to set the workout's `getWorkouts` method to
    subscribe to that `response`, and then add the appropriate `expect` statements
    to confirm that we are getting back the correct number of `workouts` in the `response`
    and that the first `workout` is of type `WorkoutPlan`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程的最后一步是将workout的`getWorkouts`方法设置为订阅该`response`，然后添加适当的`expect`语句来确认我们在`response`中获取到了正确数量的`workouts`，并且第一个`workout`的类型是`WorkoutPlan`。
- en: 'We''ll follow the same pattern of using `fakeAsync` with our `mockBackend`
    to build additional tests that confirm that we are able to do the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循相同的模式，使用`fakeAsync`和我们的`mockBackend`来构建额外的测试，以确认我们能够做到以下事情：
- en: Return a `workout` plan with a specific name
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回具有特定名称的`workout`计划
- en: Map `exercises` correctly within the `getWorkout` method
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`getWorkout`方法中正确映射`exercises`
- en: 'You can review these tests in the code for checkpoint 7.1\. But one thing to
    note is that in both these tests we have the following conditional logic within
    the `connections.subscribe` method:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在检查点7.1的代码中查看这些测试。但需要注意的一点是，在这两个测试中，我们在`connections.subscribe`方法中有以下条件逻辑：
- en: '[PRE39]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This may seem a little confusing at first until we realize that with the `getWorkout`
    method we are actually making two `Http` calls: one to retrieve  `workout` and
    one to retrieve all  `exercises`. As you recall from [Chapter 5](part0056.xhtml#aid-1LCVG2
    "Chapter 5.  Supporting Server Data Persistence"), *Supporting Server Data Persistence*,
    we are doing that in order to create a fuller description of each `exercise` that
    is included within  `workout`. So what we are doing here is checking to make sure
    that we construct a `response` made up of a `workout` for the call that is retrieving
    a `workout` and a `response` made up of an `exercise` for the other call.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这一开始可能有点令人困惑，直到我们意识到，通过`getWorkout`方法，我们实际上进行了两次`Http`调用：一次是检索`workout`，一次是检索所有`exercises`。正如您从[第5章](part0056.xhtml#aid-1LCVG2
    "第5章。支持服务器数据持久性")中回忆的那样，我们这样做是为了创建包含在`workout`中的每个`exercise`的更完整描述。因此，我们在这里所做的是检查我们是否构建了一个由`workout`组成的`response`，用于检索`workout`的调用，以及由`exercise`组成的`response`，用于其他调用。
- en: With that, we are finished with testing our service.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经完成了对服务的测试。
- en: Next, we need to learn how to test directives. The next section is dedicated
    to understanding the challenges in directive testing and how to overcome them.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要学习如何测试指令。下一节将专门讨论指令测试中的挑战以及如何克服这些挑战。
- en: Unit-testing directives
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指令的单元测试
- en: No other Angular constructs that we have tested so far do not involve any UI
    interaction. But directives, as we know, are a different beast. Directives are
    all about enhancing a component's view and extending the behavior of HTML elements.
    While testing directives, we cannot ignore the UI connections, and hence directive
    testing may not strictly qualify as unit testing.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们测试过的其他Angular构造都不涉及任何UI交互。但是，众所周知，指令是一种不同的东西。指令主要是增强组件的视图并扩展HTML元素的行为。在测试指令时，我们不能忽略UI连接，因此指令测试可能并不严格符合单元测试的标准。
- en: 'The good thing about directive testing is that its setup process is not as
    elaborate as that for services or components. The pattern to follow while unit-testing
    directives is as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 指令测试的好处在于其设置过程不像服务或组件那样复杂。在单元测试指令时要遵循的模式如下：
- en: Take an HTML fragment containing the directive markup.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取包含指令标记的HTML片段。
- en: Compile and link it to a mock component.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并链接到一个模拟组件。
- en: Verify that the generated HTML has the required attributes.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证生成的HTML是否具有所需的属性。
- en: Verify the changes if the directive created changes the state.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证指令创建的更改是否改变了状态。
- en: The TestBed class
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TestBed类
- en: As mentioned previously, Angular provides the `TestBed` class to facilitate
    this kind of UI testing. We can use it to dig into the markup in a component's
    view and check for DOM changes that are triggered by events. Armed with this tool,
    let's get started with the testing of our directives. In this section, we are
    going to test `remoteValidator`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Angular提供了`TestBed`类来方便这种UI测试。我们可以使用它来深入到组件视图中的标记，并检查由事件触发的DOM更改。有了这个工具，让我们开始测试我们的指令。在本节中，我们将测试`remoteValidator`。
- en: Note
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This will be a good time to revisit the directives that we built in the previous
    chapter. Also, keep the code handy for the tests we will create in the following
    sections.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是重新审视我们在上一章中构建的指令的好时机。同时，保持代码方便，以便在接下来的章节中创建测试。
- en: Testing remote validator
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试远程验证器
- en: Let's start with unit-testing the `remoteValidatorDirective`. Just to refresh
    our memory, `remoteValidatorDirective` validates an input against remote rules.
    It does so by calling a component method that returns a promise. If the promise
    is resolved with success, the validation passes; otherwise, the validation fails.
    The `[validateFunction]` attribute provides the link between the DOM and the component's
    method that checks for the duplication.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始对`remoteValidatorDirective`进行单元测试。为了刷新我们的记忆，`remoteValidatorDirective`用远程规则验证输入。它通过调用返回一个promise的组件方法来实现。如果promise解析为成功，验证通过；否则，验证失败。`[validateFunction]`属性提供了DOM和检查重复的组件方法之间的链接。
- en: Similar to our other test files, we add a `remote-validator.directive.spec.ts`
    file in the workout builder folder. Refer to the file in checkpoint 7.1 for the
    imports, which we will not cover at this point.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们其他的测试文件类似，我们在健身教练构建器文件夹中添加了一个`remote-validator.directive.spec.ts`文件。请参考第7.1检查点中的文件进行导入，这一点我们暂时不会涉及。
- en: 'Just below the import statements, add the following component definition:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入语句的下面，添加以下组件定义：
- en: '[PRE40]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This component looks a lot like the components we set up in our other tests
    to mock dependencies. Here, however, it is serving a slightly different purpose;
    it is acting as a host container for the directive that we will be testing. Using
    this minimal component, lets us avoid having to load the actual host for this
    directive, which is the `Workout` component.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件看起来很像我们在其他测试中设置的组件来模拟依赖关系。然而，在这里，它的作用略有不同；它充当了我们将要测试的指令的宿主容器。使用这个最小的组件，让我们避免加载这个指令的实际宿主，即`Workout`组件。
- en: One thing to notice here is that we have set up a method for `validateWorkoutName`
    that will be called by our directive. It is essentially a stub that just returns
    a resolved `Promise` of `false`. Remember we are not concerned with how this method
    handles its validation but with verifying that the directive calls it and returns
    the correct result, either `true` or `false`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，我们已经为`validateWorkoutName`设置了一个方法，该方法将被我们的指令调用。它本质上是一个存根，只返回一个解析为`false`的`Promise`。请记住，我们不关心这个方法如何处理其验证，而是验证指令是否调用它并返回正确的结果，即`true`或`false`。
- en: 'Next, we set up the describe statement for our test suite by adding the following
    code, which injects  `RemoteValidatorDirective` into our tests:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过添加以下代码来设置我们测试套件的描述语句，将`RemoteValidatorDirective`注入到我们的测试中：
- en: '[PRE41]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, we are setting up local variables for  `fixture`, its `componentInstance`,
    and `debugElement`. We are also using `by.css` (which we will see more of in our
    end-to-end tests) along with the query method on  `debugElement` to extract the
    `workoutName` input from our component. We'll be using these to delve into the
    rendered HTML in our directive.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们正在为`fixture`、它的`componentInstance`和`debugElement`设置本地变量。我们还使用了`by.css`（我们将在端到端测试中看到更多）以及`debugElement`上的查询方法来提取我们组件中的`workoutName`输入。我们将使用这些来深入研究我们指令中呈现的HTML。
- en: 'Now we are ready to write our individual tests. First, we''ll write a test
    to confirm that we have been able to load  `RemoteValidatorDirective`. So add
    the following code:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备编写我们的单独测试。首先，我们将编写一个测试来确认我们已经能够加载`RemoteValidatorDirective`。因此添加以下代码：
- en: '[PRE42]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'What''s interesting about this test is that using the `debugElement`, we have
    been able to drill-down into the attributes of the input tag in our host component
    and find our validator, confirming that it has indeed been loaded. Also notice
    the use of `fakeAsync`, which we discussed in connection with unit testing. Using
    it makes it possible for us to write our tests in a synchronous fashion and avoid
    the complications that would otherwise exist with trying to manage the asynchronous
    rendering of our host component. Next, we''ll write two tests to confirm that
    our validator is working properly. The first test will make sure that an error
    is created if remote validation fails (that is, a workout with the same name as
    the one we are using is found). Add the following code for that test:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的有趣之处在于，使用`debugElement`，我们已经能够深入到我们宿主组件的输入标签的属性中，并找到我们的验证器，确认它确实已被加载。还要注意到我们讨论过的`fakeAsync`的使用，它使我们能够以同步的方式编写我们的测试，并避免在尝试管理宿主组件的异步渲染时可能存在的复杂性。接下来，我们将编写两个测试来确认我们的验证器是否正常工作。第一个测试将确保如果远程验证失败（即找到与我们使用的相同名称的锻炼），则会创建错误。为此添加以下代码：
- en: '[PRE43]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Again, we are using `fakeAsync` to eliminate the challenges we would otherwise
    have with the async behavior associated with the rendering and execution of our
    `remoteValidatorDirective`. Next, we add a spy to track the invocation of the
    `validateWorkoutName` method. We also set the spy to call through to our method
    because in this case, we are expecting it to return false. The spy is being used
    to verify that our method has indeed been invoked. Next, we set `fixture.detectChanges`,
    which triggers a change detection cycle. We then set the value of our input and
    call tick, which will, we hope, trigger the response we are expecting from our
    remote validator. We then grab the form encapsulating our input tag using the
    injector that is available from the child element array of the debug element.
    From there, we extract the form control for our input box. Then we run several
    expectations that confirm that an error has been added both to our control and
    to the form and that both are now in an invalid state. The next test is the mirror
    opposite of this test and checks for a positive:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们使用`fakeAsync`来消除我们在渲染和执行`remoteValidatorDirective`时可能遇到的异步行为挑战。接下来，我们添加一个间谍来跟踪`validateWorkoutName`方法的调用。我们还设置间谍调用我们的方法，因为在这种情况下，我们期望它返回false。该间谍用于验证我们的方法确实已被调用。接下来，我们设置`fixture.detectChanges`，触发变更检测周期。然后我们设置输入的值并调用tick，希望这将触发我们从远程验证器中期望的响应。然后，我们使用从调试元素的子元素数组中可用的注入器来获取封装我们输入标签的表单。从那里，我们提取我们输入框的表单控件。然后我们运行几个期望，确认错误已经被添加到我们的控件和表单，并且两者现在都处于无效状态。下一个测试是这个测试的镜像相反，并检查是否为正：
- en: '[PRE44]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Other than changing the expectations, the only change we are making from the
    previous test is setting up our spy to return a value of true. Unit-testing our
    `remoteValidatorDirective` shows how powerful the `TestBed` utilities are in testing
    our UI and the elements and behaviors associated with it.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更改期望值之外，我们从之前的测试中唯一做出的更改是设置我们的间谍返回一个true值。单元测试我们的`remoteValidatorDirective`展示了`TestBed`实用程序在测试我们的UI以及与之相关的元素和行为方面有多么强大。
- en: Getting started with E2E testing
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始进行E2E测试
- en: Automated **E2E** testing is an invaluable asset if the underlying framework
    supports it. As the size of an app grows, automated E2E testing can save a lot
    of manual effort.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果底层框架支持，自动化**E2E**测试是一项非常宝贵的资产。随着应用程序规模的增长，自动化E2E测试可以节省大量手动工作。
- en: Without automation, it's just a never-ending battle to make sure that the app
    is functional. However, remember that in an E2E setup, not everything can be automated;
    automation may require a lot of effort. With due diligence, we can offload a sizable
    amount of manual effort but not everything.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 没有自动化，确保应用程序功能正常就是一个永无止境的战斗。然而，请记住，在E2E设置中，并非所有事情都可以自动化；自动化可能需要大量的工作。通过尽职调查，我们可以减轻相当多的手动工作，但并非所有工作都可以。
- en: The process of E2E testing of a web-based application is about running the application
    in a real browser and asserting the behavior of the application based on the user
    interface state. This is how an actual user does testing.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序的E2E测试过程涉及在真实浏览器中运行应用程序，并根据用户界面状态断言应用程序的行为。这就是实际用户进行测试的方式。
- en: Browser automation holds the key here, and modern browsers have become smarter
    and more capable in terms of supporting automation. Selenium tools for browser
    automation are the most popular option out there. Selenium has the WebDriver ([https://www.w3.org/TR/webdriver/](https://www.w3.org/TR/webdriver/))
    API that allows us to control the browser through the automation API that modern
    browsers natively support.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器自动化在这里起着关键作用，现代浏览器在支持自动化方面变得更加智能和更有能力。Selenium工具是浏览器自动化的最流行选项。Selenium具有WebDriver
    ([https://www.w3.org/TR/webdriver/](https://www.w3.org/TR/webdriver/)) API，允许我们通过现代浏览器本地支持的自动化API来控制浏览器。
- en: The reason behind bringing up Selenium WebDriver is that the Angular E2E testing
    framework/runner **Protractor** also uses **WebDriverJS**, which is a JavaScript
    binding of WebDriver on Node. These language bindings (like the preceding JavaScript
    binding) allow us to use the automation API in the language of our choice.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 提到Selenium WebDriver的原因是Angular E2E测试框架/运行器**Protractor**也使用**WebDriverJS**，这是Node上WebDriver的JavaScript绑定。这些语言绑定（如前面的JavaScript绑定）允许我们使用我们选择的语言中的自动化API。
- en: Let's discuss Protractor before we start writing some integration tests for
    our app.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始为应用程序编写一些集成测试之前，让我们讨论一下Protractor。
- en: Introducting Protractor
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Protractor
- en: Protractor is the de facto test runner for E2E testing in Angular. Protractor
    uses Selenium WebDriver to control a browser and simulate user actions.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor是Angular中E2E测试的事实上的测试运行器。Protractor使用Selenium WebDriver来控制浏览器并模拟用户操作。
- en: Note
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Protractor supersedes an earlier E2E framework known as **AngularJS Scenario
    Runner**. Karma had a plugin that allowed Karma to execute E2E tests.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor取代了之前的E2E框架**AngularJS Scenario Runner**。Karma有一个插件，允许Karma执行E2E测试。
- en: 'A typical Protractor setup has the following components:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的Protractor设置包括以下组件：
- en: A test runner (Protractor)
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个测试运行器（Protractor）
- en: A Selenium server
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Selenium服务器
- en: A browser
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个浏览器
- en: We write our test in Jasmine and use some objects exposed by Protractors (which
    is a wrapper over WebDriverJS) to control the browser.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Jasmine编写我们的测试，并使用Protractors（它是WebDriverJS的包装器）暴露的一些对象来控制浏览器。
- en: When these tests run, Protractor sends commands to the Selenium server. This
    interaction happens mostly over HTTP.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些测试运行时，Protractor 发送命令到 Selenium 服务器。这种交互主要是通过 HTTP 进行的。
- en: The Selenium server, in turn, communicates with the browser using the *WebDriver
    Wire Protocol*, and internally the browser interprets the action commands using
    the browser driver (such as *ChromeDriver* in the case of Chrome).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium 服务器反过来使用 *WebDriver Wire Protocol* 与浏览器通信，而浏览器在内部使用浏览器驱动程序（例如 Chrome
    的 *ChromeDriver*）来解释操作命令。
- en: It is not that important to understand the technicalities of this communication,
    but we should be aware of the E2E testing setup. Check out the article from the
    Protractor documentation at [http://angular.github.io/protractor/#/infrastructure](http://angular.github.io/protractor/#/infrastructure)
    to learn more about this flow.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这种通信的技术细节并不是那么重要，但我们应该意识到端到端测试的设置。查看 Protractor 文档中的文章 [http://angular.github.io/protractor/#/infrastructure](http://angular.github.io/protractor/#/infrastructure)
    以了解更多关于这个流程的信息。
- en: Another important thing to realize when using Protractor is that the overall
    interaction with the browser or the browser control flow is asynchronous in nature
    and promise-based. Any HTML element action, whether `sendKeys`, `getText`, `click`,
    `submit`, or any other, does not execute at the time of invocation; instead the
    action is queued up in a control flow queue. For this precise reason, the return
    value of every action statement is a promise that gets resolved when the action
    completes.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Protractor 时另一个重要的事情要意识到的是，与浏览器的整体交互或浏览器控制流是异步的，并且基于 promise。任何 HTML 元素操作，无论是
    `sendKeys`、`getText`、`click`、`submit` 还是其他任何操作，在调用时都不会立即执行；相反，该操作会排队在控制流队列中。因此，每个操作语句的返回值都是一个
    promise，在操作完成时得到解析。
- en: 'To handle this *asynchronicity* in Jasmine tests, Protractor patches Jasmine,
    and therefore assertions like these work:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理 Jasmine 测试中的这种 *异步性*，Protractor 对 Jasmine 进行了补丁，因此像这样的断言可以工作：
- en: '[PRE45]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: They work despite the `getText` function returning a promise and not the element
    content.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `getText` 函数返回一个 promise 而不是元素内容，它们仍然可以工作。
- en: Note
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing this book, Protractor supports Jasmine version 2.5.2.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本书时，Protractor 支持 Jasmine 版本 2.5.2。
- en: With this basic understanding of how Protractor works, let's set up Protractor
    for end-to-end testing.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Protractor 的基本理解，让我们为端到端测试设置 Protractor。
- en: Setting up Protractor for E2E testing
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Protractor 进行端到端测试
- en: 'To install Protractor globally, run this command in the console:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 要全局安装 Protractor，请在控制台中运行此命令：
- en: '[PRE46]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This installs two command-line tools: Protractor and webdriver-manager. Run
    the following command to make sure that Protractor is set up correctly:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装两个命令行工具：Protractor 和 webdriver-manager。运行以下命令以确保 Protractor 设置正确：
- en: '[PRE47]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All E2E tests have been verified against Protractor 4.0.9.web.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 所有端到端测试都已针对 Protractor 4.0.9.web 进行验证。
- en: 'webdriver-manager is a helper tool to easily get an instance of a running Selenium
    server. Before we start the Selenium server, we need to update the driver binaries
    with the following call:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: webdriver-manager 是一个辅助工具，可以轻松获取运行中的 Selenium 服务器实例。在启动 Selenium 服务器之前，我们需要使用以下调用更新驱动程序二进制文件。
- en: '[PRE48]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, run this command to start the Selenium server:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行此命令启动 Selenium 服务器：
- en: '[PRE49]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Protractor tests send requests to this server to control a local browser. E2E
    testing can be verified by checking the status of the server at `http://localhost:4444/wd/hub`
    (the default location).
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor 测试向该服务器发送请求以控制本地浏览器。可以通过检查 `http://localhost:4444/wd/hub`（默认位置）的服务器状态来验证端到端测试。
- en: Protractor also needs to be configured, like Karma, and has a configuration
    file. We copy the `protractor.config.js` file from the `tests` folder under `chapter7/
    checkpoint1/` to our local `tests` folder.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor也需要进行配置，就像Karma一样，并且有一个配置文件。我们将`protractor.config.js`文件从`chapter7/
    checkpoint1/`文件夹下的`tests`文件夹复制到我们本地的`tests`文件夹中。
- en: 'The Protractor configuration file we just added contains four settings that
    we want to make sure are configured according to our local app setup, and these
    include the following:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的Protractor配置文件包含四个设置，我们要确保这些设置根据我们本地的应用程序设置进行配置，其中包括以下内容：
- en: '| **Key** | **Description** |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| **关键** | **描述** |'
- en: '| `Specs` | The location of the specification files (the E2E test files). The
    current assigned value `[''e2e/*.js'']` should work. |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| `Specs` | 规范文件的位置（E2E测试文件）。当前分配的值`[''e2e/*.js'']`应该可以工作。'
- en: '| `baseUrl` | The base URL where the app is running. Change the server name
    and port to match your local setup. Navigate to the URL to make sure that the
    app is running. |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| `baseUrl` | 应用程序运行的基本URL。更改服务器名称和端口以匹配您的本地设置。导航到URL以确保应用程序正在运行。 |'
- en: '| `seleniumAddress` | The base URL where the Selenium server is running. Unless
    you have reconfigured the Selenium server settings, the default value should work.
    |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| `seleniumAddress` | Selenium服务器正在运行的基本URL。除非您重新配置了Selenium服务器设置，否则默认值应该可以工作。'
- en: '| `useAllAngular2AppRoots` | Set this to `true`. This lets Protractor know
    that we are no longer using earlier versions of Angular. |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| `useAllAngular2AppRoots` | 将其设置为`true`。这让Protractor知道我们不再使用早期版本的Angular。
    |'
- en: Note
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The configuration file documentation on the Protractor website ([https://github.com/angular/protractor/blob/master/lib/config.ts](https://github.com/angular/protractor/blob/master/lib/config.ts))
    contains details on other supported configurations.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor网站上的配置文件文档（[https://github.com/angular/protractor/blob/master/lib/config.ts](https://github.com/angular/protractor/blob/master/lib/config.ts)）包含其他支持的配置的详细信息。
- en: That is enough to start testing with Protractor.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这就足够开始使用Protractor进行测试了。
- en: TypeScript configuration
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript配置
- en: As with all the other examples in this book, we will be writing our tests in
    TypeScript. This requires a couple more configuration steps.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的所有其他示例一样，我们将使用TypeScript编写我们的测试。这需要进行一些额外的配置步骤。
- en: 'First, copy the `tsconfig.json` file from checkpoint 7.1 into the `trainer`
    folder. You''ll notice that this file now has some additional global dependencies
    for WebDriver and angular-protractor:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将`checkpoint 7.1`中的`tsconfig.json`文件复制到`trainer`文件夹中。您会注意到，这个文件现在具有一些额外的全局依赖项，用于WebDriver和angular-protractor。
- en: '[PRE50]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, from the command line in the `trainer` folder, run the following:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`trainer`文件夹的命令行中运行以下命令：
- en: '[PRE51]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This will install the type definitions for Protractor and web driver that we
    will be using when in our tests.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装我们在测试中将要使用的Protractor和web驱动程序的类型定义。
- en: Now let's begin writing and executing some tests.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始编写和执行一些测试。
- en: Writing E2E tests for the app
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为应用程序编写E2E测试
- en: Let's start in a simple manner and test our app start page (**#/start**). This
    page has some static content, a workout listing section with search capabilities,
    and the ability to start a workout by clicking on any workout tile.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一种简单的方式开始测试我们的应用程序起始页面（**#/start**）。这个页面有一些静态内容，一个带有搜索功能的锻炼列表部分，以及通过点击任何锻炼瓷砖来开始锻炼的能力。
- en: Note
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All our E2E tests will be added to the `e2e` folder under `tests`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的E2E测试将被添加到`tests`文件夹下的`e2e`文件夹中。
- en: Add a new file called `workout-runner.spec.ts` to the `e2e` folder under `tests`.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tests`文件夹下的`e2e`文件夹中添加一个名为`workout-runner.spec.ts`的新文件。
- en: 'At the top of the file add the following reference:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部添加以下引用：
- en: '[PRE52]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This brings in the type definitions we just installed. Next add the following
    code:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这引入了我们刚刚安装的类型定义。接下来添加以下代码：
- en: '[PRE53]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Since we are writing this test in TypeScript, we have to introduce a transpilation
    step here. Therefore, in a new command window, navigate to the to the `e2e` folder
    under `tests` and type the following:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在TypeScript中编写这个测试，我们必须在这里引入一个转译步骤。因此，在一个新的命令窗口中，导航到`tests`下的`e2e`文件夹，并输入以下内容：
- en: '[PRE54]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You should see the following message:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下消息：
- en: '[PRE55]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `-w` switch means that TypeScript will recompile the tests in this file
    as we change them. So we will not need to run this command again.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`-w`开关意味着TypeScript会在我们更改它们时重新编译这个文件中的测试。因此，我们将不需要再次运行这个命令。'
- en: Executing our E2E tests
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行我们的E2E测试
- en: Before we execute our first test, we have to make sure that the Selenium server
    is running (`webdriver-manager start`) and the app is running (run `gulp play`
    from the command line in the `trainer` folder).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行我们的第一个测试之前，我们必须确保Selenium服务器正在运行（`webdriver-manager start`），应用正在运行（在`trainer`文件夹的命令行中运行`gulp
    play`）。
- en: 'Now from the command line in the `trainer` folder, run the following and see
    the browser dance to your tune:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`trainer`文件夹的命令行中运行以下命令，并看到浏览器按照你的指示跳舞：
- en: '[PRE56]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Protractor will open the browser. It will then navigate to the start page; wait
    for the page, the scripts, and the framework to load; and then perform the test.
    It finally logs the results of the test in the console. That is pretty awesome!
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor将打开浏览器。然后它将导航到起始页面；等待页面、脚本和框架加载；然后执行测试。最后在控制台中记录测试的结果。这太棒了！
- en: Let's walk through this simple test.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们走一遍这个简单的测试。
- en: The first interesting piece is inside the `beforeEach` block. The browser object
    is a global object exposed by Protractor and is used to control the browser-level
    actions. Underneath, it is just a wrapper around WebDriver. The `browser.get(`""`)`
    method navigates the browser to start the app page, every time, before the start
    of the test.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个有趣的部分在`beforeEach`块内。浏览器对象是Protractor公开的全局对象，用于控制浏览器级别的操作。在底层，它只是WebDriver的一个包装器。`browser.get(`""`)`方法在测试开始之前每次将浏览器导航到应用页面。
- en: The actual test verifies that the title of the page is correct. It also checks
    whether some random content is present on the page.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的测试验证了页面的标题是否正确。它还检查页面上是否存在一些随机内容。
- en: 'The preceding test employs two new globals, `element` and `by`, that are made
    available by Protractor:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试使用了两个新的全局变量`element`和`by`，这些变量是由Protractor提供的。
- en: '`element`: This function returns an `ElementFinder` object. The primary job
    of `ElementFinder` is to interact with the selected element. We will be using
    the `element` function to select `ElementFinder` extensively in our tests.'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`element`：这个函数返回一个`ElementFinder`对象。`ElementFinder`的主要工作是与选定的元素进行交互。我们将在我们的测试中广泛使用`element`函数来选择`ElementFinder`。'
- en: Note
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Refer to the documentation at [http://www.protractortest.org/#/locators#actions](http://bit.ly/2ekp2VQ)
    to learn more about element manipulation API support. Functions such as `getText()`
    are actually defined on `WebElement` but are always accessed using `ElementFinder`.
    As the documentation suggests, `ElementFinder` can be treated as `WebElement`
    for most purposes. For more information, you can refer to [http://www.protractortest.org/#/locators#behind-the-scenes-elementfinders-versus-webelements](http://bit.ly/2fnOzhC).
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考[http://www.protractortest.org/#/locators#actions](http://bit.ly/2ekp2VQ)上的文档，了解更多关于元素操作API支持的信息。`getText()`等函数实际上是在`WebElement`上定义的，但总是使用`ElementFinder`访问。正如文档所建议的，`ElementFinder`在大多数情况下可以被视为`WebElement`。有关更多信息，您可以参考[http://www.protractortest.org/#/locators#behind-the-scenes-elementfinders-versus-webelements](http://bit.ly/2fnOzhC)。
- en: '`by`: This object is there to locate elements. It has functions that create
    `locators`. In the preceding test, a locator is created to search for elements
    with `id=start`. There are a number of locators that can be used to search for
    a specific element. These include by class, by ID, and by css. (At this time by
    model and by binding are not yet supported.) Refer to the Protractor documentation
    on locators at [http://angular.github.io/protractor/#/locators](http://angular.github.io/protractor/#/locators)
    to learn about the supported locators.'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`by`：这个对象用于定位元素。它有创建`定位器`的函数。在前面的测试中，创建了一个定位器来搜索具有`id=start`的元素。可以使用多种定位器来搜索特定元素。这些包括按类、按ID和按css。
    （目前尚不支持按模型和按绑定。）请参考Protractor定位器文档 [http://angular.github.io/protractor/#/locators](http://angular.github.io/protractor/#/locators)
    了解支持的定位器。'
- en: Note
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Just to reiterate what we discussed earlier, `getTitle()` and `getText()` in
    the preceding test do not return the actual text but a Promise; we can still assert
    on the text value.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调我们之前讨论的，前面测试中的`getTitle()`和`getText()`并不返回实际文本，而是一个Promise；我们仍然可以对文本值进行断言。
- en: This simple test highlights another salient feature of Protractor. It automatically
    detects when the Angular app is loaded and when data is available for testing.
    There are no ugly hacks to delay testing (using `timeouts`) that may otherwise
    be required in standard E2E testing scenarios.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的测试突出了Protractor的另一个显著特点。它会自动检测Angular应用程序何时加载以及何时可以进行测试。在标准的端到端测试场景中，通常需要使用丑陋的延迟测试（使用`timeouts`），而在Protractor中不需要。
- en: Remember, this is an *SPA*; full-page browser refresh does not happen, so it
    is not that simple to determine when the page is loaded and when the data that
    is rendered for AJAX calls is available. Protractor makes it all possible.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这是一个*SPA*；全页浏览器刷新不会发生，因此确定页面何时加载以及渲染用于AJAX调用的数据何时可用并不那么简单。Protractor使所有这些成为可能。
- en: Note
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Protractor may still timeout while trying to assess whether the page is available
    for testing. If you are hitting timeout errors with Protractor, this article from
    the Protractor documentation can be really helpful ([http://www.protractortest.org/#/timeouts](http://www.protractortest.org/#/timeouts))
    for debugging such issues.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor在尝试评估页面是否可用于测试时可能仍会超时。如果您在使用Protractor时遇到超时错误，Protractor文档中的这篇文章可能会非常有帮助（[http://www.protractortest.org/#/timeouts](http://www.protractortest.org/#/timeouts)）来调试此类问题。
- en: Setting up backend data for E2E testing
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为端到端测试设置后端数据
- en: Setting up backend data for E2E testing is a challenge, irrespective of the
    E2E framework we employ for testing. The ultimate aim is to assert the behavior
    of an application against some data, and unless the data is fixed, we cannot verify
    the behavior that involves getting or setting data.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 为端到端测试设置后端数据是一个挑战，无论我们使用什么样的端到端框架进行测试。最终目标是对应用程序的行为进行断言，除非数据是固定的，否则我们无法验证涉及获取或设置数据的行为。
- en: One approach to setting up data for E2E tests is to create a test data store
    specifically for E2E tests with some seed data. Once the E2E tests are over, the
    data store can be reset to its original state for future testing. For *Personal
    Trainer*, we can create a new database in MongoLab dedicated exclusively to E2E
    testing.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 为端到端测试设置数据的一种方法是创建一个专门用于端到端测试的测试数据存储，并附带一些种子数据。一旦端到端测试结束，数据存储可以重置为其原始状态以供将来测试使用。对于*个人教练*，我们可以在MongoLab中创建一个专门用于端到端测试的新数据库。
- en: This may seem a lot of effort, but it is necessary. Who said E2E testing is
    easy! In fact, this challenge is there even if we do manual testing. For a real
    app, we always have to set up data stores/databases for every environment, whether *dev*,
    *test*, or *production*.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很费力，但是这是必要的。谁说端到端测试很容易！事实上，即使我们进行手动测试，这个挑战也存在。对于一个真正的应用程序，我们总是需要为每个环境设置数据存储/数据库，无论是*dev*、*test*还是*production*。
- en: 'In this case, we will continue to use our existing backend but go ahead and
    add another workout that we will use for testing. Name this workout `1minworkout`
    and give it a title of `1 Minute Workout`. Add two exercises to the workout: Jumping
    Jacks and Wall Sit. Set the duration of each exercise to 15 seconds and the rest
    time to 1 second.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将继续使用我们现有的后端，但是继续添加另一个我们将用于测试的锻炼。将此锻炼命名为`1minworkout`，并将其标题设置为`1 Minute
    Workout`。为锻炼添加两个练习：开合跳和靠墙坐。将每个练习的持续时间设置为15秒，休息时间设置为1秒。
- en: Note
  id: totrans-446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have deliberately kept our new workout short so that we can complete our
    end-to-end testing of this workout within the normal timeouts provided by Protractor.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意将新的锻炼设置得很短，以便我们可以在Protractor提供的正常超时时间内完成对这个锻炼的端到端测试。
- en: More E2E tests
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多的端到端测试
- en: Let's get back to testing the workout search features on the start page. With
    the addition of 1 Minute Workout, we now have two workouts and we can assert search
    behaviors against these.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到测试起始页面上的锻炼搜索功能。通过添加1分钟锻炼，我们现在有两个锻炼，我们可以对这些进行搜索行为断言。
- en: Note
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you have added other workouts to the backend, just adjust the numbers in
    this test accordingly.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经向后端添加了其他锻炼，请相应地调整此测试中的数字。
- en: 'Add this test after the existing test in `workout-runner.spec.ts`:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在`workout-runner.spec.ts`中的现有测试之后添加此测试：
- en: '[PRE57]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The test uses `ElementFinder` and `Locator API` to look for elements on the
    page. Check the second line of the test. We are using the `element.all` function
    together with the `by.css` locator to do a multi-element match on all elements
    on the screen that are using the `.workout.tile` CSS class. This gives us a list
    of workouts against which the next line asserts the element count of 3.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 该测试使用`ElementFinder`和`Locator API`来查找页面上的元素。检查测试的第二行。我们使用`element.all`函数与`by.css`定位器一起对屏幕上使用`.workout.tile`
    CSS类的所有元素进行多元素匹配。这给我们提供了一个锻炼列表，下一行对其进行断言，断言元素计数为3。
- en: The test then gets hold of the search input using the `element` function along
    with the `by.css` locator to do a single element match for an element using the
    `.form-contol` CSS class. We then use the `sendKeys` function to simulate data
    entry in the search input.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，测试使用`element`函数和`by.css`定位器获取搜索输入，以便使用`.form-contol` CSS类进行单个元素匹配。然后我们使用`sendKeys`函数模拟在搜索输入中输入数据。
- en: The last two expect operations check for the count of elements in our list,
    which after the search should be 1\. Also, they check whether the correct workout
    is filtered based on a div tag using the `title` CSS class that is a child of
    the element that contains our workout. This last expect statement highlights how
    we can chain element filtering and get hold of child elements in HTML.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个expect操作检查了我们列表中元素的数量，在搜索之后应该是1。此外，它们检查了基于`title` CSS类的div标签过滤出的正确锻炼是否是包含我们锻炼的元素的子元素。这最后一个expect语句突出了我们如何链接元素过滤并获取HTML中的子元素。
- en: 'There is one more test associated with the start page that we should add. It
    tests the navigation from the start page to the workout runner screen. Add this
    code for that test:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 与起始页面相关的另一个测试应该添加。它测试了从起始页面到锻炼运行器屏幕的导航。为此测试添加以下代码：
- en: '[PRE58]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This test uses the `click` function to simulate clicking on a workout tile,
    and then we use the `browser.getCurrentUrl` function to confirm that the navigation
    is correct.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试使用`click`函数来模拟点击一个锻炼块，然后我们使用`browser.getCurrentUrl`函数来确认导航是否正确。
- en: Run the test again (`protractor tests/protractor.conf.js`) and once again observe
    the magic of browser automation as the tests run one after another.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试（`protractor tests/protractor.conf.js`），并再次观察浏览器自动化的魔力，测试一个接一个地运行。
- en: Can we automate E2E testing for *Workout Runner*? Well, we can try.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否自动化*Workout Runner*的E2E测试？好吧，我们可以尝试。
- en: Testing WorkoutRunner
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试WorkoutRunner
- en: One of the major challenges with testing WorkoutRunner is that everything is
    time-dependent. With unit testing, at least we were able to mock the interval,
    but not anymore. Testing exercise transitions and workout completion is definitely
    difficult.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 测试WorkoutRunner的一个主要挑战是一切都取决于时间。在单元测试中，至少我们能够模拟间隔，但现在不行了。测试锻炼转换和锻炼完成肯定是困难的。
- en: 'However, before we tackle this problem or try to find an acceptable workaround,
    let''s digress and learn about an important technique to manage E2E testing: page
    objects!'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们解决这个问题或尝试找到可接受的解决方法之前，让我们偏离一下，学习一个重要的管理E2E测试的技术：页面对象！
- en: Using page objects to manage E2E testing
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用页面对象管理E2E测试
- en: The concept of page objects is simple. We encapsulate the representation of
    page elements into an object so that we do not have to litter our E2E test code
    with `ElementFinder` and `locators`. If any page element moves, we just need to
    fix the page object.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 页面对象的概念很简单。我们将页面元素的表示封装到一个对象中，这样我们就不必在E2E测试代码中使用`ElementFinder`和`locators`。如果任何页面元素移动，我们只需要修复页面对象。
- en: 'Here is how we can represent our Workout Runner page:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何表示我们的Workout Runner页面：
- en: '[PRE59]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This page object now encapsulates many of the elements that we want to test.
    By organizing the element selection code in one place, we increase the readability
    and hence the maintainability of E2E tests.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面对象现在封装了我们想要测试的许多元素。通过将元素选择代码组织在一个地方，我们增加了E2E测试的可读性和可维护性。
- en: 'Now add the Workout Runner page object to the top of the test file. We''ll
    use it in a test for the workout runner. Add the following new describe block
    containing the first of our workout runner tests:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将Workout Runner页面对象添加到测试文件的顶部。我们将在锻炼运行器的测试中使用它。添加以下包含我们的第一个锻炼运行器测试的新描述块：
- en: '[PRE60]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The test verifies that the workout is loaded and the correct data is shown.
    We make full use of the page object that we defined earlier. Run the test and
    verify that it passes.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 测试验证了锻炼是否加载，并显示了正确的数据。我们充分利用了之前定义的页面对象。运行测试并验证其是否通过。
- en: 'Let''s get back to the challenge of testing code based on `interval` or `timeout`.
    First, we''ll add a test that confirms a click event on the screen, when the pause
    button is pushed:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到基于`interval`或`timeout`的代码测试的挑战。首先，我们将添加一个测试，确认在屏幕上点击事件时，暂停按钮被按下：
- en: '[PRE61]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: What is interesting here is that we use the `browser.sleep` function within
    a promise to verify that the exercise time remaining is the same before and after
    the button is clicked. We are again using our `WorkoutRunner` page object to make
    the test more readable and understandable.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们在一个promise中使用`browser.sleep`函数来验证在按钮点击之前和之后，锻炼剩余时间是否相同。我们再次使用我们的`WorkoutRunner`页面对象来使测试更易读和易懂。
- en: 'Next, add the following test to the current test suite:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下测试添加到当前测试套件中：
- en: '[PRE62]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This test checks whether the exercise transition happened. It does so by adding
    a `browser.sleep` function for 15 seconds and then checking from the UI state
    whether the exercise-related content of `Rest` is visible. The problem with this
    test is that it is not very accurate. It can confirm that the transition is happening
    but cannot confirm that it happened at the right time.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试检查了运动过渡是否发生。它通过添加一个`browser.sleep`函数来进行15秒的等待，然后从UI状态检查`Rest`的运动相关内容是否可见。这个测试的问题在于它并不是非常准确。它可以确认过渡正在发生，但无法确认它是否发生在正确的时间。
- en: A plausible explanation for this behavior is in the way Protractor works. Before
    Protractor can start a test, it first waits for the page to load. If the test
    involves any action (such as `getText`), it again waits till Angular synchronizes
    the page. During page synchronization, Angular waits for any pending HTTP requests
    or any timeout-based operations to complete before it starts the test. As a result,
    when the `browser. sleep` function is invoked and when the browser actually goes
    to sleep cannot be predicted with great accuracy.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为的一个合理解释在于Protractor的工作方式。在Protractor开始测试之前，它首先等待页面加载。如果测试涉及任何操作（如`getText`），它会再次等待直到Angular同步页面。在页面同步期间，Angular会等待任何未决的HTTP请求或任何基于超时的操作完成，然后才开始测试。因此，当调用`browser.sleep`函数并且浏览器实际上进入睡眠状态的时间无法准确预测。
- en: Note
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can disable this synchronization behavior by setting `browser. ignoreSynchronization`
    to `true`, but we should avoid this as much as possible. If we set it to `true`,
    the onus is on us to determine when the page content is available for making assertions.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`browser.ignoreSynchronization`设置为`true`来禁用这种同步行为，但我们应尽量避免这样做。如果我们将其设置为`true`，那么我们就需要确定页面内容何时可以用于进行断言。
- en: The bottom line is that the *Workout Runner* app workflow is indeed difficult
    to test. Compared to *Workflow Runner*, other things are far easier to test as
    we saw with the start page testing.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是*Workout Runner*应用程序的工作流确实很难测试。与*Workflow Runner*相比，其他事情要容易得多，就像我们在开始页面测试中看到的那样。
- en: It's time now to wrap up the chapter and summarize our learning.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候结束本章并总结我们的学习了。
- en: Summary
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We do not need to reiterate how important unit- and E2E-testing are for any
    application. The way the Angular framework has been designed makes testing the
    Angular app easy. In this chapter, we covered how to write unit tests and E2E
    tests using libraries and frameworks that target Angular.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要重申单元测试和端到端测试对于任何应用程序有多么重要。Angular框架的设计方式使得测试Angular应用程序变得容易。在本章中，我们介绍了如何使用针对Angular的库和框架编写单元测试和端到端测试。
- en: For unit testing, we used Jasmine to write our tests and Karma to execute them.
    We tested a number of filters, components, services, and directives from *Personal
    Trainer*. In the process, you learned about the challenges and the techniques
    used to effectively test these types.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单元测试，我们使用Jasmine编写测试，并使用Karma执行它们。我们测试了*Personal Trainer*中的许多过滤器、组件、服务和指令。在这个过程中，您了解了有效测试这些类型所使用的挑战和技术。
- en: For E2E testing, the framework of choice was Protractor. We still wrote out
    tests in Jasmine but the test runner this time was Protractor. You learned how
    Protractor automates E2E testing using Selenium WebDriver, as we did some scenario
    testing for the *Start* and *Workout Runner* pages.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 对于端到端测试，我们选择的框架是Protractor。我们仍然使用Jasmine编写测试，但这次的测试运行器是Protractor。您学习了Protractor如何使用Selenium
    WebDriver自动化端到端测试，因为我们对*Start*和*Workout Runner*页面进行了一些场景测试。
- en: If you have reached this point, you are getting closer to becoming a proficient
    Angular developer. The next chapter reinforces this with more practical scenarios
    and implementations built using Angular. We will touch upon important concepts
    in the last chapter of this book; these include multilingual support, authentication
    and authorization, communication patterns, performance optimizations, and a few
    others. You certainly do not want to miss them!
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经到达这一点，你离成为一个熟练的Angular开发者更近了。下一章将通过更多实际场景和使用Angular构建的实现来加强这一点。在本书的最后一章中，我们将涉及一些重要概念；这些包括多语言支持、认证和授权、通信模式、性能优化等等。你肯定不想错过它们！
